{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/example/Example_Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma fold_min_commute:\n  \"fold min xs (min a b) = min a (fold min xs b)\" for a :: \"'a :: linorder\"", "lemma min_list_fold:\n  \"min_list (x # xs) = fold min xs x\" for x :: \"'a :: linorder\"", "lemma induct_list012:\n  \"\\<lbrakk>P []; \\<And>x. P [x]; \\<And>x y zs. P (y # zs) \\<Longrightarrow> P (x # y # zs)\\<rbrakk> \\<Longrightarrow> P xs\"", "lemma min_list_Min: \"xs \\<noteq> [] \\<Longrightarrow> min_list xs = Min (set xs)\"", "lemma Pinf_add_right[simp]:\n  \"\\<infinity> + x = \\<infinity>\""], "translations": [["", "lemma fold_min_commute:\n  \"fold min xs (min a b) = min a (fold min xs b)\" for a :: \"'a :: linorder\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold min xs (min a b) = min a (fold min xs b)", "by (induction xs arbitrary: a; auto; metis min.commute min.assoc)"], ["", "lemma min_list_fold:\n  \"min_list (x # xs) = fold min xs x\" for x :: \"'a :: linorder\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Example_Misc.min_list (x # xs) = fold min xs x", "by (induction xs arbitrary: x; auto simp: fold_min_commute[symmetric]; metis min.commute)"], ["", "(* FIXME mv List *)"], ["", "lemma induct_list012:\n  \"\\<lbrakk>P []; \\<And>x. P [x]; \\<And>x y zs. P (y # zs) \\<Longrightarrow> P (x # y # zs)\\<rbrakk> \\<Longrightarrow> P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P []; \\<And>x. P [x];\n     \\<And>x y zs. P (y # zs) \\<Longrightarrow> P (x # y # zs)\\<rbrakk>\n    \\<Longrightarrow> P xs", "by induction_schema (pat_completeness, lexicographic_order)"], ["", "lemma min_list_Min: \"xs \\<noteq> [] \\<Longrightarrow> min_list xs = Min (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> Example_Misc.min_list xs = Min (set xs)", "by (induction xs rule: induct_list012)(auto)"], ["", "paragraph \\<open>Extended Data Type\\<close>"], ["", "(* TODO: Move to distribution! *)"], ["", "lemma Pinf_add_right[simp]:\n  \"\\<infinity> + x = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> + x = \\<infinity>", "by (cases x; simp)"], ["", "paragraph \\<open>Syntax\\<close>"], ["", "bundle app_syntax begin"], ["", "notation App (infixl \"$\" 999)"], ["", "notation Wrap (\"\\<llangle>_\\<rrangle>\")"], ["", "end"], ["", "(*\nparagraph \\<open>Code Setup\\<close>\n\ndefinition map1\\<^sub>T' where\n  \"map1\\<^sub>T' f xs \\<equiv> \\<langle>rec_list \\<langle>[]\\<rangle> (\\<lambda>x xs a. \\<langle>\\<lambda>y. \\<langle>\\<lambda>ys. \\<langle>y#ys\\<rangle>\\<rangle>\\<rangle> . (f x) . a)\\<rangle> . \\<langle>xs\\<rangle> \"\n\nlemma map1\\<^sub>T_map1\\<^sub>T':\n  \"map1\\<^sub>T = \\<langle>\\<lambda>f. \\<langle>\\<lambda>xs. map1\\<^sub>T' f xs\\<rangle>\\<rangle>\"\n  unfolding map1\\<^sub>T_def map1\\<^sub>T'_def ..\n\nlemmas [code] =\n  mem_defs.checkmem'_def\n\nlemmas [code_unfold] =\n  map\\<^sub>T_def\n  map1\\<^sub>T_map1\\<^sub>T'\n\n\nparagraph \\<open>Simplifying monad expressions\\<close>\n\nlemma app_return_right:\n  \"f . \\<langle>g\\<rangle> = do {f \\<leftarrow> f; f g}\"\n  unfolding fun_app_lifted_def left_identity ..\n\nlemma app_return_left:\n  \"\\<langle>f\\<rangle> . g = g \\<bind> f\"\n  unfolding fun_app_lifted_def left_identity ..\n\nlemma get_return:\n  \"(do {m \\<leftarrow> get; \\<langle>f m\\<rangle>}) = State (\\<lambda> mem. (f mem, mem))\"\n  unfolding get_def bind_def return_def by simp\n\nlemma get_put:\n  \"do {m \\<leftarrow> get; put (f m)} = State (\\<lambda> mem. ((), f mem))\"\n  unfolding get_def put_def bind_def return_def by simp\n\nlemma bind_return_assoc:\n  \"(do {\n       x \\<leftarrow> a;\n       \\<langle>f x\\<rangle>\n     }) \\<bind>\n    b =\n    do {\n      x \\<leftarrow> a;\n      b (f x)\n    }\"\n  by (auto split: prod.split simp add: bind_def return_def)\n\nlemma app_lifted_return_assoc:\n  \"(do {\n       x \\<leftarrow> a;\n       \\<langle>f x\\<rangle>\n     }) .\n    b =\n    do {\n      x \\<leftarrow> a;\n      b \\<bind> f x\n    }\"\n  unfolding fun_app_lifted_def bind_return_assoc ..\n\n(* There could be a simpproc for this pattern *)\nlemma bind_return_assoc2:\n  \"(do {\n       x \\<leftarrow> a;\n       y \\<leftarrow> b;\n       \\<langle>f x y\\<rangle>\n     }) \\<bind>\n    c =\n    do {\n      x \\<leftarrow> a;\n      y \\<leftarrow> b;\n      c (f x y)\n    }\"\n  by (auto split: prod.split simp add: bind_def return_def)\n\nlemma bind_return_assoc3:\n  \"(do {\n       x \\<leftarrow> a;\n       y \\<leftarrow> b;\n       z \\<leftarrow> c;\n       \\<langle>f x y z\\<rangle>\n     }) \\<bind>\n    d =\n    do {\n      x \\<leftarrow> a;\n      y \\<leftarrow> b;\n      z \\<leftarrow> c;\n      d (f x y z)\n    }\"\n  by (auto split: prod.split simp add: bind_def return_def)\n\nlemma if\\<^sub>T_return:\n  \"if\\<^sub>T \\<langle>b\\<rangle> x\\<^sub>T y\\<^sub>T \\<equiv> if b then x\\<^sub>T else y\\<^sub>T\"\n  unfolding if\\<^sub>T_def return_def bind_def by simp\n\n(* Would it be a good idea to just unfold fun_app_lifted? *)\nlemmas monad_unfolds =\n  app_return_right app_return_left Monad.left_identity Monad.right_identity\n  app_lifted_return_assoc bind_return_assoc bind_return_assoc2 bind_return_assoc3\n  get_return get_put\n  map1\\<^sub>T_map1\\<^sub>T'\n  if\\<^sub>T_return\n*)"], ["", "end"]]}