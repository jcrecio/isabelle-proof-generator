{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/heap_monad/State_Heap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma execute_cases:\n  \"case execute f heap of None \\<Rightarrow> False | Some (_, heap) \\<Rightarrow> P heap\"", "lemma execute_cases':\n  \"case execute f heap of Some (_, heap) \\<Rightarrow> P heap\"", "lemma lift_p_None[simp, dest]:\n  False if \"execute f heap = None\"", "lemma lift_p_P:\n  \"case the (execute f heap) of (_, heap) \\<Rightarrow> P heap\"", "lemma lift_p_P':\n  \"P heap'\" if \"the (execute f heap) = (v, heap')\"", "lemma lift_p_P'':\n  \"P heap'\" if \"execute f heap = Some (v, heap')\"", "lemma lift_p_the_Some[simp]:\n  \"execute f heap = Some (v, heap')\" if \"the (execute f heap) = (v, heap')\"", "lemma lift_p_E:\n  obtains v heap' where \"execute f heap = Some (v, heap')\" \"P heap'\"", "lemma checkmem_checkmem':\n  \"checkmem' param (\\<lambda>_. calc) = checkmem param calc\"", "lemma rel_state_elim:\n  assumes \"rel_state R f g\" \"P heap\"\n  obtains heap' v v' where\n    \"State_Monad.run_state f heap = (v, heap')\" \"execute g heap = Some (v', heap')\" \"R v v'\" \"P heap'\"", "lemma rel_state_intro:\n  assumes\n    \"\\<And> heap v heap'. P heap \\<Longrightarrow> State_Monad.run_state f heap = (v, heap')\n      \\<Longrightarrow> \\<exists> v'. R v v' \\<and> execute g heap = Some (v', heap')\"\n    \"\\<And> heap v heap'. P heap \\<Longrightarrow> State_Monad.run_state f heap = (v, heap') \\<Longrightarrow> P heap'\"\n  shows \"rel_state R f g\"", "lemma transfer_bind[transfer_rule]:\n  \"(rel_state R ===> (R ===> rel_state Q) ===> rel_state Q) State_Monad.bind Heap_Monad.bind\"", "lemma transfer_return[transfer_rule]:\n  \"(R ===> rel_state R) State_Monad.return Heap_Monad.return\"", "lemma fun_app_lifted_transfer:\n  \"(rel_state (R ===> rel_state Q) ===> rel_state R ===> rel_state Q)\n      State_Monad_Ext.fun_app_lifted Heap_Monad_Ext.fun_app_lifted\"", "lemma transfer_get[transfer_rule]:\n  \"rel_state (=) State_Monad.get heap_get\"", "lemma rel_state_lookup:\n  \"rel_state (=) (lookup' k) (lookup k)\"", "lemma rel_state_update:\n  \"rel_state (=) (update' k v) (update k v)\"", "lemma transfer_lookup:\n  \"((=) ===> rel_state (=)) lookup' lookup\"", "lemma transfer_update:\n  \"((=) ===> (=) ===> rel_state (=)) update' update\"", "lemma transfer_checkmem:\n  \"((=) ===> rel_state (=) ===> rel_state (=))\n    (state_mem_defs.checkmem lookup' update') checkmem\"", "lemma lookup'_correct:\n  \"state_mem_defs.map_of lookup' (snd (State_Monad.run_state (lookup' k) m)) \\<subseteq>\\<^sub>m (state_mem_defs.map_of lookup' m)\" if \"P m\"", "lemma update'_correct:\n  \"state_mem_defs.map_of lookup' (snd (State_Monad.run_state (update' k v) m)) \\<subseteq>\\<^sub>m state_mem_defs.map_of lookup' m(k \\<mapsto> v)\"\n  if \"P m\"", "lemma lookup'_inv:\n  \"DP_CRelVS.lift_p P (lookup' k)\"", "lemma update'_inv:\n  \"DP_CRelVS.lift_p P (update' k v)\"", "lemma mem_correct_heap: \"mem_correct lookup' update' P\"", "lemma mem_correct_heap_correct:\n  assumes correct: \"mem_correct lookup\\<^sub>s update\\<^sub>s P\"\n    and lookup: \"((=) ===> rel_state (=)) lookup\\<^sub>s lookup\"\n    and update: \"((=) ===> (=) ===> rel_state (=)) update\\<^sub>s update\"\n  shows \"heap_correct P update lookup\""], "translations": [["", "lemma execute_cases:\n  \"case execute f heap of None \\<Rightarrow> False | Some (_, heap) \\<Rightarrow> P heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case execute f heap of None \\<Rightarrow> False\n    | Some (x, heap) \\<Rightarrow> P heap", "using lift P"], ["proof (prove)\nusing this:\n  State_Heap.lift_p P f\n  P heap\n\ngoal (1 subgoal):\n 1. case execute f heap of None \\<Rightarrow> False\n    | Some (x, heap) \\<Rightarrow> P heap", "unfolding lift_p_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<longrightarrow>\n     (case execute f heap of None \\<Rightarrow> False\n      | Some (xa, xb) \\<Rightarrow> P xb)\n  P heap\n\ngoal (1 subgoal):\n 1. case execute f heap of None \\<Rightarrow> False\n    | Some (x, heap) \\<Rightarrow> P heap", "by auto"], ["", "lemma execute_cases':\n  \"case execute f heap of Some (_, heap) \\<Rightarrow> P heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case execute f heap of Some (x, heap) \\<Rightarrow> P heap", "using execute_cases"], ["proof (prove)\nusing this:\n  case execute f heap of None \\<Rightarrow> False\n  | Some (x, heap) \\<Rightarrow> P heap\n\ngoal (1 subgoal):\n 1. case execute f heap of Some (x, heap) \\<Rightarrow> P heap", "by (auto split: option.split)"], ["", "lemma lift_p_None[simp, dest]:\n  False if \"execute f heap = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using that execute_cases"], ["proof (prove)\nusing this:\n  execute f heap = None\n  case execute f heap of None \\<Rightarrow> False\n  | Some (x, heap) \\<Rightarrow> P heap\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["", "lemma lift_p_P:\n  \"case the (execute f heap) of (_, heap) \\<Rightarrow> P heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case the (execute f heap) of (x, heap) \\<Rightarrow> P heap", "using execute_cases"], ["proof (prove)\nusing this:\n  case execute f heap of None \\<Rightarrow> False\n  | Some (x, heap) \\<Rightarrow> P heap\n\ngoal (1 subgoal):\n 1. case the (execute f heap) of (x, heap) \\<Rightarrow> P heap", "by (auto split: option.split_asm)"], ["", "lemma lift_p_P':\n  \"P heap'\" if \"the (execute f heap) = (v, heap')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P heap'", "using that lift_p_P"], ["proof (prove)\nusing this:\n  the (execute f heap) = (v, heap')\n  case the (execute f heap) of (x, heap) \\<Rightarrow> P heap\n\ngoal (1 subgoal):\n 1. P heap'", "by auto"], ["", "lemma lift_p_P'':\n  \"P heap'\" if \"execute f heap = Some (v, heap')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P heap'", "using that lift_p_P"], ["proof (prove)\nusing this:\n  execute f heap = Some (v, heap')\n  case the (execute f heap) of (x, heap) \\<Rightarrow> P heap\n\ngoal (1 subgoal):\n 1. P heap'", "by auto"], ["", "lemma lift_p_the_Some[simp]:\n  \"execute f heap = Some (v, heap')\" if \"the (execute f heap) = (v, heap')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute f heap = Some (v, heap')", "using that execute_cases"], ["proof (prove)\nusing this:\n  the (execute f heap) = (v, heap')\n  case execute f heap of None \\<Rightarrow> False\n  | Some (x, heap) \\<Rightarrow> P heap\n\ngoal (1 subgoal):\n 1. execute f heap = Some (v, heap')", "by (auto split: option.split_asm)"], ["", "lemma lift_p_E:\n  obtains v heap' where \"execute f heap = Some (v, heap')\" \"P heap'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v heap'.\n        \\<lbrakk>execute f heap = Some (v, heap'); P heap'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using execute_cases"], ["proof (prove)\nusing this:\n  case execute f heap of None \\<Rightarrow> False\n  | Some (x, heap) \\<Rightarrow> P heap\n\ngoal (1 subgoal):\n 1. (\\<And>v heap'.\n        \\<lbrakk>execute f heap = Some (v, heap'); P heap'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"execute f heap\") auto"], ["", "end"], ["", "definition \"state_of s \\<equiv> State (\\<lambda> heap. the (execute s heap))\""], ["", "locale heap_mem_defs =\n  fixes P :: \"heap \\<Rightarrow> bool\"\n    and lookup :: \"'k \\<Rightarrow> 'v option Heap\"\n    and update :: \"'k \\<Rightarrow> 'v \\<Rightarrow> unit Heap\"\nbegin"], ["", "definition rel_state :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> (heap, 'a) state \\<Rightarrow> 'b Heap \\<Rightarrow> bool\" where\n  \"rel_state R f g \\<equiv>\n    \\<forall> heap. P heap \\<longrightarrow>\n      (case State_Monad.run_state f heap of (v1, heap1) \\<Rightarrow> case execute g heap of\n        Some (v2, heap2) \\<Rightarrow> R v1 v2 \\<and> heap1 = heap2 \\<and> P heap2 | None \\<Rightarrow> False)\""], ["", "definition \"lookup' k \\<equiv> State (\\<lambda> heap. the (execute (lookup k) heap))\""], ["", "definition \"update' k v \\<equiv> State (\\<lambda> heap. the (execute (update k v) heap))\""], ["", "definition \"heap_get = Heap_Monad.Heap (\\<lambda> heap. Some (heap, heap))\""], ["", "definition checkmem :: \"'k \\<Rightarrow> 'v Heap \\<Rightarrow> 'v Heap\" where\n  \"checkmem param calc \\<equiv>\n    Heap_Monad.bind (lookup param) (\\<lambda> x.\n    case x of\n      Some x \\<Rightarrow> return x\n    | None \\<Rightarrow> Heap_Monad.bind calc (\\<lambda> x.\n        Heap_Monad.bind (update param x) (\\<lambda> _.\n        return x\n      )\n    )\n  )\n  \""], ["", "definition checkmem' :: \"'k \\<Rightarrow> (unit \\<Rightarrow> 'v Heap) \\<Rightarrow> 'v Heap\" where\n  \"checkmem' param calc \\<equiv>\n    Heap_Monad.bind (lookup param) (\\<lambda> x.\n    case x of\n      Some x \\<Rightarrow> return x\n    | None \\<Rightarrow> Heap_Monad.bind (calc ()) (\\<lambda> x.\n        Heap_Monad.bind (update param x) (\\<lambda> _.\n        return x\n      )\n    )\n  )\n  \""], ["", "lemma checkmem_checkmem':\n  \"checkmem' param (\\<lambda>_. calc) = checkmem param calc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checkmem' param (\\<lambda>_. calc) = checkmem param calc", "unfolding checkmem'_def checkmem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup param \\<bind>\n    (\\<lambda>x.\n        case x of\n        None \\<Rightarrow>\n          calc \\<bind>\n          (\\<lambda>x. update param x \\<bind> (\\<lambda>_. return x))\n        | Some x \\<Rightarrow> return x) =\n    lookup param \\<bind>\n    (\\<lambda>x.\n        case x of\n        None \\<Rightarrow>\n          calc \\<bind>\n          (\\<lambda>x. update param x \\<bind> (\\<lambda>_. return x))\n        | Some x \\<Rightarrow> return x)", ".."], ["", "definition map_of_heap where\n  \"map_of_heap heap k = fst (the (execute (lookup k) heap))\""], ["", "lemma rel_state_elim:\n  assumes \"rel_state R f g\" \"P heap\"\n  obtains heap' v v' where\n    \"State_Monad.run_state f heap = (v, heap')\" \"execute g heap = Some (v', heap')\" \"R v v'\" \"P heap'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v heap' v'.\n        \\<lbrakk>run_state f heap = (v, heap');\n         execute g heap = Some (v', heap'); R v v'; P heap'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v heap' v'.\n       run_state f heap = (v, heap') \\<and>\n       execute g heap = Some (v', heap') \\<and> R v v' \\<and> P heap'", "using assms"], ["proof (prove)\nusing this:\n  local.rel_state R f g\n  P heap\n\ngoal (1 subgoal):\n 1. \\<exists>v heap' v'.\n       run_state f heap = (v, heap') \\<and>\n       execute g heap = Some (v', heap') \\<and> R v v' \\<and> P heap'", "unfolding rel_state_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<longrightarrow>\n     (case run_state f heap of\n      (v1, heap1) \\<Rightarrow>\n        case execute g heap of None \\<Rightarrow> False\n        | Some (v2, heap2) \\<Rightarrow>\n            R v1 v2 \\<and> heap1 = heap2 \\<and> P heap2)\n  P heap\n\ngoal (1 subgoal):\n 1. \\<exists>v heap' v'.\n       run_state f heap = (v, heap') \\<and>\n       execute g heap = Some (v', heap') \\<and> R v v' \\<and> P heap'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>heap.\n                P heap \\<longrightarrow>\n                (case run_state f heap of\n                 (v1, heap1) \\<Rightarrow>\n                   case execute g heap of None \\<Rightarrow> False\n                   | Some (v2, heap2) \\<Rightarrow>\n                       R v1 v2 \\<and> heap1 = heap2 \\<and> P heap2);\n     P heap\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v heap'.\n                         run_state f heap = (v, heap') \\<and>\n                         (\\<exists>v'.\n                             execute g heap = Some (v', heap') \\<and>\n                             R v v' \\<and> P heap')", "apply (cases \"State_Monad.run_state f heap\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>heap.\n                   P heap \\<longrightarrow>\n                   (case run_state f heap of\n                    (v1, heap1) \\<Rightarrow>\n                      case execute g heap of None \\<Rightarrow> False\n                      | Some (v2, heap2) \\<Rightarrow>\n                          R v1 v2 \\<and> heap1 = heap2 \\<and> P heap2);\n        P heap; run_state f heap = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v heap'.\n                            run_state f heap = (v, heap') \\<and>\n                            (\\<exists>v'.\n                                execute g heap = Some (v', heap') \\<and>\n                                R v v' \\<and> P heap')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>heap.\n                   P heap \\<longrightarrow>\n                   (case run_state f heap of\n                    (v1, heap1) \\<Rightarrow>\n                      case execute g heap of None \\<Rightarrow> False\n                      | Some (v2, heap2) \\<Rightarrow>\n                          R v1 v2 \\<and> heap1 = heap2 \\<and> P heap2);\n        P heap; run_state f heap = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'.\n                            execute g heap = Some (v', b) \\<and>\n                            R a v' \\<and> P b", "apply (auto split: option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_state_intro:\n  assumes\n    \"\\<And> heap v heap'. P heap \\<Longrightarrow> State_Monad.run_state f heap = (v, heap')\n      \\<Longrightarrow> \\<exists> v'. R v v' \\<and> execute g heap = Some (v', heap')\"\n    \"\\<And> heap v heap'. P heap \\<Longrightarrow> State_Monad.run_state f heap = (v, heap') \\<Longrightarrow> P heap'\"\n  shows \"rel_state R f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_state R f g", "unfolding rel_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       P heap \\<longrightarrow>\n       (case run_state f heap of\n        (v1, heap1) \\<Rightarrow>\n          case execute g heap of None \\<Rightarrow> False\n          | Some (v2, heap2) \\<Rightarrow>\n              R v1 v2 \\<and> heap1 = heap2 \\<and> P heap2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>heap v1 heap1.\n       \\<lbrakk>P heap; run_state f heap = (v1, heap1)\\<rbrakk>\n       \\<Longrightarrow> case execute g heap of None \\<Rightarrow> False\n                         | Some (v2, heap2) \\<Rightarrow>\n                             R v1 v2 \\<and> heap1 = heap2 \\<and> P heap2", "apply (frule assms(1)[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>heap v1 heap1.\n       \\<lbrakk>P heap; run_state f heap = (v1, heap1)\\<rbrakk>\n       \\<Longrightarrow> P heap\n 2. \\<And>heap v1 heap1.\n       \\<lbrakk>P heap; run_state f heap = (v1, heap1);\n        \\<exists>v'.\n           R v1 v' \\<and> execute g heap = Some (v', heap1)\\<rbrakk>\n       \\<Longrightarrow> case execute g heap of None \\<Rightarrow> False\n                         | Some (v2, heap2) \\<Rightarrow>\n                             R v1 v2 \\<and> heap1 = heap2 \\<and> P heap2", "apply (auto intro: assms(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context\n  includes lifting_syntax state_monad_syntax\nbegin"], ["", "lemma transfer_bind[transfer_rule]:\n  \"(rel_state R ===> (R ===> rel_state Q) ===> rel_state Q) State_Monad.bind Heap_Monad.bind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.rel_state R ===>\n     (R ===> local.rel_state Q) ===> local.rel_state Q)\n     (\\<bind>) (\\<bind>)", "unfolding rel_fun_def State_Monad.bind_def Heap_Monad.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       local.rel_state R x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<forall>x y.\n               R x y \\<longrightarrow>\n               local.rel_state Q (xa x) (ya y)) \\<longrightarrow>\n           local.rel_state Q\n            (State\n              (\\<lambda>s.\n                  case run_state x s of\n                  (a, x) \\<Rightarrow> run_state (xa a) x))\n            (Heap.Heap\n              (\\<lambda>h.\n                  case execute y h of None \\<Rightarrow> None\n                  | Some (xa, xb) \\<Rightarrow> execute (ya xa) xb)))", "by (force elim!: rel_state_elim intro!: rel_state_intro)"], ["", "lemma transfer_return[transfer_rule]:\n  \"(R ===> rel_state R) State_Monad.return Heap_Monad.return\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> local.rel_state R) State_Monad.return return", "unfolding rel_fun_def State_Monad.return_def Heap_Monad.return_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       R x y \\<longrightarrow>\n       local.rel_state R (State (Pair x)) (Heap_Monad.heap (Pair y))", "by (fastforce intro: rel_state_intro elim: rel_state_elim simp: execute_heap)"], ["", "lemma fun_app_lifted_transfer:\n  \"(rel_state (R ===> rel_state Q) ===> rel_state R ===> rel_state Q)\n      State_Monad_Ext.fun_app_lifted Heap_Monad_Ext.fun_app_lifted\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.rel_state (R ===> local.rel_state Q) ===>\n     local.rel_state R ===> local.rel_state Q)\n     (.) Heap_Monad_Ext.fun_app_lifted", "unfolding State_Monad_Ext.fun_app_lifted_def Heap_Monad_Ext.fun_app_lifted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.rel_state (R ===> local.rel_state Q) ===>\n     local.rel_state R ===> local.rel_state Q)\n     (\\<lambda>f\\<^sub>T x\\<^sub>T. f\\<^sub>T \\<bind> (\\<bind>) x\\<^sub>T)\n     (\\<lambda>f\\<^sub>T x\\<^sub>T. f\\<^sub>T \\<bind> (\\<bind>) x\\<^sub>T)", "by transfer_prover"], ["", "lemma transfer_get[transfer_rule]:\n  \"rel_state (=) State_Monad.get heap_get\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_state (=) State_Monad.get heap_get", "unfolding State_Monad.get_def heap_get_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_state (=) (State (\\<lambda>s. (s, s)))\n     (Heap.Heap (\\<lambda>heap. Some (heap, heap)))", "by (auto intro: rel_state_intro)"], ["", "end"], ["", "(* Lifting Syntax *)"], ["", "end"], ["", "(* Heap Mem Defs *)"], ["", "locale heap_inv = heap_mem_defs _ lookup for lookup :: \"'k \\<Rightarrow> 'v option Heap\"  +\n  assumes lookup_inv: \"lift_p P (lookup k)\"\n  assumes update_inv: \"lift_p P (update k v)\"\nbegin"], ["", "lemma rel_state_lookup:\n  \"rel_state (=) (lookup' k) (lookup k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_state (=) (lookup' k) (lookup k)", "unfolding rel_state_def lookup'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       P heap \\<longrightarrow>\n       (case run_state\n              (State (\\<lambda>heap. the (execute (lookup k) heap))) heap of\n        (v1, heap1) \\<Rightarrow>\n          case execute (lookup k) heap of None \\<Rightarrow> False\n          | Some (v2, heap2) \\<Rightarrow>\n              v1 = v2 \\<and> heap1 = heap2 \\<and> P heap2)", "using lookup_inv[of k]"], ["proof (prove)\nusing this:\n  State_Heap.lift_p P (lookup k)\n\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       P heap \\<longrightarrow>\n       (case run_state\n              (State (\\<lambda>heap. the (execute (lookup k) heap))) heap of\n        (v1, heap1) \\<Rightarrow>\n          case execute (lookup k) heap of None \\<Rightarrow> False\n          | Some (v2, heap2) \\<Rightarrow>\n              v1 = v2 \\<and> heap1 = heap2 \\<and> P heap2)", "by (auto intro: lift_p_P')"], ["", "lemma rel_state_update:\n  \"rel_state (=) (update' k v) (update k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_state (=) (update' k v) (update k v)", "unfolding rel_state_def update'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       P heap \\<longrightarrow>\n       (case run_state\n              (State (\\<lambda>heap. the (execute (update k v) heap)))\n              heap of\n        (v1, heap1) \\<Rightarrow>\n          case execute (update k v) heap of None \\<Rightarrow> False\n          | Some (v2, heap2) \\<Rightarrow>\n              v1 = v2 \\<and> heap1 = heap2 \\<and> P heap2)", "using update_inv[of k v]"], ["proof (prove)\nusing this:\n  State_Heap.lift_p P (update k v)\n\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       P heap \\<longrightarrow>\n       (case run_state\n              (State (\\<lambda>heap. the (execute (update k v) heap)))\n              heap of\n        (v1, heap1) \\<Rightarrow>\n          case execute (update k v) heap of None \\<Rightarrow> False\n          | Some (v2, heap2) \\<Rightarrow>\n              v1 = v2 \\<and> heap1 = heap2 \\<and> P heap2)", "by (auto intro: lift_p_P')"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma transfer_lookup:\n  \"((=) ===> rel_state (=)) lookup' lookup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (=)) lookup' lookup", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = y \\<longrightarrow> local.rel_state (=) (lookup' x) (lookup y)", "by (auto intro: rel_state_lookup)"], ["", "lemma transfer_update:\n  \"((=) ===> (=) ===> rel_state (=)) update' update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> local.rel_state (=)) update' update", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = ya \\<longrightarrow>\n           local.rel_state (=) (update' x xa) (update y ya))", "by (auto intro: rel_state_update)"], ["", "lemma transfer_checkmem:\n  \"((=) ===> rel_state (=) ===> rel_state (=))\n    (state_mem_defs.checkmem lookup' update') checkmem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (=) ===> local.rel_state (=))\n     (state_mem_defs.checkmem lookup' update') checkmem", "supply [transfer_rule] = transfer_lookup transfer_update"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (=) ===> local.rel_state (=))\n     (state_mem_defs.checkmem lookup' update') checkmem", "unfolding state_mem_defs.checkmem_def checkmem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (=) ===> local.rel_state (=))\n     (\\<lambda>param calc.\n         lookup' param \\<bind>\n         case_option\n          (calc \\<bind>\n           (\\<lambda>x.\n               update' param x \\<bind> (\\<lambda>_. State_Monad.return x)))\n          State_Monad.return)\n     (\\<lambda>param calc.\n         lookup param \\<bind>\n         (\\<lambda>x.\n             case x of\n             None \\<Rightarrow>\n               calc \\<bind>\n               (\\<lambda>x. update param x \\<bind> (\\<lambda>_. return x))\n             | Some x \\<Rightarrow> return x))", "by transfer_prover"], ["", "end"], ["", "(* Lifting Syntax *)"], ["", "end"], ["", "(* Heap Invariant *)"], ["", "locale heap_correct =\n  heap_inv +\n  assumes lookup_correct:\n      \"P m \\<Longrightarrow> map_of_heap (snd (the (execute (lookup k) m))) \\<subseteq>\\<^sub>m (map_of_heap m)\"\n  and update_correct:\n      \"P m \\<Longrightarrow> map_of_heap (snd (the (execute (update k v) m))) \\<subseteq>\\<^sub>m (map_of_heap m)(k \\<mapsto> v)\"\nbegin"], ["", "lemma lookup'_correct:\n  \"state_mem_defs.map_of lookup' (snd (State_Monad.run_state (lookup' k) m)) \\<subseteq>\\<^sub>m (state_mem_defs.map_of lookup' m)\" if \"P m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_mem_defs.map_of lookup'\n     (snd (run_state (lookup' k) m)) \\<subseteq>\\<^sub>m\n    state_mem_defs.map_of lookup' m", "using \\<open>P m\\<close>"], ["proof (prove)\nusing this:\n  P m\n\ngoal (1 subgoal):\n 1. state_mem_defs.map_of lookup'\n     (snd (run_state (lookup' k) m)) \\<subseteq>\\<^sub>m\n    state_mem_defs.map_of lookup' m", "unfolding state_mem_defs.map_of_def map_le_def lookup'_def"], ["proof (prove)\nusing this:\n  P m\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom (\\<lambda>ka.\n                           fst (run_state\n                                 (State\n                                   (\\<lambda>heap.\n the (execute (lookup ka) heap)))\n                                 (snd (run_state\n  (State (\\<lambda>heap. the (execute (lookup k) heap))) m)))).\n       fst (run_state (State (\\<lambda>heap. the (execute (lookup a) heap)))\n             (snd (run_state\n                    (State (\\<lambda>heap. the (execute (lookup k) heap)))\n                    m))) =\n       fst (run_state (State (\\<lambda>heap. the (execute (lookup a) heap)))\n             m)", "by simp (metis (mono_tags, lifting) domIff lookup_correct map_le_def map_of_heap_def)"], ["", "lemma update'_correct:\n  \"state_mem_defs.map_of lookup' (snd (State_Monad.run_state (update' k v) m)) \\<subseteq>\\<^sub>m state_mem_defs.map_of lookup' m(k \\<mapsto> v)\"\n  if \"P m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_mem_defs.map_of lookup'\n     (snd (run_state (update' k v) m)) \\<subseteq>\\<^sub>m\n    state_mem_defs.map_of lookup' m(k \\<mapsto> v)", "unfolding state_mem_defs.map_of_def map_le_def lookup'_def update'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom (\\<lambda>ka.\n                           fst (run_state\n                                 (State\n                                   (\\<lambda>heap.\n the (execute (lookup ka) heap)))\n                                 (snd (run_state\n  (State (\\<lambda>heap. the (execute (update k v) heap))) m)))).\n       fst (run_state (State (\\<lambda>heap. the (execute (lookup a) heap)))\n             (snd (run_state\n                    (State (\\<lambda>heap. the (execute (update k v) heap)))\n                    m))) =\n       ((\\<lambda>k.\n            fst (run_state\n                  (State (\\<lambda>heap. the (execute (lookup k) heap))) m))\n        (k \\<mapsto> v))\n        a", "using update_correct[of m k v] that"], ["proof (prove)\nusing this:\n  P m \\<Longrightarrow>\n  map_of_heap (snd (the (execute (update k v) m))) \\<subseteq>\\<^sub>m\n  map_of_heap m(k \\<mapsto> v)\n  P m\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom (\\<lambda>ka.\n                           fst (run_state\n                                 (State\n                                   (\\<lambda>heap.\n the (execute (lookup ka) heap)))\n                                 (snd (run_state\n  (State (\\<lambda>heap. the (execute (update k v) heap))) m)))).\n       fst (run_state (State (\\<lambda>heap. the (execute (lookup a) heap)))\n             (snd (run_state\n                    (State (\\<lambda>heap. the (execute (update k v) heap)))\n                    m))) =\n       ((\\<lambda>k.\n            fst (run_state\n                  (State (\\<lambda>heap. the (execute (lookup k) heap))) m))\n        (k \\<mapsto> v))\n        a", "by (auto split: if_split_asm simp: map_le_def map_of_heap_def)"], ["", "lemma lookup'_inv:\n  \"DP_CRelVS.lift_p P (lookup' k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p P (lookup' k)", "unfolding DP_CRelVS.lift_p_def lookup'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       P heap \\<longrightarrow>\n       (case run_state\n              (State (\\<lambda>heap. the (execute (lookup k) heap))) heap of\n        (x, xa) \\<Rightarrow> P xa)", "by (auto elim: lift_p_P'[OF lookup_inv])"], ["", "lemma update'_inv:\n  \"DP_CRelVS.lift_p P (update' k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p P (update' k v)", "unfolding DP_CRelVS.lift_p_def update'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       P heap \\<longrightarrow>\n       (case run_state\n              (State (\\<lambda>heap. the (execute (update k v) heap)))\n              heap of\n        (x, xa) \\<Rightarrow> P xa)", "by (auto elim: lift_p_P'[OF update_inv])"], ["", "lemma mem_correct_heap: \"mem_correct lookup' update' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct lookup' update' P", "by (intro mem_correct.intro lookup'_correct update'_correct lookup'_inv update'_inv)"], ["", "end"], ["", "(* Heap correct *)"], ["", "context heap_mem_defs\nbegin"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma mem_correct_heap_correct:\n  assumes correct: \"mem_correct lookup\\<^sub>s update\\<^sub>s P\"\n    and lookup: \"((=) ===> rel_state (=)) lookup\\<^sub>s lookup\"\n    and update: \"((=) ===> (=) ===> rel_state (=)) update\\<^sub>s update\"\n  shows \"heap_correct P update lookup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_correct P update lookup", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. heap_correct P update lookup", "interpret mem: mem_correct lookup\\<^sub>s update\\<^sub>s P"], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct lookup\\<^sub>s update\\<^sub>s P", "by (rule correct)"], ["proof (state)\ngoal (1 subgoal):\n 1. heap_correct P update lookup", "have [simp]: \"the (execute (lookup k) m) = run_state (lookup\\<^sub>s k) m\" if \"P m\" for k m"], ["proof (prove)\ngoal (1 subgoal):\n 1. the (execute (lookup k) m) = run_state (lookup\\<^sub>s k) m", "using lookup[THEN rel_funD, OF HOL.refl, of k] \\<open>P m\\<close>"], ["proof (prove)\nusing this:\n  local.rel_state (=) (lookup\\<^sub>s k) (lookup k)\n  P m\n\ngoal (1 subgoal):\n 1. the (execute (lookup k) m) = run_state (lookup\\<^sub>s k) m", "by (auto elim: rel_state_elim)"], ["proof (state)\nthis:\n  P ?m1 \\<Longrightarrow>\n  the (execute (lookup ?k1) ?m1) = run_state (lookup\\<^sub>s ?k1) ?m1\n\ngoal (1 subgoal):\n 1. heap_correct P update lookup", "have [simp]: \"the (execute (update k v) m) = run_state (update\\<^sub>s k v) m\" if \"P m\" for k v m"], ["proof (prove)\ngoal (1 subgoal):\n 1. the (execute (update k v) m) = run_state (update\\<^sub>s k v) m", "using update[THEN rel_funD, THEN rel_funD, OF HOL.refl HOL.refl, of k v] \\<open>P m\\<close>"], ["proof (prove)\nusing this:\n  local.rel_state (=) (update\\<^sub>s k v) (update k v)\n  P m\n\ngoal (1 subgoal):\n 1. the (execute (update k v) m) = run_state (update\\<^sub>s k v) m", "by (auto elim: rel_state_elim)"], ["proof (state)\nthis:\n  P ?m1 \\<Longrightarrow>\n  the (execute (update ?k1 ?v1) ?m1) =\n  run_state (update\\<^sub>s ?k1 ?v1) ?m1\n\ngoal (1 subgoal):\n 1. heap_correct P update lookup", "have [simp]: \"map_of_heap m = mem.map_of m\" if \"P m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_heap m = mem.map_of m", "unfolding map_of_heap_def mem.map_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. fst (the (execute (lookup k) m))) =\n    (\\<lambda>k. fst (run_state (lookup\\<^sub>s k) m))", "using \\<open>P m\\<close>"], ["proof (prove)\nusing this:\n  P m\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. fst (the (execute (lookup k) m))) =\n    (\\<lambda>k. fst (run_state (lookup\\<^sub>s k) m))", "by simp"], ["proof (state)\nthis:\n  P ?m1 \\<Longrightarrow> map_of_heap ?m1 = mem.map_of ?m1\n\ngoal (1 subgoal):\n 1. heap_correct P update lookup", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_correct P update lookup", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k. State_Heap.lift_p P (lookup k)\n 2. \\<And>k v. State_Heap.lift_p P (update k v)\n 3. \\<And>m k.\n       P m \\<Longrightarrow>\n       map_of_heap (snd (the (execute (lookup k) m))) \\<subseteq>\\<^sub>m\n       map_of_heap m\n 4. \\<And>m k v.\n       P m \\<Longrightarrow>\n       map_of_heap (snd (the (execute (update k v) m))) \\<subseteq>\\<^sub>m\n       map_of_heap m(k \\<mapsto> v)", "subgoal for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Heap.lift_p P (lookup k)", "using mem.lookup_inv[of k] lookup[THEN rel_funD, OF HOL.refl, of k]"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p P (lookup\\<^sub>s k)\n  local.rel_state (=) (lookup\\<^sub>s k) (lookup k)\n\ngoal (1 subgoal):\n 1. State_Heap.lift_p P (lookup k)", "unfolding lift_p_def DP_CRelVS.lift_p_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<longrightarrow>\n     (case run_state (lookup\\<^sub>s k) heap of (x, xa) \\<Rightarrow> P xa)\n  local.rel_state (=) (lookup\\<^sub>s k) (lookup k)\n\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       P heap \\<longrightarrow>\n       (case execute (lookup k) heap of None \\<Rightarrow> False\n        | Some (xa, xb) \\<Rightarrow> P xb)", "by (auto split: option.splits elim: rel_state_elim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k v. State_Heap.lift_p P (update k v)\n 2. \\<And>m k.\n       P m \\<Longrightarrow>\n       map_of_heap (snd (the (execute (lookup k) m))) \\<subseteq>\\<^sub>m\n       map_of_heap m\n 3. \\<And>m k v.\n       P m \\<Longrightarrow>\n       map_of_heap (snd (the (execute (update k v) m))) \\<subseteq>\\<^sub>m\n       map_of_heap m(k \\<mapsto> v)", "subgoal for k v"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Heap.lift_p P (update k v)", "using mem.update_inv[of k] update[THEN rel_funD, THEN rel_funD, OF HOL.refl HOL.refl, of k v]"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p P (update\\<^sub>s k ?v)\n  local.rel_state (=) (update\\<^sub>s k v) (update k v)\n\ngoal (1 subgoal):\n 1. State_Heap.lift_p P (update k v)", "unfolding lift_p_def DP_CRelVS.lift_p_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<longrightarrow>\n     (case run_state (update\\<^sub>s k ?v) heap of\n      (x, xa) \\<Rightarrow> P xa)\n  local.rel_state (=) (update\\<^sub>s k v) (update k v)\n\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       P heap \\<longrightarrow>\n       (case execute (update k v) heap of None \\<Rightarrow> False\n        | Some (xa, xb) \\<Rightarrow> P xb)", "by (auto split: option.splits elim: rel_state_elim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k.\n       P m \\<Longrightarrow>\n       map_of_heap (snd (the (execute (lookup k) m))) \\<subseteq>\\<^sub>m\n       map_of_heap m\n 2. \\<And>m k v.\n       P m \\<Longrightarrow>\n       map_of_heap (snd (the (execute (update k v) m))) \\<subseteq>\\<^sub>m\n       map_of_heap m(k \\<mapsto> v)", "subgoal premises prems for m k"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_heap (snd (the (execute (lookup k) m))) \\<subseteq>\\<^sub>m\n    map_of_heap m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of_heap (snd (the (execute (lookup k) m))) \\<subseteq>\\<^sub>m\n    map_of_heap m", "have \"P (snd (run_state (lookup\\<^sub>s k) m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (snd (run_state (lookup\\<^sub>s k) m))", "by (meson DP_CRelVS.lift_p_P mem.lookup_inv prems prod.exhaust_sel)"], ["proof (state)\nthis:\n  P (snd (run_state (lookup\\<^sub>s k) m))\n\ngoal (1 subgoal):\n 1. map_of_heap (snd (the (execute (lookup k) m))) \\<subseteq>\\<^sub>m\n    map_of_heap m", "with mem.lookup_correct[OF \\<open>P m\\<close>, of k] \\<open>P m\\<close>"], ["proof (chain)\npicking this:\n  mem.map_of (snd (run_state (lookup\\<^sub>s k) m)) \\<subseteq>\\<^sub>m\n  mem.map_of m\n  P m\n  P (snd (run_state (lookup\\<^sub>s k) m))", "show ?thesis"], ["proof (prove)\nusing this:\n  mem.map_of (snd (run_state (lookup\\<^sub>s k) m)) \\<subseteq>\\<^sub>m\n  mem.map_of m\n  P m\n  P (snd (run_state (lookup\\<^sub>s k) m))\n\ngoal (1 subgoal):\n 1. map_of_heap (snd (the (execute (lookup k) m))) \\<subseteq>\\<^sub>m\n    map_of_heap m", "by (simp add: prems)"], ["proof (state)\nthis:\n  map_of_heap (snd (the (execute (lookup k) m))) \\<subseteq>\\<^sub>m\n  map_of_heap m\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       P m \\<Longrightarrow>\n       map_of_heap (snd (the (execute (update k v) m))) \\<subseteq>\\<^sub>m\n       map_of_heap m(k \\<mapsto> v)", "subgoal premises prems for m k v"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_heap (snd (the (execute (update k v) m))) \\<subseteq>\\<^sub>m\n    map_of_heap m(k \\<mapsto> v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of_heap (snd (the (execute (update k v) m))) \\<subseteq>\\<^sub>m\n    map_of_heap m(k \\<mapsto> v)", "have \"P (snd (run_state (update\\<^sub>s k v) m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (snd (run_state (update\\<^sub>s k v) m))", "by (meson DP_CRelVS.lift_p_P mem.update_inv prems prod.exhaust_sel)"], ["proof (state)\nthis:\n  P (snd (run_state (update\\<^sub>s k v) m))\n\ngoal (1 subgoal):\n 1. map_of_heap (snd (the (execute (update k v) m))) \\<subseteq>\\<^sub>m\n    map_of_heap m(k \\<mapsto> v)", "with mem.update_correct[OF \\<open>P m\\<close>, of k] \\<open>P m\\<close>"], ["proof (chain)\npicking this:\n  mem.map_of (snd (run_state (update\\<^sub>s k ?v) m)) \\<subseteq>\\<^sub>m\n  mem.map_of m(k \\<mapsto> ?v)\n  P m\n  P (snd (run_state (update\\<^sub>s k v) m))", "show ?thesis"], ["proof (prove)\nusing this:\n  mem.map_of (snd (run_state (update\\<^sub>s k ?v) m)) \\<subseteq>\\<^sub>m\n  mem.map_of m(k \\<mapsto> ?v)\n  P m\n  P (snd (run_state (update\\<^sub>s k v) m))\n\ngoal (1 subgoal):\n 1. map_of_heap (snd (the (execute (update k v) m))) \\<subseteq>\\<^sub>m\n    map_of_heap m(k \\<mapsto> v)", "by (simp add: prems)"], ["proof (state)\nthis:\n  map_of_heap (snd (the (execute (update k v) m))) \\<subseteq>\\<^sub>m\n  map_of_heap m(k \\<mapsto> v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  heap_correct P update lookup\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"], ["", "(* Theory *)"]]}