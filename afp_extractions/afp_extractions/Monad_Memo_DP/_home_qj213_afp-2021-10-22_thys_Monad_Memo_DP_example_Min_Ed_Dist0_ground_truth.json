{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/example/Min_Ed_Dist0.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma \"min_eds ''vintner'' ''writers'' =\n  [Ins CHR ''w'', Repl CHR ''r'', Copy, Del, Copy, Del, Copy, Copy, Ins CHR ''s'']\"", "lemma min_eds_correct: \"edit (min_eds xs ys) xs = ys\"", "lemma min_eds_same: \"min_eds xs xs = replicate (length xs) Copy\"", "lemma min_eds_eq_Nil_iff: \"min_eds xs ys = [] \\<longleftrightarrow> xs = [] \\<and> ys = []\"", "lemma min_eds_Nil: \"min_eds [] ys = map Ins ys\"", "lemma min_eds_Nil2: \"min_eds xs [] = replicate (length xs) Del\"", "lemma if_edit_Nil2: \"edit es ([]::'a list) = ys \\<Longrightarrow> length ys \\<le> cost es\"", "lemma if_edit_eq_Nil: \"edit es xs = [] \\<Longrightarrow> length xs \\<le> cost es\"", "lemma min_eds_minimal: \"edit es xs = ys \\<Longrightarrow> cost(min_eds xs ys) \\<le> cost es\"", "lemma min_ed_min_eds: \"min_ed xs ys = cost(min_eds xs ys)\"", "lemma \"min_ed ''madagascar'' ''bananas'' = 6\"", "lemma cost_Copy_Del: \"cost(min_eds xs ys) \\<le> cost (min_eds xs (x#ys)) + 1\"", "lemma cost_Copy_Ins: \"cost(min_eds xs ys) \\<le> cost (min_eds (x#xs) ys) + 1\"", "lemma \"cost(min_eds2 xs ys) = cost(min_eds xs ys)\"", "lemma \"min_eds2 xs ys = min_eds xs ys\"", "lemma min_ed_ix'_min_ed:\n  \"min_ed_ix' xs ys (length xs) (length ys) (i, j) = min_ed (drop i xs) (drop j ys)\"", "lemmas [code] = min_ed_ix\\<^sub>m.memoized_correct", "lemma [intro]:\n  \"dp_consistency_heap_array_pair' (n + 1) fst snd id m (m + 1) mem\"", "lemma [intro]:\n  \"dp_consistency_heap_array_pair_iterator (n + 1) fst snd id m (m + 1) mem\n   (\\<lambda> (x, y). if y > 0 then (x, y - 1) else (x - 1, n))\n   (\\<lambda> (x, y). (m - x) * (n + 1) + (n - y))\n   (\\<lambda> (x, y). x \\<le> m \\<and> y \\<le> n \\<and> x > 0)\n  \"", "lemmas memoized_empty =\n  min_ed_ix\\<^sub>h.memoized_empty[OF min_ed_ix\\<^sub>h.consistent_DP_iter_and_compute[OF min_ed_ix\\<^sub>h.crel]]", "lemmas iter_heap_unfold = iter_heap_unfold", "lemma min_ed_Nil1: \"min_ed [] ys = length ys\"", "lemma min_ed_Nil2: \"min_ed xs [] = length xs\"", "lemma min_ed_ix_min_ed: \"min_ed_ix xs ys m n (i,j) = min_ed (slice xs i m) (slice ys j n)\"", "lemma \"min_ed_list ''madagascar'' ''bananas'' = 6\"", "lemma \"min_ed_ia ''madagascar'' ''bananas'' = 6\"", "lemmas [simp del] = min_ed_ix\\<^sub>h'_impl.simps min_ed_ix\\<^sub>h'.simps", "lemma min_ed_ix\\<^sub>h'_impl_def:\n  includes heap_monad_syntax\n  fixes m n :: nat\n  fixes mem :: \"nat ref \\<times> nat ref \\<times> nat option array ref \\<times> nat option array ref\"\n  assumes mem_is_init: \"mem = result_of (init_state (n + 1) m (m + 1)) Heap.empty\"\n  shows \"min_ed_ix\\<^sub>h'_impl xs ys m n mem = min_ed_ix\\<^sub>h' xs ys m n mem\"", "lemma iter_min_ed_ix_unfold[code]:\n  \"iter_min_ed_ix xs ys m n mem = (\\<lambda> (i, j).\n    (if i > 0 \\<and> i \\<le> m \\<and> j \\<le> n\n     then do {\n            min_ed_ix\\<^sub>h'_impl xs ys m n mem (i, j);\n            iter_min_ed_ix xs ys m n mem (if j > 0 then (i, j - 1) else (i - 1, n))\n          }\n     else Heap_Monad.return ()))\"", "lemma bf_impl_correct:\n  \"min_ed_ix xs ys m n (i, j) = result_of (min_ed_ix_impl xs ys m n i j) Heap.empty\""], "translations": [["", "lemma \"min_eds ''vintner'' ''writers'' =\n  [Ins CHR ''w'', Repl CHR ''r'', Copy, Del, Copy, Del, Copy, Copy, Ins CHR ''s'']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_eds ''vintner'' ''writers'' =\n    [Ins CHR ''w'', Repl CHR ''r'', Copy, Del, Copy, Del, Copy, Copy,\n     Ins CHR ''s'']", "by eval"], ["", "(*\nvalue \"min_eds ''madagascar'' ''bananas''\"\n\nvalue \"min_eds ''madagascaram'' ''banananas''\"\n*)"], ["", "lemma min_eds_correct: \"edit (min_eds xs ys) xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edit (min_eds xs ys) xs = ys", "by (induction xs ys rule: min_eds.induct) auto"], ["", "lemma min_eds_same: \"min_eds xs xs = replicate (length xs) Copy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_eds xs xs = replicate (length xs) Copy", "by (induction xs) auto"], ["", "lemma min_eds_eq_Nil_iff: \"min_eds xs ys = [] \\<longleftrightarrow> xs = [] \\<and> ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min_eds xs ys = []) = (xs = [] \\<and> ys = [])", "by (induction xs ys rule: min_eds.induct) auto"], ["", "lemma min_eds_Nil: \"min_eds [] ys = map Ins ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_eds [] ys = map Ins ys", "by (induction ys) auto"], ["", "lemma min_eds_Nil2: \"min_eds xs [] = replicate (length xs) Del\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_eds xs [] = replicate (length xs) Del", "by (induction xs) auto"], ["", "lemma if_edit_Nil2: \"edit es ([]::'a list) = ys \\<Longrightarrow> length ys \\<le> cost es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edit es [] = ys \\<Longrightarrow> length ys \\<le> cost es", "apply(induction es \"[]::'a list\" arbitrary: ys rule: edit.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a es ys.\n       \\<lbrakk>\\<And>ys.\n                   edit es [] = ys \\<Longrightarrow>\n                   length ys \\<le> cost es;\n        edit (Ins a # es) [] = ys\\<rbrakk>\n       \\<Longrightarrow> length ys \\<le> cost (Ins a # es)\n 2. \\<And>es ys.\n       \\<lbrakk>\\<And>ys.\n                   edit es [] = ys \\<Longrightarrow>\n                   length ys \\<le> cost es;\n        edit (Copy # es) [] = ys\\<rbrakk>\n       \\<Longrightarrow> length ys \\<le> cost (Copy # es)\n 3. \\<And>a es ys.\n       \\<lbrakk>\\<And>ys.\n                   edit es [] = ys \\<Longrightarrow>\n                   length ys \\<le> cost es;\n        edit (Repl a # es) [] = ys\\<rbrakk>\n       \\<Longrightarrow> length ys \\<le> cost (Repl a # es)\n 4. \\<And>es ys.\n       \\<lbrakk>\\<And>ys.\n                   edit es [] = ys \\<Longrightarrow>\n                   length ys \\<le> cost es;\n        edit (Del # es) [] = ys\\<rbrakk>\n       \\<Longrightarrow> length ys \\<le> cost (Del # es)\n 5. \\<And>ys. edit [] [] = ys \\<Longrightarrow> length ys \\<le> cost []", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma if_edit_eq_Nil: \"edit es xs = [] \\<Longrightarrow> length xs \\<le> cost es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edit es xs = [] \\<Longrightarrow> length xs \\<le> cost es", "by (induction es xs rule: edit.induct) auto"], ["", "lemma min_eds_minimal: \"edit es xs = ys \\<Longrightarrow> cost(min_eds xs ys) \\<le> cost es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edit es xs = ys \\<Longrightarrow> cost (min_eds xs ys) \\<le> cost es", "proof(induction xs ys arbitrary: es rule: min_eds.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>es.\n       edit es [] = [] \\<Longrightarrow> cost (min_eds [] []) \\<le> cost es\n 2. \\<And>y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es [] = ys \\<Longrightarrow>\n                   cost (min_eds [] ys) \\<le> cost es;\n        edit es [] = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds [] (y # ys)) \\<le> cost es\n 3. \\<And>x xs es.\n       \\<lbrakk>\\<And>es.\n                   edit es xs = [] \\<Longrightarrow>\n                   cost (min_eds xs []) \\<le> cost es;\n        edit es (x # xs) = []\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) []) \\<le> cost es\n 4. \\<And>x xs y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es (x # xs) = ys \\<Longrightarrow>\n                   cost (min_eds (x # xs) ys) \\<le> cost es;\n        \\<And>es.\n           edit es xs = y # ys \\<Longrightarrow>\n           cost (min_eds xs (y # ys)) \\<le> cost es;\n        \\<And>es.\n           edit es xs = ys \\<Longrightarrow>\n           cost (min_eds xs ys) \\<le> cost es;\n        edit es (x # xs) = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) (y # ys)) \\<le> cost es", "case 1"], ["proof (state)\nthis:\n  edit es [] = []\n\ngoal (4 subgoals):\n 1. \\<And>es.\n       edit es [] = [] \\<Longrightarrow> cost (min_eds [] []) \\<le> cost es\n 2. \\<And>y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es [] = ys \\<Longrightarrow>\n                   cost (min_eds [] ys) \\<le> cost es;\n        edit es [] = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds [] (y # ys)) \\<le> cost es\n 3. \\<And>x xs es.\n       \\<lbrakk>\\<And>es.\n                   edit es xs = [] \\<Longrightarrow>\n                   cost (min_eds xs []) \\<le> cost es;\n        edit es (x # xs) = []\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) []) \\<le> cost es\n 4. \\<And>x xs y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es (x # xs) = ys \\<Longrightarrow>\n                   cost (min_eds (x # xs) ys) \\<le> cost es;\n        \\<And>es.\n           edit es xs = y # ys \\<Longrightarrow>\n           cost (min_eds xs (y # ys)) \\<le> cost es;\n        \\<And>es.\n           edit es xs = ys \\<Longrightarrow>\n           cost (min_eds xs ys) \\<le> cost es;\n        edit es (x # xs) = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) (y # ys)) \\<le> cost es", "thus ?case"], ["proof (prove)\nusing this:\n  edit es [] = []\n\ngoal (1 subgoal):\n 1. cost (min_eds [] []) \\<le> cost es", "by simp"], ["proof (state)\nthis:\n  cost (min_eds [] []) \\<le> cost es\n\ngoal (3 subgoals):\n 1. \\<And>y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es [] = ys \\<Longrightarrow>\n                   cost (min_eds [] ys) \\<le> cost es;\n        edit es [] = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds [] (y # ys)) \\<le> cost es\n 2. \\<And>x xs es.\n       \\<lbrakk>\\<And>es.\n                   edit es xs = [] \\<Longrightarrow>\n                   cost (min_eds xs []) \\<le> cost es;\n        edit es (x # xs) = []\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) []) \\<le> cost es\n 3. \\<And>x xs y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es (x # xs) = ys \\<Longrightarrow>\n                   cost (min_eds (x # xs) ys) \\<le> cost es;\n        \\<And>es.\n           edit es xs = y # ys \\<Longrightarrow>\n           cost (min_eds xs (y # ys)) \\<le> cost es;\n        \\<And>es.\n           edit es xs = ys \\<Longrightarrow>\n           cost (min_eds xs ys) \\<le> cost es;\n        edit es (x # xs) = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) (y # ys)) \\<le> cost es", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es [] = ys \\<Longrightarrow>\n                   cost (min_eds [] ys) \\<le> cost es;\n        edit es [] = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds [] (y # ys)) \\<le> cost es\n 2. \\<And>x xs es.\n       \\<lbrakk>\\<And>es.\n                   edit es xs = [] \\<Longrightarrow>\n                   cost (min_eds xs []) \\<le> cost es;\n        edit es (x # xs) = []\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) []) \\<le> cost es\n 3. \\<And>x xs y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es (x # xs) = ys \\<Longrightarrow>\n                   cost (min_eds (x # xs) ys) \\<le> cost es;\n        \\<And>es.\n           edit es xs = y # ys \\<Longrightarrow>\n           cost (min_eds xs (y # ys)) \\<le> cost es;\n        \\<And>es.\n           edit es xs = ys \\<Longrightarrow>\n           cost (min_eds xs ys) \\<le> cost es;\n        edit es (x # xs) = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) (y # ys)) \\<le> cost es", "case 2"], ["proof (state)\nthis:\n  edit ?es [] = ys_ \\<Longrightarrow> cost (min_eds [] ys_) \\<le> cost ?es\n  edit es [] = y_ # ys_\n\ngoal (3 subgoals):\n 1. \\<And>y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es [] = ys \\<Longrightarrow>\n                   cost (min_eds [] ys) \\<le> cost es;\n        edit es [] = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds [] (y # ys)) \\<le> cost es\n 2. \\<And>x xs es.\n       \\<lbrakk>\\<And>es.\n                   edit es xs = [] \\<Longrightarrow>\n                   cost (min_eds xs []) \\<le> cost es;\n        edit es (x # xs) = []\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) []) \\<le> cost es\n 3. \\<And>x xs y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es (x # xs) = ys \\<Longrightarrow>\n                   cost (min_eds (x # xs) ys) \\<le> cost es;\n        \\<And>es.\n           edit es xs = y # ys \\<Longrightarrow>\n           cost (min_eds xs (y # ys)) \\<le> cost es;\n        \\<And>es.\n           edit es xs = ys \\<Longrightarrow>\n           cost (min_eds xs ys) \\<le> cost es;\n        edit es (x # xs) = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) (y # ys)) \\<le> cost es", "thus ?case"], ["proof (prove)\nusing this:\n  edit ?es [] = ys_ \\<Longrightarrow> cost (min_eds [] ys_) \\<le> cost ?es\n  edit es [] = y_ # ys_\n\ngoal (1 subgoal):\n 1. cost (min_eds [] (y_ # ys_)) \\<le> cost es", "by (auto simp add: min_eds_Nil dest: if_edit_Nil2)"], ["proof (state)\nthis:\n  cost (min_eds [] (y_ # ys_)) \\<le> cost es\n\ngoal (2 subgoals):\n 1. \\<And>x xs es.\n       \\<lbrakk>\\<And>es.\n                   edit es xs = [] \\<Longrightarrow>\n                   cost (min_eds xs []) \\<le> cost es;\n        edit es (x # xs) = []\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) []) \\<le> cost es\n 2. \\<And>x xs y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es (x # xs) = ys \\<Longrightarrow>\n                   cost (min_eds (x # xs) ys) \\<le> cost es;\n        \\<And>es.\n           edit es xs = y # ys \\<Longrightarrow>\n           cost (min_eds xs (y # ys)) \\<le> cost es;\n        \\<And>es.\n           edit es xs = ys \\<Longrightarrow>\n           cost (min_eds xs ys) \\<le> cost es;\n        edit es (x # xs) = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) (y # ys)) \\<le> cost es", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs es.\n       \\<lbrakk>\\<And>es.\n                   edit es xs = [] \\<Longrightarrow>\n                   cost (min_eds xs []) \\<le> cost es;\n        edit es (x # xs) = []\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) []) \\<le> cost es\n 2. \\<And>x xs y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es (x # xs) = ys \\<Longrightarrow>\n                   cost (min_eds (x # xs) ys) \\<le> cost es;\n        \\<And>es.\n           edit es xs = y # ys \\<Longrightarrow>\n           cost (min_eds xs (y # ys)) \\<le> cost es;\n        \\<And>es.\n           edit es xs = ys \\<Longrightarrow>\n           cost (min_eds xs ys) \\<le> cost es;\n        edit es (x # xs) = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) (y # ys)) \\<le> cost es", "case 3"], ["proof (state)\nthis:\n  edit ?es xs_ = [] \\<Longrightarrow> cost (min_eds xs_ []) \\<le> cost ?es\n  edit es (x_ # xs_) = []\n\ngoal (2 subgoals):\n 1. \\<And>x xs es.\n       \\<lbrakk>\\<And>es.\n                   edit es xs = [] \\<Longrightarrow>\n                   cost (min_eds xs []) \\<le> cost es;\n        edit es (x # xs) = []\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) []) \\<le> cost es\n 2. \\<And>x xs y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es (x # xs) = ys \\<Longrightarrow>\n                   cost (min_eds (x # xs) ys) \\<le> cost es;\n        \\<And>es.\n           edit es xs = y # ys \\<Longrightarrow>\n           cost (min_eds xs (y # ys)) \\<le> cost es;\n        \\<And>es.\n           edit es xs = ys \\<Longrightarrow>\n           cost (min_eds xs ys) \\<le> cost es;\n        edit es (x # xs) = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) (y # ys)) \\<le> cost es", "thus ?case"], ["proof (prove)\nusing this:\n  edit ?es xs_ = [] \\<Longrightarrow> cost (min_eds xs_ []) \\<le> cost ?es\n  edit es (x_ # xs_) = []\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) []) \\<le> cost es", "by(auto simp add: min_eds_Nil2 dest: if_edit_eq_Nil)"], ["proof (state)\nthis:\n  cost (min_eds (x_ # xs_) []) \\<le> cost es\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es (x # xs) = ys \\<Longrightarrow>\n                   cost (min_eds (x # xs) ys) \\<le> cost es;\n        \\<And>es.\n           edit es xs = y # ys \\<Longrightarrow>\n           cost (min_eds xs (y # ys)) \\<le> cost es;\n        \\<And>es.\n           edit es xs = ys \\<Longrightarrow>\n           cost (min_eds xs ys) \\<le> cost es;\n        edit es (x # xs) = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) (y # ys)) \\<le> cost es", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es (x # xs) = ys \\<Longrightarrow>\n                   cost (min_eds (x # xs) ys) \\<le> cost es;\n        \\<And>es.\n           edit es xs = y # ys \\<Longrightarrow>\n           cost (min_eds xs (y # ys)) \\<le> cost es;\n        \\<And>es.\n           edit es xs = ys \\<Longrightarrow>\n           cost (min_eds xs ys) \\<le> cost es;\n        edit es (x # xs) = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) (y # ys)) \\<le> cost es", "case 4"], ["proof (state)\nthis:\n  edit ?es (x_ # xs_) = ys_ \\<Longrightarrow>\n  cost (min_eds (x_ # xs_) ys_) \\<le> cost ?es\n  edit ?es xs_ = y_ # ys_ \\<Longrightarrow>\n  cost (min_eds xs_ (y_ # ys_)) \\<le> cost ?es\n  edit ?es xs_ = ys_ \\<Longrightarrow> cost (min_eds xs_ ys_) \\<le> cost ?es\n  edit es (x_ # xs_) = y_ # ys_\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys es.\n       \\<lbrakk>\\<And>es.\n                   edit es (x # xs) = ys \\<Longrightarrow>\n                   cost (min_eds (x # xs) ys) \\<le> cost es;\n        \\<And>es.\n           edit es xs = y # ys \\<Longrightarrow>\n           cost (min_eds xs (y # ys)) \\<le> cost es;\n        \\<And>es.\n           edit es xs = ys \\<Longrightarrow>\n           cost (min_eds xs ys) \\<le> cost es;\n        edit es (x # xs) = y # ys\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (x # xs) (y # ys)) \\<le> cost es", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "proof (cases \"es\")"], ["proof (state)\ngoal (2 subgoals):\n 1. es = [] \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 2. \\<And>a list.\n       es = a # list \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "case Nil"], ["proof (state)\nthis:\n  es = []\n\ngoal (2 subgoals):\n 1. es = [] \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 2. \\<And>a list.\n       es = a # list \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "then"], ["proof (chain)\npicking this:\n  es = []", "show ?thesis"], ["proof (prove)\nusing this:\n  es = []\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "using \"4.prems\""], ["proof (prove)\nusing this:\n  es = []\n  edit es (x_ # xs_) = y_ # ys_\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "by (auto simp: min_eds_same)"], ["proof (state)\nthis:\n  cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es = a # list \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es = a # list \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "case [simp]: (Cons e es')"], ["proof (state)\nthis:\n  es = e # es'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es = a # list \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "proof (cases e)"], ["proof (state)\ngoal (4 subgoals):\n 1. e = Copy \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 2. \\<And>x2.\n       e = Repl x2 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 3. \\<And>x3.\n       e = Ins x3 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 4. e = Del \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "case Copy"], ["proof (state)\nthis:\n  e = Copy\n\ngoal (4 subgoals):\n 1. e = Copy \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 2. \\<And>x2.\n       e = Repl x2 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 3. \\<And>x3.\n       e = Ins x3 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 4. e = Del \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "thus ?thesis"], ["proof (prove)\nusing this:\n  e = Copy\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "using \"4.prems\" \"4.IH\"(3)[of es']"], ["proof (prove)\nusing this:\n  e = Copy\n  edit es (x_ # xs_) = y_ # ys_\n  edit es' xs_ = ys_ \\<Longrightarrow> cost (min_eds xs_ ys_) \\<le> cost es'\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "by simp"], ["proof (state)\nthis:\n  cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       e = Repl x2 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 2. \\<And>x3.\n       e = Ins x3 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 3. e = Del \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       e = Repl x2 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 2. \\<And>x3.\n       e = Ins x3 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 3. e = Del \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "case (Repl a)"], ["proof (state)\nthis:\n  e = Repl a\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       e = Repl x2 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 2. \\<And>x3.\n       e = Ins x3 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 3. e = Del \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "thus ?thesis"], ["proof (prove)\nusing this:\n  e = Repl a\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "using \"4.prems\" \"4.IH\"(3)[of es']"], ["proof (prove)\nusing this:\n  e = Repl a\n  edit es (x_ # xs_) = y_ # ys_\n  edit es' xs_ = ys_ \\<Longrightarrow> cost (min_eds xs_ ys_) \\<le> cost es'\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "using [[simp_depth_limit=1]]"], ["proof (prove)\nusing this:\n  e = Repl a\n  edit es (x_ # xs_) = y_ # ys_\n  edit es' xs_ = ys_ \\<Longrightarrow> cost (min_eds xs_ ys_) \\<le> cost es'\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "by simp"], ["proof (state)\nthis:\n  cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       e = Ins x3 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 2. e = Del \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       e = Ins x3 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 2. e = Del \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "case (Ins a)"], ["proof (state)\nthis:\n  e = Ins a\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       e = Ins x3 \\<Longrightarrow>\n       cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n 2. e = Del \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "thus ?thesis"], ["proof (prove)\nusing this:\n  e = Ins a\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "using \"4.prems\" \"4.IH\"(1)[of es']"], ["proof (prove)\nusing this:\n  e = Ins a\n  edit es (x_ # xs_) = y_ # ys_\n  edit es' (x_ # xs_) = ys_ \\<Longrightarrow>\n  cost (min_eds (x_ # xs_) ys_) \\<le> cost es'\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "using [[simp_depth_limit=1]]"], ["proof (prove)\nusing this:\n  e = Ins a\n  edit es (x_ # xs_) = y_ # ys_\n  edit es' (x_ # xs_) = ys_ \\<Longrightarrow>\n  cost (min_eds (x_ # xs_) ys_) \\<le> cost es'\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "by auto"], ["proof (state)\nthis:\n  cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n\ngoal (1 subgoal):\n 1. e = Del \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e = Del \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "case Del"], ["proof (state)\nthis:\n  e = Del\n\ngoal (1 subgoal):\n 1. e = Del \\<Longrightarrow>\n    cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "thus ?thesis"], ["proof (prove)\nusing this:\n  e = Del\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "using \"4.prems\" \"4.IH\"(2)[of es']"], ["proof (prove)\nusing this:\n  e = Del\n  edit es (x_ # xs_) = y_ # ys_\n  edit es' xs_ = y_ # ys_ \\<Longrightarrow>\n  cost (min_eds xs_ (y_ # ys_)) \\<le> cost es'\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "using [[simp_depth_limit=1]]"], ["proof (prove)\nusing this:\n  e = Del\n  edit es (x_ # xs_) = y_ # ys_\n  edit es' xs_ = y_ # ys_ \\<Longrightarrow>\n  cost (min_eds xs_ (y_ # ys_)) \\<le> cost es'\n\ngoal (1 subgoal):\n 1. cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es", "by auto"], ["proof (state)\nthis:\n  cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cost (min_eds (x_ # xs_) (y_ # ys_)) \\<le> cost es\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Computing the Minimum Edit Distance\""], ["", "fun min_ed :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> nat\" where\n\"min_ed [] [] = 0\" |\n\"min_ed [] (y#ys) = 1 + min_ed [] ys\" |\n\"min_ed (x#xs) [] = 1 + min_ed xs []\" |\n\"min_ed (x#xs) (y#ys) =\n  Min {1 + min_ed (x#xs) ys, 1 + min_ed xs (y#ys), (if x=y then 0 else 1) + min_ed xs ys}\""], ["", "lemma min_ed_min_eds: \"min_ed xs ys = cost(min_eds xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed xs ys = cost (min_eds xs ys)", "apply(induction xs ys rule: min_ed.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. min_ed [] [] = cost (min_eds [] [])\n 2. \\<And>y ys.\n       min_ed [] ys = cost (min_eds [] ys) \\<Longrightarrow>\n       min_ed [] (y # ys) = cost (min_eds [] (y # ys))\n 3. \\<And>x xs.\n       min_ed xs [] = cost (min_eds xs []) \\<Longrightarrow>\n       min_ed (x # xs) [] = cost (min_eds (x # xs) [])\n 4. \\<And>x xs y ys.\n       \\<lbrakk>min_ed (x # xs) ys = cost (min_eds (x # xs) ys);\n        min_ed xs (y # ys) = cost (min_eds xs (y # ys));\n        min_ed xs ys = cost (min_eds xs ys)\\<rbrakk>\n       \\<Longrightarrow> min_ed (x # xs) (y # ys) =\n                         cost (min_eds (x # xs) (y # ys))", "apply (auto split!: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"min_ed ''madagascar'' ''bananas'' = 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed ''madagascar'' ''bananas'' = 6", "by eval"], ["", "(*\nvalue \"min_ed ''madagascaram'' ''banananas''\"\n*)"], ["", "text \"Exercise: Optimization of the Copy case\""], ["", "fun min_eds2 :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a ed list\" where\n\"min_eds2 [] [] = []\" |\n\"min_eds2 [] (y#ys) = Ins y # min_eds2 [] ys\" |\n\"min_eds2 (x#xs) [] = Del # min_eds2 xs []\" |\n\"min_eds2 (x#xs) (y#ys) =\n  (if x=y then Copy # min_eds2 xs ys\n   else argmin cost\n     [Ins y # min_eds2 (x#xs) ys, Del # min_eds2 xs (y#ys), Repl y # min_eds2 xs ys])\""], ["", "value \"min_eds2 ''madagascar'' ''bananas''\""], ["", "lemma cost_Copy_Del: \"cost(min_eds xs ys) \\<le> cost (min_eds xs (x#ys)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (min_eds xs ys) \\<le> cost (min_eds xs (x # ys)) + 1", "apply(induction xs ys rule: min_eds.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. cost (min_eds [] []) \\<le> cost (min_eds [] [x]) + 1\n 2. \\<And>y ys.\n       cost (min_eds [] ys)\n       \\<le> cost (min_eds [] (x # ys)) + 1 \\<Longrightarrow>\n       cost (min_eds [] (y # ys)) \\<le> cost (min_eds [] (x # y # ys)) + 1\n 3. \\<And>xa xs.\n       cost (min_eds xs [])\n       \\<le> cost (min_eds xs [x]) + 1 \\<Longrightarrow>\n       cost (min_eds (xa # xs) []) \\<le> cost (min_eds (xa # xs) [x]) + 1\n 4. \\<And>xa xs y ys.\n       \\<lbrakk>cost (min_eds (xa # xs) ys)\n                \\<le> cost (min_eds (xa # xs) (x # ys)) + 1;\n        cost (min_eds xs (y # ys)) \\<le> cost (min_eds xs (x # y # ys)) + 1;\n        cost (min_eds xs ys) \\<le> cost (min_eds xs (x # ys)) + 1\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (xa # xs) (y # ys))\n                         \\<le> cost (min_eds (xa # xs) (x # y # ys)) + 1", "apply(auto simp del: filter_True filter_False split!: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cost_Copy_Ins: \"cost(min_eds xs ys) \\<le> cost (min_eds (x#xs) ys) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (min_eds xs ys) \\<le> cost (min_eds (x # xs) ys) + 1", "apply(induction xs ys rule: min_eds.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. cost (min_eds [] []) \\<le> cost (min_eds [x] []) + 1\n 2. \\<And>y ys.\n       cost (min_eds [] ys)\n       \\<le> cost (min_eds [x] ys) + 1 \\<Longrightarrow>\n       cost (min_eds [] (y # ys)) \\<le> cost (min_eds [x] (y # ys)) + 1\n 3. \\<And>xa xs.\n       cost (min_eds xs [])\n       \\<le> cost (min_eds (x # xs) []) + 1 \\<Longrightarrow>\n       cost (min_eds (xa # xs) []) \\<le> cost (min_eds (x # xa # xs) []) + 1\n 4. \\<And>xa xs y ys.\n       \\<lbrakk>cost (min_eds (xa # xs) ys)\n                \\<le> cost (min_eds (x # xa # xs) ys) + 1;\n        cost (min_eds xs (y # ys))\n        \\<le> cost (min_eds (x # xs) (y # ys)) + 1;\n        cost (min_eds xs ys) \\<le> cost (min_eds (x # xs) ys) + 1\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds (xa # xs) (y # ys))\n                         \\<le> cost (min_eds (x # xa # xs) (y # ys)) + 1", "apply(auto simp del: filter_True filter_False split!: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"cost(min_eds2 xs ys) = cost(min_eds xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (min_eds2 xs ys) = cost (min_eds xs ys)", "proof(induction xs ys rule: min_eds2.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. cost (min_eds2 [] []) = cost (min_eds [] [])\n 2. \\<And>y ys.\n       cost (min_eds2 [] ys) = cost (min_eds [] ys) \\<Longrightarrow>\n       cost (min_eds2 [] (y # ys)) = cost (min_eds [] (y # ys))\n 3. \\<And>x xs.\n       cost (min_eds2 xs []) = cost (min_eds xs []) \\<Longrightarrow>\n       cost (min_eds2 (x # xs) []) = cost (min_eds (x # xs) [])\n 4. \\<And>x xs y ys.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                cost (min_eds2 xs ys) = cost (min_eds xs ys);\n        x \\<noteq> y \\<Longrightarrow>\n        cost (min_eds2 (x # xs) ys) = cost (min_eds (x # xs) ys);\n        x \\<noteq> y \\<Longrightarrow>\n        cost (min_eds2 xs (y # ys)) = cost (min_eds xs (y # ys));\n        x \\<noteq> y \\<Longrightarrow>\n        cost (min_eds2 xs ys) = cost (min_eds xs ys)\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds2 (x # xs) (y # ys)) =\n                         cost (min_eds (x # xs) (y # ys))", "case (4 x xs y ys)"], ["proof (state)\nthis:\n  x = y \\<Longrightarrow> cost (min_eds2 xs ys) = cost (min_eds xs ys)\n  x \\<noteq> y \\<Longrightarrow>\n  cost (min_eds2 (x # xs) ys) = cost (min_eds (x # xs) ys)\n  x \\<noteq> y \\<Longrightarrow>\n  cost (min_eds2 xs (y # ys)) = cost (min_eds xs (y # ys))\n  x \\<noteq> y \\<Longrightarrow>\n  cost (min_eds2 xs ys) = cost (min_eds xs ys)\n\ngoal (4 subgoals):\n 1. cost (min_eds2 [] []) = cost (min_eds [] [])\n 2. \\<And>y ys.\n       cost (min_eds2 [] ys) = cost (min_eds [] ys) \\<Longrightarrow>\n       cost (min_eds2 [] (y # ys)) = cost (min_eds [] (y # ys))\n 3. \\<And>x xs.\n       cost (min_eds2 xs []) = cost (min_eds xs []) \\<Longrightarrow>\n       cost (min_eds2 (x # xs) []) = cost (min_eds (x # xs) [])\n 4. \\<And>x xs y ys.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                cost (min_eds2 xs ys) = cost (min_eds xs ys);\n        x \\<noteq> y \\<Longrightarrow>\n        cost (min_eds2 (x # xs) ys) = cost (min_eds (x # xs) ys);\n        x \\<noteq> y \\<Longrightarrow>\n        cost (min_eds2 xs (y # ys)) = cost (min_eds xs (y # ys));\n        x \\<noteq> y \\<Longrightarrow>\n        cost (min_eds2 xs ys) = cost (min_eds xs ys)\\<rbrakk>\n       \\<Longrightarrow> cost (min_eds2 (x # xs) (y # ys)) =\n                         cost (min_eds (x # xs) (y # ys))", "thus ?case"], ["proof (prove)\nusing this:\n  x = y \\<Longrightarrow> cost (min_eds2 xs ys) = cost (min_eds xs ys)\n  x \\<noteq> y \\<Longrightarrow>\n  cost (min_eds2 (x # xs) ys) = cost (min_eds (x # xs) ys)\n  x \\<noteq> y \\<Longrightarrow>\n  cost (min_eds2 xs (y # ys)) = cost (min_eds xs (y # ys))\n  x \\<noteq> y \\<Longrightarrow>\n  cost (min_eds2 xs ys) = cost (min_eds xs ys)\n\ngoal (1 subgoal):\n 1. cost (min_eds2 (x # xs) (y # ys)) = cost (min_eds (x # xs) (y # ys))", "apply (auto split!: if_split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>cost (min_eds2 xs ys) = cost (min_eds xs ys); x = y;\n     Suc (cost (min_eds xs (y # ys))) \\<le> cost (min_eds xs ys);\n     cost (min_eds (y # xs) ys) \\<le> cost (min_eds xs (y # ys))\\<rbrakk>\n    \\<Longrightarrow> cost (min_eds xs ys) =\n                      Suc (cost (min_eds (y # xs) ys))\n 2. \\<lbrakk>cost (min_eds2 xs ys) = cost (min_eds xs ys); x = y;\n     Suc (cost (min_eds xs (y # ys))) \\<le> cost (min_eds xs ys);\n     \\<not> cost (min_eds (y # xs) ys)\n            \\<le> cost (min_eds xs (y # ys))\\<rbrakk>\n    \\<Longrightarrow> cost (min_eds xs ys) =\n                      Suc (cost (min_eds xs (y # ys)))\n 3. \\<lbrakk>cost (min_eds2 xs ys) = cost (min_eds xs ys); x = y;\n     \\<not> Suc (cost (min_eds xs (y # ys))) \\<le> cost (min_eds xs ys);\n     Suc (cost (min_eds (y # xs) ys)) \\<le> cost (min_eds xs ys)\\<rbrakk>\n    \\<Longrightarrow> cost (min_eds xs ys) =\n                      Suc (cost (min_eds (y # xs) ys))", "apply (metis (mono_tags, lifting) Suc_eq_plus1 Suc_leI cost_Copy_Del cost_Copy_Ins le_imp_less_Suc le_neq_implies_less not_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cost (min_eds2 xs ys) = cost (min_eds xs ys); x = y;\n     Suc (cost (min_eds xs (y # ys))) \\<le> cost (min_eds xs ys);\n     \\<not> cost (min_eds (y # xs) ys)\n            \\<le> cost (min_eds xs (y # ys))\\<rbrakk>\n    \\<Longrightarrow> cost (min_eds xs ys) =\n                      Suc (cost (min_eds xs (y # ys)))\n 2. \\<lbrakk>cost (min_eds2 xs ys) = cost (min_eds xs ys); x = y;\n     \\<not> Suc (cost (min_eds xs (y # ys))) \\<le> cost (min_eds xs ys);\n     Suc (cost (min_eds (y # xs) ys)) \\<le> cost (min_eds xs ys)\\<rbrakk>\n    \\<Longrightarrow> cost (min_eds xs ys) =\n                      Suc (cost (min_eds (y # xs) ys))", "apply (metis Suc_eq_plus1 cost_Copy_Del le_antisym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cost (min_eds2 xs ys) = cost (min_eds xs ys); x = y;\n     \\<not> Suc (cost (min_eds xs (y # ys))) \\<le> cost (min_eds xs ys);\n     Suc (cost (min_eds (y # xs) ys)) \\<le> cost (min_eds xs ys)\\<rbrakk>\n    \\<Longrightarrow> cost (min_eds xs ys) =\n                      Suc (cost (min_eds (y # xs) ys))", "by (metis Suc_eq_plus1 cost_Copy_Ins le_antisym)"], ["proof (state)\nthis:\n  cost (min_eds2 (x # xs) (y # ys)) = cost (min_eds (x # xs) (y # ys))\n\ngoal (3 subgoals):\n 1. cost (min_eds2 [] []) = cost (min_eds [] [])\n 2. \\<And>y ys.\n       cost (min_eds2 [] ys) = cost (min_eds [] ys) \\<Longrightarrow>\n       cost (min_eds2 [] (y # ys)) = cost (min_eds [] (y # ys))\n 3. \\<And>x xs.\n       cost (min_eds2 xs []) = cost (min_eds xs []) \\<Longrightarrow>\n       cost (min_eds2 (x # xs) []) = cost (min_eds (x # xs) [])", "qed simp_all"], ["", "lemma \"min_eds2 xs ys = min_eds xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_eds2 xs ys = min_eds xs ys", "oops"], ["", "(* Not proveable because Copy comes last in min_eds but first in min_eds2.\n   Can reorder, but the proof still requires the same two lemmas cost_*_* above.\n*)"], ["", "subsubsection \"Indexing\""], ["", "text \"Indexing lists\""], ["", "context\nfixes xs ys :: \"'a list\"\nfixes m n :: nat\nbegin"], ["", "function (sequential)\n  min_ed_ix' :: \"nat * nat \\<Rightarrow> nat\" where\n\"min_ed_ix' (i,j) =\n  (if i \\<ge> m then\n     if j \\<ge> n then 0 else 1 + min_ed_ix' (i,j+1) else\n   if j \\<ge> n then 1 + min_ed_ix' (i+1, j)\n   else\n   Min {1 + min_ed_ix' (i,j+1), 1 + min_ed_ix' (i+1, j),\n       (if xs!i = ys!j then 0 else 1) + min_ed_ix' (i+1,j+1)})\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if m \\<le> i\n        then if n \\<le> j then 0 else 1 + min_ed_ix'_sumC (i, j + 1)\n        else if n \\<le> j then 1 + min_ed_ix'_sumC (i + 1, j)\n             else Min {1 + min_ed_ix'_sumC (i, j + 1),\n                       1 + min_ed_ix'_sumC (i + 1, j),\n                       (if xs ! i = ys ! j then 0 else 1) +\n                       min_ed_ix'_sumC (i + 1, j + 1)}) =\n       (if m \\<le> ia\n        then if n \\<le> ja then 0 else 1 + min_ed_ix'_sumC (ia, ja + 1)\n        else if n \\<le> ja then 1 + min_ed_ix'_sumC (ia + 1, ja)\n             else Min {1 + min_ed_ix'_sumC (ia, ja + 1),\n                       1 + min_ed_ix'_sumC (ia + 1, ja),\n                       (if xs ! ia = ys ! ja then 0 else 1) +\n                       min_ed_ix'_sumC (ia + 1, ja + 1)})", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.min_ed_ix'_dom", "by(relation \"measure(\\<lambda>(i,j). (m - i) + (n - j))\") auto"], ["", "declare min_ed_ix'.simps[simp del]"], ["", "end"], ["", "lemma min_ed_ix'_min_ed:\n  \"min_ed_ix' xs ys (length xs) (length ys) (i, j) = min_ed (drop i xs) (drop j ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed_ix' xs ys (length xs) (length ys) (i, j) =\n    min_ed (drop i xs) (drop j ys)", "apply(induction \"(i,j)\" arbitrary: i j rule: min_ed_ix'.induct[of \"length xs\" \"length ys\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>length xs \\<le> i;\n                 \\<not> length ys \\<le> j\\<rbrakk>\n                \\<Longrightarrow> min_ed_ix' xs ys (length xs) (length ys)\n                                   (i, j + 1) =\n                                  min_ed (drop i xs) (drop (j + 1) ys);\n        \\<lbrakk>\\<not> length xs \\<le> i; length ys \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix' xs ys (length xs) (length ys)\n                           (i + 1, j) =\n                          min_ed (drop (i + 1) xs) (drop j ys);\n        \\<lbrakk>\\<not> length xs \\<le> i; \\<not> length ys \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix' xs ys (length xs) (length ys)\n                           (i, j + 1) =\n                          min_ed (drop i xs) (drop (j + 1) ys);\n        \\<lbrakk>\\<not> length xs \\<le> i; \\<not> length ys \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix' xs ys (length xs) (length ys)\n                           (i + 1, j) =\n                          min_ed (drop (i + 1) xs) (drop j ys);\n        \\<lbrakk>\\<not> length xs \\<le> i; \\<not> length ys \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix' xs ys (length xs) (length ys)\n                           (i + 1, j + 1) =\n                          min_ed (drop (i + 1) xs)\n                           (drop (j + 1) ys)\\<rbrakk>\n       \\<Longrightarrow> min_ed_ix' xs ys (length xs) (length ys) (i, j) =\n                         min_ed (drop i xs) (drop j ys)", "apply(subst min_ed_ix'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>length xs \\<le> i;\n                 \\<not> length ys \\<le> j\\<rbrakk>\n                \\<Longrightarrow> min_ed_ix' xs ys (length xs) (length ys)\n                                   (i, j + 1) =\n                                  min_ed (drop i xs) (drop (j + 1) ys);\n        \\<lbrakk>\\<not> length xs \\<le> i; length ys \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix' xs ys (length xs) (length ys)\n                           (i + 1, j) =\n                          min_ed (drop (i + 1) xs) (drop j ys);\n        \\<lbrakk>\\<not> length xs \\<le> i; \\<not> length ys \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix' xs ys (length xs) (length ys)\n                           (i, j + 1) =\n                          min_ed (drop i xs) (drop (j + 1) ys);\n        \\<lbrakk>\\<not> length xs \\<le> i; \\<not> length ys \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix' xs ys (length xs) (length ys)\n                           (i + 1, j) =\n                          min_ed (drop (i + 1) xs) (drop j ys);\n        \\<lbrakk>\\<not> length xs \\<le> i; \\<not> length ys \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix' xs ys (length xs) (length ys)\n                           (i + 1, j + 1) =\n                          min_ed (drop (i + 1) xs)\n                           (drop (j + 1) ys)\\<rbrakk>\n       \\<Longrightarrow> (if length xs \\<le> i\n                          then if length ys \\<le> j then 0\n                               else 1 +\n                                    min_ed_ix' xs ys (length xs) (length ys)\n                                     (i, j + 1)\n                          else if length ys \\<le> j\n                               then 1 +\n                                    min_ed_ix' xs ys (length xs) (length ys)\n                                     (i + 1, j)\n                               else Min {1 +\n   min_ed_ix' xs ys (length xs) (length ys) (i, j + 1),\n   1 + min_ed_ix' xs ys (length xs) (length ys) (i + 1, j),\n   (if xs ! i = ys ! j then 0 else 1) +\n   min_ed_ix' xs ys (length xs) (length ys) (i + 1, j + 1)}) =\n                         min_ed (drop i xs) (drop j ys)", "apply(simp add: Cons_nth_drop_Suc[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \"Indexing functions\""], ["", "context\nfixes xs ys :: \"nat \\<Rightarrow> 'a\"\nfixes m n :: nat\nbegin"], ["", "function (sequential)\n  min_ed_ix :: \"nat \\<times> nat \\<Rightarrow> nat\" where\n\"min_ed_ix (i, j) =\n  (if i \\<ge> m then\n     if j \\<ge> n then 0 else n-j else\n   if j \\<ge> n then m-i\n   else\n   min_list [1 + min_ed_ix (i, j+1), 1 + min_ed_ix (i+1, j),\n       (if xs i = ys j then 0 else 1) + min_ed_ix (i+1, j+1)])\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if m \\<le> i then if n \\<le> j then 0 else n - j\n        else if n \\<le> j then m - i\n             else Example_Misc.min_list\n                   [1 + min_ed_ix_sumC (i, j + 1),\n                    1 + min_ed_ix_sumC (i + 1, j),\n                    (if xs i = ys j then 0 else 1) +\n                    min_ed_ix_sumC (i + 1, j + 1)]) =\n       (if m \\<le> ia then if n \\<le> ja then 0 else n - ja\n        else if n \\<le> ja then m - ia\n             else Example_Misc.min_list\n                   [1 + min_ed_ix_sumC (ia, ja + 1),\n                    1 + min_ed_ix_sumC (ia + 1, ja),\n                    (if xs ia = ys ja then 0 else 1) +\n                    min_ed_ix_sumC (ia + 1, ja + 1)])", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.min_ed_ix_dom", "by(relation \"measure(\\<lambda>(i,j). (m - i) + (n - j))\") auto"], ["", "subsubsection \\<open>Functional Memoization\\<close>"], ["", "memoize_fun min_ed_ix\\<^sub>m: min_ed_ix with_memory dp_consistency_mapping"], ["", "monadifies (state) min_ed_ix.simps"], ["", "thm min_ed_ix\\<^sub>m'.simps"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) local.min_ed_ix local.min_ed_ix\\<^sub>m'", "by memoize_prover"], ["", "print_theorems"], ["", "lemmas [code] = min_ed_ix\\<^sub>m.memoized_correct"], ["", "declare min_ed_ix.simps[simp del]"], ["", "subsubsection \\<open>Imperative Memoization\\<close>"], ["", "context\n  fixes mem :: \"nat ref \\<times> nat ref \\<times> nat option array ref \\<times> nat option array ref\"\n  assumes mem_is_init: \"mem = result_of (init_state (n + 1) m (m + 1)) Heap.empty\"\nbegin"], ["", "interpretation iterator\n  \"\\<lambda> (x, y). x \\<le> m \\<and> y \\<le> n \\<and> x > 0\"\n  \"\\<lambda> (x, y). if y > 0 then (x, y - 1) else (x - 1, n)\"\n  \"\\<lambda> (x, y). (m - x) * (n + 1) + (n - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterator (\\<lambda>(x, y). x \\<le> m \\<and> y \\<le> n \\<and> 0 < x)\n     (\\<lambda>(x, y). if 0 < y then (x, y - 1) else (x - 1, n))\n     (\\<lambda>(x, y). (m - x) * (n + 1) + (n - y))", "by (rule table_iterator_down)"], ["", "lemma [intro]:\n  \"dp_consistency_heap_array_pair' (n + 1) fst snd id m (m + 1) mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_array_pair' (n + 1) fst snd id m (m + 1) mem", "by (standard; simp add: mem_is_init injective_def)"], ["", "lemma [intro]:\n  \"dp_consistency_heap_array_pair_iterator (n + 1) fst snd id m (m + 1) mem\n   (\\<lambda> (x, y). if y > 0 then (x, y - 1) else (x - 1, n))\n   (\\<lambda> (x, y). (m - x) * (n + 1) + (n - y))\n   (\\<lambda> (x, y). x \\<le> m \\<and> y \\<le> n \\<and> x > 0)\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_array_pair_iterator (n + 1) fst snd id m (m + 1) mem\n     (\\<lambda>(x, y). if 0 < y then (x, y - 1) else (x - 1, n))\n     (\\<lambda>(x, y). (m - x) * (n + 1) + (n - y))\n     (\\<lambda>(x, y). x \\<le> m \\<and> y \\<le> n \\<and> 0 < x)", "by (standard; simp add: mem_is_init injective_def)"], ["", "memoize_fun min_ed_ix\\<^sub>h: min_ed_ix\n  with_memory (default_proof) dp_consistency_heap_array_pair_iterator\n  where size = \"n + 1\"\n    and key1=\"fst :: nat \\<times> nat \\<Rightarrow> nat\" and key2=\"snd :: nat \\<times> nat \\<Rightarrow> nat\"\n    and k1=\"m :: nat\" and k2=\"m + 1 :: nat\"\n    and to_index = \"id :: nat \\<Rightarrow> nat\"\n    and mem = mem\n    and cnt = \"\\<lambda> (x, y). x \\<le> m \\<and> y \\<le> n \\<and> x > 0\"\n    and nxt = \"\\<lambda> (x::nat, y). if y > 0 then (x, y - 1) else (x - 1, n)\"\n    and sizef = \"\\<lambda> (x, y). (m - x) * (n + 1) + (n - y)\""], ["", "monadifies (heap) min_ed_ix.simps"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed_ix\\<^sub>h.consistentDP local.min_ed_ix\\<^sub>h'", "by memoize_prover"], ["", "lemmas memoized_empty =\n  min_ed_ix\\<^sub>h.memoized_empty[OF min_ed_ix\\<^sub>h.consistent_DP_iter_and_compute[OF min_ed_ix\\<^sub>h.crel]]"], ["", "lemmas iter_heap_unfold = iter_heap_unfold"], ["", "end"], ["", "(* Fixed Memory *)"], ["", "end"], ["", "subsubsection \\<open>Test Cases\\<close>"], ["", "abbreviation (input) \"slice xs i j \\<equiv> map xs [i..<j]\""], ["", "lemma min_ed_Nil1: \"min_ed [] ys = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed [] ys = length ys", "by (induction ys) auto"], ["", "lemma min_ed_Nil2: \"min_ed xs [] = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed xs [] = length xs", "by (induction xs) auto"], ["", "(* prove correctness of min_ed_ix directly ? *)"], ["", "lemma min_ed_ix_min_ed: \"min_ed_ix xs ys m n (i,j) = min_ed (slice xs i m) (slice ys j n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed_ix xs ys m n (i, j) = min_ed (map xs [i..<m]) (map ys [j..<n])", "apply(induction \"(i,j)\" arbitrary: i j rule: min_ed_ix.induct[of m n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n                \\<Longrightarrow> min_ed_ix xs ys m n (i, j + 1) =\n                                  min_ed (map xs [i..<m])\n                                   (map ys [j + 1..<n]);\n        \\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix xs ys m n (i + 1, j) =\n                          min_ed (map xs [i + 1..<m]) (map ys [j..<n]);\n        \\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix xs ys m n (i + 1, j + 1) =\n                          min_ed (map xs [i + 1..<m])\n                           (map ys [j + 1..<n])\\<rbrakk>\n       \\<Longrightarrow> min_ed_ix xs ys m n (i, j) =\n                         min_ed (map xs [i..<m]) (map ys [j..<n])", "apply(simp add: min_ed_ix.simps upt_conv_Cons min_ed_Nil1 min_ed_Nil2 Suc_diff_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Functional Test Cases\\<close>"], ["", "definition \"min_ed_list xs ys = min_ed_ix (\\<lambda>i. xs!i) (\\<lambda>i. ys!i) (length xs) (length ys) (0,0)\""], ["", "lemma \"min_ed_list ''madagascar'' ''bananas'' = 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed_list ''madagascar'' ''bananas'' = 6", "by eval"], ["", "definition \"min_ed_ia xs ys = (let a = IArray xs; b = IArray ys\n  in min_ed_ix (\\<lambda>i. a!!i) (\\<lambda>i. b!!i) (length xs) (length ys) (0,0))\""], ["", "lemma \"min_ed_ia ''madagascar'' ''bananas'' = 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed_ia ''madagascar'' ''bananas'' = 6", "by eval"], ["", "text \\<open>Extracting an Executable Constant for the Imperative Implementation\\<close>"], ["", "ground_function min_ed_ix\\<^sub>h'_impl: min_ed_ix\\<^sub>h'.simps"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All min_ed_ix\\<^sub>h'_impl_dom", "by(relation \"measure(\\<lambda>(xs, ys, m, n, mem, i, j). (m - i) + (n - j))\") auto"], ["", "lemmas [simp del] = min_ed_ix\\<^sub>h'_impl.simps min_ed_ix\\<^sub>h'.simps"], ["", "lemma min_ed_ix\\<^sub>h'_impl_def:\n  includes heap_monad_syntax\n  fixes m n :: nat\n  fixes mem :: \"nat ref \\<times> nat ref \\<times> nat option array ref \\<times> nat option array ref\"\n  assumes mem_is_init: \"mem = result_of (init_state (n + 1) m (m + 1)) Heap.empty\"\n  shows \"min_ed_ix\\<^sub>h'_impl xs ys m n mem = min_ed_ix\\<^sub>h' xs ys m n mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed_ix\\<^sub>h'_impl xs ys m n mem = min_ed_ix\\<^sub>h' xs ys m n mem", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. min_ed_ix\\<^sub>h'_impl xs ys m n mem = min_ed_ix\\<^sub>h' xs ys m n mem", "have \"min_ed_ix\\<^sub>h'_impl xs ys m n mem (i, j) = min_ed_ix\\<^sub>h' xs ys m n mem (i, j)\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed_ix\\<^sub>h'_impl xs ys m n mem (i, j) =\n    min_ed_ix\\<^sub>h' xs ys m n mem (i, j)", "apply (induction rule: min_ed_ix\\<^sub>h'.induct[OF mem_is_init])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n                \\<Longrightarrow> min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                                   (i, j + 1) =\n                                  min_ed_ix\\<^sub>h' xs ys m n mem\n                                   (i, j + 1);\n        \\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix\\<^sub>h'_impl xs ys m n mem (i + 1, j) =\n                          min_ed_ix\\<^sub>h' xs ys m n mem (i + 1, j);\n        \\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                           (i + 1, j + 1) =\n                          min_ed_ix\\<^sub>h' xs ys m n mem\n                           (i + 1, j + 1)\\<rbrakk>\n       \\<Longrightarrow> min_ed_ix\\<^sub>h'_impl xs ys m n mem (i, j) =\n                         min_ed_ix\\<^sub>h' xs ys m n mem (i, j)", "apply (subst min_ed_ix\\<^sub>h'_impl.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n                \\<Longrightarrow> min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                                   (i, j + 1) =\n                                  min_ed_ix\\<^sub>h' xs ys m n mem\n                                   (i, j + 1);\n        \\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix\\<^sub>h'_impl xs ys m n mem (i + 1, j) =\n                          min_ed_ix\\<^sub>h' xs ys m n mem (i + 1, j);\n        \\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                           (i + 1, j + 1) =\n                          min_ed_ix\\<^sub>h' xs ys m n mem\n                           (i + 1, j + 1)\\<rbrakk>\n       \\<Longrightarrow> heap_mem_defs.checkmem\n                          (case mem of\n                           (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n                             lookup_pair (n + 1) id fst snd m_ref1 m_ref2\n                              k_ref1 k_ref2)\n                          (case mem of\n                           (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n                             update_pair (n + 1) id fst snd m_ref1 m_ref2\n                              k_ref1 k_ref2)\n                          (i, j)\n                          (Heap_Monad_Ext.if\\<^sub>T\n                            \\<langle>m \\<le> i\\<rangle>\n                            \\<langle>if n \\<le> j then 0 else n - j\\<rangle>\n                            (Heap_Monad_Ext.if\\<^sub>T\n                              \\<langle>n \\<le> j\\<rangle>\n                              \\<langle>m - i\\<rangle>\n                              (\\<langle>\\<lambda>a.\n     \\<langle>Example_Misc.min_list a\\<rangle>\\<rangle> .\n                               (\\<langle>\\<lambda>a.\n      \\<langle>\\<lambda>b. \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n                                (\\<langle>\\<lambda>a.\n       \\<langle>1 + a\\<rangle>\\<rangle> .\n                                 (min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                                   (i, j + 1))) .\n                                (\\<langle>\\<lambda>a.\n       \\<langle>\\<lambda>b. \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n                                 (\\<langle>\\<lambda>a.\n        \\<langle>1 + a\\<rangle>\\<rangle> .\n                                  (min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                                    (i + 1, j))) .\n                                 (\\<langle>\\<lambda>a.\n        \\<langle>\\<lambda>b. \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n                                  (\\<langle>\\<lambda>a.\n         \\<langle>(if xs i = ys j then 0 else 1) + a\\<rangle>\\<rangle> .\n                                   (min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                                     (i + 1, j + 1))) .\n                                  \\<langle>[]\\<rangle>)))))) =\n                         min_ed_ix\\<^sub>h' xs ys m n mem (i, j)", "apply (subst min_ed_ix\\<^sub>h'.simps[OF mem_is_init])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n                \\<Longrightarrow> min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                                   (i, j + 1) =\n                                  min_ed_ix\\<^sub>h' xs ys m n mem\n                                   (i, j + 1);\n        \\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix\\<^sub>h'_impl xs ys m n mem (i + 1, j) =\n                          min_ed_ix\\<^sub>h' xs ys m n mem (i + 1, j);\n        \\<lbrakk>\\<not> m \\<le> i; \\<not> n \\<le> j\\<rbrakk>\n        \\<Longrightarrow> min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                           (i + 1, j + 1) =\n                          min_ed_ix\\<^sub>h' xs ys m n mem\n                           (i + 1, j + 1)\\<rbrakk>\n       \\<Longrightarrow> heap_mem_defs.checkmem\n                          (case mem of\n                           (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n                             lookup_pair (n + 1) id fst snd m_ref1 m_ref2\n                              k_ref1 k_ref2)\n                          (case mem of\n                           (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n                             update_pair (n + 1) id fst snd m_ref1 m_ref2\n                              k_ref1 k_ref2)\n                          (i, j)\n                          (Heap_Monad_Ext.if\\<^sub>T\n                            \\<langle>m \\<le> i\\<rangle>\n                            \\<langle>if n \\<le> j then 0 else n - j\\<rangle>\n                            (Heap_Monad_Ext.if\\<^sub>T\n                              \\<langle>n \\<le> j\\<rangle>\n                              \\<langle>m - i\\<rangle>\n                              (\\<langle>\\<lambda>a.\n     \\<langle>Example_Misc.min_list a\\<rangle>\\<rangle> .\n                               (\\<langle>\\<lambda>a.\n      \\<langle>\\<lambda>b. \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n                                (\\<langle>\\<lambda>a.\n       \\<langle>1 + a\\<rangle>\\<rangle> .\n                                 (min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                                   (i, j + 1))) .\n                                (\\<langle>\\<lambda>a.\n       \\<langle>\\<lambda>b. \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n                                 (\\<langle>\\<lambda>a.\n        \\<langle>1 + a\\<rangle>\\<rangle> .\n                                  (min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                                    (i + 1, j))) .\n                                 (\\<langle>\\<lambda>a.\n        \\<langle>\\<lambda>b. \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n                                  (\\<langle>\\<lambda>a.\n         \\<langle>(if xs i = ys j then 0 else 1) + a\\<rangle>\\<rangle> .\n                                   (min_ed_ix\\<^sub>h'_impl xs ys m n mem\n                                     (i + 1, j + 1))) .\n                                  \\<langle>[]\\<rangle>)))))) =\n                         heap_mem_defs.checkmem\n                          (case mem of\n                           (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n                             lookup_pair (n + 1) id fst snd m_ref1 m_ref2\n                              k_ref1 k_ref2)\n                          (case mem of\n                           (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n                             update_pair (n + 1) id fst snd m_ref1 m_ref2\n                              k_ref1 k_ref2)\n                          (i, j)\n                          (Heap_Monad_Ext.if\\<^sub>T\n                            \\<langle>m \\<le> i\\<rangle>\n                            \\<langle>if n \\<le> j then 0 else n - j\\<rangle>\n                            (Heap_Monad_Ext.if\\<^sub>T\n                              \\<langle>n \\<le> j\\<rangle>\n                              \\<langle>m - i\\<rangle>\n                              (\\<langle>\\<lambda>a.\n     \\<langle>Example_Misc.min_list a\\<rangle>\\<rangle> .\n                               (\\<langle>\\<lambda>a.\n      \\<langle>\\<lambda>b. \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n                                (\\<langle>\\<lambda>a.\n       \\<langle>1 + a\\<rangle>\\<rangle> .\n                                 (min_ed_ix\\<^sub>h' xs ys m n mem\n                                   (i, j + 1))) .\n                                (\\<langle>\\<lambda>a.\n       \\<langle>\\<lambda>b. \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n                                 (\\<langle>\\<lambda>a.\n        \\<langle>1 + a\\<rangle>\\<rangle> .\n                                  (min_ed_ix\\<^sub>h' xs ys m n mem\n                                    (i + 1, j))) .\n                                 (\\<langle>\\<lambda>a.\n        \\<langle>\\<lambda>b. \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n                                  (\\<langle>\\<lambda>a.\n         \\<langle>(if xs i = ys j then 0 else 1) + a\\<rangle>\\<rangle> .\n                                   (min_ed_ix\\<^sub>h' xs ys m n mem\n                                     (i + 1, j + 1))) .\n                                  \\<langle>[]\\<rangle>))))))", "apply (solve_cong simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  min_ed_ix\\<^sub>h'_impl xs ys m n mem (?i, ?j) =\n  min_ed_ix\\<^sub>h' xs ys m n mem (?i, ?j)\n\ngoal (1 subgoal):\n 1. min_ed_ix\\<^sub>h'_impl xs ys m n mem = min_ed_ix\\<^sub>h' xs ys m n mem", "then"], ["proof (chain)\npicking this:\n  min_ed_ix\\<^sub>h'_impl xs ys m n mem (?i, ?j) =\n  min_ed_ix\\<^sub>h' xs ys m n mem (?i, ?j)", "show ?thesis"], ["proof (prove)\nusing this:\n  min_ed_ix\\<^sub>h'_impl xs ys m n mem (?i, ?j) =\n  min_ed_ix\\<^sub>h' xs ys m n mem (?i, ?j)\n\ngoal (1 subgoal):\n 1. min_ed_ix\\<^sub>h'_impl xs ys m n mem = min_ed_ix\\<^sub>h' xs ys m n mem", "by auto"], ["proof (state)\nthis:\n  min_ed_ix\\<^sub>h'_impl xs ys m n mem = min_ed_ix\\<^sub>h' xs ys m n mem\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"iter_min_ed_ix xs ys m n mem = iterator_defs.iter_heap\n    (\\<lambda> (x, y). x \\<le> m \\<and> y \\<le> n \\<and> x > 0)\n    (\\<lambda> (x, y). if y > 0 then (x, y - 1) else (x - 1, n))\n    (min_ed_ix\\<^sub>h'_impl xs ys m n mem)\n  \""], ["", "lemma iter_min_ed_ix_unfold[code]:\n  \"iter_min_ed_ix xs ys m n mem = (\\<lambda> (i, j).\n    (if i > 0 \\<and> i \\<le> m \\<and> j \\<le> n\n     then do {\n            min_ed_ix\\<^sub>h'_impl xs ys m n mem (i, j);\n            iter_min_ed_ix xs ys m n mem (if j > 0 then (i, j - 1) else (i - 1, n))\n          }\n     else Heap_Monad.return ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter_min_ed_ix xs ys m n mem =\n    (\\<lambda>(i, j).\n        if 0 < i \\<and> i \\<le> m \\<and> j \\<le> n\n        then min_ed_ix\\<^sub>h'_impl xs ys m n mem (i, j) \\<bind>\n             (\\<lambda>_.\n                 iter_min_ed_ix xs ys m n mem\n                  (if 0 < j then (i, j - 1) else (i - 1, n)))\n        else return ())", "unfolding iter_min_ed_ix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterator_defs.iter_heap\n     (\\<lambda>(x, y). x \\<le> m \\<and> y \\<le> n \\<and> 0 < x)\n     (\\<lambda>(x, y). if 0 < y then (x, y - 1) else (x - 1, n))\n     (min_ed_ix\\<^sub>h'_impl xs ys m n mem) =\n    (\\<lambda>(i, j).\n        if 0 < i \\<and> i \\<le> m \\<and> j \\<le> n\n        then min_ed_ix\\<^sub>h'_impl xs ys m n mem (i, j) \\<bind>\n             (\\<lambda>_.\n                 iterator_defs.iter_heap\n                  (\\<lambda>(x, y). x \\<le> m \\<and> y \\<le> n \\<and> 0 < x)\n                  (\\<lambda>(x, y).\n                      if 0 < y then (x, y - 1) else (x - 1, n))\n                  (min_ed_ix\\<^sub>h'_impl xs ys m n mem)\n                  (if 0 < j then (i, j - 1) else (i - 1, n)))\n        else return ())", "by (rule ext) (safe, simp add: iter_heap_unfold)"], ["", "definition\n  \"min_ed_ix_impl xs ys m n i j = do {\n    mem \\<leftarrow> (init_state (n + 1) (m::nat) (m + 1) ::\n      (nat ref \\<times> nat ref \\<times> nat option array ref \\<times> nat option array ref) Heap);\n    iter_min_ed_ix xs ys m n mem (m, n);\n    min_ed_ix\\<^sub>h'_impl xs ys m n mem (i, j)\n  }\""], ["", "lemma bf_impl_correct:\n  \"min_ed_ix xs ys m n (i, j) = result_of (min_ed_ix_impl xs ys m n i j) Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ed_ix xs ys m n (i, j) =\n    result_of (min_ed_ix_impl xs ys m n i j) Heap.empty", "using memoized_empty[OF HOL.refl, of xs ys m n \"(i, j)\" \"\\<lambda> _. (m, n)\"]"], ["proof (prove)\nusing this:\n  min_ed_ix xs ys m n (i, j) =\n  result_of\n   (init_state (n + 1) m (m + 1) \\<bind>\n    (\\<lambda>mem.\n        iterator_defs.iter_heap\n         (\\<lambda>a.\n             case a of\n             (x, y) \\<Rightarrow> x \\<le> m \\<and> y \\<le> n \\<and> 0 < x)\n         (\\<lambda>a.\n             case a of\n             (x, y) \\<Rightarrow> if 0 < y then (x, y - 1) else (x - 1, n))\n         (min_ed_ix\\<^sub>h' xs ys m n\n           (result_of (init_state (n + 1) m (m + 1)) Heap.empty))\n         (m, n) \\<bind>\n        (\\<lambda>_.\n            min_ed_ix\\<^sub>h' xs ys m n\n             (result_of (init_state (n + 1) m (m + 1)) Heap.empty) (i, j))))\n   Heap.empty\n\ngoal (1 subgoal):\n 1. min_ed_ix xs ys m n (i, j) =\n    result_of (min_ed_ix_impl xs ys m n i j) Heap.empty", "by (simp add:\n      execute_bind_success[OF succes_init_state] min_ed_ix_impl_def min_ed_ix\\<^sub>h'_impl_def\n      iter_min_ed_ix_def\n     )"], ["", "text \\<open>Imperative Test Case\\<close>"], ["", "definition\n  \"min_ed_ia\\<^sub>h xs ys = (let a = IArray xs; b = IArray ys\n  in min_ed_ix_impl (\\<lambda>i. a!!i) (\\<lambda>i. b!!i) (length xs) (length ys) 0 0)\""], ["", "definition\n  \"test_case = min_ed_ia\\<^sub>h ''madagascar'' ''bananas''\""], ["", "export_code min_ed_ix in SML module_name Test"], ["", "code_reflect Test functions test_case"], ["", "text \\<open>One can see a trace of the calls to the memory in the output\\<close>"], ["", "ML \\<open>Test.test_case ()\\<close>"], ["", "end"]]}