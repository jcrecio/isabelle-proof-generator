{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/example/Knapsack.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma OPT_0:\n  \"OPT 0 W = 0\"", "lemma Max_add_left:\n  \"(x :: nat) + Max S = Max (((+) x) ` S)\" (is \"?A = ?B\") if \"finite S\" \"S \\<noteq> {}\"", "lemma OPT_Suc:\n  \"OPT (Suc i) W = (\n    if W < w (Suc i)\n    then OPT i W\n    else max(v (Suc i) + OPT i (W - w (Suc i))) (OPT i W)\n  )\" (is \"?lhs = ?rhs\")", "theorem knapsack_correct:\n  \"OPT n W = knapsack n W\"", "lemmas [code] = knapsack\\<^sub>m.memoized_correct", "lemmas memoized_empty = knapsack\\<^sub>T.memoized_empty", "lemmas memoized_empty' = memoized_empty[\n      of mem n W \"\\<lambda> m. \\<lambda>(i,j). knapsack\\<^sub>T' m n W i j\",\n      OF knapsack\\<^sub>T.crel[of mem n W], of \"(n, W)\" for mem n W\n    ]", "lemma knapsack_heap:\n  \"knapsack n W = result_of (knapsack\\<^sub>h n W) Heap.empty\"", "lemma su_knapsack:\n  \"su n W = knapsack w n W\"", "lemma su_correct:\n  \"Max {\\<Sum> i \\<in> S. w i | S. S \\<subseteq> {1..n} \\<and> (\\<Sum> i \\<in> S. w i) \\<le> W} = su n W\"", "lemmas [code] = su\\<^sub>m.memoized_correct"], "translations": [["", "lemma OPT_0:\n  \"OPT 0 W = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT 0 W = 0", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {sum v S |S. S \\<subseteq> {1..0} \\<and> sum w S \\<le> W} = 0", "by simp"], ["", "subsubsection \\<open>Functional Correctness\\<close>"], ["", "lemma Max_add_left:\n  \"(x :: nat) + Max S = Max (((+) x) ` S)\" (is \"?A = ?B\") if \"finite S\" \"S \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + Max S = Max ((+) x ` S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x + Max S = Max ((+) x ` S)", "have \"?A \\<le> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + Max S \\<le> Max ((+) x ` S)", "using that"], ["proof (prove)\nusing this:\n  finite S\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x + Max S \\<le> Max ((+) x ` S)", "by (force intro: Min.boundedI)"], ["proof (state)\nthis:\n  x + Max S \\<le> Max ((+) x ` S)\n\ngoal (1 subgoal):\n 1. x + Max S = Max ((+) x ` S)", "moreover"], ["proof (state)\nthis:\n  x + Max S \\<le> Max ((+) x ` S)\n\ngoal (1 subgoal):\n 1. x + Max S = Max ((+) x ` S)", "have \"?B \\<le> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max ((+) x ` S) \\<le> x + Max S", "using that"], ["proof (prove)\nusing this:\n  finite S\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max ((+) x ` S) \\<le> x + Max S", "by (force intro: Min.boundedI)"], ["proof (state)\nthis:\n  Max ((+) x ` S) \\<le> x + Max S\n\ngoal (1 subgoal):\n 1. x + Max S = Max ((+) x ` S)", "ultimately"], ["proof (chain)\npicking this:\n  x + Max S \\<le> Max ((+) x ` S)\n  Max ((+) x ` S) \\<le> x + Max S", "show ?thesis"], ["proof (prove)\nusing this:\n  x + Max S \\<le> Max ((+) x ` S)\n  Max ((+) x ` S) \\<le> x + Max S\n\ngoal (1 subgoal):\n 1. x + Max S = Max ((+) x ` S)", "by simp"], ["proof (state)\nthis:\n  x + Max S = Max ((+) x ` S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT_Suc:\n  \"OPT (Suc i) W = (\n    if W < w (Suc i)\n    then OPT i W\n    else max(v (Suc i) + OPT i (W - w (Suc i))) (OPT i W)\n  )\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "have OPT_in: \"OPT n W \\<in> {\\<Sum> i \\<in> S. v i | S. S \\<subseteq> {1..n} \\<and> (\\<Sum> i \\<in> S. w i) \\<le> W}\" for n W"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT n W\n    \\<in> {sum v S |S. S \\<subseteq> {1..n} \\<and> sum w S \\<le> W}", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {sum v S |S. S \\<subseteq> {1..n} \\<and> sum w S \\<le> W}\n    \\<in> {sum v S |S. S \\<subseteq> {1..n} \\<and> sum w S \\<le> W}", "by - (rule Max_in; force)"], ["proof (state)\nthis:\n  local.OPT ?n ?W\n  \\<in> {sum v S |S. S \\<subseteq> {1..?n} \\<and> sum w S \\<le> ?W}\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "from OPT_in[of \"Suc i\" W]"], ["proof (chain)\npicking this:\n  local.OPT (Suc i) W\n  \\<in> {sum v S |S. S \\<subseteq> {1..Suc i} \\<and> sum w S \\<le> W}", "obtain S where S:\n    \"S \\<subseteq> {1..Suc i}\" \"sum w S \\<le> W\" and [simp]: \"OPT (Suc i) W = sum v S\""], ["proof (prove)\nusing this:\n  local.OPT (Suc i) W\n  \\<in> {sum v S |S. S \\<subseteq> {1..Suc i} \\<and> sum w S \\<le> W}\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S \\<subseteq> {1..Suc i}; sum w S \\<le> W;\n         local.OPT (Suc i) W = sum v S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S \\<subseteq> {1..Suc i}\n  sum w S \\<le> W\n  local.OPT (Suc i) W = sum v S\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "have \"OPT i W \\<le> OPT (Suc i) W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT i W \\<le> local.OPT (Suc i) W", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {sum v S |S. S \\<subseteq> {1..i} \\<and> sum w S \\<le> W}\n    \\<le> Max {sum v S |S. S \\<subseteq> {1..Suc i} \\<and> sum w S \\<le> W}", "by (force intro: Max_mono)"], ["proof (state)\nthis:\n  local.OPT i W \\<le> local.OPT (Suc i) W\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "moreover"], ["proof (state)\nthis:\n  local.OPT i W \\<le> local.OPT (Suc i) W\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "have \"v (Suc i) + OPT i (W - w (Suc i)) \\<le> OPT (Suc i) W\" if \"w (Suc i) \\<le> W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v (Suc i) + local.OPT i (W - w (Suc i)) \\<le> local.OPT (Suc i) W", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v (Suc i) + local.OPT i (W - w (Suc i)) \\<le> local.OPT (Suc i) W", "have *: \"\n      v (Suc i) + sum v S = sum v (S \\<union> {Suc i}) \\<and> (S \\<union> {Suc i}) \\<subseteq> {1..Suc i}\n      \\<and> sum w (S \\<union> {Suc i}) \\<le> W\" if \"S \\<subseteq> {1..i}\" \"sum w S \\<le> W - w (Suc i)\" for S"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (Suc i) + sum v S = sum v (S \\<union> {Suc i}) \\<and>\n    S \\<union> {Suc i} \\<subseteq> {1..Suc i} \\<and>\n    sum w (S \\<union> {Suc i}) \\<le> W", "using that \\<open>w (Suc i) \\<le> W\\<close>"], ["proof (prove)\nusing this:\n  S \\<subseteq> {1..i}\n  sum w S \\<le> W - w (Suc i)\n  w (Suc i) \\<le> W\n\ngoal (1 subgoal):\n 1. v (Suc i) + sum v S = sum v (S \\<union> {Suc i}) \\<and>\n    S \\<union> {Suc i} \\<subseteq> {1..Suc i} \\<and>\n    sum w (S \\<union> {Suc i}) \\<le> W", "by (subst sum.insert_if | auto intro: finite_subset[OF _ finite_atLeastAtMost])+"], ["proof (state)\nthis:\n  \\<lbrakk>?S \\<subseteq> {1..i}; sum w ?S \\<le> W - w (Suc i)\\<rbrakk>\n  \\<Longrightarrow> v (Suc i) + sum v ?S =\n                    sum v (?S \\<union> {Suc i}) \\<and>\n                    ?S \\<union> {Suc i} \\<subseteq> {1..Suc i} \\<and>\n                    sum w (?S \\<union> {Suc i}) \\<le> W\n\ngoal (1 subgoal):\n 1. v (Suc i) + local.OPT i (W - w (Suc i)) \\<le> local.OPT (Suc i) W", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (Suc i) + local.OPT i (W - w (Suc i)) \\<le> local.OPT (Suc i) W", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (Suc i) +\n    Max {sum v S |S.\n         S \\<subseteq> {1..i} \\<and> sum w S \\<le> W - w (Suc i)}\n    \\<le> Max {sum v S |S. S \\<subseteq> {1..Suc i} \\<and> sum w S \\<le> W}", "by (subst Max_add_left;\n          fastforce intro: Max_mono finite_subset[OF _ finite_atLeastAtMost] dest: *\n         )"], ["proof (state)\nthis:\n  v (Suc i) + local.OPT i (W - w (Suc i)) \\<le> local.OPT (Suc i) W\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w (Suc i) \\<le> W \\<Longrightarrow>\n  v (Suc i) + local.OPT i (W - w (Suc i)) \\<le> local.OPT (Suc i) W\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "ultimately"], ["proof (chain)\npicking this:\n  local.OPT i W \\<le> local.OPT (Suc i) W\n  w (Suc i) \\<le> W \\<Longrightarrow>\n  v (Suc i) + local.OPT i (W - w (Suc i)) \\<le> local.OPT (Suc i) W", "have \"?lhs \\<ge> ?rhs\""], ["proof (prove)\nusing this:\n  local.OPT i W \\<le> local.OPT (Suc i) W\n  w (Suc i) \\<le> W \\<Longrightarrow>\n  v (Suc i) + local.OPT i (W - w (Suc i)) \\<le> local.OPT (Suc i) W\n\ngoal (1 subgoal):\n 1. (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))\n    \\<le> local.OPT (Suc i) W", "by auto"], ["proof (state)\nthis:\n  (if W < w (Suc i) then local.OPT i W\n   else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))\n  \\<le> local.OPT (Suc i) W\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "from S"], ["proof (chain)\npicking this:\n  S \\<subseteq> {1..Suc i}\n  sum w S \\<le> W", "have *: \"sum v S \\<le> OPT i W\" if \"Suc i \\<notin> S\""], ["proof (prove)\nusing this:\n  S \\<subseteq> {1..Suc i}\n  sum w S \\<le> W\n\ngoal (1 subgoal):\n 1. sum v S \\<le> local.OPT i W", "using that"], ["proof (prove)\nusing this:\n  S \\<subseteq> {1..Suc i}\n  sum w S \\<le> W\n  Suc i \\<notin> S\n\ngoal (1 subgoal):\n 1. sum v S \\<le> local.OPT i W", "unfolding OPT_def"], ["proof (prove)\nusing this:\n  S \\<subseteq> {1..Suc i}\n  sum w S \\<le> W\n  Suc i \\<notin> S\n\ngoal (1 subgoal):\n 1. sum v S\n    \\<le> Max {sum v S |S. S \\<subseteq> {1..i} \\<and> sum w S \\<le> W}", "by (auto simp: atLeastAtMostSuc_conv intro!: Max_ge)"], ["proof (state)\nthis:\n  Suc i \\<notin> S \\<Longrightarrow> sum v S \\<le> local.OPT i W\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "have \"sum v S \\<le> OPT i W\" if \"W < w (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum v S \\<le> local.OPT i W", "proof (rule *, rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc i \\<in> S \\<Longrightarrow> False", "assume \"Suc i \\<in> S\""], ["proof (state)\nthis:\n  Suc i \\<in> S\n\ngoal (1 subgoal):\n 1. Suc i \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Suc i \\<in> S", "have \"sum w S \\<ge> w (Suc i)\""], ["proof (prove)\nusing this:\n  Suc i \\<in> S\n\ngoal (1 subgoal):\n 1. w (Suc i) \\<le> sum w S", "using S(1)"], ["proof (prove)\nusing this:\n  Suc i \\<in> S\n  S \\<subseteq> {1..Suc i}\n\ngoal (1 subgoal):\n 1. w (Suc i) \\<le> sum w S", "by (subst sum.remove) (auto intro: finite_subset[OF _ finite_atLeastAtMost])"], ["proof (state)\nthis:\n  w (Suc i) \\<le> sum w S\n\ngoal (1 subgoal):\n 1. Suc i \\<in> S \\<Longrightarrow> False", "with \\<open>W < _\\<close> \\<open>_ \\<le> W\\<close>"], ["proof (chain)\npicking this:\n  W < w (Suc i)\n  sum w S \\<le> W\n  w (Suc i) \\<le> sum w S", "show False"], ["proof (prove)\nusing this:\n  W < w (Suc i)\n  sum w S \\<le> W\n  w (Suc i) \\<le> sum w S\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  W < w (Suc i) \\<Longrightarrow> sum v S \\<le> local.OPT i W\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "moreover"], ["proof (state)\nthis:\n  W < w (Suc i) \\<Longrightarrow> sum v S \\<le> local.OPT i W\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "have\n    \"OPT (Suc i) W \\<le> max(v (Suc i) + OPT i (W - w (Suc i))) (OPT i W)\" if \"w (Suc i) \\<le> W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)", "proof (cases \"Suc i \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc i \\<in> S \\<Longrightarrow>\n    local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)\n 2. Suc i \\<notin> S \\<Longrightarrow>\n    local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)", "case True"], ["proof (state)\nthis:\n  Suc i \\<in> S\n\ngoal (2 subgoals):\n 1. Suc i \\<in> S \\<Longrightarrow>\n    local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)\n 2. Suc i \\<notin> S \\<Longrightarrow>\n    local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)", "then"], ["proof (chain)\npicking this:\n  Suc i \\<in> S", "have [simp]:\n      \"sum v S = v (Suc i) + sum v (S - {Suc i})\" \"sum w S = w (Suc i) + sum w (S - {Suc i})\""], ["proof (prove)\nusing this:\n  Suc i \\<in> S\n\ngoal (1 subgoal):\n 1. sum v S = v (Suc i) + sum v (S - {Suc i}) &&&\n    sum w S = w (Suc i) + sum w (S - {Suc i})", "using S(1)"], ["proof (prove)\nusing this:\n  Suc i \\<in> S\n  S \\<subseteq> {1..Suc i}\n\ngoal (1 subgoal):\n 1. sum v S = v (Suc i) + sum v (S - {Suc i}) &&&\n    sum w S = w (Suc i) + sum w (S - {Suc i})", "by (auto intro: finite_subset[OF _ finite_atLeastAtMost] sum.remove)"], ["proof (state)\nthis:\n  sum v S = v (Suc i) + sum v (S - {Suc i})\n  sum w S = w (Suc i) + sum w (S - {Suc i})\n\ngoal (2 subgoals):\n 1. Suc i \\<in> S \\<Longrightarrow>\n    local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)\n 2. Suc i \\<notin> S \\<Longrightarrow>\n    local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)", "have \"OPT i (W - w (Suc i)) \\<ge> sum v (S - {Suc i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum v (S - {Suc i}) \\<le> local.OPT i (W - w (Suc i))", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum v (S - {Suc i})\n    \\<le> Max {sum v S |S.\n               S \\<subseteq> {1..i} \\<and> sum w S \\<le> W - w (Suc i)}", "using S"], ["proof (prove)\nusing this:\n  S \\<subseteq> {1..Suc i}\n  sum w S \\<le> W\n\ngoal (1 subgoal):\n 1. sum v (S - {Suc i})\n    \\<le> Max {sum v S |S.\n               S \\<subseteq> {1..i} \\<and> sum w S \\<le> W - w (Suc i)}", "by (fastforce intro!: Max_ge)"], ["proof (state)\nthis:\n  sum v (S - {Suc i}) \\<le> local.OPT i (W - w (Suc i))\n\ngoal (2 subgoals):\n 1. Suc i \\<in> S \\<Longrightarrow>\n    local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)\n 2. Suc i \\<notin> S \\<Longrightarrow>\n    local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)", "then"], ["proof (chain)\npicking this:\n  sum v (S - {Suc i}) \\<le> local.OPT i (W - w (Suc i))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum v (S - {Suc i}) \\<le> local.OPT i (W - w (Suc i))\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)", "by simp"], ["proof (state)\nthis:\n  local.OPT (Suc i) W\n  \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)\n\ngoal (1 subgoal):\n 1. Suc i \\<notin> S \\<Longrightarrow>\n    local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc i \\<notin> S \\<Longrightarrow>\n    local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)", "case False"], ["proof (state)\nthis:\n  Suc i \\<notin> S\n\ngoal (1 subgoal):\n 1. Suc i \\<notin> S \\<Longrightarrow>\n    local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)", "then"], ["proof (chain)\npicking this:\n  Suc i \\<notin> S", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc i \\<notin> S\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W\n    \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)", "by (auto dest: *)"], ["proof (state)\nthis:\n  local.OPT (Suc i) W\n  \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w (Suc i) \\<le> W \\<Longrightarrow>\n  local.OPT (Suc i) W\n  \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "ultimately"], ["proof (chain)\npicking this:\n  W < w (Suc i) \\<Longrightarrow> sum v S \\<le> local.OPT i W\n  w (Suc i) \\<le> W \\<Longrightarrow>\n  local.OPT (Suc i) W\n  \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)", "have \"?lhs \\<le> ?rhs\""], ["proof (prove)\nusing this:\n  W < w (Suc i) \\<Longrightarrow> sum v S \\<le> local.OPT i W\n  w (Suc i) \\<le> W \\<Longrightarrow>\n  local.OPT (Suc i) W\n  \\<le> max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W)\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W\n    \\<le> (if W < w (Suc i) then local.OPT i W\n           else max (v (Suc i) + local.OPT i (W - w (Suc i)))\n                 (local.OPT i W))", "by auto"], ["proof (state)\nthis:\n  local.OPT (Suc i) W\n  \\<le> (if W < w (Suc i) then local.OPT i W\n         else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "with \\<open>?lhs \\<ge> ?rhs\\<close>"], ["proof (chain)\npicking this:\n  (if W < w (Suc i) then local.OPT i W\n   else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))\n  \\<le> local.OPT (Suc i) W\n  local.OPT (Suc i) W\n  \\<le> (if W < w (Suc i) then local.OPT i W\n         else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "show ?thesis"], ["proof (prove)\nusing this:\n  (if W < w (Suc i) then local.OPT i W\n   else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))\n  \\<le> local.OPT (Suc i) W\n  local.OPT (Suc i) W\n  \\<le> (if W < w (Suc i) then local.OPT i W\n         else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) W =\n    (if W < w (Suc i) then local.OPT i W\n     else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))", "by simp"], ["proof (state)\nthis:\n  local.OPT (Suc i) W =\n  (if W < w (Suc i) then local.OPT i W\n   else max (v (Suc i) + local.OPT i (W - w (Suc i))) (local.OPT i W))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem knapsack_correct:\n  \"OPT n W = knapsack n W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT n W = local.knapsack n W", "by (induction n arbitrary: W; auto simp: OPT_0 OPT_Suc)"], ["", "subsubsection \\<open>Functional Memoization\\<close>"], ["", "memoize_fun knapsack\\<^sub>m: knapsack with_memory dp_consistency_mapping"], ["", "monadifies (state) knapsack.simps"], ["", "text \\<open>Generated Definitions\\<close>"], ["", "context includes state_monad_syntax begin"], ["", "thm knapsack\\<^sub>m'.simps knapsack\\<^sub>m_def"], ["", "end"], ["", "text \\<open>Correspondence Proof\\<close>"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.knapsack x y)\n     (\\<lambda>(x, y). local.knapsack\\<^sub>m' x y)", "by memoize_prover"], ["", "print_theorems"], ["", "lemmas [code] = knapsack\\<^sub>m.memoized_correct"], ["", "subsubsection \\<open>Imperative Memoization\\<close>"], ["", "context fixes\n  mem :: \"nat option array\"\n  and n W :: nat\nbegin"], ["", "memoize_fun knapsack\\<^sub>T: knapsack\n  with_memory dp_consistency_heap_default where bound = \"Bound (0, 0) (n, W)\" and mem=\"mem\""], ["", "monadifies (heap) knapsack.simps"], ["", "context includes heap_monad_syntax begin"], ["", "thm knapsack\\<^sub>T'.simps knapsack\\<^sub>T_def"], ["", "end"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. knapsack\\<^sub>T.consistentDP\n     (\\<lambda>(x, y). local.knapsack\\<^sub>T' x y)", "by memoize_prover"], ["", "lemmas memoized_empty = knapsack\\<^sub>T.memoized_empty"], ["", "end"], ["", "(* Fixed array *)"], ["", "text \\<open>Adding Memory Initialization\\<close>"], ["", "context\n  includes heap_monad_syntax\n  notes [simp del] = knapsack\\<^sub>T'.simps\nbegin"], ["", "definition\n  \"knapsack\\<^sub>h \\<equiv> \\<lambda> i j. Heap_Monad.bind (mem_empty (i * j)) (\\<lambda> mem. knapsack\\<^sub>T' mem i j i j)\""], ["", "lemmas memoized_empty' = memoized_empty[\n      of mem n W \"\\<lambda> m. \\<lambda>(i,j). knapsack\\<^sub>T' m n W i j\",\n      OF knapsack\\<^sub>T.crel[of mem n W], of \"(n, W)\" for mem n W\n    ]"], ["", "lemma knapsack_heap:\n  \"knapsack n W = result_of (knapsack\\<^sub>h n W) Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.knapsack n W = result_of (local.knapsack\\<^sub>h n W) Heap.empty", "unfolding knapsack\\<^sub>h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.knapsack n W =\n    result_of\n     (mem_empty (n * W) \\<bind>\n      (\\<lambda>mem. local.knapsack\\<^sub>T' mem n W n W))\n     Heap.empty", "using memoized_empty'[of _ n W]"], ["proof (prove)\nusing this:\n  ?mem =\n  result_of (mem_empty (bounded_index.size (Bound (0, 0) (n, W))))\n   Heap.empty \\<Longrightarrow>\n  (case (n, W) of (x, xa) \\<Rightarrow> local.knapsack x xa) =\n  result_of\n   (mem_empty (bounded_index.size (Bound (0, 0) (n, W))) \\<bind>\n    (\\<lambda>mem.\n        case (n, W) of\n        (i, j) \\<Rightarrow> local.knapsack\\<^sub>T' mem n W i j))\n   Heap.empty\n\ngoal (1 subgoal):\n 1. local.knapsack n W =\n    result_of\n     (mem_empty (n * W) \\<bind>\n      (\\<lambda>mem. local.knapsack\\<^sub>T' mem n W n W))\n     Heap.empty", "by (simp add: index_size_defs)"], ["", "end"], ["", "end"], ["", "(* Knapsack *)"], ["", "fun su :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"su 0 W = 0\" |\n  \"su (Suc i) W = (if W < w (Suc i)\n    then su i W\n    else max (su i W) (w (Suc i) + su i (W - w (Suc i))))\""], ["", "lemma su_knapsack:\n  \"su n W = knapsack w n W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.su n W = local.knapsack w n W", "by (induction n arbitrary: W; simp)"], ["", "lemma su_correct:\n  \"Max {\\<Sum> i \\<in> S. w i | S. S \\<subseteq> {1..n} \\<and> (\\<Sum> i \\<in> S. w i) \\<le> W} = su n W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {sum w S |S. S \\<subseteq> {1..n} \\<and> sum w S \\<le> W} =\n    local.su n W", "unfolding su_knapsack knapsack_correct[symmetric] OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {sum w S |S. S \\<subseteq> {1..n} \\<and> sum w S \\<le> W} =\n    Max {sum w S |S. S \\<subseteq> {1..n} \\<and> sum w S \\<le> W}", ".."], ["", "subsubsection \\<open>Memoization\\<close>"], ["", "memoize_fun su\\<^sub>m: su with_memory dp_consistency_mapping"], ["", "monadifies (state) su.simps"], ["", "text \\<open>Generated Definitions\\<close>"], ["", "context includes state_monad_syntax begin"], ["", "thm su\\<^sub>m'.simps su\\<^sub>m_def"], ["", "end"], ["", "text \\<open>Correspondence Proof\\<close>"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.su x y)\n     (\\<lambda>(x, y). local.su\\<^sub>m' x y)", "by memoize_prover"], ["", "print_theorems"], ["", "lemmas [code] = su\\<^sub>m.memoized_correct"], ["", "end"], ["", "(* Subset Sum *)"], ["", "subsubsection \\<open>Regression Test\\<close>"], ["", "definition\n  \"knapsack_test = (knapsack\\<^sub>h (\\<lambda> i. [2,3,4] ! (i - 1)) (\\<lambda> i. [2,3,4] ! (i - 1)) 3 8)\""], ["", "code_reflect Test functions knapsack_test"], ["", "ML \\<open>Test.knapsack_test ()\\<close>"], ["", "end"], ["", "(* Theory *)"]]}