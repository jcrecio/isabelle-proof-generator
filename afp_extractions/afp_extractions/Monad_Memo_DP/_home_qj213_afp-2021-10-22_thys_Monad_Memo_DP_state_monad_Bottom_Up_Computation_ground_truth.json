{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/state_monad/Bottom_Up_Computation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma admissible:\n  \"adm_wf\n      {(nxt x, x) | x. cnt x}\n      (\\<lambda> rec x. if cnt x then do {f x; rec (nxt x)} else State_Monad.return ())\"", "lemma wellfounded:\n  \"wf {(nxt x, x) | x. cnt x}\" (is \"wf ?S\")", "lemma iter_state_unfold:\n  \"iter_state f x = (if cnt x then do {f x; iter_state f (nxt x)} else State_Monad.return ())\"", "lemma iterator_to_list_unfold:\n  \"iterator_to_list x = (if cnt x then x # iterator_to_list (nxt x) else [])\"", "lemma iter_state_iterate_state:\n  \"iter_state f x = iterate_state f (iterator_to_list x)\"", "lemma crel_vs_iterate_state:\n  \"crel_vs (=) () (iterate_state f xs)\" if \"((=) ===>\\<^sub>T R) g f\"", "lemma crel_vs_bind_ignore:\n  \"crel_vs R a (do {d; b})\" if \"crel_vs R a b\" \"crel_vs S c d\"", "lemma crel_vs_iterate_and_compute:\n  assumes \"((=) ===>\\<^sub>T R) g f\"\n  shows \"crel_vs R (g x) (do {iterate_state f xs; f x})\"", "lemma crel_vs_iter_and_compute:\n  assumes \"((=) ===>\\<^sub>T R) g f\"\n  shows \"crel_vs R (g x) (do {iter_state f y; f x})\"", "lemma consistentDP_iter_and_compute:\n  assumes \"consistentDP f\"\n  shows \"crel_vs (=) (dp x) (do {iter_state f y; f x})\"", "lemma memoized:\n  \"dp x = fst (run_state (do {iter_state f y; f x}) empty)\" if \"consistentDP f\"", "lemma cmem_result:\n  \"cmem (snd (run_state (do {iter_state f y; f x}) empty))\" if \"consistentDP f\"", "lemma dp_consistency_iterator_emptyI:\n  \"dp_consistency_iterator_empty P lookup update cnt\n    nxt sizef empty\"\n  if \"dp_consistency_empty lookup update P empty\"\n     \"iterator cnt nxt sizef\"\n   for empty", "lemma table_iterator_up:\n  \"iterator\n    (\\<lambda> (x, y). x \\<le> n \\<and> y \\<le> m)\n    (\\<lambda> (x, y). if y < m then (x, y + 1) else (x + 1, 0))\n    (\\<lambda> (x, y). x * (m + 1) + y)\"", "lemma table_iterator_down:\n  \"iterator\n    (\\<lambda> (x, y). x \\<le> n \\<and> y \\<le> m \\<and> x > 0)\n    (\\<lambda> (x, y). if y > 0 then (x, y - 1) else (x - 1, m))\n    (\\<lambda> (x, y). (n - x) * (m + 1) + (m - y))\""], "translations": [["", "lemma admissible:\n  \"adm_wf\n      {(nxt x, x) | x. cnt x}\n      (\\<lambda> rec x. if cnt x then do {f x; rec (nxt x)} else State_Monad.return ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm_wf {(nxt x, x) |x. cnt x}\n     (\\<lambda>rec x.\n         if cnt x then f x \\<bind> (\\<lambda>_. rec (nxt x))\n         else State_Monad.return ())", "unfolding adm_wf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>fa g x.\n       (\\<forall>z.\n           (z, x) \\<in> {(nxt x, x) |x. cnt x} \\<longrightarrow>\n           fa z = g z) \\<longrightarrow>\n       (if cnt x then f x \\<bind> (\\<lambda>_. fa (nxt x))\n        else State_Monad.return ()) =\n       (if cnt x then f x \\<bind> (\\<lambda>_. g (nxt x))\n        else State_Monad.return ())", "by auto"], ["", "lemma wellfounded:\n  \"wf {(nxt x, x) | x. cnt x}\" (is \"wf ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(nxt x, x) |x. cnt x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf {(nxt x, x) |x. cnt x}", "from terminating"], ["proof (chain)\npicking this:\n  finite {x. cnt x}\n  \\<forall>x. cnt x \\<longrightarrow> sizef x < sizef (nxt x)", "have \"acyclic ?S\""], ["proof (prove)\nusing this:\n  finite {x. cnt x}\n  \\<forall>x. cnt x \\<longrightarrow> sizef x < sizef (nxt x)\n\ngoal (1 subgoal):\n 1. acyclic {(nxt x, x) |x. cnt x}", "by (auto intro: acyclicI_order[where f = sizef])"], ["proof (state)\nthis:\n  acyclic {(nxt x, x) |x. cnt x}\n\ngoal (1 subgoal):\n 1. wf {(nxt x, x) |x. cnt x}", "moreover"], ["proof (state)\nthis:\n  acyclic {(nxt x, x) |x. cnt x}\n\ngoal (1 subgoal):\n 1. wf {(nxt x, x) |x. cnt x}", "have \"finite ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(nxt x, x) |x. cnt x}", "using [[simproc add: finite_Collect]] terminating(1)"], ["proof (prove)\nusing this:\n  finite {x. cnt x}\n\ngoal (1 subgoal):\n 1. finite {(nxt x, x) |x. cnt x}", "by auto"], ["proof (state)\nthis:\n  finite {(nxt x, x) |x. cnt x}\n\ngoal (1 subgoal):\n 1. wf {(nxt x, x) |x. cnt x}", "ultimately"], ["proof (chain)\npicking this:\n  acyclic {(nxt x, x) |x. cnt x}\n  finite {(nxt x, x) |x. cnt x}", "show ?thesis"], ["proof (prove)\nusing this:\n  acyclic {(nxt x, x) |x. cnt x}\n  finite {(nxt x, x) |x. cnt x}\n\ngoal (1 subgoal):\n 1. wf {(nxt x, x) |x. cnt x}", "by - (rule finite_acyclic_wf)"], ["proof (state)\nthis:\n  wf {(nxt x, x) |x. cnt x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iter_state_unfold:\n  \"iter_state f x = (if cnt x then do {f x; iter_state f (nxt x)} else State_Monad.return ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter_state f x =\n    (if cnt x then f x \\<bind> (\\<lambda>_. iter_state f (nxt x))\n     else State_Monad.return ())", "unfolding iter_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wfrec {(nxt x, x) |x. cnt x}\n     (\\<lambda>rec x.\n         if cnt x then f x \\<bind> (\\<lambda>_. rec (nxt x))\n         else State_Monad.return ())\n     x =\n    (if cnt x\n     then f x \\<bind>\n          (\\<lambda>_.\n              wfrec {(nxt x, x) |x. cnt x}\n               (\\<lambda>rec x.\n                   if cnt x then f x \\<bind> (\\<lambda>_. rec (nxt x))\n                   else State_Monad.return ())\n               (nxt x))\n     else State_Monad.return ())", "by (simp add: wfrec_fixpoint[OF wellfounded admissible])"], ["", "lemma iterator_to_list_unfold:\n  \"iterator_to_list x = (if cnt x then x # iterator_to_list (nxt x) else [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterator_to_list x =\n    (if cnt x then x # iterator_to_list (nxt x) else [])", "unfolding iterator_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wfrec {(nxt x, x) |x. cnt x}\n     (\\<lambda>rec x. if cnt x then x # rec (nxt x) else []) x =\n    (if cnt x\n     then x #\n          wfrec {(nxt x, x) |x. cnt x}\n           (\\<lambda>rec x. if cnt x then x # rec (nxt x) else []) (nxt x)\n     else [])", "by (simp add: adm_wf_def wfrec_fixpoint[OF wellfounded])"], ["", "lemma iter_state_iterate_state:\n  \"iter_state f x = iterate_state f (iterator_to_list x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter_state f x = iterate_state f (iterator_to_list x)", "apply (induction \"iterator_to_list x\" arbitrary: x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       [] = iterator_to_list x \\<Longrightarrow>\n       iter_state f x = iterate_state f (iterator_to_list x)\n 2. \\<And>a xa x.\n       \\<lbrakk>\\<And>x.\n                   xa = iterator_to_list x \\<Longrightarrow>\n                   iter_state f x = iterate_state f (iterator_to_list x);\n        a # xa = iterator_to_list x\\<rbrakk>\n       \\<Longrightarrow> iter_state f x =\n                         iterate_state f (iterator_to_list x)", "apply (simp add: iterator_to_list_unfold split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<not> cnt x \\<Longrightarrow> iter_state f x = State_Monad.return ()\n 2. \\<And>a xa x.\n       \\<lbrakk>\\<And>x.\n                   xa = iterator_to_list x \\<Longrightarrow>\n                   iter_state f x = iterate_state f (iterator_to_list x);\n        a # xa = iterator_to_list x\\<rbrakk>\n       \\<Longrightarrow> iter_state f x =\n                         iterate_state f (iterator_to_list x)", "apply (simp add: iter_state_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xa x.\n       \\<lbrakk>\\<And>x.\n                   xa = iterator_to_list x \\<Longrightarrow>\n                   iter_state f x = iterate_state f (iterator_to_list x);\n        a # xa = iterator_to_list x\\<rbrakk>\n       \\<Longrightarrow> iter_state f x =\n                         iterate_state f (iterator_to_list x)", "apply (subst (asm) (3) iterator_to_list_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xa x.\n       \\<lbrakk>\\<And>x.\n                   xa = iterator_to_list x \\<Longrightarrow>\n                   iter_state f x = iterate_state f (iterator_to_list x);\n        a # xa =\n        (if cnt x then x # iterator_to_list (nxt x) else [])\\<rbrakk>\n       \\<Longrightarrow> iter_state f x =\n                         iterate_state f (iterator_to_list x)", "apply (simp split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xa.\n       \\<lbrakk>\\<And>x.\n                   iterator_to_list (nxt a) =\n                   iterator_to_list x \\<Longrightarrow>\n                   iter_state f x = iterate_state f (iterator_to_list x);\n        cnt a; xa = iterator_to_list (nxt a)\\<rbrakk>\n       \\<Longrightarrow> iter_state f a =\n                         iterate_state f (iterator_to_list a)", "apply (auto simp: iterator_to_list_unfold iter_state_unfold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(* Termination *)"], ["", "context dp_consistency\nbegin"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma crel_vs_iterate_state:\n  \"crel_vs (=) () (iterate_state f xs)\" if \"((=) ===>\\<^sub>T R) g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (=) () (iterate_state f xs)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. crel_vs (=) () (iterate_state f [])\n 2. \\<And>a xs.\n       crel_vs (=) () (iterate_state f xs) \\<Longrightarrow>\n       crel_vs (=) () (iterate_state f (a # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. crel_vs (=) () (iterate_state f [])\n 2. \\<And>a xs.\n       crel_vs (=) () (iterate_state f xs) \\<Longrightarrow>\n       crel_vs (=) () (iterate_state f (a # xs))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (=) () (iterate_state f [])", "by (simp; rule crel_vs_return_ext[unfolded Transfer.Rel_def]; simp; fail)"], ["proof (state)\nthis:\n  crel_vs (=) () (iterate_state f [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       crel_vs (=) () (iterate_state f xs) \\<Longrightarrow>\n       crel_vs (=) () (iterate_state f (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       crel_vs (=) () (iterate_state f xs) \\<Longrightarrow>\n       crel_vs (=) () (iterate_state f (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  crel_vs (=) () (iterate_state f xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       crel_vs (=) () (iterate_state f xs) \\<Longrightarrow>\n       crel_vs (=) () (iterate_state f (a # xs))", "have unit_expand: \"() = (\\<lambda> a f. f a) () (\\<lambda> _. ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. () = ()", ".."], ["proof (state)\nthis:\n  () = ()\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       crel_vs (=) () (iterate_state f xs) \\<Longrightarrow>\n       crel_vs (=) () (iterate_state f (a # xs))", "from Cons"], ["proof (chain)\npicking this:\n  crel_vs (=) () (iterate_state f xs)", "show ?case"], ["proof (prove)\nusing this:\n  crel_vs (=) () (iterate_state f xs)\n\ngoal (1 subgoal):\n 1. crel_vs (=) () (iterate_state f (x # xs))", "by simp\n      (rule\n        bind_transfer[unfolded rel_fun_def, rule_format, unfolded unit_expand]\n        that[unfolded rel_fun_def, rule_format] HOL.refl\n      )+"], ["proof (state)\nthis:\n  crel_vs (=) () (iterate_state f (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crel_vs_bind_ignore:\n  \"crel_vs R a (do {d; b})\" if \"crel_vs R a b\" \"crel_vs S c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs R a (d \\<bind> (\\<lambda>_. b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. crel_vs R a (d \\<bind> (\\<lambda>_. b))", "have unit_expand: \"a = (\\<lambda> a f. f a) () (\\<lambda> _. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a", ".."], ["proof (state)\nthis:\n  a = a\n\ngoal (1 subgoal):\n 1. crel_vs R a (d \\<bind> (\\<lambda>_. b))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs R a (d \\<bind> (\\<lambda>_. b))", "by (subst unit_expand)\n       (rule bind_transfer[unfolded rel_fun_def, rule_format, unfolded unit_expand] that)+"], ["proof (state)\nthis:\n  crel_vs R a (d \\<bind> (\\<lambda>_. b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crel_vs_iterate_and_compute:\n  assumes \"((=) ===>\\<^sub>T R) g f\"\n  shows \"crel_vs R (g x) (do {iterate_state f xs; f x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs R (g x) (iterate_state f xs \\<bind> (\\<lambda>_. f x))", "by (rule\n        crel_vs_bind_ignore crel_vs_iterate_state HOL.refl\n        assms[unfolded rel_fun_def, rule_format] assms\n     )+"], ["", "end"], ["", "(* Lifting Syntax *)"], ["", "end"], ["", "(* DP Consistency *)"], ["", "locale dp_consistency_iterator =\n  dp_consistency lookup update + iterator cnt nxt sizef\n  for lookup :: \"'a \\<Rightarrow> ('b, 'c option) state\" and update\n    and cnt :: \"'a \\<Rightarrow> bool\" and nxt and sizef\nbegin"], ["", "lemma crel_vs_iter_and_compute:\n  assumes \"((=) ===>\\<^sub>T R) g f\"\n  shows \"crel_vs R (g x) (do {iter_state f y; f x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs R (g x) (iter_state f y \\<bind> (\\<lambda>_. f x))", "unfolding iter_state_iterate_state"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs R (g x)\n     (iterate_state f (iterator_to_list y) \\<bind> (\\<lambda>_. f x))", "using crel_vs_iterate_and_compute[OF assms]"], ["proof (prove)\nusing this:\n  crel_vs R (g ?x) (iterate_state f ?xs \\<bind> (\\<lambda>_. f ?x))\n\ngoal (1 subgoal):\n 1. crel_vs R (g x)\n     (iterate_state f (iterator_to_list y) \\<bind> (\\<lambda>_. f x))", "."], ["", "lemma consistentDP_iter_and_compute:\n  assumes \"consistentDP f\"\n  shows \"crel_vs (=) (dp x) (do {iter_state f y; f x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (=) (dp x) (iter_state f y \\<bind> (\\<lambda>_. f x))", "using assms"], ["proof (prove)\nusing this:\n  consistentDP f\n\ngoal (1 subgoal):\n 1. crel_vs (=) (dp x) (iter_state f y \\<bind> (\\<lambda>_. f x))", "unfolding consistentDP_def"], ["proof (prove)\nusing this:\n  ((=) ===>\\<^sub>T (=)) dp f\n\ngoal (1 subgoal):\n 1. crel_vs (=) (dp x) (iter_state f y \\<bind> (\\<lambda>_. f x))", "by (rule crel_vs_iter_and_compute)"], ["", "end"], ["", "(* Consistency + Iterator *)"], ["", "locale dp_consistency_iterator_empty =\n  dp_consistency_iterator + dp_consistency_empty\nbegin"], ["", "lemma memoized:\n  \"dp x = fst (run_state (do {iter_state f y; f x}) empty)\" if \"consistentDP f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp x = fst (run_state (iter_state f y \\<bind> (\\<lambda>_. f x)) empty)", "using consistentDP_iter_and_compute[OF that, of x y]"], ["proof (prove)\nusing this:\n  crel_vs (=) (dp x) (iter_state f y \\<bind> (\\<lambda>_. f x))\n\ngoal (1 subgoal):\n 1. dp x = fst (run_state (iter_state f y \\<bind> (\\<lambda>_. f x)) empty)", "by (auto elim!: crel_vs_elim intro: P_empty cmem_empty)"], ["", "lemma cmem_result:\n  \"cmem (snd (run_state (do {iter_state f y; f x}) empty))\" if \"consistentDP f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmem (snd (run_state (iter_state f y \\<bind> (\\<lambda>_. f x)) empty))", "using consistentDP_iter_and_compute[OF that, of x y]"], ["proof (prove)\nusing this:\n  crel_vs (=) (dp x) (iter_state f y \\<bind> (\\<lambda>_. f x))\n\ngoal (1 subgoal):\n 1. cmem (snd (run_state (iter_state f y \\<bind> (\\<lambda>_. f x)) empty))", "by (auto elim!: crel_vs_elim intro: P_empty cmem_empty)"], ["", "end"], ["", "(* Consistency + Iterator *)"], ["", "lemma dp_consistency_iterator_emptyI:\n  \"dp_consistency_iterator_empty P lookup update cnt\n    nxt sizef empty\"\n  if \"dp_consistency_empty lookup update P empty\"\n     \"iterator cnt nxt sizef\"\n   for empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_iterator_empty P lookup update cnt nxt sizef empty", "by (meson\n      dp_consistency_empty.axioms(1) dp_consistency_iterator_def\n      dp_consistency_iterator_empty_def that\n     )"], ["", "context\n  fixes m :: nat \\<comment> \\<open>Width of a row\\<close>\n    and n :: nat \\<comment> \\<open>Number of rows\\<close>\nbegin"], ["", "lemma table_iterator_up:\n  \"iterator\n    (\\<lambda> (x, y). x \\<le> n \\<and> y \\<le> m)\n    (\\<lambda> (x, y). if y < m then (x, y + 1) else (x + 1, 0))\n    (\\<lambda> (x, y). x * (m + 1) + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterator (\\<lambda>(x, y). x \\<le> n \\<and> y \\<le> m)\n     (\\<lambda>(x, y). if y < m then (x, y + 1) else (x + 1, 0))\n     (\\<lambda>(x, y). x * (m + 1) + y)", "by standard auto"], ["", "lemma table_iterator_down:\n  \"iterator\n    (\\<lambda> (x, y). x \\<le> n \\<and> y \\<le> m \\<and> x > 0)\n    (\\<lambda> (x, y). if y > 0 then (x, y - 1) else (x - 1, m))\n    (\\<lambda> (x, y). (n - x) * (m + 1) + (m - y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterator (\\<lambda>(x, y). x \\<le> n \\<and> y \\<le> m \\<and> 0 < x)\n     (\\<lambda>(x, y). if 0 < y then (x, y - 1) else (x - 1, m))\n     (\\<lambda>(x, y). (n - x) * (m + 1) + (m - y))", "using [[simproc add: finite_Collect]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterator (\\<lambda>(x, y). x \\<le> n \\<and> y \\<le> m \\<and> 0 < x)\n     (\\<lambda>(x, y). if 0 < y then (x, y - 1) else (x - 1, m))\n     (\\<lambda>(x, y). (n - x) * (m + 1) + (m - y))", "by standard (auto simp: Suc_diff_le)"], ["", "end"], ["", "(* Table *)"], ["", "end"], ["", "(* Theory *)"]]}