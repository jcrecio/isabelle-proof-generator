{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/heap_monad/Bottom_Up_Computation_Heap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma (in iterator) iter_heap_unfold:\n  \"iter_heap f x = (if cnt x then do {f x; iter_heap f (nxt x)} else return ())\"", "lemma crel_vs_iterate_state:\n  \"crel_vs (=) () (iter_heap f x)\" if \"((=) ===> crel_vs R) g f\"", "lemma crel_vs_bind_ignore:\n  \"crel_vs R a (do {d; b})\" if \"crel_vs R a b\" \"crel_vs S c d\"", "lemma crel_vs_iter_and_compute:\n  assumes \"((=) ===> crel_vs R) g f\"\n  shows \"crel_vs R (g x) (do {iter_heap f y; f x})\"", "lemma consistent_DP_iter_and_compute:\n  assumes \"consistentDP f\"\n  shows \"consistentDP (\\<lambda> x. do {iter_heap f y; f x})\""], "translations": [["", "lemma (in iterator) iter_heap_unfold:\n  \"iter_heap f x = (if cnt x then do {f x; iter_heap f (nxt x)} else return ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter_heap f x =\n    (if cnt x then f x \\<bind> (\\<lambda>_. iter_heap f (nxt x))\n     else return ())", "unfolding iter_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wfrec {(nxt x, x) |x. cnt x}\n     (\\<lambda>rec x.\n         if cnt x then f x \\<bind> (\\<lambda>_. rec (nxt x)) else return ())\n     x =\n    (if cnt x\n     then f x \\<bind>\n          (\\<lambda>_.\n              wfrec {(nxt x, x) |x. cnt x}\n               (\\<lambda>rec x.\n                   if cnt x then f x \\<bind> (\\<lambda>_. rec (nxt x))\n                   else return ())\n               (nxt x))\n     else return ())", "by (simp add: wfrec_fixpoint[OF iterator.wellfounded,OF iterator.intro,OF terminating] adm_wf_def)"], ["", "locale dp_consistency_iterator_heap =\n  dp_consistency_heap P update lookup dp + iterator cnt nxt sizef\n  for lookup :: \"'a \\<Rightarrow> ('c option) Heap\" and update and P dp\n    and cnt :: \"'a \\<Rightarrow> bool\" and nxt and sizef\nbegin"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "term iter_heap"], ["", "term crel_vs"], ["", "lemma crel_vs_iterate_state:\n  \"crel_vs (=) () (iter_heap f x)\" if \"((=) ===> crel_vs R) g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (=) () (iter_heap f x)", "using wellfounded"], ["proof (prove)\nusing this:\n  wf {(nxt x, x) |x. cnt x}\n\ngoal (1 subgoal):\n 1. crel_vs (=) () (iter_heap f x)", "proof induction"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> {(nxt x, x) |x. cnt x} \\<Longrightarrow>\n           crel_vs (=) () (iter_heap f y)) \\<Longrightarrow>\n       crel_vs (=) () (iter_heap f x)", "case (less x)"], ["proof (state)\nthis:\n  (?y2, x) \\<in> {(nxt x, x) |x. cnt x} \\<Longrightarrow>\n  crel_vs (=) () (iter_heap f ?y2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> {(nxt x, x) |x. cnt x} \\<Longrightarrow>\n           crel_vs (=) () (iter_heap f y)) \\<Longrightarrow>\n       crel_vs (=) () (iter_heap f x)", "have unit_expand: \"() = (\\<lambda> a f. f a) () (\\<lambda> _. ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. () = ()", ".."], ["proof (state)\nthis:\n  () = ()\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> {(nxt x, x) |x. cnt x} \\<Longrightarrow>\n           crel_vs (=) () (iter_heap f y)) \\<Longrightarrow>\n       crel_vs (=) () (iter_heap f x)", "from less"], ["proof (chain)\npicking this:\n  (?y2, x) \\<in> {(nxt x, x) |x. cnt x} \\<Longrightarrow>\n  crel_vs (=) () (iter_heap f ?y2)", "show ?case"], ["proof (prove)\nusing this:\n  (?y2, x) \\<in> {(nxt x, x) |x. cnt x} \\<Longrightarrow>\n  crel_vs (=) () (iter_heap f ?y2)\n\ngoal (1 subgoal):\n 1. crel_vs (=) () (iter_heap f x)", "by (subst iter_heap_unfold)\n       (auto intro:\n          bind_transfer[unfolded rel_fun_def, rule_format, unfolded unit_expand]\n          crel_vs_return_ext[unfolded Transfer.Rel_def] that[unfolded rel_fun_def, rule_format]\n       )"], ["proof (state)\nthis:\n  crel_vs (=) () (iter_heap f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crel_vs_bind_ignore:\n  \"crel_vs R a (do {d; b})\" if \"crel_vs R a b\" \"crel_vs S c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs R a (d \\<bind> (\\<lambda>_. b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. crel_vs R a (d \\<bind> (\\<lambda>_. b))", "have unit_expand: \"a = (\\<lambda> a f. f a) () (\\<lambda> _. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a", ".."], ["proof (state)\nthis:\n  a = a\n\ngoal (1 subgoal):\n 1. crel_vs R a (d \\<bind> (\\<lambda>_. b))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs R a (d \\<bind> (\\<lambda>_. b))", "by (subst unit_expand)\n       (rule bind_transfer[unfolded rel_fun_def, rule_format, unfolded unit_expand] that)+"], ["proof (state)\nthis:\n  crel_vs R a (d \\<bind> (\\<lambda>_. b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crel_vs_iter_and_compute:\n  assumes \"((=) ===> crel_vs R) g f\"\n  shows \"crel_vs R (g x) (do {iter_heap f y; f x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs R (g x) (iter_heap f y \\<bind> (\\<lambda>_. f x))", "by (rule\n        crel_vs_bind_ignore crel_vs_iterate_state HOL.refl\n        assms[unfolded rel_fun_def, rule_format] assms\n     )+"], ["", "lemma consistent_DP_iter_and_compute:\n  assumes \"consistentDP f\"\n  shows \"consistentDP (\\<lambda> x. do {iter_heap f y; f x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistentDP (\\<lambda>x. iter_heap f y \\<bind> (\\<lambda>_. f x))", "apply (rule consistentDP_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>param.\n       Transfer.Rel (crel_vs (=)) (dp param)\n        (iter_heap f y \\<bind> (\\<lambda>_. f param))", "using assms"], ["proof (prove)\nusing this:\n  consistentDP f\n\ngoal (1 subgoal):\n 1. \\<And>param.\n       Transfer.Rel (crel_vs (=)) (dp param)\n        (iter_heap f y \\<bind> (\\<lambda>_. f param))", "unfolding consistentDP_def Rel_def"], ["proof (prove)\nusing this:\n  ((=) ===>\\<^sub>T (=)) dp f\n\ngoal (1 subgoal):\n 1. \\<And>param.\n       crel_vs (=) (dp param) (iter_heap f y \\<bind> (\\<lambda>_. f param))", "by (rule crel_vs_iter_and_compute)"], ["", "end"], ["", "(* Lifting Syntax *)"], ["", "end"], ["", "(* DP Consistency Iterator Heap *)"], ["", "end"], ["", "(* Theory *)"]]}