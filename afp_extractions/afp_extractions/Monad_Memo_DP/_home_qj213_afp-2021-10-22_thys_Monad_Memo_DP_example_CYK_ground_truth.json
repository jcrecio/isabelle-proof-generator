{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/example/CYK.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma append_iff_take_drop:\n  \"w = u@v \\<longleftrightarrow> (\\<exists>k \\<in> {0..length w}. u = take k w \\<and> v = drop k w)\"", "lemma append_iff_take_drop1: \"u \\<noteq> [] \\<Longrightarrow> v \\<noteq> [] \\<Longrightarrow>\n  w = u@v \\<longleftrightarrow> (\\<exists>k \\<in> {1..length w - 1}. u = take k w \\<and> v = drop k w)\"", "lemma yield_not_Nil: \"yield A w \\<Longrightarrow> w \\<noteq> []\"", "lemma yield_eq1:\n  \"yield A [a] \\<longleftrightarrow> (A, T a) \\<in> set P\" (is \"?L = ?R\")", "lemma yield_eq2: assumes \"length w > 1\"\nshows \"yield A w \\<longleftrightarrow> (\\<exists>B u C v. yield B u \\<and> yield C v \\<and> w = u@v \\<and> (A, NN B C) \\<in> set P)\"\n       (is \"?L = ?R\")", "lemma set_cyk_simp2[simp]: \"length w \\<ge> 2 \\<Longrightarrow> set(cyk w) =\n  (\\<Union>k \\<in> {1..length w - 1}. \\<Union>B \\<in> set(cyk (take k w)). \\<Union>C \\<in> set(cyk (drop k w)). {A. (A, NN B C) \\<in> set P})\"", "lemma cyk_correct: \"set(cyk w) = {N. yield N w}\"", "lemma set_aux: \"(\\<Union>xb\\<in>set P. {A. (A, NN B C) = xb}) = {A. (A, NN B C) \\<in> set P}\"", "lemma cyk2_eq_cyk: \"i+n \\<le> length w \\<Longrightarrow> set(cyk2 w (i,n)) = set(cyk (take n (drop i w)))\"", "theorem CYK_correct: \"CYK S w = yield S w\"", "lemma cyk_ix_simp2: \"set(cyk_ix (i,Suc(Suc n))) =\n  (\\<Union>k \\<in> {1..Suc n}. \\<Union>B \\<in> set(cyk_ix (i,k)). \\<Union>C \\<in> set(cyk_ix (i+k,n+2-k)). {A. (A, NN B C) \\<in> set P})\"", "lemma slice_append_iff_take_drop1: \"u \\<noteq> [] \\<Longrightarrow> v \\<noteq> [] \\<Longrightarrow>\n  slice w i j = u @ v \\<longleftrightarrow> (\\<exists>k. 1 \\<le> k \\<and> k \\<le> j-i-1 \\<and> slice w i (i + k) = u \\<and> slice w (i + k) j = v)\"", "lemma cyk_ix_correct:\n  \"set(cyk_ix (i,n)) = {N. yield N (slice w i (i+n))}\"", "lemmas [code] = cyk_ix\\<^sub>m.memoized_correct", "lemmas memoized_empty = cyk_ix\\<^sub>h.memoized_empty", "lemmas init_success = cyk_ix\\<^sub>h.init_success", "lemma cyk_ix_impl_success:\n  \"success (cyk_ix_impl i j) Heap.empty\"", "lemma min_wpl_heap:\n  \"cyk_ix (i, j) = result_of (cyk_ix_impl i j) Heap.empty\"", "theorem CYK_ix_correct: \"CYK_ix S w n = yield S (slice w 0 n)\"", "lemma CYK_ix_impl_correct:\n  \"result_of (CYK_ix_impl S w n) Heap.empty = yield S (slice w 0 n)\""], "translations": [["", "lemma append_iff_take_drop:\n  \"w = u@v \\<longleftrightarrow> (\\<exists>k \\<in> {0..length w}. u = take k w \\<and> v = drop k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w = u @ v) =\n    (\\<exists>k\\<in>{0..length w}. u = take k w \\<and> v = drop k w)", "by (metis (full_types) append_eq_conv_conj append_take_drop_id atLeastAtMost_iff le0 le_add1 length_append)"], ["", "lemma append_iff_take_drop1: \"u \\<noteq> [] \\<Longrightarrow> v \\<noteq> [] \\<Longrightarrow>\n  w = u@v \\<longleftrightarrow> (\\<exists>k \\<in> {1..length w - 1}. u = take k w \\<and> v = drop k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<noteq> []; v \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (w = u @ v) =\n                      (\\<exists>k\\<in>{1..length w - 1}.\n                          u = take k w \\<and> v = drop k w)", "by(auto simp: append_iff_take_drop)"], ["", "subsubsection \\<open>Definitions\\<close>"], ["", "datatype ('n, 't) rhs = NN 'n 'n | T 't"], ["", "type_synonym ('n, 't) prods = \"('n \\<times> ('n, 't) rhs) list\""], ["", "context\nfixes P :: \"('n :: heap, 't) prods\"\nbegin"], ["", "inductive yield :: \"'n \\<Rightarrow> 't list \\<Rightarrow> bool\" where\n\"(A, T a) \\<in> set P \\<Longrightarrow> yield A [a]\" |\n\"\\<lbrakk> (A, NN B C) \\<in> set P; yield B u; yield C v \\<rbrakk> \\<Longrightarrow> yield A (u@v)\""], ["", "lemma yield_not_Nil: \"yield A w \\<Longrightarrow> w \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.yield A w \\<Longrightarrow> w \\<noteq> []", "by (induction rule: yield.induct) auto"], ["", "lemma yield_eq1:\n  \"yield A [a] \\<longleftrightarrow> (A, T a) \\<in> set P\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.yield A [a] = ((A, T a) \\<in> set P)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. local.yield A [a] \\<Longrightarrow> (A, T a) \\<in> set P\n 2. (A, T a) \\<in> set P \\<Longrightarrow> local.yield A [a]", "assume ?L"], ["proof (state)\nthis:\n  local.yield A [a]\n\ngoal (2 subgoals):\n 1. local.yield A [a] \\<Longrightarrow> (A, T a) \\<in> set P\n 2. (A, T a) \\<in> set P \\<Longrightarrow> local.yield A [a]", "thus ?R"], ["proof (prove)\nusing this:\n  local.yield A [a]\n\ngoal (1 subgoal):\n 1. (A, T a) \\<in> set P", "by(induction A \"[a]\" arbitrary: a rule: yield.induct)\n      (auto simp add: yield_not_Nil append_eq_Cons_conv)"], ["proof (state)\nthis:\n  (A, T a) \\<in> set P\n\ngoal (1 subgoal):\n 1. (A, T a) \\<in> set P \\<Longrightarrow> local.yield A [a]", "qed (simp add: yield.intros)"], ["", "lemma yield_eq2: assumes \"length w > 1\"\nshows \"yield A w \\<longleftrightarrow> (\\<exists>B u C v. yield B u \\<and> yield C v \\<and> w = u@v \\<and> (A, NN B C) \\<in> set P)\"\n       (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.yield A w =\n    (\\<exists>B u C v.\n        local.yield B u \\<and>\n        local.yield C v \\<and> w = u @ v \\<and> (A, NN B C) \\<in> set P)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. local.yield A w \\<Longrightarrow>\n    \\<exists>B u C v.\n       local.yield B u \\<and>\n       local.yield C v \\<and> w = u @ v \\<and> (A, NN B C) \\<in> set P\n 2. \\<exists>B u C v.\n       local.yield B u \\<and>\n       local.yield C v \\<and>\n       w = u @ v \\<and> (A, NN B C) \\<in> set P \\<Longrightarrow>\n    local.yield A w", "assume ?L"], ["proof (state)\nthis:\n  local.yield A w\n\ngoal (2 subgoals):\n 1. local.yield A w \\<Longrightarrow>\n    \\<exists>B u C v.\n       local.yield B u \\<and>\n       local.yield C v \\<and> w = u @ v \\<and> (A, NN B C) \\<in> set P\n 2. \\<exists>B u C v.\n       local.yield B u \\<and>\n       local.yield C v \\<and>\n       w = u @ v \\<and> (A, NN B C) \\<in> set P \\<Longrightarrow>\n    local.yield A w", "from this assms"], ["proof (chain)\npicking this:\n  local.yield A w\n  1 < length w", "show ?R"], ["proof (prove)\nusing this:\n  local.yield A w\n  1 < length w\n\ngoal (1 subgoal):\n 1. \\<exists>B u C v.\n       local.yield B u \\<and>\n       local.yield C v \\<and> w = u @ v \\<and> (A, NN B C) \\<in> set P", "by(induction rule: yield.induct) (auto)"], ["proof (state)\nthis:\n  \\<exists>B u C v.\n     local.yield B u \\<and>\n     local.yield C v \\<and> w = u @ v \\<and> (A, NN B C) \\<in> set P\n\ngoal (1 subgoal):\n 1. \\<exists>B u C v.\n       local.yield B u \\<and>\n       local.yield C v \\<and>\n       w = u @ v \\<and> (A, NN B C) \\<in> set P \\<Longrightarrow>\n    local.yield A w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B u C v.\n       local.yield B u \\<and>\n       local.yield C v \\<and>\n       w = u @ v \\<and> (A, NN B C) \\<in> set P \\<Longrightarrow>\n    local.yield A w", "assume ?R"], ["proof (state)\nthis:\n  \\<exists>B u C v.\n     local.yield B u \\<and>\n     local.yield C v \\<and> w = u @ v \\<and> (A, NN B C) \\<in> set P\n\ngoal (1 subgoal):\n 1. \\<exists>B u C v.\n       local.yield B u \\<and>\n       local.yield C v \\<and>\n       w = u @ v \\<and> (A, NN B C) \\<in> set P \\<Longrightarrow>\n    local.yield A w", "with assms"], ["proof (chain)\npicking this:\n  1 < length w\n  \\<exists>B u C v.\n     local.yield B u \\<and>\n     local.yield C v \\<and> w = u @ v \\<and> (A, NN B C) \\<in> set P", "show ?L"], ["proof (prove)\nusing this:\n  1 < length w\n  \\<exists>B u C v.\n     local.yield B u \\<and>\n     local.yield C v \\<and> w = u @ v \\<and> (A, NN B C) \\<in> set P\n\ngoal (1 subgoal):\n 1. local.yield A w", "by (auto simp add: yield.intros)"], ["proof (state)\nthis:\n  local.yield A w\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"CYK on Lists\""], ["", "fun cyk :: \"'t list \\<Rightarrow> 'n list\" where\n\"cyk [] = []\" |\n\"cyk [a] = [A . (A, T a') <- P, a'= a]\" |\n\"cyk w =\n  [A. k <- [1..<length w], B <- cyk (take k w), C <- cyk (drop k w), (A, NN B' C') <- P, B' = B, C' = C]\""], ["", "lemma set_cyk_simp2[simp]: \"length w \\<ge> 2 \\<Longrightarrow> set(cyk w) =\n  (\\<Union>k \\<in> {1..length w - 1}. \\<Union>B \\<in> set(cyk (take k w)). \\<Union>C \\<in> set(cyk (drop k w)). {A. (A, NN B C) \\<in> set P})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length w \\<Longrightarrow>\n    set (local.cyk w) =\n    (\\<Union>k\\<in>{1..length w - 1}.\n        \\<Union>B\\<in>set (local.cyk (take k w)).\n           \\<Union>C\\<in>set (local.cyk (drop k w)).\n              {A. (A, NN B C) \\<in> set P})", "apply(cases w)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 \\<le> length w; w = []\\<rbrakk>\n    \\<Longrightarrow> set (local.cyk w) =\n                      (\\<Union>k\\<in>{1..length w - 1}.\n                          \\<Union>B\\<in>set (local.cyk (take k w)).\n                             \\<Union>C\\<in>set (local.cyk (drop k w)).\n                                {A. (A, NN B C) \\<in> set P})\n 2. \\<And>a list.\n       \\<lbrakk>2 \\<le> length w; w = a # list\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk w) =\n                         (\\<Union>k\\<in>{1..length w - 1}.\n                             \\<Union>B\\<in>set (local.cyk (take k w)).\n                                \\<Union>C\\<in>set (local.cyk (drop k w)).\n                                   {A. (A, NN B C) \\<in> set P})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>2 \\<le> length w; w = a # list\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk w) =\n                         (\\<Union>k\\<in>{1..length w - 1}.\n                             \\<Union>B\\<in>set (local.cyk (take k w)).\n                                \\<Union>C\\<in>set (local.cyk (drop k w)).\n                                   {A. (A, NN B C) \\<in> set P})", "subgoal for _ w'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 \\<le> length w; w = a_ # w'\\<rbrakk>\n    \\<Longrightarrow> set (local.cyk w) =\n                      (\\<Union>k\\<in>{1..length w - 1}.\n                          \\<Union>B\\<in>set (local.cyk (take k w)).\n                             \\<Union>C\\<in>set (local.cyk (drop k w)).\n                                {A. (A, NN B C) \\<in> set P})", "apply(case_tac w')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 \\<le> length w; w = a_ # w'; w' = []\\<rbrakk>\n    \\<Longrightarrow> set (local.cyk w) =\n                      (\\<Union>k\\<in>{1..length w - 1}.\n                          \\<Union>B\\<in>set (local.cyk (take k w)).\n                             \\<Union>C\\<in>set (local.cyk (drop k w)).\n                                {A. (A, NN B C) \\<in> set P})\n 2. \\<And>aa list.\n       \\<lbrakk>2 \\<le> length w; w = a_ # w'; w' = aa # list\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk w) =\n                         (\\<Union>k\\<in>{1..length w - 1}.\n                             \\<Union>B\\<in>set (local.cyk (take k w)).\n                                \\<Union>C\\<in>set (local.cyk (drop k w)).\n                                   {A. (A, NN B C) \\<in> set P})", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>aa list xb xc aaa.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take (length list) (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop (length list) (a_ # aa # list)));\n        (aaa, NN xb xc) \\<in> set P; Suc 0 \\<le> length list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{Suc 0..Suc (length list)}.\n                            \\<exists>xa\\<in>set\n       (local.cyk (take x (a_ # aa # list))).\n                               \\<exists>x\n  \\<in>set (local.cyk (drop x (a_ # aa # list))).\n                                  (aaa, NN xa x) \\<in> set P\n 2. \\<And>aa list xa xb xc aaa.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        (aaa, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa < length list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{Suc 0..Suc (length list)}.\n                            \\<exists>xa\\<in>set\n       (local.cyk (take x (a_ # aa # list))).\n                               \\<exists>x\n  \\<in>set (local.cyk (drop x (a_ # aa # list))).\n                                  (aaa, NN xa x) \\<in> set P\n 3. \\<And>aa list xa xb aaa.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xa \\<in> set (local.cyk (a_ # take (length list) (aa # list)));\n        xb \\<in> set (local.cyk (drop (length list) (aa # list)));\n        (aaa, NN xa xb) \\<in> set P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{Suc 0..Suc (length list)}.\n                            \\<exists>xa\\<in>set\n       (local.cyk (take x (a_ # aa # list))).\n                               \\<exists>x\n  \\<in>set (local.cyk (drop x (a_ # aa # list))).\n                                  (aaa, NN xa x) \\<in> set P\n 4. \\<And>aa list x xa xb xc.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        \\<forall>xa\\<in>set (local.cyk\n                              (a_ # take (length list) (aa # list))).\n           \\<forall>xb\\<in>set (local.cyk (drop (length list) (aa # list))).\n              (x, NN xa xb) \\<notin> set P;\n        (x, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa \\<le> Suc (length list)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> length list\n 5. \\<And>aa list x xa xb xc.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        \\<forall>xa\\<in>set (local.cyk\n                              (a_ # take (length list) (aa # list))).\n           \\<forall>xb\\<in>set (local.cyk (drop (length list) (aa # list))).\n              (x, NN xa xb) \\<notin> set P;\n        (x, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa \\<le> Suc (length list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (xa = length list \\<or>\n                             Suc 0 \\<le> xa \\<and> xa < length list) \\<and>\n                            (\\<exists>xb\n\\<in>set (local.cyk (take xa (a_ # aa # list))).\n                                \\<exists>xa\n   \\<in>set (local.cyk (drop xa (a_ # aa # list))).\n                                   (x, NN xb xa) \\<in> set P)", "apply force"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa list xa xb xc aaa.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        (aaa, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa < length list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{Suc 0..Suc (length list)}.\n                            \\<exists>xa\\<in>set\n       (local.cyk (take x (a_ # aa # list))).\n                               \\<exists>x\n  \\<in>set (local.cyk (drop x (a_ # aa # list))).\n                                  (aaa, NN xa x) \\<in> set P\n 2. \\<And>aa list xa xb aaa.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xa \\<in> set (local.cyk (a_ # take (length list) (aa # list)));\n        xb \\<in> set (local.cyk (drop (length list) (aa # list)));\n        (aaa, NN xa xb) \\<in> set P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{Suc 0..Suc (length list)}.\n                            \\<exists>xa\\<in>set\n       (local.cyk (take x (a_ # aa # list))).\n                               \\<exists>x\n  \\<in>set (local.cyk (drop x (a_ # aa # list))).\n                                  (aaa, NN xa x) \\<in> set P\n 3. \\<And>aa list x xa xb xc.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        \\<forall>xa\\<in>set (local.cyk\n                              (a_ # take (length list) (aa # list))).\n           \\<forall>xb\\<in>set (local.cyk (drop (length list) (aa # list))).\n              (x, NN xa xb) \\<notin> set P;\n        (x, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa \\<le> Suc (length list)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> length list\n 4. \\<And>aa list x xa xb xc.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        \\<forall>xa\\<in>set (local.cyk\n                              (a_ # take (length list) (aa # list))).\n           \\<forall>xb\\<in>set (local.cyk (drop (length list) (aa # list))).\n              (x, NN xa xb) \\<notin> set P;\n        (x, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa \\<le> Suc (length list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (xa = length list \\<or>\n                             Suc 0 \\<le> xa \\<and> xa < length list) \\<and>\n                            (\\<exists>xb\n\\<in>set (local.cyk (take xa (a_ # aa # list))).\n                                \\<exists>xa\n   \\<in>set (local.cyk (drop xa (a_ # aa # list))).\n                                   (x, NN xb xa) \\<in> set P)", "apply force"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa list xa xb aaa.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xa \\<in> set (local.cyk (a_ # take (length list) (aa # list)));\n        xb \\<in> set (local.cyk (drop (length list) (aa # list)));\n        (aaa, NN xa xb) \\<in> set P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{Suc 0..Suc (length list)}.\n                            \\<exists>xa\\<in>set\n       (local.cyk (take x (a_ # aa # list))).\n                               \\<exists>x\n  \\<in>set (local.cyk (drop x (a_ # aa # list))).\n                                  (aaa, NN xa x) \\<in> set P\n 2. \\<And>aa list x xa xb xc.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        \\<forall>xa\\<in>set (local.cyk\n                              (a_ # take (length list) (aa # list))).\n           \\<forall>xb\\<in>set (local.cyk (drop (length list) (aa # list))).\n              (x, NN xa xb) \\<notin> set P;\n        (x, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa \\<le> Suc (length list)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> length list\n 3. \\<And>aa list x xa xb xc.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        \\<forall>xa\\<in>set (local.cyk\n                              (a_ # take (length list) (aa # list))).\n           \\<forall>xb\\<in>set (local.cyk (drop (length list) (aa # list))).\n              (x, NN xa xb) \\<notin> set P;\n        (x, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa \\<le> Suc (length list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (xa = length list \\<or>\n                             Suc 0 \\<le> xa \\<and> xa < length list) \\<and>\n                            (\\<exists>xb\n\\<in>set (local.cyk (take xa (a_ # aa # list))).\n                                \\<exists>xa\n   \\<in>set (local.cyk (drop xa (a_ # aa # list))).\n                                   (x, NN xb xa) \\<in> set P)", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa list x xa xb xc.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        \\<forall>xa\\<in>set (local.cyk\n                              (a_ # take (length list) (aa # list))).\n           \\<forall>xb\\<in>set (local.cyk (drop (length list) (aa # list))).\n              (x, NN xa xb) \\<notin> set P;\n        (x, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa \\<le> Suc (length list)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> length list\n 2. \\<And>aa list x xa xb xc.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        \\<forall>xa\\<in>set (local.cyk\n                              (a_ # take (length list) (aa # list))).\n           \\<forall>xb\\<in>set (local.cyk (drop (length list) (aa # list))).\n              (x, NN xa xb) \\<notin> set P;\n        (x, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa \\<le> Suc (length list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (xa = length list \\<or>\n                             Suc 0 \\<le> xa \\<and> xa < length list) \\<and>\n                            (\\<exists>xb\n\\<in>set (local.cyk (take xa (a_ # aa # list))).\n                                \\<exists>xa\n   \\<in>set (local.cyk (drop xa (a_ # aa # list))).\n                                   (x, NN xb xa) \\<in> set P)", "using le_Suc_eq le_simps(3)"], ["proof (prove)\nusing this:\n  (?m \\<le> Suc ?n) = (?m \\<le> ?n \\<or> ?m = Suc ?n)\n  (Suc ?m \\<le> ?n) = (?m < ?n)\n\ngoal (2 subgoals):\n 1. \\<And>aa list x xa xb xc.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        \\<forall>xa\\<in>set (local.cyk\n                              (a_ # take (length list) (aa # list))).\n           \\<forall>xb\\<in>set (local.cyk (drop (length list) (aa # list))).\n              (x, NN xa xb) \\<notin> set P;\n        (x, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa \\<le> Suc (length list)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> length list\n 2. \\<And>aa list x xa xb xc.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        \\<forall>xa\\<in>set (local.cyk\n                              (a_ # take (length list) (aa # list))).\n           \\<forall>xb\\<in>set (local.cyk (drop (length list) (aa # list))).\n              (x, NN xa xb) \\<notin> set P;\n        (x, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa \\<le> Suc (length list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (xa = length list \\<or>\n                             Suc 0 \\<le> xa \\<and> xa < length list) \\<and>\n                            (\\<exists>xb\n\\<in>set (local.cyk (take xa (a_ # aa # list))).\n                                \\<exists>xa\n   \\<in>set (local.cyk (drop xa (a_ # aa # list))).\n                                   (x, NN xb xa) \\<in> set P)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list x xa xb xc.\n       \\<lbrakk>w = a_ # aa # list; w' = aa # list;\n        xb \\<in> set (local.cyk (take xa (a_ # aa # list)));\n        xc \\<in> set (local.cyk (drop xa (a_ # aa # list)));\n        \\<forall>xa\\<in>set (local.cyk\n                              (a_ # take (length list) (aa # list))).\n           \\<forall>xb\\<in>set (local.cyk (drop (length list) (aa # list))).\n              (x, NN xa xb) \\<notin> set P;\n        (x, NN xb xc) \\<in> set P; Suc 0 \\<le> xa;\n        xa \\<le> Suc (length list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (xa = length list \\<or>\n                             Suc 0 \\<le> xa \\<and> xa < length list) \\<and>\n                            (\\<exists>xb\n\\<in>set (local.cyk (take xa (a_ # aa # list))).\n                                \\<exists>xa\n   \\<in>set (local.cyk (drop xa (a_ # aa # list))).\n                                   (x, NN xb xa) \\<in> set P)", "by (metis drop_Suc_Cons le_Suc_eq le_antisym not_le take_Suc_Cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare cyk.simps(3)[simp del]"], ["", "lemma cyk_correct: \"set(cyk w) = {N. yield N w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk w) = {N. local.yield N w}", "proof (induction w rule: cyk.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. set (local.cyk []) = {N. local.yield N []}\n 2. \\<And>a. set (local.cyk [a]) = {N. local.yield N [a]}\n 3. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. set (local.cyk []) = {N. local.yield N []}\n 2. \\<And>a. set (local.cyk [a]) = {N. local.yield N [a]}\n 3. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk []) = {N. local.yield N []}", "by (auto dest: yield_not_Nil)"], ["proof (state)\nthis:\n  set (local.cyk []) = {N. local.yield N []}\n\ngoal (2 subgoals):\n 1. \\<And>a. set (local.cyk [a]) = {N. local.yield N [a]}\n 2. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. set (local.cyk [a]) = {N. local.yield N [a]}\n 2. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a. set (local.cyk [a]) = {N. local.yield N [a]}\n 2. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk [a_]) = {N. local.yield N [a_]}", "by (auto simp add: yield_eq1)"], ["proof (state)\nthis:\n  set (local.cyk [a_]) = {N. local.yield N [a_]}\n\ngoal (1 subgoal):\n 1. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "case (3 v vb vc)"], ["proof (state)\nthis:\n  ?x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n  set (local.cyk (take ?x (v # vb # vc))) =\n  {N. local.yield N (take ?x (v # vb # vc))}\n  \\<lbrakk>?x \\<in> set [1..<length (v # vb # vc)];\n   ?xa \\<in> set (local.cyk (take ?x (v # vb # vc)))\\<rbrakk>\n  \\<Longrightarrow> set (local.cyk (drop ?x (v # vb # vc))) =\n                    {N. local.yield N (drop ?x (v # vb # vc))}\n\ngoal (1 subgoal):\n 1. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "let ?w = \"v # vb # vc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "have \"set(cyk ?w) = (\\<Union>k\\<in>{1..length ?w-1}. {N. \\<exists>A B. (N, NN A B) \\<in> set P \\<and>\n             yield A (take k ?w) \\<and> yield B (drop k ?w)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk (v # vb # vc)) =\n    (\\<Union>k\\<in>{1..length (v # vb # vc) - 1}.\n        {N. \\<exists>A B.\n               (N, NN A B) \\<in> set P \\<and>\n               local.yield A (take k (v # vb # vc)) \\<and>\n               local.yield B (drop k (v # vb # vc))})", "by(auto simp add:\"3.IH\" simp del:upt_Suc)"], ["proof (state)\nthis:\n  set (local.cyk (v # vb # vc)) =\n  (\\<Union>k\\<in>{1..length (v # vb # vc) - 1}.\n      {N. \\<exists>A B.\n             (N, NN A B) \\<in> set P \\<and>\n             local.yield A (take k (v # vb # vc)) \\<and>\n             local.yield B (drop k (v # vb # vc))})\n\ngoal (1 subgoal):\n 1. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "also"], ["proof (state)\nthis:\n  set (local.cyk (v # vb # vc)) =\n  (\\<Union>k\\<in>{1..length (v # vb # vc) - 1}.\n      {N. \\<exists>A B.\n             (N, NN A B) \\<in> set P \\<and>\n             local.yield A (take k (v # vb # vc)) \\<and>\n             local.yield B (drop k (v # vb # vc))})\n\ngoal (1 subgoal):\n 1. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "have \"... = {N. \\<exists>A B. (N, NN A B) \\<in> set P \\<and>\n              (\\<exists>u v. yield A u \\<and> yield B v \\<and> ?w = u@v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>k\\<in>{1..length (v # vb # vc) - 1}.\n        {N. \\<exists>A B.\n               (N, NN A B) \\<in> set P \\<and>\n               local.yield A (take k (v # vb # vc)) \\<and>\n               local.yield B (drop k (v # vb # vc))}) =\n    {N. \\<exists>A B.\n           (N, NN A B) \\<in> set P \\<and>\n           (\\<exists>u va.\n               local.yield A u \\<and>\n               local.yield B va \\<and> v # vb # vc = u @ va)}", "by(fastforce simp add: append_iff_take_drop1 yield_not_Nil)"], ["proof (state)\nthis:\n  (\\<Union>k\\<in>{1..length (v # vb # vc) - 1}.\n      {N. \\<exists>A B.\n             (N, NN A B) \\<in> set P \\<and>\n             local.yield A (take k (v # vb # vc)) \\<and>\n             local.yield B (drop k (v # vb # vc))}) =\n  {N. \\<exists>A B.\n         (N, NN A B) \\<in> set P \\<and>\n         (\\<exists>u va.\n             local.yield A u \\<and>\n             local.yield B va \\<and> v # vb # vc = u @ va)}\n\ngoal (1 subgoal):\n 1. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "also"], ["proof (state)\nthis:\n  (\\<Union>k\\<in>{1..length (v # vb # vc) - 1}.\n      {N. \\<exists>A B.\n             (N, NN A B) \\<in> set P \\<and>\n             local.yield A (take k (v # vb # vc)) \\<and>\n             local.yield B (drop k (v # vb # vc))}) =\n  {N. \\<exists>A B.\n         (N, NN A B) \\<in> set P \\<and>\n         (\\<exists>u va.\n             local.yield A u \\<and>\n             local.yield B va \\<and> v # vb # vc = u @ va)}\n\ngoal (1 subgoal):\n 1. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "have \"... = {N. yield N ?w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {N. \\<exists>A B.\n           (N, NN A B) \\<in> set P \\<and>\n           (\\<exists>u va.\n               local.yield A u \\<and>\n               local.yield B va \\<and> v # vb # vc = u @ va)} =\n    {N. local.yield N (v # vb # vc)}", "using yield_eq2[of ?w]"], ["proof (prove)\nusing this:\n  1 < length (v # vb # vc) \\<Longrightarrow>\n  local.yield ?A (v # vb # vc) =\n  (\\<exists>B u C va.\n      local.yield B u \\<and>\n      local.yield C va \\<and>\n      v # vb # vc = u @ va \\<and> (?A, NN B C) \\<in> set P)\n\ngoal (1 subgoal):\n 1. {N. \\<exists>A B.\n           (N, NN A B) \\<in> set P \\<and>\n           (\\<exists>u va.\n               local.yield A u \\<and>\n               local.yield B va \\<and> v # vb # vc = u @ va)} =\n    {N. local.yield N (v # vb # vc)}", "by(auto)"], ["proof (state)\nthis:\n  {N. \\<exists>A B.\n         (N, NN A B) \\<in> set P \\<and>\n         (\\<exists>u va.\n             local.yield A u \\<and>\n             local.yield B va \\<and> v # vb # vc = u @ va)} =\n  {N. local.yield N (v # vb # vc)}\n\ngoal (1 subgoal):\n 1. \\<And>v vb vc.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<length (v # vb # vc)] \\<Longrightarrow>\n                   set (local.cyk (take x (v # vb # vc))) =\n                   {N. local.yield N (take x (v # vb # vc))};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<length (v # vb # vc)];\n            xa \\<in> set (local.cyk (take x (v # vb # vc)))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk (drop x (v # vb # vc))) =\n                             {N. local.yield N\n                                  (drop x (v # vb # vc))}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk (v # vb # vc)) =\n                         {N. local.yield N (v # vb # vc)}", "finally"], ["proof (chain)\npicking this:\n  set (local.cyk (v # vb # vc)) = {N. local.yield N (v # vb # vc)}", "show ?case"], ["proof (prove)\nusing this:\n  set (local.cyk (v # vb # vc)) = {N. local.yield N (v # vb # vc)}\n\ngoal (1 subgoal):\n 1. set (local.cyk (v # vb # vc)) = {N. local.yield N (v # vb # vc)}", "."], ["proof (state)\nthis:\n  set (local.cyk (v # vb # vc)) = {N. local.yield N (v # vb # vc)}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"CYK on Lists and Index\""], ["", "fun cyk2 :: \"'t list \\<Rightarrow> nat * nat \\<Rightarrow> 'n list\" where\n\"cyk2 w (i,0) = []\" |\n\"cyk2 w (i,Suc 0) = [A . (A, T a) <- P, a = w!i]\" |\n\"cyk2 w (i,n) =\n[A. k <- [1..<n], B <- cyk2 w (i,k), C <- cyk2 w (i+k,n-k), (A, NN B' C') <- P, B' = B, C' = C]\""], ["", "lemma set_aux: \"(\\<Union>xb\\<in>set P. {A. (A, NN B C) = xb}) = {A. (A, NN B C) \\<in> set P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>xb\\<in>set P. {A. (A, NN B C) = xb}) =\n    {A. (A, NN B C) \\<in> set P}", "by auto"], ["", "lemma cyk2_eq_cyk: \"i+n \\<le> length w \\<Longrightarrow> set(cyk2 w (i,n)) = set(cyk (take n (drop i w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + n \\<le> length w \\<Longrightarrow>\n    set (local.cyk2 w (i, n)) = set (local.cyk (take n (drop i w)))", "proof(induction w \"(i,n)\" arbitrary: i n rule: cyk2.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>w i.\n       i + 0 \\<le> length w \\<Longrightarrow>\n       set (local.cyk2 w (i, 0)) = set (local.cyk (take 0 (drop i w)))\n 2. \\<And>w i.\n       i + Suc 0 \\<le> length w \\<Longrightarrow>\n       set (local.cyk2 w (i, Suc 0)) =\n       set (local.cyk (take (Suc 0) (drop i w)))\n 3. \\<And>w i va.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n                    i + x \\<le> length w\\<rbrakk>\n                   \\<Longrightarrow> set (local.cyk2 w (i, x)) =\n                                     set (local.cyk (take x (drop i w)));\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk2 w (i, x));\n            i + x + (Suc (Suc va) - x) \\<le> length w\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk2 w (i + x, Suc (Suc va) - x)) =\n                             set (local.cyk\n                                   (take (Suc (Suc va) - x)\n                                     (drop (i + x) w)));\n        i + Suc (Suc va) \\<le> length w\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk2 w (i, Suc (Suc va))) =\n                         set (local.cyk (take (Suc (Suc va)) (drop i w)))", "case 1"], ["proof (state)\nthis:\n  i_ + 0 \\<le> length w_\n\ngoal (3 subgoals):\n 1. \\<And>w i.\n       i + 0 \\<le> length w \\<Longrightarrow>\n       set (local.cyk2 w (i, 0)) = set (local.cyk (take 0 (drop i w)))\n 2. \\<And>w i.\n       i + Suc 0 \\<le> length w \\<Longrightarrow>\n       set (local.cyk2 w (i, Suc 0)) =\n       set (local.cyk (take (Suc 0) (drop i w)))\n 3. \\<And>w i va.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n                    i + x \\<le> length w\\<rbrakk>\n                   \\<Longrightarrow> set (local.cyk2 w (i, x)) =\n                                     set (local.cyk (take x (drop i w)));\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk2 w (i, x));\n            i + x + (Suc (Suc va) - x) \\<le> length w\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk2 w (i + x, Suc (Suc va) - x)) =\n                             set (local.cyk\n                                   (take (Suc (Suc va) - x)\n                                     (drop (i + x) w)));\n        i + Suc (Suc va) \\<le> length w\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk2 w (i, Suc (Suc va))) =\n                         set (local.cyk (take (Suc (Suc va)) (drop i w)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk2 w_ (i_, 0)) = set (local.cyk (take 0 (drop i_ w_)))", "by(simp)"], ["proof (state)\nthis:\n  set (local.cyk2 w_ (i_, 0)) = set (local.cyk (take 0 (drop i_ w_)))\n\ngoal (2 subgoals):\n 1. \\<And>w i.\n       i + Suc 0 \\<le> length w \\<Longrightarrow>\n       set (local.cyk2 w (i, Suc 0)) =\n       set (local.cyk (take (Suc 0) (drop i w)))\n 2. \\<And>w i va.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n                    i + x \\<le> length w\\<rbrakk>\n                   \\<Longrightarrow> set (local.cyk2 w (i, x)) =\n                                     set (local.cyk (take x (drop i w)));\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk2 w (i, x));\n            i + x + (Suc (Suc va) - x) \\<le> length w\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk2 w (i + x, Suc (Suc va) - x)) =\n                             set (local.cyk\n                                   (take (Suc (Suc va) - x)\n                                     (drop (i + x) w)));\n        i + Suc (Suc va) \\<le> length w\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk2 w (i, Suc (Suc va))) =\n                         set (local.cyk (take (Suc (Suc va)) (drop i w)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w i.\n       i + Suc 0 \\<le> length w \\<Longrightarrow>\n       set (local.cyk2 w (i, Suc 0)) =\n       set (local.cyk (take (Suc 0) (drop i w)))\n 2. \\<And>w i va.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n                    i + x \\<le> length w\\<rbrakk>\n                   \\<Longrightarrow> set (local.cyk2 w (i, x)) =\n                                     set (local.cyk (take x (drop i w)));\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk2 w (i, x));\n            i + x + (Suc (Suc va) - x) \\<le> length w\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk2 w (i + x, Suc (Suc va) - x)) =\n                             set (local.cyk\n                                   (take (Suc (Suc va) - x)\n                                     (drop (i + x) w)));\n        i + Suc (Suc va) \\<le> length w\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk2 w (i, Suc (Suc va))) =\n                         set (local.cyk (take (Suc (Suc va)) (drop i w)))", "case 2"], ["proof (state)\nthis:\n  i_ + Suc 0 \\<le> length w_\n\ngoal (2 subgoals):\n 1. \\<And>w i.\n       i + Suc 0 \\<le> length w \\<Longrightarrow>\n       set (local.cyk2 w (i, Suc 0)) =\n       set (local.cyk (take (Suc 0) (drop i w)))\n 2. \\<And>w i va.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n                    i + x \\<le> length w\\<rbrakk>\n                   \\<Longrightarrow> set (local.cyk2 w (i, x)) =\n                                     set (local.cyk (take x (drop i w)));\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk2 w (i, x));\n            i + x + (Suc (Suc va) - x) \\<le> length w\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk2 w (i + x, Suc (Suc va) - x)) =\n                             set (local.cyk\n                                   (take (Suc (Suc va) - x)\n                                     (drop (i + x) w)));\n        i + Suc (Suc va) \\<le> length w\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk2 w (i, Suc (Suc va))) =\n                         set (local.cyk (take (Suc (Suc va)) (drop i w)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk2 w_ (i_, Suc 0)) =\n    set (local.cyk (take (Suc 0) (drop i_ w_)))", "using \"2.prems\""], ["proof (prove)\nusing this:\n  i_ + Suc 0 \\<le> length w_\n\ngoal (1 subgoal):\n 1. set (local.cyk2 w_ (i_, Suc 0)) =\n    set (local.cyk (take (Suc 0) (drop i_ w_)))", "by(auto simp: hd_drop_conv_nth take_Suc)"], ["proof (state)\nthis:\n  set (local.cyk2 w_ (i_, Suc 0)) =\n  set (local.cyk (take (Suc 0) (drop i_ w_)))\n\ngoal (1 subgoal):\n 1. \\<And>w i va.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n                    i + x \\<le> length w\\<rbrakk>\n                   \\<Longrightarrow> set (local.cyk2 w (i, x)) =\n                                     set (local.cyk (take x (drop i w)));\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk2 w (i, x));\n            i + x + (Suc (Suc va) - x) \\<le> length w\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk2 w (i + x, Suc (Suc va) - x)) =\n                             set (local.cyk\n                                   (take (Suc (Suc va) - x)\n                                     (drop (i + x) w)));\n        i + Suc (Suc va) \\<le> length w\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk2 w (i, Suc (Suc va))) =\n                         set (local.cyk (take (Suc (Suc va)) (drop i w)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w i va.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n                    i + x \\<le> length w\\<rbrakk>\n                   \\<Longrightarrow> set (local.cyk2 w (i, x)) =\n                                     set (local.cyk (take x (drop i w)));\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk2 w (i, x));\n            i + x + (Suc (Suc va) - x) \\<le> length w\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk2 w (i + x, Suc (Suc va) - x)) =\n                             set (local.cyk\n                                   (take (Suc (Suc va) - x)\n                                     (drop (i + x) w)));\n        i + Suc (Suc va) \\<le> length w\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk2 w (i, Suc (Suc va))) =\n                         set (local.cyk (take (Suc (Suc va)) (drop i w)))", "case (3 w i m)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set [1..<Suc (Suc m)]; i + ?x \\<le> length w\\<rbrakk>\n  \\<Longrightarrow> set (local.cyk2 w (i, ?x)) =\n                    set (local.cyk (take ?x (drop i w)))\n  \\<lbrakk>?x \\<in> set [1..<Suc (Suc m)];\n   ?xa \\<in> set (local.cyk2 w (i, ?x));\n   i + ?x + (Suc (Suc m) - ?x) \\<le> length w\\<rbrakk>\n  \\<Longrightarrow> set (local.cyk2 w (i + ?x, Suc (Suc m) - ?x)) =\n                    set (local.cyk\n                          (take (Suc (Suc m) - ?x) (drop (i + ?x) w)))\n  i + Suc (Suc m) \\<le> length w\n\ngoal (1 subgoal):\n 1. \\<And>w i va.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n                    i + x \\<le> length w\\<rbrakk>\n                   \\<Longrightarrow> set (local.cyk2 w (i, x)) =\n                                     set (local.cyk (take x (drop i w)));\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk2 w (i, x));\n            i + x + (Suc (Suc va) - x) \\<le> length w\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk2 w (i + x, Suc (Suc va) - x)) =\n                             set (local.cyk\n                                   (take (Suc (Suc va) - x)\n                                     (drop (i + x) w)));\n        i + Suc (Suc va) \\<le> length w\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk2 w (i, Suc (Suc va))) =\n                         set (local.cyk (take (Suc (Suc va)) (drop i w)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk2 w (i, Suc (Suc m))) =\n    set (local.cyk (take (Suc (Suc m)) (drop i w)))", "using \"3.prems\""], ["proof (prove)\nusing this:\n  i + Suc (Suc m) \\<le> length w\n\ngoal (1 subgoal):\n 1. set (local.cyk2 w (i, Suc (Suc m))) =\n    set (local.cyk (take (Suc (Suc m)) (drop i w)))", "by(simp add: 3(1,2) min.absorb1 min.absorb2 drop_take atLeastLessThanSuc_atLeastAtMost set_aux\n         del:upt_Suc cong: SUP_cong_simp)\n      (simp add: add.commute)"], ["proof (state)\nthis:\n  set (local.cyk2 w (i, Suc (Suc m))) =\n  set (local.cyk (take (Suc (Suc m)) (drop i w)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"CYK S w =  (S \\<in> set(cyk2 w (0, length w)))\""], ["", "theorem CYK_correct: \"CYK S w = yield S w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.CYK S w = local.yield S w", "by(simp add: CYK_def cyk2_eq_cyk cyk_correct)"], ["", "subsubsection \"CYK With Index Function\""], ["", "context\nfixes w :: \"nat \\<Rightarrow> 't\"\nbegin"], ["", "fun cyk_ix :: \"nat * nat \\<Rightarrow> 'n list\" where\n\"cyk_ix (i,0) = []\" |\n\"cyk_ix (i,Suc 0) = [A . (A, T a) <- P, a = w i]\" |\n\"cyk_ix (i,n) =\n  [A. k <- [1..<n], B <- cyk_ix (i,k), C <- cyk_ix (i+k,n-k), (A, NN B' C') <- P, B' = B, C' = C]\""], ["", "subsubsection \\<open>Correctness Proof\\<close>"], ["", "lemma cyk_ix_simp2: \"set(cyk_ix (i,Suc(Suc n))) =\n  (\\<Union>k \\<in> {1..Suc n}. \\<Union>B \\<in> set(cyk_ix (i,k)). \\<Union>C \\<in> set(cyk_ix (i+k,n+2-k)). {A. (A, NN B C) \\<in> set P})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk_ix (i, Suc (Suc n))) =\n    (\\<Union>k\\<in>{1..Suc n}.\n        \\<Union>B\\<in>set (local.cyk_ix (i, k)).\n           \\<Union>C\\<in>set (local.cyk_ix (i + k, n + 2 - k)).\n              {A. (A, NN B C) \\<in> set P})", "by(simp add: atLeastLessThanSuc_atLeastAtMost set_aux del: upt_Suc)"], ["", "declare cyk_ix.simps(3)[simp del]"], ["", "abbreviation (input) \"slice f i j \\<equiv> map f [i..<j]\""], ["", "lemma slice_append_iff_take_drop1: \"u \\<noteq> [] \\<Longrightarrow> v \\<noteq> [] \\<Longrightarrow>\n  slice w i j = u @ v \\<longleftrightarrow> (\\<exists>k. 1 \\<le> k \\<and> k \\<le> j-i-1 \\<and> slice w i (i + k) = u \\<and> slice w (i + k) j = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<noteq> []; v \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (map w [i..<j] = u @ v) =\n                      (\\<exists>k\\<ge>1.\n                          k \\<le> j - i - 1 \\<and>\n                          map w [i..<i + k] = u \\<and>\n                          map w [i + k..<j] = v)", "by(subst append_iff_take_drop1) (auto simp: take_map drop_map Bex_def)"], ["", "lemma cyk_ix_correct:\n  \"set(cyk_ix (i,n)) = {N. yield N (slice w i (i+n))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk_ix (i, n)) = {N. local.yield N (map w [i..<i + n])}", "proof (induction \"(i,n)\" arbitrary: i n rule: cyk_ix.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       set (local.cyk_ix (i, 0)) = {N. local.yield N (map w [i..<i + 0])}\n 2. \\<And>i.\n       set (local.cyk_ix (i, Suc 0)) =\n       {N. local.yield N (map w [i..<i + Suc 0])}\n 3. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>i.\n       set (local.cyk_ix (i, 0)) = {N. local.yield N (map w [i..<i + 0])}\n 2. \\<And>i.\n       set (local.cyk_ix (i, Suc 0)) =\n       {N. local.yield N (map w [i..<i + Suc 0])}\n 3. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk_ix (i_, 0)) = {N. local.yield N (map w [i_..<i_ + 0])}", "by (auto simp: dest: yield_not_Nil)"], ["proof (state)\nthis:\n  set (local.cyk_ix (i_, 0)) = {N. local.yield N (map w [i_..<i_ + 0])}\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       set (local.cyk_ix (i, Suc 0)) =\n       {N. local.yield N (map w [i..<i + Suc 0])}\n 2. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       set (local.cyk_ix (i, Suc 0)) =\n       {N. local.yield N (map w [i..<i + Suc 0])}\n 2. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>i.\n       set (local.cyk_ix (i, Suc 0)) =\n       {N. local.yield N (map w [i..<i + Suc 0])}\n 2. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk_ix (i_, Suc 0)) =\n    {N. local.yield N (map w [i_..<i_ + Suc 0])}", "by (auto simp add: yield_eq1)"], ["proof (state)\nthis:\n  set (local.cyk_ix (i_, Suc 0)) =\n  {N. local.yield N (map w [i_..<i_ + Suc 0])}\n\ngoal (1 subgoal):\n 1. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "case (3 i m)"], ["proof (state)\nthis:\n  ?x \\<in> set [1..<Suc (Suc m)] \\<Longrightarrow>\n  set (local.cyk_ix (i, ?x)) = {N. local.yield N (map w [i..<i + ?x])}\n  \\<lbrakk>?x \\<in> set [1..<Suc (Suc m)];\n   ?xa \\<in> set (local.cyk_ix (i, ?x))\\<rbrakk>\n  \\<Longrightarrow> set (local.cyk_ix (i + ?x, Suc (Suc m) - ?x)) =\n                    {N. local.yield N\n                         (map w [i + ?x..<i + ?x + (Suc (Suc m) - ?x)])}\n\ngoal (1 subgoal):\n 1. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "let ?n = \"Suc(Suc m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "let ?w = \"slice w i (i+?n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "have \"set(cyk_ix (i,?n)) = (\\<Union>k\\<in>{1..Suc m}. {N. \\<exists>A B. (N, NN A B) \\<in> set P \\<and>\n             yield A (slice w i (i+k)) \\<and> yield B (slice w (i+k) (i+?n))})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.cyk_ix (i, Suc (Suc m))) =\n    (\\<Union>k\\<in>{1..Suc m}.\n        {N. \\<exists>A B.\n               (N, NN A B) \\<in> set P \\<and>\n               local.yield A (map w [i..<i + k]) \\<and>\n               local.yield B (map w [i + k..<i + Suc (Suc m)])})", "by(auto simp add: 3 cyk_ix_simp2 simp del: upt_Suc)"], ["proof (state)\nthis:\n  set (local.cyk_ix (i, Suc (Suc m))) =\n  (\\<Union>k\\<in>{1..Suc m}.\n      {N. \\<exists>A B.\n             (N, NN A B) \\<in> set P \\<and>\n             local.yield A (map w [i..<i + k]) \\<and>\n             local.yield B (map w [i + k..<i + Suc (Suc m)])})\n\ngoal (1 subgoal):\n 1. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "also"], ["proof (state)\nthis:\n  set (local.cyk_ix (i, Suc (Suc m))) =\n  (\\<Union>k\\<in>{1..Suc m}.\n      {N. \\<exists>A B.\n             (N, NN A B) \\<in> set P \\<and>\n             local.yield A (map w [i..<i + k]) \\<and>\n             local.yield B (map w [i + k..<i + Suc (Suc m)])})\n\ngoal (1 subgoal):\n 1. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "have \"... = {N. \\<exists>A B. (N, NN A B) \\<in> set P \\<and>\n              (\\<exists>u v. yield A u \\<and> yield B v \\<and> slice w i (i+?n) = u@v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>k\\<in>{1..Suc m}.\n        {N. \\<exists>A B.\n               (N, NN A B) \\<in> set P \\<and>\n               local.yield A (map w [i..<i + k]) \\<and>\n               local.yield B (map w [i + k..<i + Suc (Suc m)])}) =\n    {N. \\<exists>A B.\n           (N, NN A B) \\<in> set P \\<and>\n           (\\<exists>u v.\n               local.yield A u \\<and>\n               local.yield B v \\<and> map w [i..<i + Suc (Suc m)] = u @ v)}", "by(fastforce simp del: upt_Suc simp: slice_append_iff_take_drop1 yield_not_Nil cong: conj_cong)"], ["proof (state)\nthis:\n  (\\<Union>k\\<in>{1..Suc m}.\n      {N. \\<exists>A B.\n             (N, NN A B) \\<in> set P \\<and>\n             local.yield A (map w [i..<i + k]) \\<and>\n             local.yield B (map w [i + k..<i + Suc (Suc m)])}) =\n  {N. \\<exists>A B.\n         (N, NN A B) \\<in> set P \\<and>\n         (\\<exists>u v.\n             local.yield A u \\<and>\n             local.yield B v \\<and> map w [i..<i + Suc (Suc m)] = u @ v)}\n\ngoal (1 subgoal):\n 1. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "also"], ["proof (state)\nthis:\n  (\\<Union>k\\<in>{1..Suc m}.\n      {N. \\<exists>A B.\n             (N, NN A B) \\<in> set P \\<and>\n             local.yield A (map w [i..<i + k]) \\<and>\n             local.yield B (map w [i + k..<i + Suc (Suc m)])}) =\n  {N. \\<exists>A B.\n         (N, NN A B) \\<in> set P \\<and>\n         (\\<exists>u v.\n             local.yield A u \\<and>\n             local.yield B v \\<and> map w [i..<i + Suc (Suc m)] = u @ v)}\n\ngoal (1 subgoal):\n 1. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "have \"... = {N. yield N ?w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {N. \\<exists>A B.\n           (N, NN A B) \\<in> set P \\<and>\n           (\\<exists>u v.\n               local.yield A u \\<and>\n               local.yield B v \\<and>\n               map w [i..<i + Suc (Suc m)] = u @ v)} =\n    {N. local.yield N (map w [i..<i + Suc (Suc m)])}", "using yield_eq2[of ?w]"], ["proof (prove)\nusing this:\n  1 < length (map w [i..<i + Suc (Suc m)]) \\<Longrightarrow>\n  local.yield ?A (map w [i..<i + Suc (Suc m)]) =\n  (\\<exists>B u C v.\n      local.yield B u \\<and>\n      local.yield C v \\<and>\n      map w [i..<i + Suc (Suc m)] = u @ v \\<and> (?A, NN B C) \\<in> set P)\n\ngoal (1 subgoal):\n 1. {N. \\<exists>A B.\n           (N, NN A B) \\<in> set P \\<and>\n           (\\<exists>u v.\n               local.yield A u \\<and>\n               local.yield B v \\<and>\n               map w [i..<i + Suc (Suc m)] = u @ v)} =\n    {N. local.yield N (map w [i..<i + Suc (Suc m)])}", "by(auto)"], ["proof (state)\nthis:\n  {N. \\<exists>A B.\n         (N, NN A B) \\<in> set P \\<and>\n         (\\<exists>u v.\n             local.yield A u \\<and>\n             local.yield B v \\<and> map w [i..<i + Suc (Suc m)] = u @ v)} =\n  {N. local.yield N (map w [i..<i + Suc (Suc m)])}\n\ngoal (1 subgoal):\n 1. \\<And>i va.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [1..<Suc (Suc va)] \\<Longrightarrow>\n                   set (local.cyk_ix (i, x)) =\n                   {N. local.yield N (map w [i..<i + x])};\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set [1..<Suc (Suc va)];\n            xa \\<in> set (local.cyk_ix (i, x))\\<rbrakk>\n           \\<Longrightarrow> set (local.cyk_ix (i + x, Suc (Suc va) - x)) =\n                             {N. local.yield N\n                                  (map w\n                                    [i + x..<\n                                     i + x + (Suc (Suc va) - x)])}\\<rbrakk>\n       \\<Longrightarrow> set (local.cyk_ix (i, Suc (Suc va))) =\n                         {N. local.yield N (map w [i..<i + Suc (Suc va)])}", "finally"], ["proof (chain)\npicking this:\n  set (local.cyk_ix (i, Suc (Suc m))) =\n  {N. local.yield N (map w [i..<i + Suc (Suc m)])}", "show ?case"], ["proof (prove)\nusing this:\n  set (local.cyk_ix (i, Suc (Suc m))) =\n  {N. local.yield N (map w [i..<i + Suc (Suc m)])}\n\ngoal (1 subgoal):\n 1. set (local.cyk_ix (i, Suc (Suc m))) =\n    {N. local.yield N (map w [i..<i + Suc (Suc m)])}", "."], ["proof (state)\nthis:\n  set (local.cyk_ix (i, Suc (Suc m))) =\n  {N. local.yield N (map w [i..<i + Suc (Suc m)])}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Functional Memoization\\<close>"], ["", "memoize_fun cyk_ix\\<^sub>m: cyk_ix with_memory dp_consistency_mapping"], ["", "monadifies (state) cyk_ix.simps"], ["", "thm cyk_ix\\<^sub>m'.simps"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) local.cyk_ix local.cyk_ix\\<^sub>m'", "by memoize_prover"], ["", "print_theorems"], ["", "lemmas [code] = cyk_ix\\<^sub>m.memoized_correct"], ["", "subsubsection \\<open>Imperative Memoization\\<close>"], ["", "context\n  fixes n :: nat\nbegin"], ["", "context\n  fixes mem :: \"'n list option array\"\nbegin"], ["", "memoize_fun cyk_ix\\<^sub>h: cyk_ix\n  with_memory dp_consistency_heap_default where bound = \"Bound (0, 0) (n, n)\" and mem=\"mem\""], ["", "monadifies (heap) cyk_ix.simps"], ["", "context includes heap_monad_syntax begin"], ["", "thm cyk_ix\\<^sub>h'.simps cyk_ix\\<^sub>h_def"], ["", "end"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. cyk_ix\\<^sub>h.consistentDP local.cyk_ix\\<^sub>h'", "by memoize_prover"], ["", "lemmas memoized_empty = cyk_ix\\<^sub>h.memoized_empty"], ["", "lemmas init_success = cyk_ix\\<^sub>h.init_success"], ["", "end"], ["", "(* Fixed array *)"], ["", "definition \"cyk_ix_impl i j = do {mem \\<leftarrow> mem_empty (n * n); cyk_ix\\<^sub>h' mem (i, j)}\""], ["", "lemma cyk_ix_impl_success:\n  \"success (cyk_ix_impl i j) Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success (local.cyk_ix_impl i j) Heap.empty", "using init_success[of _ cyk_ix\\<^sub>h' \"(i, j)\", OF cyk_ix\\<^sub>h.crel]"], ["proof (prove)\nusing this:\n  ?mem =\n  result_of (mem_empty (bounded_index.size (Bound (0, 0) (n, n))))\n   Heap.empty \\<Longrightarrow>\n  success\n   (mem_empty (bounded_index.size (Bound (0, 0) (n, n))) \\<bind>\n    (\\<lambda>mem. local.cyk_ix\\<^sub>h' mem (i, j)))\n   Heap.empty\n\ngoal (1 subgoal):\n 1. success (local.cyk_ix_impl i j) Heap.empty", "by (simp add: cyk_ix_impl_def index_size_defs)"], ["", "lemma min_wpl_heap:\n  \"cyk_ix (i, j) = result_of (cyk_ix_impl i j) Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.cyk_ix (i, j) = result_of (local.cyk_ix_impl i j) Heap.empty", "unfolding cyk_ix_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.cyk_ix (i, j) =\n    result_of\n     (mem_empty (n * n) \\<bind>\n      (\\<lambda>mem. local.cyk_ix\\<^sub>h' mem (i, j)))\n     Heap.empty", "using memoized_empty[of _ cyk_ix\\<^sub>h' \"(i, j)\", OF cyk_ix\\<^sub>h.crel]"], ["proof (prove)\nusing this:\n  ?mem =\n  result_of (mem_empty (bounded_index.size (Bound (0, 0) (n, n))))\n   Heap.empty \\<Longrightarrow>\n  local.cyk_ix (i, j) =\n  result_of\n   (mem_empty (bounded_index.size (Bound (0, 0) (n, n))) \\<bind>\n    (\\<lambda>mem. local.cyk_ix\\<^sub>h' mem (i, j)))\n   Heap.empty\n\ngoal (1 subgoal):\n 1. local.cyk_ix (i, j) =\n    result_of\n     (mem_empty (n * n) \\<bind>\n      (\\<lambda>mem. local.cyk_ix\\<^sub>h' mem (i, j)))\n     Heap.empty", "by (simp add: index_size_defs)"], ["", "end"], ["", "(* Bound *)"], ["", "end"], ["", "(* Index *)"], ["", "definition \"CYK_ix S w n =  (S \\<in> set(cyk_ix w (0,n)))\""], ["", "theorem CYK_ix_correct: \"CYK_ix S w n = yield S (slice w 0 n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.CYK_ix S w n = local.yield S (map w [0..<n])", "by(simp add: CYK_ix_def cyk_ix_correct)"], ["", "definition \"cyk_list w = cyk_ix (\\<lambda>i. w ! i) (0,length w)\""], ["", "definition\n  \"CYK_ix_impl S w n = do {R \\<leftarrow> cyk_ix_impl w n 0 n; return (S \\<in> set R)}\""], ["", "lemma CYK_ix_impl_correct:\n  \"result_of (CYK_ix_impl S w n) Heap.empty = yield S (slice w 0 n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result_of (local.CYK_ix_impl S w n) Heap.empty =\n    local.yield S (map w [0..<n])", "unfolding CYK_ix_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. result_of\n     (local.cyk_ix_impl w n 0 n \\<bind>\n      (\\<lambda>R. return (S \\<in> set R)))\n     Heap.empty =\n    local.yield S (map w [0..<n])", "by (simp add: execute_bind_success[OF cyk_ix_impl_success]\n        min_wpl_heap[symmetric] CYK_ix_correct CYK_ix_def[symmetric]\n     )"], ["", "end"], ["", "(* Fixed Productions *)"], ["", "subsubsection \\<open>Functional Test Case\\<close>"], ["", "value\n  \"(let P = [(0::int, NN 1 2), (0, NN 2 3),\n            (1, NN 2 1), (1, T (CHR ''a'')),\n            (2, NN 3 3), (2, T (CHR ''b'')),\n            (3, NN 1 2), (3, T (CHR ''a''))]\n  in map (\\<lambda>w. cyk2 P w (0,length w)) [''baaba'', ''baba''])\""], ["", "value\n  \"(let P = [(0::int, NN 1 2), (0, NN 2 3),\n            (1, NN 2 1), (1, T (CHR ''a'')),\n            (2, NN 3 3), (2, T (CHR ''b'')),\n            (3, NN 1 2), (3, T (CHR ''a''))]\n  in map (cyk_list P) [''baaba'', ''baba''])\""], ["", "definition \"cyk_ia P w = (let a = IArray w in cyk_ix P (\\<lambda>i. a !! i) (0,length w))\""], ["", "value\n  \"(let P = [(0::int, NN 1 2), (0, NN 2 3),\n            (1, NN 2 1), (1, T (CHR ''a'')),\n            (2, NN 3 3), (2, T (CHR ''b'')),\n            (3, NN 1 2), (3, T (CHR ''a''))]\n  in map (cyk_ia P) [''baaba'', ''baba''])\""], ["", "subsubsection \\<open>Imperative Test Case\\<close>"], ["", "definition \"cyk_ia' P w = (let a = IArray w in cyk_ix_impl P (\\<lambda>i. a !! i) (length w) 0 (length w))\""], ["", "definition\n  \"test = (let P = [(0::int, NN 1 2), (0, NN 2 3),\n            (1, NN 2 1), (1, T (CHR ''a'')),\n            (2, NN 3 3), (2, T (CHR ''b'')),\n            (3, NN 1 2), (3, T (CHR ''a''))]\n  in map (cyk_ia' P) [''baaba'', ''baba''])\""], ["", "code_reflect Test functions test"], ["", "ML \\<open>List.map (fn f => f ()) Test.test\\<close>"], ["", "end"]]}