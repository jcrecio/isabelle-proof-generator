{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/example/Bellman_Ford.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma nat_le_cases:\n  fixes n :: nat\n  assumes \"i \\<le> n\"\n  obtains \"i < n\" | \"i = n\"", "lemma crel_vs_iterate_state:\n  \"crel_vs (=) () (iter_state f x)\" if \"((=) ===>\\<^sub>T R) g f\"", "lemma consistent_crel_vs_iterate_state:\n  \"crel_vs (=) () (iter_state f x)\" if \"consistentDP f\"", "lemma Minf_eq_zero[simp]: \"-\\<infinity> = 0 \\<longleftrightarrow> False\" and Pinf_eq_zero[simp]: \"\\<infinity> = 0 \\<longleftrightarrow> False\"", "lemma Sup_int:\n  fixes x :: int and X :: \"int set\"\n  assumes \"X \\<noteq> {}\" \"bdd_above X\"\n  shows \"Sup X \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> Sup X)\"", "lemmas Sup_int_in = Sup_int[THEN conjunct1]", "lemma Inf_int_in:\n  fixes S :: \"int set\"\n  assumes \"S \\<noteq> {}\" \"bdd_below S\"\n  shows \"Inf S \\<in> S\"", "lemma finite_setcompr_eq_image: \"finite {f x |x. P x} \\<longleftrightarrow> finite (f ` {x. P x})\"", "lemma finite_lists_length_le1: \"finite {xs. length xs \\<le> i \\<and> set xs \\<subseteq> {0..(n::nat)}}\" for i", "lemma finite_lists_length_le2: \"finite {xs. length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..(n::nat)}}\" for i", "lemmas [simp] =\n  finite_setcompr_eq_image finite_lists_length_le2[simplified] finite_lists_length_le1", "lemma get_return:\n  \"run_state (State_Monad.bind State_Monad.get (\\<lambda> m. State_Monad.return (f m))) m = (f m, m)\"", "lemma list_pidgeonhole:\n  assumes \"set xs \\<subseteq> S\" \"card S < length xs\" \"finite S\"\n  obtains as a bs cs where \"xs = as @ a # bs @ a # cs\"", "lemma path_eq_cycleE:\n  assumes \"v # ys @ [t] = as @ a # bs @ a # cs\"\n  obtains (Nil_Nil) \"as = []\" \"cs = []\" \"v = a\" \"a = t\" \"ys = bs\"\n  | (Nil_Cons) cs' where \"as = []\" \"v = a\" \"ys = bs @ a # cs'\" \"cs = cs' @ [t]\"\n  | (Cons_Nil) as' where \"as = v # as'\" \"cs = []\" \"a = t\" \"ys = as' @ a # bs\"\n  | (Cons_Cons) as' cs' where \"as = v # as'\" \"cs = cs' @ [t]\" \"ys = as' @ a # bs @ a # cs'\"", "lemma le_add_same_cancel1:\n  \"a + b \\<ge> a \\<longleftrightarrow> b \\<ge> 0\" if \"a < \\<infinity>\" \"-\\<infinity> < a\" for a b :: \"int extended\"", "lemma add_gt_minfI:\n  assumes \"-\\<infinity> < a\" \"-\\<infinity> < b\"\n  shows \"-\\<infinity> < a + b\"", "lemma add_lt_infI:\n  assumes \"a < \\<infinity>\" \"b < \\<infinity>\"\n  shows \"a + b < \\<infinity>\"", "lemma sum_list_not_infI:\n  \"sum_list xs < \\<infinity>\" if \"\\<forall> x \\<in> set xs. x < \\<infinity>\" for xs :: \"int extended list\"", "lemma sum_list_not_minfI:\n  \"sum_list xs > -\\<infinity>\" if \"\\<forall> x \\<in> set xs. x > -\\<infinity>\" for xs :: \"int extended list\"", "lemma weight_alt_def':\n  \"weight (s # xs) + w = snd (fold (\\<lambda>j (i, x). (j, W i j + x)) xs (s, w))\"", "lemma weight_alt_def:\n  \"weight (s # xs) = snd (fold (\\<lambda>j (i, x). (j, W i j + x)) xs (s, 0))\"", "lemma weight_append:\n  \"weight (xs @ a # ys) = weight (xs @ [a]) + weight (a # ys)\"", "lemma OPT_0:\n  \"OPT 0 v = (if t = v then 0 else \\<infinity>)\"", "lemma OPT_cases:\n  obtains (path) xs where \"OPT i v = weight (v # xs @ [t])\" \"length xs + 1 \\<le> i\" \"set xs \\<subseteq> {0..n}\"\n  | (sink) \"v = t\" \"OPT i v = 0\"\n  | (unreachable) \"v \\<noteq> t\" \"OPT i v = \\<infinity>\"", "lemma OPT_Suc:\n  \"OPT (Suc i) v = min (OPT i v) (Min {OPT i w + W v w | w. w \\<le> n})\" (is \"?lhs = ?rhs\")\n  if \"t \\<le> n\"", "lemmas [simp del] = bf.simps", "lemmas bf_simps[simp] = bf.simps[unfolded min_list_fold]", "lemma bf_correct:\n  \"OPT i j = bf i j\" if \\<open>t \\<le> n\\<close>", "lemmas [code] = bf\\<^sub>m.memoized_correct", "lemma iter_bf_unfold[code]:\n  \"iter_bf = (\\<lambda> (i, j).\n    (if i \\<le> n \\<and> j \\<le> n\n     then do {\n            bf\\<^sub>m' i j;\n            iter_bf (if j < n then (i, j + 1) else (i + 1, 0))\n          }\n     else State_Monad.return ()))\"", "lemmas bf_memoized = bf\\<^sub>m.memoized[OF bf\\<^sub>m.crel]", "lemmas bf_bottom_up = bottom_up.memoized[OF bf\\<^sub>m.crel, folded iter_bf_def]", "lemma bellman_ford_alt_def:\n  \"bellman_ford \\<equiv>\n    do {\n      _  \\<leftarrow> iter_bf (n, n);\n      (\\<langle>\\<lambda>xs. \\<langle>\\<lambda>ys. State_Monad.return (if xs = ys then Some xs else None)\\<rangle>\n      . (State_Main.map\\<^sub>T . \\<langle>\\<lambda>i. bf\\<^sub>m' (n + 1) i\\<rangle> . \\<langle>[0..<n+1]\\<rangle>)\\<rangle>)\n      . (State_Main.map\\<^sub>T . \\<langle>\\<lambda>i. bf\\<^sub>m' n i\\<rangle>       . \\<langle>[0..<n+1]\\<rangle>)\n    }\"", "lemma [intro]:\n  \"dp_consistency_heap_array_pair' (n + 1) fst snd id 1 0 mem\"", "lemma [intro]:\n  \"dp_consistency_heap_array_pair_iterator (n + 1) fst snd id 1 0 mem\n  (\\<lambda> (x, y). if y < n then (x, y + 1) else (x + 1, 0))\n  (\\<lambda> (x, y). x * (n + 1) + y)\n  (\\<lambda> (x, y). x \\<le> n \\<and> y \\<le> n)\"", "lemmas memoized_empty = bf\\<^sub>h.memoized_empty[OF bf\\<^sub>h.consistent_DP_iter_and_compute[OF bf\\<^sub>h.crel]]", "lemmas iter_heap_unfold = iter_heap_unfold", "lemma fold_sum_aux':\n  assumes \"\\<forall>u \\<in> set (a # xs). \\<forall>v \\<in> set (xs @ [b]). f v + W u v \\<ge> f u\"\n  shows \"sum_list (map f (a # xs)) \\<le> sum_list (map f (xs @ [b])) + weight (a # xs @ [b])\"", "lemma fold_sum_aux:\n  assumes \"\\<forall>u \\<in> set (a # xs). \\<forall>v \\<in> set (a # xs). f v + W u v \\<ge> f u\"\n  shows \"sum_list (map f (a # xs @ [a])) \\<le> sum_list (map f (a # xs @ [a])) + weight (a # xs @ [a])\"", "lemma is_path2_remove_cycle:\n  assumes \"is_path2 (as @ a # bs @ a # cs)\"\n  shows \"is_path2 (as @ a # cs)\"", "lemma is_path_eq:\n  \"is_path xs \\<longleftrightarrow> is_path2 (xs @ [t])\"", "lemma is_path_remove_cycle:\n  assumes \"is_path (as @ a # bs @ a # cs)\"\n  shows \"is_path (as @ a # cs)\"", "lemma is_path_remove_cycle2:\n  assumes \"is_path (as @ t # cs)\"\n  shows \"is_path as\"", "lemma is_path_shorten:\n  assumes \"is_path (i # xs)\" \"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"t \\<le> n\" \"t \\<noteq> i\"\n  obtains xs where \"is_path (i # xs)\" \"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"length xs < n\"", "lemma reaches_non_inf_path:\n  assumes \"reaches i\" \"i \\<le> n\" \"t \\<le> n\"\n  shows \"OPT n i < \\<infinity>\"", "lemma OPT_sink_le_0:\n  \"OPT i t \\<le> 0\"", "lemma is_path_appendD:\n  assumes \"is_path (as @ a # bs)\"\n  shows \"is_path (a # bs)\"", "lemma has_negative_cycleI:\n  assumes \"set (a # xs @ ys) \\<subseteq> {0..n}\" \"weight (a # xs @ [a]) < 0\" \"is_path (a # ys)\"\n  shows has_negative_cycle", "lemma OPT_cases2:\n  obtains (path) xs where\n    \"v \\<noteq> t\" \"OPT i v \\<noteq> \\<infinity>\" \"OPT i v = weight (v # xs @ [t])\" \"length xs + 1 \\<le> i\" \"set xs \\<subseteq> {0..n}\"\n  | (unreachable) \"v \\<noteq> t\" \"OPT i v = \\<infinity>\"\n  | (sink) \"v = t\" \"OPT i v \\<le> 0\"", "lemma shortest_le_OPT:\n  assumes \"v \\<le> n\"\n  shows \"shortest v \\<le> OPT i v\"", "lemma weight_not_minfI:\n  \"-\\<infinity> < weight xs\" if \"set xs \\<subseteq> {0..n}\" \"xs \\<noteq> []\"", "lemma OPT_not_minfI:\n  \"OPT n i > -\\<infinity>\" if \"i \\<le> n\"", "theorem detects_cycle:\n  assumes has_negative_cycle\n  shows \"\\<exists>i \\<le> n. OPT (n + 1) i < OPT n i\"", "lemma shortest_cases:\n  assumes \"v \\<le> n\"\n  obtains (path) xs where \"shortest v = weight (v # xs @ [t])\" \"set xs \\<subseteq> {0..n}\"\n  | (sink) \"v = t\" \"shortest v = 0\"\n  | (unreachable) \"v \\<noteq> t\" \"shortest v = \\<infinity>\"\n  | (negative_cycle) \"shortest v = -\\<infinity>\" \"\\<forall>x. \\<exists>xs. set xs \\<subseteq> {0..n} \\<and> weight (v # xs @ [t]) < Fin x\"", "lemma simple_paths:\n  assumes \"\\<not> has_negative_cycle\" \"weight (v # xs @ [t]) < \\<infinity>\" \"set xs \\<subseteq> {0..n}\" \"v \\<le> n\"\n  obtains ys where\n    \"weight (v # ys @ [t]) \\<le> weight (v # xs @ [t])\" \"set ys \\<subseteq> {0..n}\" \"length ys < n\" | \"v = t\"", "theorem shorter_than_OPT_n_has_negative_cycle:\n  assumes \"shortest v < OPT n v\" \"v \\<le> n\"\n  shows has_negative_cycle", "lemma OPT_mono:\n  \"OPT m v \\<le> OPT n v\" if \\<open>v \\<le> n\\<close> \\<open>n \\<le> m\\<close>", "lemma bellman_ford_correct':\n  \"bf\\<^sub>m.crel_vs (=) (if has_negative_cycle then None else Some (map shortest [0..<n+1])) bellman_ford\"", "theorem bellman_ford_correct:\n  \"fst (run_state bellman_ford Mapping.empty) =\n  (if has_negative_cycle then None else Some (map shortest [0..<n+1]))\"", "lemma bf\\<^sub>h'_impl_def:\n  fixes n :: nat\n  fixes mem :: \"nat ref \\<times> nat ref \\<times> int extended option array ref \\<times> int extended option array ref\"\n  assumes mem_is_init: \"mem = result_of (init_state (n + 1) 1 0) Heap.empty\"\n  shows \"bf\\<^sub>h'_impl n w t mem = bf\\<^sub>h' n w t mem\"", "lemma iter_bf_heap_unfold[code]:\n  \"iter_bf_heap n w t mem = (\\<lambda> (i, j).\n    (if i \\<le> n \\<and> j \\<le> n\n     then do {\n            bf\\<^sub>h'_impl n w t mem i j;\n            iter_bf_heap n w t mem (if j < n then (i, j + 1) else (i + 1, 0))\n          }\n     else Heap_Monad.return ()))\"", "lemma bf_impl_correct:\n  \"bf n w t i j = result_of (bf_impl n w t i j) Heap.empty\"", "lemma bottom_up_alt[code]:\n  \"bf n W t i j =\n     fst (run_state\n      (iter_bf n W t (0, 0) \\<bind> (\\<lambda>_. bf\\<^sub>m' n W t i j))\n      Mapping.empty)\"", "lemma\n  \"fst (run_state (bf\\<^sub>m' 3 (graph_of (IArray G\\<^sub>1_list)) 3 3 0) Mapping.empty) = 4\"\n  \"bf 3 (graph_of (IArray G\\<^sub>1_list)) 3 3 0 = 4\"", "lemma\n  \"fst (run_state (bellman_ford 3 (graph_of (IArray G\\<^sub>1_list)) 3) Mapping.empty) = Some [4, 10, 2, 0]\"\n  \"fst (run_state (bellman_ford 4 (graph_of (IArray G\\<^sub>3_list)) 4) Mapping.empty) = Some [4, 5, 3, 1, 0]\"", "lemma\n  \"fst (run_state (bellman_ford 3 (graph_of (IArray G\\<^sub>2_list)) 3) Mapping.empty) = None\"\n  \"fst (run_state (bellman_ford 4 (graph_of (IArray G\\<^sub>4_list)) 4) Mapping.empty) = None\""], "translations": [["", "lemma nat_le_cases:\n  fixes n :: nat\n  assumes \"i \\<le> n\"\n  obtains \"i < n\" | \"i = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n \\<Longrightarrow> thesis;\n     i = n \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n \\<Longrightarrow> thesis;\n     i = n \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases \"i = n\") auto"], ["", "context dp_consistency_iterator\nbegin"], ["", "lemma crel_vs_iterate_state:\n  \"crel_vs (=) () (iter_state f x)\" if \"((=) ===>\\<^sub>T R) g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (=) () (iter_state f x)", "by (metis crel_vs_iterate_state iter_state_iterate_state that)"], ["", "lemma consistent_crel_vs_iterate_state:\n  \"crel_vs (=) () (iter_state f x)\" if \"consistentDP f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (=) () (iter_state f x)", "using consistentDP_def crel_vs_iterate_state that"], ["proof (prove)\nusing this:\n  consistentDP \\<equiv> ((=) ===>\\<^sub>T (=)) dp\n  ((=) ===>\\<^sub>T ?R) ?g ?f \\<Longrightarrow>\n  crel_vs (=) () (iter_state ?f ?x)\n  consistentDP f\n\ngoal (1 subgoal):\n 1. crel_vs (=) () (iter_state f x)", "by simp"], ["", "end"], ["", "instance extended :: (countable) countable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a extended, countable_class)", "proof standard"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "obtain to_nat :: \"'a \\<Rightarrow> nat\" where \"inj to_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>to_nat. inj to_nat \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  inj to_nat\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "let ?f = \"\\<lambda> x. case x of Fin n \\<Rightarrow> to_nat n + 2 | Pinf \\<Rightarrow> 0 | Minf \\<Rightarrow> 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "from \\<open>inj _ \\<close>"], ["proof (chain)\npicking this:\n  inj to_nat", "have \"inj ?f\""], ["proof (prove)\nusing this:\n  inj to_nat\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>x.\n            case x of Fin n \\<Rightarrow> to_nat n + 2\n            | \\<infinity> \\<Rightarrow> 0 | -\\<infinity> \\<Rightarrow> 1)", "by (auto simp: inj_def split: extended.split)"], ["proof (state)\nthis:\n  inj (\\<lambda>x.\n          case x of Fin n \\<Rightarrow> to_nat n + 2\n          | \\<infinity> \\<Rightarrow> 0 | -\\<infinity> \\<Rightarrow> 1)\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "then"], ["proof (chain)\npicking this:\n  inj (\\<lambda>x.\n          case x of Fin n \\<Rightarrow> to_nat n + 2\n          | \\<infinity> \\<Rightarrow> 0 | -\\<infinity> \\<Rightarrow> 1)", "show \"\\<exists>to_nat :: 'a extended \\<Rightarrow> nat. inj to_nat\""], ["proof (prove)\nusing this:\n  inj (\\<lambda>x.\n          case x of Fin n \\<Rightarrow> to_nat n + 2\n          | \\<infinity> \\<Rightarrow> 0 | -\\<infinity> \\<Rightarrow> 1)\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "by auto"], ["proof (state)\nthis:\n  \\<exists>to_nat. inj to_nat\n\ngoal:\nNo subgoals!", "qed"], ["", "instance extended :: (heap) heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a extended, heap_class)", ".."], ["", "instantiation \"extended\" :: (conditionally_complete_lattice) complete_lattice\nbegin"], ["", "definition\n  \"Inf A = (\n    if A = {} \\<or> A = {\\<infinity>} then \\<infinity>\n    else if -\\<infinity> \\<in> A \\<or> \\<not> bdd_below (Fin -` A) then -\\<infinity>\n    else Fin (Inf (Fin -` A)))\""], ["", "definition\n  \"Sup A = (\n    if A = {} \\<or> A = {-\\<infinity>} then -\\<infinity>\n    else if \\<infinity> \\<in> A \\<or> \\<not> bdd_above (Fin -` A) then \\<infinity>\n    else Fin (Sup (Fin -` A)))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a extended, complete_lattice_class)", "proof standard"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> Inf A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 5. Inf {} = top\n 6. Sup {} = bot", "have [dest]: \"Inf (Fin -` A) \\<le> x\" if \"Fin x \\<in> A\" \"bdd_below (Fin -` A)\" for A and x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf (Fin -` A) \\<le> x", "using that"], ["proof (prove)\nusing this:\n  Fin x \\<in> A\n  bdd_below (Fin -` A)\n\ngoal (1 subgoal):\n 1. Inf (Fin -` A) \\<le> x", "by (intro cInf_lower) auto"], ["proof (state)\nthis:\n  \\<lbrakk>Fin ?x \\<in> ?A; bdd_below (Fin -` ?A)\\<rbrakk>\n  \\<Longrightarrow> Inf (Fin -` ?A) \\<le> ?x\n\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> Inf A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 5. Inf {} = top\n 6. Sup {} = bot", "have *: False if \"\\<not> z \\<le> Inf (Fin -` A)\" \"\\<And>x. x \\<in> A \\<Longrightarrow> Fin z \\<le> x\" \"Fin x \\<in> A\" for A and x z :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using cInf_greatest[of \"Fin -` A\" z] that vimage_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>Fin -` A \\<noteq> {};\n   \\<And>x. x \\<in> Fin -` A \\<Longrightarrow> z \\<le> x\\<rbrakk>\n  \\<Longrightarrow> z \\<le> Inf (Fin -` A)\n  \\<not> z \\<le> Inf (Fin -` A)\n  ?x \\<in> A \\<Longrightarrow> Fin z \\<le> ?x\n  Fin x \\<in> A\n  (?a \\<in> ?f -` ?B) = (?f ?a \\<in> ?B)\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> ?z \\<le> Inf (Fin -` ?A);\n   \\<And>x. x \\<in> ?A \\<Longrightarrow> Fin ?z \\<le> x;\n   Fin ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> Inf A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 5. Inf {} = top\n 6. Sup {} = bot", "show \"Inf A \\<le> x\" if \"x \\<in> A\" for x :: \"'a extended\" and A"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf A \\<le> x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. Inf A \\<le> x", "unfolding Inf_extended_def"], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (if A = {} \\<or> A = {\\<infinity>} then \\<infinity>\n     else if -\\<infinity> \\<in> A \\<or> \\<not> bdd_below (Fin -` A)\n          then -\\<infinity> else Fin (Inf (Fin -` A)))\n    \\<le> x", "by (cases x) auto"], ["proof (state)\nthis:\n  ?x \\<in> ?A \\<Longrightarrow> Inf ?A \\<le> ?x\n\ngoal (5 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 2. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 3. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 4. Inf {} = top\n 5. Sup {} = bot", "show \"z \\<le> Inf A\" if \"\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x\" for z :: \"'a extended\" and A"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> Inf A", "using that"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> z \\<le> ?x\n\ngoal (1 subgoal):\n 1. z \\<le> Inf A", "unfolding Inf_extended_def"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> z \\<le> ?x\n\ngoal (1 subgoal):\n 1. z \\<le> (if A = {} \\<or> A = {\\<infinity>} then \\<infinity>\n             else if -\\<infinity> \\<in> A \\<or> \\<not> bdd_below (Fin -` A)\n                  then -\\<infinity> else Fin (Inf (Fin -` A)))", "apply (clarsimp; safe)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<in> A; z \\<noteq> -\\<infinity>; x \\<in> A;\n        x \\<notin> {}; xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = \\<infinity>\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<in> A; z \\<noteq> -\\<infinity>; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A\n 3. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<not> bdd_below (Fin -` A); z \\<noteq> -\\<infinity>; x \\<in> A;\n        x \\<notin> {}; xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = \\<infinity>\n 4. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<not> bdd_below (Fin -` A); z \\<noteq> -\\<infinity>; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A\n 5. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n        \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A; x \\<notin> {};\n        xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = \\<infinity>\n 6. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n        \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A", "apply force"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<in> A; z \\<noteq> -\\<infinity>; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<not> bdd_below (Fin -` A); z \\<noteq> -\\<infinity>; x \\<in> A;\n        x \\<notin> {}; xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = \\<infinity>\n 3. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<not> bdd_below (Fin -` A); z \\<noteq> -\\<infinity>; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A\n 4. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n        \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A; x \\<notin> {};\n        xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = \\<infinity>\n 5. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n        \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A", "apply force"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<not> bdd_below (Fin -` A); z \\<noteq> -\\<infinity>; x \\<in> A;\n        x \\<notin> {}; xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = \\<infinity>\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<not> bdd_below (Fin -` A); z \\<noteq> -\\<infinity>; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A\n 3. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n        \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A; x \\<notin> {};\n        xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = \\<infinity>\n 4. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n        \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n     \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n     \\<not> bdd_below (Fin -` A); z \\<noteq> -\\<infinity>; x_ \\<in> A;\n     x_ \\<notin> {}; xa_ \\<in> A; xa_ \\<notin> {}\\<rbrakk>\n    \\<Longrightarrow> xa_ = \\<infinity>", "by (cases z; force simp: bdd_below_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<not> bdd_below (Fin -` A); z \\<noteq> -\\<infinity>; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n        \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A; x \\<notin> {};\n        xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = \\<infinity>\n 3. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n        \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n     \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n     \\<not> bdd_below (Fin -` A); z \\<noteq> -\\<infinity>; x_ \\<in> A;\n     x_ \\<notin> {}\\<rbrakk>\n    \\<Longrightarrow> \\<infinity> \\<in> A", "by (cases z; force simp: bdd_below_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n        \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A; x \\<notin> {};\n        xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = \\<infinity>\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n        \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n     \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n     -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n     \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A; x \\<notin> {};\n     y \\<in> A; y \\<notin> {}\\<rbrakk>\n    \\<Longrightarrow> y = \\<infinity>", "by (cases z; cases y) (auto elim: *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n        \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity> \\<in> A", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n     \\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n     -\\<infinity> \\<notin> A; bdd_below (Fin -` A);\n     \\<not> z \\<le> Fin (Inf (Fin -` A)); x \\<in> A; x \\<notin> {}\\<rbrakk>\n    \\<Longrightarrow> \\<infinity> \\<in> A", "by (cases z; cases y; simp; metis * less_eq_extended.elims(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> ?z \\<le> x) \\<Longrightarrow>\n  ?z \\<le> Inf ?A\n\ngoal (4 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 3. Inf {} = top\n 4. Sup {} = bot", "have [dest]: \"x \\<le> Sup (Fin -` A)\" if \"Fin x \\<in> A\" \"bdd_above (Fin -` A)\" for A and x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> Sup (Fin -` A)", "using that"], ["proof (prove)\nusing this:\n  Fin x \\<in> A\n  bdd_above (Fin -` A)\n\ngoal (1 subgoal):\n 1. x \\<le> Sup (Fin -` A)", "by (intro cSup_upper) auto"], ["proof (state)\nthis:\n  \\<lbrakk>Fin ?x \\<in> ?A; bdd_above (Fin -` ?A)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> Sup (Fin -` ?A)\n\ngoal (4 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 3. Inf {} = top\n 4. Sup {} = bot", "have *: False if \"\\<not> Sup (Fin -` A) \\<le> z\" \"\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> Fin z\" \"Fin x \\<in> A\" for A and x z :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using cSup_least[of \"Fin -` A\" z] that vimage_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>Fin -` A \\<noteq> {};\n   \\<And>x. x \\<in> Fin -` A \\<Longrightarrow> x \\<le> z\\<rbrakk>\n  \\<Longrightarrow> Sup (Fin -` A) \\<le> z\n  \\<not> Sup (Fin -` A) \\<le> z\n  ?x \\<in> A \\<Longrightarrow> ?x \\<le> Fin z\n  Fin x \\<in> A\n  (?a \\<in> ?f -` ?B) = (?f ?a \\<in> ?B)\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> Sup (Fin -` ?A) \\<le> ?z;\n   \\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<le> Fin ?z;\n   Fin ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (4 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 3. Inf {} = top\n 4. Sup {} = bot", "show \"x \\<le> Sup A\" if \"x \\<in> A\" for x :: \"'a extended\" and A"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> Sup A", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<le> Sup A", "unfolding Sup_extended_def"], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<le> (if A = {} \\<or> A = {-\\<infinity>} then -\\<infinity>\n             else if \\<infinity> \\<in> A \\<or> \\<not> bdd_above (Fin -` A)\n                  then \\<infinity> else Fin (Sup (Fin -` A)))", "by (cases x) auto"], ["proof (state)\nthis:\n  ?x \\<in> ?A \\<Longrightarrow> ?x \\<le> Sup ?A\n\ngoal (3 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 2. Inf {} = top\n 3. Sup {} = bot", "show \"Sup A \\<le> z\" if \"\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\" for z :: \"'a extended\" and A"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup A \\<le> z", "using that"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> ?x \\<le> z\n\ngoal (1 subgoal):\n 1. Sup A \\<le> z", "unfolding Sup_extended_def"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> ?x \\<le> z\n\ngoal (1 subgoal):\n 1. (if A = {} \\<or> A = {-\\<infinity>} then -\\<infinity>\n     else if \\<infinity> \\<in> A \\<or> \\<not> bdd_above (Fin -` A)\n          then \\<infinity> else Fin (Sup (Fin -` A)))\n    \\<le> z", "apply (clarsimp; safe)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z; \\<infinity> \\<in> A;\n        z \\<noteq> \\<infinity>; x \\<in> A; x \\<notin> {}; xa \\<in> A;\n        xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = -\\<infinity>\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z; \\<infinity> \\<in> A;\n        z \\<noteq> \\<infinity>; x \\<in> A; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A\n 3. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<not> bdd_above (Fin -` A); z \\<noteq> \\<infinity>; x \\<in> A;\n        x \\<notin> {}; xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = -\\<infinity>\n 4. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<not> bdd_above (Fin -` A); z \\<noteq> \\<infinity>; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A\n 5. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<infinity> \\<notin> A; bdd_above (Fin -` A);\n        \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A; x \\<notin> {};\n        xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = -\\<infinity>\n 6. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<infinity> \\<notin> A; bdd_above (Fin -` A);\n        \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A", "apply force"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z; \\<infinity> \\<in> A;\n        z \\<noteq> \\<infinity>; x \\<in> A; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<not> bdd_above (Fin -` A); z \\<noteq> \\<infinity>; x \\<in> A;\n        x \\<notin> {}; xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = -\\<infinity>\n 3. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<not> bdd_above (Fin -` A); z \\<noteq> \\<infinity>; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A\n 4. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<infinity> \\<notin> A; bdd_above (Fin -` A);\n        \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A; x \\<notin> {};\n        xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = -\\<infinity>\n 5. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<infinity> \\<notin> A; bdd_above (Fin -` A);\n        \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A", "apply force"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<not> bdd_above (Fin -` A); z \\<noteq> \\<infinity>; x \\<in> A;\n        x \\<notin> {}; xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = -\\<infinity>\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<not> bdd_above (Fin -` A); z \\<noteq> \\<infinity>; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A\n 3. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<infinity> \\<notin> A; bdd_above (Fin -` A);\n        \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A; x \\<notin> {};\n        xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = -\\<infinity>\n 4. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<infinity> \\<notin> A; bdd_above (Fin -` A);\n        \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n     \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n     \\<not> bdd_above (Fin -` A); z \\<noteq> \\<infinity>; x_ \\<in> A;\n     x_ \\<notin> {}; xa_ \\<in> A; xa_ \\<notin> {}\\<rbrakk>\n    \\<Longrightarrow> xa_ = -\\<infinity>", "by (cases z; force)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<not> bdd_above (Fin -` A); z \\<noteq> \\<infinity>; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<infinity> \\<notin> A; bdd_above (Fin -` A);\n        \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A; x \\<notin> {};\n        xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = -\\<infinity>\n 3. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<infinity> \\<notin> A; bdd_above (Fin -` A);\n        \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n     \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n     \\<not> bdd_above (Fin -` A); z \\<noteq> \\<infinity>; x_ \\<in> A;\n     x_ \\<notin> {}\\<rbrakk>\n    \\<Longrightarrow> -\\<infinity> \\<in> A", "by (cases z; force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<infinity> \\<notin> A; bdd_above (Fin -` A);\n        \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A; x \\<notin> {};\n        xa \\<in> A; xa \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xa = -\\<infinity>\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<infinity> \\<notin> A; bdd_above (Fin -` A);\n        \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n     \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z; \\<infinity> \\<notin> A;\n     bdd_above (Fin -` A); \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A;\n     x \\<notin> {}; y \\<in> A; y \\<notin> {}\\<rbrakk>\n    \\<Longrightarrow> y = -\\<infinity>", "by (cases z; cases y) (auto elim: *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<infinity> \\<notin> A; bdd_above (Fin -` A);\n        \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A;\n        x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> -\\<infinity> \\<in> A", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n     \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z; \\<infinity> \\<notin> A;\n     bdd_above (Fin -` A); \\<not> Fin (Sup (Fin -` A)) \\<le> z; x \\<in> A;\n     x \\<notin> {}\\<rbrakk>\n    \\<Longrightarrow> -\\<infinity> \\<in> A", "by (cases z; cases y; simp; metis * extended.exhaust)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<le> ?z) \\<Longrightarrow>\n  Sup ?A \\<le> ?z\n\ngoal (2 subgoals):\n 1. Inf {} = top\n 2. Sup {} = bot", "show \"Inf {} = (top::'a extended)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {} = top", "unfolding Inf_extended_def top_extended_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if {} = {} \\<or> {} = {\\<infinity>} then \\<infinity>\n     else if -\\<infinity> \\<in> {} \\<or> \\<not> bdd_below (Fin -` {})\n          then -\\<infinity> else Fin (Inf (Fin -` {}))) =\n    \\<infinity>", "by simp"], ["proof (state)\nthis:\n  Inf {} = top\n\ngoal (1 subgoal):\n 1. Sup {} = bot", "show \"Sup {} = (bot::'a extended)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {} = bot", "unfolding Sup_extended_def bot_extended_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if {} = {} \\<or> {} = {-\\<infinity>} then -\\<infinity>\n     else if \\<infinity> \\<in> {} \\<or> \\<not> bdd_above (Fin -` {})\n          then \\<infinity> else Fin (Sup (Fin -` {}))) =\n    -\\<infinity>", "by simp"], ["proof (state)\nthis:\n  Sup {} = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instance \"extended\" :: (\"{conditionally_complete_lattice,linorder}\") complete_linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a extended, complete_linorder_class)", ".."], ["", "lemma Minf_eq_zero[simp]: \"-\\<infinity> = 0 \\<longleftrightarrow> False\" and Pinf_eq_zero[simp]: \"\\<infinity> = 0 \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (-\\<infinity> = 0) = False &&& (\\<infinity> = 0) = False", "unfolding zero_extended_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (-\\<infinity> = Fin (0::'a)) = False &&&\n    (\\<infinity> = Fin (0::'b)) = False", "by auto"], ["", "lemma Sup_int:\n  fixes x :: int and X :: \"int set\"\n  assumes \"X \\<noteq> {}\" \"bdd_above X\"\n  shows \"Sup X \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> Sup X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup X \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> Sup X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sup X \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> Sup X)", "from assms"], ["proof (chain)\npicking this:\n  X \\<noteq> {}\n  bdd_above X", "obtain x y where \"X \\<subseteq> {..y}\" \"x \\<in> X\""], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n  bdd_above X\n\ngoal (1 subgoal):\n 1. (\\<And>y x.\n        \\<lbrakk>X \\<subseteq> {..y}; x \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: bdd_above_def)"], ["proof (state)\nthis:\n  X \\<subseteq> {..y}\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. Sup X \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> Sup X)", "then"], ["proof (chain)\npicking this:\n  X \\<subseteq> {..y}\n  x \\<in> X", "have *: \"finite (X \\<inter> {x..y})\" \"X \\<inter> {x..y} \\<noteq> {}\" and \"x \\<le> y\""], ["proof (prove)\nusing this:\n  X \\<subseteq> {..y}\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. (finite (X \\<inter> {x..y}) &&& X \\<inter> {x..y} \\<noteq> {}) &&&\n    x \\<le> y", "by (auto simp: subset_eq)"], ["proof (state)\nthis:\n  finite (X \\<inter> {x..y})\n  X \\<inter> {x..y} \\<noteq> {}\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. Sup X \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> Sup X)", "have \"\\<exists>!x\\<in>X. (\\<forall>y\\<in>X. y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> ?a)\n 2. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = ?a", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> ?a)\n 2. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = ?a", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> ?a)\n 2. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = ?a", "assume \"z \\<in> X\""], ["proof (state)\nthis:\n  z \\<in> X\n\ngoal (2 subgoals):\n 1. ?a \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> ?a)\n 2. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = ?a", "have \"z \\<le> Max (X \\<inter> {x..y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> Max (X \\<inter> {x..y})", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> z \\<le> Max (X \\<inter> {x..y})\n 2. \\<not> ?P \\<Longrightarrow> z \\<le> Max (X \\<inter> {x..y})", "assume \"x \\<le> z\""], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> z \\<le> Max (X \\<inter> {x..y})\n 2. \\<not> ?P \\<Longrightarrow> z \\<le> Max (X \\<inter> {x..y})", "with \\<open>z \\<in> X\\<close> \\<open>X \\<subseteq> {..y}\\<close> *(1)"], ["proof (chain)\npicking this:\n  z \\<in> X\n  X \\<subseteq> {..y}\n  finite (X \\<inter> {x..y})\n  x \\<le> z", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> X\n  X \\<subseteq> {..y}\n  finite (X \\<inter> {x..y})\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. z \\<le> Max (X \\<inter> {x..y})", "by (auto intro!: Max_ge)"], ["proof (state)\nthis:\n  z \\<le> Max (X \\<inter> {x..y})\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow> z \\<le> Max (X \\<inter> {x..y})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow> z \\<le> Max (X \\<inter> {x..y})", "assume \"\\<not> x \\<le> z\""], ["proof (state)\nthis:\n  \\<not> x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow> z \\<le> Max (X \\<inter> {x..y})", "then"], ["proof (chain)\npicking this:\n  \\<not> x \\<le> z", "have \"z < x\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> z\n\ngoal (1 subgoal):\n 1. z < x", "by simp"], ["proof (state)\nthis:\n  z < x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow> z \\<le> Max (X \\<inter> {x..y})", "also"], ["proof (state)\nthis:\n  z < x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow> z \\<le> Max (X \\<inter> {x..y})", "have \"x \\<le> Max (X \\<inter> {x..y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> Max (X \\<inter> {x..y})", "using \\<open>x \\<in> X\\<close> *(1) \\<open>x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> X\n  finite (X \\<inter> {x..y})\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> Max (X \\<inter> {x..y})", "by (intro Max_ge) auto"], ["proof (state)\nthis:\n  x \\<le> Max (X \\<inter> {x..y})\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow> z \\<le> Max (X \\<inter> {x..y})", "finally"], ["proof (chain)\npicking this:\n  z < Max (X \\<inter> {x..y})", "show ?thesis"], ["proof (prove)\nusing this:\n  z < Max (X \\<inter> {x..y})\n\ngoal (1 subgoal):\n 1. z \\<le> Max (X \\<inter> {x..y})", "by simp"], ["proof (state)\nthis:\n  z \\<le> Max (X \\<inter> {x..y})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<le> Max (X \\<inter> {x..y})\n\ngoal (2 subgoals):\n 1. ?a \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> ?a)\n 2. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = ?a", "}"], ["proof (state)\nthis:\n  ?z2 \\<in> X \\<Longrightarrow> ?z2 \\<le> Max (X \\<inter> {x..y})\n\ngoal (2 subgoals):\n 1. ?a \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> ?a)\n 2. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = ?a", "note le = this"], ["proof (state)\nthis:\n  ?z2 \\<in> X \\<Longrightarrow> ?z2 \\<le> Max (X \\<inter> {x..y})\n\ngoal (2 subgoals):\n 1. ?a \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> ?a)\n 2. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = ?a", "with Max_in[OF *]"], ["proof (chain)\npicking this:\n  Max (X \\<inter> {x..y}) \\<in> X \\<inter> {x..y}\n  ?z2 \\<in> X \\<Longrightarrow> ?z2 \\<le> Max (X \\<inter> {x..y})", "show ex: \"Max (X \\<inter> {x..y}) \\<in> X \\<and> (\\<forall>z\\<in>X. z \\<le> Max (X \\<inter> {x..y}))\""], ["proof (prove)\nusing this:\n  Max (X \\<inter> {x..y}) \\<in> X \\<inter> {x..y}\n  ?z2 \\<in> X \\<Longrightarrow> ?z2 \\<le> Max (X \\<inter> {x..y})\n\ngoal (1 subgoal):\n 1. Max (X \\<inter> {x..y}) \\<in> X \\<and>\n    (\\<forall>z\\<in>X. z \\<le> Max (X \\<inter> {x..y}))", "by auto"], ["proof (state)\nthis:\n  Max (X \\<inter> {x..y}) \\<in> X \\<and>\n  (\\<forall>z\\<in>X. z \\<le> Max (X \\<inter> {x..y}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = Max (X \\<inter> {x..y})", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = Max (X \\<inter> {x..y})", "assume *: \"z \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> z)\""], ["proof (state)\nthis:\n  z \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = Max (X \\<inter> {x..y})", "with le"], ["proof (chain)\npicking this:\n  ?z2 \\<in> X \\<Longrightarrow> ?z2 \\<le> Max (X \\<inter> {x..y})\n  z \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> z)", "have \"z \\<le> Max (X \\<inter> {x..y})\""], ["proof (prove)\nusing this:\n  ?z2 \\<in> X \\<Longrightarrow> ?z2 \\<le> Max (X \\<inter> {x..y})\n  z \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> z)\n\ngoal (1 subgoal):\n 1. z \\<le> Max (X \\<inter> {x..y})", "by auto"], ["proof (state)\nthis:\n  z \\<le> Max (X \\<inter> {x..y})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = Max (X \\<inter> {x..y})", "moreover"], ["proof (state)\nthis:\n  z \\<le> Max (X \\<inter> {x..y})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = Max (X \\<inter> {x..y})", "have \"Max (X \\<inter> {x..y}) \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (X \\<inter> {x..y}) \\<le> z", "using * ex"], ["proof (prove)\nusing this:\n  z \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> z)\n  Max (X \\<inter> {x..y}) \\<in> X \\<and>\n  (\\<forall>z\\<in>X. z \\<le> Max (X \\<inter> {x..y}))\n\ngoal (1 subgoal):\n 1. Max (X \\<inter> {x..y}) \\<le> z", "by auto"], ["proof (state)\nthis:\n  Max (X \\<inter> {x..y}) \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x) \\<Longrightarrow>\n       x = Max (X \\<inter> {x..y})", "ultimately"], ["proof (chain)\npicking this:\n  z \\<le> Max (X \\<inter> {x..y})\n  Max (X \\<inter> {x..y}) \\<le> z", "show \"z = Max (X \\<inter> {x..y})\""], ["proof (prove)\nusing this:\n  z \\<le> Max (X \\<inter> {x..y})\n  Max (X \\<inter> {x..y}) \\<le> z\n\ngoal (1 subgoal):\n 1. z = Max (X \\<inter> {x..y})", "by auto"], ["proof (state)\nthis:\n  z = Max (X \\<inter> {x..y})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x)\n\ngoal (1 subgoal):\n 1. Sup X \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> Sup X)", "then"], ["proof (chain)\npicking this:\n  \\<exists>!x. x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x)", "show \"Sup X \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> Sup X)\""], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x)\n\ngoal (1 subgoal):\n 1. Sup X \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> Sup X)", "unfolding Sup_int_def"], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x)\n\ngoal (1 subgoal):\n 1. (THE x. x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x)) \\<in> X \\<and>\n    (\\<forall>y\\<in>X.\n        y \\<le> (THE x. x \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> x)))", "by (rule theI')"], ["proof (state)\nthis:\n  Sup X \\<in> X \\<and> (\\<forall>y\\<in>X. y \\<le> Sup X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas Sup_int_in = Sup_int[THEN conjunct1]"], ["", "lemma Inf_int_in:\n  fixes S :: \"int set\"\n  assumes \"S \\<noteq> {}\" \"bdd_below S\"\n  shows \"Inf S \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf S \\<in> S", "using assms"], ["proof (prove)\nusing this:\n  S \\<noteq> {}\n  bdd_below S\n\ngoal (1 subgoal):\n 1. Inf S \\<in> S", "unfolding Inf_int_def"], ["proof (prove)\nusing this:\n  S \\<noteq> {}\n  bdd_below S\n\ngoal (1 subgoal):\n 1. - Sup (uminus ` S) \\<in> S", "by (smt Sup_int_in bdd_above_uminus image_iff image_is_empty)"], ["", "lemma finite_setcompr_eq_image: \"finite {f x |x. P x} \\<longleftrightarrow> finite (f ` {x. P x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {f x |x. P x} = finite (f ` {x. P x})", "by (simp add: setcompr_eq_image)"], ["", "lemma finite_lists_length_le1: \"finite {xs. length xs \\<le> i \\<and> set xs \\<subseteq> {0..(n::nat)}}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. length xs \\<le> i \\<and> set xs \\<subseteq> {0..n}}", "by (auto intro: finite_subset[OF _ finite_lists_length_le[OF finite_atLeastAtMost]])"], ["", "lemma finite_lists_length_le2: \"finite {xs. length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..(n::nat)}}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}}", "by (auto intro: finite_subset[OF _ finite_lists_length_le1[of \"i\"]])"], ["", "lemmas [simp] =\n  finite_setcompr_eq_image finite_lists_length_le2[simplified] finite_lists_length_le1"], ["", "lemma get_return:\n  \"run_state (State_Monad.bind State_Monad.get (\\<lambda> m. State_Monad.return (f m))) m = (f m, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state\n     (State_Monad.get \\<bind> (\\<lambda>m. State_Monad.return (f m))) m =\n    (f m, m)", "by (simp add: State_Monad.bind_def State_Monad.get_def)"], ["", "lemma list_pidgeonhole:\n  assumes \"set xs \\<subseteq> S\" \"card S < length xs\" \"finite S\"\n  obtains as a bs cs where \"xs = as @ a # bs @ a # cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as a bs cs.\n        xs = as @ a # bs @ a # cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>as a bs cs.\n        xs = as @ a # bs @ a # cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> S\n  card S < length xs\n  finite S", "have \"\\<not> distinct xs\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> S\n  card S < length xs\n  finite S\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs", "by (metis card_mono distinct_card not_le)"], ["proof (state)\nthis:\n  \\<not> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs cs.\n        xs = as @ a # bs @ a # cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct xs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> distinct xs\n\ngoal (1 subgoal):\n 1. thesis", "by (metis append.assoc append_Cons not_distinct_conv_prefix split_list that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_eq_cycleE:\n  assumes \"v # ys @ [t] = as @ a # bs @ a # cs\"\n  obtains (Nil_Nil) \"as = []\" \"cs = []\" \"v = a\" \"a = t\" \"ys = bs\"\n  | (Nil_Cons) cs' where \"as = []\" \"v = a\" \"ys = bs @ a # cs'\" \"cs = cs' @ [t]\"\n  | (Cons_Nil) as' where \"as = v # as'\" \"cs = []\" \"a = t\" \"ys = as' @ a # bs\"\n  | (Cons_Cons) as' cs' where \"as = v # as'\" \"cs = cs' @ [t]\" \"ys = as' @ a # bs @ a # cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>as = []; cs = []; v = a; a = t; ys = bs\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<And>cs'.\n        \\<lbrakk>as = []; v = a; ys = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>as'.\n        \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>as' cs'.\n        \\<lbrakk>as = v # as'; cs = cs' @ [t];\n         ys = as' @ a # bs @ a # cs'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  v # ys @ [t] = as @ a # bs @ a # cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>as = []; cs = []; v = a; a = t; ys = bs\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<And>cs'.\n        \\<lbrakk>as = []; v = a; ys = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>as'.\n        \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>as' cs'.\n        \\<lbrakk>as = v # as'; cs = cs' @ [t];\n         ys = as' @ a # bs @ a # cs'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: Cons_eq_append_conv append_eq_Cons_conv append_eq_append_conv2)"], ["", "lemma le_add_same_cancel1:\n  \"a + b \\<ge> a \\<longleftrightarrow> b \\<ge> 0\" if \"a < \\<infinity>\" \"-\\<infinity> < a\" for a b :: \"int extended\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> a + b) = (0 \\<le> b)", "using that"], ["proof (prove)\nusing this:\n  a < \\<infinity>\n  -\\<infinity> < a\n\ngoal (1 subgoal):\n 1. (a \\<le> a + b) = (0 \\<le> b)", "by (cases a; cases b) (auto simp add: zero_extended_def)"], ["", "lemma add_gt_minfI:\n  assumes \"-\\<infinity> < a\" \"-\\<infinity> < b\"\n  shows \"-\\<infinity> < a + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. -\\<infinity> < a + b", "using assms"], ["proof (prove)\nusing this:\n  -\\<infinity> < a\n  -\\<infinity> < b\n\ngoal (1 subgoal):\n 1. -\\<infinity> < a + b", "by (cases a; cases b) auto"], ["", "lemma add_lt_infI:\n  assumes \"a < \\<infinity>\" \"b < \\<infinity>\"\n  shows \"a + b < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b < \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  a < \\<infinity>\n  b < \\<infinity>\n\ngoal (1 subgoal):\n 1. a + b < \\<infinity>", "by (cases a; cases b) auto"], ["", "lemma sum_list_not_infI:\n  \"sum_list xs < \\<infinity>\" if \"\\<forall> x \\<in> set xs. x < \\<infinity>\" for xs :: \"int extended list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs < \\<infinity>", "using that"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. x < \\<infinity>\n\ngoal (1 subgoal):\n 1. sum_list xs < \\<infinity>", "apply (induction xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. x < \\<infinity> \\<Longrightarrow>\n    sum_list [] < \\<infinity>\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x < \\<infinity> \\<Longrightarrow>\n                sum_list xs < \\<infinity>;\n        \\<forall>x\\<in>set (a # xs). x < \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # xs) < \\<infinity>", "apply (simp add: zero_extended_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sum_list xs < \\<infinity>;\n        a < \\<infinity> \\<and>\n        (\\<forall>x\\<in>set xs. x < \\<infinity>)\\<rbrakk>\n       \\<Longrightarrow> a + sum_list xs < \\<infinity>", "by (smt less_extended_simps(2) plus_extended.elims)"], ["", "lemma sum_list_not_minfI:\n  \"sum_list xs > -\\<infinity>\" if \"\\<forall> x \\<in> set xs. x > -\\<infinity>\" for xs :: \"int extended list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. -\\<infinity> < sum_list xs", "using that"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. -\\<infinity> < x\n\ngoal (1 subgoal):\n 1. -\\<infinity> < sum_list xs", "by (induction xs) (auto intro: add_gt_minfI simp: zero_extended_def)"], ["", "subsubsection \\<open>Single-Sink Shortest Path Problem\\<close>"], ["", "datatype bf_result = Path \"nat list\" int | No_Path | Computation_Error"], ["", "context\n  fixes n :: nat and W :: \"nat \\<Rightarrow> nat \\<Rightarrow> int extended\"\nbegin"], ["", "context\n  fixes t :: nat \\<comment> \\<open>Final node\\<close>\nbegin"], ["", "text \\<open>\n  The correctness proof closely follows Kleinberg \\<open>&\\<close> Tardos: \"Algorithm Design\",\n  chapter \"Dynamic Programming\" @{cite \"Kleinberg-Tardos\"}\n\\<close>"], ["", "fun weight :: \"nat list \\<Rightarrow> int extended\" where\n  \"weight [s] = 0\"\n| \"weight (i # j # xs) = W i j + weight (j # xs)\""], ["", "definition\n  \"OPT i v = (\n    Min (\n      {weight (v # xs @ [t]) | xs. length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n      {if t = v then 0 else \\<infinity>}\n    )\n  )\""], ["", "lemma weight_alt_def':\n  \"weight (s # xs) + w = snd (fold (\\<lambda>j (i, x). (j, W i j + x)) xs (s, w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.weight (s # xs) + w =\n    snd (fold (\\<lambda>j (i, x). (j, W i j + x)) xs (s, w))", "by (induction xs arbitrary: s w; simp; smt add.commute add.left_commute)"], ["", "lemma weight_alt_def:\n  \"weight (s # xs) = snd (fold (\\<lambda>j (i, x). (j, W i j + x)) xs (s, 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.weight (s # xs) =\n    snd (fold (\\<lambda>j (i, x). (j, W i j + x)) xs (s, 0))", "by (rule weight_alt_def'[of s xs 0, simplified])"], ["", "lemma weight_append:\n  \"weight (xs @ a # ys) = weight (xs @ [a]) + weight (a # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.weight (xs @ a # ys) =\n    local.weight (xs @ [a]) + local.weight (a # ys)", "by (induction xs rule: weight.induct; simp add: add.assoc)"], ["", "lemma OPT_0:\n  \"OPT 0 v = (if t = v then 0 else \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT 0 v = (if t = v then 0 else \\<infinity>)", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min ({local.weight (v # xs @ [t]) |xs.\n          length xs + 1 \\<le> 0 \\<and> set xs \\<subseteq> {0..n}} \\<union>\n         {if t = v then 0 else \\<infinity>}) =\n    (if t = v then 0 else \\<infinity>)", "by simp"], ["", "subsubsection \\<open>Functional Correctness\\<close>"], ["", "lemma OPT_cases:\n  obtains (path) xs where \"OPT i v = weight (v # xs @ [t])\" \"length xs + 1 \\<le> i\" \"set xs \\<subseteq> {0..n}\"\n  | (sink) \"v = t\" \"OPT i v = 0\"\n  | (unreachable) \"v \\<noteq> t\" \"OPT i v = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.OPT i v = local.weight (v # xs @ [t]);\n                 length xs + 1 \\<le> i; set xs \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>v = t; local.OPT i v = 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> t; local.OPT i v = \\<infinity>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>Min ({local.weight (v # xs @ [t]) |xs.\n                               length xs + 1 \\<le> i \\<and>\n                               set xs \\<subseteq> {0..n}} \\<union>\n                              {if t = v then 0 else \\<infinity>}) =\n                         local.weight (v # xs @ [t]);\n                 length xs + 1 \\<le> i; set xs \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>v = t;\n      Min ({local.weight (v # xs @ [t]) |xs.\n            length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>}) =\n      0\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> t;\n      Min ({local.weight (v # xs @ [t]) |xs.\n            length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>}) =\n      \\<infinity>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using Min_in[of \"{weight (v # xs @ [t]) |xs. length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}}\n    \\<union> {if t = v then 0 else \\<infinity>}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite\n            ({local.weight (v # xs @ [t]) |xs.\n              length xs + 1 \\<le> i \\<and>\n              set xs \\<subseteq> {0..n}} \\<union>\n             {if t = v then 0 else \\<infinity>});\n   {local.weight (v # xs @ [t]) |xs.\n    length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n   {if t = v then 0 else \\<infinity>} \\<noteq>\n   {}\\<rbrakk>\n  \\<Longrightarrow> Min ({local.weight (v # xs @ [t]) |xs.\n                          length xs + 1 \\<le> i \\<and>\n                          set xs \\<subseteq> {0..n}} \\<union>\n                         {if t = v then 0 else \\<infinity>})\n                    \\<in> {local.weight (v # xs @ [t]) |xs.\n                           length xs + 1 \\<le> i \\<and>\n                           set xs \\<subseteq> {0..n}} \\<union>\n                          {if t = v then 0 else \\<infinity>}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>Min ({local.weight (v # xs @ [t]) |xs.\n                               length xs + 1 \\<le> i \\<and>\n                               set xs \\<subseteq> {0..n}} \\<union>\n                              {if t = v then 0 else \\<infinity>}) =\n                         local.weight (v # xs @ [t]);\n                 length xs + 1 \\<le> i; set xs \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>v = t;\n      Min ({local.weight (v # xs @ [t]) |xs.\n            length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>}) =\n      0\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> t;\n      Min ({local.weight (v # xs @ [t]) |xs.\n            length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>}) =\n      \\<infinity>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: finite_lists_length_le2[simplified] split: if_split_asm)"], ["", "lemma OPT_Suc:\n  \"OPT (Suc i) v = min (OPT i v) (Min {OPT i w + W v w | w. w \\<le> n})\" (is \"?lhs = ?rhs\")\n  if \"t \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v =\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v =\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})", "have \"OPT i w + W v w \\<ge> OPT (Suc i) v\" if \"w \\<le> n\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "using OPT_cases[of i w]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>xs.\n              \\<lbrakk>local.OPT i w = local.weight (w # xs @ [t]);\n               length xs + 1 \\<le> i; set xs \\<subseteq> {0..n}\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<lbrakk>w = t; local.OPT i w = 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>w \\<noteq> t; local.OPT i w = \\<infinity>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>local.OPT i w = local.weight (w # xs @ [t]);\n        length xs + 1 \\<le> i; set xs \\<subseteq> {0..n}\\<rbrakk>\n       \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w\n 2. \\<lbrakk>w = t; local.OPT i w = 0\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w\n 3. \\<lbrakk>w \\<noteq> t; local.OPT i w = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "case (path xs)"], ["proof (state)\nthis:\n  local.OPT i w = local.weight (w # xs @ [t])\n  length xs + 1 \\<le> i\n  set xs \\<subseteq> {0..n}\n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>local.OPT i w = local.weight (w # xs @ [t]);\n        length xs + 1 \\<le> i; set xs \\<subseteq> {0..n}\\<rbrakk>\n       \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w\n 2. \\<lbrakk>w = t; local.OPT i w = 0\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w\n 3. \\<lbrakk>w \\<noteq> t; local.OPT i w = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "with \\<open>w \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  w \\<le> n\n  local.OPT i w = local.weight (w # xs @ [t])\n  length xs + 1 \\<le> i\n  set xs \\<subseteq> {0..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<le> n\n  local.OPT i w = local.weight (w # xs @ [t])\n  length xs + 1 \\<le> i\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "by (subst OPT_def) (auto intro!: Min_le exI[where x = \"w # xs\"] simp: add.commute)"], ["proof (state)\nthis:\n  local.OPT (Suc i) v \\<le> local.OPT i w + W v w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w = t; local.OPT i w = 0\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w\n 2. \\<lbrakk>w \\<noteq> t; local.OPT i w = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>w = t; local.OPT i w = 0\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w\n 2. \\<lbrakk>w \\<noteq> t; local.OPT i w = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "case sink"], ["proof (state)\nthis:\n  w = t\n  local.OPT i w = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w = t; local.OPT i w = 0\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w\n 2. \\<lbrakk>w \\<noteq> t; local.OPT i w = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "then"], ["proof (chain)\npicking this:\n  w = t\n  local.OPT i w = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  w = t\n  local.OPT i w = 0\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "by (subst OPT_def) (auto intro!: Min_le exI[where x = \"[]\"])"], ["proof (state)\nthis:\n  local.OPT (Suc i) v \\<le> local.OPT i w + W v w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> t; local.OPT i w = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> t; local.OPT i w = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "case unreachable"], ["proof (state)\nthis:\n  w \\<noteq> t\n  local.OPT i w = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> t; local.OPT i w = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "then"], ["proof (chain)\npicking this:\n  w \\<noteq> t\n  local.OPT i w = \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<noteq> t\n  local.OPT i w = \\<infinity>\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v \\<le> local.OPT i w + W v w", "by simp"], ["proof (state)\nthis:\n  local.OPT (Suc i) v \\<le> local.OPT i w + W v w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?w \\<le> n \\<Longrightarrow>\n  local.OPT (Suc i) v \\<le> local.OPT i ?w + W v ?w\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v =\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})", "then"], ["proof (chain)\npicking this:\n  ?w \\<le> n \\<Longrightarrow>\n  local.OPT (Suc i) v \\<le> local.OPT i ?w + W v ?w", "have \"Min {OPT i w + W v w |w. w \\<le> n} \\<ge> OPT (Suc i) v\""], ["proof (prove)\nusing this:\n  ?w \\<le> n \\<Longrightarrow>\n  local.OPT (Suc i) v \\<le> local.OPT i ?w + W v ?w\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v \\<le> Min {local.OPT i w + W v w |w. w \\<le> n}", "by (auto intro!: Min.boundedI)"], ["proof (state)\nthis:\n  local.OPT (Suc i) v \\<le> Min {local.OPT i w + W v w |w. w \\<le> n}\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v =\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})", "moreover"], ["proof (state)\nthis:\n  local.OPT (Suc i) v \\<le> Min {local.OPT i w + W v w |w. w \\<le> n}\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v =\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})", "have \"OPT i v \\<ge> OPT (Suc i) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v \\<le> local.OPT i v", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min ({local.weight (v # xs @ [t]) |xs.\n          length xs + 1 \\<le> Suc i \\<and>\n          set xs \\<subseteq> {0..n}} \\<union>\n         {if t = v then 0 else \\<infinity>})\n    \\<le> Min ({local.weight (v # xs @ [t]) |xs.\n                length xs + 1 \\<le> i \\<and>\n                set xs \\<subseteq> {0..n}} \\<union>\n               {if t = v then 0 else \\<infinity>})", "by (rule Min_antimono) auto"], ["proof (state)\nthis:\n  local.OPT (Suc i) v \\<le> local.OPT i v\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v =\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})", "ultimately"], ["proof (chain)\npicking this:\n  local.OPT (Suc i) v \\<le> Min {local.OPT i w + W v w |w. w \\<le> n}\n  local.OPT (Suc i) v \\<le> local.OPT i v", "have \"?lhs \\<le> ?rhs\""], ["proof (prove)\nusing this:\n  local.OPT (Suc i) v \\<le> Min {local.OPT i w + W v w |w. w \\<le> n}\n  local.OPT (Suc i) v \\<le> local.OPT i v\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v\n    \\<le> min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})", "by simp"], ["proof (state)\nthis:\n  local.OPT (Suc i) v\n  \\<le> min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v =\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})", "from OPT_cases[of \"Suc i\" v]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>xs.\n              \\<lbrakk>local.OPT (Suc i) v = local.weight (v # xs @ [t]);\n               length xs + 1 \\<le> Suc i; set xs \\<subseteq> {0..n}\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>v \\<noteq> t; local.OPT (Suc i) v = \\<infinity>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"?lhs \\<ge> ?rhs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>xs.\n              \\<lbrakk>local.OPT (Suc i) v = local.weight (v # xs @ [t]);\n               length xs + 1 \\<le> Suc i; set xs \\<subseteq> {0..n}\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>v \\<noteq> t; local.OPT (Suc i) v = \\<infinity>\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>local.OPT (Suc i) v = local.weight (v # xs @ [t]);\n        length xs + 1 \\<le> Suc i; set xs \\<subseteq> {0..n}\\<rbrakk>\n       \\<Longrightarrow> min (local.OPT i v)\n                          (Min {local.OPT i w + W v w |w. w \\<le> n})\n                         \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 3. \\<lbrakk>v \\<noteq> t; local.OPT (Suc i) v = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v", "case (path xs)"], ["proof (state)\nthis:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}\n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>local.OPT (Suc i) v = local.weight (v # xs @ [t]);\n        length xs + 1 \\<le> Suc i; set xs \\<subseteq> {0..n}\\<rbrakk>\n       \\<Longrightarrow> min (local.OPT i v)\n                          (Min {local.OPT i w + W v w |w. w \\<le> n})\n                         \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 3. \\<lbrakk>v \\<noteq> t; local.OPT (Suc i) v = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v", "note [simp] = path(1)"], ["proof (state)\nthis:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>local.OPT (Suc i) v = local.weight (v # xs @ [t]);\n        length xs + 1 \\<le> Suc i; set xs \\<subseteq> {0..n}\\<rbrakk>\n       \\<Longrightarrow> min (local.OPT i v)\n                          (Min {local.OPT i w + W v w |w. w \\<le> n})\n                         \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 3. \\<lbrakk>v \\<noteq> t; local.OPT (Suc i) v = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v", "from path"], ["proof (chain)\npicking this:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}", "consider\n      (zero) \"i = 0\" \"length xs = 0\" | (new) \"i > 0\" \"length xs = i\" | (old) \"length xs < i\""], ["proof (prove)\nusing this:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>i = 0; length xs = 0\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>0 < i; length xs = i\\<rbrakk> \\<Longrightarrow> thesis;\n     length xs < i \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases \"length xs = i\") auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>i = 0; length xs = 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>0 < i; length xs = i\\<rbrakk> \\<Longrightarrow> ?thesis;\n   length xs < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>local.OPT (Suc i) v = local.weight (v # xs @ [t]);\n        length xs + 1 \\<le> Suc i; set xs \\<subseteq> {0..n}\\<rbrakk>\n       \\<Longrightarrow> min (local.OPT i v)\n                          (Min {local.OPT i w + W v w |w. w \\<le> n})\n                         \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 3. \\<lbrakk>v \\<noteq> t; local.OPT (Suc i) v = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>i = 0; length xs = 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>0 < i; length xs = i\\<rbrakk> \\<Longrightarrow> ?thesis;\n   length xs < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>i = 0; length xs = 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>0 < i; length xs = i\\<rbrakk> \\<Longrightarrow> ?thesis;\n   length xs < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; length xs = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 3. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "case zero"], ["proof (state)\nthis:\n  i = 0\n  length xs = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; length xs = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 3. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "with path"], ["proof (chain)\npicking this:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}\n  i = 0\n  length xs = 0", "have \"OPT (Suc i) v = W v t\""], ["proof (prove)\nusing this:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}\n  i = 0\n  length xs = 0\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v = W v t", "by simp"], ["proof (state)\nthis:\n  local.OPT (Suc i) v = W v t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; length xs = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 3. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "also"], ["proof (state)\nthis:\n  local.OPT (Suc i) v = W v t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; length xs = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 3. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "have \"W v t = OPT i t + W v t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W v t = local.OPT i t + W v t", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. W v t =\n    Min ({local.weight (t # xs @ [t]) |xs.\n          length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n         {if t = t then 0 else \\<infinity>}) +\n    W v t", "using \\<open>i = 0\\<close>"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. W v t =\n    Min ({local.weight (t # xs @ [t]) |xs.\n          length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n         {if t = t then 0 else \\<infinity>}) +\n    W v t", "by auto"], ["proof (state)\nthis:\n  W v t = local.OPT i t + W v t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; length xs = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 3. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "also"], ["proof (state)\nthis:\n  W v t = local.OPT i t + W v t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; length xs = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 3. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "have \"\\<dots> \\<ge> Min {OPT i w + W v w |w. w \\<le> n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {local.OPT i w + W v w |w. w \\<le> n} \\<le> local.OPT i t + W v t", "using \\<open>t \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  t \\<le> n\n\ngoal (1 subgoal):\n 1. Min {local.OPT i w + W v w |w. w \\<le> n} \\<le> local.OPT i t + W v t", "by (auto intro: Min_le)"], ["proof (state)\nthis:\n  Min {local.OPT i w + W v w |w. w \\<le> n} \\<le> local.OPT i t + W v t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; length xs = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 3. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "finally"], ["proof (chain)\npicking this:\n  Min {local.OPT i w + W v w |w. w \\<le> n} \\<le> local.OPT (Suc i) v", "show ?thesis"], ["proof (prove)\nusing this:\n  Min {local.OPT i w + W v w |w. w \\<le> n} \\<le> local.OPT (Suc i) v\n\ngoal (1 subgoal):\n 1. min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "by (rule min.coboundedI2)"], ["proof (state)\nthis:\n  min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n  \\<le> local.OPT (Suc i) v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "case new"], ["proof (state)\nthis:\n  0 < i\n  length xs = i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "with \\<open>_ = i\\<close>"], ["proof (chain)\npicking this:\n  length xs = i\n  0 < i\n  length xs = i", "obtain u ys where [simp]: \"xs = u # ys\""], ["proof (prove)\nusing this:\n  length xs = i\n  0 < i\n  length xs = i\n\ngoal (1 subgoal):\n 1. (\\<And>u ys. xs = u # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs) auto"], ["proof (state)\nthis:\n  xs = u # ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "from path"], ["proof (chain)\npicking this:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}", "have \"OPT i u \\<le> weight (u # ys @ [t])\""], ["proof (prove)\nusing this:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. local.OPT i u \\<le> local.weight (u # ys @ [t])", "unfolding OPT_def"], ["proof (prove)\nusing this:\n  Min ({local.weight (v # xs @ [t]) |xs.\n        length xs + 1 \\<le> Suc i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n       {if t = v then 0 else \\<infinity>}) =\n  local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. Min ({local.weight (u # xs @ [t]) |xs.\n          length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n         {if t = u then 0 else \\<infinity>})\n    \\<le> local.weight (u # ys @ [t])", "by (intro Min_le) auto"], ["proof (state)\nthis:\n  local.OPT i u \\<le> local.weight (u # ys @ [t])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "from path"], ["proof (chain)\npicking this:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}", "have \"Min {OPT i w + W v w |w. w \\<le> n} \\<le> W v u + OPT i u\""], ["proof (prove)\nusing this:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. Min {local.OPT i w + W v w |w. w \\<le> n} \\<le> W v u + local.OPT i u", "by (intro Min_le) (auto simp: add.commute)"], ["proof (state)\nthis:\n  Min {local.OPT i w + W v w |w. w \\<le> n} \\<le> W v u + local.OPT i u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "also"], ["proof (state)\nthis:\n  Min {local.OPT i w + W v w |w. w \\<le> n} \\<le> W v u + local.OPT i u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "from \\<open>OPT i u \\<le> _\\<close>"], ["proof (chain)\npicking this:\n  local.OPT i u \\<le> local.weight (u # ys @ [t])", "have \"\\<dots> \\<le> OPT (Suc i) v\""], ["proof (prove)\nusing this:\n  local.OPT i u \\<le> local.weight (u # ys @ [t])\n\ngoal (1 subgoal):\n 1. W v u + local.OPT i u \\<le> local.OPT (Suc i) v", "by (simp add: add_left_mono)"], ["proof (state)\nthis:\n  W v u + local.OPT i u \\<le> local.OPT (Suc i) v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "finally"], ["proof (chain)\npicking this:\n  Min {local.OPT i w + W v w |w. w \\<le> n} \\<le> local.OPT (Suc i) v", "show ?thesis"], ["proof (prove)\nusing this:\n  Min {local.OPT i w + W v w |w. w \\<le> n} \\<le> local.OPT (Suc i) v\n\ngoal (1 subgoal):\n 1. min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "by (rule min.coboundedI2)"], ["proof (state)\nthis:\n  min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n  \\<le> local.OPT (Suc i) v\n\ngoal (1 subgoal):\n 1. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "case old"], ["proof (state)\nthis:\n  length xs < i\n\ngoal (1 subgoal):\n 1. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "with path"], ["proof (chain)\npicking this:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}\n  length xs < i", "have \"OPT i v \\<le> OPT (Suc i) v\""], ["proof (prove)\nusing this:\n  local.OPT (Suc i) v = local.weight (v # xs @ [t])\n  length xs + 1 \\<le> Suc i\n  set xs \\<subseteq> {0..n}\n  length xs < i\n\ngoal (1 subgoal):\n 1. local.OPT i v \\<le> local.OPT (Suc i) v", "by (auto 4 3 intro: Min_le simp: OPT_def)"], ["proof (state)\nthis:\n  local.OPT i v \\<le> local.OPT (Suc i) v\n\ngoal (1 subgoal):\n 1. length xs < i \\<Longrightarrow>\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "then"], ["proof (chain)\npicking this:\n  local.OPT i v \\<le> local.OPT (Suc i) v", "show ?thesis"], ["proof (prove)\nusing this:\n  local.OPT i v \\<le> local.OPT (Suc i) v\n\ngoal (1 subgoal):\n 1. min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "by (rule min.coboundedI1)"], ["proof (state)\nthis:\n  min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n  \\<le> local.OPT (Suc i) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n  \\<le> local.OPT (Suc i) v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>v \\<noteq> t; local.OPT (Suc i) v = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>v \\<noteq> t; local.OPT (Suc i) v = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v", "case unreachable"], ["proof (state)\nthis:\n  v \\<noteq> t\n  local.OPT (Suc i) v = \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v\n 2. \\<lbrakk>v \\<noteq> t; local.OPT (Suc i) v = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> t\n  local.OPT (Suc i) v = \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<noteq> t\n  local.OPT (Suc i) v = \\<infinity>\n\ngoal (1 subgoal):\n 1. min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "by simp"], ["proof (state)\nthis:\n  min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n  \\<le> local.OPT (Suc i) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v", "case sink"], ["proof (state)\nthis:\n  v = t\n  local.OPT (Suc i) v = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v", "then"], ["proof (chain)\npicking this:\n  v = t\n  local.OPT (Suc i) v = 0", "have \"OPT i v \\<le> OPT (Suc i) v\""], ["proof (prove)\nusing this:\n  v = t\n  local.OPT (Suc i) v = 0\n\ngoal (1 subgoal):\n 1. local.OPT i v \\<le> local.OPT (Suc i) v", "unfolding OPT_def"], ["proof (prove)\nusing this:\n  v = t\n  Min ({local.weight (v # xs @ [t]) |xs.\n        length xs + 1 \\<le> Suc i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n       {if t = v then 0 else \\<infinity>}) =\n  0\n\ngoal (1 subgoal):\n 1. Min ({local.weight (v # xs @ [t]) |xs.\n          length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n         {if t = v then 0 else \\<infinity>})\n    \\<le> Min ({local.weight (v # xs @ [t]) |xs.\n                length xs + 1 \\<le> Suc i \\<and>\n                set xs \\<subseteq> {0..n}} \\<union>\n               {if t = v then 0 else \\<infinity>})", "by auto"], ["proof (state)\nthis:\n  local.OPT i v \\<le> local.OPT (Suc i) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v = t; local.OPT (Suc i) v = 0\\<rbrakk>\n    \\<Longrightarrow> min (local.OPT i v)\n                       (Min {local.OPT i w + W v w |w. w \\<le> n})\n                      \\<le> local.OPT (Suc i) v", "then"], ["proof (chain)\npicking this:\n  local.OPT i v \\<le> local.OPT (Suc i) v", "show ?thesis"], ["proof (prove)\nusing this:\n  local.OPT i v \\<le> local.OPT (Suc i) v\n\ngoal (1 subgoal):\n 1. min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n    \\<le> local.OPT (Suc i) v", "by (rule min.coboundedI1)"], ["proof (state)\nthis:\n  min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n  \\<le> local.OPT (Suc i) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n  \\<le> local.OPT (Suc i) v\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v =\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})", "with \\<open>?lhs \\<le> ?rhs\\<close>"], ["proof (chain)\npicking this:\n  local.OPT (Suc i) v\n  \\<le> min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n  min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n  \\<le> local.OPT (Suc i) v", "show ?thesis"], ["proof (prove)\nusing this:\n  local.OPT (Suc i) v\n  \\<le> min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n  min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n  \\<le> local.OPT (Suc i) v\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) v =\n    min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})", "by (rule order.antisym)"], ["proof (state)\nthis:\n  local.OPT (Suc i) v =\n  min (local.OPT i v) (Min {local.OPT i w + W v w |w. w \\<le> n})\n\ngoal:\nNo subgoals!", "qed"], ["", "fun bf :: \"nat \\<Rightarrow> nat \\<Rightarrow> int extended\" where\n  \"bf 0 j = (if t = j then 0 else \\<infinity>)\"\n| \"bf (Suc k) j = min_list\n      (bf k j # [W j i + bf k i . i \\<leftarrow> [0 ..< Suc n]])\""], ["", "lemmas [simp del] = bf.simps"], ["", "lemmas bf_simps[simp] = bf.simps[unfolded min_list_fold]"], ["", "lemma bf_correct:\n  \"OPT i j = bf i j\" if \\<open>t \\<le> n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT i j = local.bf i j", "proof (induction i arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j. local.OPT 0 j = local.bf 0 j\n 2. \\<And>i j.\n       (\\<And>j. local.OPT i j = local.bf i j) \\<Longrightarrow>\n       local.OPT (Suc i) j = local.bf (Suc i) j", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>j. local.OPT 0 j = local.bf 0 j\n 2. \\<And>i j.\n       (\\<And>j. local.OPT i j = local.bf i j) \\<Longrightarrow>\n       local.OPT (Suc i) j = local.bf (Suc i) j", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT 0 j = local.bf 0 j", "by (simp add: OPT_0)"], ["proof (state)\nthis:\n  local.OPT 0 j = local.bf 0 j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (\\<And>j. local.OPT i j = local.bf i j) \\<Longrightarrow>\n       local.OPT (Suc i) j = local.bf (Suc i) j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (\\<And>j. local.OPT i j = local.bf i j) \\<Longrightarrow>\n       local.OPT (Suc i) j = local.bf (Suc i) j", "case (Suc i)"], ["proof (state)\nthis:\n  local.OPT i ?j = local.bf i ?j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (\\<And>j. local.OPT i j = local.bf i j) \\<Longrightarrow>\n       local.OPT (Suc i) j = local.bf (Suc i) j", "have *:\n    \"{bf i w + W j w |w. w \\<le> n} = set (map (\\<lambda>w. W j w + bf i w) [0..<Suc n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {local.bf i w + W j w |w. w \\<le> n} =\n    set (map (\\<lambda>w. W j w + local.bf i w) [0..<Suc n])", "by (fastforce simp: add.commute image_def)"], ["proof (state)\nthis:\n  {local.bf i w + W j w |w. w \\<le> n} =\n  set (map (\\<lambda>w. W j w + local.bf i w) [0..<Suc n])\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (\\<And>j. local.OPT i j = local.bf i j) \\<Longrightarrow>\n       local.OPT (Suc i) j = local.bf (Suc i) j", "from Suc \\<open>t \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  local.OPT i ?j = local.bf i ?j\n  t \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  local.OPT i ?j = local.bf i ?j\n  t \\<le> n\n\ngoal (1 subgoal):\n 1. local.OPT (Suc i) j = local.bf (Suc i) j", "by (simp add: OPT_Suc del: upt_Suc, subst Min.set_eq_fold[symmetric], auto simp: *)"], ["proof (state)\nthis:\n  local.OPT (Suc i) j = local.bf (Suc i) j\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Functional Memoization\\<close>"], ["", "memoize_fun bf\\<^sub>m: bf with_memory dp_consistency_mapping"], ["", "monadifies (state) bf.simps"], ["", "text \\<open>Generated Definitions\\<close>"], ["", "context includes state_monad_syntax begin"], ["", "thm bf\\<^sub>m'.simps bf\\<^sub>m_def"], ["", "end"], ["", "text \\<open>Correspondence Proof\\<close>"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y)\n     (\\<lambda>(x, y). local.bf\\<^sub>m' x y)", "by memoize_prover"], ["", "print_theorems"], ["", "lemmas [code] = bf\\<^sub>m.memoized_correct"], ["", "interpretation iterator\n  \"\\<lambda> (x, y). x \\<le> n \\<and> y \\<le> n\"\n  \"\\<lambda> (x, y). if y < n then (x, y + 1) else (x + 1, 0)\"\n  \"\\<lambda> (x, y). x * (n + 1) + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterator (\\<lambda>(x, y). x \\<le> n \\<and> y \\<le> n)\n     (\\<lambda>(x, y). if y < n then (x, y + 1) else (x + 1, 0))\n     (\\<lambda>(x, y). x * (n + 1) + y)", "by (rule table_iterator_up)"], ["", "interpretation bottom_up: dp_consistency_iterator_empty\n  \"\\<lambda> (_::(nat \\<times> nat, int extended) mapping). True\"\n  \"\\<lambda> (x, y). bf x y\"\n  \"\\<lambda> k. do {m \\<leftarrow> State_Monad.get; State_Monad.return (Mapping.lookup m k :: int extended option)}\"\n  \"\\<lambda> k v. do {m \\<leftarrow> State_Monad.get; State_Monad.set (Mapping.update k v m)}\"\n  \"\\<lambda> (x, y). x \\<le> n \\<and> y \\<le> n\"\n  \"\\<lambda> (x, y). if y < n then (x, y + 1) else (x + 1, 0)\"\n  \"\\<lambda> (x, y). x * (n + 1) + y\"\n  Mapping.empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_iterator_empty (\\<lambda>_. True)\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>k v.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.set (Mapping.update k v m)))\n     (\\<lambda>(x, y). x \\<le> n \\<and> y \\<le> n)\n     (\\<lambda>(x, y). if y < n then (x, y + 1) else (x + 1, 0))\n     (\\<lambda>(x, y). x * (n + 1) + y) Mapping.empty", ".."], ["", "definition\n  \"iter_bf = iter_state (\\<lambda> (x, y). bf\\<^sub>m' x y)\""], ["", "lemma iter_bf_unfold[code]:\n  \"iter_bf = (\\<lambda> (i, j).\n    (if i \\<le> n \\<and> j \\<le> n\n     then do {\n            bf\\<^sub>m' i j;\n            iter_bf (if j < n then (i, j + 1) else (i + 1, 0))\n          }\n     else State_Monad.return ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.iter_bf =\n    (\\<lambda>(i, j).\n        if i \\<le> n \\<and> j \\<le> n\n        then local.bf\\<^sub>m' i j \\<bind>\n             (\\<lambda>_.\n                 local.iter_bf (if j < n then (i, j + 1) else (i + 1, 0)))\n        else State_Monad.return ())", "unfolding iter_bf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iter_state (\\<lambda>(x, y). local.bf\\<^sub>m' x y) =\n    (\\<lambda>(i, j).\n        if i \\<le> n \\<and> j \\<le> n\n        then local.bf\\<^sub>m' i j \\<bind>\n             (\\<lambda>_.\n                 iter_state (\\<lambda>(x, y). local.bf\\<^sub>m' x y)\n                  (if j < n then (i, j + 1) else (i + 1, 0)))\n        else State_Monad.return ())", "by (rule ext) (safe, clarsimp simp: iter_state_unfold)"], ["", "lemmas bf_memoized = bf\\<^sub>m.memoized[OF bf\\<^sub>m.crel]"], ["", "lemmas bf_bottom_up = bottom_up.memoized[OF bf\\<^sub>m.crel, folded iter_bf_def]"], ["", "text \\<open>\nThis will be our final implementation, which includes detection of negative cycles.\nSee the corresponding section below for the correctness proof.\n\\<close>"], ["", "definition\n  \"bellman_ford \\<equiv>\n    do {\n      _  \\<leftarrow> iter_bf (n, n);\n      xs \\<leftarrow> State_Main.map\\<^sub>T' (\\<lambda>i. bf\\<^sub>m' n i) [0..<n+1];\n      ys \\<leftarrow> State_Main.map\\<^sub>T' (\\<lambda>i. bf\\<^sub>m' (n + 1) i) [0..<n+1];\n      State_Monad.return (if xs = ys then Some xs else None)\n    }\""], ["", "context\n  includes state_monad_syntax\nbegin"], ["", "lemma bellman_ford_alt_def:\n  \"bellman_ford \\<equiv>\n    do {\n      _  \\<leftarrow> iter_bf (n, n);\n      (\\<langle>\\<lambda>xs. \\<langle>\\<lambda>ys. State_Monad.return (if xs = ys then Some xs else None)\\<rangle>\n      . (State_Main.map\\<^sub>T . \\<langle>\\<lambda>i. bf\\<^sub>m' (n + 1) i\\<rangle> . \\<langle>[0..<n+1]\\<rangle>)\\<rangle>)\n      . (State_Main.map\\<^sub>T . \\<langle>\\<lambda>i. bf\\<^sub>m' n i\\<rangle>       . \\<langle>[0..<n+1]\\<rangle>)\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bellman_ford \\<equiv>\n    local.iter_bf (n, n) \\<bind>\n    (\\<lambda>_.\n        \\<langle>\\<lambda>xs.\n                    \\<langle>\\<lambda>ys.\n                                \\<langle>if xs = ys then Some xs\n   else None\\<rangle>\\<rangle> .\n                    (State_Main.map\\<^sub>T .\n                     \\<langle>local.bf\\<^sub>m' (n + 1)\\<rangle> .\n                     \\<langle>[0..<n + 1]\\<rangle>)\\<rangle> .\n        (State_Main.map\\<^sub>T . \\<langle>local.bf\\<^sub>m' n\\<rangle> .\n         \\<langle>[0..<n + 1]\\<rangle>))", "unfolding\n    State_Monad_Ext.fun_app_lifted_def bellman_ford_def State_Main.map\\<^sub>T_def bind_left_identity"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.iter_bf (n, n) \\<bind>\n    (\\<lambda>_.\n        State_Main.map\\<^sub>T' (local.bf\\<^sub>m' n) [0..<n + 1] \\<bind>\n        (\\<lambda>xs.\n            State_Main.map\\<^sub>T' (local.bf\\<^sub>m' (n + 1))\n             [0..<n + 1] \\<bind>\n            (\\<lambda>ys.\n                \\<langle>if xs = ys then Some xs\n                         else None\\<rangle>))) \\<equiv>\n    local.iter_bf (n, n) \\<bind>\n    (\\<lambda>_.\n        State_Main.map\\<^sub>T' (local.bf\\<^sub>m' n) [0..<n + 1] \\<bind>\n        (\\<lambda>xs.\n            State_Main.map\\<^sub>T' (local.bf\\<^sub>m' (n + 1))\n             [0..<n + 1] \\<bind>\n            (\\<lambda>ys.\n                \\<langle>if xs = ys then Some xs else None\\<rangle>)))", "."], ["", "end"], ["", "subsubsection \\<open>Imperative Memoization\\<close>"], ["", "context\n  fixes mem :: \"nat ref \\<times> nat ref \\<times> int extended option array ref \\<times> int extended option array ref\"\n  assumes mem_is_init: \"mem = result_of (init_state (n + 1) 1 0) Heap.empty\"\nbegin"], ["", "lemma [intro]:\n  \"dp_consistency_heap_array_pair' (n + 1) fst snd id 1 0 mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_array_pair' (n + 1) fst snd id 1 0 mem", "by (standard; simp add: mem_is_init injective_def)"], ["", "interpretation iterator\n  \"\\<lambda> (x, y). x \\<le> n \\<and> y \\<le> n\"\n  \"\\<lambda> (x, y). if y < n then (x, y + 1) else (x + 1, 0)\"\n  \"\\<lambda> (x, y). x * (n + 1) + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterator (\\<lambda>(x, y). x \\<le> n \\<and> y \\<le> n)\n     (\\<lambda>(x, y). if y < n then (x, y + 1) else (x + 1, 0))\n     (\\<lambda>(x, y). x * (n + 1) + y)", "by (rule table_iterator_up)"], ["", "lemma [intro]:\n  \"dp_consistency_heap_array_pair_iterator (n + 1) fst snd id 1 0 mem\n  (\\<lambda> (x, y). if y < n then (x, y + 1) else (x + 1, 0))\n  (\\<lambda> (x, y). x * (n + 1) + y)\n  (\\<lambda> (x, y). x \\<le> n \\<and> y \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_array_pair_iterator (n + 1) fst snd id 1 0 mem\n     (\\<lambda>(x, y). if y < n then (x, y + 1) else (x + 1, 0))\n     (\\<lambda>(x, y). x * (n + 1) + y)\n     (\\<lambda>(x, y). x \\<le> n \\<and> y \\<le> n)", "by (standard; simp add: mem_is_init injective_def)"], ["", "memoize_fun bf\\<^sub>h: bf\n  with_memory (default_proof) dp_consistency_heap_array_pair_iterator\n  where size = \"n + 1\"\n    and key1 = \"fst :: nat \\<times> nat \\<Rightarrow> nat\" and key2 = \"snd :: nat \\<times> nat \\<Rightarrow> nat\"\n    and k1 = \"1 :: nat\" and k2 = \"0 :: nat\"\n    and to_index = \"id :: nat \\<Rightarrow> nat\"\n    and mem = mem\n    and cnt = \"\\<lambda> (x, y). x \\<le> n \\<and> y \\<le> n\"\n    and nxt = \"\\<lambda> (x :: nat, y). if y < n then (x, y + 1) else (x + 1, 0)\"\n    and sizef = \"\\<lambda> (x, y). x * (n + 1) + y\""], ["", "monadifies (heap) bf.simps"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. bf\\<^sub>h.consistentDP (\\<lambda>(x, y). local.bf\\<^sub>h' x y)", "by memoize_prover"], ["", "lemmas memoized_empty = bf\\<^sub>h.memoized_empty[OF bf\\<^sub>h.consistent_DP_iter_and_compute[OF bf\\<^sub>h.crel]]"], ["", "lemmas iter_heap_unfold = iter_heap_unfold"], ["", "end"], ["", "(* Fixed Memory *)"], ["", "subsubsection \\<open>Detecting Negative Cycles\\<close>"], ["", "definition\n  \"shortest v = (\n    Inf (\n      {weight (v # xs @ [t]) | xs. set xs \\<subseteq> {0..n}} \\<union>\n      {if t = v then 0 else \\<infinity>}\n    )\n  )\""], ["", "definition\n  \"is_path xs \\<equiv> weight (xs @ [t]) < \\<infinity>\""], ["", "definition\n  \"has_negative_cycle \\<equiv>\n  \\<exists>xs a ys. set (a # xs @ ys) \\<subseteq> {0..n} \\<and> weight (a # xs @ [a]) < 0 \\<and> is_path (a # ys)\""], ["", "definition\n  \"reaches a \\<equiv> \\<exists>xs. is_path (a # xs) \\<and> a \\<le> n \\<and> set xs \\<subseteq> {0..n}\""], ["", "lemma fold_sum_aux':\n  assumes \"\\<forall>u \\<in> set (a # xs). \\<forall>v \\<in> set (xs @ [b]). f v + W u v \\<ge> f u\"\n  shows \"sum_list (map f (a # xs)) \\<le> sum_list (map f (xs @ [b])) + weight (a # xs @ [b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (a # xs))\n    \\<le> sum_list (map f (xs @ [b])) + local.weight (a # xs @ [b])", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>set (a # xs).\n     \\<forall>v\\<in>set (xs @ [b]). f u \\<le> f v + W u v\n\ngoal (1 subgoal):\n 1. sum_list (map f (a # xs))\n    \\<le> sum_list (map f (xs @ [b])) + local.weight (a # xs @ [b])", "by (induction xs arbitrary: a; simp)\n     (smt ab_semigroup_add_class.add_ac(1) add.left_commute add_mono)"], ["", "lemma fold_sum_aux:\n  assumes \"\\<forall>u \\<in> set (a # xs). \\<forall>v \\<in> set (a # xs). f v + W u v \\<ge> f u\"\n  shows \"sum_list (map f (a # xs @ [a])) \\<le> sum_list (map f (a # xs @ [a])) + weight (a # xs @ [a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (a # xs @ [a]))\n    \\<le> sum_list (map f (a # xs @ [a])) + local.weight (a # xs @ [a])", "using fold_sum_aux'[of a xs a f] assms"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>set (a # xs).\n     \\<forall>v\\<in>set (xs @ [a]). f u \\<le> f v + W u v \\<Longrightarrow>\n  sum_list (map f (a # xs))\n  \\<le> sum_list (map f (xs @ [a])) + local.weight (a # xs @ [a])\n  \\<forall>u\\<in>set (a # xs).\n     \\<forall>v\\<in>set (a # xs). f u \\<le> f v + W u v\n\ngoal (1 subgoal):\n 1. sum_list (map f (a # xs @ [a]))\n    \\<le> sum_list (map f (a # xs @ [a])) + local.weight (a # xs @ [a])", "by auto (metis (no_types, hide_lams) add.assoc add.commute add_left_mono)"], ["", "context\nbegin"], ["", "private"], ["", "definition \"is_path2 xs \\<equiv> weight xs < \\<infinity>\""], ["", "private"], ["", "lemma is_path2_remove_cycle:\n  assumes \"is_path2 (as @ a # bs @ a # cs)\"\n  shows \"is_path2 (as @ a # cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path2 (as @ a # cs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_path2 (as @ a # cs)", "have \"weight (as @ a # bs @ a # cs) =\n    weight (as @ [a]) + weight (a # bs @ [a]) + weight (a # cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.weight (as @ a # bs @ a # cs) =\n    local.weight (as @ [a]) + local.weight (a # bs @ [a]) +\n    local.weight (a # cs)", "by (metis Bellman_Ford.weight_append append_Cons append_assoc)"], ["proof (state)\nthis:\n  local.weight (as @ a # bs @ a # cs) =\n  local.weight (as @ [a]) + local.weight (a # bs @ [a]) +\n  local.weight (a # cs)\n\ngoal (1 subgoal):\n 1. is_path2 (as @ a # cs)", "with assms"], ["proof (chain)\npicking this:\n  is_path2 (as @ a # bs @ a # cs)\n  local.weight (as @ a # bs @ a # cs) =\n  local.weight (as @ [a]) + local.weight (a # bs @ [a]) +\n  local.weight (a # cs)", "have \"weight (as @ [a]) < \\<infinity>\" \"weight (a # cs) < \\<infinity>\""], ["proof (prove)\nusing this:\n  is_path2 (as @ a # bs @ a # cs)\n  local.weight (as @ a # bs @ a # cs) =\n  local.weight (as @ [a]) + local.weight (a # bs @ [a]) +\n  local.weight (a # cs)\n\ngoal (1 subgoal):\n 1. local.weight (as @ [a]) < \\<infinity> &&&\n    local.weight (a # cs) < \\<infinity>", "unfolding is_path2_def"], ["proof (prove)\nusing this:\n  local.weight (as @ a # bs @ a # cs) < \\<infinity>\n  local.weight (as @ a # bs @ a # cs) =\n  local.weight (as @ [a]) + local.weight (a # bs @ [a]) +\n  local.weight (a # cs)\n\ngoal (1 subgoal):\n 1. local.weight (as @ [a]) < \\<infinity> &&&\n    local.weight (a # cs) < \\<infinity>", "by (simp, metis Pinf_add_right antisym less_extended_simps(4) not_less add.commute)+"], ["proof (state)\nthis:\n  local.weight (as @ [a]) < \\<infinity>\n  local.weight (a # cs) < \\<infinity>\n\ngoal (1 subgoal):\n 1. is_path2 (as @ a # cs)", "then"], ["proof (chain)\npicking this:\n  local.weight (as @ [a]) < \\<infinity>\n  local.weight (a # cs) < \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  local.weight (as @ [a]) < \\<infinity>\n  local.weight (a # cs) < \\<infinity>\n\ngoal (1 subgoal):\n 1. is_path2 (as @ a # cs)", "unfolding is_path2_def"], ["proof (prove)\nusing this:\n  local.weight (as @ [a]) < \\<infinity>\n  local.weight (a # cs) < \\<infinity>\n\ngoal (1 subgoal):\n 1. local.weight (as @ a # cs) < \\<infinity>", "by (subst weight_append) (rule add_lt_infI)"], ["proof (state)\nthis:\n  is_path2 (as @ a # cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma is_path_eq:\n  \"is_path xs \\<longleftrightarrow> is_path2 (xs @ [t])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.is_path xs = is_path2 (xs @ [t])", "unfolding is_path_def is_path2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.weight (xs @ [t]) < \\<infinity>) =\n    (local.weight (xs @ [t]) < \\<infinity>)", ".."], ["", "lemma is_path_remove_cycle:\n  assumes \"is_path (as @ a # bs @ a # cs)\"\n  shows \"is_path (as @ a # cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.is_path (as @ a # cs)", "using assms"], ["proof (prove)\nusing this:\n  local.is_path (as @ a # bs @ a # cs)\n\ngoal (1 subgoal):\n 1. local.is_path (as @ a # cs)", "unfolding is_path_eq"], ["proof (prove)\nusing this:\n  is_path2 ((as @ a # bs @ a # cs) @ [t])\n\ngoal (1 subgoal):\n 1. is_path2 ((as @ a # cs) @ [t])", "by (simp add: is_path2_remove_cycle)"], ["", "lemma is_path_remove_cycle2:\n  assumes \"is_path (as @ t # cs)\"\n  shows \"is_path as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.is_path as", "using assms"], ["proof (prove)\nusing this:\n  local.is_path (as @ t # cs)\n\ngoal (1 subgoal):\n 1. local.is_path as", "unfolding is_path_eq"], ["proof (prove)\nusing this:\n  is_path2 ((as @ t # cs) @ [t])\n\ngoal (1 subgoal):\n 1. is_path2 (as @ [t])", "by (simp add: is_path2_remove_cycle)"], ["", "end"], ["", "(* private lemmas *)"], ["", "lemma is_path_shorten:\n  assumes \"is_path (i # xs)\" \"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"t \\<le> n\" \"t \\<noteq> i\"\n  obtains xs where \"is_path (i # xs)\" \"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"length xs < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n         set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"length xs < n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n                 set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length xs < n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n                 set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> length xs < n\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  length xs < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n                 set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length xs < n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n                 set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> length xs < n\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms"], ["proof (chain)\npicking this:\n  local.is_path (i # xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  t \\<le> n\n  t \\<noteq> i\n  length xs < n", "show ?thesis"], ["proof (prove)\nusing this:\n  local.is_path (i # xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  t \\<le> n\n  t \\<noteq> i\n  length xs < n\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n                 set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> length xs < n\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n                 set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> length xs < n\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> length xs < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n                 set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> length xs < n\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<not> length xs < n", "have \"length xs \\<ge> n\""], ["proof (prove)\nusing this:\n  \\<not> length xs < n\n\ngoal (1 subgoal):\n 1. n \\<le> length xs", "by auto"], ["proof (state)\nthis:\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n                 set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> length xs < n\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms(1,3)"], ["proof (chain)\npicking this:\n  local.is_path (i # xs)\n  set xs \\<subseteq> {0..n}\n  n \\<le> length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  local.is_path (i # xs)\n  set xs \\<subseteq> {0..n}\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. thesis", "proof (induction \"length xs\" arbitrary: xs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs; local.is_path (i # xsa);\n                    set xsa \\<subseteq> {0..n}; n \\<le> length xsa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        local.is_path (i # xs); set xs \\<subseteq> {0..n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> thesis", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>length ?xs2 < length xs; local.is_path (i # ?xs2);\n   set ?xs2 \\<subseteq> {0..n}; n \\<le> length ?xs2\\<rbrakk>\n  \\<Longrightarrow> thesis\n  local.is_path (i # xs)\n  set xs \\<subseteq> {0..n}\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs; local.is_path (i # xsa);\n                    set xsa \\<subseteq> {0..n}; n \\<le> length xsa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        local.is_path (i # xs); set xs \\<subseteq> {0..n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?xs2 < length xs; local.is_path (i # ?xs2);\n   set ?xs2 \\<subseteq> {0..n}; n \\<le> length ?xs2\\<rbrakk>\n  \\<Longrightarrow> thesis\n  local.is_path (i # xs)\n  set xs \\<subseteq> {0..n}\n  n \\<le> length xs", "have \"length (i # xs @ [t]) > card ({0..n})\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?xs2 < length xs; local.is_path (i # ?xs2);\n   set ?xs2 \\<subseteq> {0..n}; n \\<le> length ?xs2\\<rbrakk>\n  \\<Longrightarrow> thesis\n  local.is_path (i # xs)\n  set xs \\<subseteq> {0..n}\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. card {0..n} < length (i # xs @ [t])", "by auto"], ["proof (state)\nthis:\n  card {0..n} < length (i # xs @ [t])\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs; local.is_path (i # xsa);\n                    set xsa \\<subseteq> {0..n}; n \\<le> length xsa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        local.is_path (i # xs); set xs \\<subseteq> {0..n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  card {0..n} < length (i # xs @ [t])\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs; local.is_path (i # xsa);\n                    set xsa \\<subseteq> {0..n}; n \\<le> length xsa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        local.is_path (i # xs); set xs \\<subseteq> {0..n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> thesis", "from less.prems \\<open>i \\<le> n\\<close> \\<open>t \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  local.is_path (i # xs)\n  set xs \\<subseteq> {0..n}\n  n \\<le> length xs\n  i \\<le> n\n  t \\<le> n", "have \"set (i # xs @ [t]) \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  local.is_path (i # xs)\n  set xs \\<subseteq> {0..n}\n  n \\<le> length xs\n  i \\<le> n\n  t \\<le> n\n\ngoal (1 subgoal):\n 1. set (i # xs @ [t]) \\<subseteq> {0..n}", "by auto"], ["proof (state)\nthis:\n  set (i # xs @ [t]) \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs; local.is_path (i # xsa);\n                    set xsa \\<subseteq> {0..n}; n \\<le> length xsa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        local.is_path (i # xs); set xs \\<subseteq> {0..n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  card {0..n} < length (i # xs @ [t])\n  set (i # xs @ [t]) \\<subseteq> {0..n}", "obtain a as bs cs where *: \"i # xs @ [t] = as @ a # bs @ a # cs\""], ["proof (prove)\nusing this:\n  card {0..n} < length (i # xs @ [t])\n  set (i # xs @ [t]) \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs cs.\n        i # xs @ [t] = as @ a # bs @ a # cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (elim list_pidgeonhole) auto"], ["proof (state)\nthis:\n  i # xs @ [t] = as @ a # bs @ a # cs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs; local.is_path (i # xsa);\n                    set xsa \\<subseteq> {0..n}; n \\<le> length xsa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        local.is_path (i # xs); set xs \\<subseteq> {0..n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain ys where ys: \"is_path (i # ys)\" \"length ys < length xs\" \"set (i # ys) \\<subseteq> {0..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>local.is_path (i # ys); length ys < length xs;\n         set (i # ys) \\<subseteq> {0..n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       local.is_path (i # ys) \\<and>\n       length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}", "using *"], ["proof (prove)\nusing this:\n  i # xs @ [t] = as @ a # bs @ a # cs\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       local.is_path (i # ys) \\<and>\n       length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}", "proof (cases rule: path_eq_cycleE)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>as = []; cs = []; i = a; a = t; xs = bs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys.\n                         local.is_path (i # ys) \\<and>\n                         length ys < length xs \\<and>\n                         set (i # ys) \\<subseteq> {0..n}\n 2. \\<And>cs'.\n       \\<lbrakk>as = []; i = a; xs = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 3. \\<And>as'.\n       \\<lbrakk>as = i # as'; cs = []; a = t; xs = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 4. \\<And>as' cs'.\n       \\<lbrakk>as = i # as'; cs = cs' @ [t];\n        xs = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}", "case Nil_Nil"], ["proof (state)\nthis:\n  as = []\n  cs = []\n  i = a\n  a = t\n  xs = bs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>as = []; cs = []; i = a; a = t; xs = bs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys.\n                         local.is_path (i # ys) \\<and>\n                         length ys < length xs \\<and>\n                         set (i # ys) \\<subseteq> {0..n}\n 2. \\<And>cs'.\n       \\<lbrakk>as = []; i = a; xs = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 3. \\<And>as'.\n       \\<lbrakk>as = i # as'; cs = []; a = t; xs = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 4. \\<And>as' cs'.\n       \\<lbrakk>as = i # as'; cs = cs' @ [t];\n        xs = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}", "with \\<open>t \\<noteq> i\\<close>"], ["proof (chain)\npicking this:\n  t \\<noteq> i\n  as = []\n  cs = []\n  i = a\n  a = t\n  xs = bs", "show \"\\<exists>ys. is_path (i # ys) \\<and> length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  t \\<noteq> i\n  as = []\n  cs = []\n  i = a\n  a = t\n  xs = bs\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       local.is_path (i # ys) \\<and>\n       length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}", "by auto"], ["proof (state)\nthis:\n  \\<exists>ys.\n     local.is_path (i # ys) \\<and>\n     length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}\n\ngoal (3 subgoals):\n 1. \\<And>cs'.\n       \\<lbrakk>as = []; i = a; xs = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 2. \\<And>as'.\n       \\<lbrakk>as = i # as'; cs = []; a = t; xs = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 3. \\<And>as' cs'.\n       \\<lbrakk>as = i # as'; cs = cs' @ [t];\n        xs = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs'.\n       \\<lbrakk>as = []; i = a; xs = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 2. \\<And>as'.\n       \\<lbrakk>as = i # as'; cs = []; a = t; xs = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 3. \\<And>as' cs'.\n       \\<lbrakk>as = i # as'; cs = cs' @ [t];\n        xs = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}", "case (Nil_Cons cs')"], ["proof (state)\nthis:\n  as = []\n  i = a\n  xs = bs @ a # cs'\n  cs = cs' @ [t]\n\ngoal (3 subgoals):\n 1. \\<And>cs'.\n       \\<lbrakk>as = []; i = a; xs = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 2. \\<And>as'.\n       \\<lbrakk>as = i # as'; cs = []; a = t; xs = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 3. \\<And>as' cs'.\n       \\<lbrakk>as = i # as'; cs = cs' @ [t];\n        xs = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}", "then"], ["proof (chain)\npicking this:\n  as = []\n  i = a\n  xs = bs @ a # cs'\n  cs = cs' @ [t]", "show \"\\<exists>ys. is_path (i # ys) \\<and> length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  as = []\n  i = a\n  xs = bs @ a # cs'\n  cs = cs' @ [t]\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       local.is_path (i # ys) \\<and>\n       length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}", "using \\<open>set (i # xs @ [t]) \\<subseteq> {0..n}\\<close> \\<open>is_path (i # xs)\\<close> is_path_remove_cycle[of \"[]\"]"], ["proof (prove)\nusing this:\n  as = []\n  i = a\n  xs = bs @ a # cs'\n  cs = cs' @ [t]\n  set (i # xs @ [t]) \\<subseteq> {0..n}\n  local.is_path (i # xs)\n  local.is_path ([] @ ?a # ?bs @ ?a # ?cs) \\<Longrightarrow>\n  local.is_path ([] @ ?a # ?cs)\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       local.is_path (i # ys) \\<and>\n       length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}", "by - (rule exI[where x = cs'], simp)"], ["proof (state)\nthis:\n  \\<exists>ys.\n     local.is_path (i # ys) \\<and>\n     length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}\n\ngoal (2 subgoals):\n 1. \\<And>as'.\n       \\<lbrakk>as = i # as'; cs = []; a = t; xs = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 2. \\<And>as' cs'.\n       \\<lbrakk>as = i # as'; cs = cs' @ [t];\n        xs = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as'.\n       \\<lbrakk>as = i # as'; cs = []; a = t; xs = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 2. \\<And>as' cs'.\n       \\<lbrakk>as = i # as'; cs = cs' @ [t];\n        xs = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}", "case (Cons_Nil as')"], ["proof (state)\nthis:\n  as = i # as'\n  cs = []\n  a = t\n  xs = as' @ a # bs\n\ngoal (2 subgoals):\n 1. \\<And>as'.\n       \\<lbrakk>as = i # as'; cs = []; a = t; xs = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}\n 2. \\<And>as' cs'.\n       \\<lbrakk>as = i # as'; cs = cs' @ [t];\n        xs = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}", "then"], ["proof (chain)\npicking this:\n  as = i # as'\n  cs = []\n  a = t\n  xs = as' @ a # bs", "show \"\\<exists>ys. is_path (i # ys) \\<and> length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  as = i # as'\n  cs = []\n  a = t\n  xs = as' @ a # bs\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       local.is_path (i # ys) \\<and>\n       length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}", "using \\<open>set (i # xs @ [t]) \\<subseteq> {0..n}\\<close> \\<open>is_path (i # xs)\\<close>"], ["proof (prove)\nusing this:\n  as = i # as'\n  cs = []\n  a = t\n  xs = as' @ a # bs\n  set (i # xs @ [t]) \\<subseteq> {0..n}\n  local.is_path (i # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       local.is_path (i # ys) \\<and>\n       length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}", "by - (rule exI[where x = as'], auto intro: is_path_remove_cycle2)"], ["proof (state)\nthis:\n  \\<exists>ys.\n     local.is_path (i # ys) \\<and>\n     length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. \\<And>as' cs'.\n       \\<lbrakk>as = i # as'; cs = cs' @ [t];\n        xs = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as' cs'.\n       \\<lbrakk>as = i # as'; cs = cs' @ [t];\n        xs = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}", "case (Cons_Cons as' cs')"], ["proof (state)\nthis:\n  as = i # as'\n  cs = cs' @ [t]\n  xs = as' @ a # bs @ a # cs'\n\ngoal (1 subgoal):\n 1. \\<And>as' cs'.\n       \\<lbrakk>as = i # as'; cs = cs' @ [t];\n        xs = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            local.is_path (i # ys) \\<and>\n                            length ys < length xs \\<and>\n                            set (i # ys) \\<subseteq> {0..n}", "then"], ["proof (chain)\npicking this:\n  as = i # as'\n  cs = cs' @ [t]\n  xs = as' @ a # bs @ a # cs'", "show \"\\<exists>ys. is_path (i # ys) \\<and> length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  as = i # as'\n  cs = cs' @ [t]\n  xs = as' @ a # bs @ a # cs'\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       local.is_path (i # ys) \\<and>\n       length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}", "using \\<open>set (i # xs @ [t]) \\<subseteq> {0..n}\\<close> \\<open>is_path (i # xs)\\<close> is_path_remove_cycle[of \"i # as'\"]"], ["proof (prove)\nusing this:\n  as = i # as'\n  cs = cs' @ [t]\n  xs = as' @ a # bs @ a # cs'\n  set (i # xs @ [t]) \\<subseteq> {0..n}\n  local.is_path (i # xs)\n  local.is_path ((i # as') @ ?a # ?bs @ ?a # ?cs) \\<Longrightarrow>\n  local.is_path ((i # as') @ ?a # ?cs)\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       local.is_path (i # ys) \\<and>\n       length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}", "by - (rule exI[where x = \"as' @ a # cs'\"], auto)"], ["proof (state)\nthis:\n  \\<exists>ys.\n     local.is_path (i # ys) \\<and>\n     length ys < length xs \\<and> set (i # ys) \\<subseteq> {0..n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.is_path (i # ys)\n  length ys < length xs\n  set (i # ys) \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs; local.is_path (i # xsa);\n                    set xsa \\<subseteq> {0..n}; n \\<le> length xsa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        local.is_path (i # xs); set xs \\<subseteq> {0..n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  local.is_path (i # ys)\n  length ys < length xs\n  set (i # ys) \\<subseteq> {0..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  local.is_path (i # ys)\n  length ys < length xs\n  set (i # ys) \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. thesis", "by (cases \"n \\<le> length ys\") (auto intro: that less)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reaches_non_inf_path:\n  assumes \"reaches i\" \"i \\<le> n\" \"t \\<le> n\"\n  shows \"OPT n i < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT n i < \\<infinity>", "proof (cases \"t = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = i \\<Longrightarrow> local.OPT n i < \\<infinity>\n 2. t \\<noteq> i \\<Longrightarrow> local.OPT n i < \\<infinity>", "case True"], ["proof (state)\nthis:\n  t = i\n\ngoal (2 subgoals):\n 1. t = i \\<Longrightarrow> local.OPT n i < \\<infinity>\n 2. t \\<noteq> i \\<Longrightarrow> local.OPT n i < \\<infinity>", "with \\<open>i \\<le> n\\<close> \\<open>t \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  i \\<le> n\n  t \\<le> n\n  t = i", "have \"OPT n i \\<le> 0\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  t \\<le> n\n  t = i\n\ngoal (1 subgoal):\n 1. local.OPT n i \\<le> 0", "unfolding OPT_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  t \\<le> n\n  t = i\n\ngoal (1 subgoal):\n 1. Min ({local.weight (i # xs @ [t]) |xs.\n          length xs + 1 \\<le> n \\<and> set xs \\<subseteq> {0..n}} \\<union>\n         {if t = i then 0 else \\<infinity>})\n    \\<le> 0", "by (auto intro: Min_le simp: finite_lists_length_le2[simplified])"], ["proof (state)\nthis:\n  local.OPT n i \\<le> 0\n\ngoal (2 subgoals):\n 1. t = i \\<Longrightarrow> local.OPT n i < \\<infinity>\n 2. t \\<noteq> i \\<Longrightarrow> local.OPT n i < \\<infinity>", "then"], ["proof (chain)\npicking this:\n  local.OPT n i \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  local.OPT n i \\<le> 0\n\ngoal (1 subgoal):\n 1. local.OPT n i < \\<infinity>", "using less_linear"], ["proof (prove)\nusing this:\n  local.OPT n i \\<le> 0\n  ?x < ?y \\<or> ?x = ?y \\<or> ?y < ?x\n\ngoal (1 subgoal):\n 1. local.OPT n i < \\<infinity>", "by (fastforce simp: zero_extended_def)"], ["proof (state)\nthis:\n  local.OPT n i < \\<infinity>\n\ngoal (1 subgoal):\n 1. t \\<noteq> i \\<Longrightarrow> local.OPT n i < \\<infinity>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> i \\<Longrightarrow> local.OPT n i < \\<infinity>", "case False"], ["proof (state)\nthis:\n  t \\<noteq> i\n\ngoal (1 subgoal):\n 1. t \\<noteq> i \\<Longrightarrow> local.OPT n i < \\<infinity>", "from assms(1)"], ["proof (chain)\npicking this:\n  local.reaches i", "obtain xs where \"is_path (i # xs)\" \"i \\<le> n\" \"set xs \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  local.reaches i\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n         set xs \\<subseteq> {0..n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reaches_def"], ["proof (prove)\nusing this:\n  \\<exists>xs.\n     local.is_path (i # xs) \\<and>\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n         set xs \\<subseteq> {0..n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by safe"], ["proof (state)\nthis:\n  local.is_path (i # xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. t \\<noteq> i \\<Longrightarrow> local.OPT n i < \\<infinity>", "then"], ["proof (chain)\npicking this:\n  local.is_path (i # xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}", "obtain xs where xs: \"is_path (i # xs)\" \"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"length xs < n\""], ["proof (prove)\nusing this:\n  local.is_path (i # xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n         set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>t \\<noteq> i\\<close> \\<open>t \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  local.is_path (i # xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  t \\<noteq> i\n  t \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>local.is_path (i # xs); i \\<le> n;\n         set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: is_path_shorten)"], ["proof (state)\nthis:\n  local.is_path (i # xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  length xs < n\n\ngoal (1 subgoal):\n 1. t \\<noteq> i \\<Longrightarrow> local.OPT n i < \\<infinity>", "then"], ["proof (chain)\npicking this:\n  local.is_path (i # xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  length xs < n", "have \"weight (i # xs @ [t]) < \\<infinity>\""], ["proof (prove)\nusing this:\n  local.is_path (i # xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  length xs < n\n\ngoal (1 subgoal):\n 1. local.weight (i # xs @ [t]) < \\<infinity>", "unfolding is_path_def"], ["proof (prove)\nusing this:\n  local.weight ((i # xs) @ [t]) < \\<infinity>\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  length xs < n\n\ngoal (1 subgoal):\n 1. local.weight (i # xs @ [t]) < \\<infinity>", "by auto"], ["proof (state)\nthis:\n  local.weight (i # xs @ [t]) < \\<infinity>\n\ngoal (1 subgoal):\n 1. t \\<noteq> i \\<Longrightarrow> local.OPT n i < \\<infinity>", "with xs(2-)"], ["proof (chain)\npicking this:\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  length xs < n\n  local.weight (i # xs @ [t]) < \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  length xs < n\n  local.weight (i # xs @ [t]) < \\<infinity>\n\ngoal (1 subgoal):\n 1. local.OPT n i < \\<infinity>", "unfolding OPT_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  length xs < n\n  local.weight (i # xs @ [t]) < \\<infinity>\n\ngoal (1 subgoal):\n 1. Min ({local.weight (i # xs @ [t]) |xs.\n          length xs + 1 \\<le> n \\<and> set xs \\<subseteq> {0..n}} \\<union>\n         {if t = i then 0 else \\<infinity>})\n    < \\<infinity>", "by (elim order.strict_trans1[rotated])\n       (auto simp: setcompr_eq_image finite_lists_length_le2[simplified])"], ["proof (state)\nthis:\n  local.OPT n i < \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT_sink_le_0:\n  \"OPT i t \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT i t \\<le> 0", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min ({local.weight (t # xs @ [t]) |xs.\n          length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n         {if t = t then 0 else \\<infinity>})\n    \\<le> 0", "by (auto simp: finite_lists_length_le2[simplified])"], ["", "lemma is_path_appendD:\n  assumes \"is_path (as @ a # bs)\"\n  shows \"is_path (a # bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.is_path (a # bs)", "using assms weight_append[of as a \"bs @ [t]\"]"], ["proof (prove)\nusing this:\n  local.is_path (as @ a # bs)\n  local.weight (as @ a # bs @ [t]) =\n  local.weight (as @ [a]) + local.weight (a # bs @ [t])\n\ngoal (1 subgoal):\n 1. local.is_path (a # bs)", "unfolding is_path_def"], ["proof (prove)\nusing this:\n  local.weight ((as @ a # bs) @ [t]) < \\<infinity>\n  local.weight (as @ a # bs @ [t]) =\n  local.weight (as @ [a]) + local.weight (a # bs @ [t])\n\ngoal (1 subgoal):\n 1. local.weight ((a # bs) @ [t]) < \\<infinity>", "by simp (metis Pinf_add_right add.commute less_extended_simps(4) not_less_iff_gr_or_eq)"], ["", "lemma has_negative_cycleI:\n  assumes \"set (a # xs @ ys) \\<subseteq> {0..n}\" \"weight (a # xs @ [a]) < 0\" \"is_path (a # ys)\"\n  shows has_negative_cycle"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.has_negative_cycle", "using assms"], ["proof (prove)\nusing this:\n  set (a # xs @ ys) \\<subseteq> {0..n}\n  local.weight (a # xs @ [a]) < 0\n  local.is_path (a # ys)\n\ngoal (1 subgoal):\n 1. local.has_negative_cycle", "unfolding has_negative_cycle_def"], ["proof (prove)\nusing this:\n  set (a # xs @ ys) \\<subseteq> {0..n}\n  local.weight (a # xs @ [a]) < 0\n  local.is_path (a # ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs a ys.\n       set (a # xs @ ys) \\<subseteq> {0..n} \\<and>\n       local.weight (a # xs @ [a]) < 0 \\<and> local.is_path (a # ys)", "by auto"], ["", "lemma OPT_cases2:\n  obtains (path) xs where\n    \"v \\<noteq> t\" \"OPT i v \\<noteq> \\<infinity>\" \"OPT i v = weight (v # xs @ [t])\" \"length xs + 1 \\<le> i\" \"set xs \\<subseteq> {0..n}\"\n  | (unreachable) \"v \\<noteq> t\" \"OPT i v = \\<infinity>\"\n  | (sink) \"v = t\" \"OPT i v \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>v \\<noteq> t; local.OPT i v \\<noteq> \\<infinity>;\n                 local.OPT i v = local.weight (v # xs @ [t]);\n                 length xs + 1 \\<le> i; set xs \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> t; local.OPT i v = \\<infinity>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>v = t; local.OPT i v \\<le> 0\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>v \\<noteq> t;\n                 Min ({local.weight (v # xs @ [t]) |xs.\n                       length xs + 1 \\<le> i \\<and>\n                       set xs \\<subseteq> {0..n}} \\<union>\n                      {if t = v then 0 else \\<infinity>}) \\<noteq>\n                 \\<infinity>;\n                 Min ({local.weight (v # xs @ [t]) |xs.\n                       length xs + 1 \\<le> i \\<and>\n                       set xs \\<subseteq> {0..n}} \\<union>\n                      {if t = v then 0 else \\<infinity>}) =\n                 local.weight (v # xs @ [t]);\n                 length xs + 1 \\<le> i; set xs \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> t;\n      Min ({local.weight (v # xs @ [t]) |xs.\n            length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>}) =\n      \\<infinity>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>v = t;\n      Min ({local.weight (v # xs @ [t]) |xs.\n            length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>})\n      \\<le> 0\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using Min_in[of \"{weight (v # xs @ [t]) |xs. length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}}\n    \\<union> {if t = v then 0 else \\<infinity>}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite\n            ({local.weight (v # xs @ [t]) |xs.\n              length xs + 1 \\<le> i \\<and>\n              set xs \\<subseteq> {0..n}} \\<union>\n             {if t = v then 0 else \\<infinity>});\n   {local.weight (v # xs @ [t]) |xs.\n    length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n   {if t = v then 0 else \\<infinity>} \\<noteq>\n   {}\\<rbrakk>\n  \\<Longrightarrow> Min ({local.weight (v # xs @ [t]) |xs.\n                          length xs + 1 \\<le> i \\<and>\n                          set xs \\<subseteq> {0..n}} \\<union>\n                         {if t = v then 0 else \\<infinity>})\n                    \\<in> {local.weight (v # xs @ [t]) |xs.\n                           length xs + 1 \\<le> i \\<and>\n                           set xs \\<subseteq> {0..n}} \\<union>\n                          {if t = v then 0 else \\<infinity>}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>v \\<noteq> t;\n                 Min ({local.weight (v # xs @ [t]) |xs.\n                       length xs + 1 \\<le> i \\<and>\n                       set xs \\<subseteq> {0..n}} \\<union>\n                      {if t = v then 0 else \\<infinity>}) \\<noteq>\n                 \\<infinity>;\n                 Min ({local.weight (v # xs @ [t]) |xs.\n                       length xs + 1 \\<le> i \\<and>\n                       set xs \\<subseteq> {0..n}} \\<union>\n                      {if t = v then 0 else \\<infinity>}) =\n                 local.weight (v # xs @ [t]);\n                 length xs + 1 \\<le> i; set xs \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> t;\n      Min ({local.weight (v # xs @ [t]) |xs.\n            length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>}) =\n      \\<infinity>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>v = t;\n      Min ({local.weight (v # xs @ [t]) |xs.\n            length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>})\n      \\<le> 0\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases \"v = t\"; force simp: finite_lists_length_le2[simplified] split: if_split_asm)"], ["", "lemma shortest_le_OPT:\n  assumes \"v \\<le> n\"\n  shows \"shortest v \\<le> OPT i v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.shortest v \\<le> local.OPT i v", "unfolding OPT_def shortest_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf ({local.weight (v # xs @ [t]) |xs.\n          set xs \\<subseteq> {0..n}} \\<union>\n         {if t = v then 0 else \\<infinity>})\n    \\<le> Min ({local.weight (v # xs @ [t]) |xs.\n                length xs + 1 \\<le> i \\<and>\n                set xs \\<subseteq> {0..n}} \\<union>\n               {if t = v then 0 else \\<infinity>})", "apply (subst Min_Inf)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     ({local.weight (v # xs @ [t]) |xs.\n       length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n      {if t = v then 0 else \\<infinity>})\n 2. {local.weight (v # xs @ [t]) |xs.\n     length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n    {if t = v then 0 else \\<infinity>} \\<noteq>\n    {}\n 3. Inf ({local.weight (v # xs @ [t]) |xs.\n          set xs \\<subseteq> {0..n}} \\<union>\n         {if t = v then 0 else \\<infinity>})\n    \\<le> Inf ({local.weight (v # xs @ [t]) |xs.\n                length xs + 1 \\<le> i \\<and>\n                set xs \\<subseteq> {0..n}} \\<union>\n               {if t = v then 0 else \\<infinity>})", "apply (simp add: setcompr_eq_image finite_lists_length_le2[simplified]; fail)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf ({local.weight (v # xs @ [t]) |xs.\n          set xs \\<subseteq> {0..n}} \\<union>\n         {if t = v then 0 else \\<infinity>})\n    \\<le> Inf ({local.weight (v # xs @ [t]) |xs.\n                length xs + 1 \\<le> i \\<and>\n                set xs \\<subseteq> {0..n}} \\<union>\n               {if t = v then 0 else \\<infinity>})", "apply (rule Inf_superset_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {local.weight (v # xs @ [t]) |xs.\n     length xs + 1 \\<le> i \\<and> set xs \\<subseteq> {0..n}} \\<union>\n    {if t = v then 0 else \\<infinity>}\n    \\<subseteq> {local.weight (v # xs @ [t]) |xs.\n                 set xs \\<subseteq> {0..n}} \\<union>\n                {if t = v then 0 else \\<infinity>}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context\n  assumes W_wellformed: \"\\<forall>i \\<le> n. \\<forall>j \\<le> n. W i j > -\\<infinity>\"\n  assumes \"t \\<le> n\"\nbegin"], ["", "lemma weight_not_minfI:\n  \"-\\<infinity> < weight xs\" if \"set xs \\<subseteq> {0..n}\" \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. -\\<infinity> < local.weight xs", "using that"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> {0..n}\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. -\\<infinity> < local.weight xs", "using W_wellformed \\<open>t \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> {0..n}\n  xs \\<noteq> []\n  \\<forall>i\\<le>n. \\<forall>j\\<le>n. -\\<infinity> < W i j\n  t \\<le> n\n\ngoal (1 subgoal):\n 1. -\\<infinity> < local.weight xs", "by (induction xs rule: induct_list012) (auto intro: add_gt_minfI simp: zero_extended_def)"], ["", "lemma OPT_not_minfI:\n  \"OPT n i > -\\<infinity>\" if \"i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. -\\<infinity> < local.OPT n i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. -\\<infinity> < local.OPT n i", "have \"OPT n i \\<in>\n    {weight (i # xs @ [t]) |xs. length xs + 1 \\<le> n \\<and> set xs \\<subseteq> {0..n}} \\<union> {if t = i then 0 else \\<infinity>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT n i\n    \\<in> {local.weight (i # xs @ [t]) |xs.\n           length xs + 1 \\<le> n \\<and> set xs \\<subseteq> {0..n}} \\<union>\n          {if t = i then 0 else \\<infinity>}", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min ({local.weight (i # xs @ [t]) |xs.\n          length xs + 1 \\<le> n \\<and> set xs \\<subseteq> {0..n}} \\<union>\n         {if t = i then 0 else \\<infinity>})\n    \\<in> {local.weight (i # xs @ [t]) |xs.\n           length xs + 1 \\<le> n \\<and> set xs \\<subseteq> {0..n}} \\<union>\n          {if t = i then 0 else \\<infinity>}", "by (rule Min_in) (auto simp: setcompr_eq_image finite_lists_length_le2[simplified])"], ["proof (state)\nthis:\n  local.OPT n i\n  \\<in> {local.weight (i # xs @ [t]) |xs.\n         length xs + 1 \\<le> n \\<and> set xs \\<subseteq> {0..n}} \\<union>\n        {if t = i then 0 else \\<infinity>}\n\ngoal (1 subgoal):\n 1. -\\<infinity> < local.OPT n i", "with that \\<open>t \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  i \\<le> n\n  t \\<le> n\n  local.OPT n i\n  \\<in> {local.weight (i # xs @ [t]) |xs.\n         length xs + 1 \\<le> n \\<and> set xs \\<subseteq> {0..n}} \\<union>\n        {if t = i then 0 else \\<infinity>}", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  t \\<le> n\n  local.OPT n i\n  \\<in> {local.weight (i # xs @ [t]) |xs.\n         length xs + 1 \\<le> n \\<and> set xs \\<subseteq> {0..n}} \\<union>\n        {if t = i then 0 else \\<infinity>}\n\ngoal (1 subgoal):\n 1. -\\<infinity> < local.OPT n i", "by (auto 4 3 intro!: weight_not_minfI simp: zero_extended_def)"], ["proof (state)\nthis:\n  -\\<infinity> < local.OPT n i\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem detects_cycle:\n  assumes has_negative_cycle\n  shows \"\\<exists>i \\<le> n. OPT (n + 1) i < OPT n i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. local.OPT (n + 1) i < local.OPT n i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. local.OPT (n + 1) i < local.OPT n i", "from assms \\<open>t \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  local.has_negative_cycle\n  t \\<le> n", "obtain xs a ys where cycle:\n    \"a \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"set ys \\<subseteq> {0..n}\"\n    \"weight (a # xs @ [a]) < 0\" \"is_path (a # ys)\""], ["proof (prove)\nusing this:\n  local.has_negative_cycle\n  t \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>a xs ys.\n        \\<lbrakk>a \\<le> n; set xs \\<subseteq> {0..n};\n         set ys \\<subseteq> {0..n}; local.weight (a # xs @ [a]) < 0;\n         local.is_path (a # ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_negative_cycle_def"], ["proof (prove)\nusing this:\n  \\<exists>xs a ys.\n     set (a # xs @ ys) \\<subseteq> {0..n} \\<and>\n     local.weight (a # xs @ [a]) < 0 \\<and> local.is_path (a # ys)\n  t \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>a xs ys.\n        \\<lbrakk>a \\<le> n; set xs \\<subseteq> {0..n};\n         set ys \\<subseteq> {0..n}; local.weight (a # xs @ [a]) < 0;\n         local.is_path (a # ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  set ys \\<subseteq> {0..n}\n  local.weight (a # xs @ [a]) < 0\n  local.is_path (a # ys)\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. local.OPT (n + 1) i < local.OPT n i", "then"], ["proof (chain)\npicking this:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  set ys \\<subseteq> {0..n}\n  local.weight (a # xs @ [a]) < 0\n  local.is_path (a # ys)", "have \"reaches a\""], ["proof (prove)\nusing this:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  set ys \\<subseteq> {0..n}\n  local.weight (a # xs @ [a]) < 0\n  local.is_path (a # ys)\n\ngoal (1 subgoal):\n 1. local.reaches a", "unfolding reaches_def"], ["proof (prove)\nusing this:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  set ys \\<subseteq> {0..n}\n  local.weight (a # xs @ [a]) < 0\n  local.is_path (a # ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       local.is_path (a # xs) \\<and>\n       a \\<le> n \\<and> set xs \\<subseteq> {0..n}", "by auto"], ["proof (state)\nthis:\n  local.reaches a\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. local.OPT (n + 1) i < local.OPT n i", "have reaches: \"reaches x\" if \"x \\<in> set xs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.reaches x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.reaches x", "from that"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "obtain as bs where \"xs = as @ x # bs\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        xs = as @ x # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule split_list)"], ["proof (state)\nthis:\n  xs = as @ x # bs\n\ngoal (1 subgoal):\n 1. local.reaches x", "with cycle"], ["proof (chain)\npicking this:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  set ys \\<subseteq> {0..n}\n  local.weight (a # xs @ [a]) < 0\n  local.is_path (a # ys)\n  xs = as @ x # bs", "have \"weight (x # bs @ [a]) < \\<infinity>\""], ["proof (prove)\nusing this:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  set ys \\<subseteq> {0..n}\n  local.weight (a # xs @ [a]) < 0\n  local.is_path (a # ys)\n  xs = as @ x # bs\n\ngoal (1 subgoal):\n 1. local.weight (x # bs @ [a]) < \\<infinity>", "using weight_append[of \"a # as\" x \"bs @ [a]\"]"], ["proof (prove)\nusing this:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  set ys \\<subseteq> {0..n}\n  local.weight (a # xs @ [a]) < 0\n  local.is_path (a # ys)\n  xs = as @ x # bs\n  local.weight ((a # as) @ x # bs @ [a]) =\n  local.weight ((a # as) @ [x]) + local.weight (x # bs @ [a])\n\ngoal (1 subgoal):\n 1. local.weight (x # bs @ [a]) < \\<infinity>", "by simp (metis Pinf_add_right Pinf_le add.commute less_eq_extended.simps(2) not_less)"], ["proof (state)\nthis:\n  local.weight (x # bs @ [a]) < \\<infinity>\n\ngoal (1 subgoal):\n 1. local.reaches x", "moreover"], ["proof (state)\nthis:\n  local.weight (x # bs @ [a]) < \\<infinity>\n\ngoal (1 subgoal):\n 1. local.reaches x", "from \\<open>reaches a\\<close>"], ["proof (chain)\npicking this:\n  local.reaches a", "obtain cs where \"local.weight (a # cs @ [t]) < \\<infinity>\" \"set cs \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  local.reaches a\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>local.weight (a # cs @ [t]) < \\<infinity>;\n         set cs \\<subseteq> {0..n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reaches_def is_path_def"], ["proof (prove)\nusing this:\n  \\<exists>xs.\n     local.weight ((a # xs) @ [t]) < \\<infinity> \\<and>\n     a \\<le> n \\<and> set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>local.weight (a # cs @ [t]) < \\<infinity>;\n         set cs \\<subseteq> {0..n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  local.weight (a # cs @ [t]) < \\<infinity>\n  set cs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. local.reaches x", "ultimately"], ["proof (chain)\npicking this:\n  local.weight (x # bs @ [a]) < \\<infinity>\n  local.weight (a # cs @ [t]) < \\<infinity>\n  set cs \\<subseteq> {0..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  local.weight (x # bs @ [a]) < \\<infinity>\n  local.weight (a # cs @ [t]) < \\<infinity>\n  set cs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. local.reaches x", "unfolding reaches_def is_path_def"], ["proof (prove)\nusing this:\n  local.weight (x # bs @ [a]) < \\<infinity>\n  local.weight (a # cs @ [t]) < \\<infinity>\n  set cs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       local.weight ((x # xs) @ [t]) < \\<infinity> \\<and>\n       x \\<le> n \\<and> set xs \\<subseteq> {0..n}", "using \\<open>a \\<le> n\\<close> weight_append[of \"x # bs\" a \"cs @ [t]\"] cycle(2) \\<open>xs = _\\<close>"], ["proof (prove)\nusing this:\n  local.weight (x # bs @ [a]) < \\<infinity>\n  local.weight (a # cs @ [t]) < \\<infinity>\n  set cs \\<subseteq> {0..n}\n  a \\<le> n\n  local.weight ((x # bs) @ a # cs @ [t]) =\n  local.weight ((x # bs) @ [a]) + local.weight (a # cs @ [t])\n  set xs \\<subseteq> {0..n}\n  xs = as @ x # bs\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       local.weight ((x # xs) @ [t]) < \\<infinity> \\<and>\n       x \\<le> n \\<and> set xs \\<subseteq> {0..n}", "by - (rule exI[where x = \"bs @ [a] @ cs\"], auto intro: add_lt_infI)"], ["proof (state)\nthis:\n  local.reaches x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x2 \\<in> set xs \\<Longrightarrow> local.reaches ?x2\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. local.OPT (n + 1) i < local.OPT n i", "let ?S = \"sum_list (map (OPT n) (a # xs @ [a]))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. local.OPT (n + 1) i < local.OPT n i", "obtain u v where \"u \\<le> n\" \"v \\<le> n\" \"OPT n v + W u v < OPT n u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<le> n; v \\<le> n;\n         local.OPT n v + W u v < local.OPT n u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (atomize_elim, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>u v.\n       u \\<le> n \\<and>\n       v \\<le> n \\<and>\n       local.OPT n v + W u v < local.OPT n u \\<Longrightarrow>\n    False", "assume \"\\<nexists>u v. u \\<le> n \\<and> v \\<le> n \\<and> OPT n v + W u v < OPT n u\""], ["proof (state)\nthis:\n  \\<nexists>u v.\n     u \\<le> n \\<and> v \\<le> n \\<and> local.OPT n v + W u v < local.OPT n u\n\ngoal (1 subgoal):\n 1. \\<nexists>u v.\n       u \\<le> n \\<and>\n       v \\<le> n \\<and>\n       local.OPT n v + W u v < local.OPT n u \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>u v.\n     u \\<le> n \\<and> v \\<le> n \\<and> local.OPT n v + W u v < local.OPT n u", "have \"?S \\<le> ?S + weight (a # xs @ [a])\""], ["proof (prove)\nusing this:\n  \\<nexists>u v.\n     u \\<le> n \\<and> v \\<le> n \\<and> local.OPT n v + W u v < local.OPT n u\n\ngoal (1 subgoal):\n 1. sum_list (map (local.OPT n) (a # xs @ [a]))\n    \\<le> sum_list (map (local.OPT n) (a # xs @ [a])) +\n          local.weight (a # xs @ [a])", "using cycle(1-3)"], ["proof (prove)\nusing this:\n  \\<nexists>u v.\n     u \\<le> n \\<and> v \\<le> n \\<and> local.OPT n v + W u v < local.OPT n u\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  set ys \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. sum_list (map (local.OPT n) (a # xs @ [a]))\n    \\<le> sum_list (map (local.OPT n) (a # xs @ [a])) +\n          local.weight (a # xs @ [a])", "by (subst fold_sum_aux; fastforce simp: subset_eq)"], ["proof (state)\nthis:\n  sum_list (map (local.OPT n) (a # xs @ [a]))\n  \\<le> sum_list (map (local.OPT n) (a # xs @ [a])) +\n        local.weight (a # xs @ [a])\n\ngoal (1 subgoal):\n 1. \\<nexists>u v.\n       u \\<le> n \\<and>\n       v \\<le> n \\<and>\n       local.OPT n v + W u v < local.OPT n u \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  sum_list (map (local.OPT n) (a # xs @ [a]))\n  \\<le> sum_list (map (local.OPT n) (a # xs @ [a])) +\n        local.weight (a # xs @ [a])\n\ngoal (1 subgoal):\n 1. \\<nexists>u v.\n       u \\<le> n \\<and>\n       v \\<le> n \\<and>\n       local.OPT n v + W u v < local.OPT n u \\<Longrightarrow>\n    False", "have \"?S > -\\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. -\\<infinity> < sum_list (map (local.OPT n) (a # xs @ [a]))", "using cycle(1-4)"], ["proof (prove)\nusing this:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  set ys \\<subseteq> {0..n}\n  local.weight (a # xs @ [a]) < 0\n\ngoal (1 subgoal):\n 1. -\\<infinity> < sum_list (map (local.OPT n) (a # xs @ [a]))", "by (intro sum_list_not_minfI, auto intro!: OPT_not_minfI)"], ["proof (state)\nthis:\n  -\\<infinity> < sum_list (map (local.OPT n) (a # xs @ [a]))\n\ngoal (1 subgoal):\n 1. \\<nexists>u v.\n       u \\<le> n \\<and>\n       v \\<le> n \\<and>\n       local.OPT n v + W u v < local.OPT n u \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  -\\<infinity> < sum_list (map (local.OPT n) (a # xs @ [a]))\n\ngoal (1 subgoal):\n 1. \\<nexists>u v.\n       u \\<le> n \\<and>\n       v \\<le> n \\<and>\n       local.OPT n v + W u v < local.OPT n u \\<Longrightarrow>\n    False", "have \"?S < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map (local.OPT n) (a # xs @ [a])) < \\<infinity>", "using reaches \\<open>t \\<le> n\\<close> cycle(1,2)"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set xs \\<Longrightarrow> local.reaches ?x2\n  t \\<le> n\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. sum_list (map (local.OPT n) (a # xs @ [a])) < \\<infinity>", "by (intro sum_list_not_infI) (auto intro: reaches_non_inf_path \\<open>reaches a\\<close> simp: subset_eq)"], ["proof (state)\nthis:\n  sum_list (map (local.OPT n) (a # xs @ [a])) < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<nexists>u v.\n       u \\<le> n \\<and>\n       v \\<le> n \\<and>\n       local.OPT n v + W u v < local.OPT n u \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  sum_list (map (local.OPT n) (a # xs @ [a]))\n  \\<le> sum_list (map (local.OPT n) (a # xs @ [a])) +\n        local.weight (a # xs @ [a])\n  -\\<infinity> < sum_list (map (local.OPT n) (a # xs @ [a]))\n  sum_list (map (local.OPT n) (a # xs @ [a])) < \\<infinity>", "have \"weight (a # xs @ [a]) \\<ge> 0\""], ["proof (prove)\nusing this:\n  sum_list (map (local.OPT n) (a # xs @ [a]))\n  \\<le> sum_list (map (local.OPT n) (a # xs @ [a])) +\n        local.weight (a # xs @ [a])\n  -\\<infinity> < sum_list (map (local.OPT n) (a # xs @ [a]))\n  sum_list (map (local.OPT n) (a # xs @ [a])) < \\<infinity>\n\ngoal (1 subgoal):\n 1. 0 \\<le> local.weight (a # xs @ [a])", "by (simp add: le_add_same_cancel1)"], ["proof (state)\nthis:\n  0 \\<le> local.weight (a # xs @ [a])\n\ngoal (1 subgoal):\n 1. \\<nexists>u v.\n       u \\<le> n \\<and>\n       v \\<le> n \\<and>\n       local.OPT n v + W u v < local.OPT n u \\<Longrightarrow>\n    False", "with \\<open>weight _ < 0\\<close>"], ["proof (chain)\npicking this:\n  local.weight (a # xs @ [a]) < 0\n  0 \\<le> local.weight (a # xs @ [a])", "show False"], ["proof (prove)\nusing this:\n  local.weight (a # xs @ [a]) < 0\n  0 \\<le> local.weight (a # xs @ [a])\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<le> n\n  v \\<le> n\n  local.OPT n v + W u v < local.OPT n u\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. local.OPT (n + 1) i < local.OPT n i", "then"], ["proof (chain)\npicking this:\n  u \\<le> n\n  v \\<le> n\n  local.OPT n v + W u v < local.OPT n u", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<le> n\n  v \\<le> n\n  local.OPT n v + W u v < local.OPT n u\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. local.OPT (n + 1) i < local.OPT n i", "by -\n       (rule exI[where x = u],\n        auto 4 4 intro: Min.coboundedI min.strict_coboundedI2 elim: order.strict_trans1[rotated]\n          simp: OPT_Suc[OF \\<open>t \\<le> n\\<close>])"], ["proof (state)\nthis:\n  \\<exists>i\\<le>n. local.OPT (n + 1) i < local.OPT n i\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary bf_detects_cycle:\n  assumes has_negative_cycle\n  shows \"\\<exists>i \\<le> n. bf (n + 1) i < bf n i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. local.bf (n + 1) i < local.bf n i", "using detects_cycle[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>i\\<le>n. local.OPT (n + 1) i < local.OPT n i\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. local.bf (n + 1) i < local.bf n i", "unfolding bf_correct[OF \\<open>t \\<le> n\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>i\\<le>n. local.bf (n + 1) i < local.bf n i\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. local.bf (n + 1) i < local.bf n i", "."], ["", "lemma shortest_cases:\n  assumes \"v \\<le> n\"\n  obtains (path) xs where \"shortest v = weight (v # xs @ [t])\" \"set xs \\<subseteq> {0..n}\"\n  | (sink) \"v = t\" \"shortest v = 0\"\n  | (unreachable) \"v \\<noteq> t\" \"shortest v = \\<infinity>\"\n  | (negative_cycle) \"shortest v = -\\<infinity>\" \"\\<forall>x. \\<exists>xs. set xs \\<subseteq> {0..n} \\<and> weight (v # xs @ [t]) < Fin x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.shortest v = local.weight (v # xs @ [t]);\n                 set xs \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>v = t; local.shortest v = 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> t; local.shortest v = \\<infinity>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>local.shortest v = -\\<infinity>;\n      \\<forall>x.\n         \\<exists>xs.\n            set xs \\<subseteq> {0..n} \\<and>\n            local.weight (v # xs @ [t]) < Fin x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.shortest v = local.weight (v # xs @ [t]);\n                 set xs \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>v = t; local.shortest v = 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> t; local.shortest v = \\<infinity>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>local.shortest v = -\\<infinity>;\n      \\<forall>x.\n         \\<exists>xs.\n            set xs \\<subseteq> {0..n} \\<and>\n            local.weight (v # xs @ [t]) < Fin x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "let ?S = \"{weight (v # xs @ [t]) | xs. set xs \\<subseteq> {0..n}} \\<union> {if t = v then 0 else \\<infinity>}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.shortest v = local.weight (v # xs @ [t]);\n                 set xs \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>v = t; local.shortest v = 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> t; local.shortest v = \\<infinity>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>local.shortest v = -\\<infinity>;\n      \\<forall>x.\n         \\<exists>xs.\n            set xs \\<subseteq> {0..n} \\<and>\n            local.weight (v # xs @ [t]) < Fin x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"?S \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n    {if t = v then 0 else \\<infinity>} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n  {if t = v then 0 else \\<infinity>} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.shortest v = local.weight (v # xs @ [t]);\n                 set xs \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>v = t; local.shortest v = 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> t; local.shortest v = \\<infinity>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>local.shortest v = -\\<infinity>;\n      \\<forall>x.\n         \\<exists>xs.\n            set xs \\<subseteq> {0..n} \\<and>\n            local.weight (v # xs @ [t]) < Fin x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have Minf_lowest: False if  \"-\\<infinity> < a\" \"-\\<infinity> = a\" for a :: \"int extended\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  -\\<infinity> < a\n  -\\<infinity> = a\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>-\\<infinity> < ?a2; -\\<infinity> = ?a2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>local.shortest v = local.weight (v # xs @ [t]);\n                 set xs \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>v = t; local.shortest v = 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> t; local.shortest v = \\<infinity>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>local.shortest v = -\\<infinity>;\n      \\<forall>x.\n         \\<exists>xs.\n            set xs \\<subseteq> {0..n} \\<and>\n            local.weight (v # xs @ [t]) < Fin x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"shortest v\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1. local.shortest v = Fin x1 \\<Longrightarrow> thesis\n 2. local.shortest v = \\<infinity> \\<Longrightarrow> thesis\n 3. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "case (Fin x)"], ["proof (state)\nthis:\n  local.shortest v = Fin x\n\ngoal (3 subgoals):\n 1. \\<And>x1. local.shortest v = Fin x1 \\<Longrightarrow> thesis\n 2. local.shortest v = \\<infinity> \\<Longrightarrow> thesis\n 3. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  local.shortest v = Fin x", "have \"-\\<infinity> \\<notin> ?S\" \"bdd_below (Fin -` ?S)\" \"?S \\<noteq> {\\<infinity>}\" \"x = Inf (Fin -` ?S)\""], ["proof (prove)\nusing this:\n  local.shortest v = Fin x\n\ngoal (1 subgoal):\n 1. (-\\<infinity>\n     \\<notin> {local.weight (v # xs @ [t]) |xs.\n               set xs \\<subseteq> {0..n}} \\<union>\n              {if t = v then 0 else \\<infinity>} &&&\n     bdd_below\n      (Fin -`\n       ({local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}))) &&&\n    {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n    {if t = v then 0 else \\<infinity>} \\<noteq>\n    {\\<infinity>} &&&\n    x =\n    Inf (Fin -`\n         ({local.weight (v # xs @ [t]) |xs.\n           set xs \\<subseteq> {0..n}} \\<union>\n          {if t = v then 0 else \\<infinity>}))", "unfolding shortest_def Inf_extended_def"], ["proof (prove)\nusing this:\n  (if {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n      {if t = v then 0 else \\<infinity>} =\n      {} \\<or>\n      {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n      {if t = v then 0 else \\<infinity>} =\n      {\\<infinity>}\n   then \\<infinity>\n   else if -\\<infinity>\n           \\<in> {local.weight (v # xs @ [t]) |xs.\n                  set xs \\<subseteq> {0..n}} \\<union>\n                 {if t = v then 0 else \\<infinity>} \\<or>\n           \\<not> bdd_below\n                   (Fin -`\n                    ({local.weight (v # xs @ [t]) |xs.\n                      set xs \\<subseteq> {0..n}} \\<union>\n                     {if t = v then 0 else \\<infinity>}))\n        then -\\<infinity>\n        else Fin (Inf (Fin -`\n                       ({local.weight (v # xs @ [t]) |xs.\n                         set xs \\<subseteq> {0..n}} \\<union>\n                        {if t = v then 0 else \\<infinity>})))) =\n  Fin x\n\ngoal (1 subgoal):\n 1. (-\\<infinity>\n     \\<notin> {local.weight (v # xs @ [t]) |xs.\n               set xs \\<subseteq> {0..n}} \\<union>\n              {if t = v then 0 else \\<infinity>} &&&\n     bdd_below\n      (Fin -`\n       ({local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}))) &&&\n    {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n    {if t = v then 0 else \\<infinity>} \\<noteq>\n    {\\<infinity>} &&&\n    x =\n    Inf (Fin -`\n         ({local.weight (v # xs @ [t]) |xs.\n           set xs \\<subseteq> {0..n}} \\<union>\n          {if t = v then 0 else \\<infinity>}))", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  -\\<infinity>\n  \\<notin> {local.weight (v # xs @ [t]) |xs.\n            set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>}\n  bdd_below\n   (Fin -`\n    ({local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n     {if t = v then 0 else \\<infinity>}))\n  {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n  {if t = v then 0 else \\<infinity>} \\<noteq>\n  {\\<infinity>}\n  x =\n  Inf (Fin -`\n       ({local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}))\n\ngoal (3 subgoals):\n 1. \\<And>x1. local.shortest v = Fin x1 \\<Longrightarrow> thesis\n 2. local.shortest v = \\<infinity> \\<Longrightarrow> thesis\n 3. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "from this(1-3)"], ["proof (chain)\npicking this:\n  -\\<infinity>\n  \\<notin> {local.weight (v # xs @ [t]) |xs.\n            set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>}\n  bdd_below\n   (Fin -`\n    ({local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n     {if t = v then 0 else \\<infinity>}))\n  {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n  {if t = v then 0 else \\<infinity>} \\<noteq>\n  {\\<infinity>}", "have \"x \\<in> Fin -` ?S\""], ["proof (prove)\nusing this:\n  -\\<infinity>\n  \\<notin> {local.weight (v # xs @ [t]) |xs.\n            set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>}\n  bdd_below\n   (Fin -`\n    ({local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n     {if t = v then 0 else \\<infinity>}))\n  {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n  {if t = v then 0 else \\<infinity>} \\<noteq>\n  {\\<infinity>}\n\ngoal (1 subgoal):\n 1. x \\<in> Fin -`\n            ({local.weight (v # xs @ [t]) |xs.\n              set xs \\<subseteq> {0..n}} \\<union>\n             {if t = v then 0 else \\<infinity>})", "unfolding \\<open>x = _\\<close>"], ["proof (prove)\nusing this:\n  -\\<infinity>\n  \\<notin> {local.weight (v # xs @ [t]) |xs.\n            set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>}\n  bdd_below\n   (Fin -`\n    ({local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n     {if t = v then 0 else \\<infinity>}))\n  {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n  {if t = v then 0 else \\<infinity>} \\<noteq>\n  {\\<infinity>}\n\ngoal (1 subgoal):\n 1. Inf (Fin -`\n         ({local.weight (v # xs @ [t]) |xs.\n           set xs \\<subseteq> {0..n}} \\<union>\n          {if t = v then 0 else \\<infinity>}))\n    \\<in> Fin -`\n          ({local.weight (v # xs @ [t]) |xs.\n            set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>})", "by (intro Inf_int_in, auto simp: zero_extended_def)\n        (smt empty_iff extended.exhaust insertI2 mem_Collect_eq vimage_eq)"], ["proof (state)\nthis:\n  x \\<in> Fin -`\n          ({local.weight (v # xs @ [t]) |xs.\n            set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>})\n\ngoal (3 subgoals):\n 1. \\<And>x1. local.shortest v = Fin x1 \\<Longrightarrow> thesis\n 2. local.shortest v = \\<infinity> \\<Longrightarrow> thesis\n 3. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "with \\<open>shortest v = _\\<close>"], ["proof (chain)\npicking this:\n  local.shortest v = Fin x\n  x \\<in> Fin -`\n          ({local.weight (v # xs @ [t]) |xs.\n            set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>})", "show ?thesis"], ["proof (prove)\nusing this:\n  local.shortest v = Fin x\n  x \\<in> Fin -`\n          ({local.weight (v # xs @ [t]) |xs.\n            set xs \\<subseteq> {0..n}} \\<union>\n           {if t = v then 0 else \\<infinity>})\n\ngoal (1 subgoal):\n 1. thesis", "unfolding vimage_eq"], ["proof (prove)\nusing this:\n  local.shortest v = Fin x\n  Fin x\n  \\<in> {local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}\n\ngoal (1 subgoal):\n 1. thesis", "by (auto split: if_split_asm intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. local.shortest v = \\<infinity> \\<Longrightarrow> thesis\n 2. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. local.shortest v = \\<infinity> \\<Longrightarrow> thesis\n 2. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "case Pinf"], ["proof (state)\nthis:\n  local.shortest v = \\<infinity>\n\ngoal (2 subgoals):\n 1. local.shortest v = \\<infinity> \\<Longrightarrow> thesis\n 2. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "with \\<open>?S \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n  {if t = v then 0 else \\<infinity>} \\<noteq>\n  {}\n  local.shortest v = \\<infinity>", "have \"t \\<noteq> v\""], ["proof (prove)\nusing this:\n  {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n  {if t = v then 0 else \\<infinity>} \\<noteq>\n  {}\n  local.shortest v = \\<infinity>\n\ngoal (1 subgoal):\n 1. t \\<noteq> v", "unfolding shortest_def Inf_extended_def"], ["proof (prove)\nusing this:\n  {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n  {if t = v then 0 else \\<infinity>} \\<noteq>\n  {}\n  (if {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n      {if t = v then 0 else \\<infinity>} =\n      {} \\<or>\n      {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n      {if t = v then 0 else \\<infinity>} =\n      {\\<infinity>}\n   then \\<infinity>\n   else if -\\<infinity>\n           \\<in> {local.weight (v # xs @ [t]) |xs.\n                  set xs \\<subseteq> {0..n}} \\<union>\n                 {if t = v then 0 else \\<infinity>} \\<or>\n           \\<not> bdd_below\n                   (Fin -`\n                    ({local.weight (v # xs @ [t]) |xs.\n                      set xs \\<subseteq> {0..n}} \\<union>\n                     {if t = v then 0 else \\<infinity>}))\n        then -\\<infinity>\n        else Fin (Inf (Fin -`\n                       ({local.weight (v # xs @ [t]) |xs.\n                         set xs \\<subseteq> {0..n}} \\<union>\n                        {if t = v then 0 else \\<infinity>})))) =\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. t \\<noteq> v", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  t \\<noteq> v\n\ngoal (2 subgoals):\n 1. local.shortest v = \\<infinity> \\<Longrightarrow> thesis\n 2. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "with \\<open>_ = \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  local.shortest v = \\<infinity>\n  t \\<noteq> v", "show ?thesis"], ["proof (prove)\nusing this:\n  local.shortest v = \\<infinity>\n  t \\<noteq> v\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "case Minf"], ["proof (state)\nthis:\n  local.shortest v = -\\<infinity>\n\ngoal (1 subgoal):\n 1. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  local.shortest v = -\\<infinity>", "have \"?S \\<noteq> {}\" \"?S \\<noteq> {\\<infinity>}\" \"-\\<infinity> \\<in> ?S \\<or> \\<not> bdd_below (Fin -` ?S)\""], ["proof (prove)\nusing this:\n  local.shortest v = -\\<infinity>\n\ngoal (1 subgoal):\n 1. {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n    {if t = v then 0 else \\<infinity>} \\<noteq>\n    {} &&&\n    {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n    {if t = v then 0 else \\<infinity>} \\<noteq>\n    {\\<infinity>} &&&\n    -\\<infinity>\n    \\<in> {local.weight (v # xs @ [t]) |xs.\n           set xs \\<subseteq> {0..n}} \\<union>\n          {if t = v then 0 else \\<infinity>} \\<or>\n    \\<not> bdd_below\n            (Fin -`\n             ({local.weight (v # xs @ [t]) |xs.\n               set xs \\<subseteq> {0..n}} \\<union>\n              {if t = v then 0 else \\<infinity>}))", "unfolding shortest_def Inf_extended_def"], ["proof (prove)\nusing this:\n  (if {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n      {if t = v then 0 else \\<infinity>} =\n      {} \\<or>\n      {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n      {if t = v then 0 else \\<infinity>} =\n      {\\<infinity>}\n   then \\<infinity>\n   else if -\\<infinity>\n           \\<in> {local.weight (v # xs @ [t]) |xs.\n                  set xs \\<subseteq> {0..n}} \\<union>\n                 {if t = v then 0 else \\<infinity>} \\<or>\n           \\<not> bdd_below\n                   (Fin -`\n                    ({local.weight (v # xs @ [t]) |xs.\n                      set xs \\<subseteq> {0..n}} \\<union>\n                     {if t = v then 0 else \\<infinity>}))\n        then -\\<infinity>\n        else Fin (Inf (Fin -`\n                       ({local.weight (v # xs @ [t]) |xs.\n                         set xs \\<subseteq> {0..n}} \\<union>\n                        {if t = v then 0 else \\<infinity>})))) =\n  -\\<infinity>\n\ngoal (1 subgoal):\n 1. {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n    {if t = v then 0 else \\<infinity>} \\<noteq>\n    {} &&&\n    {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n    {if t = v then 0 else \\<infinity>} \\<noteq>\n    {\\<infinity>} &&&\n    -\\<infinity>\n    \\<in> {local.weight (v # xs @ [t]) |xs.\n           set xs \\<subseteq> {0..n}} \\<union>\n          {if t = v then 0 else \\<infinity>} \\<or>\n    \\<not> bdd_below\n            (Fin -`\n             ({local.weight (v # xs @ [t]) |xs.\n               set xs \\<subseteq> {0..n}} \\<union>\n              {if t = v then 0 else \\<infinity>}))", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n  {if t = v then 0 else \\<infinity>} \\<noteq>\n  {}\n  {local.weight (v # xs @ [t]) |xs. set xs \\<subseteq> {0..n}} \\<union>\n  {if t = v then 0 else \\<infinity>} \\<noteq>\n  {\\<infinity>}\n  -\\<infinity>\n  \\<in> {local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>} \\<or>\n  \\<not> bdd_below\n          (Fin -`\n           ({local.weight (v # xs @ [t]) |xs.\n             set xs \\<subseteq> {0..n}} \\<union>\n            {if t = v then 0 else \\<infinity>}))\n\ngoal (1 subgoal):\n 1. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "from this(3)"], ["proof (chain)\npicking this:\n  -\\<infinity>\n  \\<in> {local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>} \\<or>\n  \\<not> bdd_below\n          (Fin -`\n           ({local.weight (v # xs @ [t]) |xs.\n             set xs \\<subseteq> {0..n}} \\<union>\n            {if t = v then 0 else \\<infinity>}))", "have \"\\<forall>x. \\<exists>xs. set xs \\<subseteq> {0..n} \\<and> weight (v # xs @ [t]) < Fin x\""], ["proof (prove)\nusing this:\n  -\\<infinity>\n  \\<in> {local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>} \\<or>\n  \\<not> bdd_below\n          (Fin -`\n           ({local.weight (v # xs @ [t]) |xs.\n             set xs \\<subseteq> {0..n}} \\<union>\n            {if t = v then 0 else \\<infinity>}))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. -\\<infinity>\n    \\<in> {local.weight (v # xs @ [t]) |xs.\n           set xs \\<subseteq> {0..n}} \\<union>\n          {if t = v then 0 else \\<infinity>} \\<Longrightarrow>\n    \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x\n 2. \\<not> bdd_below\n            (Fin -`\n             ({local.weight (v # xs @ [t]) |xs.\n               set xs \\<subseteq> {0..n}} \\<union>\n              {if t = v then 0 else \\<infinity>})) \\<Longrightarrow>\n    \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "assume \"-\\<infinity> \\<in> ?S\""], ["proof (state)\nthis:\n  -\\<infinity>\n  \\<in> {local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}\n\ngoal (2 subgoals):\n 1. -\\<infinity>\n    \\<in> {local.weight (v # xs @ [t]) |xs.\n           set xs \\<subseteq> {0..n}} \\<union>\n          {if t = v then 0 else \\<infinity>} \\<Longrightarrow>\n    \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x\n 2. \\<not> bdd_below\n            (Fin -`\n             ({local.weight (v # xs @ [t]) |xs.\n               set xs \\<subseteq> {0..n}} \\<union>\n              {if t = v then 0 else \\<infinity>})) \\<Longrightarrow>\n    \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "with weight_not_minfI"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ?xs \\<subseteq> {0..n}; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> -\\<infinity> < local.weight ?xs\n  -\\<infinity>\n  \\<in> {local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}", "have False"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?xs \\<subseteq> {0..n}; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> -\\<infinity> < local.weight ?xs\n  -\\<infinity>\n  \\<in> {local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}\n\ngoal (1 subgoal):\n 1. False", "using \\<open>v \\<le> n\\<close> \\<open>t \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?xs \\<subseteq> {0..n}; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> -\\<infinity> < local.weight ?xs\n  -\\<infinity>\n  \\<in> {local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}\n  v \\<le> n\n  t \\<le> n\n\ngoal (1 subgoal):\n 1. False", "by (auto split: if_split_asm elim: Minf_lowest[rotated])"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. -\\<infinity>\n    \\<in> {local.weight (v # xs @ [t]) |xs.\n           set xs \\<subseteq> {0..n}} \\<union>\n          {if t = v then 0 else \\<infinity>} \\<Longrightarrow>\n    \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x\n 2. \\<not> bdd_below\n            (Fin -`\n             ({local.weight (v # xs @ [t]) |xs.\n               set xs \\<subseteq> {0..n}} \\<union>\n              {if t = v then 0 else \\<infinity>})) \\<Longrightarrow>\n    \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", ".."], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<exists>xs.\n        set xs \\<subseteq> {0..n} \\<and> local.weight (v # xs @ [t]) < Fin x\n\ngoal (1 subgoal):\n 1. \\<not> bdd_below\n            (Fin -`\n             ({local.weight (v # xs @ [t]) |xs.\n               set xs \\<subseteq> {0..n}} \\<union>\n              {if t = v then 0 else \\<infinity>})) \\<Longrightarrow>\n    \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> bdd_below\n            (Fin -`\n             ({local.weight (v # xs @ [t]) |xs.\n               set xs \\<subseteq> {0..n}} \\<union>\n              {if t = v then 0 else \\<infinity>})) \\<Longrightarrow>\n    \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "assume \"\\<not> bdd_below (Fin -` ?S)\""], ["proof (state)\nthis:\n  \\<not> bdd_below\n          (Fin -`\n           ({local.weight (v # xs @ [t]) |xs.\n             set xs \\<subseteq> {0..n}} \\<union>\n            {if t = v then 0 else \\<infinity>}))\n\ngoal (1 subgoal):\n 1. \\<not> bdd_below\n            (Fin -`\n             ({local.weight (v # xs @ [t]) |xs.\n               set xs \\<subseteq> {0..n}} \\<union>\n              {if t = v then 0 else \\<infinity>})) \\<Longrightarrow>\n    \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "fix x :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "let ?m = \"min x (-1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "from \\<open>\\<not> bdd_below _\\<close>"], ["proof (chain)\npicking this:\n  \\<not> bdd_below\n          (Fin -`\n           ({local.weight (v # xs @ [t]) |xs.\n             set xs \\<subseteq> {0..n}} \\<union>\n            {if t = v then 0 else \\<infinity>}))", "obtain m where \"Fin m \\<in> ?S\" \"m < ?m\""], ["proof (prove)\nusing this:\n  \\<not> bdd_below\n          (Fin -`\n           ({local.weight (v # xs @ [t]) |xs.\n             set xs \\<subseteq> {0..n}} \\<union>\n            {if t = v then 0 else \\<infinity>}))\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>Fin m\n                 \\<in> {local.weight (v # xs @ [t]) |xs.\n                        set xs \\<subseteq> {0..n}} \\<union>\n                       {if t = v then 0 else \\<infinity>};\n         m < min x (- 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding bdd_below_def"], ["proof (prove)\nusing this:\n  \\<nexists>m.\n     Ball\n      (Fin -`\n       ({local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}))\n      ((\\<le>) m)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>Fin m\n                 \\<in> {local.weight (v # xs @ [t]) |xs.\n                        set xs \\<subseteq> {0..n}} \\<union>\n                       {if t = v then 0 else \\<infinity>};\n         m < min x (- 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (simp, drule spec[of _ \"?m\"], force)"], ["proof (state)\nthis:\n  Fin m\n  \\<in> {local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}\n  m < min x (- 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xs.\n          set xs \\<subseteq> {0..n} \\<and>\n          local.weight (v # xs @ [t]) < Fin x", "then"], ["proof (chain)\npicking this:\n  Fin m\n  \\<in> {local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}\n  m < min x (- 1)", "show \"\\<exists>xs. set xs \\<subseteq> {0..n} \\<and> weight (v # xs @ [t]) < Fin x\""], ["proof (prove)\nusing this:\n  Fin m\n  \\<in> {local.weight (v # xs @ [t]) |xs.\n         set xs \\<subseteq> {0..n}} \\<union>\n        {if t = v then 0 else \\<infinity>}\n  m < min x (- 1)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and> local.weight (v # xs @ [t]) < Fin x", "by (auto split: if_split_asm simp: zero_extended_def) (metis less_extended_simps(1))+"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and> local.weight (v # xs @ [t]) < Fin x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<exists>xs.\n        set xs \\<subseteq> {0..n} \\<and> local.weight (v # xs @ [t]) < Fin x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<exists>xs.\n        set xs \\<subseteq> {0..n} \\<and> local.weight (v # xs @ [t]) < Fin x\n\ngoal (1 subgoal):\n 1. local.shortest v = -\\<infinity> \\<Longrightarrow> thesis", "with \\<open>shortest v = _\\<close>"], ["proof (chain)\npicking this:\n  local.shortest v = -\\<infinity>\n  \\<forall>x.\n     \\<exists>xs.\n        set xs \\<subseteq> {0..n} \\<and> local.weight (v # xs @ [t]) < Fin x", "show ?thesis"], ["proof (prove)\nusing this:\n  local.shortest v = -\\<infinity>\n  \\<forall>x.\n     \\<exists>xs.\n        set xs \\<subseteq> {0..n} \\<and> local.weight (v # xs @ [t]) < Fin x\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simple_paths:\n  assumes \"\\<not> has_negative_cycle\" \"weight (v # xs @ [t]) < \\<infinity>\" \"set xs \\<subseteq> {0..n}\" \"v \\<le> n\"\n  obtains ys where\n    \"weight (v # ys @ [t]) \\<le> weight (v # xs @ [t])\" \"set ys \\<subseteq> {0..n}\" \"length ys < n\" | \"v = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>local.weight (v # ys @ [t])\n                         \\<le> local.weight (v # xs @ [t]);\n                 set ys \\<subseteq> {0..n}; length ys < n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v = t \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(2-)"], ["proof (prove)\nusing this:\n  local.weight (v # xs @ [t]) < \\<infinity>\n  set xs \\<subseteq> {0..n}\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>local.weight (v # ys @ [t])\n                         \\<le> local.weight (v # xs @ [t]);\n                 set ys \\<subseteq> {0..n}; length ys < n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v = t \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (atomize_elim, induction \"length xs\" arbitrary: xs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs;\n                    local.weight (v # xsa @ [t]) < \\<infinity>;\n                    set xsa \\<subseteq> {0..n}; v \\<le> n;\n                    local.weight (v # xsa @ [t]) < \\<infinity>;\n                    set xsa \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>ys.\n   local.weight (v # ys @ [t]) \\<le> local.weight (v # xsa @ [t]) \\<and>\n   set ys \\<subseteq> {0..n} \\<and> length ys < n) \\<or>\n                                     v = t;\n        local.weight (v # xs @ [t]) < \\<infinity>;\n        set xs \\<subseteq> {0..n}; v \\<le> n;\n        local.weight (v # xs @ [t]) < \\<infinity>;\n        set xs \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ys.\n                             local.weight (v # ys @ [t])\n                             \\<le> local.weight (v # xs @ [t]) \\<and>\n                             set ys \\<subseteq> {0..n} \\<and>\n                             length ys < n) \\<or>\n                         v = t", "case (less ys)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?xs2 < length ys;\n   local.weight (v # ?xs2 @ [t]) < \\<infinity>; set ?xs2 \\<subseteq> {0..n};\n   v \\<le> n; local.weight (v # ?xs2 @ [t]) < \\<infinity>;\n   set ?xs2 \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>ys.\n                        local.weight (v # ys @ [t])\n                        \\<le> local.weight (v # ?xs2 @ [t]) \\<and>\n                        set ys \\<subseteq> {0..n} \\<and>\n                        length ys < n) \\<or>\n                    v = t\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  v \\<le> n\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs;\n                    local.weight (v # xsa @ [t]) < \\<infinity>;\n                    set xsa \\<subseteq> {0..n}; v \\<le> n;\n                    local.weight (v # xsa @ [t]) < \\<infinity>;\n                    set xsa \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>ys.\n   local.weight (v # ys @ [t]) \\<le> local.weight (v # xsa @ [t]) \\<and>\n   set ys \\<subseteq> {0..n} \\<and> length ys < n) \\<or>\n                                     v = t;\n        local.weight (v # xs @ [t]) < \\<infinity>;\n        set xs \\<subseteq> {0..n}; v \\<le> n;\n        local.weight (v # xs @ [t]) < \\<infinity>;\n        set xs \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ys.\n                             local.weight (v # ys @ [t])\n                             \\<le> local.weight (v # xs @ [t]) \\<and>\n                             set ys \\<subseteq> {0..n} \\<and>\n                             length ys < n) \\<or>\n                         v = t", "note ys = less.prems(1,2)"], ["proof (state)\nthis:\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs;\n                    local.weight (v # xsa @ [t]) < \\<infinity>;\n                    set xsa \\<subseteq> {0..n}; v \\<le> n;\n                    local.weight (v # xsa @ [t]) < \\<infinity>;\n                    set xsa \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>ys.\n   local.weight (v # ys @ [t]) \\<le> local.weight (v # xsa @ [t]) \\<and>\n   set ys \\<subseteq> {0..n} \\<and> length ys < n) \\<or>\n                                     v = t;\n        local.weight (v # xs @ [t]) < \\<infinity>;\n        set xs \\<subseteq> {0..n}; v \\<le> n;\n        local.weight (v # xs @ [t]) < \\<infinity>;\n        set xs \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ys.\n                             local.weight (v # ys @ [t])\n                             \\<le> local.weight (v # xs @ [t]) \\<and>\n                             set ys \\<subseteq> {0..n} \\<and>\n                             length ys < n) \\<or>\n                         v = t", "note IH = less.hyps"], ["proof (state)\nthis:\n  \\<lbrakk>length ?xs2 < length ys;\n   local.weight (v # ?xs2 @ [t]) < \\<infinity>; set ?xs2 \\<subseteq> {0..n};\n   v \\<le> n; local.weight (v # ?xs2 @ [t]) < \\<infinity>;\n   set ?xs2 \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>ys.\n                        local.weight (v # ys @ [t])\n                        \\<le> local.weight (v # ?xs2 @ [t]) \\<and>\n                        set ys \\<subseteq> {0..n} \\<and>\n                        length ys < n) \\<or>\n                    v = t\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs;\n                    local.weight (v # xsa @ [t]) < \\<infinity>;\n                    set xsa \\<subseteq> {0..n}; v \\<le> n;\n                    local.weight (v # xsa @ [t]) < \\<infinity>;\n                    set xsa \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>ys.\n   local.weight (v # ys @ [t]) \\<le> local.weight (v # xsa @ [t]) \\<and>\n   set ys \\<subseteq> {0..n} \\<and> length ys < n) \\<or>\n                                     v = t;\n        local.weight (v # xs @ [t]) < \\<infinity>;\n        set xs \\<subseteq> {0..n}; v \\<le> n;\n        local.weight (v # xs @ [t]) < \\<infinity>;\n        set xs \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ys.\n                             local.weight (v # ys @ [t])\n                             \\<le> local.weight (v # xs @ [t]) \\<and>\n                             set ys \\<subseteq> {0..n} \\<and>\n                             length ys < n) \\<or>\n                         v = t", "have path: \"is_path (v # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.is_path (v # ys)", "using is_path_def not_less_iff_gr_or_eq ys(1)"], ["proof (prove)\nusing this:\n  local.is_path ?xs \\<equiv> local.weight (?xs @ [t]) < \\<infinity>\n  (\\<not> ?x < ?y) = (?y < ?x \\<or> ?x = ?y)\n  local.weight (v # ys @ [t]) < \\<infinity>\n\ngoal (1 subgoal):\n 1. local.is_path (v # ys)", "by fastforce"], ["proof (state)\nthis:\n  local.is_path (v # ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs;\n                    local.weight (v # xsa @ [t]) < \\<infinity>;\n                    set xsa \\<subseteq> {0..n}; v \\<le> n;\n                    local.weight (v # xsa @ [t]) < \\<infinity>;\n                    set xsa \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>ys.\n   local.weight (v # ys @ [t]) \\<le> local.weight (v # xsa @ [t]) \\<and>\n   set ys \\<subseteq> {0..n} \\<and> length ys < n) \\<or>\n                                     v = t;\n        local.weight (v # xs @ [t]) < \\<infinity>;\n        set xs \\<subseteq> {0..n}; v \\<le> n;\n        local.weight (v # xs @ [t]) < \\<infinity>;\n        set xs \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ys.\n                             local.weight (v # ys @ [t])\n                             \\<le> local.weight (v # xs @ [t]) \\<and>\n                             set ys \\<subseteq> {0..n} \\<and>\n                             length ys < n) \\<or>\n                         v = t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "proof (cases \"length ys \\<ge> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> length ys \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t\n 2. \\<not> n \\<le> length ys \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "case True"], ["proof (state)\nthis:\n  n \\<le> length ys\n\ngoal (2 subgoals):\n 1. n \\<le> length ys \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t\n 2. \\<not> n \\<le> length ys \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "with ys \\<open>v \\<le> n\\<close> \\<open>t \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  v \\<le> n\n  t \\<le> n\n  n \\<le> length ys", "obtain a as bs cs where \"v # ys @ [t] = as @ a # bs @ a # cs\""], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  v \\<le> n\n  t \\<le> n\n  n \\<le> length ys\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs cs.\n        v # ys @ [t] = as @ a # bs @ a # cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by - (rule list_pidgeonhole[of \"v # ys @ [t]\" \"{0..n}\"], auto)"], ["proof (state)\nthis:\n  v # ys @ [t] = as @ a # bs @ a # cs\n\ngoal (2 subgoals):\n 1. n \\<le> length ys \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t\n 2. \\<not> n \\<le> length ys \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "then"], ["proof (chain)\npicking this:\n  v # ys @ [t] = as @ a # bs @ a # cs", "show ?thesis"], ["proof (prove)\nusing this:\n  v # ys @ [t] = as @ a # bs @ a # cs\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "proof (cases rule: path_eq_cycleE)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>as = []; cs = []; v = a; a = t; ys = bs\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ysa.\n                          local.weight (v # ysa @ [t])\n                          \\<le> local.weight (v # ys @ [t]) \\<and>\n                          set ysa \\<subseteq> {0..n} \\<and>\n                          length ysa < n) \\<or>\n                      v = t\n 2. \\<And>cs'.\n       \\<lbrakk>as = []; v = a; ys = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 3. \\<And>as'.\n       \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 4. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "case Nil_Nil"], ["proof (state)\nthis:\n  as = []\n  cs = []\n  v = a\n  a = t\n  ys = bs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>as = []; cs = []; v = a; a = t; ys = bs\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ysa.\n                          local.weight (v # ysa @ [t])\n                          \\<le> local.weight (v # ys @ [t]) \\<and>\n                          set ysa \\<subseteq> {0..n} \\<and>\n                          length ysa < n) \\<or>\n                      v = t\n 2. \\<And>cs'.\n       \\<lbrakk>as = []; v = a; ys = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 3. \\<And>as'.\n       \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 4. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "then"], ["proof (chain)\npicking this:\n  as = []\n  cs = []\n  v = a\n  a = t\n  ys = bs", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n  cs = []\n  v = a\n  a = t\n  ys = bs\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "by simp"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal (3 subgoals):\n 1. \\<And>cs'.\n       \\<lbrakk>as = []; v = a; ys = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 2. \\<And>as'.\n       \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 3. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs'.\n       \\<lbrakk>as = []; v = a; ys = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 2. \\<And>as'.\n       \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 3. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "case (Nil_Cons cs')"], ["proof (state)\nthis:\n  as = []\n  v = a\n  ys = bs @ a # cs'\n  cs = cs' @ [t]\n\ngoal (3 subgoals):\n 1. \\<And>cs'.\n       \\<lbrakk>as = []; v = a; ys = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 2. \\<And>as'.\n       \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 3. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "then"], ["proof (chain)\npicking this:\n  as = []\n  v = a\n  ys = bs @ a # cs'\n  cs = cs' @ [t]", "have *: \"weight (v # ys @ [t]) = weight (a # bs @ [a]) + weight (a # cs' @ [t])\""], ["proof (prove)\nusing this:\n  as = []\n  v = a\n  ys = bs @ a # cs'\n  cs = cs' @ [t]\n\ngoal (1 subgoal):\n 1. local.weight (v # ys @ [t]) =\n    local.weight (a # bs @ [a]) + local.weight (a # cs' @ [t])", "by (simp add: weight_append[of \"a # bs\" a \"cs' @ [t]\", simplified])"], ["proof (state)\nthis:\n  local.weight (v # ys @ [t]) =\n  local.weight (a # bs @ [a]) + local.weight (a # cs' @ [t])\n\ngoal (3 subgoals):\n 1. \\<And>cs'.\n       \\<lbrakk>as = []; v = a; ys = bs @ a # cs'; cs = cs' @ [t]\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 2. \\<And>as'.\n       \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 3. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "proof (cases \"weight (a # bs @ [a]) < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t\n 2. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "case True"], ["proof (state)\nthis:\n  local.weight (a # bs @ [a]) < 0\n\ngoal (2 subgoals):\n 1. local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t\n 2. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "with Nil_Cons \\<open>set ys \\<subseteq> _\\<close> path"], ["proof (chain)\npicking this:\n  as = []\n  v = a\n  ys = bs @ a # cs'\n  cs = cs' @ [t]\n  set ys \\<subseteq> {0..n}\n  local.is_path (v # ys)\n  local.weight (a # bs @ [a]) < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n  v = a\n  ys = bs @ a # cs'\n  cs = cs' @ [t]\n  set ys \\<subseteq> {0..n}\n  local.is_path (v # ys)\n  local.weight (a # bs @ [a]) < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "using assms(1)"], ["proof (prove)\nusing this:\n  as = []\n  v = a\n  ys = bs @ a # cs'\n  cs = cs' @ [t]\n  set ys \\<subseteq> {0..n}\n  local.is_path (v # ys)\n  local.weight (a # bs @ [a]) < 0\n  \\<not> local.has_negative_cycle\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "by (force intro: has_negative_cycleI[of a bs ys])"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "case False"], ["proof (state)\nthis:\n  \\<not> local.weight (a # bs @ [a]) < 0\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "then"], ["proof (chain)\npicking this:\n  \\<not> local.weight (a # bs @ [a]) < 0", "have \"weight (a # bs @ [a]) \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> local.weight (a # bs @ [a]) < 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> local.weight (a # bs @ [a])", "by auto"], ["proof (state)\nthis:\n  0 \\<le> local.weight (a # bs @ [a])\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "with * ys"], ["proof (chain)\npicking this:\n  local.weight (v # ys @ [t]) =\n  local.weight (a # bs @ [a]) + local.weight (a # cs' @ [t])\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  0 \\<le> local.weight (a # bs @ [a])", "have \"weight (a # cs' @ [t]) \\<le> weight (v # ys @ [t])\""], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) =\n  local.weight (a # bs @ [a]) + local.weight (a # cs' @ [t])\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  0 \\<le> local.weight (a # bs @ [a])\n\ngoal (1 subgoal):\n 1. local.weight (a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])", "using add_mono not_le"], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) =\n  local.weight (a # bs @ [a]) + local.weight (a # cs' @ [t])\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  0 \\<le> local.weight (a # bs @ [a])\n  \\<lbrakk>?a \\<le> ?b; ?c \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a + ?c \\<le> ?b + ?d\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. local.weight (a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])", "by fastforce"], ["proof (state)\nthis:\n  local.weight (a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "with Nil_Cons \\<open>length ys \\<ge> n\\<close> ys"], ["proof (chain)\npicking this:\n  as = []\n  v = a\n  ys = bs @ a # cs'\n  cs = cs' @ [t]\n  n \\<le> length ys\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  local.weight (a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n  v = a\n  ys = bs @ a # cs'\n  cs = cs' @ [t]\n  n \\<le> length ys\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  local.weight (a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "using IH[of cs']"], ["proof (prove)\nusing this:\n  as = []\n  v = a\n  ys = bs @ a # cs'\n  cs = cs' @ [t]\n  n \\<le> length ys\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  local.weight (a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])\n  \\<lbrakk>length cs' < length ys;\n   local.weight (v # cs' @ [t]) < \\<infinity>; set cs' \\<subseteq> {0..n};\n   v \\<le> n; local.weight (v # cs' @ [t]) < \\<infinity>;\n   set cs' \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>ys.\n                        local.weight (v # ys @ [t])\n                        \\<le> local.weight (v # cs' @ [t]) \\<and>\n                        set ys \\<subseteq> {0..n} \\<and>\n                        length ys < n) \\<or>\n                    v = t\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "by simp (meson le_less_trans order_trans)"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal (2 subgoals):\n 1. \\<And>as'.\n       \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 2. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as'.\n       \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 2. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "case (Cons_Nil as')"], ["proof (state)\nthis:\n  as = v # as'\n  cs = []\n  a = t\n  ys = as' @ a # bs\n\ngoal (2 subgoals):\n 1. \\<And>as'.\n       \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 2. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "with ys"], ["proof (chain)\npicking this:\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  as = v # as'\n  cs = []\n  a = t\n  ys = as' @ a # bs", "have *: \"weight (v # ys @ [t]) = weight (v # as' @ [t]) + weight (a # bs @ [a])\""], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  as = v # as'\n  cs = []\n  a = t\n  ys = as' @ a # bs\n\ngoal (1 subgoal):\n 1. local.weight (v # ys @ [t]) =\n    local.weight (v # as' @ [t]) + local.weight (a # bs @ [a])", "using weight_append[of \"v # as'\" t \"bs @ [t]\"]"], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  as = v # as'\n  cs = []\n  a = t\n  ys = as' @ a # bs\n  local.weight ((v # as') @ t # bs @ [t]) =\n  local.weight ((v # as') @ [t]) + local.weight (t # bs @ [t])\n\ngoal (1 subgoal):\n 1. local.weight (v # ys @ [t]) =\n    local.weight (v # as' @ [t]) + local.weight (a # bs @ [a])", "by simp"], ["proof (state)\nthis:\n  local.weight (v # ys @ [t]) =\n  local.weight (v # as' @ [t]) + local.weight (a # bs @ [a])\n\ngoal (2 subgoals):\n 1. \\<And>as'.\n       \\<lbrakk>as = v # as'; cs = []; a = t; ys = as' @ a # bs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t\n 2. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "proof (cases \"weight (a # bs @ [a]) < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t\n 2. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "case True"], ["proof (state)\nthis:\n  local.weight (a # bs @ [a]) < 0\n\ngoal (2 subgoals):\n 1. local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t\n 2. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "with Cons_Nil \\<open>set ys \\<subseteq> _\\<close> path assms(1)"], ["proof (chain)\npicking this:\n  as = v # as'\n  cs = []\n  a = t\n  ys = as' @ a # bs\n  set ys \\<subseteq> {0..n}\n  local.is_path (v # ys)\n  \\<not> local.has_negative_cycle\n  local.weight (a # bs @ [a]) < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  as = v # as'\n  cs = []\n  a = t\n  ys = as' @ a # bs\n  set ys \\<subseteq> {0..n}\n  local.is_path (v # ys)\n  \\<not> local.has_negative_cycle\n  local.weight (a # bs @ [a]) < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "using is_path_appendD[of \"v # as'\"]"], ["proof (prove)\nusing this:\n  as = v # as'\n  cs = []\n  a = t\n  ys = as' @ a # bs\n  set ys \\<subseteq> {0..n}\n  local.is_path (v # ys)\n  \\<not> local.has_negative_cycle\n  local.weight (a # bs @ [a]) < 0\n  local.is_path ((v # as') @ ?a # ?bs) \\<Longrightarrow>\n  local.is_path (?a # ?bs)\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "by (force intro: has_negative_cycleI[of a bs bs])"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "case False"], ["proof (state)\nthis:\n  \\<not> local.weight (a # bs @ [a]) < 0\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "then"], ["proof (chain)\npicking this:\n  \\<not> local.weight (a # bs @ [a]) < 0", "have \"weight (a # bs @ [a]) \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> local.weight (a # bs @ [a]) < 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> local.weight (a # bs @ [a])", "by auto"], ["proof (state)\nthis:\n  0 \\<le> local.weight (a # bs @ [a])\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "with * ys(1)"], ["proof (chain)\npicking this:\n  local.weight (v # ys @ [t]) =\n  local.weight (v # as' @ [t]) + local.weight (a # bs @ [a])\n  local.weight (v # ys @ [t]) < \\<infinity>\n  0 \\<le> local.weight (a # bs @ [a])", "have \"weight (v # as' @ [t]) \\<le> weight (v # ys @ [t])\""], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) =\n  local.weight (v # as' @ [t]) + local.weight (a # bs @ [a])\n  local.weight (v # ys @ [t]) < \\<infinity>\n  0 \\<le> local.weight (a # bs @ [a])\n\ngoal (1 subgoal):\n 1. local.weight (v # as' @ [t]) \\<le> local.weight (v # ys @ [t])", "using add_left_mono"], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) =\n  local.weight (v # as' @ [t]) + local.weight (a # bs @ [a])\n  local.weight (v # ys @ [t]) < \\<infinity>\n  0 \\<le> local.weight (a # bs @ [a])\n  ?a \\<le> ?b \\<Longrightarrow> ?c + ?a \\<le> ?c + ?b\n\ngoal (1 subgoal):\n 1. local.weight (v # as' @ [t]) \\<le> local.weight (v # ys @ [t])", "by fastforce"], ["proof (state)\nthis:\n  local.weight (v # as' @ [t]) \\<le> local.weight (v # ys @ [t])\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "with Cons_Nil \\<open>length ys \\<ge> n\\<close> \\<open>v \\<le> n\\<close> ys"], ["proof (chain)\npicking this:\n  as = v # as'\n  cs = []\n  a = t\n  ys = as' @ a # bs\n  n \\<le> length ys\n  v \\<le> n\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  local.weight (v # as' @ [t]) \\<le> local.weight (v # ys @ [t])", "show ?thesis"], ["proof (prove)\nusing this:\n  as = v # as'\n  cs = []\n  a = t\n  ys = as' @ a # bs\n  n \\<le> length ys\n  v \\<le> n\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  local.weight (v # as' @ [t]) \\<le> local.weight (v # ys @ [t])\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "using IH[of as']"], ["proof (prove)\nusing this:\n  as = v # as'\n  cs = []\n  a = t\n  ys = as' @ a # bs\n  n \\<le> length ys\n  v \\<le> n\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  local.weight (v # as' @ [t]) \\<le> local.weight (v # ys @ [t])\n  \\<lbrakk>length as' < length ys;\n   local.weight (v # as' @ [t]) < \\<infinity>; set as' \\<subseteq> {0..n};\n   v \\<le> n; local.weight (v # as' @ [t]) < \\<infinity>;\n   set as' \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>ys.\n                        local.weight (v # ys @ [t])\n                        \\<le> local.weight (v # as' @ [t]) \\<and>\n                        set ys \\<subseteq> {0..n} \\<and>\n                        length ys < n) \\<or>\n                    v = t\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "by simp (meson le_less_trans order_trans)"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal (1 subgoal):\n 1. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "case (Cons_Cons as' cs')"], ["proof (state)\nthis:\n  as = v # as'\n  cs = cs' @ [t]\n  ys = as' @ a # bs @ a # cs'\n\ngoal (1 subgoal):\n 1. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "with ys"], ["proof (chain)\npicking this:\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  as = v # as'\n  cs = cs' @ [t]\n  ys = as' @ a # bs @ a # cs'", "have *:\n        \"weight (v # ys @ [t]) = weight (v # as' @ a # cs' @ [t]) + weight (a # bs @ [a])\""], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  as = v # as'\n  cs = cs' @ [t]\n  ys = as' @ a # bs @ a # cs'\n\ngoal (1 subgoal):\n 1. local.weight (v # ys @ [t]) =\n    local.weight (v # as' @ a # cs' @ [t]) + local.weight (a # bs @ [a])", "using\n          weight_append[of \"v # as'\" a \"bs @ a # cs' @ [t]\"]\n          weight_append[of \"a # bs\" a \"cs' @ [t]\"]\n          weight_append[of \"v # as'\" a \"cs' @ [t]\"]"], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  as = v # as'\n  cs = cs' @ [t]\n  ys = as' @ a # bs @ a # cs'\n  local.weight ((v # as') @ a # bs @ a # cs' @ [t]) =\n  local.weight ((v # as') @ [a]) + local.weight (a # bs @ a # cs' @ [t])\n  local.weight ((a # bs) @ a # cs' @ [t]) =\n  local.weight ((a # bs) @ [a]) + local.weight (a # cs' @ [t])\n  local.weight ((v # as') @ a # cs' @ [t]) =\n  local.weight ((v # as') @ [a]) + local.weight (a # cs' @ [t])\n\ngoal (1 subgoal):\n 1. local.weight (v # ys @ [t]) =\n    local.weight (v # as' @ a # cs' @ [t]) + local.weight (a # bs @ [a])", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  local.weight (v # ys @ [t]) =\n  local.weight (v # as' @ a # cs' @ [t]) + local.weight (a # bs @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>as' cs'.\n       \\<lbrakk>as = v # as'; cs = cs' @ [t];\n        ys = as' @ a # bs @ a # cs'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ysa.\n                             local.weight (v # ysa @ [t])\n                             \\<le> local.weight (v # ys @ [t]) \\<and>\n                             set ysa \\<subseteq> {0..n} \\<and>\n                             length ysa < n) \\<or>\n                         v = t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "proof (cases \"weight (a # bs @ [a]) < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t\n 2. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "case True"], ["proof (state)\nthis:\n  local.weight (a # bs @ [a]) < 0\n\ngoal (2 subgoals):\n 1. local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t\n 2. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "with Cons_Cons \\<open>set ys \\<subseteq> _\\<close> path assms(1)"], ["proof (chain)\npicking this:\n  as = v # as'\n  cs = cs' @ [t]\n  ys = as' @ a # bs @ a # cs'\n  set ys \\<subseteq> {0..n}\n  local.is_path (v # ys)\n  \\<not> local.has_negative_cycle\n  local.weight (a # bs @ [a]) < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  as = v # as'\n  cs = cs' @ [t]\n  ys = as' @ a # bs @ a # cs'\n  set ys \\<subseteq> {0..n}\n  local.is_path (v # ys)\n  \\<not> local.has_negative_cycle\n  local.weight (a # bs @ [a]) < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "using is_path_appendD[of \"v # as'\"]"], ["proof (prove)\nusing this:\n  as = v # as'\n  cs = cs' @ [t]\n  ys = as' @ a # bs @ a # cs'\n  set ys \\<subseteq> {0..n}\n  local.is_path (v # ys)\n  \\<not> local.has_negative_cycle\n  local.weight (a # bs @ [a]) < 0\n  local.is_path ((v # as') @ ?a # ?bs) \\<Longrightarrow>\n  local.is_path (?a # ?bs)\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "by (force intro: has_negative_cycleI[of a bs \"bs @ a # cs'\"])"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "case False"], ["proof (state)\nthis:\n  \\<not> local.weight (a # bs @ [a]) < 0\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "then"], ["proof (chain)\npicking this:\n  \\<not> local.weight (a # bs @ [a]) < 0", "have \"weight (a # bs @ [a]) \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> local.weight (a # bs @ [a]) < 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> local.weight (a # bs @ [a])", "by auto"], ["proof (state)\nthis:\n  0 \\<le> local.weight (a # bs @ [a])\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "with * ys"], ["proof (chain)\npicking this:\n  local.weight (v # ys @ [t]) =\n  local.weight (v # as' @ a # cs' @ [t]) + local.weight (a # bs @ [a])\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  0 \\<le> local.weight (a # bs @ [a])", "have \"weight (v # as' @ a # cs' @ [t]) \\<le> weight (v # ys @ [t])\""], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) =\n  local.weight (v # as' @ a # cs' @ [t]) + local.weight (a # bs @ [a])\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  0 \\<le> local.weight (a # bs @ [a])\n\ngoal (1 subgoal):\n 1. local.weight (v # as' @ a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])", "using add_left_mono"], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) =\n  local.weight (v # as' @ a # cs' @ [t]) + local.weight (a # bs @ [a])\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  0 \\<le> local.weight (a # bs @ [a])\n  ?a \\<le> ?b \\<Longrightarrow> ?c + ?a \\<le> ?c + ?b\n\ngoal (1 subgoal):\n 1. local.weight (v # as' @ a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])", "by fastforce"], ["proof (state)\nthis:\n  local.weight (v # as' @ a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])\n\ngoal (1 subgoal):\n 1. \\<not> local.weight (a # bs @ [a]) < 0 \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "with Cons_Cons \\<open>v \\<le> n\\<close> ys"], ["proof (chain)\npicking this:\n  as = v # as'\n  cs = cs' @ [t]\n  ys = as' @ a # bs @ a # cs'\n  v \\<le> n\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  local.weight (v # as' @ a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])", "show ?thesis"], ["proof (prove)\nusing this:\n  as = v # as'\n  cs = cs' @ [t]\n  ys = as' @ a # bs @ a # cs'\n  v \\<le> n\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  local.weight (v # as' @ a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "using is_path_remove_cycle2 IH[of \"as' @ a # cs'\"]"], ["proof (prove)\nusing this:\n  as = v # as'\n  cs = cs' @ [t]\n  ys = as' @ a # bs @ a # cs'\n  v \\<le> n\n  local.weight (v # ys @ [t]) < \\<infinity>\n  set ys \\<subseteq> {0..n}\n  local.weight (v # as' @ a # cs' @ [t]) \\<le> local.weight (v # ys @ [t])\n  local.is_path (?as @ t # ?cs) \\<Longrightarrow> local.is_path ?as\n  \\<lbrakk>length (as' @ a # cs') < length ys;\n   local.weight (v # (as' @ a # cs') @ [t]) < \\<infinity>;\n   set (as' @ a # cs') \\<subseteq> {0..n}; v \\<le> n;\n   local.weight (v # (as' @ a # cs') @ [t]) < \\<infinity>;\n   set (as' @ a # cs') \\<subseteq> {0..n}; v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>ys.\n                        local.weight (v # ys @ [t])\n                        \\<le> local.weight\n                               (v # (as' @ a # cs') @ [t]) \\<and>\n                        set ys \\<subseteq> {0..n} \\<and>\n                        length ys < n) \\<or>\n                    v = t\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "by simp (meson le_less_trans order_trans)"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> length ys \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> length ys \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "case False"], ["proof (state)\nthis:\n  \\<not> n \\<le> length ys\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> length ys \\<Longrightarrow>\n    (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "with \\<open>set ys \\<subseteq> _\\<close>"], ["proof (chain)\npicking this:\n  set ys \\<subseteq> {0..n}\n  \\<not> n \\<le> length ys", "show ?thesis"], ["proof (prove)\nusing this:\n  set ys \\<subseteq> {0..n}\n  \\<not> n \\<le> length ys\n\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        local.weight (v # ysa @ [t])\n        \\<le> local.weight (v # ys @ [t]) \\<and>\n        set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n    v = t", "by auto"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>ysa.\n      local.weight (v # ysa @ [t]) \\<le> local.weight (v # ys @ [t]) \\<and>\n      set ysa \\<subseteq> {0..n} \\<and> length ysa < n) \\<or>\n  v = t\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem shorter_than_OPT_n_has_negative_cycle:\n  assumes \"shortest v < OPT n v\" \"v \\<le> n\"\n  shows has_negative_cycle"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.has_negative_cycle", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.has_negative_cycle", "from assms"], ["proof (chain)\npicking this:\n  local.shortest v < local.OPT n v\n  v \\<le> n", "obtain ys where ys:\n    \"weight (v # ys @ [t]) < OPT n v\" \"set ys \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  local.shortest v < local.OPT n v\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>local.weight (v # ys @ [t]) < local.OPT n v;\n         set ys \\<subseteq> {0..n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases rule: OPT_cases2[of v n]; cases rule: shortest_cases[OF \\<open>v \\<le> n\\<close>]; simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>local.weight (v # ys @ [t])\n                            < local.weight (v # xs @ [t]);\n                    set ys \\<subseteq> {0..n}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        -\\<infinity> < local.weight (v # xs @ [t]); v \\<noteq> t;\n        local.weight (v # xs @ [t]) \\<noteq> \\<infinity>;\n        local.OPT n v = local.weight (v # xs @ [t]);\n        Suc (length xs) \\<le> n; set xs \\<subseteq> {0..n};\n        local.shortest v = -\\<infinity>;\n        \\<forall>x.\n           \\<exists>xs.\n              set xs \\<subseteq> {0..n} \\<and>\n              local.weight (v # xs @ [t]) < Fin x;\n        v \\<le> n\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>local.weight (v # ys @ [t]) < \\<infinity>;\n                 set ys \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<noteq> t; local.OPT n v = \\<infinity>;\n     local.shortest v = -\\<infinity>;\n     \\<forall>x.\n        \\<exists>xs.\n           set xs \\<subseteq> {0..n} \\<and>\n           local.weight (v # xs @ [t]) < Fin x;\n     v \\<le> n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>local.weight (t # ys @ [t]) < local.OPT n t;\n                 set ys \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v = t; local.OPT n t \\<le> 0; local.shortest t = -\\<infinity>;\n     \\<forall>x.\n        \\<exists>xs.\n           set xs \\<subseteq> {0..n} \\<and>\n           local.weight (t # xs @ [t]) < Fin x;\n     -\\<infinity> < local.OPT n t; t \\<le> n\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (metis uminus_extended.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>local.weight (v # ys @ [t]) < \\<infinity>;\n                 set ys \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<noteq> t; local.OPT n v = \\<infinity>;\n     local.shortest v = -\\<infinity>;\n     \\<forall>x.\n        \\<exists>xs.\n           set xs \\<subseteq> {0..n} \\<and>\n           local.weight (v # xs @ [t]) < Fin x;\n     v \\<le> n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>local.weight (t # ys @ [t]) < local.OPT n t;\n                 set ys \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v = t; local.OPT n t \\<le> 0; local.shortest t = -\\<infinity>;\n     \\<forall>x.\n        \\<exists>xs.\n           set xs \\<subseteq> {0..n} \\<and>\n           local.weight (t # xs @ [t]) < Fin x;\n     -\\<infinity> < local.OPT n t; t \\<le> n\\<rbrakk>\n    \\<Longrightarrow> thesis", "using less_extended_simps(2) less_trans"], ["proof (prove)\nusing this:\n  (Fin ?x < \\<infinity>) = True\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>local.weight (v # ys @ [t]) < \\<infinity>;\n                 set ys \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<noteq> t; local.OPT n v = \\<infinity>;\n     local.shortest v = -\\<infinity>;\n     \\<forall>x.\n        \\<exists>xs.\n           set xs \\<subseteq> {0..n} \\<and>\n           local.weight (v # xs @ [t]) < Fin x;\n     v \\<le> n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>local.weight (t # ys @ [t]) < local.OPT n t;\n                 set ys \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v = t; local.OPT n t \\<le> 0; local.shortest t = -\\<infinity>;\n     \\<forall>x.\n        \\<exists>xs.\n           set xs \\<subseteq> {0..n} \\<and>\n           local.weight (t # xs @ [t]) < Fin x;\n     -\\<infinity> < local.OPT n t; t \\<le> n\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>local.weight (t # ys @ [t]) < local.OPT n t;\n                 set ys \\<subseteq> {0..n}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v = t; local.OPT n t \\<le> 0; local.shortest t = -\\<infinity>;\n     \\<forall>x.\n        \\<exists>xs.\n           set xs \\<subseteq> {0..n} \\<and>\n           local.weight (t # xs @ [t]) < Fin x;\n     -\\<infinity> < local.OPT n t; t \\<le> n\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (metis less_eq_extended.elims(2) less_extended_def zero_extended_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  local.weight (v # ys @ [t]) < local.OPT n v\n  set ys \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. local.has_negative_cycle", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.has_negative_cycle", "proof (cases \"v = t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = t \\<Longrightarrow> local.has_negative_cycle\n 2. v \\<noteq> t \\<Longrightarrow> local.has_negative_cycle", "case True"], ["proof (state)\nthis:\n  v = t\n\ngoal (2 subgoals):\n 1. v = t \\<Longrightarrow> local.has_negative_cycle\n 2. v \\<noteq> t \\<Longrightarrow> local.has_negative_cycle", "with ys \\<open>t \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  local.weight (v # ys @ [t]) < local.OPT n v\n  set ys \\<subseteq> {0..n}\n  t \\<le> n\n  v = t", "show ?thesis"], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) < local.OPT n v\n  set ys \\<subseteq> {0..n}\n  t \\<le> n\n  v = t\n\ngoal (1 subgoal):\n 1. local.has_negative_cycle", "using OPT_sink_le_0[of n]"], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) < local.OPT n v\n  set ys \\<subseteq> {0..n}\n  t \\<le> n\n  v = t\n  local.OPT n t \\<le> 0\n\ngoal (1 subgoal):\n 1. local.has_negative_cycle", "unfolding has_negative_cycle_def is_path_def"], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) < local.OPT n v\n  set ys \\<subseteq> {0..n}\n  t \\<le> n\n  v = t\n  local.OPT n t \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<exists>xs a ys.\n       set (a # xs @ ys) \\<subseteq> {0..n} \\<and>\n       local.weight (a # xs @ [a]) < 0 \\<and>\n       local.weight ((a # ys) @ [t]) < \\<infinity>", "using less_extended_def"], ["proof (prove)\nusing this:\n  local.weight (v # ys @ [t]) < local.OPT n v\n  set ys \\<subseteq> {0..n}\n  t \\<le> n\n  v = t\n  local.OPT n t \\<le> 0\n  (?x < ?y) = (?x \\<le> ?y \\<and> \\<not> ?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>xs a ys.\n       set (a # xs @ ys) \\<subseteq> {0..n} \\<and>\n       local.weight (a # xs @ [a]) < 0 \\<and>\n       local.weight ((a # ys) @ [t]) < \\<infinity>", "by force"], ["proof (state)\nthis:\n  local.has_negative_cycle\n\ngoal (1 subgoal):\n 1. v \\<noteq> t \\<Longrightarrow> local.has_negative_cycle", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> t \\<Longrightarrow> local.has_negative_cycle", "case False"], ["proof (state)\nthis:\n  v \\<noteq> t\n\ngoal (1 subgoal):\n 1. v \\<noteq> t \\<Longrightarrow> local.has_negative_cycle", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.has_negative_cycle", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> local.has_negative_cycle \\<Longrightarrow> False", "assume \"\\<not> has_negative_cycle\""], ["proof (state)\nthis:\n  \\<not> local.has_negative_cycle\n\ngoal (1 subgoal):\n 1. \\<not> local.has_negative_cycle \\<Longrightarrow> False", "with False False ys \\<open>v \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  v \\<noteq> t\n  v \\<noteq> t\n  local.weight (v # ys @ [t]) < local.OPT n v\n  set ys \\<subseteq> {0..n}\n  v \\<le> n\n  \\<not> local.has_negative_cycle", "obtain xs where\n        \"weight (v # xs @ [t]) \\<le> weight (v # ys @ [t])\" \"set xs \\<subseteq> {0..n}\" \"length xs < n\""], ["proof (prove)\nusing this:\n  v \\<noteq> t\n  v \\<noteq> t\n  local.weight (v # ys @ [t]) < local.OPT n v\n  set ys \\<subseteq> {0..n}\n  v \\<le> n\n  \\<not> local.has_negative_cycle\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>local.weight (v # xs @ [t])\n                 \\<le> local.weight (v # ys @ [t]);\n         set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less_extended_def"], ["proof (prove)\nusing this:\n  v \\<noteq> t\n  v \\<noteq> t\n  local.weight (v # ys @ [t]) < local.OPT n v\n  set ys \\<subseteq> {0..n}\n  v \\<le> n\n  \\<not> local.has_negative_cycle\n  (?x < ?y) = (?x \\<le> ?y \\<and> \\<not> ?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>local.weight (v # xs @ [t])\n                 \\<le> local.weight (v # ys @ [t]);\n         set xs \\<subseteq> {0..n}; length xs < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce elim!: simple_paths[of v ys])"], ["proof (state)\nthis:\n  local.weight (v # xs @ [t]) \\<le> local.weight (v # ys @ [t])\n  set xs \\<subseteq> {0..n}\n  length xs < n\n\ngoal (1 subgoal):\n 1. \\<not> local.has_negative_cycle \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  local.weight (v # xs @ [t]) \\<le> local.weight (v # ys @ [t])\n  set xs \\<subseteq> {0..n}\n  length xs < n", "have \"OPT n v \\<le> weight (v # xs @ [t])\""], ["proof (prove)\nusing this:\n  local.weight (v # xs @ [t]) \\<le> local.weight (v # ys @ [t])\n  set xs \\<subseteq> {0..n}\n  length xs < n\n\ngoal (1 subgoal):\n 1. local.OPT n v \\<le> local.weight (v # xs @ [t])", "unfolding OPT_def"], ["proof (prove)\nusing this:\n  local.weight (v # xs @ [t]) \\<le> local.weight (v # ys @ [t])\n  set xs \\<subseteq> {0..n}\n  length xs < n\n\ngoal (1 subgoal):\n 1. Min ({local.weight (v # xs @ [t]) |xs.\n          length xs + 1 \\<le> n \\<and> set xs \\<subseteq> {0..n}} \\<union>\n         {if t = v then 0 else \\<infinity>})\n    \\<le> local.weight (v # xs @ [t])", "by (intro Min_le) auto"], ["proof (state)\nthis:\n  local.OPT n v \\<le> local.weight (v # xs @ [t])\n\ngoal (1 subgoal):\n 1. \\<not> local.has_negative_cycle \\<Longrightarrow> False", "with \\<open>_ \\<le> weight (v # ys @ [t])\\<close> \\<open>weight (v # ys @ [t]) < OPT n v\\<close>"], ["proof (chain)\npicking this:\n  local.weight (v # xs @ [t]) \\<le> local.weight (v # ys @ [t])\n  local.weight (v # ys @ [t]) < local.OPT n v\n  local.OPT n v \\<le> local.weight (v # xs @ [t])", "show False"], ["proof (prove)\nusing this:\n  local.weight (v # xs @ [t]) \\<le> local.weight (v # ys @ [t])\n  local.weight (v # ys @ [t]) < local.OPT n v\n  local.OPT n v \\<le> local.weight (v # xs @ [t])\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.has_negative_cycle\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.has_negative_cycle\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary detects_cycle_has_negative_cycle:\n  assumes \"OPT (n + 1) v < OPT n v\" \"v \\<le> n\"\n  shows has_negative_cycle"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.has_negative_cycle", "using assms shortest_le_OPT[of v \"n + 1\"] shorter_than_OPT_n_has_negative_cycle[of v]"], ["proof (prove)\nusing this:\n  local.OPT (n + 1) v < local.OPT n v\n  v \\<le> n\n  v \\<le> n \\<Longrightarrow> local.shortest v \\<le> local.OPT (n + 1) v\n  \\<lbrakk>local.shortest v < local.OPT n v; v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> local.has_negative_cycle\n\ngoal (1 subgoal):\n 1. local.has_negative_cycle", "by auto"], ["", "corollary bellman_ford_detects_cycle:\n  \"has_negative_cycle \\<longleftrightarrow> (\\<exists>v \\<le> n. OPT (n + 1) v < OPT n v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.has_negative_cycle =\n    (\\<exists>v\\<le>n. local.OPT (n + 1) v < local.OPT n v)", "using detects_cycle_has_negative_cycle detects_cycle"], ["proof (prove)\nusing this:\n  \\<lbrakk>local.OPT (n + 1) ?v < local.OPT n ?v; ?v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> local.has_negative_cycle\n  local.has_negative_cycle \\<Longrightarrow>\n  \\<exists>i\\<le>n. local.OPT (n + 1) i < local.OPT n i\n\ngoal (1 subgoal):\n 1. local.has_negative_cycle =\n    (\\<exists>v\\<le>n. local.OPT (n + 1) v < local.OPT n v)", "by blast"], ["", "corollary bellman_ford_shortest_paths:\n  assumes \"\\<not> has_negative_cycle\"\n  shows \"\\<forall>v \\<le> n. bf n v = shortest v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<le>n. local.bf n v = local.shortest v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v\\<le>n. local.bf n v = local.shortest v", "have \"OPT n v \\<le> shortest v\" if \"v \\<le> n\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT n v \\<le> local.shortest v", "using that assms shorter_than_OPT_n_has_negative_cycle[of v]"], ["proof (prove)\nusing this:\n  v \\<le> n\n  \\<not> local.has_negative_cycle\n  \\<lbrakk>local.shortest v < local.OPT n v; v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> local.has_negative_cycle\n\ngoal (1 subgoal):\n 1. local.OPT n v \\<le> local.shortest v", "by force"], ["proof (state)\nthis:\n  ?v2 \\<le> n \\<Longrightarrow> local.OPT n ?v2 \\<le> local.shortest ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<le>n. local.bf n v = local.shortest v", "then"], ["proof (chain)\npicking this:\n  ?v2 \\<le> n \\<Longrightarrow> local.OPT n ?v2 \\<le> local.shortest ?v2", "show ?thesis"], ["proof (prove)\nusing this:\n  ?v2 \\<le> n \\<Longrightarrow> local.OPT n ?v2 \\<le> local.shortest ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<le>n. local.bf n v = local.shortest v", "unfolding bf_correct[OF \\<open>t \\<le> n\\<close>, symmetric]"], ["proof (prove)\nusing this:\n  ?v2 \\<le> n \\<Longrightarrow> local.OPT n ?v2 \\<le> local.shortest ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<le>n. local.OPT n v = local.shortest v", "by (safe, rule order.antisym) (auto elim: shortest_le_OPT)"], ["proof (state)\nthis:\n  \\<forall>v\\<le>n. local.bf n v = local.shortest v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT_mono:\n  \"OPT m v \\<le> OPT n v\" if \\<open>v \\<le> n\\<close> \\<open>n \\<le> m\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT m v \\<le> local.OPT n v", "using that"], ["proof (prove)\nusing this:\n  v \\<le> n\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. local.OPT m v \\<le> local.OPT n v", "unfolding OPT_def"], ["proof (prove)\nusing this:\n  v \\<le> n\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. Min ({local.weight (v # xs @ [t]) |xs.\n          length xs + 1 \\<le> m \\<and> set xs \\<subseteq> {0..n}} \\<union>\n         {if t = v then 0 else \\<infinity>})\n    \\<le> Min ({local.weight (v # xs @ [t]) |xs.\n                length xs + 1 \\<le> n \\<and>\n                set xs \\<subseteq> {0..n}} \\<union>\n               {if t = v then 0 else \\<infinity>})", "by (intro Min_antimono) auto"], ["", "corollary bf_fix:\n  assumes \"\\<not> has_negative_cycle\" \"m \\<ge> n\"\n  shows \"\\<forall>v \\<le> n. bf m v = bf n v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<le>n. local.bf m v = local.bf n v", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<le> n \\<Longrightarrow> local.bf m v = local.bf n v", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<le> n \\<Longrightarrow> local.bf m v = local.bf n v", "assume \"v \\<le> n\""], ["proof (state)\nthis:\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<le> n \\<Longrightarrow> local.bf m v = local.bf n v", "from \\<open>v \\<le> n\\<close> \\<open>n \\<le> m\\<close>"], ["proof (chain)\npicking this:\n  v \\<le> n\n  n \\<le> m", "have \"shortest v \\<le> OPT m v\""], ["proof (prove)\nusing this:\n  v \\<le> n\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. local.shortest v \\<le> local.OPT m v", "by (simp add: shortest_le_OPT)"], ["proof (state)\nthis:\n  local.shortest v \\<le> local.OPT m v\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<le> n \\<Longrightarrow> local.bf m v = local.bf n v", "moreover"], ["proof (state)\nthis:\n  local.shortest v \\<le> local.OPT m v\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<le> n \\<Longrightarrow> local.bf m v = local.bf n v", "from \\<open>v \\<le> n\\<close> \\<open>n \\<le> m\\<close>"], ["proof (chain)\npicking this:\n  v \\<le> n\n  n \\<le> m", "have \"OPT m v \\<le> OPT n v\""], ["proof (prove)\nusing this:\n  v \\<le> n\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. local.OPT m v \\<le> local.OPT n v", "by (rule OPT_mono)"], ["proof (state)\nthis:\n  local.OPT m v \\<le> local.OPT n v\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<le> n \\<Longrightarrow> local.bf m v = local.bf n v", "moreover"], ["proof (state)\nthis:\n  local.OPT m v \\<le> local.OPT n v\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<le> n \\<Longrightarrow> local.bf m v = local.bf n v", "from \\<open>v \\<le> n\\<close> assms"], ["proof (chain)\npicking this:\n  v \\<le> n\n  \\<not> local.has_negative_cycle\n  n \\<le> m", "have \"OPT n v \\<le> shortest v\""], ["proof (prove)\nusing this:\n  v \\<le> n\n  \\<not> local.has_negative_cycle\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. local.OPT n v \\<le> local.shortest v", "using shorter_than_OPT_n_has_negative_cycle[of v]"], ["proof (prove)\nusing this:\n  v \\<le> n\n  \\<not> local.has_negative_cycle\n  n \\<le> m\n  \\<lbrakk>local.shortest v < local.OPT n v; v \\<le> n\\<rbrakk>\n  \\<Longrightarrow> local.has_negative_cycle\n\ngoal (1 subgoal):\n 1. local.OPT n v \\<le> local.shortest v", "by force"], ["proof (state)\nthis:\n  local.OPT n v \\<le> local.shortest v\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<le> n \\<Longrightarrow> local.bf m v = local.bf n v", "ultimately"], ["proof (chain)\npicking this:\n  local.shortest v \\<le> local.OPT m v\n  local.OPT m v \\<le> local.OPT n v\n  local.OPT n v \\<le> local.shortest v", "show \"bf m v = bf n v\""], ["proof (prove)\nusing this:\n  local.shortest v \\<le> local.OPT m v\n  local.OPT m v \\<le> local.OPT n v\n  local.OPT n v \\<le> local.shortest v\n\ngoal (1 subgoal):\n 1. local.bf m v = local.bf n v", "unfolding bf_correct[OF \\<open>t \\<le> n\\<close>, symmetric]"], ["proof (prove)\nusing this:\n  local.shortest v \\<le> local.OPT m v\n  local.OPT m v \\<le> local.OPT n v\n  local.OPT n v \\<le> local.shortest v\n\ngoal (1 subgoal):\n 1. local.OPT m v = local.OPT n v", "by simp"], ["proof (state)\nthis:\n  local.bf m v = local.bf n v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bellman_ford_correct':\n  \"bf\\<^sub>m.crel_vs (=) (if has_negative_cycle then None else Some (map shortest [0..<n+1])) bellman_ford\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n     (if local.has_negative_cycle then None\n      else Some (map local.shortest [0..<n + 1]))\n     local.bellman_ford", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n     (if local.has_negative_cycle then None\n      else Some (map local.shortest [0..<n + 1]))\n     local.bellman_ford", "include state_monad_syntax app_syntax"], ["proof (state)\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n     (if local.has_negative_cycle then None\n      else Some (map local.shortest [0..<n + 1]))\n     local.bellman_ford", "let ?l = \"if has_negative_cycle then None else Some (map shortest [0..<n + 1])\""], ["proof (state)\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n     (if local.has_negative_cycle then None\n      else Some (map local.shortest [0..<n + 1]))\n     local.bellman_ford", "let ?r = \"(\\<lambda>xs. (\\<lambda>ys. (if xs = ys then Some xs else None))\n    $ (map $ \\<llangle>bf (n + 1)\\<rrangle> $ \\<llangle>[0..<n + 1]\\<rrangle>)) $ (map $ \\<llangle>bf n\\<rrangle> $ \\<llangle>[0..<n + 1]\\<rrangle>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n     (if local.has_negative_cycle then None\n      else Some (map local.shortest [0..<n + 1]))\n     local.bellman_ford", "note crel_bf\\<^sub>m' = bf\\<^sub>m.crel[unfolded bf\\<^sub>m.consistentDP_def, THEN rel_funD,\n      of \"(m, x)\" \"(m, y)\" for m x y, unfolded prod.case]"], ["proof (state)\nthis:\n  (?m4, ?x4) = (?m4, ?y4) \\<Longrightarrow>\n  dp_consistency.crel_vs\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n   (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=) (local.bf ?m4 ?x4)\n   (local.bf\\<^sub>m' ?m4 ?y4)\n\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n     (if local.has_negative_cycle then None\n      else Some (map local.shortest [0..<n + 1]))\n     local.bellman_ford", "have \"?l = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if local.has_negative_cycle then None\n     else Some (map local.shortest [0..<n + 1])) =\n    (\\<lambda>xs.\n        (\\<lambda>ys. if xs = ys then Some xs else None) $\n        (map $ \\<llangle>local.bf (n + 1)\\<rrangle> $\n         \\<llangle>[0..<n + 1]\\<rrangle>)) $\n    (map $ \\<llangle>local.bf n\\<rrangle> $ \\<llangle>[0..<n + 1]\\<rrangle>)", "supply [simp del] = bf_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if local.has_negative_cycle then None\n     else Some (map local.shortest [0..<n + 1])) =\n    (\\<lambda>xs.\n        (\\<lambda>ys. if xs = ys then Some xs else None) $\n        (map $ \\<llangle>local.bf (n + 1)\\<rrangle> $\n         \\<llangle>[0..<n + 1]\\<rrangle>)) $\n    (map $ \\<llangle>local.bf n\\<rrangle> $ \\<llangle>[0..<n + 1]\\<rrangle>)", "supply [simp add] =\n      bf_fix[rule_format, symmetric] bellman_ford_shortest_paths[rule_format, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if local.has_negative_cycle then None\n     else Some (map local.shortest [0..<n + 1])) =\n    (\\<lambda>xs.\n        (\\<lambda>ys. if xs = ys then Some xs else None) $\n        (map $ \\<llangle>local.bf (n + 1)\\<rrangle> $\n         \\<llangle>[0..<n + 1]\\<rrangle>)) $\n    (map $ \\<llangle>local.bf n\\<rrangle> $ \\<llangle>[0..<n + 1]\\<rrangle>)", "unfolding Wrap_def App_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if local.has_negative_cycle then None\n     else Some (map local.shortest [0..<n + 1])) =\n    (if map (local.bf n) [0..<n + 1] = map (local.bf (n + 1)) [0..<n + 1]\n     then Some (map (local.bf n) [0..<n + 1]) else None)", "using bf_detects_cycle"], ["proof (prove)\nusing this:\n  local.has_negative_cycle \\<Longrightarrow>\n  \\<exists>i\\<le>n. local.bf (n + 1) i < local.bf n i\n\ngoal (1 subgoal):\n 1. (if local.has_negative_cycle then None\n     else Some (map local.shortest [0..<n + 1])) =\n    (if map (local.bf n) [0..<n + 1] = map (local.bf (n + 1)) [0..<n + 1]\n     then Some (map (local.bf n) [0..<n + 1]) else None)", "by (fastforce elim: nat_le_cases)\n  \\<comment> \\<open>Slightly transform the goal, then apply parametric reasoning like usual.\\<close>"], ["proof (state)\nthis:\n  (if local.has_negative_cycle then None\n   else Some (map local.shortest [0..<n + 1])) =\n  (\\<lambda>xs.\n      (\\<lambda>ys. if xs = ys then Some xs else None) $\n      (map $ \\<llangle>local.bf (n + 1)\\<rrangle> $\n       \\<llangle>[0..<n + 1]\\<rrangle>)) $\n  (map $ \\<llangle>local.bf n\\<rrangle> $ \\<llangle>[0..<n + 1]\\<rrangle>)\n\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n     (if local.has_negative_cycle then None\n      else Some (map local.shortest [0..<n + 1]))\n     local.bellman_ford", "show ?thesis\n    \\<comment> \\<open>Roughly \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n     (if local.has_negative_cycle then None\n      else Some (map local.shortest [0..<n + 1]))\n     local.bellman_ford", "unfolding bellman_ford_alt_def \\<open>?l = ?r\\<close> \\<comment> \\<open>Obtain parametric form.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n     ((\\<lambda>xs.\n          (\\<lambda>ys. if xs = ys then Some xs else None) $\n          (map $ \\<llangle>local.bf (n + 1)\\<rrangle> $\n           \\<llangle>[0..<n + 1]\\<rrangle>)) $\n      (map $ \\<llangle>local.bf n\\<rrangle> $\n       \\<llangle>[0..<n + 1]\\<rrangle>))\n     (local.iter_bf (n, n) \\<bind>\n      (\\<lambda>_.\n          \\<langle>\\<lambda>xs.\n                      \\<langle>\\<lambda>ys.\n                                  \\<langle>if xs = ys then Some xs\n     else None\\<rangle>\\<rangle> .\n                      (State_Main.map\\<^sub>T .\n                       \\<langle>local.bf\\<^sub>m' (n + 1)\\<rangle> .\n                       \\<langle>[0..<n + 1]\\<rangle>)\\<rangle> .\n          (State_Main.map\\<^sub>T . \\<langle>local.bf\\<^sub>m' n\\<rangle> .\n           \\<langle>[0..<n + 1]\\<rangle>)))", "apply (rule bf\\<^sub>m.crel_vs_bind_ignore[rotated]) \\<comment> \\<open>Drop bind.\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) ?S ?c\n     (local.iter_bf (n, n))\n 2. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n     ((\\<lambda>xs.\n          (\\<lambda>ys. if xs = ys then Some xs else None) $\n          (map $ \\<llangle>local.bf (n + 1)\\<rrangle> $\n           \\<llangle>[0..<n + 1]\\<rrangle>)) $\n      (map $ \\<llangle>local.bf n\\<rrangle> $\n       \\<llangle>[0..<n + 1]\\<rrangle>))\n     (\\<langle>\\<lambda>xs.\n                  \\<langle>\\<lambda>ys.\n                              \\<langle>if xs = ys then Some xs\n else None\\<rangle>\\<rangle> .\n                  (State_Main.map\\<^sub>T .\n                   \\<langle>local.bf\\<^sub>m' (n + 1)\\<rangle> .\n                   \\<langle>[0..<n + 1]\\<rangle>)\\<rangle> .\n      (State_Main.map\\<^sub>T . \\<langle>local.bf\\<^sub>m' n\\<rangle> .\n       \\<langle>[0..<n + 1]\\<rangle>))", "apply (rule bottom_up.consistent_crel_vs_iterate_state[OF bf\\<^sub>m.crel, folded iter_bf_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n     ((\\<lambda>xs.\n          (\\<lambda>ys. if xs = ys then Some xs else None) $\n          (map $ \\<llangle>local.bf (n + 1)\\<rrangle> $\n           \\<llangle>[0..<n + 1]\\<rrangle>)) $\n      (map $ \\<llangle>local.bf n\\<rrangle> $\n       \\<llangle>[0..<n + 1]\\<rrangle>))\n     (\\<langle>\\<lambda>xs.\n                  \\<langle>\\<lambda>ys.\n                              \\<langle>if xs = ys then Some xs\n else None\\<rangle>\\<rangle> .\n                  (State_Main.map\\<^sub>T .\n                   \\<langle>local.bf\\<^sub>m' (n + 1)\\<rangle> .\n                   \\<langle>[0..<n + 1]\\<rangle>)\\<rangle> .\n      (State_Main.map\\<^sub>T . \\<langle>local.bf\\<^sub>m' n\\<rangle> .\n       \\<langle>[0..<n + 1]\\<rangle>))", "apply (subst Transfer.Rel_def[symmetric]) \\<comment> \\<open>Setup typical goal for automated reasoner.\\<close>\n    \\<comment> \\<open>We need to reason manually because we are not in the context where \\<open>bf\\<^sub>m\\<close> was defined.\\<close>\n    \\<comment> \\<open>This is roughly what @{method \"memoize_prover_match_step\"}/\\<open>Transform_Tactic.step_tac\\<close> does.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (dp_consistency.crel_vs\n          (\\<lambda>k.\n              State_Monad.get \\<bind>\n              (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n          (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=))\n     ((\\<lambda>xs.\n          (\\<lambda>ys. if xs = ys then Some xs else None) $\n          (map $ \\<llangle>local.bf (n + 1)\\<rrangle> $\n           \\<llangle>[0..<n + 1]\\<rrangle>)) $\n      (map $ \\<llangle>local.bf n\\<rrangle> $\n       \\<llangle>[0..<n + 1]\\<rrangle>))\n     (\\<langle>\\<lambda>xs.\n                  \\<langle>\\<lambda>ys.\n                              \\<langle>if xs = ys then Some xs\n else None\\<rangle>\\<rangle> .\n                  (State_Main.map\\<^sub>T .\n                   \\<langle>local.bf\\<^sub>m' (n + 1)\\<rangle> .\n                   \\<langle>[0..<n + 1]\\<rangle>)\\<rangle> .\n      (State_Main.map\\<^sub>T . \\<langle>local.bf\\<^sub>m' n\\<rangle> .\n       \\<langle>[0..<n + 1]\\<rangle>))", "ML_prf \\<open>val ctxt = @{context}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (dp_consistency.crel_vs\n          (\\<lambda>k.\n              State_Monad.get \\<bind>\n              (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n          (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=))\n     ((\\<lambda>xs.\n          (\\<lambda>ys. if xs = ys then Some xs else None) $\n          (map $ \\<llangle>local.bf (n + 1)\\<rrangle> $\n           \\<llangle>[0..<n + 1]\\<rrangle>)) $\n      (map $ \\<llangle>local.bf n\\<rrangle> $\n       \\<llangle>[0..<n + 1]\\<rrangle>))\n     (\\<langle>\\<lambda>xs.\n                  \\<langle>\\<lambda>ys.\n                              \\<langle>if xs = ys then Some xs\n else None\\<rangle>\\<rangle> .\n                  (State_Main.map\\<^sub>T .\n                   \\<langle>local.bf\\<^sub>m' (n + 1)\\<rangle> .\n                   \\<langle>[0..<n + 1]\\<rangle>)\\<rangle> .\n      (State_Main.map\\<^sub>T . \\<langle>local.bf\\<^sub>m' n\\<rangle> .\n       \\<langle>[0..<n + 1]\\<rangle>))", "apply (tactic \\<open>Transform_Tactic.solve_relator_tac ctxt 1\\<close>\n          | rule HOL.refl\n          | rule bf\\<^sub>m.dp_match_rule\n          | rule bf\\<^sub>m.crel_vs_return_ext\n          | (subst Rel_def, rule crel_bf\\<^sub>m')\n          | tactic \\<open>Transform_Tactic.transfer_raw_tac ctxt 1\\<close>)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dp_consistency.crel_vs\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n   (\\<lambda>_. True) (\\<lambda>(x, y). local.bf x y) (=)\n   (if local.has_negative_cycle then None\n    else Some (map local.shortest [0..<n + 1]))\n   local.bellman_ford\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem bellman_ford_correct:\n  \"fst (run_state bellman_ford Mapping.empty) =\n  (if has_negative_cycle then None else Some (map shortest [0..<n+1]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (run_state local.bellman_ford Mapping.empty) =\n    (if local.has_negative_cycle then None\n     else Some (map local.shortest [0..<n + 1]))", "using bf\\<^sub>m.cmem_empty bellman_ford_correct'[unfolded bf\\<^sub>m.crel_vs_def, rule_format, of Mapping.empty]"], ["proof (prove)\nusing this:\n  dp_consistency.cmem\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n   (\\<lambda>(x, y). local.bf x y) Mapping.empty\n  dp_consistency.cmem\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n   (\\<lambda>(x, y). local.bf x y) Mapping.empty \\<and>\n  True \\<Longrightarrow>\n  case run_state local.bellman_ford Mapping.empty of\n  (v', M') \\<Rightarrow>\n    (if local.has_negative_cycle then None\n     else Some (map local.shortest [0..<n + 1])) =\n    v' \\<and>\n    dp_consistency.cmem\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>(x, y). local.bf x y) M' \\<and>\n    True\n\ngoal (1 subgoal):\n 1. fst (run_state local.bellman_ford Mapping.empty) =\n    (if local.has_negative_cycle then None\n     else Some (map local.shortest [0..<n + 1]))", "unfolding bf\\<^sub>m.crel_vs_def"], ["proof (prove)\nusing this:\n  dp_consistency.cmem\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n   (\\<lambda>(x, y). local.bf x y) Mapping.empty\n  dp_consistency.cmem\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n   (\\<lambda>(x, y). local.bf x y) Mapping.empty \\<and>\n  True \\<Longrightarrow>\n  case run_state local.bellman_ford Mapping.empty of\n  (v', M') \\<Rightarrow>\n    (if local.has_negative_cycle then None\n     else Some (map local.shortest [0..<n + 1])) =\n    v' \\<and>\n    dp_consistency.cmem\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>(x, y). local.bf x y) M' \\<and>\n    True\n\ngoal (1 subgoal):\n 1. fst (run_state local.bellman_ford Mapping.empty) =\n    (if local.has_negative_cycle then None\n     else Some (map local.shortest [0..<n + 1]))", "by auto"], ["", "end"], ["", "(* Wellformedness *)"], ["", "end"], ["", "(* Final Node *)"], ["", "end"], ["", "(* Bellman Ford *)"], ["", "subsubsection \\<open>Extracting an Executable Constant for the Imperative Implementation\\<close>"], ["", "ground_function (prove_termination) bf\\<^sub>h'_impl: bf\\<^sub>h'.simps"], ["", "lemma bf\\<^sub>h'_impl_def:\n  fixes n :: nat\n  fixes mem :: \"nat ref \\<times> nat ref \\<times> int extended option array ref \\<times> int extended option array ref\"\n  assumes mem_is_init: \"mem = result_of (init_state (n + 1) 1 0) Heap.empty\"\n  shows \"bf\\<^sub>h'_impl n w t mem = bf\\<^sub>h' n w t mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bf\\<^sub>h'_impl n w t mem = bf\\<^sub>h' n w t mem", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bf\\<^sub>h'_impl n w t mem = bf\\<^sub>h' n w t mem", "have \"bf\\<^sub>h'_impl n w t mem i j = bf\\<^sub>h' n w t mem i j\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. bf\\<^sub>h'_impl n w t mem i j = bf\\<^sub>h' n w t mem i j", "by (induction rule: bf\\<^sub>h'.induct[OF mem_is_init];\n        simp add: bf\\<^sub>h'.simps[OF mem_is_init]; solve_cong simp\n       )"], ["proof (state)\nthis:\n  bf\\<^sub>h'_impl n w t mem ?i ?j = bf\\<^sub>h' n w t mem ?i ?j\n\ngoal (1 subgoal):\n 1. bf\\<^sub>h'_impl n w t mem = bf\\<^sub>h' n w t mem", "then"], ["proof (chain)\npicking this:\n  bf\\<^sub>h'_impl n w t mem ?i ?j = bf\\<^sub>h' n w t mem ?i ?j", "show ?thesis"], ["proof (prove)\nusing this:\n  bf\\<^sub>h'_impl n w t mem ?i ?j = bf\\<^sub>h' n w t mem ?i ?j\n\ngoal (1 subgoal):\n 1. bf\\<^sub>h'_impl n w t mem = bf\\<^sub>h' n w t mem", "by auto"], ["proof (state)\nthis:\n  bf\\<^sub>h'_impl n w t mem = bf\\<^sub>h' n w t mem\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"iter_bf_heap n w t mem = iterator_defs.iter_heap\n      (\\<lambda>(x, y). x \\<le> n \\<and> y \\<le> n)\n      (\\<lambda>(x, y). if y < n then (x, y + 1) else (x + 1, 0))\n      (\\<lambda>(x, y). bf\\<^sub>h'_impl n w t mem x y)\""], ["", "lemma iter_bf_heap_unfold[code]:\n  \"iter_bf_heap n w t mem = (\\<lambda> (i, j).\n    (if i \\<le> n \\<and> j \\<le> n\n     then do {\n            bf\\<^sub>h'_impl n w t mem i j;\n            iter_bf_heap n w t mem (if j < n then (i, j + 1) else (i + 1, 0))\n          }\n     else Heap_Monad.return ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter_bf_heap n w t mem =\n    (\\<lambda>(i, j).\n        if i \\<le> n \\<and> j \\<le> n\n        then bf\\<^sub>h'_impl n w t mem i j \\<bind>\n             (\\<lambda>_.\n                 iter_bf_heap n w t mem\n                  (if j < n then (i, j + 1) else (i + 1, 0)))\n        else return ())", "unfolding iter_bf_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterator_defs.iter_heap (\\<lambda>(x, y). x \\<le> n \\<and> y \\<le> n)\n     (\\<lambda>(x, y). if y < n then (x, y + 1) else (x + 1, 0))\n     (\\<lambda>(x, y). bf\\<^sub>h'_impl n w t mem x y) =\n    (\\<lambda>(i, j).\n        if i \\<le> n \\<and> j \\<le> n\n        then bf\\<^sub>h'_impl n w t mem i j \\<bind>\n             (\\<lambda>_.\n                 iterator_defs.iter_heap\n                  (\\<lambda>(x, y). x \\<le> n \\<and> y \\<le> n)\n                  (\\<lambda>(x, y).\n                      if y < n then (x, y + 1) else (x + 1, 0))\n                  (\\<lambda>(x, y). bf\\<^sub>h'_impl n w t mem x y)\n                  (if j < n then (i, j + 1) else (i + 1, 0)))\n        else return ())", "by (rule ext) (safe, simp add: iter_heap_unfold)"], ["", "definition\n  \"bf_impl n w t i j = do {\n    mem \\<leftarrow> (init_state (n + 1) (1::nat) (0::nat) ::\n      (nat ref \\<times> nat ref \\<times> int extended option array ref \\<times> int extended option array ref) Heap);\n    iter_bf_heap n w t mem (0, 0);\n    bf\\<^sub>h'_impl n w t mem i j\n  }\""], ["", "lemma bf_impl_correct:\n  \"bf n w t i j = result_of (bf_impl n w t i j) Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bf n w t i j = result_of (bf_impl n w t i j) Heap.empty", "using memoized_empty[OF HOL.refl, of n w t \"(i, j)\"]"], ["proof (prove)\nusing this:\n  (case (i, j) of (a, b) \\<Rightarrow> bf n w t a b) =\n  result_of\n   (init_state (n + 1) 1 0 \\<bind>\n    (\\<lambda>mem.\n        iterator_defs.iter_heap\n         (\\<lambda>a.\n             case a of (x, y) \\<Rightarrow> x \\<le> n \\<and> y \\<le> n)\n         (\\<lambda>a.\n             case a of\n             (x, y) \\<Rightarrow> if y < n then (x, y + 1) else (x + 1, 0))\n         (\\<lambda>a.\n             case a of\n             (a, b) \\<Rightarrow>\n               bf\\<^sub>h' n w t\n                (result_of (init_state (n + 1) 1 0) Heap.empty) a b)\n         (?y mem) \\<bind>\n        (\\<lambda>_.\n            case (i, j) of\n            (a, b) \\<Rightarrow>\n              bf\\<^sub>h' n w t\n               (result_of (init_state (n + 1) 1 0) Heap.empty) a b)))\n   Heap.empty\n\ngoal (1 subgoal):\n 1. bf n w t i j = result_of (bf_impl n w t i j) Heap.empty", "by (simp add:\n        execute_bind_success[OF succes_init_state] bf_impl_def bf\\<^sub>h'_impl_def iter_bf_heap_def\n      )"], ["", "subsubsection \\<open>Test Cases\\<close>"], ["", "definition\n  \"G\\<^sub>1_list = [[(1 :: nat,-6 :: int), (2,4), (3,5)], [(3,10)], [(3,2)], []]\""], ["", "definition\n  \"G\\<^sub>2_list = [[(1 :: nat,-6 :: int), (2,4), (3,5)], [(3,10)], [(3,2)], [(0, -5)]]\""], ["", "definition\n  \"G\\<^sub>3_list = [[(1 :: nat,-1 :: int), (2,2)], [(2,5), (3,4)], [(3,2), (4,3)], [(2,-2), (4,2)], []]\""], ["", "definition\n  \"G\\<^sub>4_list = [[(1 :: nat,-1 :: int), (2,2)], [(2,5), (3,4)], [(3,2), (4,3)], [(2,-3), (4,2)], []]\""], ["", "definition\n  \"graph_of a i j = case_option \\<infinity> (Fin o snd) (List.find (\\<lambda> p. fst p = j) (a !! i))\""], ["", "definition \"test_bf = bf_impl 3 (graph_of (IArray G\\<^sub>1_list)) 3 3 0\""], ["", "code_reflect Test functions test_bf"], ["", "text \\<open>One can see a trace of the calls to the memory in the output\\<close>"], ["", "ML \\<open>Test.test_bf ()\\<close>"], ["", "lemma bottom_up_alt[code]:\n  \"bf n W t i j =\n     fst (run_state\n      (iter_bf n W t (0, 0) \\<bind> (\\<lambda>_. bf\\<^sub>m' n W t i j))\n      Mapping.empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bf n W t i j =\n    fst (run_state\n          (iter_bf n W t (0, 0) \\<bind> (\\<lambda>_. bf\\<^sub>m' n W t i j))\n          Mapping.empty)", "using bf_bottom_up"], ["proof (prove)\nusing this:\n  (case ?x of (x, y) \\<Rightarrow> bf ?n ?W ?t x y) =\n  fst (run_state\n        (iter_bf ?n ?W ?t ?y \\<bind>\n         (\\<lambda>_.\n             case ?x of (a, b) \\<Rightarrow> bf\\<^sub>m' ?n ?W ?t a b))\n        Mapping.empty)\n\ngoal (1 subgoal):\n 1. bf n W t i j =\n    fst (run_state\n          (iter_bf n W t (0, 0) \\<bind> (\\<lambda>_. bf\\<^sub>m' n W t i j))\n          Mapping.empty)", "by auto"], ["", "definition\n  \"bf_ia n W t i j = (let W' = graph_of (IArray W) in\n    fst (run_state\n      (iter_bf n W' t (i, j) \\<bind> (\\<lambda>_. bf\\<^sub>m' n W' t i j))\n      Mapping.empty)\n  )\"\n\n\\<comment> \\<open>Component tests.\\<close>"], ["", "lemma\n  \"fst (run_state (bf\\<^sub>m' 3 (graph_of (IArray G\\<^sub>1_list)) 3 3 0) Mapping.empty) = 4\"\n  \"bf 3 (graph_of (IArray G\\<^sub>1_list)) 3 3 0 = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (run_state (bf\\<^sub>m' 3 (graph_of (IArray G\\<^sub>1_list)) 3 3 0)\n          Mapping.empty) =\n    4 &&&\n    bf 3 (graph_of (IArray G\\<^sub>1_list)) 3 3 0 = 4", "by eval+\n\n\\<comment> \\<open>Regular test cases.\\<close>"], ["", "lemma\n  \"fst (run_state (bellman_ford 3 (graph_of (IArray G\\<^sub>1_list)) 3) Mapping.empty) = Some [4, 10, 2, 0]\"\n  \"fst (run_state (bellman_ford 4 (graph_of (IArray G\\<^sub>3_list)) 4) Mapping.empty) = Some [4, 5, 3, 1, 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (run_state (bellman_ford 3 (graph_of (IArray G\\<^sub>1_list)) 3)\n          Mapping.empty) =\n    Some [4, 10, 2, 0] &&&\n    fst (run_state (bellman_ford 4 (graph_of (IArray G\\<^sub>3_list)) 4)\n          Mapping.empty) =\n    Some [4, 5, 3, 1, 0]", "by eval+\n\n\\<comment> \\<open>Test detection of negative cycles.\\<close>"], ["", "lemma\n  \"fst (run_state (bellman_ford 3 (graph_of (IArray G\\<^sub>2_list)) 3) Mapping.empty) = None\"\n  \"fst (run_state (bellman_ford 4 (graph_of (IArray G\\<^sub>4_list)) 4) Mapping.empty) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (run_state (bellman_ford 3 (graph_of (IArray G\\<^sub>2_list)) 3)\n          Mapping.empty) =\n    None &&&\n    fst (run_state (bellman_ford 4 (graph_of (IArray G\\<^sub>4_list)) 4)\n          Mapping.empty) =\n    None", "by eval+"], ["", "end"], ["", "(* Theory *)"]]}