{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/heap_monad/Heap_Default.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemmas memoizedI = consistent.memoized", "lemmas successI = consistent.memoized_success", "lemma mem_empty_empty:\n  \"map_of_heap (heap_of (mem_empty idx.size :: 'v option array Heap) Heap.empty) \\<subseteq>\\<^sub>m Map.empty\"\n  if \"mem = result_of (mem_empty idx.size) Heap.empty\"", "lemma memoized_empty:\n  \"dp x = result_of ((mem_empty idx.size :: 'v option array Heap) \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP (dp\\<^sub>T mem)\" \"mem = result_of (mem_empty idx.size) Heap.empty\"", "lemma init_success:\n  \"success ((mem_empty idx.size :: 'v option array Heap) \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP (dp\\<^sub>T mem)\" \"mem = result_of (mem_empty idx.size) Heap.empty\""], "translations": [["", "lemmas memoizedI = consistent.memoized"], ["", "lemmas successI = consistent.memoized_success"], ["", "end"], ["", "lemma mem_empty_empty:\n  \"map_of_heap (heap_of (mem_empty idx.size :: 'v option array Heap) Heap.empty) \\<subseteq>\\<^sub>m Map.empty\"\n  if \"mem = result_of (mem_empty idx.size) Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_heap\n     (heap_of (mem_empty idx.size) Heap.empty) \\<subseteq>\\<^sub>m\n    Map.empty", "by (auto intro!: map_emptyI simp:\n      that length_mem_empty Let_def nth_mem_empty mem_lookup_def heap_mem_defs.map_of_heap_def\n      )"], ["", "lemma memoized_empty:\n  \"dp x = result_of ((mem_empty idx.size :: 'v option array Heap) \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP (dp\\<^sub>T mem)\" \"mem = result_of (mem_empty idx.size) Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp x =\n    result_of (mem_empty idx.size \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x))\n     Heap.empty", "apply (subst execute_bind_success)"], ["proof (prove)\ngoal (2 subgoals):\n 1. success (mem_empty idx.size) Heap.empty\n 2. dp x =\n    result_of (dp\\<^sub>T (result_of (mem_empty idx.size) Heap.empty) x)\n     (heap_of (mem_empty idx.size) Heap.empty)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. dp x =\n    result_of (dp\\<^sub>T (result_of (mem_empty idx.size) Heap.empty) x)\n     (heap_of (mem_empty idx.size) Heap.empty)\n 2. success (mem_empty idx.size) Heap.empty", "apply (subst memoizedI[OF _ _ that(1)])"], ["proof (prove)\ngoal (4 subgoals):\n 1. map_of_heap ?empty1 \\<subseteq>\\<^sub>m Map.empty\n 2. Array.length ?empty1 mem = idx.size\n 3. result_of (dp\\<^sub>T mem x) ?empty1 =\n    result_of (dp\\<^sub>T (result_of (mem_empty idx.size) Heap.empty) x)\n     (heap_of (mem_empty idx.size) Heap.empty)\n 4. success (mem_empty idx.size) Heap.empty", "using mem_empty_empty[OF that(2)]"], ["proof (prove)\nusing this:\n  map_of_heap (heap_of (mem_empty idx.size) Heap.empty) \\<subseteq>\\<^sub>m\n  Map.empty\n\ngoal (4 subgoals):\n 1. map_of_heap ?empty1 \\<subseteq>\\<^sub>m Map.empty\n 2. Array.length ?empty1 mem = idx.size\n 3. result_of (dp\\<^sub>T mem x) ?empty1 =\n    result_of (dp\\<^sub>T (result_of (mem_empty idx.size) Heap.empty) x)\n     (heap_of (mem_empty idx.size) Heap.empty)\n 4. success (mem_empty idx.size) Heap.empty", "by (auto simp: that(2) length_mem_empty)"], ["", "lemma init_success:\n  \"success ((mem_empty idx.size :: 'v option array Heap) \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP (dp\\<^sub>T mem)\" \"mem = result_of (mem_empty idx.size) Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success (mem_empty idx.size \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x))\n     Heap.empty", "apply (rule success_bind_I[OF success_empty])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa h'.\n       execute (mem_empty idx.size) Heap.empty =\n       Some (xa, h') \\<Longrightarrow>\n       success (dp\\<^sub>T xa x) h'", "apply (frule execute_result_ofD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa h'.\n       \\<lbrakk>execute (mem_empty idx.size) Heap.empty = Some (xa, h');\n        result_of (mem_empty idx.size) Heap.empty = xa\\<rbrakk>\n       \\<Longrightarrow> success (dp\\<^sub>T xa x) h'", "apply (drule execute_heap_ofD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa h'.\n       \\<lbrakk>result_of (mem_empty idx.size) Heap.empty = xa;\n        heap_of (mem_empty idx.size) Heap.empty = h'\\<rbrakk>\n       \\<Longrightarrow> success (dp\\<^sub>T xa x) h'", "using mem_empty_empty that"], ["proof (prove)\nusing this:\n  mem = result_of (mem_empty idx.size) Heap.empty \\<Longrightarrow>\n  map_of_heap (heap_of (mem_empty idx.size) Heap.empty) \\<subseteq>\\<^sub>m\n  Map.empty\n  consistentDP (dp\\<^sub>T mem)\n  mem = result_of (mem_empty idx.size) Heap.empty\n\ngoal (1 subgoal):\n 1. \\<And>xa h'.\n       \\<lbrakk>result_of (mem_empty idx.size) Heap.empty = xa;\n        heap_of (mem_empty idx.size) Heap.empty = h'\\<rbrakk>\n       \\<Longrightarrow> success (dp\\<^sub>T xa x) h'", "by (auto simp: length_mem_empty intro: successI)"], ["", "end"], ["", "end"]]}