{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/heap_monad/Heap_Main.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma ifT_cong:\n  assumes \"b = c\" \"c \\<Longrightarrow> x = u\" \"\\<not>c \\<Longrightarrow> y = v\"\n  shows \"Heap_Monad_Ext.if\\<^sub>T \\<langle>b\\<rangle> x y = Heap_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> u v\"", "lemma return_app_return_cong:\n  assumes \"f x = g y\"\n  shows \"\\<langle>f\\<rangle> . \\<langle>x\\<rangle> = \\<langle>g\\<rangle> . \\<langle>y\\<rangle>\"", "lemmas [fundef_cong] =\n  return_app_return_cong\n  ifT_cong", "lemma (in dp_consistency_heap) shows comp\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R1 ===>\\<^sub>T R2) ===>\\<^sub>T (R0 ===>\\<^sub>T R1) ===>\\<^sub>T (R0 ===>\\<^sub>T R2)) comp comp\\<^sub>T\"", "lemma (in dp_consistency_heap) map\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R0 ===>\\<^sub>T R1) ===>\\<^sub>T list_all2 R0 ===>\\<^sub>T list_all2 R1) map map\\<^sub>T\"", "lemma (in dp_consistency_heap) fold\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) ===>\\<^sub>T list_all2 R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) fold fold\\<^sub>T\"", "lemma mapT_cong:\n  assumes \"xs = ys\" \"\\<And>x. x\\<in>set ys \\<Longrightarrow> f x = g x\"\n  shows \"map\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> = map\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>\"", "lemma foldT_cong:\n  assumes \"xs = ys\" \"\\<And>x. x\\<in>set ys \\<Longrightarrow> f x = g x\"\n  shows \"fold\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> = fold\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>\"", "lemma abs_unit_cong:\n  (* for lazy checkmem *)\n  assumes \"x = y\"\n  shows \"(\\<lambda>_::unit. x) = (\\<lambda>_. y)\"", "lemma arg_cong4:\n  \"f a b c d = f a' b' c' d'\" if \"a = a'\" \"b = b'\" \"c = c'\" \"d = d'\"", "lemmas [fundef_cong, cong_rules] =\n  return_app_return_cong\n  ifT_cong\n  mapT_cong\n  foldT_cong\n  abs_unit_cong", "lemmas [cong_rules] =\n  arg_cong4[where f = heap_mem_defs.checkmem]\n  arg_cong2[where f = fun_app_lifted]", "lemma if\\<^sub>T_cong2:\n  assumes \"Rel (=) b c\" \"c \\<Longrightarrow> Rel (crel_vs R) x x\\<^sub>T\" \"\\<not>c \\<Longrightarrow> Rel (crel_vs R) y y\\<^sub>T\"\n  shows \"Rel (crel_vs R) (if (Wrap b) then x else y) (Heap_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> x\\<^sub>T y\\<^sub>T)\"", "lemma map\\<^sub>T_cong2:\n  assumes\n    \"is_equality R\"\n    \"Rel R xs ys\"\n    \"\\<And>x. x\\<in>set ys \\<Longrightarrow> Rel (crel_vs S) (f x) (f\\<^sub>T' x)\"\n  shows \"Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap xs)) (map\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)\"", "lemma fold\\<^sub>T_cong2:\n  assumes\n    \"is_equality R\"\n    \"Rel R xs ys\"\n    \"\\<And>x. x\\<in>set ys \\<Longrightarrow> Rel (crel_vs (S ===> crel_vs S)) (f x) (f\\<^sub>T' x)\"\n  shows\n    \"Rel (crel_vs (S ===> crel_vs S)) (fold f xs) (fold\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)\"", "lemma refl2:\n  \"is_equality R \\<Longrightarrow> Rel R x x\"", "lemma rel_fun2:\n  assumes \"is_equality R0\" \"\\<And>x. Rel R1 (f x) (g x)\"\n  shows \"Rel (rel_fun R0 R1) f g\"", "lemma crel_vs_return_app_return:\n  assumes \"Rel R (f x) (g x)\"\n  shows \"Rel R (App (Wrap f) (Wrap x)) (\\<langle>g\\<rangle> . \\<langle>x\\<rangle>)\"", "lemma option_case_cong':\n\"Rel (=) option' option \\<Longrightarrow>\n(option = None \\<Longrightarrow> Rel R f1 g1) \\<Longrightarrow>\n(\\<And>x2. option = Some x2 \\<Longrightarrow> Rel R (f2 x2) (g2 x2)) \\<Longrightarrow>\nRel R (case option' of None \\<Rightarrow> f1 | Some x2 \\<Rightarrow> f2 x2)\n(case option of None \\<Rightarrow> g1 | Some x2 \\<Rightarrow> g2 x2)\"", "lemma prod_case_cong': fixes prod prod' shows\n\"Rel (=) prod prod' \\<Longrightarrow>\n(\\<And>x1 x2. prod' = (x1, x2) \\<Longrightarrow> Rel R (f x1 x2) (g x1 x2)) \\<Longrightarrow>\nRel R (case prod of (x1, x2) \\<Rightarrow> f x1 x2)\n(case prod' of (x1, x2) \\<Rightarrow> g x1 x2)\"", "lemmas [dp_match_rule] = prod_case_cong' option_case_cong'", "lemmas [dp_match_rule] =\n  crel_vs_return_app_return", "lemmas [dp_match_rule] =\n  map\\<^sub>T_cong2\n  fold\\<^sub>T_cong2\n  if\\<^sub>T_cong2", "lemmas [dp_match_rule] =\n  crel_vs_return\n  crel_vs_fun_app\n  refl2\n  rel_fun2", "lemma execute_heap_ofD:\n  \"heap_of c h = h'\" if \"execute c h = Some (v, h')\"", "lemma execute_result_ofD:\n  \"result_of c h = v\" if \"execute c h = Some (v, h')\"", "lemma memoized_empty:\n  \"dp x = result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP (dp\\<^sub>T (result_of init Heap.empty))\"", "lemma memoized_empty:\n  \"dp x = result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP init_mem (dp\\<^sub>T (result_of init Heap.empty))\"", "lemma memoized_empty:\n  \"dp x = result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP (dp\\<^sub>T (result_of init Heap.empty))\"", "lemma memoized_empty:\n  \"dp x = result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP (dp\\<^sub>T (result_of init Heap.empty))\"", "lemmas [code_unfold] = heap_mem_defs.checkmem_checkmem'[symmetric]", "lemmas [code] =\n  heap_mem_defs.checkmem'_def\n  Heap_Main.map\\<^sub>T_def"], "translations": [["", "lemma ifT_cong:\n  assumes \"b = c\" \"c \\<Longrightarrow> x = u\" \"\\<not>c \\<Longrightarrow> y = v\"\n  shows \"Heap_Monad_Ext.if\\<^sub>T \\<langle>b\\<rangle> x y = Heap_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap_Monad_Ext.if\\<^sub>T \\<langle>b\\<rangle> x y =\n    Heap_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> u v", "unfolding Heap_Monad_Ext.if\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>b\\<rangle> \\<bind> (\\<lambda>b. if b then x else y) =\n    \\<langle>c\\<rangle> \\<bind> (\\<lambda>b. if b then u else v)", "unfolding return_bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then x else y) = (if c then u else v)", "using if_cong[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>c \\<Longrightarrow> c;\n   \\<not> c \\<Longrightarrow> \\<not> c\\<rbrakk>\n  \\<Longrightarrow> (if b then x else y) = (if c then u else v)\n\ngoal (1 subgoal):\n 1. (if b then x else y) = (if c then u else v)", "."], ["", "lemma return_app_return_cong:\n  assumes \"f x = g y\"\n  shows \"\\<langle>f\\<rangle> . \\<langle>x\\<rangle> = \\<langle>g\\<rangle> . \\<langle>y\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>f\\<rangle> . \\<langle>x\\<rangle> =\n    \\<langle>g\\<rangle> . \\<langle>y\\<rangle>", "unfolding Heap_Monad_Ext.return_app_return_meta assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. g y = g y", ".."], ["", "lemmas [fundef_cong] =\n  return_app_return_cong\n  ifT_cong"], ["", "end"], ["", "memoize_fun comp\\<^sub>T: comp"], ["", "monadifies (heap) comp_def"], ["", "thm comp\\<^sub>T'.simps"], ["", "lemma (in dp_consistency_heap) shows comp\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R1 ===>\\<^sub>T R2) ===>\\<^sub>T (R0 ===>\\<^sub>T R1) ===>\\<^sub>T (R0 ===>\\<^sub>T R2)) comp comp\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs\n     ((R1 ===>\\<^sub>T R2) ===>\\<^sub>T\n      (R0 ===>\\<^sub>T R1) ===>\\<^sub>T R0 ===>\\<^sub>T R2)\n     (\\<circ>) comp\\<^sub>T", "apply memoize_combinator_init"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x uu_ xa uua_.\n       \\<lbrakk>(R1 ===>\\<^sub>T R2) x uu_;\n        (R0 ===>\\<^sub>T R1) xa uua_\\<rbrakk>\n       \\<Longrightarrow> crel_vs (R0 ===>\\<^sub>T R2) (x \\<circ> xa)\n                          (comp\\<^sub>T' uu_ uua_)", "subgoal premises IH [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (R0 ===>\\<^sub>T R2) (x_ \\<circ> xa_) (comp\\<^sub>T' uu_ uua_)", "by memoize_unfold_defs transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "memoize_fun map\\<^sub>T: map"], ["", "monadifies (heap) list.map"], ["", "lemma (in dp_consistency_heap) map\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R0 ===>\\<^sub>T R1) ===>\\<^sub>T list_all2 R0 ===>\\<^sub>T list_all2 R1) map map\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs\n     ((R0 ===>\\<^sub>T R1) ===>\\<^sub>T\n      list_all2 R0 ===>\\<^sub>T list_all2 R1)\n     map map\\<^sub>T", "apply memoize_combinator_init"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x uu_ xa uua_.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1) x uu_; list_all2 R0 xa uua_\\<rbrakk>\n       \\<Longrightarrow> crel_vs (list_all2 R1) (map x xa)\n                          (map\\<^sub>T' uu_ uua_)", "apply (erule list_all2_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x uu_ xa _.\n       (R0 ===>\\<^sub>T R1) x uu_ \\<Longrightarrow>\n       crel_vs (list_all2 R1) (map x []) (map\\<^sub>T' uu_ [])\n 2. \\<And>x uu_ xa _ xb xs y ys.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1) x uu_; R0 xb y; list_all2 R0 xs ys;\n        crel_vs (list_all2 R1) (map x xs) (map\\<^sub>T' uu_ ys)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (list_all2 R1) (map x (xb # xs))\n                          (map\\<^sub>T' uu_ (y # ys))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 R1) (map x_ []) (map\\<^sub>T' uu_ [])", "by memoize_unfold_defs transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x uu_ xa _ xb xs y ys.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1) x uu_; R0 xb y; list_all2 R0 xs ys;\n        crel_vs (list_all2 R1) (map x xs) (map\\<^sub>T' uu_ ys)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (list_all2 R1) (map x (xb # xs))\n                          (map\\<^sub>T' uu_ (y # ys))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 R1) (map x_ (xb_ # xs_))\n     (map\\<^sub>T' uu_ (y_ # ys_))", "by memoize_unfold_defs transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "memoize_fun fold\\<^sub>T: fold"], ["", "monadifies (heap) fold.simps"], ["", "lemma (in dp_consistency_heap) fold\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) ===>\\<^sub>T list_all2 R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) fold fold\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs\n     ((R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) ===>\\<^sub>T\n      list_all2 R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1)\n     fold fold\\<^sub>T", "apply memoize_combinator_init"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x uu_ xa uua_.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) x uu_;\n        list_all2 R0 xa uua_\\<rbrakk>\n       \\<Longrightarrow> crel_vs (R1 ===>\\<^sub>T R1) (fold x xa)\n                          (fold\\<^sub>T' uu_ uua_)", "apply (erule list_all2_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x uu_ xa _.\n       (R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) x uu_ \\<Longrightarrow>\n       crel_vs (R1 ===>\\<^sub>T R1) (fold x []) (fold\\<^sub>T' uu_ [])\n 2. \\<And>x uu_ xa _ xb xs y ys.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) x uu_; R0 xb y;\n        list_all2 R0 xs ys;\n        crel_vs (R1 ===>\\<^sub>T R1) (fold x xs)\n         (fold\\<^sub>T' uu_ ys)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (R1 ===>\\<^sub>T R1) (fold x (xb # xs))\n                          (fold\\<^sub>T' uu_ (y # ys))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (R1 ===>\\<^sub>T R1) (fold x_ []) (fold\\<^sub>T' uu_ [])", "by memoize_unfold_defs transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x uu_ xa _ xb xs y ys.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) x uu_; R0 xb y;\n        list_all2 R0 xs ys;\n        crel_vs (R1 ===>\\<^sub>T R1) (fold x xs)\n         (fold\\<^sub>T' uu_ ys)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (R1 ===>\\<^sub>T R1) (fold x (xb # xs))\n                          (fold\\<^sub>T' uu_ (y # ys))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (R1 ===>\\<^sub>T R1) (fold x_ (xb_ # xs_))\n     (fold\\<^sub>T' uu_ (y_ # ys_))", "by memoize_unfold_defs transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context includes heap_monad_syntax begin"], ["", "thm map_cong"], ["", "lemma mapT_cong:\n  assumes \"xs = ys\" \"\\<And>x. x\\<in>set ys \\<Longrightarrow> f x = g x\"\n  shows \"map\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> = map\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> =\n    map\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>", "unfolding map\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>xs\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "unfolding assms(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>ys\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "using assms(2)"], ["proof (prove)\nusing this:\n  ?x \\<in> set ys \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>ys\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "by (induction ys) (auto simp: Heap_Monad_Ext.return_app_return_meta)"], ["", "thm fold_cong"], ["", "lemma foldT_cong:\n  assumes \"xs = ys\" \"\\<And>x. x\\<in>set ys \\<Longrightarrow> f x = g x\"\n  shows \"fold\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> = fold\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> =\n    fold\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>", "unfolding fold\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>xs\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "unfolding assms(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>ys\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "using assms(2)"], ["proof (prove)\nusing this:\n  ?x \\<in> set ys \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>ys\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "by (induction ys) (auto simp: Heap_Monad_Ext.return_app_return_meta)"], ["", "lemma abs_unit_cong:\n  (* for lazy checkmem *)\n  assumes \"x = y\"\n  shows \"(\\<lambda>_::unit. x) = (\\<lambda>_. y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. x) = (\\<lambda>_. y)", "using assms"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. (\\<lambda>_. x) = (\\<lambda>_. y)", ".."], ["", "lemma arg_cong4:\n  \"f a b c d = f a' b' c' d'\" if \"a = a'\" \"b = b'\" \"c = c'\" \"d = d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a b c d = f a' b' c' d'", "by (simp add: that)"], ["", "lemmas [fundef_cong, cong_rules] =\n  return_app_return_cong\n  ifT_cong\n  mapT_cong\n  foldT_cong\n  abs_unit_cong"], ["", "lemmas [cong_rules] =\n  arg_cong4[where f = heap_mem_defs.checkmem]\n  arg_cong2[where f = fun_app_lifted]"], ["", "end"], ["", "context dp_consistency_heap begin"], ["", "context includes lifting_syntax heap_monad_syntax begin"], ["", "named_theorems dp_match_rule"], ["", "thm if_cong"], ["", "lemma if\\<^sub>T_cong2:\n  assumes \"Rel (=) b c\" \"c \\<Longrightarrow> Rel (crel_vs R) x x\\<^sub>T\" \"\\<not>c \\<Longrightarrow> Rel (crel_vs R) y y\\<^sub>T\"\n  shows \"Rel (crel_vs R) (if (Wrap b) then x else y) (Heap_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> x\\<^sub>T y\\<^sub>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs R) (if Wrap b then x else y)\n     (Heap_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> x\\<^sub>T y\\<^sub>T)", "using assms"], ["proof (prove)\nusing this:\n  Rel (=) b c\n  c \\<Longrightarrow> Rel (crel_vs R) x x\\<^sub>T\n  \\<not> c \\<Longrightarrow> Rel (crel_vs R) y y\\<^sub>T\n\ngoal (1 subgoal):\n 1. Rel (crel_vs R) (if Wrap b then x else y)\n     (Heap_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> x\\<^sub>T y\\<^sub>T)", "unfolding Heap_Monad_Ext.if\\<^sub>T_def bind_left_identity Rel_def Wrap_def"], ["proof (prove)\nusing this:\n  b = c\n  c \\<Longrightarrow> crel_vs R x x\\<^sub>T\n  \\<not> c \\<Longrightarrow> crel_vs R y y\\<^sub>T\n\ngoal (1 subgoal):\n 1. crel_vs R (if b then x else y)\n     (\\<langle>c\\<rangle> \\<bind>\n      (\\<lambda>b. if b then x\\<^sub>T else y\\<^sub>T))", "by (auto split: if_split)"], ["", "lemma map\\<^sub>T_cong2:\n  assumes\n    \"is_equality R\"\n    \"Rel R xs ys\"\n    \"\\<And>x. x\\<in>set ys \\<Longrightarrow> Rel (crel_vs S) (f x) (f\\<^sub>T' x)\"\n  shows \"Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap xs)) (map\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap xs))\n     (map\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)", "unfolding map\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap xs))\n     (\\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n      \\<langle>f\\<^sub>T'\\<rangle> .\n      \\<langle>ys\\<rangle>)", "unfolding Heap_Monad_Ext.return_app_return_meta"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap xs))\n     (map\\<^sub>T' f\\<^sub>T' ys)", "unfolding assms(2)[unfolded Rel_def assms(1)[unfolded is_equality_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap ys))\n     (map\\<^sub>T' f\\<^sub>T' ys)", "using assms(3)"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set ys \\<Longrightarrow>\n  Rel (crel_vs S) (f ?x1) (f\\<^sub>T' ?x1)\n\ngoal (1 subgoal):\n 1. Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap ys))\n     (map\\<^sub>T' f\\<^sub>T' ys)", "unfolding Rel_def Wrap_def App_def"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set ys \\<Longrightarrow> crel_vs S (f ?x1) (f\\<^sub>T' ?x1)\n\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S) (map f ys) (map\\<^sub>T' f\\<^sub>T' ys)", "apply (induction ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        crel_vs S (f x) (f\\<^sub>T' x)) \\<Longrightarrow>\n    crel_vs (list_all2 S) (map f []) (map\\<^sub>T' f\\<^sub>T' [])\n 2. \\<And>a ys.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ys \\<Longrightarrow>\n                    crel_vs S (f x) (f\\<^sub>T' x)) \\<Longrightarrow>\n                crel_vs (list_all2 S) (map f ys)\n                 (map\\<^sub>T' f\\<^sub>T' ys);\n        \\<And>x.\n           x \\<in> set (a # ys) \\<Longrightarrow>\n           crel_vs S (f x) (f\\<^sub>T' x)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (list_all2 S) (map f (a # ys))\n                          (map\\<^sub>T' f\\<^sub>T' (a # ys))", "subgoal premises"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S) (map f []) (map\\<^sub>T' f\\<^sub>T' [])", "by (memoize_unfold_defs (heap) map) transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ys \\<Longrightarrow>\n                    crel_vs S (f x) (f\\<^sub>T' x)) \\<Longrightarrow>\n                crel_vs (list_all2 S) (map f ys)\n                 (map\\<^sub>T' f\\<^sub>T' ys);\n        \\<And>x.\n           x \\<in> set (a # ys) \\<Longrightarrow>\n           crel_vs S (f x) (f\\<^sub>T' x)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (list_all2 S) (map f (a # ys))\n                          (map\\<^sub>T' f\\<^sub>T' (a # ys))", "subgoal premises prems for a ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S) (map f (a # ys))\n     (map\\<^sub>T' f\\<^sub>T' (a # ys))", "apply (memoize_unfold_defs (heap) map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S)\n     (App (App (Wrap (\\<lambda>x. Wrap (\\<lambda>xa. Wrap (x # xa))))\n            (App (Wrap f) (Wrap a)))\n       (map f ys))\n     (\\<langle>\\<lambda>a.\n                  \\<langle>\\<lambda>b.\n                              \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n      (\\<langle>f\\<^sub>T'\\<rangle> . \\<langle>a\\<rangle>) .\n      (map\\<^sub>T' f\\<^sub>T' ys))", "apply (unfold Heap_Monad_Ext.return_app_return_meta Wrap_App_Wrap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S)\n     (App (App (Wrap (\\<lambda>x. Wrap (\\<lambda>xa. Wrap (x # xa)))) (f a))\n       (map f ys))\n     (\\<langle>\\<lambda>a.\n                  \\<langle>\\<lambda>b.\n                              \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n      (f\\<^sub>T' a) .\n      (map\\<^sub>T' f\\<^sub>T' ys))", "supply [transfer_rule] =\n      prems(2)[OF list.set_intros(1)]\n      prems(1)[OF prems(2)[OF list.set_intros(2)], simplified]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S)\n     (App (App (Wrap (\\<lambda>x. Wrap (\\<lambda>xa. Wrap (x # xa)))) (f a))\n       (map f ys))\n     (\\<langle>\\<lambda>a.\n                  \\<langle>\\<lambda>b.\n                              \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n      (f\\<^sub>T' a) .\n      (map\\<^sub>T' f\\<^sub>T' ys))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fold\\<^sub>T_cong2:\n  assumes\n    \"is_equality R\"\n    \"Rel R xs ys\"\n    \"\\<And>x. x\\<in>set ys \\<Longrightarrow> Rel (crel_vs (S ===> crel_vs S)) (f x) (f\\<^sub>T' x)\"\n  shows\n    \"Rel (crel_vs (S ===> crel_vs S)) (fold f xs) (fold\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (S ===>\\<^sub>T S)) (fold f xs)\n     (fold\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)", "unfolding fold\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (S ===>\\<^sub>T S)) (fold f xs)\n     (\\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n      \\<langle>f\\<^sub>T'\\<rangle> .\n      \\<langle>ys\\<rangle>)", "unfolding Heap_Monad_Ext.return_app_return_meta"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (S ===>\\<^sub>T S)) (fold f xs)\n     (fold\\<^sub>T' f\\<^sub>T' ys)", "unfolding assms(2)[unfolded Rel_def assms(1)[unfolded is_equality_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (S ===>\\<^sub>T S)) (fold f ys)\n     (fold\\<^sub>T' f\\<^sub>T' ys)", "using assms(3)"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set ys \\<Longrightarrow>\n  Rel (crel_vs (S ===>\\<^sub>T S)) (f ?x1) (f\\<^sub>T' ?x1)\n\ngoal (1 subgoal):\n 1. Rel (crel_vs (S ===>\\<^sub>T S)) (fold f ys)\n     (fold\\<^sub>T' f\\<^sub>T' ys)", "unfolding Rel_def"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set ys \\<Longrightarrow>\n  crel_vs (S ===>\\<^sub>T S) (f ?x1) (f\\<^sub>T' ?x1)\n\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S) (fold f ys) (fold\\<^sub>T' f\\<^sub>T' ys)", "apply (induction ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        crel_vs (S ===>\\<^sub>T S) (f x) (f\\<^sub>T' x)) \\<Longrightarrow>\n    crel_vs (S ===>\\<^sub>T S) (fold f []) (fold\\<^sub>T' f\\<^sub>T' [])\n 2. \\<And>a ys.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ys \\<Longrightarrow>\n                    crel_vs (S ===>\\<^sub>T S) (f x)\n                     (f\\<^sub>T' x)) \\<Longrightarrow>\n                crel_vs (S ===>\\<^sub>T S) (fold f ys)\n                 (fold\\<^sub>T' f\\<^sub>T' ys);\n        \\<And>x.\n           x \\<in> set (a # ys) \\<Longrightarrow>\n           crel_vs (S ===>\\<^sub>T S) (f x) (f\\<^sub>T' x)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (S ===>\\<^sub>T S) (fold f (a # ys))\n                          (fold\\<^sub>T' f\\<^sub>T' (a # ys))", "subgoal premises"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S) (fold f []) (fold\\<^sub>T' f\\<^sub>T' [])", "by (memoize_unfold_defs (heap) fold) transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ys \\<Longrightarrow>\n                    crel_vs (S ===>\\<^sub>T S) (f x)\n                     (f\\<^sub>T' x)) \\<Longrightarrow>\n                crel_vs (S ===>\\<^sub>T S) (fold f ys)\n                 (fold\\<^sub>T' f\\<^sub>T' ys);\n        \\<And>x.\n           x \\<in> set (a # ys) \\<Longrightarrow>\n           crel_vs (S ===>\\<^sub>T S) (f x) (f\\<^sub>T' x)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (S ===>\\<^sub>T S) (fold f (a # ys))\n                          (fold\\<^sub>T' f\\<^sub>T' (a # ys))", "subgoal premises prems for a ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S) (fold f (a # ys))\n     (fold\\<^sub>T' f\\<^sub>T' (a # ys))", "apply (memoize_unfold_defs (heap) fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S)\n     (App (App (\\<circ>) (fold f ys)) (App (Wrap f) (Wrap a)))\n     (comp\\<^sub>T . (fold\\<^sub>T' f\\<^sub>T' ys) .\n      (\\<langle>f\\<^sub>T'\\<rangle> . \\<langle>a\\<rangle>))", "apply (unfold Heap_Monad_Ext.return_app_return_meta Wrap_App_Wrap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S) (App (App (\\<circ>) (fold f ys)) (f a))\n     (comp\\<^sub>T . (fold\\<^sub>T' f\\<^sub>T' ys) . (f\\<^sub>T' a))", "supply [transfer_rule] =\n      prems(2)[OF list.set_intros(1)]\n      prems(1)[OF prems(2)[OF list.set_intros(2)], simplified]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S) (App (App (\\<circ>) (fold f ys)) (f a))\n     (comp\\<^sub>T . (fold\\<^sub>T' f\\<^sub>T' ys) . (f\\<^sub>T' a))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma refl2:\n  \"is_equality R \\<Longrightarrow> Rel R x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_equality R \\<Longrightarrow> Rel R x x", "unfolding is_equality_def Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. R = (=) \\<Longrightarrow> R x x", "by simp"], ["", "lemma rel_fun2:\n  assumes \"is_equality R0\" \"\\<And>x. Rel R1 (f x) (g x)\"\n  shows \"Rel (rel_fun R0 R1) f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (R0 ===> R1) f g", "using assms"], ["proof (prove)\nusing this:\n  is_equality R0\n  Rel R1 (f ?x1) (g ?x1)\n\ngoal (1 subgoal):\n 1. Rel (R0 ===> R1) f g", "unfolding is_equality_def Rel_def"], ["proof (prove)\nusing this:\n  R0 = (=)\n  R1 (f ?x1) (g ?x1)\n\ngoal (1 subgoal):\n 1. (R0 ===> R1) f g", "by auto"], ["", "lemma crel_vs_return_app_return:\n  assumes \"Rel R (f x) (g x)\"\n  shows \"Rel R (App (Wrap f) (Wrap x)) (\\<langle>g\\<rangle> . \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel R (App (Wrap f) (Wrap x))\n     (\\<langle>g\\<rangle> . \\<langle>x\\<rangle>)", "using assms"], ["proof (prove)\nusing this:\n  Rel R (f x) (g x)\n\ngoal (1 subgoal):\n 1. Rel R (App (Wrap f) (Wrap x))\n     (\\<langle>g\\<rangle> . \\<langle>x\\<rangle>)", "unfolding Heap_Monad_Ext.return_app_return_meta Wrap_App_Wrap"], ["proof (prove)\nusing this:\n  Rel R (f x) (g x)\n\ngoal (1 subgoal):\n 1. Rel R (f x) (g x)", "."], ["", "thm option.case_cong[no_vars]"], ["", "lemma option_case_cong':\n\"Rel (=) option' option \\<Longrightarrow>\n(option = None \\<Longrightarrow> Rel R f1 g1) \\<Longrightarrow>\n(\\<And>x2. option = Some x2 \\<Longrightarrow> Rel R (f2 x2) (g2 x2)) \\<Longrightarrow>\nRel R (case option' of None \\<Rightarrow> f1 | Some x2 \\<Rightarrow> f2 x2)\n(case option of None \\<Rightarrow> g1 | Some x2 \\<Rightarrow> g2 x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rel (=) option' option;\n     option = None \\<Longrightarrow> Rel R f1 g1;\n     \\<And>x2.\n        option = Some x2 \\<Longrightarrow> Rel R (f2 x2) (g2 x2)\\<rbrakk>\n    \\<Longrightarrow> Rel R\n                       (case option' of None \\<Rightarrow> f1\n                        | Some x2 \\<Rightarrow> f2 x2)\n                       (case option of None \\<Rightarrow> g1\n                        | Some x2 \\<Rightarrow> g2 x2)", "unfolding Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>option' = option; option = None \\<Longrightarrow> R f1 g1;\n     \\<And>x2. option = Some x2 \\<Longrightarrow> R (f2 x2) (g2 x2)\\<rbrakk>\n    \\<Longrightarrow> R (case option' of None \\<Rightarrow> f1\n                         | Some x2 \\<Rightarrow> f2 x2)\n                       (case option of None \\<Rightarrow> g1\n                        | Some x2 \\<Rightarrow> g2 x2)", "by (auto split: option.split)"], ["", "thm prod.case_cong[no_vars]"], ["", "lemma prod_case_cong': fixes prod prod' shows\n\"Rel (=) prod prod' \\<Longrightarrow>\n(\\<And>x1 x2. prod' = (x1, x2) \\<Longrightarrow> Rel R (f x1 x2) (g x1 x2)) \\<Longrightarrow>\nRel R (case prod of (x1, x2) \\<Rightarrow> f x1 x2)\n(case prod' of (x1, x2) \\<Rightarrow> g x1 x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rel (=) prod prod';\n     \\<And>x1 x2.\n        prod' = (x1, x2) \\<Longrightarrow>\n        Rel R (f x1 x2) (g x1 x2)\\<rbrakk>\n    \\<Longrightarrow> Rel R (case prod of (x1, x2) \\<Rightarrow> f x1 x2)\n                       (case prod' of (x1, x2) \\<Rightarrow> g x1 x2)", "unfolding Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prod = prod';\n     \\<And>x1 x2.\n        prod' = (x1, x2) \\<Longrightarrow> R (f x1 x2) (g x1 x2)\\<rbrakk>\n    \\<Longrightarrow> R (case prod of (x1, x2) \\<Rightarrow> f x1 x2)\n                       (case prod' of (x1, x2) \\<Rightarrow> g x1 x2)", "by (auto split: prod.splits)"], ["", "lemmas [dp_match_rule] = prod_case_cong' option_case_cong'"], ["", "lemmas [dp_match_rule] =\n  crel_vs_return_app_return"], ["", "lemmas [dp_match_rule] =\n  map\\<^sub>T_cong2\n  fold\\<^sub>T_cong2\n  if\\<^sub>T_cong2"], ["", "lemmas [dp_match_rule] =\n  crel_vs_return\n  crel_vs_fun_app\n  refl2\n  rel_fun2"], ["", "(*\nlemmas [dp_match_rule] =\n  crel_vs_checkmem_tupled\n*)"], ["", "end"], ["", "(* context lifting_syntax *)"], ["", "end"], ["", "(* context dp_consistency *)"], ["", "subsubsection \\<open>More Heap\\<close>"], ["", "lemma execute_heap_ofD:\n  \"heap_of c h = h'\" if \"execute c h = Some (v, h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_of c h = h'", "using that"], ["proof (prove)\nusing this:\n  execute c h = Some (v, h')\n\ngoal (1 subgoal):\n 1. heap_of c h = h'", "by auto"], ["", "lemma execute_result_ofD:\n  \"result_of c h = v\" if \"execute c h = Some (v, h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result_of c h = v", "using that"], ["proof (prove)\nusing this:\n  execute c h = Some (v, h')\n\ngoal (1 subgoal):\n 1. result_of c h = v", "by auto"], ["", "locale heap_correct_init_defs =\n  fixes P :: \"'m \\<Rightarrow> heap \\<Rightarrow> bool\"\n    and lookup :: \"'m \\<Rightarrow> 'k \\<Rightarrow> 'v option Heap\"\n    and update :: \"'m \\<Rightarrow> 'k \\<Rightarrow> 'v \\<Rightarrow> unit Heap\"\nbegin"], ["", "definition map_of_heap' where\n  \"map_of_heap' m heap k = fst (the (execute (lookup m k) heap))\""], ["", "end"], ["", "locale heap_correct_init_inv = heap_correct_init_defs +\n  assumes lookup_inv: \"\\<And> m. lift_p (P m) (lookup m k)\"\n  assumes update_inv: \"\\<And> m. lift_p (P m) (update m k v)\""], ["", "locale heap_correct_init =\n  heap_correct_init_inv +\n  assumes lookup_correct:\n      \"\\<And> a. P a m \\<Longrightarrow> map_of_heap' a (snd (the (execute (lookup a k) m))) \\<subseteq>\\<^sub>m (map_of_heap' a m)\"\n  and update_correct:\n      \"\\<And> a. P a m \\<Longrightarrow>\n        map_of_heap' a (snd (the (execute (update a k v) m))) \\<subseteq>\\<^sub>m (map_of_heap' a m)(k \\<mapsto> v)\"\nbegin"], ["", "end"], ["", "locale dp_consistency_heap_init = heap_correct_init _ lookup for lookup :: \"'m \\<Rightarrow> 'k \\<Rightarrow> 'v option Heap\"  +\n  fixes dp :: \"'k \\<Rightarrow> 'v\"\n  fixes init :: \"'m Heap\"\n  assumes success: \"success init Heap.empty\"\n  assumes empty_correct:\n    \"\\<And> empty heap. execute init Heap.empty = Some (empty, heap) \\<Longrightarrow> map_of_heap' empty heap \\<subseteq>\\<^sub>m Map.empty\"\n    and P_empty: \"\\<And> empty heap. execute init Heap.empty = Some (empty, heap) \\<Longrightarrow> P empty heap\"\nbegin"], ["", "definition \"init_mem = result_of init Heap.empty\""], ["", "sublocale dp_consistency_heap\n  where P=\"P init_mem\"\n    and lookup=\"lookup init_mem\"\n    and update=\"update init_mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap (P init_mem) (update init_mem) (lookup init_mem)", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k. State_Heap.lift_p (P init_mem) (lookup init_mem k)\n 2. \\<And>k v. State_Heap.lift_p (P init_mem) (update init_mem k v)\n 3. \\<And>m k.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (lookup init_mem k) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m\n 4. \\<And>m k v.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (update init_mem k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m(k \\<mapsto> v)", "apply (rule lookup_inv[of init_mem])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k v. State_Heap.lift_p (P init_mem) (update init_mem k v)\n 2. \\<And>m k.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (lookup init_mem k) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m\n 3. \\<And>m k v.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (update init_mem k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m(k \\<mapsto> v)", "apply (rule update_inv[of init_mem])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (lookup init_mem k) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m\n 2. \\<And>m k v.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (update init_mem k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m(k \\<mapsto> v)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem m_ \\<Longrightarrow>\n    heap_mem_defs.map_of_heap (lookup init_mem)\n     (heap_of (lookup init_mem k_) m_) \\<subseteq>\\<^sub>m\n    heap_mem_defs.map_of_heap (lookup init_mem) m_", "unfolding heap_mem_defs.map_of_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem m_ \\<Longrightarrow>\n    (\\<lambda>ka.\n        result_of (lookup init_mem ka)\n         (heap_of (lookup init_mem k_) m_)) \\<subseteq>\\<^sub>m\n    (\\<lambda>k. result_of (lookup init_mem k) m_)", "by (rule lookup_correct[of init_mem, unfolded map_of_heap'_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (update init_mem k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m(k \\<mapsto> v)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem m_ \\<Longrightarrow>\n    heap_mem_defs.map_of_heap (lookup init_mem)\n     (heap_of (update init_mem k_ v_) m_) \\<subseteq>\\<^sub>m\n    heap_mem_defs.map_of_heap (lookup init_mem) m_(k_ \\<mapsto> v_)", "unfolding heap_mem_defs.map_of_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem m_ \\<Longrightarrow>\n    (\\<lambda>ka.\n        result_of (lookup init_mem ka)\n         (heap_of (update init_mem k_ v_) m_)) \\<subseteq>\\<^sub>m\n    (\\<lambda>k. result_of (lookup init_mem k) m_)(k_ \\<mapsto> v_)", "by (rule update_correct[of init_mem, unfolded map_of_heap'_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation consistent: dp_consistency_heap_empty\n  where P=\"P init_mem\"\n    and lookup=\"lookup init_mem\"\n    and update=\"update init_mem\"\n    and empty= \"heap_of init Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_empty (P init_mem) (update init_mem)\n     (lookup init_mem) (heap_of init Heap.empty)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_of_heap (heap_of init Heap.empty) \\<subseteq>\\<^sub>m Map.empty\n 2. P init_mem (heap_of init Heap.empty)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_heap (heap_of init Heap.empty) \\<subseteq>\\<^sub>m Map.empty", "apply (rule successE[OF success])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       execute init Heap.empty = Some (r, h') \\<Longrightarrow>\n       map_of_heap (heap_of init Heap.empty) \\<subseteq>\\<^sub>m Map.empty", "apply (frule empty_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       \\<lbrakk>execute init Heap.empty = Some (r, h');\n        map_of_heap' r h' \\<subseteq>\\<^sub>m Map.empty\\<rbrakk>\n       \\<Longrightarrow> map_of_heap\n                          (heap_of init Heap.empty) \\<subseteq>\\<^sub>m\n                         Map.empty", "unfolding heap_mem_defs.map_of_heap_def init_mem_def map_of_heap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       \\<lbrakk>execute init Heap.empty = Some (r, h');\n        (\\<lambda>k. result_of (lookup r k) h') \\<subseteq>\\<^sub>m\n        Map.empty\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>k.\n                             result_of\n                              (lookup (result_of init Heap.empty) k)\n                              (heap_of init Heap.empty)) \\<subseteq>\\<^sub>m\n                         Map.empty", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem (heap_of init Heap.empty)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem (heap_of init Heap.empty)", "apply (rule successE[OF success])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       execute init Heap.empty = Some (r, h') \\<Longrightarrow>\n       P init_mem (heap_of init Heap.empty)", "apply (frule P_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       \\<lbrakk>execute init Heap.empty = Some (r, h'); P r h'\\<rbrakk>\n       \\<Longrightarrow> P init_mem (heap_of init Heap.empty)", "unfolding init_mem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       \\<lbrakk>execute init Heap.empty = Some (r, h'); P r h'\\<rbrakk>\n       \\<Longrightarrow> P (result_of init Heap.empty)\n                          (heap_of init Heap.empty)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma memoized_empty:\n  \"dp x = result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP (dp\\<^sub>T (result_of init Heap.empty))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp x =\n    result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty", "by (simp add: execute_bind_success consistent.memoized[OF that(1)] success)"], ["", "end"], ["", "locale dp_consistency_heap_init' = heap_correct_init _ lookup for lookup :: \"'m \\<Rightarrow> 'k \\<Rightarrow> 'v option Heap\"  +\n  fixes dp :: \"'k \\<Rightarrow> 'v\"\n  fixes init :: \"'m Heap\"\n  assumes success: \"success init Heap.empty\"\n  assumes empty_correct:\n    \"\\<And> empty heap. execute init Heap.empty = Some (empty, heap) \\<Longrightarrow> map_of_heap' empty heap \\<subseteq>\\<^sub>m Map.empty\"\n    and P_empty: \"\\<And> empty heap. execute init Heap.empty = Some (empty, heap) \\<Longrightarrow> P empty heap\"\nbegin"], ["", "sublocale dp_consistency_heap\n  where P=\"P init_mem\"\n    and lookup=\"lookup init_mem\"\n    and update=\"update init_mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap (P init_mem) (update init_mem) (lookup init_mem)", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k. State_Heap.lift_p (P init_mem) (lookup init_mem k)\n 2. \\<And>k v. State_Heap.lift_p (P init_mem) (update init_mem k v)\n 3. \\<And>m k.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (lookup init_mem k) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m\n 4. \\<And>m k v.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (update init_mem k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m(k \\<mapsto> v)", "apply (rule lookup_inv[of init_mem])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k v. State_Heap.lift_p (P init_mem) (update init_mem k v)\n 2. \\<And>m k.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (lookup init_mem k) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m\n 3. \\<And>m k v.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (update init_mem k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m(k \\<mapsto> v)", "apply (rule update_inv[of init_mem])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (lookup init_mem k) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m\n 2. \\<And>m k v.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (update init_mem k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m(k \\<mapsto> v)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem m_ \\<Longrightarrow>\n    heap_mem_defs.map_of_heap (lookup init_mem)\n     (heap_of (lookup init_mem k_) m_) \\<subseteq>\\<^sub>m\n    heap_mem_defs.map_of_heap (lookup init_mem) m_", "unfolding heap_mem_defs.map_of_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem m_ \\<Longrightarrow>\n    (\\<lambda>ka.\n        result_of (lookup init_mem ka)\n         (heap_of (lookup init_mem k_) m_)) \\<subseteq>\\<^sub>m\n    (\\<lambda>k. result_of (lookup init_mem k) m_)", "by (rule lookup_correct[of init_mem, unfolded map_of_heap'_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       P init_mem m \\<Longrightarrow>\n       heap_mem_defs.map_of_heap (lookup init_mem)\n        (heap_of (update init_mem k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap (lookup init_mem) m(k \\<mapsto> v)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem m_ \\<Longrightarrow>\n    heap_mem_defs.map_of_heap (lookup init_mem)\n     (heap_of (update init_mem k_ v_) m_) \\<subseteq>\\<^sub>m\n    heap_mem_defs.map_of_heap (lookup init_mem) m_(k_ \\<mapsto> v_)", "unfolding heap_mem_defs.map_of_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem m_ \\<Longrightarrow>\n    (\\<lambda>ka.\n        result_of (lookup init_mem ka)\n         (heap_of (update init_mem k_ v_) m_)) \\<subseteq>\\<^sub>m\n    (\\<lambda>k. result_of (lookup init_mem k) m_)(k_ \\<mapsto> v_)", "by (rule update_correct[of init_mem, unfolded map_of_heap'_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"init_mem = result_of init Heap.empty\""], ["", "interpretation consistent: dp_consistency_heap_empty\n  where P=\"P init_mem\"\n    and lookup=\"lookup init_mem\"\n    and update=\"update init_mem\"\n    and empty= \"heap_of init Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_empty (P init_mem) (update init_mem)\n     (lookup init_mem) (heap_of init Heap.empty)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_of_heap init_mem (heap_of init Heap.empty) \\<subseteq>\\<^sub>m\n    Map.empty\n 2. P init_mem (heap_of init Heap.empty)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_heap init_mem (heap_of init Heap.empty) \\<subseteq>\\<^sub>m\n    Map.empty", "apply (rule successE[OF success])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       execute init Heap.empty = Some (r, h') \\<Longrightarrow>\n       map_of_heap init_mem (heap_of init Heap.empty) \\<subseteq>\\<^sub>m\n       Map.empty", "apply (frule empty_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       \\<lbrakk>execute init Heap.empty = Some (r, h');\n        map_of_heap' r h' \\<subseteq>\\<^sub>m Map.empty\\<rbrakk>\n       \\<Longrightarrow> map_of_heap init_mem\n                          (heap_of init Heap.empty) \\<subseteq>\\<^sub>m\n                         Map.empty", "unfolding heap_mem_defs.map_of_heap_def init_mem_def map_of_heap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       \\<lbrakk>execute init Heap.empty = Some (r, h');\n        (\\<lambda>k. result_of (lookup r k) h') \\<subseteq>\\<^sub>m\n        Map.empty\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>k.\n                             result_of\n                              (lookup (result_of init Heap.empty) k)\n                              (heap_of init Heap.empty)) \\<subseteq>\\<^sub>m\n                         Map.empty", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem (heap_of init Heap.empty)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. P init_mem (heap_of init Heap.empty)", "apply (rule successE[OF success])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       execute init Heap.empty = Some (r, h') \\<Longrightarrow>\n       P init_mem (heap_of init Heap.empty)", "apply (frule P_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       \\<lbrakk>execute init Heap.empty = Some (r, h'); P r h'\\<rbrakk>\n       \\<Longrightarrow> P init_mem (heap_of init Heap.empty)", "unfolding init_mem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r h'.\n       \\<lbrakk>execute init Heap.empty = Some (r, h'); P r h'\\<rbrakk>\n       \\<Longrightarrow> P (result_of init Heap.empty)\n                          (heap_of init Heap.empty)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma memoized_empty:\n  \"dp x = result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP init_mem (dp\\<^sub>T (result_of init Heap.empty))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp x =\n    result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty", "by (simp add: execute_bind_success consistent.memoized[OF that(1)] success)"], ["", "end"], ["", "locale dp_consistency_new =\n  fixes dp :: \"'k \\<Rightarrow> 'v\"\n  fixes P :: \"'m \\<Rightarrow> heap \\<Rightarrow> bool\"\n    and lookup :: \"'m \\<Rightarrow> 'k \\<Rightarrow> 'v option Heap\"\n    and update :: \"'m \\<Rightarrow> 'k \\<Rightarrow> 'v \\<Rightarrow> unit Heap\"\n    and init\n  assumes\n    success: \"success init Heap.empty\"\n  assumes\n    inv_init: \"\\<And> empty heap. execute init Heap.empty = Some (empty, heap) \\<Longrightarrow> P empty heap\"\n  assumes consistent:\n    \"\\<And> empty heap. execute init Heap.empty = Some (empty, heap)\n    \\<Longrightarrow> dp_consistency_heap_empty (P empty) (update empty) (lookup empty) heap\"\nbegin"], ["", "sublocale dp_consistency_heap_empty\n  where P=\"P (result_of init Heap.empty)\"\n    and lookup=\"lookup (result_of init Heap.empty)\"\n    and update=\"update (result_of init Heap.empty)\"\n    and empty= \"heap_of init Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_empty (P (result_of init Heap.empty))\n     (update (result_of init Heap.empty))\n     (lookup (result_of init Heap.empty)) (heap_of init Heap.empty)", "using success"], ["proof (prove)\nusing this:\n  success init Heap.empty\n\ngoal (1 subgoal):\n 1. dp_consistency_heap_empty (P (result_of init Heap.empty))\n     (update (result_of init Heap.empty))\n     (lookup (result_of init Heap.empty)) (heap_of init Heap.empty)", "by (auto 4 3 intro: consistent successE)"], ["", "(* Extract Theorem *)"], ["", "lemma memoized_empty:\n  \"dp x = result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP (dp\\<^sub>T (result_of init Heap.empty))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp x =\n    result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty", "by (simp add: execute_bind_success memoized[OF that(1)] success)"], ["", "end"], ["", "locale dp_consistency_new' =\n  fixes dp :: \"'k \\<Rightarrow> 'v\"\n  fixes P :: \"'m \\<Rightarrow> heap \\<Rightarrow> bool\"\n    and lookup :: \"'m \\<Rightarrow> 'k \\<Rightarrow> 'v option Heap\"\n    and update :: \"'m \\<Rightarrow> 'k \\<Rightarrow> 'v \\<Rightarrow> unit Heap\"\n    and init\n    and mem :: 'm\n  assumes mem_is_init: \"mem = result_of init Heap.empty\"\n  assumes\n    success: \"success init Heap.empty\"\n  assumes\n    inv_init: \"\\<And> empty heap. execute init Heap.empty = Some (empty, heap) \\<Longrightarrow> P empty heap\"\n  assumes consistent:\n    \"\\<And> empty heap. execute init Heap.empty = Some (empty, heap)\n    \\<Longrightarrow> dp_consistency_heap_empty (P empty) (update empty) (lookup empty) heap\"\nbegin"], ["", "sublocale dp_consistency_heap_empty\n  where P=\"P mem\"\n    and lookup=\"lookup mem\"\n    and update=\"update mem\"\n    and empty= \"heap_of init Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_empty (P mem) (update mem) (lookup mem)\n     (heap_of init Heap.empty)", "unfolding mem_is_init"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_empty (P (result_of init Heap.empty))\n     (update (result_of init Heap.empty))\n     (lookup (result_of init Heap.empty)) (heap_of init Heap.empty)", "using success"], ["proof (prove)\nusing this:\n  success init Heap.empty\n\ngoal (1 subgoal):\n 1. dp_consistency_heap_empty (P (result_of init Heap.empty))\n     (update (result_of init Heap.empty))\n     (lookup (result_of init Heap.empty)) (heap_of init Heap.empty)", "by (auto 4 3 intro: consistent successE)"], ["", "(* Extract Theorem *)"], ["", "lemma memoized_empty:\n  \"dp x = result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty\"\n  if \"consistentDP (dp\\<^sub>T (result_of init Heap.empty))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp x =\n    result_of (init \\<bind> (\\<lambda>mem. dp\\<^sub>T mem x)) Heap.empty", "by (simp add: execute_bind_success memoized[OF that(1)] success)"], ["", "end"], ["", "locale dp_consistency_heap_array_new' =\n  fixes size :: nat\n    and to_index :: \"('k :: heap) \\<Rightarrow> nat\"\n    and mem :: \"('v::heap) option array\"\n    and dp :: \"'k \\<Rightarrow> 'v::heap\"\n  assumes mem_is_init: \"mem = result_of (mem_empty size) Heap.empty\"\n  assumes injective: \"injective size to_index\"\nbegin"], ["", "sublocale dp_consistency_new'\n  where P      = \"\\<lambda> mem heap. Array.length heap mem = size\"\n    and lookup = \"\\<lambda> mem. mem_lookup size to_index mem\"\n    and update = \"\\<lambda> mem. mem_update size to_index mem\"\n    and init   = \"mem_empty size\"\n    and mem    = mem"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_new' (\\<lambda>mem heap. Array.length heap mem = size)\n     (mem_lookup size to_index) (mem_update size to_index) (mem_empty size)\n     mem", "apply (rule dp_consistency_new'.intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. mem = result_of (mem_empty size) Heap.empty\n 2. success (mem_empty size) Heap.empty\n 3. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size\n 4. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty\n        (\\<lambda>heap. Array.length heap emptya = size)\n        (mem_update size to_index emptya) (mem_lookup size to_index emptya)\n        heap", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mem = result_of (mem_empty size) Heap.empty", "by (rule mem_is_init)"], ["proof (prove)\ngoal (3 subgoals):\n 1. success (mem_empty size) Heap.empty\n 2. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size\n 3. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty\n        (\\<lambda>heap. Array.length heap emptya = size)\n        (mem_update size to_index emptya) (mem_lookup size to_index emptya)\n        heap", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. success (mem_empty size) Heap.empty", "by (rule success_empty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size\n 2. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty\n        (\\<lambda>heap. Array.length heap emptya = size)\n        (mem_update size to_index emptya) (mem_lookup size to_index emptya)\n        heap", "subgoal for empty heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (mem_empty size) Heap.empty =\n    Some (empty, heap) \\<Longrightarrow>\n    Array.length heap empty = size", "using length_mem_empty"], ["proof (prove)\nusing this:\n  Array.length (heap_of (mem_empty ?size) ?h)\n   (result_of (mem_empty ?size) ?h) =\n  ?size\n\ngoal (1 subgoal):\n 1. execute (mem_empty size) Heap.empty =\n    Some (empty, heap) \\<Longrightarrow>\n    Array.length heap empty = size", "by (metis fst_conv option.sel snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty\n        (\\<lambda>heap. Array.length heap emptya = size)\n        (mem_update size to_index emptya) (mem_lookup size to_index emptya)\n        heap", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (mem_empty size) Heap.empty =\n    Some (emptya_, heap_) \\<Longrightarrow>\n    dp_consistency_heap_empty\n     (\\<lambda>heap. Array.length heap emptya_ = size)\n     (mem_update size to_index emptya_) (mem_lookup size to_index emptya_)\n     heap_", "apply (frule execute_heap_ofD[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>execute (mem_empty size) Heap.empty = Some (emptya_, heap_);\n     heap_ = heap_of (mem_empty size) Heap.empty\\<rbrakk>\n    \\<Longrightarrow> dp_consistency_heap_empty\n                       (\\<lambda>heap. Array.length heap emptya_ = size)\n                       (mem_update size to_index emptya_)\n                       (mem_lookup size to_index emptya_) heap_", "apply (frule execute_result_ofD[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>execute (mem_empty size) Heap.empty = Some (emptya_, heap_);\n     heap_ = heap_of (mem_empty size) Heap.empty;\n     emptya_ = result_of (mem_empty size) Heap.empty\\<rbrakk>\n    \\<Longrightarrow> dp_consistency_heap_empty\n                       (\\<lambda>heap. Array.length heap emptya_ = size)\n                       (mem_update size to_index emptya_)\n                       (mem_lookup size to_index emptya_) heap_", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>execute (mem_empty size) Heap.empty =\n             Some (the (execute (mem_empty size) Heap.empty));\n     heap_ = heap_of (mem_empty size) Heap.empty;\n     emptya_ = result_of (mem_empty size) Heap.empty\\<rbrakk>\n    \\<Longrightarrow> dp_consistency_heap_empty\n                       (\\<lambda>heap.\n                           Array.length heap\n                            (result_of (mem_empty size) Heap.empty) =\n                           size)\n                       (mem_update size to_index\n                         (result_of (mem_empty size) Heap.empty))\n                       (mem_lookup size to_index\n                         (result_of (mem_empty size) Heap.empty))\n                       (heap_of (mem_empty size) Heap.empty)", "apply (rule array_consistentI[OF injective HOL.refl])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "thm memoized_empty"], ["", "end"], ["", "locale dp_consistency_heap_array_new =\n  fixes size :: nat\n    and to_index :: \"('k :: heap) \\<Rightarrow> nat\"\n    and dp :: \"'k \\<Rightarrow> 'v::heap\"\n  assumes injective: \"injective size to_index\"\nbegin"], ["", "sublocale dp_consistency_new\n  where P      = \"\\<lambda> mem heap. Array.length heap mem = size\"\n    and lookup = \"\\<lambda> mem. mem_lookup size to_index mem\"\n    and update = \"\\<lambda> mem. mem_update size to_index mem\"\n    and init   = \"mem_empty size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_new (\\<lambda>mem heap. Array.length heap mem = size)\n     (mem_lookup size to_index) (mem_update size to_index) (mem_empty size)", "apply (rule dp_consistency_new.intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. success (mem_empty size) Heap.empty\n 2. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size\n 3. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty\n        (\\<lambda>heap. Array.length heap emptya = size)\n        (mem_update size to_index emptya) (mem_lookup size to_index emptya)\n        heap", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. success (mem_empty size) Heap.empty", "by (rule success_empty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size\n 2. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty\n        (\\<lambda>heap. Array.length heap emptya = size)\n        (mem_update size to_index emptya) (mem_lookup size to_index emptya)\n        heap", "subgoal for empty heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (mem_empty size) Heap.empty =\n    Some (empty, heap) \\<Longrightarrow>\n    Array.length heap empty = size", "using length_mem_empty"], ["proof (prove)\nusing this:\n  Array.length (heap_of (mem_empty ?size) ?h)\n   (result_of (mem_empty ?size) ?h) =\n  ?size\n\ngoal (1 subgoal):\n 1. execute (mem_empty size) Heap.empty =\n    Some (empty, heap) \\<Longrightarrow>\n    Array.length heap empty = size", "by (metis fst_conv option.sel snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty\n        (\\<lambda>heap. Array.length heap emptya = size)\n        (mem_update size to_index emptya) (mem_lookup size to_index emptya)\n        heap", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (mem_empty size) Heap.empty =\n    Some (emptya_, heap_) \\<Longrightarrow>\n    dp_consistency_heap_empty\n     (\\<lambda>heap. Array.length heap emptya_ = size)\n     (mem_update size to_index emptya_) (mem_lookup size to_index emptya_)\n     heap_", "apply (frule execute_heap_ofD[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>execute (mem_empty size) Heap.empty = Some (emptya_, heap_);\n     heap_ = heap_of (mem_empty size) Heap.empty\\<rbrakk>\n    \\<Longrightarrow> dp_consistency_heap_empty\n                       (\\<lambda>heap. Array.length heap emptya_ = size)\n                       (mem_update size to_index emptya_)\n                       (mem_lookup size to_index emptya_) heap_", "apply (frule execute_result_ofD[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>execute (mem_empty size) Heap.empty = Some (emptya_, heap_);\n     heap_ = heap_of (mem_empty size) Heap.empty;\n     emptya_ = result_of (mem_empty size) Heap.empty\\<rbrakk>\n    \\<Longrightarrow> dp_consistency_heap_empty\n                       (\\<lambda>heap. Array.length heap emptya_ = size)\n                       (mem_update size to_index emptya_)\n                       (mem_lookup size to_index emptya_) heap_", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>execute (mem_empty size) Heap.empty =\n             Some (the (execute (mem_empty size) Heap.empty));\n     heap_ = heap_of (mem_empty size) Heap.empty;\n     emptya_ = result_of (mem_empty size) Heap.empty\\<rbrakk>\n    \\<Longrightarrow> dp_consistency_heap_empty\n                       (\\<lambda>heap.\n                           Array.length heap\n                            (result_of (mem_empty size) Heap.empty) =\n                           size)\n                       (mem_update size to_index\n                         (result_of (mem_empty size) Heap.empty))\n                       (mem_lookup size to_index\n                         (result_of (mem_empty size) Heap.empty))\n                       (heap_of (mem_empty size) Heap.empty)", "apply (rule array_consistentI[OF injective HOL.refl])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "thm memoized_empty"], ["", "end"], ["", "locale dp_consistency_heap_array =\n  fixes size :: nat\n    and to_index :: \"('k :: heap) \\<Rightarrow> nat\"\n    and dp :: \"'k \\<Rightarrow> 'v::heap\"\n  assumes injective: \"injective size to_index\"\nbegin"], ["", "sublocale dp_consistency_heap_init\n  where P=\"\\<lambda>mem heap. Array.length heap mem = size\"\n    and lookup=\"\\<lambda> mem. mem_lookup size to_index mem\"\n    and update=\"\\<lambda> mem. mem_update size to_index mem\"\n    and init=\"mem_empty size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_init\n     (\\<lambda>mem heap. Array.length heap mem = size)\n     (mem_update size to_index) (mem_lookup size to_index) (mem_empty size)", "apply standard"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>k m.\n       State_Heap.lift_p (\\<lambda>heap. Array.length heap m = size)\n        (mem_lookup size to_index m k)\n 2. \\<And>k v m.\n       State_Heap.lift_p (\\<lambda>heap. Array.length heap m = size)\n        (mem_update size to_index m k v)\n 3. \\<And>m k a.\n       Array.length m a = size \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a\n        (heap_of (mem_lookup size to_index a k) m) \\<subseteq>\\<^sub>m\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a m\n 4. \\<And>m k v a.\n       Array.length m a = size \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a\n        (heap_of (mem_update size to_index a k v) m) \\<subseteq>\\<^sub>m\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a m(k \n       \\<mapsto> v)\n 5. success (mem_empty size) Heap.empty\n 6. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) emptya\n        heap \\<subseteq>\\<^sub>m\n       Map.empty\n 7. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size", "subgoal lookup_inv"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Heap.lift_p (\\<lambda>heap. Array.length heap m_ = size)\n     (mem_lookup size to_index m_ k_)", "unfolding lift_p_def mem_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       Array.length heap m_ = size \\<longrightarrow>\n       (case execute\n              (let i = to_index k_\n               in if i < size then Array.nth m_ i else return None)\n              heap of\n        None \\<Rightarrow> False\n        | Some (xa, heap) \\<Rightarrow> Array.length heap m_ = size)", "by (simp add: Let_def execute_simps)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>k v m.\n       State_Heap.lift_p (\\<lambda>heap. Array.length heap m = size)\n        (mem_update size to_index m k v)\n 2. \\<And>m k a.\n       Array.length m a = size \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a\n        (heap_of (mem_lookup size to_index a k) m) \\<subseteq>\\<^sub>m\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a m\n 3. \\<And>m k v a.\n       Array.length m a = size \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a\n        (heap_of (mem_update size to_index a k v) m) \\<subseteq>\\<^sub>m\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a m(k \n       \\<mapsto> v)\n 4. success (mem_empty size) Heap.empty\n 5. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) emptya\n        heap \\<subseteq>\\<^sub>m\n       Map.empty\n 6. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size", "subgoal update_inv"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Heap.lift_p (\\<lambda>heap. Array.length heap m_ = size)\n     (mem_update size to_index m_ k_ v_)", "unfolding State_Heap.lift_p_def mem_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       Array.length heap m_ = size \\<longrightarrow>\n       (case execute\n              (let i = to_index k_\n               in if i < size\n                  then Array.upd i (Some v_) m_ \\<bind>\n                       (\\<lambda>_. return ())\n                  else return ())\n              heap of\n        None \\<Rightarrow> False\n        | Some (xa, heap) \\<Rightarrow> Array.length heap m_ = size)", "by (simp add: Let_def execute_simps)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>m k a.\n       Array.length m a = size \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a\n        (heap_of (mem_lookup size to_index a k) m) \\<subseteq>\\<^sub>m\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a m\n 2. \\<And>m k v a.\n       Array.length m a = size \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a\n        (heap_of (mem_update size to_index a k v) m) \\<subseteq>\\<^sub>m\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a m(k \n       \\<mapsto> v)\n 3. success (mem_empty size) Heap.empty\n 4. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) emptya\n        heap \\<subseteq>\\<^sub>m\n       Map.empty\n 5. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size", "subgoal for k heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length k a_ = size \\<Longrightarrow>\n    heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a_\n     (heap_of (mem_lookup size to_index a_ heap) k) \\<subseteq>\\<^sub>m\n    heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a_ k", "unfolding heap_correct_init_defs.map_of_heap'_def map_le_def mem_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length k a_ = size \\<Longrightarrow>\n    \\<forall>aa\\<in>dom (\\<lambda>ka.\n                            result_of\n                             (let i = to_index ka\n                              in if i < size then Array.nth a_ i\n                                 else return None)\n                             (heap_of\n                               (let i = to_index heap\n                                in if i < size then Array.nth a_ i\n                                   else return None)\n                               k)).\n       result_of\n        (let i = to_index aa\n         in if i < size then Array.nth a_ i else return None)\n        (heap_of\n          (let i = to_index heap\n           in if i < size then Array.nth a_ i else return None)\n          k) =\n       result_of\n        (let i = to_index aa\n         in if i < size then Array.nth a_ i else return None)\n        k", "by (auto simp: execute_simps Let_def split: if_split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m k v a.\n       Array.length m a = size \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a\n        (heap_of (mem_update size to_index a k v) m) \\<subseteq>\\<^sub>m\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a m(k \n       \\<mapsto> v)\n 2. success (mem_empty size) Heap.empty\n 3. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) emptya\n        heap \\<subseteq>\\<^sub>m\n       Map.empty\n 4. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size", "subgoal for heap k"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length heap a_ = size \\<Longrightarrow>\n    heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a_\n     (heap_of (mem_update size to_index a_ k v_) heap) \\<subseteq>\\<^sub>m\n    heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) a_ heap\n    (k \\<mapsto> v_)", "unfolding heap_correct_init_defs.map_of_heap'_def map_le_def mem_lookup_def mem_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length heap a_ = size \\<Longrightarrow>\n    \\<forall>aa\\<in>dom (\\<lambda>ka.\n                            result_of\n                             (let i = to_index ka\n                              in if i < size then Array.nth a_ i\n                                 else return None)\n                             (heap_of\n                               (let i = to_index k\n                                in if i < size\n                                   then Array.upd i (Some v_) a_ \\<bind>\n  (\\<lambda>_. return ())\n                                   else return ())\n                               heap)).\n       result_of\n        (let i = to_index aa\n         in if i < size then Array.nth a_ i else return None)\n        (heap_of\n          (let i = to_index k\n           in if i < size\n              then Array.upd i (Some v_) a_ \\<bind> (\\<lambda>_. return ())\n              else return ())\n          heap) =\n       ((\\<lambda>k.\n            result_of\n             (let i = to_index k\n              in if i < size then Array.nth a_ i else return None)\n             heap)\n        (k \\<mapsto> v_))\n        aa", "apply (auto simp: execute_simps Let_def length_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa y.\n       \\<lbrakk>size = length (Array.get heap a_);\n        to_index k < length (Array.get heap a_);\n        (Array.get heap a_)[to_index k := Some v_] ! to_index aa = Some y;\n        to_index aa < length (Array.get heap a_); aa \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> Some y = Array.get heap a_ ! to_index aa", "apply (subst (asm) nth_list_update_neq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa y.\n       \\<lbrakk>to_index aa < length (Array.get heap a_); aa \\<noteq> k;\n        size = length (Array.get heap a_);\n        to_index k < length (Array.get heap a_)\\<rbrakk>\n       \\<Longrightarrow> to_index k \\<noteq> to_index aa\n 2. \\<And>aa y.\n       \\<lbrakk>size = length (Array.get heap a_);\n        to_index k < length (Array.get heap a_);\n        Array.get heap a_ ! to_index aa = Some y;\n        to_index aa < length (Array.get heap a_); aa \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> Some y = Array.get heap a_ ! to_index aa", "using injective[unfolded injective_def]"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     to_index a = to_index b \\<and>\n     to_index a < size \\<and> to_index b < size \\<longrightarrow>\n     a = b\n\ngoal (2 subgoals):\n 1. \\<And>aa y.\n       \\<lbrakk>to_index aa < length (Array.get heap a_); aa \\<noteq> k;\n        size = length (Array.get heap a_);\n        to_index k < length (Array.get heap a_)\\<rbrakk>\n       \\<Longrightarrow> to_index k \\<noteq> to_index aa\n 2. \\<And>aa y.\n       \\<lbrakk>size = length (Array.get heap a_);\n        to_index k < length (Array.get heap a_);\n        Array.get heap a_ ! to_index aa = Some y;\n        to_index aa < length (Array.get heap a_); aa \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> Some y = Array.get heap a_ ! to_index aa", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. success (mem_empty size) Heap.empty\n 2. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) emptya\n        heap \\<subseteq>\\<^sub>m\n       Map.empty\n 3. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. success (mem_empty size) Heap.empty", "by (rule success_empty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) emptya\n        heap \\<subseteq>\\<^sub>m\n       Map.empty\n 2. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size", "subgoal for empty' heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (mem_empty size) Heap.empty =\n    Some (empty', heap) \\<Longrightarrow>\n    heap_correct_init_defs.map_of_heap' (mem_lookup size to_index) empty'\n     heap \\<subseteq>\\<^sub>m\n    Map.empty", "unfolding heap_correct_init_defs.map_of_heap'_def mem_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (mem_empty size) Heap.empty =\n    Some (empty', heap) \\<Longrightarrow>\n    (\\<lambda>k.\n        result_of\n         (let i = to_index k\n          in if i < size then Array.nth empty' i else return None)\n         heap) \\<subseteq>\\<^sub>m\n    Map.empty", "by (auto intro!: map_emptyI simp: Let_def ) (metis fst_conv option.sel snd_conv nth_mem_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>emptya heap.\n       execute (mem_empty size) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       Array.length heap emptya = size", "subgoal for empty' heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (mem_empty size) Heap.empty =\n    Some (empty', heap) \\<Longrightarrow>\n    Array.length heap empty' = size", "unfolding heap_correct_init_defs.map_of_heap'_def mem_lookup_def map_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (mem_empty size) Heap.empty =\n    Some (empty', heap) \\<Longrightarrow>\n    Array.length heap empty' = size", "using length_mem_empty"], ["proof (prove)\nusing this:\n  Array.length (heap_of (mem_empty ?size) ?h)\n   (result_of (mem_empty ?size) ?h) =\n  ?size\n\ngoal (1 subgoal):\n 1. execute (mem_empty size) Heap.empty =\n    Some (empty', heap) \\<Longrightarrow>\n    Array.length heap empty' = size", "by (metis fst_conv option.sel snd_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "locale dp_consistency_heap_array_pair' =\n  fixes size :: nat\n  fixes key1 :: \"'k \\<Rightarrow> ('k1 :: heap)\" and key2 :: \"'k \\<Rightarrow> 'k2 :: heap\"\n    and to_index :: \"'k2 \\<Rightarrow> nat\"\n    and dp :: \"'k \\<Rightarrow> 'v::heap\"\n    and k1 k2 :: \"'k1\"\n    and mem :: \"('k1 ref \\<times>\n             'k1 ref \\<times>\n             'v option array ref \\<times>\n             'v option array ref)\"\n  assumes mem_is_init: \"mem = result_of (init_state size k1 k2) Heap.empty\"\n  assumes injective: \"injective size to_index\"\n      and keys_injective: \"\\<forall>k k'. key1 k = key1 k' \\<and> key2 k = key2 k' \\<longrightarrow> k = k'\"\n      and keys_neq: \"k1 \\<noteq> k2\"\nbegin"], ["", "definition\n  \"inv_pair' = (\\<lambda> (k_ref1, k_ref2, m_ref1, m_ref2).\n      pair_mem_defs.inv_pair (lookup1 size to_index m_ref1)\n        (lookup2 size to_index m_ref2) (get_k1 k_ref1)\n        (get_k2 k_ref2)\n        (inv_pair_weak size m_ref1 m_ref2 k_ref1 k_ref2) key1 key2)\""], ["", "sublocale dp_consistency_new'\n  where P=inv_pair'\n    and lookup=\"\\<lambda> (k_ref1, k_ref2, m_ref1, m_ref2).\n      lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2\"\n    and update=\"\\<lambda> (k_ref1, k_ref2, m_ref1, m_ref2).\n      update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2\"\n    and init=\"init_state size k1 k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_new' inv_pair'\n     (\\<lambda>(k_ref1, k_ref2, m_ref1, m_ref2).\n         lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n     (\\<lambda>(k_ref1, k_ref2, m_ref1, m_ref2).\n         update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n     (init_state size k1 k2) mem", "apply (rule dp_consistency_new'.intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. mem = result_of (init_state size k1 k2) Heap.empty\n 2. success (init_state size k1 k2) Heap.empty\n 3. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       inv_pair' emptya heap\n 4. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty (inv_pair' emptya)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        heap", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mem = result_of (init_state size k1 k2) Heap.empty", "by (rule mem_is_init)"], ["proof (prove)\ngoal (3 subgoals):\n 1. success (init_state size k1 k2) Heap.empty\n 2. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       inv_pair' emptya heap\n 3. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty (inv_pair' emptya)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        heap", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. success (init_state size k1 k2) Heap.empty", "by (rule succes_init_state)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       inv_pair' emptya heap\n 2. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty (inv_pair' emptya)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        heap", "subgoal for empty heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (init_state size k1 k2) Heap.empty =\n    Some (empty, heap) \\<Longrightarrow>\n    inv_pair' empty heap", "unfolding inv_pair'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (init_state size k1 k2) Heap.empty =\n    Some (empty, heap) \\<Longrightarrow>\n    (case empty of\n     (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n       pair_mem_defs.inv_pair (lookup1 size to_index m_ref1)\n        (lookup2 size to_index m_ref2) (get_k1 k_ref1) (get_k2 k_ref2)\n        (inv_pair_weak size m_ref1 m_ref2 k_ref1 k_ref2) key1 key2)\n     heap", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> pair_mem_defs.inv_pair (lookup1 size to_index aa)\n                          (lookup2 size to_index b) (get_k1 k_ref1)\n                          (get_k2 a) (inv_pair_weak size aa b k_ref1 a) key1\n                          key2 heap", "apply (rule init_state_inv')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> injective size to_index\n 2. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> inv_distinct k_ref1 a aa b\n 3. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k k'.\n                            key1 k = key1 k' \\<and>\n                            key2 k = key2 k' \\<longrightarrow>\n                            k = k'\n 4. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> execute\n                          (init_state size (?k1.4 k_ref1 a aa b)\n                            (?k2.4 k_ref1 a aa b))\n                          (?heap4 k_ref1 a aa b) =\n                         Some ((k_ref1, a, aa, b), heap)\n 5. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> ?k1.4 k_ref1 a aa b \\<noteq> ?k2.4 k_ref1 a aa b", "apply (rule injective)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> inv_distinct k_ref1 a aa b\n 2. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k k'.\n                            key1 k = key1 k' \\<and>\n                            key2 k = key2 k' \\<longrightarrow>\n                            k = k'\n 3. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> execute\n                          (init_state size (?k1.4 k_ref1 a aa b)\n                            (?k2.4 k_ref1 a aa b))\n                          (?heap4 k_ref1 a aa b) =\n                         Some ((k_ref1, a, aa, b), heap)\n 4. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> ?k1.4 k_ref1 a aa b \\<noteq> ?k2.4 k_ref1 a aa b", "apply (erule init_state_distinct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k k'.\n                            key1 k = key1 k' \\<and>\n                            key2 k = key2 k' \\<longrightarrow>\n                            k = k'\n 2. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> execute\n                          (init_state size (?k1.4 k_ref1 a aa b)\n                            (?k2.4 k_ref1 a aa b))\n                          (?heap4 k_ref1 a aa b) =\n                         Some ((k_ref1, a, aa, b), heap)\n 3. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> ?k1.4 k_ref1 a aa b \\<noteq> ?k2.4 k_ref1 a aa b", "apply (rule keys_injective)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> execute\n                          (init_state size (?k1.4 k_ref1 a aa b)\n                            (?k2.4 k_ref1 a aa b))\n                          (?heap4 k_ref1 a aa b) =\n                         Some ((k_ref1, a, aa, b), heap)\n 2. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> ?k1.4 k_ref1 a aa b \\<noteq> ?k2.4 k_ref1 a aa b", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> k1 \\<noteq> k2", "apply (rule keys_neq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty (inv_pair' emptya)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        heap", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       dp_consistency_heap_empty (inv_pair' (a, aa, ab, b))\n        (update_pair size to_index key1 key2 ab b a aa)\n        (lookup_pair size to_index key1 key2 ab b a aa) heap", "unfolding inv_pair'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa aaa b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, aaa, b), heap) \\<Longrightarrow>\n       dp_consistency_heap_empty\n        (case (a, aa, aaa, b) of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           pair_mem_defs.inv_pair (lookup1 size to_index m_ref1)\n            (lookup2 size to_index m_ref2) (get_k1 k_ref1) (get_k2 k_ref2)\n            (inv_pair_weak size m_ref1 m_ref2 k_ref1 k_ref2) key1 key2)\n        (update_pair size to_index key1 key2 aaa b a aa)\n        (lookup_pair size to_index key1 key2 aaa b a aa) heap", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       dp_consistency_heap_empty\n        (pair_mem_defs.inv_pair (lookup1 size to_index ab)\n          (lookup2 size to_index b) (get_k1 a) (get_k2 aa)\n          (inv_pair_weak size ab b a aa) key1 key2)\n        (update_pair size to_index key1 key2 ab b a aa)\n        (lookup_pair size to_index key1 key2 ab b a aa) heap", "apply (rule consistent_empty_pairI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       injective size to_index\n 2. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       inv_distinct a aa ab b\n 3. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       \\<forall>k k'.\n          key1 k = key1 k' \\<and> key2 k = key2 k' \\<longrightarrow> k = k'\n 4. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       execute\n        (init_state size (?k1.8 a aa ab b heap) (?k2.8 a aa ab b heap))\n        (?heap8 a aa ab b heap) =\n       Some ((a, aa, ab, b), heap)\n 5. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       ?k1.8 a aa ab b heap \\<noteq> ?k2.8 a aa ab b heap", "apply (rule injective)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       inv_distinct a aa ab b\n 2. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       \\<forall>k k'.\n          key1 k = key1 k' \\<and> key2 k = key2 k' \\<longrightarrow> k = k'\n 3. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       execute\n        (init_state size (?k1.8 a aa ab b heap) (?k2.8 a aa ab b heap))\n        (?heap8 a aa ab b heap) =\n       Some ((a, aa, ab, b), heap)\n 4. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       ?k1.8 a aa ab b heap \\<noteq> ?k2.8 a aa ab b heap", "apply (erule init_state_distinct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       \\<forall>k k'.\n          key1 k = key1 k' \\<and> key2 k = key2 k' \\<longrightarrow> k = k'\n 2. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       execute\n        (init_state size (?k1.8 a aa ab b heap) (?k2.8 a aa ab b heap))\n        (?heap8 a aa ab b heap) =\n       Some ((a, aa, ab, b), heap)\n 3. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       ?k1.8 a aa ab b heap \\<noteq> ?k2.8 a aa ab b heap", "apply (rule keys_injective)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       execute\n        (init_state size (?k1.8 a aa ab b heap) (?k2.8 a aa ab b heap))\n        (?heap8 a aa ab b heap) =\n       Some ((a, aa, ab, b), heap)\n 2. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       ?k1.8 a aa ab b heap \\<noteq> ?k2.8 a aa ab b heap", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       k1 \\<noteq> k2", "apply (rule keys_neq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "locale dp_consistency_heap_array_pair_iterator =\n  dp_consistency_heap_array_pair' where dp = dp + iterator where cnt = cnt\n  for dp :: \"'k \\<Rightarrow> 'v::heap\" and cnt :: \"'k \\<Rightarrow> bool\"\nbegin"], ["", "sublocale dp_consistency_iterator_heap\n  where P = \"inv_pair' mem\"\n  and update = \"(case mem of\n  (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n    update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\"\n  and lookup = \"(case mem of\n  (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n    lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_iterator_heap\n     (case mem of\n      (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n        lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n     (case mem of\n      (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n        update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n     (inv_pair' mem) cnt nxt sizef", ".."], ["", "end"], ["", "locale dp_consistency_heap_array_pair =\n  fixes size :: nat\n  fixes key1 :: \"'k \\<Rightarrow> ('k1 :: heap)\" and key2 :: \"'k \\<Rightarrow> 'k2 :: heap\"\n    and to_index :: \"'k2 \\<Rightarrow> nat\"\n    and dp :: \"'k \\<Rightarrow> 'v::heap\"\n    and k1 k2 :: \"'k1\"\n  assumes injective: \"injective size to_index\"\n      and keys_injective: \"\\<forall>k k'. key1 k = key1 k' \\<and> key2 k = key2 k' \\<longrightarrow> k = k'\"\n      and keys_neq: \"k1 \\<noteq> k2\"\nbegin"], ["", "definition\n  \"inv_pair' = (\\<lambda> (k_ref1, k_ref2, m_ref1, m_ref2).\n      pair_mem_defs.inv_pair (lookup1 size to_index m_ref1)\n        (lookup2 size to_index m_ref2) (get_k1 k_ref1)\n        (get_k2 k_ref2)\n        (inv_pair_weak size m_ref1 m_ref2 k_ref1 k_ref2) key1 key2)\""], ["", "sublocale dp_consistency_new\n  where P=inv_pair'\n    and lookup=\"\\<lambda> (k_ref1, k_ref2, m_ref1, m_ref2).\n      lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2\"\n    and update=\"\\<lambda> (k_ref1, k_ref2, m_ref1, m_ref2).\n      update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2\"\n    and init=\"init_state size k1 k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_new inv_pair'\n     (\\<lambda>(k_ref1, k_ref2, m_ref1, m_ref2).\n         lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n     (\\<lambda>(k_ref1, k_ref2, m_ref1, m_ref2).\n         update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n     (init_state size k1 k2)", "apply (rule dp_consistency_new.intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. success (init_state size k1 k2) Heap.empty\n 2. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       inv_pair' emptya heap\n 3. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty (inv_pair' emptya)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        heap", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. success (init_state size k1 k2) Heap.empty", "by (rule succes_init_state)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       inv_pair' emptya heap\n 2. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty (inv_pair' emptya)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        heap", "subgoal for empty heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (init_state size k1 k2) Heap.empty =\n    Some (empty, heap) \\<Longrightarrow>\n    inv_pair' empty heap", "unfolding inv_pair'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute (init_state size k1 k2) Heap.empty =\n    Some (empty, heap) \\<Longrightarrow>\n    (case empty of\n     (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n       pair_mem_defs.inv_pair (lookup1 size to_index m_ref1)\n        (lookup2 size to_index m_ref2) (get_k1 k_ref1) (get_k2 k_ref2)\n        (inv_pair_weak size m_ref1 m_ref2 k_ref1 k_ref2) key1 key2)\n     heap", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> pair_mem_defs.inv_pair (lookup1 size to_index aa)\n                          (lookup2 size to_index b) (get_k1 k_ref1)\n                          (get_k2 a) (inv_pair_weak size aa b k_ref1 a) key1\n                          key2 heap", "apply (rule init_state_inv')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> injective size to_index\n 2. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> inv_distinct k_ref1 a aa b\n 3. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k k'.\n                            key1 k = key1 k' \\<and>\n                            key2 k = key2 k' \\<longrightarrow>\n                            k = k'\n 4. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> execute\n                          (init_state size (?k1.4 k_ref1 a aa b)\n                            (?k2.4 k_ref1 a aa b))\n                          (?heap4 k_ref1 a aa b) =\n                         Some ((k_ref1, a, aa, b), heap)\n 5. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> ?k1.4 k_ref1 a aa b \\<noteq> ?k2.4 k_ref1 a aa b", "apply (rule injective)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> inv_distinct k_ref1 a aa b\n 2. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k k'.\n                            key1 k = key1 k' \\<and>\n                            key2 k = key2 k' \\<longrightarrow>\n                            k = k'\n 3. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> execute\n                          (init_state size (?k1.4 k_ref1 a aa b)\n                            (?k2.4 k_ref1 a aa b))\n                          (?heap4 k_ref1 a aa b) =\n                         Some ((k_ref1, a, aa, b), heap)\n 4. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> ?k1.4 k_ref1 a aa b \\<noteq> ?k2.4 k_ref1 a aa b", "apply (erule init_state_distinct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k k'.\n                            key1 k = key1 k' \\<and>\n                            key2 k = key2 k' \\<longrightarrow>\n                            k = k'\n 2. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> execute\n                          (init_state size (?k1.4 k_ref1 a aa b)\n                            (?k2.4 k_ref1 a aa b))\n                          (?heap4 k_ref1 a aa b) =\n                         Some ((k_ref1, a, aa, b), heap)\n 3. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> ?k1.4 k_ref1 a aa b \\<noteq> ?k2.4 k_ref1 a aa b", "apply (rule keys_injective)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> execute\n                          (init_state size (?k1.4 k_ref1 a aa b)\n                            (?k2.4 k_ref1 a aa b))\n                          (?heap4 k_ref1 a aa b) =\n                         Some ((k_ref1, a, aa, b), heap)\n 2. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> ?k1.4 k_ref1 a aa b \\<noteq> ?k2.4 k_ref1 a aa b", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k_ref1 a aa b.\n       \\<lbrakk>execute (init_state size k1 k2) Heap.empty =\n                Some ((k_ref1, a, aa, b), heap);\n        empty = (k_ref1, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> k1 \\<noteq> k2", "apply (rule keys_neq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>emptya heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some (emptya, heap) \\<Longrightarrow>\n       dp_consistency_heap_empty (inv_pair' emptya)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           update_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        (case emptya of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           lookup_pair size to_index key1 key2 m_ref1 m_ref2 k_ref1 k_ref2)\n        heap", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       dp_consistency_heap_empty (inv_pair' (a, aa, ab, b))\n        (update_pair size to_index key1 key2 ab b a aa)\n        (lookup_pair size to_index key1 key2 ab b a aa) heap", "unfolding inv_pair'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa aaa b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, aaa, b), heap) \\<Longrightarrow>\n       dp_consistency_heap_empty\n        (case (a, aa, aaa, b) of\n         (k_ref1, k_ref2, m_ref1, m_ref2) \\<Rightarrow>\n           pair_mem_defs.inv_pair (lookup1 size to_index m_ref1)\n            (lookup2 size to_index m_ref2) (get_k1 k_ref1) (get_k2 k_ref2)\n            (inv_pair_weak size m_ref1 m_ref2 k_ref1 k_ref2) key1 key2)\n        (update_pair size to_index key1 key2 aaa b a aa)\n        (lookup_pair size to_index key1 key2 aaa b a aa) heap", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       dp_consistency_heap_empty\n        (pair_mem_defs.inv_pair (lookup1 size to_index ab)\n          (lookup2 size to_index b) (get_k1 a) (get_k2 aa)\n          (inv_pair_weak size ab b a aa) key1 key2)\n        (update_pair size to_index key1 key2 ab b a aa)\n        (lookup_pair size to_index key1 key2 ab b a aa) heap", "apply (rule consistent_empty_pairI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       injective size to_index\n 2. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       inv_distinct a aa ab b\n 3. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       \\<forall>k k'.\n          key1 k = key1 k' \\<and> key2 k = key2 k' \\<longrightarrow> k = k'\n 4. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       execute\n        (init_state size (?k1.6 a aa ab b heap) (?k2.6 a aa ab b heap))\n        (?heap6 a aa ab b heap) =\n       Some ((a, aa, ab, b), heap)\n 5. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       ?k1.6 a aa ab b heap \\<noteq> ?k2.6 a aa ab b heap", "apply (rule injective)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       inv_distinct a aa ab b\n 2. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       \\<forall>k k'.\n          key1 k = key1 k' \\<and> key2 k = key2 k' \\<longrightarrow> k = k'\n 3. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       execute\n        (init_state size (?k1.6 a aa ab b heap) (?k2.6 a aa ab b heap))\n        (?heap6 a aa ab b heap) =\n       Some ((a, aa, ab, b), heap)\n 4. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       ?k1.6 a aa ab b heap \\<noteq> ?k2.6 a aa ab b heap", "apply (erule init_state_distinct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       \\<forall>k k'.\n          key1 k = key1 k' \\<and> key2 k = key2 k' \\<longrightarrow> k = k'\n 2. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       execute\n        (init_state size (?k1.6 a aa ab b heap) (?k2.6 a aa ab b heap))\n        (?heap6 a aa ab b heap) =\n       Some ((a, aa, ab, b), heap)\n 3. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       ?k1.6 a aa ab b heap \\<noteq> ?k2.6 a aa ab b heap", "apply (rule keys_injective)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       execute\n        (init_state size (?k1.6 a aa ab b heap) (?k2.6 a aa ab b heap))\n        (?heap6 a aa ab b heap) =\n       Some ((a, aa, ab, b), heap)\n 2. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       ?k1.6 a aa ab b heap \\<noteq> ?k2.6 a aa ab b heap", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b heap.\n       execute (init_state size k1 k2) Heap.empty =\n       Some ((a, aa, ab, b), heap) \\<Longrightarrow>\n       k1 \\<noteq> k2", "apply (rule keys_neq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \\<open>Code Setup\\<close>"], ["", "lemmas [code_unfold] = heap_mem_defs.checkmem_checkmem'[symmetric]"], ["", "lemmas [code] =\n  heap_mem_defs.checkmem'_def\n  Heap_Main.map\\<^sub>T_def"], ["", "end"], ["", "(* theory *)"]]}