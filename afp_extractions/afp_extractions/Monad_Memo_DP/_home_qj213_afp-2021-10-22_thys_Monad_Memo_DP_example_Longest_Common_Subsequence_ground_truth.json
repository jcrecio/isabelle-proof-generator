{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/example/Longest_Common_Subsequence.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma finite_subseq:\n  \"finite {xs. subseq xs ys}\" (is \"finite ?S\")", "lemma subseq_singleton_right:\n  \"subseq xs [x] = (xs = [x] \\<or> xs = [])\"", "lemma subseq_append_single_right:\n  \"subseq xs (ys @ [x]) = ((\\<exists> xs'. subseq xs' ys \\<and> xs = xs' @ [x]) \\<or> subseq xs ys)\"", "lemma Max_nat_plus:\n  \"Max (((+) n) ` S) = (n :: nat) + Max S\" if \"finite S\" \"S \\<noteq> {}\"", "lemma finite_OPT:\n  \"finite {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\" (is \"finite ?S\")", "lemma non_empty_OPT:\n  \"{xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<noteq> {}\"", "lemma OPT_0_left:\n  \"OPT 0 j = 0\"", "lemma OPT_0_right:\n  \"OPT i 0 = 0\"", "lemma OPT_rec1:\n  \"OPT (i + 1) (j + 1) = 1 + OPT i j\" (is \"?l = ?r\")\n  if \"A!i = B!j\" \"i < length A\" \"j < length B\"", "lemma OPT_rec2:\n  \"OPT (i + 1) (j + 1) = max (OPT i (j + 1)) (OPT (i + 1) j)\" (is \"?l = ?r\")\n  if \"A!i \\<noteq> B!j\" \"i < length A\" \"j < length B\"", "lemma lcs_correct':\n  \"OPT i j = lcs i j\" if \"i \\<le> length A\" \"j \\<le> length B\"", "theorem lcs_correct:\n  \"Max {length xs | xs. subseq xs A \\<and> subseq xs B} = lcs (length A) (length B)\"", "lemma lcs_lcs_ia:\n  \"lcs xs ys i j = lcs_ia i j\" if \"A = IArray xs\" \"B = IArray ys\"", "lemmas [code] = lcs\\<^sub>m.memoized_correct", "lemma lcs\\<^sub>a_correct:\n  \"lcs xs ys (length xs) (length ys) = lcs\\<^sub>a xs ys\""], "translations": [["", "lemma finite_subseq:\n  \"finite {xs. subseq xs ys}\" (is \"finite ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. subseq xs ys}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {xs. subseq xs ys}", "have \"?S \\<subseteq> {xs. set xs \\<subseteq> set ys \\<and> length xs \\<le> length ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. subseq xs ys}\n    \\<subseteq> {xs.\n                 set xs \\<subseteq> set ys \\<and> length xs \\<le> length ys}", "by (auto elim: list_emb_set intro: list_emb_length)"], ["proof (state)\nthis:\n  {xs. subseq xs ys}\n  \\<subseteq> {xs.\n               set xs \\<subseteq> set ys \\<and> length xs \\<le> length ys}\n\ngoal (1 subgoal):\n 1. finite {xs. subseq xs ys}", "moreover"], ["proof (state)\nthis:\n  {xs. subseq xs ys}\n  \\<subseteq> {xs.\n               set xs \\<subseteq> set ys \\<and> length xs \\<le> length ys}\n\ngoal (1 subgoal):\n 1. finite {xs. subseq xs ys}", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. set xs \\<subseteq> set ys \\<and> length xs \\<le> length ys}", "by (intro finite_lists_length_le finite_set)"], ["proof (state)\nthis:\n  finite {xs. set xs \\<subseteq> set ys \\<and> length xs \\<le> length ys}\n\ngoal (1 subgoal):\n 1. finite {xs. subseq xs ys}", "ultimately"], ["proof (chain)\npicking this:\n  {xs. subseq xs ys}\n  \\<subseteq> {xs.\n               set xs \\<subseteq> set ys \\<and> length xs \\<le> length ys}\n  finite {xs. set xs \\<subseteq> set ys \\<and> length xs \\<le> length ys}", "show ?thesis"], ["proof (prove)\nusing this:\n  {xs. subseq xs ys}\n  \\<subseteq> {xs.\n               set xs \\<subseteq> set ys \\<and> length xs \\<le> length ys}\n  finite {xs. set xs \\<subseteq> set ys \\<and> length xs \\<le> length ys}\n\ngoal (1 subgoal):\n 1. finite {xs. subseq xs ys}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {xs. subseq xs ys}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subseq_singleton_right:\n  \"subseq xs [x] = (xs = [x] \\<or> xs = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq xs [x] = (xs = [x] \\<or> xs = [])", "by (cases xs; simp add: subseq_append_le_same_iff[of _ \"[]\", simplified])"], ["", "lemma subseq_append_single_right:\n  \"subseq xs (ys @ [x]) = ((\\<exists> xs'. subseq xs' ys \\<and> xs = xs' @ [x]) \\<or> subseq xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq xs (ys @ [x]) =\n    ((\\<exists>xs'. subseq xs' ys \\<and> xs = xs' @ [x]) \\<or> subseq xs ys)", "by (auto simp: subseq_append_iff subseq_singleton_right)"], ["", "(* TODO: Move, generalize *)"], ["", "lemma Max_nat_plus:\n  \"Max (((+) n) ` S) = (n :: nat) + Max S\" if \"finite S\" \"S \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max ((+) n ` S) = n + Max S", "using that"], ["proof (prove)\nusing this:\n  finite S\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max ((+) n ` S) = n + Max S", "by (auto intro!: Max_ge Max_in Max_eqI)"], ["", "subsubsection \\<open>Definitions\\<close>"], ["", "context\n  fixes A B :: \"'a list\"\nbegin"], ["", "fun lcs :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"lcs 0 _ = 0\" |\n  \"lcs _ 0 = 0\" |\n  \"lcs (Suc i) (Suc j) = (if A!i = B!j then 1 + lcs i j else max (lcs i (j + 1)) (lcs (i + 1) j))\""], ["", "definition \"OPT i j = Max {length xs | xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\""], ["", "lemma finite_OPT:\n  \"finite {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\" (is \"finite ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}", "have \"?S \\<subseteq> {xs. subseq xs (take i A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n    \\<subseteq> {xs. subseq xs (take i A)}", "by auto"], ["proof (state)\nthis:\n  {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n  \\<subseteq> {xs. subseq xs (take i A)}\n\ngoal (1 subgoal):\n 1. finite {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}", "moreover"], ["proof (state)\nthis:\n  {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n  \\<subseteq> {xs. subseq xs (take i A)}\n\ngoal (1 subgoal):\n 1. finite {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. subseq xs (take i A)}", "by (rule finite_subseq)"], ["proof (state)\nthis:\n  finite {xs. subseq xs (take i A)}\n\ngoal (1 subgoal):\n 1. finite {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}", "ultimately"], ["proof (chain)\npicking this:\n  {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n  \\<subseteq> {xs. subseq xs (take i A)}\n  finite {xs. subseq xs (take i A)}", "show ?thesis"], ["proof (prove)\nusing this:\n  {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n  \\<subseteq> {xs. subseq xs (take i A)}\n  finite {xs. subseq xs (take i A)}\n\ngoal (1 subgoal):\n 1. finite {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Correctness Proof\\<close>"], ["", "lemma non_empty_OPT:\n  \"{xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<noteq> {}", "by auto"], ["", "lemma OPT_0_left:\n  \"OPT 0 j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT 0 j = 0", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {length xs |xs. subseq xs (take 0 A) \\<and> subseq xs (take j B)} =\n    0", "by (simp add: subseq_append_le_same_iff[of _ \"[]\", simplified])"], ["", "lemma OPT_0_right:\n  \"OPT i 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT i 0 = 0", "unfolding OPT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take 0 B)} =\n    0", "by (simp add: subseq_append_le_same_iff[of _ \"[]\", simplified])"], ["", "lemma OPT_rec1:\n  \"OPT (i + 1) (j + 1) = 1 + OPT i j\" (is \"?l = ?r\")\n  if \"A!i = B!j\" \"i < length A\" \"j < length B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) = 1 + local.OPT i j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) = 1 + local.OPT i j", "let ?S = \"{length xs |xs. subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) = 1 + local.OPT i j", "let ?R = \"{length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) = 1 + local.OPT i j", "have \"?S = {length xs | xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n    \\<union> {length xs | xs. \\<exists> ys. subseq ys (take i A) \\<and> subseq ys (take j B) \\<and> xs = ys @ [B!i]}\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length xs |xs.\n     subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n    {length xs |xs.\n     subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n    {length xs |xs.\n     \\<exists>ys.\n        subseq ys (take i A) \\<and>\n        subseq ys (take j B) \\<and> xs = ys @ [B ! i]}", "using that"], ["proof (prove)\nusing this:\n  A ! i = B ! j\n  i < length A\n  j < length B\n\ngoal (1 subgoal):\n 1. {length xs |xs.\n     subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n    {length xs |xs.\n     subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n    {length xs |xs.\n     \\<exists>ys.\n        subseq ys (take i A) \\<and>\n        subseq ys (take j B) \\<and> xs = ys @ [B ! i]}", "apply (simp add: take_Suc_conv_app_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A ! i = B ! j; i < length A; j < length B\\<rbrakk>\n    \\<Longrightarrow> {length xs |xs.\n                       subseq xs (take i A @ [B ! j]) \\<and>\n                       subseq xs (take j B @ [B ! j])} =\n                      {length xs |xs.\n                       subseq xs (take i A) \\<and>\n                       subseq xs (take j B)} \\<union>\n                      {length xs |xs.\n                       \\<exists>ys.\n                          subseq ys (take i A) \\<and>\n                          subseq ys (take j B) \\<and> xs = ys @ [B ! i]}", "apply (simp add: subseq_append_single_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A ! i = B ! j; i < length A; j < length B\\<rbrakk>\n    \\<Longrightarrow> {length xs |xs.\n                       ((\\<exists>xs'.\n                            subseq xs' (take i A) \\<and>\n                            xs = xs' @ [B ! j]) \\<or>\n                        subseq xs (take i A)) \\<and>\n                       ((\\<exists>xs'.\n                            subseq xs' (take j B) \\<and>\n                            xs = xs' @ [B ! j]) \\<or>\n                        subseq xs (take j B))} =\n                      {length xs |xs.\n                       subseq xs (take i A) \\<and>\n                       subseq xs (take j B)} \\<union>\n                      {length xs |xs.\n                       \\<exists>ys.\n                          subseq ys (take i A) \\<and>\n                          subseq ys (take j B) \\<and> xs = ys @ [B ! i]}", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xs'a.\n       \\<lbrakk>A ! i = B ! j; i < length A; j < length B;\n        \\<forall>xs.\n           Suc (length xs'a) = length xs \\<longrightarrow>\n           (\\<forall>ys.\n               subseq ys (take j B) \\<longrightarrow>\n               subseq ys (take i A) \\<longrightarrow>\n               xs \\<noteq> ys @ [B ! i]);\n        subseq xs'a (take i A); subseq xs'a (take j B)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            Suc (length xs'a) = length xs \\<and>\n                            subseq xs (take i A) \\<and> subseq xs (take j B)\n 2. \\<And>xs'.\n       \\<lbrakk>A ! i = B ! j; i < length A; j < length B;\n        \\<forall>xs.\n           Suc (length xs') = length xs \\<longrightarrow>\n           (\\<forall>ys.\n               subseq ys (take j B) \\<longrightarrow>\n               subseq ys (take i A) \\<longrightarrow>\n               xs \\<noteq> ys @ [B ! i]);\n        subseq xs' (take i A); subseq (xs' @ [B ! j]) (take j B)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            Suc (length xs') = length xs \\<and>\n                            subseq xs (take i A) \\<and> subseq xs (take j B)\n 3. \\<And>xs'.\n       \\<lbrakk>A ! i = B ! j; i < length A; j < length B;\n        \\<forall>xs.\n           Suc (length xs') = length xs \\<longrightarrow>\n           (\\<forall>ys.\n               subseq ys (take j B) \\<longrightarrow>\n               subseq ys (take i A) \\<longrightarrow>\n               xs \\<noteq> ys @ [B ! i]);\n        subseq (xs' @ [B ! j]) (take i A); subseq xs' (take j B)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            Suc (length xs') = length xs \\<and>\n                            subseq xs (take i A) \\<and> subseq xs (take j B)\n 4. \\<And>ys.\n       \\<lbrakk>A ! i = B ! j; i < length A; j < length B;\n        subseq ys (take i A); subseq ys (take j B)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            Suc (length ys) = length xs \\<and>\n                            ((\\<exists>xs'.\n                                 subseq xs' (take i A) \\<and>\n                                 xs = xs' @ [B ! j]) \\<or>\n                             subseq xs (take i A)) \\<and>\n                            ((\\<exists>xs'.\n                                 subseq xs' (take j B) \\<and>\n                                 xs = xs' @ [B ! j]) \\<or>\n                             subseq xs (take j B))", "apply (metis length_append_singleton list_emb_prefix subseq_append)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {length xs |xs.\n   subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]}\n\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) = 1 + local.OPT i j", "moreover"], ["proof (state)\nthis:\n  {length xs |xs.\n   subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]}\n\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) = 1 + local.OPT i j", "have \"\\<dots> = {length xs | xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n    \\<union> {length xs + 1 | xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length xs |xs.\n     subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n    {length xs |xs.\n     \\<exists>ys.\n        subseq ys (take i A) \\<and>\n        subseq ys (take j B) \\<and> xs = ys @ [B ! i]} =\n    {length xs |xs.\n     subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n    {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}", "by force"], ["proof (state)\nthis:\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) = 1 + local.OPT i j", "moreover"], ["proof (state)\nthis:\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) = 1 + local.OPT i j", "have \"Max \\<dots> = Max ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max ({length xs |xs.\n          subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n         {length xs + 1 |xs.\n          subseq xs (take i A) \\<and> subseq xs (take j B)}) =\n    Max {length xs + 1 |xs.\n         subseq xs (take i A) \\<and> subseq xs (take j B)}", "using finite_OPT"], ["proof (prove)\nusing this:\n  finite {xs. subseq xs (take ?i A) \\<and> subseq xs (take ?j B)}\n\ngoal (1 subgoal):\n 1. Max ({length xs |xs.\n          subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n         {length xs + 1 |xs.\n          subseq xs (take i A) \\<and> subseq xs (take j B)}) =\n    Max {length xs + 1 |xs.\n         subseq xs (take i A) \\<and> subseq xs (take j B)}", "by - (rule Max_eq_if, auto)"], ["proof (state)\nthis:\n  Max ({length xs |xs.\n        subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n       {length xs + 1 |xs.\n        subseq xs (take i A) \\<and> subseq xs (take j B)}) =\n  Max {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) = 1 + local.OPT i j", "ultimately"], ["proof (chain)\npicking this:\n  {length xs |xs.\n   subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]}\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n  Max ({length xs |xs.\n        subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n       {length xs + 1 |xs.\n        subseq xs (take i A) \\<and> subseq xs (take j B)}) =\n  Max {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}", "show \"?l = ?r\""], ["proof (prove)\nusing this:\n  {length xs |xs.\n   subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]}\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n  Max ({length xs |xs.\n        subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n       {length xs + 1 |xs.\n        subseq xs (take i A) \\<and> subseq xs (take j B)}) =\n  Max {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) = 1 + local.OPT i j", "unfolding OPT_def"], ["proof (prove)\nusing this:\n  {length xs |xs.\n   subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]}\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n  Max ({length xs |xs.\n        subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n       {length xs + 1 |xs.\n        subseq xs (take i A) \\<and> subseq xs (take j B)}) =\n  Max {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n\ngoal (1 subgoal):\n 1. Max {length xs |xs.\n         subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n    1 +\n    Max {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}", "using finite_OPT non_empty_OPT"], ["proof (prove)\nusing this:\n  {length xs |xs.\n   subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]}\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs |xs.\n   \\<exists>ys.\n      subseq ys (take i A) \\<and>\n      subseq ys (take j B) \\<and> xs = ys @ [B ! i]} =\n  {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n  {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n  Max ({length xs |xs.\n        subseq xs (take i A) \\<and> subseq xs (take j B)} \\<union>\n       {length xs + 1 |xs.\n        subseq xs (take i A) \\<and> subseq xs (take j B)}) =\n  Max {length xs + 1 |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}\n  finite {xs. subseq xs (take ?i A) \\<and> subseq xs (take ?j B)}\n  {xs. subseq xs (take ?i A) \\<and> subseq xs (take ?j B)} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max {length xs |xs.\n         subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n    1 +\n    Max {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take j B)}", "by (subst Max_nat_plus[symmetric]) (auto simp: image_def intro: arg_cong[where f = Max])"], ["proof (state)\nthis:\n  local.OPT (i + 1) (j + 1) = 1 + local.OPT i j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OPT_rec2:\n  \"OPT (i + 1) (j + 1) = max (OPT i (j + 1)) (OPT (i + 1) j)\" (is \"?l = ?r\")\n  if \"A!i \\<noteq> B!j\" \"i < length A\" \"j < length B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) =\n    max (local.OPT i (j + 1)) (local.OPT (i + 1) j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) =\n    max (local.OPT i (j + 1)) (local.OPT (i + 1) j)", "have \"{length xs |xs. subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)}\n    = {length xs |xs. subseq xs (take i A) \\<and> subseq xs (take (j + 1) B)}\n    \\<union> {length xs |xs. subseq xs (take (i + 1) A) \\<and> subseq xs (take j B)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length xs |xs.\n     subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n    {length xs |xs.\n     subseq xs (take i A) \\<and> subseq xs (take (j + 1) B)} \\<union>\n    {length xs |xs. subseq xs (take (i + 1) A) \\<and> subseq xs (take j B)}", "using that"], ["proof (prove)\nusing this:\n  A ! i \\<noteq> B ! j\n  i < length A\n  j < length B\n\ngoal (1 subgoal):\n 1. {length xs |xs.\n     subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n    {length xs |xs.\n     subseq xs (take i A) \\<and> subseq xs (take (j + 1) B)} \\<union>\n    {length xs |xs. subseq xs (take (i + 1) A) \\<and> subseq xs (take j B)}", "by (auto simp: subseq_append_single_right take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  {length xs |xs.\n   subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n  {length xs |xs.\n   subseq xs (take i A) \\<and> subseq xs (take (j + 1) B)} \\<union>\n  {length xs |xs. subseq xs (take (i + 1) A) \\<and> subseq xs (take j B)}\n\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) =\n    max (local.OPT i (j + 1)) (local.OPT (i + 1) j)", "with finite_OPT non_empty_OPT"], ["proof (chain)\npicking this:\n  finite {xs. subseq xs (take ?i A) \\<and> subseq xs (take ?j B)}\n  {xs. subseq xs (take ?i A) \\<and> subseq xs (take ?j B)} \\<noteq> {}\n  {length xs |xs.\n   subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n  {length xs |xs.\n   subseq xs (take i A) \\<and> subseq xs (take (j + 1) B)} \\<union>\n  {length xs |xs. subseq xs (take (i + 1) A) \\<and> subseq xs (take j B)}", "show \"?l = ?r\""], ["proof (prove)\nusing this:\n  finite {xs. subseq xs (take ?i A) \\<and> subseq xs (take ?j B)}\n  {xs. subseq xs (take ?i A) \\<and> subseq xs (take ?j B)} \\<noteq> {}\n  {length xs |xs.\n   subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n  {length xs |xs.\n   subseq xs (take i A) \\<and> subseq xs (take (j + 1) B)} \\<union>\n  {length xs |xs. subseq xs (take (i + 1) A) \\<and> subseq xs (take j B)}\n\ngoal (1 subgoal):\n 1. local.OPT (i + 1) (j + 1) =\n    max (local.OPT i (j + 1)) (local.OPT (i + 1) j)", "unfolding OPT_def"], ["proof (prove)\nusing this:\n  finite {xs. subseq xs (take ?i A) \\<and> subseq xs (take ?j B)}\n  {xs. subseq xs (take ?i A) \\<and> subseq xs (take ?j B)} \\<noteq> {}\n  {length xs |xs.\n   subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n  {length xs |xs.\n   subseq xs (take i A) \\<and> subseq xs (take (j + 1) B)} \\<union>\n  {length xs |xs. subseq xs (take (i + 1) A) \\<and> subseq xs (take j B)}\n\ngoal (1 subgoal):\n 1. Max {length xs |xs.\n         subseq xs (take (i + 1) A) \\<and> subseq xs (take (j + 1) B)} =\n    max (Max {length xs |xs.\n              subseq xs (take i A) \\<and> subseq xs (take (j + 1) B)})\n     (Max {length xs |xs.\n           subseq xs (take (i + 1) A) \\<and> subseq xs (take j B)})", "by (simp) (rule Max_Un, auto)"], ["proof (state)\nthis:\n  local.OPT (i + 1) (j + 1) =\n  max (local.OPT i (j + 1)) (local.OPT (i + 1) j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lcs_correct':\n  \"OPT i j = lcs i j\" if \"i \\<le> length A\" \"j \\<le> length B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.OPT i j = local.lcs i j", "using that OPT_rec1 OPT_rec2"], ["proof (prove)\nusing this:\n  i \\<le> length A\n  j \\<le> length B\n  \\<lbrakk>A ! ?i = B ! ?j; ?i < length A; ?j < length B\\<rbrakk>\n  \\<Longrightarrow> local.OPT (?i + 1) (?j + 1) = 1 + local.OPT ?i ?j\n  \\<lbrakk>A ! ?i \\<noteq> B ! ?j; ?i < length A; ?j < length B\\<rbrakk>\n  \\<Longrightarrow> local.OPT (?i + 1) (?j + 1) =\n                    max (local.OPT ?i (?j + 1)) (local.OPT (?i + 1) ?j)\n\ngoal (1 subgoal):\n 1. local.OPT i j = local.lcs i j", "by (induction i j rule: lcs.induct; simp add: OPT_0_left OPT_0_right)"], ["", "theorem lcs_correct:\n  \"Max {length xs | xs. subseq xs A \\<and> subseq xs B} = lcs (length A) (length B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {length xs |xs. subseq xs A \\<and> subseq xs B} =\n    local.lcs (length A) (length B)", "by (simp add: OPT_def lcs_correct'[symmetric])"], ["", "end"], ["", "(* Fixed Lists *)"], ["", "subsubsection \\<open>Functional Memoization\\<close>"], ["", "context\n  fixes A B :: \"'a iarray\"\nbegin"], ["", "fun lcs_ia :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"lcs_ia 0 _ = 0\" |\n  \"lcs_ia _ 0 = 0\" |\n  \"lcs_ia (Suc i) (Suc j) =\n    (if A!!i = B!!j then 1 + lcs_ia i j else max (lcs_ia i (j + 1)) (lcs_ia (i + 1) j))\""], ["", "lemma lcs_lcs_ia:\n  \"lcs xs ys i j = lcs_ia i j\" if \"A = IArray xs\" \"B = IArray ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs xs ys i j = local.lcs_ia i j", "by (induction i j rule: lcs_ia.induct; simp; simp add: that)"], ["", "memoize_fun lcs\\<^sub>m: lcs_ia with_memory dp_consistency_mapping"], ["", "monadifies (state) lcs_ia.simps"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.lcs_ia x y)\n     (\\<lambda>(x, y). local.lcs\\<^sub>m' x y)", "by memoize_prover"], ["", "lemmas [code] = lcs\\<^sub>m.memoized_correct"], ["", "end"], ["", "subsubsection \\<open>Test Case\\<close>"], ["", "definition lcs\\<^sub>a where\n  \"lcs\\<^sub>a xs ys = (let A = IArray xs; B = IArray ys in lcs_ia A B (length xs) (length ys))\""], ["", "lemma lcs\\<^sub>a_correct:\n  \"lcs xs ys (length xs) (length ys) = lcs\\<^sub>a xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs xs ys (length xs) (length ys) = lcs\\<^sub>a xs ys", "unfolding lcs\\<^sub>a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs xs ys (length xs) (length ys) =\n    (let A = IArray xs; B = IArray ys in lcs_ia A B (length xs) (length ys))", "by (simp add: lcs_lcs_ia)"], ["", "value \"lcs\\<^sub>a ''ABCDGH'' ''AEDFHR''\""], ["", "value \"lcs\\<^sub>a ''AGGTAB'' ''GXTXAYB''\""], ["", "end"], ["", "(* Theory *)"]]}