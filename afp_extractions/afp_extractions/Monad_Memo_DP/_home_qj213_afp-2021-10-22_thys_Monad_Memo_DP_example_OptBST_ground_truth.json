{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/example/OptBST.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma argmin_forall: \"xs \\<noteq> [] \\<Longrightarrow> (\\<And>x. x\\<in>set xs \\<Longrightarrow> P x) \\<Longrightarrow> P (argmin f xs)\"", "lemma argmin_Min: \"xs \\<noteq> [] \\<Longrightarrow> f (argmin f xs) = Min (f ` set xs)\"", "lemma upto_join: \"\\<lbrakk> i \\<le> j; j \\<le> k \\<rbrakk> \\<Longrightarrow> [i..j-1] @ j # [j+1..k] = [i..k]\"", "lemma atLeastAtMost_split:\n  \"{i..j} = {i..k} \\<union> {k+1..j}\" if \"i \\<le> k\" \"k \\<le> j\" for i j k :: int", "lemma atLeastAtMost_split_insert:\n  \"{i..k} = insert k {i..k-1}\" if \"k \\<ge> i\" for i :: int", "lemmas memoized_empty = min_wpl\\<^sub>T.memoized_empty", "lemma min_wpl_heap:\n  \"min_wpl i j = result_of (min_wpl\\<^sub>h i j) Heap.empty\"", "lemmas [code] = min_wpl\\<^sub>m.memoized_correct", "lemmas [code] = opt_bst\\<^sub>m.memoized_correct", "lemma min_wpl_minimal:\n  \"inorder t = [i..j] \\<Longrightarrow> min_wpl i j \\<le> wpl i j t\"", "lemma opt_bst_correct: \"inorder (opt_bst (i,j)) = [i..j]\"", "lemma wpl_opt_bst: \"wpl i j (opt_bst (i,j)) = min_wpl i j\"", "lemma opt_bst_is_optimal:\n  \"inorder t = [i..j] \\<Longrightarrow> wpl i j (opt_bst (i,j)) \\<le> wpl i j t\"", "lemma W_rec:\n  \"W i j = (if j \\<ge> i then W i (j - 1) + p j else 0)\"", "lemma inorder_wpl_correct:\n  \"inorder t = [i..j] \\<Longrightarrow> wpl W i j t = cost t\"", "lemma opt_bst_has_optimal_cost:\n  \"inorder t = [i..j] \\<Longrightarrow> cost (opt_bst W (i,j)) \\<le> cost t\"", "lemma min_wpl_minimal_cost:\n  \"inorder t = [i..j] \\<Longrightarrow> min_wpl W i j \\<le> cost t\"", "lemma min_wpl_tree:\n  \"cost (opt_bst W (i,j)) = min_wpl W i j\"", "lemma [simp]:\n  \"the_fin 1 = 1\"", "lemma set_tree_depth:\n  assumes \"x \\<notin> set_tree t\"\n  shows \"depth x t = \\<infinity>\"", "lemma depth_inf_iff:\n  \"depth x t = \\<infinity> \\<longleftrightarrow> x \\<notin> set_tree t\"", "lemma depth_not_neg_inf[simp]:\n  \"depth x t = -\\<infinity> \\<longleftrightarrow> False\"", "lemma depth_FinD:\n  assumes \"x \\<in> set_tree t\"\n  obtains d where \"depth x t = Fin d\"", "lemma cost'_Leaf[simp]:\n  \"cost' Leaf = 0\"", "lemma cost'_Node:\n  \"distinct (inorder \\<langle>l, x, r\\<rangle>) \\<Longrightarrow>\n  cost' \\<langle>l, x, r\\<rangle> = sum p (set_tree l) + cost' l + p x + cost' r + sum p (set_tree r)\"", "lemma weight_correct:\n  \"distinct (inorder t) \\<Longrightarrow> cost' t = cost t\"", "lemma W_fun_correct:\n  \"W_fun i j = W i j\"", "lemmas W\\<^sub>m_crel = W\\<^sub>m.crel[unfolded W\\<^sub>m.consistentDP_def, THEN rel_funD,\n      of \"(m, x)\" \"(m, y)\" for m x y, unfolded prod.case]", "lemma compute_W_correct:\n  assumes \"Mapping.lookup (compute_W n) (i, j) = Some x\"\n  shows \"W i j = x\"", "lemma W_compute: \"W i j = (case Mapping.lookup (compute_W n) (i, j) of None \\<Rightarrow> W i j | Some x \\<Rightarrow> x)\"", "lemma min_wpl'_correct:\n  \"min_wpl' i j = min_wpl W i j\"", "lemma opt_bst'_correct:\n  \"opt_bst' i j = opt_bst W (i, j)\"", "lemma \"min_wpl (\\<lambda>i j. nat(i+j)) 0 4 = 10\"", "lemma \"opt_bst (\\<lambda>i j. nat(i+j)) (0, 4) = \\<langle>\\<langle>\\<langle>\\<langle>\\<langle>\\<langle>\\<rangle>, 0, \\<langle>\\<rangle>\\<rangle>, 1, \\<langle>\\<rangle>\\<rangle>, 2, \\<langle>\\<rangle>\\<rangle>, 3, \\<langle>\\<rangle>\\<rangle>, 4, \\<langle>\\<rangle>\\<rangle>\"", "lemma \"opt_bst' (list_to_p ex_p_1) 1 5 = opt_tree_1\""], "translations": [["", "lemma argmin_forall: \"xs \\<noteq> [] \\<Longrightarrow> (\\<And>x. x\\<in>set xs \\<Longrightarrow> P x) \\<Longrightarrow> P (argmin f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [];\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> P (argmin f xs)", "by(induction xs) (auto simp: Let_def)"], ["", "lemma argmin_Min: \"xs \\<noteq> [] \\<Longrightarrow> f (argmin f xs) = Min (f ` set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> f (argmin f xs) = Min (f ` set xs)", "by(induction xs) (auto simp: min_def intro!: antisym)"], ["", "subsubsection \\<open>Misc\\<close>"], ["", "lemma upto_join: \"\\<lbrakk> i \\<le> j; j \\<le> k \\<rbrakk> \\<Longrightarrow> [i..j-1] @ j # [j+1..k] = [i..k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [i..j - 1] @ j # [j + 1..k] = [i..k]", "using upto_rec1 upto_split1"], ["proof (prove)\nusing this:\n  ?i \\<le> ?j \\<Longrightarrow> [?i..?j] = ?i # [?i + 1..?j]\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> [?i..?k] = [?i..?j - 1] @ [?j..?k]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [i..j - 1] @ j # [j + 1..k] = [i..k]", "by auto"], ["", "lemma atLeastAtMost_split:\n  \"{i..j} = {i..k} \\<union> {k+1..j}\" if \"i \\<le> k\" \"k \\<le> j\" for i j k :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i..j} = {i..k} \\<union> {k + 1..j}", "using that"], ["proof (prove)\nusing this:\n  i \\<le> k\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. {i..j} = {i..k} \\<union> {k + 1..j}", "by auto"], ["", "lemma atLeastAtMost_split_insert:\n  \"{i..k} = insert k {i..k-1}\" if \"k \\<ge> i\" for i :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i..k} = insert k {i..k - 1}", "using that"], ["proof (prove)\nusing this:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. {i..k} = insert k {i..k - 1}", "by auto"], ["", "subsubsection \\<open>Definitions\\<close>"], ["", "context\nfixes W :: \"int \\<Rightarrow> int \\<Rightarrow> nat\"\nbegin"], ["", "fun wpl :: \"int \\<Rightarrow> int \\<Rightarrow> int tree \\<Rightarrow> nat\" where\n   \"wpl i j Leaf = 0\"\n | \"wpl i j (Node l k r) = wpl i (k-1) l + wpl (k+1) j r + W i j\""], ["", "function min_wpl :: \"int \\<Rightarrow> int \\<Rightarrow> nat\" where\n\"min_wpl i j =\n  (if i > j then 0\n   else min_list (map (\\<lambda>k. min_wpl i (k-1) + min_wpl (k+1) j + W i j) [i..j]))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if j < i then 0\n        else Example_Misc.min_list\n              (map (\\<lambda>k.\n                       min_wpl_sumC (i, k - 1) + min_wpl_sumC (k + 1, j) +\n                       W i j)\n                [i..j])) =\n       (if ja < ia then 0\n        else Example_Misc.min_list\n              (map (\\<lambda>k.\n                       min_wpl_sumC (ia, k - 1) + min_wpl_sumC (k + 1, ja) +\n                       W ia ja)\n                [ia..ja]))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All min_wpl_dom", "by (relation \"measure (\\<lambda>(i,j) . nat(j-i+1))\") auto"], ["", "declare min_wpl.simps[simp del]"], ["", "function opt_bst :: \"int * int \\<Rightarrow> int tree\" where\n\"opt_bst (i,j) =\n  (if i > j then Leaf else argmin (wpl i j) [\\<langle>opt_bst (i,k-1), k, opt_bst (k+1,j)\\<rangle>. k \\<leftarrow> [i..j]])\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if j < i then \\<langle>\\<rangle>\n        else argmin (local.wpl i j)\n              (map (\\<lambda>k.\n                       \\<langle>opt_bst_sumC (i, k - 1), k,\n                        opt_bst_sumC (k + 1, j)\\<rangle>)\n                [i..j])) =\n       (if ja < ia then \\<langle>\\<rangle>\n        else argmin (local.wpl ia ja)\n              (map (\\<lambda>k.\n                       \\<langle>opt_bst_sumC (ia, k - 1), k,\n                        opt_bst_sumC (k + 1, ja)\\<rangle>)\n                [ia..ja]))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All opt_bst_dom", "by (relation \"measure (\\<lambda>(i,j) . nat(j-i+1))\") auto"], ["", "declare opt_bst.simps[simp del]"], ["", "subsubsection \\<open>Functional Memoization\\<close>"], ["", "context\n  fixes n :: nat\nbegin"], ["", "context fixes\n  mem :: \"nat option array\"\nbegin"], ["", "memoize_fun min_wpl\\<^sub>T: min_wpl\n  with_memory dp_consistency_heap_default where bound = \"Bound (0, 0) (int n, int n)\" and mem=\"mem\""], ["", "monadifies (heap) min_wpl.simps"], ["", "context includes heap_monad_syntax begin"], ["", "thm min_wpl\\<^sub>T'.simps min_wpl\\<^sub>T_def"], ["", "end"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_wpl\\<^sub>T.consistentDP\n     (\\<lambda>(x, y). local.min_wpl\\<^sub>T' x y)", "by memoize_prover"], ["", "lemmas memoized_empty = min_wpl\\<^sub>T.memoized_empty"], ["", "end"], ["", "(* Fixed array *)"], ["", "context\n  includes heap_monad_syntax\n  notes [simp del] = min_wpl\\<^sub>T'.simps\nbegin"], ["", "definition \"min_wpl\\<^sub>h \\<equiv> \\<lambda> i j. Heap_Monad.bind (mem_empty (n * n)) (\\<lambda> mem. min_wpl\\<^sub>T' mem i j)\""], ["", "lemma min_wpl_heap:\n  \"min_wpl i j = result_of (min_wpl\\<^sub>h i j) Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min_wpl i j = result_of (local.min_wpl\\<^sub>h i j) Heap.empty", "unfolding min_wpl\\<^sub>h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min_wpl i j =\n    result_of\n     (mem_empty (n * n) \\<bind>\n      (\\<lambda>mem. local.min_wpl\\<^sub>T' mem i j))\n     Heap.empty", "using memoized_empty[of _ \"\\<lambda> m. \\<lambda> (a, b). min_wpl\\<^sub>T' m a b\" \"(i, j)\", OF min_wpl\\<^sub>T.crel]"], ["proof (prove)\nusing this:\n  ?mem =\n  result_of (mem_empty (bounded_index.size (Bound (0, 0) (int n, int n))))\n   Heap.empty \\<Longrightarrow>\n  (case (i, j) of (x, xa) \\<Rightarrow> local.min_wpl x xa) =\n  result_of\n   (mem_empty (bounded_index.size (Bound (0, 0) (int n, int n))) \\<bind>\n    (\\<lambda>mem.\n        case (i, j) of (a, b) \\<Rightarrow> local.min_wpl\\<^sub>T' mem a b))\n   Heap.empty\n\ngoal (1 subgoal):\n 1. local.min_wpl i j =\n    result_of\n     (mem_empty (n * n) \\<bind>\n      (\\<lambda>mem. local.min_wpl\\<^sub>T' mem i j))\n     Heap.empty", "by (simp add: index_size_defs)"], ["", "end"], ["", "end"], ["", "(* Bound *)"], ["", "context includes state_monad_syntax begin"], ["", "memoize_fun min_wpl\\<^sub>m: min_wpl with_memory dp_consistency_mapping"], ["", "monadifies (state) min_wpl.simps"], ["", "thm min_wpl\\<^sub>m'.simps"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.min_wpl x y)\n     (\\<lambda>(x, y). local.min_wpl\\<^sub>m' x y)", "by memoize_prover"], ["", "print_theorems"], ["", "lemmas [code] = min_wpl\\<^sub>m.memoized_correct"], ["", "memoize_fun opt_bst\\<^sub>m: opt_bst with_memory dp_consistency_mapping"], ["", "monadifies (state) opt_bst.simps"], ["", "thm opt_bst\\<^sub>m'.simps"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) local.opt_bst local.opt_bst\\<^sub>m'", "by memoize_prover"], ["", "print_theorems"], ["", "lemmas [code] = opt_bst\\<^sub>m.memoized_correct"], ["", "end"], ["", "subsubsection \\<open>Correctness Proof\\<close>"], ["", "lemma min_wpl_minimal:\n  \"inorder t = [i..j] \\<Longrightarrow> min_wpl i j \\<le> wpl i j t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder t = [i..j] \\<Longrightarrow>\n    local.min_wpl i j \\<le> local.wpl i j t", "proof(induction i j t rule: wpl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       inorder \\<langle>\\<rangle> = [i..j] \\<Longrightarrow>\n       local.min_wpl i j \\<le> local.wpl i j \\<langle>\\<rangle>\n 2. \\<And>i j l k r.\n       \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n                local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n        inorder r = [k + 1..j] \\<Longrightarrow>\n        local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n        inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> local.min_wpl i j\n                         \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "case (1 i j)"], ["proof (state)\nthis:\n  inorder \\<langle>\\<rangle> = [i..j]\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       inorder \\<langle>\\<rangle> = [i..j] \\<Longrightarrow>\n       local.min_wpl i j \\<le> local.wpl i j \\<langle>\\<rangle>\n 2. \\<And>i j l k r.\n       \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n                local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n        inorder r = [k + 1..j] \\<Longrightarrow>\n        local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n        inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> local.min_wpl i j\n                         \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "then"], ["proof (chain)\npicking this:\n  inorder \\<langle>\\<rangle> = [i..j]", "show ?case"], ["proof (prove)\nusing this:\n  inorder \\<langle>\\<rangle> = [i..j]\n\ngoal (1 subgoal):\n 1. local.min_wpl i j \\<le> local.wpl i j \\<langle>\\<rangle>", "by (simp add: min_wpl.simps)"], ["proof (state)\nthis:\n  local.min_wpl i j \\<le> local.wpl i j \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>i j l k r.\n       \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n                local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n        inorder r = [k + 1..j] \\<Longrightarrow>\n        local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n        inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> local.min_wpl i j\n                         \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j l k r.\n       \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n                local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n        inorder r = [k + 1..j] \\<Longrightarrow>\n        local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n        inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> local.min_wpl i j\n                         \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "case (2 i j l k r)"], ["proof (state)\nthis:\n  inorder l = [i..k - 1] \\<Longrightarrow>\n  local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l\n  inorder r = [k + 1..j] \\<Longrightarrow>\n  local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r\n  inorder \\<langle>l, k, r\\<rangle> = [i..j]\n\ngoal (1 subgoal):\n 1. \\<And>i j l k r.\n       \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n                local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n        inorder r = [k + 1..j] \\<Longrightarrow>\n        local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n        inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> local.min_wpl i j\n                         \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "then"], ["proof (chain)\npicking this:\n  inorder l = [i..k - 1] \\<Longrightarrow>\n  local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l\n  inorder r = [k + 1..j] \\<Longrightarrow>\n  local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r\n  inorder \\<langle>l, k, r\\<rangle> = [i..j]", "show ?case"], ["proof (prove)\nusing this:\n  inorder l = [i..k - 1] \\<Longrightarrow>\n  local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l\n  inorder r = [k + 1..j] \\<Longrightarrow>\n  local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r\n  inorder \\<langle>l, k, r\\<rangle> = [i..j]\n\ngoal (1 subgoal):\n 1. local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; ?P3\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n 2. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> ?P3\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; ?P3\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n 2. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> ?P3\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "by(simp add: min_wpl.simps)"], ["proof (state)\nthis:\n  local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "assume [arith]: \"\\<not> i > j\""], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have kk_ij: \"k\\<in>set[i..j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> set [i..j]", "using 2"], ["proof (prove)\nusing this:\n  inorder l = [i..k - 1] \\<Longrightarrow>\n  local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l\n  inorder r = [k + 1..j] \\<Longrightarrow>\n  local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r\n  inorder \\<langle>l, k, r\\<rangle> = [i..j]\n\ngoal (1 subgoal):\n 1. k \\<in> set [i..j]", "by (metis set_inorder tree.set_intros(2))"], ["proof (state)\nthis:\n  k \\<in> set [i..j]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "let ?M = \"((\\<lambda>k. min_wpl i (k-1) + min_wpl (k+1) j + W i j) ` {i..j})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "let ?w = \"min_wpl i (k-1) + min_wpl (k+1) j + W i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have aux_min:\"Min ?M \\<le> ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MIN k\\<in>{i..j}.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j)\n    \\<le> local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j", "proof (rule Min_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     ((\\<lambda>k.\n          local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) `\n      {i..j})\n 2. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n    \\<in> (\\<lambda>k.\n              local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) `\n          {i..j}", "show \"finite ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>k.\n          local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) `\n      {i..j})", "by simp"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>k.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) `\n    {i..j})\n\ngoal (1 subgoal):\n 1. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n    \\<in> (\\<lambda>k.\n              local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) `\n          {i..j}", "show \"?w \\<in> ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n    \\<in> (\\<lambda>k.\n              local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) `\n          {i..j}", "using kk_ij"], ["proof (prove)\nusing this:\n  k \\<in> set [i..j]\n\ngoal (1 subgoal):\n 1. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n    \\<in> (\\<lambda>k.\n              local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) `\n          {i..j}", "by auto"], ["proof (state)\nthis:\n  local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n  \\<in> (\\<lambda>k.\n            local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) `\n        {i..j}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j)\n  \\<le> local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have\"inorder \\<langle>l,k,r\\<rangle> = inorder l @k#inorder r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder \\<langle>l, k, r\\<rangle> = inorder l @ k # inorder r", "by auto"], ["proof (state)\nthis:\n  inorder \\<langle>l, k, r\\<rangle> = inorder l @ k # inorder r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "from this"], ["proof (chain)\npicking this:\n  inorder \\<langle>l, k, r\\<rangle> = inorder l @ k # inorder r", "have C:\"[i..j] = inorder l @ k#inorder r\""], ["proof (prove)\nusing this:\n  inorder \\<langle>l, k, r\\<rangle> = inorder l @ k # inorder r\n\ngoal (1 subgoal):\n 1. [i..j] = inorder l @ k # inorder r", "using 2"], ["proof (prove)\nusing this:\n  inorder \\<langle>l, k, r\\<rangle> = inorder l @ k # inorder r\n  inorder l = [i..k - 1] \\<Longrightarrow>\n  local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l\n  inorder r = [k + 1..j] \\<Longrightarrow>\n  local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r\n  inorder \\<langle>l, k, r\\<rangle> = [i..j]\n\ngoal (1 subgoal):\n 1. [i..j] = inorder l @ k # inorder r", "by auto"], ["proof (state)\nthis:\n  [i..j] = inorder l @ k # inorder r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have D: \"[i..j] = [i..k-1]@k#[k+1..j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i..j] = [i..k - 1] @ k # [k + 1..j]", "using kk_ij upto_rec1 upto_split1"], ["proof (prove)\nusing this:\n  k \\<in> set [i..j]\n  ?i \\<le> ?j \\<Longrightarrow> [?i..?j] = ?i # [?i + 1..?j]\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> [?i..?k] = [?i..?j - 1] @ [?j..?k]\n\ngoal (1 subgoal):\n 1. [i..j] = [i..k - 1] @ k # [k + 1..j]", "by (metis atLeastAtMost_iff set_upto)"], ["proof (state)\nthis:\n  [i..j] = [i..k - 1] @ k # [k + 1..j]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have l_inorder: \"inorder l = [i..k-1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder l = [i..k - 1]", "by (smt C D append_Cons_eq_iff atLeastAtMost_iff set_upto)"], ["proof (state)\nthis:\n  inorder l = [i..k - 1]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have r_inorder: \"inorder r = [k+1..j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder r = [k + 1..j]", "by (smt C D append_Cons_eq_iff atLeastAtMost_iff set_upto)"], ["proof (state)\nthis:\n  inorder r = [k + 1..j]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have \"min_wpl i j = Min ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min_wpl i j =\n    (MIN k\\<in>{i..j}.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j)", "by (simp add: min_wpl.simps min_list_Min)"], ["proof (state)\nthis:\n  local.min_wpl i j =\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "also"], ["proof (state)\nthis:\n  local.min_wpl i j =\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have \"... \\<le> ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MIN k\\<in>{i..j}.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j)\n    \\<le> local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j", "by (rule aux_min)"], ["proof (state)\nthis:\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j)\n  \\<le> local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "also"], ["proof (state)\nthis:\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j)\n  \\<le> local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have \"... \\<le> wpl i (k-1) l + wpl (k+1) j r + W i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n    \\<le> local.wpl i (k - 1) l + local.wpl (k + 1) j r + W i j", "using l_inorder r_inorder \"2.IH\""], ["proof (prove)\nusing this:\n  inorder l = [i..k - 1]\n  inorder r = [k + 1..j]\n  inorder l = [i..k - 1] \\<Longrightarrow>\n  local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l\n  inorder r = [k + 1..j] \\<Longrightarrow>\n  local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r\n\ngoal (1 subgoal):\n 1. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n    \\<le> local.wpl i (k - 1) l + local.wpl (k + 1) j r + W i j", "by simp"], ["proof (state)\nthis:\n  local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n  \\<le> local.wpl i (k - 1) l + local.wpl (k + 1) j r + W i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "also"], ["proof (state)\nthis:\n  local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j\n  \\<le> local.wpl i (k - 1) l + local.wpl (k + 1) j r + W i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have \"... = wpl i j \\<langle>l,k,r\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i (k - 1) l + local.wpl (k + 1) j r + W i j =\n    local.wpl i j \\<langle>l, k, r\\<rangle>", "by simp"], ["proof (state)\nthis:\n  local.wpl i (k - 1) l + local.wpl (k + 1) j r + W i j =\n  local.wpl i j \\<langle>l, k, r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "finally"], ["proof (chain)\npicking this:\n  local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n\ngoal (1 subgoal):\n 1. local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "."], ["proof (state)\nthis:\n  local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma opt_bst_correct: \"inorder (opt_bst (i,j)) = [i..j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (local.opt_bst (i, j)) = [i..j]", "by (induction \"(i,j)\" arbitrary: i j rule: opt_bst.induct)\n     (clarsimp simp: opt_bst.simps upto_join | rule argmin_forall)+"], ["", "lemma wpl_opt_bst: \"wpl i j (opt_bst (i,j)) = min_wpl i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "proof(induction i j rule: min_wpl.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> j < i; x \\<in> set [i..j]\\<rbrakk>\n                   \\<Longrightarrow> local.wpl i (x - 1)\n(local.opt_bst (i, x - 1)) =\n                                     local.min_wpl i (x - 1);\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; x \\<in> set [i..j]\\<rbrakk>\n           \\<Longrightarrow> local.wpl (x + 1) j\n                              (local.opt_bst (x + 1, j)) =\n                             local.min_wpl (x + 1) j\\<rbrakk>\n       \\<Longrightarrow> local.wpl i j (local.opt_bst (i, j)) =\n                         local.min_wpl i j", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> j < i; ?x2 \\<in> set [i..j]\\<rbrakk>\n  \\<Longrightarrow> local.wpl i (?x2 - 1) (local.opt_bst (i, ?x2 - 1)) =\n                    local.min_wpl i (?x2 - 1)\n  \\<lbrakk>\\<not> j < i; ?x2 \\<in> set [i..j]\\<rbrakk>\n  \\<Longrightarrow> local.wpl (?x2 + 1) j (local.opt_bst (?x2 + 1, j)) =\n                    local.min_wpl (?x2 + 1) j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> j < i; x \\<in> set [i..j]\\<rbrakk>\n                   \\<Longrightarrow> local.wpl i (x - 1)\n(local.opt_bst (i, x - 1)) =\n                                     local.min_wpl i (x - 1);\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; x \\<in> set [i..j]\\<rbrakk>\n           \\<Longrightarrow> local.wpl (x + 1) j\n                              (local.opt_bst (x + 1, j)) =\n                             local.min_wpl (x + 1) j\\<rbrakk>\n       \\<Longrightarrow> local.wpl i j (local.opt_bst (i, j)) =\n                         local.min_wpl i j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j\n 2. \\<not> ?P \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j\n 2. \\<not> ?P \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "by(simp add: min_wpl.simps opt_bst.simps)"], ["proof (state)\nthis:\n  local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "assume *[arith]: \"\\<not> i > j\""], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "let ?ts = \"[\\<langle>opt_bst (i,k-1), k, opt_bst (k+1,j)\\<rangle>. k <- [i..j]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "let ?M = \"((\\<lambda>k. min_wpl i (k-1) + min_wpl (k+1) j + W i j) ` {i..j})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "have \"?ts \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k.\n            \\<langle>local.opt_bst (i, k - 1), k,\n             local.opt_bst (k + 1, j)\\<rangle>)\n     [i..j] \\<noteq>\n    []", "by (auto simp add: upto.simps)"], ["proof (state)\nthis:\n  map (\\<lambda>k.\n          \\<langle>local.opt_bst (i, k - 1), k,\n           local.opt_bst (k + 1, j)\\<rangle>)\n   [i..j] \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "have \"wpl i j (opt_bst (i,j)) = wpl i j (argmin (wpl i j) ?ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i j (local.opt_bst (i, j)) =\n    local.wpl i j\n     (argmin (local.wpl i j)\n       (map (\\<lambda>k.\n                \\<langle>local.opt_bst (i, k - 1), k,\n                 local.opt_bst (k + 1, j)\\<rangle>)\n         [i..j]))", "by (simp add: opt_bst.simps)"], ["proof (state)\nthis:\n  local.wpl i j (local.opt_bst (i, j)) =\n  local.wpl i j\n   (argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst (i, k - 1), k,\n               local.opt_bst (k + 1, j)\\<rangle>)\n       [i..j]))\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "also"], ["proof (state)\nthis:\n  local.wpl i j (local.opt_bst (i, j)) =\n  local.wpl i j\n   (argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst (i, k - 1), k,\n               local.opt_bst (k + 1, j)\\<rangle>)\n       [i..j]))\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "have \"\\<dots> = Min (wpl i j ` (set ?ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i j\n     (argmin (local.wpl i j)\n       (map (\\<lambda>k.\n                \\<langle>local.opt_bst (i, k - 1), k,\n                 local.opt_bst (k + 1, j)\\<rangle>)\n         [i..j])) =\n    Min (local.wpl i j `\n         set (map (\\<lambda>k.\n                      \\<langle>local.opt_bst (i, k - 1), k,\n                       local.opt_bst (k + 1, j)\\<rangle>)\n               [i..j]))", "by (rule argmin_Min[OF \\<open>?ts \\<noteq> []\\<close>])"], ["proof (state)\nthis:\n  local.wpl i j\n   (argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst (i, k - 1), k,\n               local.opt_bst (k + 1, j)\\<rangle>)\n       [i..j])) =\n  Min (local.wpl i j `\n       set (map (\\<lambda>k.\n                    \\<langle>local.opt_bst (i, k - 1), k,\n                     local.opt_bst (k + 1, j)\\<rangle>)\n             [i..j]))\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "also"], ["proof (state)\nthis:\n  local.wpl i j\n   (argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst (i, k - 1), k,\n               local.opt_bst (k + 1, j)\\<rangle>)\n       [i..j])) =\n  Min (local.wpl i j `\n       set (map (\\<lambda>k.\n                    \\<langle>local.opt_bst (i, k - 1), k,\n                     local.opt_bst (k + 1, j)\\<rangle>)\n             [i..j]))\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "have \"\\<dots> = Min ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (local.wpl i j `\n         set (map (\\<lambda>k.\n                      \\<langle>local.opt_bst (i, k - 1), k,\n                       local.opt_bst (k + 1, j)\\<rangle>)\n               [i..j])) =\n    (MIN k\\<in>{i..j}.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j)", "proof (rule arg_cong[where f=Min])"], ["proof (state)\ngoal (1 subgoal):\n 1. local.wpl i j `\n    set (map (\\<lambda>k.\n                 \\<langle>local.opt_bst (i, k - 1), k,\n                  local.opt_bst (k + 1, j)\\<rangle>)\n          [i..j]) =\n    (\\<lambda>k.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) `\n    {i..j}", "show \"wpl i j ` (set ?ts) = ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i j `\n    set (map (\\<lambda>k.\n                 \\<langle>local.opt_bst (i, k - 1), k,\n                  local.opt_bst (k + 1, j)\\<rangle>)\n          [i..j]) =\n    (\\<lambda>k.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) `\n    {i..j}", "by (fastforce simp: Bex_def image_iff 1[OF *])"], ["proof (state)\nthis:\n  local.wpl i j `\n  set (map (\\<lambda>k.\n               \\<langle>local.opt_bst (i, k - 1), k,\n                local.opt_bst (k + 1, j)\\<rangle>)\n        [i..j]) =\n  (\\<lambda>k. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) `\n  {i..j}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (local.wpl i j `\n       set (map (\\<lambda>k.\n                    \\<langle>local.opt_bst (i, k - 1), k,\n                     local.opt_bst (k + 1, j)\\<rangle>)\n             [i..j])) =\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "also"], ["proof (state)\nthis:\n  Min (local.wpl i j `\n       set (map (\\<lambda>k.\n                    \\<langle>local.opt_bst (i, k - 1), k,\n                     local.opt_bst (k + 1, j)\\<rangle>)\n             [i..j])) =\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "have \"\\<dots> = min_wpl i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MIN k\\<in>{i..j}.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) =\n    local.min_wpl i j", "by (simp add: min_wpl.simps min_list_Min)"], ["proof (state)\nthis:\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + W i j) =\n  local.min_wpl i j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "finally"], ["proof (chain)\npicking this:\n  local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "show ?thesis"], ["proof (prove)\nusing this:\n  local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j\n\ngoal (1 subgoal):\n 1. local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j", "."], ["proof (state)\nthis:\n  local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.wpl i j (local.opt_bst (i, j)) = local.min_wpl i j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma opt_bst_is_optimal:\n  \"inorder t = [i..j] \\<Longrightarrow> wpl i j (opt_bst (i,j)) \\<le> wpl i j t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder t = [i..j] \\<Longrightarrow>\n    local.wpl i j (local.opt_bst (i, j)) \\<le> local.wpl i j t", "by (simp add: min_wpl_minimal wpl_opt_bst)"], ["", "end"], ["", "(* Weight function *)"], ["", "subsubsection \\<open>Access Frequencies\\<close>"], ["", "text \\<open>Usually, the problem is phrased in terms of access frequencies.\nWe now give an interpretation of @{term wpl} in this view and show that we have actually computed\nthe right thing.\\<close>"], ["", "context\n  \\<comment> \\<open>We are given a range \\<open>[i..j]\\<close> of integer keys with access frequencies \\<open>p\\<close>.\n  These can be thought of as a probability distribution but are not required to represent one.\n  This model assumes that the tree will contain all keys in the range \\<open>[i..j]\\<close>.\n  See \\<open>Optimal_BST\\<close> for a model with missing keys.\n  \\<close>\n  fixes p :: \"int \\<Rightarrow> nat\"\nbegin\n\n\\<comment> \\<open>The \\<^emph>\\<open>weighted path path length\\<close> (or \\<open>cost\\<close>) of a tree.\\<close>"], ["", "fun cost :: \"int tree \\<Rightarrow> nat\" where\n  \"cost Leaf = 0\"\n| \"cost (Node l k r) = sum p (set_tree l) + cost l + p k + cost r + sum p (set_tree r)\"\n\n\\<comment> \\<open>Deriving a weight function from \\<open>p\\<close>.\\<close>"], ["", "qualified"], ["", "definition W where\n  \"W i j = sum p {i..j}\"\n\n\\<comment> \\<open>We will use this later for computing \\<open>W\\<close> efficiently.\\<close>"], ["", "lemma W_rec:\n  \"W i j = (if j \\<ge> i then W i (j - 1) + p j else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W i j = (if i \\<le> j then W i (j - 1) + p j else 0)", "unfolding W_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum p {i..j} = (if i \\<le> j then sum p {i..j - 1} + p j else 0)", "by (simp add: atLeastAtMost_split_insert)\n\n\\<comment> \\<open>The weight function correctly implements costs.\\<close>"], ["", "lemma inorder_wpl_correct:\n  \"inorder t = [i..j] \\<Longrightarrow> wpl W i j t = cost t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder t = [i..j] \\<Longrightarrow> wpl W i j t = local.cost t", "proof (induction t arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       inorder \\<langle>\\<rangle> = [i..j] \\<Longrightarrow>\n       wpl W i j \\<langle>\\<rangle> = local.cost \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2 i j.\n       \\<lbrakk>\\<And>i j.\n                   inorder t1 = [i..j] \\<Longrightarrow>\n                   wpl W i j t1 = local.cost t1;\n        \\<And>i j.\n           inorder t2 = [i..j] \\<Longrightarrow>\n           wpl W i j t2 = local.cost t2;\n        inorder \\<langle>t1, x2, t2\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> wpl W i j \\<langle>t1, x2, t2\\<rangle> =\n                         local.cost \\<langle>t1, x2, t2\\<rangle>", "case Leaf"], ["proof (state)\nthis:\n  inorder \\<langle>\\<rangle> = [i..j]\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       inorder \\<langle>\\<rangle> = [i..j] \\<Longrightarrow>\n       wpl W i j \\<langle>\\<rangle> = local.cost \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2 i j.\n       \\<lbrakk>\\<And>i j.\n                   inorder t1 = [i..j] \\<Longrightarrow>\n                   wpl W i j t1 = local.cost t1;\n        \\<And>i j.\n           inorder t2 = [i..j] \\<Longrightarrow>\n           wpl W i j t2 = local.cost t2;\n        inorder \\<langle>t1, x2, t2\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> wpl W i j \\<langle>t1, x2, t2\\<rangle> =\n                         local.cost \\<langle>t1, x2, t2\\<rangle>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wpl W i j \\<langle>\\<rangle> = local.cost \\<langle>\\<rangle>", "by simp"], ["proof (state)\nthis:\n  wpl W i j \\<langle>\\<rangle> = local.cost \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2 i j.\n       \\<lbrakk>\\<And>i j.\n                   inorder t1 = [i..j] \\<Longrightarrow>\n                   wpl W i j t1 = local.cost t1;\n        \\<And>i j.\n           inorder t2 = [i..j] \\<Longrightarrow>\n           wpl W i j t2 = local.cost t2;\n        inorder \\<langle>t1, x2, t2\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> wpl W i j \\<langle>t1, x2, t2\\<rangle> =\n                         local.cost \\<langle>t1, x2, t2\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2 i j.\n       \\<lbrakk>\\<And>i j.\n                   inorder t1 = [i..j] \\<Longrightarrow>\n                   wpl W i j t1 = local.cost t1;\n        \\<And>i j.\n           inorder t2 = [i..j] \\<Longrightarrow>\n           wpl W i j t2 = local.cost t2;\n        inorder \\<langle>t1, x2, t2\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> wpl W i j \\<langle>t1, x2, t2\\<rangle> =\n                         local.cost \\<langle>t1, x2, t2\\<rangle>", "case (Node l k r)"], ["proof (state)\nthis:\n  inorder l = [?i..?j] \\<Longrightarrow> wpl W ?i ?j l = local.cost l\n  inorder r = [?i..?j] \\<Longrightarrow> wpl W ?i ?j r = local.cost r\n  inorder \\<langle>l, k, r\\<rangle> = [i..j]\n\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2 i j.\n       \\<lbrakk>\\<And>i j.\n                   inorder t1 = [i..j] \\<Longrightarrow>\n                   wpl W i j t1 = local.cost t1;\n        \\<And>i j.\n           inorder t2 = [i..j] \\<Longrightarrow>\n           wpl W i j t2 = local.cost t2;\n        inorder \\<langle>t1, x2, t2\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> wpl W i j \\<langle>t1, x2, t2\\<rangle> =\n                         local.cost \\<langle>t1, x2, t2\\<rangle>", "from \\<open>inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<close>"], ["proof (chain)\npicking this:\n  inorder \\<langle>l, k, r\\<rangle> = [i..j]", "have *: \"i \\<le> k\" \"k \\<le> j\""], ["proof (prove)\nusing this:\n  inorder \\<langle>l, k, r\\<rangle> = [i..j]\n\ngoal (1 subgoal):\n 1. i \\<le> k &&& k \\<le> j", "by - (simp, metis atLeastAtMost_iff in_set_conv_decomp set_upto)+"], ["proof (state)\nthis:\n  i \\<le> k\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2 i j.\n       \\<lbrakk>\\<And>i j.\n                   inorder t1 = [i..j] \\<Longrightarrow>\n                   wpl W i j t1 = local.cost t1;\n        \\<And>i j.\n           inorder t2 = [i..j] \\<Longrightarrow>\n           wpl W i j t2 = local.cost t2;\n        inorder \\<langle>t1, x2, t2\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> wpl W i j \\<langle>t1, x2, t2\\<rangle> =\n                         local.cost \\<langle>t1, x2, t2\\<rangle>", "moreover"], ["proof (state)\nthis:\n  i \\<le> k\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2 i j.\n       \\<lbrakk>\\<And>i j.\n                   inorder t1 = [i..j] \\<Longrightarrow>\n                   wpl W i j t1 = local.cost t1;\n        \\<And>i j.\n           inorder t2 = [i..j] \\<Longrightarrow>\n           wpl W i j t2 = local.cost t2;\n        inorder \\<langle>t1, x2, t2\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> wpl W i j \\<langle>t1, x2, t2\\<rangle> =\n                         local.cost \\<langle>t1, x2, t2\\<rangle>", "from \\<open>i \\<le> k\\<close> \\<open>k \\<le> j\\<close>"], ["proof (chain)\npicking this:\n  i \\<le> k\n  k \\<le> j", "have \"inorder l = [i..k-1]\" \"inorder r = [k+1..j]\""], ["proof (prove)\nusing this:\n  i \\<le> k\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. inorder l = [i..k - 1] &&& inorder r = [k + 1..j]", "using \\<open>inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<close>[symmetric]"], ["proof (prove)\nusing this:\n  i \\<le> k\n  k \\<le> j\n  [i..j] = inorder \\<langle>l, k, r\\<rangle>\n\ngoal (1 subgoal):\n 1. inorder l = [i..k - 1] &&& inorder r = [k + 1..j]", "by (simp add: upto_split3 append_Cons_eq_iff)+"], ["proof (state)\nthis:\n  inorder l = [i..k - 1]\n  inorder r = [k + 1..j]\n\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2 i j.\n       \\<lbrakk>\\<And>i j.\n                   inorder t1 = [i..j] \\<Longrightarrow>\n                   wpl W i j t1 = local.cost t1;\n        \\<And>i j.\n           inorder t2 = [i..j] \\<Longrightarrow>\n           wpl W i j t2 = local.cost t2;\n        inorder \\<langle>t1, x2, t2\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> wpl W i j \\<langle>t1, x2, t2\\<rangle> =\n                         local.cost \\<langle>t1, x2, t2\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  i \\<le> k\n  k \\<le> j\n  inorder l = [i..k - 1]\n  inorder r = [k + 1..j]", "show ?case"], ["proof (prove)\nusing this:\n  i \\<le> k\n  k \\<le> j\n  inorder l = [i..k - 1]\n  inorder r = [k + 1..j]\n\ngoal (1 subgoal):\n 1. wpl W i j \\<langle>l, k, r\\<rangle> =\n    local.cost \\<langle>l, k, r\\<rangle>", "by (simp add: Node.IH, subst W_def, subst atLeastAtMost_split)\n       (simp add: sum.union_disjoint atLeastAtMost_split_insert flip: set_inorder)+"], ["proof (state)\nthis:\n  wpl W i j \\<langle>l, k, r\\<rangle> = local.cost \\<langle>l, k, r\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The optimal binary search tree has minimal cost among all binary search trees.\\<close>"], ["", "lemma opt_bst_has_optimal_cost:\n  \"inorder t = [i..j] \\<Longrightarrow> cost (opt_bst W (i,j)) \\<le> cost t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder t = [i..j] \\<Longrightarrow>\n    local.cost (opt_bst W (i, j)) \\<le> local.cost t", "using inorder_wpl_correct opt_bst_is_optimal opt_bst_correct"], ["proof (prove)\nusing this:\n  inorder ?t = [?i..?j] \\<Longrightarrow> wpl W ?i ?j ?t = local.cost ?t\n  inorder ?t = [?i..?j] \\<Longrightarrow>\n  wpl ?W ?i ?j (opt_bst ?W (?i, ?j)) \\<le> wpl ?W ?i ?j ?t\n  inorder (opt_bst ?W (?i, ?j)) = [?i..?j]\n\ngoal (1 subgoal):\n 1. inorder t = [i..j] \\<Longrightarrow>\n    local.cost (opt_bst W (i, j)) \\<le> local.cost t", "by metis"], ["", "text \\<open>\n  The function @{term min_wpl} correctly computes the minimal cost among all binary search trees:\n  \\<^item> Its cost is a lower bound for the cost of all binary search trees\n  \\<^item> Its cost actually corresponds to an optimal binary search tree\n\\<close>"], ["", "lemma min_wpl_minimal_cost:\n  \"inorder t = [i..j] \\<Longrightarrow> min_wpl W i j \\<le> cost t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder t = [i..j] \\<Longrightarrow> min_wpl W i j \\<le> local.cost t", "using inorder_wpl_correct min_wpl_minimal"], ["proof (prove)\nusing this:\n  inorder ?t = [?i..?j] \\<Longrightarrow> wpl W ?i ?j ?t = local.cost ?t\n  inorder ?t = [?i..?j] \\<Longrightarrow>\n  min_wpl ?W ?i ?j \\<le> wpl ?W ?i ?j ?t\n\ngoal (1 subgoal):\n 1. inorder t = [i..j] \\<Longrightarrow> min_wpl W i j \\<le> local.cost t", "by metis"], ["", "lemma min_wpl_tree:\n  \"cost (opt_bst W (i,j)) = min_wpl W i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.cost (opt_bst W (i, j)) = min_wpl W i j", "using wpl_opt_bst opt_bst_correct inorder_wpl_correct"], ["proof (prove)\nusing this:\n  wpl ?W ?i ?j (opt_bst ?W (?i, ?j)) = min_wpl ?W ?i ?j\n  inorder (opt_bst ?W (?i, ?j)) = [?i..?j]\n  inorder ?t = [?i..?j] \\<Longrightarrow> wpl W ?i ?j ?t = local.cost ?t\n\ngoal (1 subgoal):\n 1. local.cost (opt_bst W (i, j)) = min_wpl W i j", "by metis"], ["", "paragraph \\<open>An alternative view of costs.\\<close>"], ["", "fun depth :: \"'a \\<Rightarrow> 'a tree \\<Rightarrow> nat extended\" where\n  \"depth x Leaf = \\<infinity>\"\n| \"depth x (Node l k r) = (if x = k then 1 else min (depth x l) (depth x r) + 1)\""], ["", "fun the_fin where\n  \"the_fin (Fin x) = x\" | \"the_fin _ = undefined\""], ["", "definition cost' :: \"int tree \\<Rightarrow> nat\" where\n  \"cost' t = sum (\\<lambda>x. the_fin (depth x t) * p x) (set_tree t)\""], ["", "lemma [simp]:\n  \"the_fin 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_fin 1 = (1::'a)", "by (simp add: one_extended_def)"], ["", "lemma set_tree_depth:\n  assumes \"x \\<notin> set_tree t\"\n  shows \"depth x t = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. depth x t = \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> set_tree t\n\ngoal (1 subgoal):\n 1. depth x t = \\<infinity>", "by (induction t) auto"], ["", "lemma depth_inf_iff:\n  \"depth x t = \\<infinity> \\<longleftrightarrow> x \\<notin> set_tree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (depth x t = \\<infinity>) = (x \\<notin> set_tree t)", "apply (induction t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (depth x \\<langle>\\<rangle> = \\<infinity>) =\n    (x \\<notin> set_tree \\<langle>\\<rangle>)\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>(depth x t1 = \\<infinity>) = (x \\<notin> set_tree t1);\n        (depth x t2 = \\<infinity>) = (x \\<notin> set_tree t2)\\<rbrakk>\n       \\<Longrightarrow> (depth x \\<langle>t1, x2, t2\\<rangle> =\n                          \\<infinity>) =\n                         (x \\<notin> set_tree \\<langle>t1, x2, t2\\<rangle>)", "apply (auto simp: one_extended_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>x \\<noteq> x2; depth x t1 = \\<infinity>;\n        x \\<notin> set_tree t1; depth x t2 \\<noteq> \\<infinity>;\n        depth x t2 + Fin (Suc 0) = \\<infinity>; x \\<in> set_tree t2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>x \\<noteq> x2; depth x t1 \\<noteq> \\<infinity>;\n        depth x t2 = \\<infinity>; x \\<notin> set_tree t2;\n        depth x t1 + Fin (Suc 0) = \\<infinity>; x \\<in> set_tree t1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>t1 x2 t2.\n       \\<lbrakk>x \\<noteq> x2; depth x t1 \\<noteq> \\<infinity>;\n        depth x t2 \\<noteq> \\<infinity>; x \\<in> set_tree t2;\n        min (depth x t1) (depth x t2) + Fin (Suc 0) = \\<infinity>;\n        x \\<in> set_tree t1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>t1 x2 t2.\n       \\<lbrakk>x \\<noteq> x2; depth x t1 \\<noteq> \\<infinity>;\n        x \\<in> set_tree t1; depth x t2 \\<noteq> \\<infinity>;\n        min (depth x t1) (depth x t2) + Fin (Suc 0) = \\<infinity>;\n        x \\<in> set_tree t2\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for t1 k t2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> k; depth x t1 = \\<infinity>; x \\<notin> set_tree t1;\n     depth x t2 \\<noteq> \\<infinity>;\n     depth x t2 + Fin (Suc 0) = \\<infinity>; x \\<in> set_tree t2\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases \"depth x t1\"; cases \"depth x t2\") auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>x \\<noteq> x2; depth x t1 \\<noteq> \\<infinity>;\n        depth x t2 = \\<infinity>; x \\<notin> set_tree t2;\n        depth x t1 + Fin (Suc 0) = \\<infinity>; x \\<in> set_tree t1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>x \\<noteq> x2; depth x t1 \\<noteq> \\<infinity>;\n        depth x t2 \\<noteq> \\<infinity>; x \\<in> set_tree t2;\n        min (depth x t1) (depth x t2) + Fin (Suc 0) = \\<infinity>;\n        x \\<in> set_tree t1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>t1 x2 t2.\n       \\<lbrakk>x \\<noteq> x2; depth x t1 \\<noteq> \\<infinity>;\n        x \\<in> set_tree t1; depth x t2 \\<noteq> \\<infinity>;\n        min (depth x t1) (depth x t2) + Fin (Suc 0) = \\<infinity>;\n        x \\<in> set_tree t2\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for t1 k t2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> k; depth x t1 \\<noteq> \\<infinity>;\n     depth x t2 = \\<infinity>; x \\<notin> set_tree t2;\n     depth x t1 + Fin (Suc 0) = \\<infinity>; x \\<in> set_tree t1\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases \"depth x t1\"; cases \"depth x t2\") auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>x \\<noteq> x2; depth x t1 \\<noteq> \\<infinity>;\n        depth x t2 \\<noteq> \\<infinity>; x \\<in> set_tree t2;\n        min (depth x t1) (depth x t2) + Fin (Suc 0) = \\<infinity>;\n        x \\<in> set_tree t1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>x \\<noteq> x2; depth x t1 \\<noteq> \\<infinity>;\n        x \\<in> set_tree t1; depth x t2 \\<noteq> \\<infinity>;\n        min (depth x t1) (depth x t2) + Fin (Suc 0) = \\<infinity>;\n        x \\<in> set_tree t2\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for t1 k t2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> k; depth x t1 \\<noteq> \\<infinity>;\n     depth x t2 \\<noteq> \\<infinity>; x \\<in> set_tree t2;\n     min (depth x t1) (depth x t2) + Fin (Suc 0) = \\<infinity>;\n     x \\<in> set_tree t1\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases \"depth x t1\"; cases \"depth x t2\") auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>x \\<noteq> x2; depth x t1 \\<noteq> \\<infinity>;\n        x \\<in> set_tree t1; depth x t2 \\<noteq> \\<infinity>;\n        min (depth x t1) (depth x t2) + Fin (Suc 0) = \\<infinity>;\n        x \\<in> set_tree t2\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for t1 k t2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> k; depth x t1 \\<noteq> \\<infinity>;\n     x \\<in> set_tree t1; depth x t2 \\<noteq> \\<infinity>;\n     min (depth x t1) (depth x t2) + Fin (Suc 0) = \\<infinity>;\n     x \\<in> set_tree t2\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases \"depth x t1\"; cases \"depth x t2\") auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma depth_not_neg_inf[simp]:\n  \"depth x t = -\\<infinity> \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (depth x t = -\\<infinity>) = False", "apply (induction t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (depth x \\<langle>\\<rangle> = -\\<infinity>) = False\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>(depth x t1 = -\\<infinity>) = False;\n        (depth x t2 = -\\<infinity>) = False\\<rbrakk>\n       \\<Longrightarrow> (depth x \\<langle>t1, x2, t2\\<rangle> =\n                          -\\<infinity>) =\n                         False", "apply (auto simp: one_extended_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2.\n       \\<lbrakk>depth x t1 \\<noteq> -\\<infinity>;\n        depth x t2 \\<noteq> -\\<infinity>; x \\<noteq> x2;\n        min (depth x t1) (depth x t2) + Fin (Suc 0) = -\\<infinity>\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for t1 k t2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>depth x t1 \\<noteq> -\\<infinity>;\n     depth x t2 \\<noteq> -\\<infinity>; x \\<noteq> k;\n     min (depth x t1) (depth x t2) + Fin (Suc 0) = -\\<infinity>\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases \"depth x t1\"; cases \"depth x t2\") auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma depth_FinD:\n  assumes \"x \\<in> set_tree t\"\n  obtains d where \"depth x t = Fin d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d. depth x t = Fin d \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set_tree t\n\ngoal (1 subgoal):\n 1. (\\<And>d. depth x t = Fin d \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"depth x t\") (auto simp: depth_inf_iff)"], ["", "lemma cost'_Leaf[simp]:\n  \"cost' Leaf = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.cost' \\<langle>\\<rangle> = 0", "unfolding cost'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       the_fin (depth x \\<langle>\\<rangle>) * p x) =\n    0", "by simp"], ["", "lemma cost'_Node:\n  \"distinct (inorder \\<langle>l, x, r\\<rangle>) \\<Longrightarrow>\n  cost' \\<langle>l, x, r\\<rangle> = sum p (set_tree l) + cost' l + p x + cost' r + sum p (set_tree r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (inorder \\<langle>l, x, r\\<rangle>) \\<Longrightarrow>\n    local.cost' \\<langle>l, x, r\\<rangle> =\n    sum p (set_tree l) + local.cost' l + p x + local.cost' r +\n    sum p (set_tree r)", "unfolding cost'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (inorder \\<langle>l, x, r\\<rangle>) \\<Longrightarrow>\n    (\\<Sum>xa\\<in>set_tree \\<langle>l, x, r\\<rangle>.\n       the_fin (depth xa \\<langle>l, x, r\\<rangle>) * p xa) =\n    sum p (set_tree l) +\n    (\\<Sum>x\\<in>set_tree l. the_fin (depth x l) * p x) +\n    p x +\n    (\\<Sum>x\\<in>set_tree r. the_fin (depth x r) * p x) +\n    sum p (set_tree r)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (inorder l) \\<and>\n    x \\<notin> set_tree r \\<and>\n    distinct (inorder r) \\<and>\n    x \\<notin> set_tree l \\<and>\n    set_tree l \\<inter> set_tree r = {} \\<Longrightarrow>\n    (\\<Sum>xa\\<in>set_tree l \\<union> set_tree r.\n       the_fin (if xa = x then 1 else min (depth xa l) (depth xa r) + 1) *\n       p xa) =\n    sum p (set_tree l) +\n    ((\\<Sum>x\\<in>set_tree l. the_fin (depth x l) * p x) +\n     ((\\<Sum>x\\<in>set_tree r. the_fin (depth x r) * p x) +\n      sum p (set_tree r)))", "apply (subst sum.union_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. distinct (inorder l) \\<and>\n    x \\<notin> set_tree r \\<and>\n    distinct (inorder r) \\<and>\n    x \\<notin> set_tree l \\<and>\n    set_tree l \\<inter> set_tree r = {} \\<Longrightarrow>\n    finite (set_tree l)\n 2. distinct (inorder l) \\<and>\n    x \\<notin> set_tree r \\<and>\n    distinct (inorder r) \\<and>\n    x \\<notin> set_tree l \\<and>\n    set_tree l \\<inter> set_tree r = {} \\<Longrightarrow>\n    finite (set_tree r)\n 3. distinct (inorder l) \\<and>\n    x \\<notin> set_tree r \\<and>\n    distinct (inorder r) \\<and>\n    x \\<notin> set_tree l \\<and>\n    set_tree l \\<inter> set_tree r = {} \\<Longrightarrow>\n    set_tree l \\<inter> set_tree r = {}\n 4. distinct (inorder l) \\<and>\n    x \\<notin> set_tree r \\<and>\n    distinct (inorder r) \\<and>\n    x \\<notin> set_tree l \\<and>\n    set_tree l \\<inter> set_tree r = {} \\<Longrightarrow>\n    (\\<Sum>xa\\<in>set_tree l.\n       the_fin (if xa = x then 1 else min (depth xa l) (depth xa r) + 1) *\n       p xa) +\n    (\\<Sum>xa\\<in>set_tree r.\n       the_fin (if xa = x then 1 else min (depth xa l) (depth xa r) + 1) *\n       p xa) =\n    sum p (set_tree l) +\n    ((\\<Sum>x\\<in>set_tree l. the_fin (depth x l) * p x) +\n     ((\\<Sum>x\\<in>set_tree r. the_fin (depth x r) * p x) +\n      sum p (set_tree r)))", "apply (simp; fail)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (inorder l) \\<and>\n    x \\<notin> set_tree r \\<and>\n    distinct (inorder r) \\<and>\n    x \\<notin> set_tree l \\<and>\n    set_tree l \\<inter> set_tree r = {} \\<Longrightarrow>\n    (\\<Sum>xa\\<in>set_tree l.\n       the_fin (if xa = x then 1 else min (depth xa l) (depth xa r) + 1) *\n       p xa) +\n    (\\<Sum>xa\\<in>set_tree r.\n       the_fin (if xa = x then 1 else min (depth xa l) (depth xa r) + 1) *\n       p xa) =\n    sum p (set_tree l) +\n    ((\\<Sum>x\\<in>set_tree l. the_fin (depth x l) * p x) +\n     ((\\<Sum>x\\<in>set_tree r. the_fin (depth x r) * p x) +\n      sum p (set_tree r)))", "apply (subst sum.cong[OF HOL.refl, where h = \"\\<lambda>x. (the_fin (depth x l) + 1) * p x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>distinct (inorder l) \\<and>\n                x \\<notin> set_tree r \\<and>\n                distinct (inorder r) \\<and>\n                x \\<notin> set_tree l \\<and>\n                set_tree l \\<inter> set_tree r = {};\n        xa \\<in> set_tree l\\<rbrakk>\n       \\<Longrightarrow> the_fin\n                          (if xa = x then 1\n                           else min (depth xa l) (depth xa r) + 1) *\n                         p xa =\n                         (the_fin (depth xa l) + 1) * p xa\n 2. distinct (inorder l) \\<and>\n    x \\<notin> set_tree r \\<and>\n    distinct (inorder r) \\<and>\n    x \\<notin> set_tree l \\<and>\n    set_tree l \\<inter> set_tree r = {} \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree l. (the_fin (depth x l) + 1) * p x) +\n    (\\<Sum>xa\\<in>set_tree r.\n       the_fin (if xa = x then 1 else min (depth xa l) (depth xa r) + 1) *\n       p xa) =\n    sum p (set_tree l) +\n    ((\\<Sum>x\\<in>set_tree l. the_fin (depth x l) * p x) +\n     ((\\<Sum>x\\<in>set_tree r. the_fin (depth x r) * p x) +\n      sum p (set_tree r)))", "subgoal for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (inorder l) \\<and>\n             x \\<notin> set_tree r \\<and>\n             distinct (inorder r) \\<and>\n             x \\<notin> set_tree l \\<and>\n             set_tree l \\<inter> set_tree r = {};\n     k \\<in> set_tree l\\<rbrakk>\n    \\<Longrightarrow> the_fin\n                       (if k = x then 1\n                        else min (depth k l) (depth k r) + 1) *\n                      p k =\n                      (the_fin (depth k l) + 1) * p k", "using set_tree_depth"], ["proof (prove)\nusing this:\n  ?x \\<notin> set_tree ?t \\<Longrightarrow> depth ?x ?t = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (inorder l) \\<and>\n             x \\<notin> set_tree r \\<and>\n             distinct (inorder r) \\<and>\n             x \\<notin> set_tree l \\<and>\n             set_tree l \\<inter> set_tree r = {};\n     k \\<in> set_tree l\\<rbrakk>\n    \\<Longrightarrow> the_fin\n                       (if k = x then 1\n                        else min (depth k l) (depth k r) + 1) *\n                      p k =\n                      (the_fin (depth k l) + 1) * p k", "by (force simp: one_extended_def elim: depth_FinD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (inorder l) \\<and>\n    x \\<notin> set_tree r \\<and>\n    distinct (inorder r) \\<and>\n    x \\<notin> set_tree l \\<and>\n    set_tree l \\<inter> set_tree r = {} \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree l. (the_fin (depth x l) + 1) * p x) +\n    (\\<Sum>xa\\<in>set_tree r.\n       the_fin (if xa = x then 1 else min (depth xa l) (depth xa r) + 1) *\n       p xa) =\n    sum p (set_tree l) +\n    ((\\<Sum>x\\<in>set_tree l. the_fin (depth x l) * p x) +\n     ((\\<Sum>x\\<in>set_tree r. the_fin (depth x r) * p x) +\n      sum p (set_tree r)))", "apply (subst (2) sum.cong[OF HOL.refl, where h = \"\\<lambda>x. (the_fin (depth x r) + 1) * p x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>distinct (inorder l) \\<and>\n                x \\<notin> set_tree r \\<and>\n                distinct (inorder r) \\<and>\n                x \\<notin> set_tree l \\<and>\n                set_tree l \\<inter> set_tree r = {};\n        xa \\<in> set_tree r\\<rbrakk>\n       \\<Longrightarrow> the_fin\n                          (if xa = x then 1\n                           else min (depth xa l) (depth xa r) + 1) *\n                         p xa =\n                         (the_fin (depth xa r) + 1) * p xa\n 2. distinct (inorder l) \\<and>\n    x \\<notin> set_tree r \\<and>\n    distinct (inorder r) \\<and>\n    x \\<notin> set_tree l \\<and>\n    set_tree l \\<inter> set_tree r = {} \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree l. (the_fin (depth x l) + 1) * p x) +\n    (\\<Sum>x\\<in>set_tree r. (the_fin (depth x r) + 1) * p x) =\n    sum p (set_tree l) +\n    ((\\<Sum>x\\<in>set_tree l. the_fin (depth x l) * p x) +\n     ((\\<Sum>x\\<in>set_tree r. the_fin (depth x r) * p x) +\n      sum p (set_tree r)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (inorder l) \\<and>\n             x \\<notin> set_tree r \\<and>\n             distinct (inorder r) \\<and>\n             x \\<notin> set_tree l \\<and>\n             set_tree l \\<inter> set_tree r = {};\n     xa_ \\<in> set_tree r\\<rbrakk>\n    \\<Longrightarrow> the_fin\n                       (if xa_ = x then 1\n                        else min (depth xa_ l) (depth xa_ r) + 1) *\n                      p xa_ =\n                      (the_fin (depth xa_ r) + 1) * p xa_", "using set_tree_depth"], ["proof (prove)\nusing this:\n  ?x \\<notin> set_tree ?t \\<Longrightarrow> depth ?x ?t = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (inorder l) \\<and>\n             x \\<notin> set_tree r \\<and>\n             distinct (inorder r) \\<and>\n             x \\<notin> set_tree l \\<and>\n             set_tree l \\<inter> set_tree r = {};\n     xa_ \\<in> set_tree r\\<rbrakk>\n    \\<Longrightarrow> the_fin\n                       (if xa_ = x then 1\n                        else min (depth xa_ l) (depth xa_ r) + 1) *\n                      p xa_ =\n                      (the_fin (depth xa_ r) + 1) * p xa_", "by (force simp: one_extended_def elim: depth_FinD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (inorder l) \\<and>\n    x \\<notin> set_tree r \\<and>\n    distinct (inorder r) \\<and>\n    x \\<notin> set_tree l \\<and>\n    set_tree l \\<inter> set_tree r = {} \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree l. (the_fin (depth x l) + 1) * p x) +\n    (\\<Sum>x\\<in>set_tree r. (the_fin (depth x r) + 1) * p x) =\n    sum p (set_tree l) +\n    ((\\<Sum>x\\<in>set_tree l. the_fin (depth x l) * p x) +\n     ((\\<Sum>x\\<in>set_tree r. the_fin (depth x r) * p x) +\n      sum p (set_tree r)))", "apply (simp add: sum.distrib)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\\<comment> \\<open>The two variants coincide\\<close>"], ["", "lemma weight_correct:\n  \"distinct (inorder t) \\<Longrightarrow> cost' t = cost t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (inorder t) \\<Longrightarrow> local.cost' t = local.cost t", "by (induction t; simp add: cost'_Node)"], ["", "subsubsection \\<open>Memoizing Weights\\<close>"], ["", "function W_fun where\n  \"W_fun i j = (if i > j then 0 else W_fun i (j - 1) + p j)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if j < i then 0 else W_fun_sumC (i, j - 1) + p j) =\n       (if ja < ia then 0 else W_fun_sumC (ia, ja - 1) + p ja)", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All W_fun_dom", "by (relation \"measure (\\<lambda>(i::int, j::int). nat (j - i + 1))\") auto"], ["", "lemma W_fun_correct:\n  \"W_fun i j = W i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.W_fun i j = W i j", "by (induction rule: W_fun.induct) (simp add: W_def atLeastAtMost_split_insert)"], ["", "memoize_fun W\\<^sub>m: W_fun\n  with_memory  dp_consistency_mapping"], ["", "monadifies (state) W_fun.simps"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.W_fun x y)\n     (\\<lambda>(x, y). local.W\\<^sub>m' x y)", "by memoize_prover"], ["", "definition\n  \"compute_W n = snd (run_state (State_Main.map\\<^sub>T' (\\<lambda>i. W\\<^sub>m' i n) [0..n]) Mapping.empty)\""], ["", "notation W\\<^sub>m.crel_vs (\"crel\")"], ["", "lemmas W\\<^sub>m_crel = W\\<^sub>m.crel[unfolded W\\<^sub>m.consistentDP_def, THEN rel_funD,\n      of \"(m, x)\" \"(m, y)\" for m x y, unfolded prod.case]"], ["", "lemma compute_W_correct:\n  assumes \"Mapping.lookup (compute_W n) (i, j) = Some x\"\n  shows \"W i j = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W i j = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. W i j = x", "include state_monad_syntax app_syntax lifting_syntax"], ["proof (state)\ngoal (1 subgoal):\n 1. W i j = x", "let ?p = \"State_Main.map\\<^sub>T' (\\<lambda>i. W\\<^sub>m' i n) [0..n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. W i j = x", "let ?q = \"map (\\<lambda>i. W i n) [0..n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. W i j = x", "have \"?q = map $ \\<llangle>(\\<lambda>i. W_fun i n)\\<rrangle> $ \\<llangle>[0..n]\\<rrangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. W i n) [0..n] =\n    map $ \\<llangle>\\<lambda>i. local.W_fun i n\\<rrangle> $\n    \\<llangle>[0..n]\\<rrangle>", "unfolding Wrap_def App_def W_fun_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. W i n) [0..n] = map (\\<lambda>i. W i n) [0..n]", ".."], ["proof (state)\nthis:\n  map (\\<lambda>i. W i n) [0..n] =\n  map $ \\<llangle>\\<lambda>i. local.W_fun i n\\<rrangle> $\n  \\<llangle>[0..n]\\<rrangle>\n\ngoal (1 subgoal):\n 1. W i j = x", "have \"?p = State_Main.map\\<^sub>T . \\<langle>\\<lambda>i. W\\<^sub>m' i n\\<rangle> . \\<langle>[0..n]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Main.map\\<^sub>T' (\\<lambda>i. local.W\\<^sub>m' i n) [0..n] =\n    State_Main.map\\<^sub>T .\n    \\<langle>\\<lambda>i. local.W\\<^sub>m' i n\\<rangle> .\n    \\<langle>[0..n]\\<rangle>", "unfolding State_Monad_Ext.fun_app_lifted_def State_Main.map\\<^sub>T_def bind_left_identity"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Main.map\\<^sub>T' (\\<lambda>i. local.W\\<^sub>m' i n) [0..n] =\n    State_Main.map\\<^sub>T' (\\<lambda>i. local.W\\<^sub>m' i n) [0..n]", "..\n  \\<comment> \\<open>Not forgetting to write @{term  \"list_all2 (=)\"} instead of @{term \"(=)\"} was the tricky part.\\<close>"], ["proof (state)\nthis:\n  State_Main.map\\<^sub>T' (\\<lambda>i. local.W\\<^sub>m' i n) [0..n] =\n  State_Main.map\\<^sub>T .\n  \\<langle>\\<lambda>i. local.W\\<^sub>m' i n\\<rangle> .\n  \\<langle>[0..n]\\<rangle>\n\ngoal (1 subgoal):\n 1. W i j = x", "have \"W\\<^sub>m.crel_vs (list_all2 (=)) ?q ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.W_fun x y) (list_all2 (=))\n     (map (\\<lambda>i. W i n) [0..n])\n     (State_Main.map\\<^sub>T' (\\<lambda>i. local.W\\<^sub>m' i n) [0..n])", "unfolding \\<open>?p = _\\<close> \\<open>?q = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.crel_vs\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.W_fun x y) (list_all2 (=))\n     (map $ \\<llangle>\\<lambda>i. local.W_fun i n\\<rrangle> $\n      \\<llangle>[0..n]\\<rrangle>)\n     (State_Main.map\\<^sub>T .\n      \\<langle>\\<lambda>i. local.W\\<^sub>m' i n\\<rangle> .\n      \\<langle>[0..n]\\<rangle>)", "apply (subst Transfer.Rel_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (dp_consistency.crel_vs\n          (\\<lambda>k.\n              State_Monad.get \\<bind>\n              (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n          (\\<lambda>_. True) (\\<lambda>(x, y). local.W_fun x y)\n          (list_all2 (=)))\n     (map $ \\<llangle>\\<lambda>i. local.W_fun i n\\<rrangle> $\n      \\<llangle>[0..n]\\<rrangle>)\n     (State_Main.map\\<^sub>T .\n      \\<langle>\\<lambda>i. local.W\\<^sub>m' i n\\<rangle> .\n      \\<langle>[0..n]\\<rangle>)", "apply memoize_prover_match_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [0..n] \\<Longrightarrow>\n       Rel (dp_consistency.crel_vs\n             (\\<lambda>k.\n                 State_Monad.get \\<bind>\n                 (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n             (\\<lambda>_. True) (\\<lambda>(x, y). local.W_fun x y) (=))\n        (local.W_fun x n) (local.W\\<^sub>m' x n)", "apply (subst Rel_def, rule W\\<^sub>m_crel, rule HOL.refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dp_consistency.crel_vs\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n   (\\<lambda>_. True) (\\<lambda>(x, y). local.W_fun x y) (list_all2 (=))\n   (map (\\<lambda>i. W i n) [0..n])\n   (State_Main.map\\<^sub>T' (\\<lambda>i. local.W\\<^sub>m' i n) [0..n])\n\ngoal (1 subgoal):\n 1. W i j = x", "then"], ["proof (chain)\npicking this:\n  dp_consistency.crel_vs\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n   (\\<lambda>_. True) (\\<lambda>(x, y). local.W_fun x y) (list_all2 (=))\n   (map (\\<lambda>i. W i n) [0..n])\n   (State_Main.map\\<^sub>T' (\\<lambda>i. local.W\\<^sub>m' i n) [0..n])", "have \"W\\<^sub>m.cmem (compute_W n)\""], ["proof (prove)\nusing this:\n  dp_consistency.crel_vs\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n   (\\<lambda>_. True) (\\<lambda>(x, y). local.W_fun x y) (list_all2 (=))\n   (map (\\<lambda>i. W i n) [0..n])\n   (State_Main.map\\<^sub>T' (\\<lambda>i. local.W\\<^sub>m' i n) [0..n])\n\ngoal (1 subgoal):\n 1. dp_consistency.cmem\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>(x, y). local.W_fun x y) (local.compute_W n)", "unfolding compute_W_def"], ["proof (prove)\nusing this:\n  dp_consistency.crel_vs\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n   (\\<lambda>_. True) (\\<lambda>(x, y). local.W_fun x y) (list_all2 (=))\n   (map (\\<lambda>i. W i n) [0..n])\n   (State_Main.map\\<^sub>T' (\\<lambda>i. local.W\\<^sub>m' i n) [0..n])\n\ngoal (1 subgoal):\n 1. dp_consistency.cmem\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n     (\\<lambda>(x, y). local.W_fun x y)\n     (snd (run_state\n            (State_Main.map\\<^sub>T' (\\<lambda>i. local.W\\<^sub>m' i n)\n              [0..n])\n            Mapping.empty))", "by (elim W\\<^sub>m.crel_vs_elim[OF _ W\\<^sub>m.cmem_empty]; simp del: W\\<^sub>m'.simps)"], ["proof (state)\nthis:\n  dp_consistency.cmem\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n   (\\<lambda>(x, y). local.W_fun x y) (local.compute_W n)\n\ngoal (1 subgoal):\n 1. W i j = x", "with assms"], ["proof (chain)\npicking this:\n  Mapping.lookup (local.compute_W n) (i, j) = Some x\n  dp_consistency.cmem\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n   (\\<lambda>(x, y). local.W_fun x y) (local.compute_W n)", "show ?thesis"], ["proof (prove)\nusing this:\n  Mapping.lookup (local.compute_W n) (i, j) = Some x\n  dp_consistency.cmem\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n   (\\<lambda>(x, y). local.W_fun x y) (local.compute_W n)\n\ngoal (1 subgoal):\n 1. W i j = x", "unfolding W_fun_correct[symmetric]"], ["proof (prove)\nusing this:\n  Mapping.lookup (local.compute_W n) (i, j) = Some x\n  dp_consistency.cmem\n   (\\<lambda>k.\n       State_Monad.get \\<bind>\n       (\\<lambda>m. \\<langle>Mapping.lookup m k\\<rangle>))\n   (\\<lambda>(x, y). local.W_fun x y) (local.compute_W n)\n\ngoal (1 subgoal):\n 1. local.W_fun i j = x", "by (elim W\\<^sub>m.cmem_elim) (simp)+"], ["proof (state)\nthis:\n  W i j = x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"min_wpl' i j \\<equiv>\n  let\n    M = compute_W j;\n    W = (\\<lambda>i j. case Mapping.lookup M (i, j) of None \\<Rightarrow> W i j | Some x \\<Rightarrow> x)\n  in min_wpl W i j\""], ["", "lemma W_compute: \"W i j = (case Mapping.lookup (compute_W n) (i, j) of None \\<Rightarrow> W i j | Some x \\<Rightarrow> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W i j =\n    (case Mapping.lookup (local.compute_W n) (i, j) of\n     None \\<Rightarrow> W i j | Some x \\<Rightarrow> x)", "by (auto dest: compute_W_correct split: option.split)"], ["", "lemma min_wpl'_correct:\n  \"min_wpl' i j = min_wpl W i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min_wpl' i j = min_wpl W i j", "using W_compute"], ["proof (prove)\nusing this:\n  W ?i ?j =\n  (case Mapping.lookup (local.compute_W ?n) (?i, ?j) of\n   None \\<Rightarrow> W ?i ?j | Some x \\<Rightarrow> x)\n\ngoal (1 subgoal):\n 1. local.min_wpl' i j = min_wpl W i j", "unfolding min_wpl'_def"], ["proof (prove)\nusing this:\n  W ?i ?j =\n  (case Mapping.lookup (local.compute_W ?n) (?i, ?j) of\n   None \\<Rightarrow> W ?i ?j | Some x \\<Rightarrow> x)\n\ngoal (1 subgoal):\n 1. (let M = local.compute_W j;\n         W = \\<lambda>i j.\n                case Mapping.lookup M (i, j) of None \\<Rightarrow> W i j\n                | Some x \\<Rightarrow> x\n     in min_wpl W i j) =\n    min_wpl W i j", "by simp"], ["", "definition\n  \"opt_bst' i j \\<equiv>\n  let\n    M = compute_W j;\n    W = (\\<lambda>i j. case Mapping.lookup M (i, j) of None \\<Rightarrow> W i j | Some x \\<Rightarrow> x)\n  in opt_bst W (i, j)\""], ["", "lemma opt_bst'_correct:\n  \"opt_bst' i j = opt_bst W (i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.opt_bst' i j = opt_bst W (i, j)", "using W_compute"], ["proof (prove)\nusing this:\n  W ?i ?j =\n  (case Mapping.lookup (local.compute_W ?n) (?i, ?j) of\n   None \\<Rightarrow> W ?i ?j | Some x \\<Rightarrow> x)\n\ngoal (1 subgoal):\n 1. local.opt_bst' i j = opt_bst W (i, j)", "unfolding opt_bst'_def"], ["proof (prove)\nusing this:\n  W ?i ?j =\n  (case Mapping.lookup (local.compute_W ?n) (?i, ?j) of\n   None \\<Rightarrow> W ?i ?j | Some x \\<Rightarrow> x)\n\ngoal (1 subgoal):\n 1. (let M = local.compute_W j;\n         W = \\<lambda>i j.\n                case Mapping.lookup M (i, j) of None \\<Rightarrow> W i j\n                | Some x \\<Rightarrow> x\n     in opt_bst W (i, j)) =\n    opt_bst W (i, j)", "by simp"], ["", "end"], ["", "(* fixed p *)"], ["", "subsubsection \\<open>Test Case\\<close>"], ["", "text \\<open>Functional Implementations\\<close>"], ["", "lemma \"min_wpl (\\<lambda>i j. nat(i+j)) 0 4 = 10\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_wpl (\\<lambda>i j. nat (i + j)) 0 4 = 10", "by eval"], ["", "lemma \"opt_bst (\\<lambda>i j. nat(i+j)) (0, 4) = \\<langle>\\<langle>\\<langle>\\<langle>\\<langle>\\<langle>\\<rangle>, 0, \\<langle>\\<rangle>\\<rangle>, 1, \\<langle>\\<rangle>\\<rangle>, 2, \\<langle>\\<rangle>\\<rangle>, 3, \\<langle>\\<rangle>\\<rangle>, 4, \\<langle>\\<rangle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst (\\<lambda>i j. nat (i + j)) (0, 4) =\n    \\<langle>\\<langle>\\<langle>\\<langle>\\<langle>\\<langle>\\<rangle>, 0,\n   \\<langle>\\<rangle>\\<rangle>,\n                                1, \\<langle>\\<rangle>\\<rangle>,\n                       2, \\<langle>\\<rangle>\\<rangle>,\n              3, \\<langle>\\<rangle>\\<rangle>,\n     4, \\<langle>\\<rangle>\\<rangle>", "by eval"], ["", "text \\<open>Using Frequencies\\<close>"], ["", "definition\n  \"list_to_p xs (i::int) = (if i - 1 \\<ge> 0 \\<and> nat (i - 1) < length xs then xs ! nat (i - 1) else 0)\""], ["", "definition\n  \"ex_p_1 = [10, 30, 15, 25, 20]\""], ["", "definition\n  \"opt_tree_1 =\n  \\<langle>\n    \\<langle>\n      \\<langle>\\<langle>\\<rangle>, 1::int, \\<langle>\\<rangle>\\<rangle>,\n      2,\n      \\<langle>\\<langle>\\<rangle>, 3, \\<langle>\\<rangle>\\<rangle>\n    \\<rangle>,\n    4,\n    \\<langle>\\<langle>\\<rangle>, 5, \\<langle>\\<rangle>\\<rangle>\n  \\<rangle>\""], ["", "lemma \"opt_bst' (list_to_p ex_p_1) 1 5 = opt_tree_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst' (list_to_p ex_p_1) 1 5 = opt_tree_1", "by eval"], ["", "text \\<open>Imperative Implementation\\<close>"], ["", "code_thms min_wpl"], ["", "definition \"min_wpl_test = min_wpl\\<^sub>h (\\<lambda>i j. nat(i+j)) 4 0 4\""], ["", "code_reflect Test functions min_wpl_test"], ["", "ML \\<open>Test.min_wpl_test ()\\<close>"], ["", "end"]]}