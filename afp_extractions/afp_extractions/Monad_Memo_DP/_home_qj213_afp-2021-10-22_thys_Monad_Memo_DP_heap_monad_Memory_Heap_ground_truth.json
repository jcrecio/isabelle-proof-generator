{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/heap_monad/Memory_Heap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma map_emptyI:\n  \"m \\<subseteq>\\<^sub>m Map.empty\" if \"\\<And> x. m x = None\"", "lemma result_of_return[simp]:\n  \"result_of (Heap_Monad.return x) h = x\"", "lemma get_result_of_lookup:\n  \"result_of (!r) heap = x\" if \"Ref.get heap r = x\"", "lemma success_empty[intro]:\n  \"success mem_empty heap\"", "lemma length_mem_empty:\n  \"Array.length\n    (heap_of (mem_empty:: (('b :: heap) option array) Heap) h)\n    (result_of (mem_empty :: ('b option array) Heap) h) = size\"", "lemma nth_mem_empty:\n  \"result_of\n    (Array.nth (result_of (mem_empty :: ('b option array) Heap) h) i)\n    (heap_of (mem_empty :: (('b :: heap) option array) Heap) h) = None\" if \"i < size\"", "lemmas mem_heap_correct = heap_correct_axioms", "lemmas array_heap_emptyI = heap_correct_empty_axioms", "lemmas array_consistentI = dp_consistency_heap_empty_axioms", "lemma execute_bind_success':\n  assumes \"success f h\" \"execute (f \\<bind> g) h = Some (y, h'')\"\n  obtains x h' where \"execute f h = Some (x, h')\" \"execute (g x) h' = Some (y, h'')\"", "lemma success_bind_I:\n  assumes \"success f h\"\n    and \"\\<And> x h'. execute f h = Some (x, h') \\<Longrightarrow> success (g x) h'\"\n  shows \"success (f \\<bind> g) h\"", "lemma alloc_pair_alloc:\n  \"Ref.get heap' r1 = a\" \"Ref.get heap' r2 = b\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\"", "lemma alloc_pairD1:\n  \"r =!= r1 \\<and> r =!= r2 \\<and> Ref.present heap' r\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\" \"Ref.present heap r\"", "lemma alloc_pairD2:\n  \"r1 =!= r2 \\<and> Ref.present heap' r2 \\<and> Ref.present heap' r1\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\"", "lemma alloc_pairD3:\n  \"Array.present heap' r\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\" \"Array.present heap r\"", "lemma alloc_pairD4:\n  \"Ref.get heap' r = x\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\"\n     \"Ref.get heap r = x\" \"Ref.present heap r\"", "lemma alloc_pair_array_get:\n  \"Array.get heap' r = x\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\" \"Array.get heap r = x\"", "lemma alloc_pair_array_length:\n  \"Array.length heap' r = Array.length heap r\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\"", "lemma alloc_pair_nth:\n  \"result_of (Array.nth r i) heap' = result_of (Array.nth r i) heap\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\"", "lemma succes_alloc_pair[intro]:\n  \"success (alloc_pair a b) heap\"", "lemma init_state_inner_alloc:\n  assumes\n    \"execute (init_state_inner k1 k2 m1 m2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Ref.get heap' k_ref1 = k1\" \"Ref.get heap' k_ref2 = k2\"\n    \"Ref.get heap' m_ref1 = m1\" \"Ref.get heap' m_ref2 = m2\"", "lemma init_state_inner_distinct:\n  assumes\n    \"execute (init_state_inner k1 k2 m1 m2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"m_ref1 =!= m_ref2 \\<and> m_ref1 =!= k_ref1 \\<and> m_ref1 =!= k_ref2 \\<and> m_ref2 =!= k_ref1\n   \\<and> m_ref2 =!= k_ref2 \\<and> k_ref1 =!= k_ref2\"", "lemma init_state_inner_present:\n  assumes\n    \"execute (init_state_inner k1 k2 m1 m2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Ref.present heap' k_ref1\" \"Ref.present heap' k_ref2\"\n    \"Ref.present heap' m_ref1\" \"Ref.present heap' m_ref2\"", "lemma inite_state_inner_present':\n  assumes\n    \"execute (init_state_inner k1 k2 m1 m2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n    \"Array.present heap a\"\n  shows\n    \"Array.present heap' a\"", "lemma succes_init_state_inner[intro]:\n  \"success (init_state_inner k1 k2 m1 m2) heap\"", "lemma init_state_inner_nth:\n  \"result_of (Array.nth r i) heap' = result_of (Array.nth r i) heap\"\n  if \"execute (init_state_inner k1 k2 m1 m2) heap = Some ((r1, r2), heap')\"", "lemma succes_init_state[intro]:\n  \"success (init_state k1 k2) heap\"", "lemma init_state_distinct:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"inv_distinct k_ref1 k_ref2 m_ref1 m_ref2\"", "lemma init_state_present:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Ref.present heap' k_ref1\" \"Ref.present heap' k_ref2\"\n    \"Ref.present heap' m_ref1\" \"Ref.present heap' m_ref2\"", "lemma empty_present:\n  \"Array.present h' x\" if \"execute mem_empty heap = Some (x, h')\"", "lemma empty_present':\n  \"Array.present h' a\" if \"execute mem_empty heap = Some (x, h')\" \"Array.present heap a\"", "lemma init_state_present2:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Array.present heap' (Ref.get heap' m_ref1)\" \"Array.present heap' (Ref.get heap' m_ref2)\"", "lemma init_state_neq:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Ref.get heap' m_ref1 =!!= Ref.get heap' m_ref2\"", "lemma present_alloc_get:\n  \"Array.get heap' a = Array.get heap a\"\n  if \"Array.alloc xs heap = (a', heap')\" \"Array.present heap a\"", "lemma init_state_length:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Array.length heap' (Ref.get heap' m_ref1) = size\"\n    \"Array.length heap' (Ref.get heap' m_ref2) = size\"", "lemma init_state_inv:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows \"inv_pair_weak heap'\"", "lemma inv_pair_lengthD1:\n  \"Array.length heap (Ref.get heap m_ref1) = size\" if \"inv_pair_weak heap\"", "lemma inv_pair_lengthD2:\n  \"Array.length heap (Ref.get heap m_ref2) = size\" if \"inv_pair_weak heap\"", "lemma inv_pair_presentD:\n  \"Array.present heap (Ref.get heap m_ref1)\" \"Array.present heap (Ref.get heap m_ref2)\"\n  if \"inv_pair_weak heap\"", "lemma inv_pair_presentD2:\n  \"Ref.present heap m_ref1\" \"Ref.present heap m_ref2\"\n  \"Ref.present heap k_ref1\" \"Ref.present heap k_ref2\"\n  if \"inv_pair_weak heap\"", "lemma inv_pair_not_eqD:\n  \"Ref.get heap m_ref1 =!!= Ref.get heap m_ref2\" if \"inv_pair_weak heap\"", "lemma run_state_state_of[simp]:\n  \"State_Monad.run_state (state_of p) m = the (execute p m)\"", "lemma disjoint[simp]:\n  \"m_ref1 =!= m_ref2\" \"m_ref1 =!= k_ref1\" \"m_ref1 =!= k_ref2\"\n  \"m_ref2 =!= k_ref1\" \"m_ref2 =!= k_ref2\"\n  \"k_ref1 =!= k_ref2\"", "lemmas [simp] = disjoint[THEN noteq_sym]", "lemma [simp]:\n  \"Array.get (snd (Array.alloc xs heap)) a = Array.get heap a\" if \"Array.present heap a\"", "lemma [simp]:\n  \"Ref.get (snd (Array.alloc xs heap)) r = Ref.get heap r\" if \"Ref.present heap r\"", "lemma alloc_present:\n  \"Array.present (snd (Array.alloc xs heap)) a\" if \"Array.present heap a\"", "lemma alloc_present':\n  \"Ref.present (snd (Array.alloc xs heap)) r\" if \"Ref.present heap r\"", "lemma length_get_upd[simp]:\n  \"length (Array.get (Array.update a i x heap) r) = length (Array.get heap r)\"", "lemmas mem_correct_pair = pair.mem_correct_pair", "lemma rel_state_ofI:\n  \"rel_state (=) (state_of m) m\" if\n  \"\\<forall> heap. inv_pair_weak heap \\<longrightarrow> success m heap\"\n  \"lift_p inv_pair_weak m\"", "lemma inv_pair_iff:\n  \"inv_pair_weak = inv_pair\"", "lemma lift_p_inv_pairI:\n  \"State_Heap.lift_p inv_pair m\" if \"State_Heap.lift_p inv_pair_weak m\"", "lemma lift_p_success:\n  \"State_Heap.lift_p inv_pair_weak m\"\n  if \"DP_CRelVS.lift_p inv_pair_weak (state_of m)\" \"\\<forall> heap. inv_pair_weak heap \\<longrightarrow> success m heap\"", "lemma rel_state_ofI2:\n  \"rel_state (=) (state_of m) m\" if\n  \"\\<forall> heap. inv_pair_weak heap \\<longrightarrow> success m heap\"\n  \"DP_CRelVS.lift_p inv_pair_weak (state_of m)\"", "lemma [transfer_rule]:\n  \"((=) ===> rel_state (=)) move12 move12'\"", "lemma [transfer_rule]:\n  \"((=) ===> rel_state (rel_option (=))) lookup1 mem_lookup1\"", "lemma [transfer_rule]:\n  \"((=) ===> rel_state (rel_option (=))) lookup2 mem_lookup2\"", "lemma [transfer_rule]:\n  \"rel_state (=) get_k1 get_k1'\"", "lemma [transfer_rule]:\n  \"rel_state (=) get_k2 get_k2'\"", "lemma [transfer_rule]:\n  \"((=) ===> (=) ===> rel_state (=)) update1 update1'\"", "lemma [transfer_rule]:\n  \"((=) ===> (=) ===> rel_state (=)) update2 update2'\"", "lemma [transfer_rule]:\n  \"((=) ===> rel_state (rel_option (=))) lookup1 mem_lookup1\"", "lemma rel_state_lookup:\n  \"((=) ===> rel_state (=)) pair.lookup_pair lookup_pair\"", "lemma rel_state_update:\n  \"((=) ===> (=) ===> rel_state (=)) pair.update_pair update_pair\"", "lemma inv_pairD:\n  \"inv_pair_weak heap\" if \"pair.inv_pair heap\"", "lemma mem_rel_state_ofI:\n  \"mem.rel_state (=) m' m\" if\n  \"rel_state (=) m' m\"\n  \"\\<And> heap. pair.inv_pair heap \\<Longrightarrow>\n    (case State_Monad.run_state m' heap of (_, heap) \\<Rightarrow> inv_pair_weak heap \\<longrightarrow> pair.inv_pair heap)\"", "lemma mem_rel_state_ofI':\n  \"mem.rel_state (=) m' m\" if\n  \"rel_state (=) m' m\"\n  \"DP_CRelVS.lift_p pair.inv_pair m'\"", "lemma rel_state_lookup':\n  \"((=) ===> mem.rel_state (=)) pair.lookup_pair lookup_pair\"", "lemma rel_state_update':\n  \"((=) ===> (=) ===> mem.rel_state (=)) pair.update_pair update_pair\"", "lemmas heap_correct_pairI = heap_correct_axioms", "lemma mem_rel_state_resultD:\n  \"result_of m heap = fst (run_state m' heap)\" if \"mem.rel_state (=) m' m\" \"pair.inv_pair heap\"", "lemma map_of_heap_eq:\n  \"mem.map_of_heap heap = pair.pair.map_of heap\" if \"pair.inv_pair heap\"", "lemma init_state_empty1:\n  \"pair.mem1.map_of heap' k = None\"", "lemma init_state_empty2:\n  \"pair.mem2.map_of heap' k = None\"", "lemma\n  shows init_state_k1: \"result_of (!k_ref1) heap' = k1\"\n    and init_state_k2: \"result_of (!k_ref2) heap' = k2\"", "lemma init_state_inv':\n  \"pair.inv_pair heap'\"", "lemma init_state_empty:\n  \"pair.pair.map_of heap' \\<subseteq>\\<^sub>m Map.empty\"", "lemmas heap_correct_empty_pairI = heap_correct_empty_axioms", "lemmas consistent_empty_pairI = dp_consistency_heap_empty_axioms"], "translations": [["", "lemma map_emptyI:\n  \"m \\<subseteq>\\<^sub>m Map.empty\" if \"\\<And> x. m x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<subseteq>\\<^sub>m Map.empty", "using that"], ["proof (prove)\nusing this:\n  m ?x = None\n\ngoal (1 subgoal):\n 1. m \\<subseteq>\\<^sub>m Map.empty", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  m ?x = None\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom m. m a = None", "by auto"], ["", "lemma result_of_return[simp]:\n  \"result_of (Heap_Monad.return x) h = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result_of (return x) h = x", "by (simp add: execute_simps)"], ["", "lemma get_result_of_lookup:\n  \"result_of (!r) heap = x\" if \"Ref.get heap r = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result_of (!r) heap = x", "using that"], ["proof (prove)\nusing this:\n  Ref.get heap r = x\n\ngoal (1 subgoal):\n 1. result_of (!r) heap = x", "by (auto simp: execute_simps)"], ["", "context\n  fixes size :: nat\n    and to_index :: \"('k2 :: heap) \\<Rightarrow> nat\"\nbegin"], ["", "definition\n  \"mem_empty = (Array.new size (None :: ('v :: heap) option))\""], ["", "lemma success_empty[intro]:\n  \"success mem_empty heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success local.mem_empty heap", "unfolding mem_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. success (Array.new size None) heap", "by (auto intro: success_intros)"], ["", "lemma length_mem_empty:\n  \"Array.length\n    (heap_of (mem_empty:: (('b :: heap) option array) Heap) h)\n    (result_of (mem_empty :: ('b option array) Heap) h) = size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length (heap_of local.mem_empty h) (result_of local.mem_empty h) =\n    size", "unfolding mem_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length (heap_of (Array.new size None) h)\n     (result_of (Array.new size None) h) =\n    size", "by (auto simp: execute_simps Array.length_alloc)"], ["", "lemma nth_mem_empty:\n  \"result_of\n    (Array.nth (result_of (mem_empty :: ('b option array) Heap) h) i)\n    (heap_of (mem_empty :: (('b :: heap) option array) Heap) h) = None\" if \"i < size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result_of (Array.nth (result_of local.mem_empty h) i)\n     (heap_of local.mem_empty h) =\n    None", "apply (subst execute_nth(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < Array.length (heap_of local.mem_empty h)\n         (result_of local.mem_empty h)\n 2. fst (the (Some\n               (Array.get (heap_of local.mem_empty h)\n                 (result_of local.mem_empty h) !\n                i,\n                heap_of local.mem_empty h))) =\n    None", "apply (simp add: length_mem_empty that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (the (Some\n               (Array.get (heap_of local.mem_empty h)\n                 (result_of local.mem_empty h) !\n                i,\n                heap_of local.mem_empty h))) =\n    None", "apply (simp add: execute_simps mem_empty_def Array.get_alloc that)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context\n  fixes mem :: \"('v :: heap) option array\"\nbegin"], ["", "definition\n  \"mem_lookup k = (let i = to_index k in\n    if i < size then Array.nth mem i else return None\n  )\""], ["", "definition\n  \"mem_update k v = (let i = to_index k in\n    if i < size then (Array.upd i (Some v) mem \\<bind> (\\<lambda> _. return ()))\n    else return ()\n  )\n  \""], ["", "context assumes injective: \"injective size to_index\"\nbegin"], ["", "interpretation heap_correct \"\\<lambda>heap. Array.length heap mem = size\" mem_update mem_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_correct (\\<lambda>heap. Array.length heap mem = size)\n     local.mem_update local.mem_lookup", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k.\n       State_Heap.lift_p (\\<lambda>heap. Array.length heap mem = size)\n        (local.mem_lookup k)\n 2. \\<And>k v.\n       State_Heap.lift_p (\\<lambda>heap. Array.length heap mem = size)\n        (local.mem_update k v)\n 3. \\<And>m k.\n       Array.length m mem = size \\<Longrightarrow>\n       heap_mem_defs.map_of_heap local.mem_lookup\n        (heap_of (local.mem_lookup k) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap local.mem_lookup m\n 4. \\<And>m k v.\n       Array.length m mem = size \\<Longrightarrow>\n       heap_mem_defs.map_of_heap local.mem_lookup\n        (heap_of (local.mem_update k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap local.mem_lookup m(k \\<mapsto> v)", "subgoal lookup_inv"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Heap.lift_p (\\<lambda>heap. Array.length heap mem = size)\n     (local.mem_lookup k_)", "unfolding State_Heap.lift_p_def mem_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       Array.length heap mem = size \\<longrightarrow>\n       (case execute\n              (let i = to_index k_\n               in if i < size then Array.nth mem i else return None)\n              heap of\n        None \\<Rightarrow> False\n        | Some (xa, heap) \\<Rightarrow> Array.length heap mem = size)", "by (simp add: Let_def execute_simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k v.\n       State_Heap.lift_p (\\<lambda>heap. Array.length heap mem = size)\n        (local.mem_update k v)\n 2. \\<And>m k.\n       Array.length m mem = size \\<Longrightarrow>\n       heap_mem_defs.map_of_heap local.mem_lookup\n        (heap_of (local.mem_lookup k) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap local.mem_lookup m\n 3. \\<And>m k v.\n       Array.length m mem = size \\<Longrightarrow>\n       heap_mem_defs.map_of_heap local.mem_lookup\n        (heap_of (local.mem_update k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap local.mem_lookup m(k \\<mapsto> v)", "subgoal update_inv"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Heap.lift_p (\\<lambda>heap. Array.length heap mem = size)\n     (local.mem_update k_ v_)", "unfolding State_Heap.lift_p_def mem_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       Array.length heap mem = size \\<longrightarrow>\n       (case execute\n              (let i = to_index k_\n               in if i < size\n                  then Array.upd i (Some v_) mem \\<bind>\n                       (\\<lambda>_. return ())\n                  else return ())\n              heap of\n        None \\<Rightarrow> False\n        | Some (xa, heap) \\<Rightarrow> Array.length heap mem = size)", "by (simp add: Let_def execute_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k.\n       Array.length m mem = size \\<Longrightarrow>\n       heap_mem_defs.map_of_heap local.mem_lookup\n        (heap_of (local.mem_lookup k) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap local.mem_lookup m\n 2. \\<And>m k v.\n       Array.length m mem = size \\<Longrightarrow>\n       heap_mem_defs.map_of_heap local.mem_lookup\n        (heap_of (local.mem_update k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap local.mem_lookup m(k \\<mapsto> v)", "subgoal for k heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length k mem = size \\<Longrightarrow>\n    heap_mem_defs.map_of_heap local.mem_lookup\n     (heap_of (local.mem_lookup heap) k) \\<subseteq>\\<^sub>m\n    heap_mem_defs.map_of_heap local.mem_lookup k", "unfolding heap_mem_defs.map_of_heap_def map_le_def mem_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length k mem = size \\<Longrightarrow>\n    \\<forall>a\\<in>dom (\\<lambda>ka.\n                           result_of\n                            (let i = to_index ka\n                             in if i < size then Array.nth mem i\n                                else return None)\n                            (heap_of\n                              (let i = to_index heap\n                               in if i < size then Array.nth mem i\n                                  else return None)\n                              k)).\n       result_of\n        (let i = to_index a\n         in if i < size then Array.nth mem i else return None)\n        (heap_of\n          (let i = to_index heap\n           in if i < size then Array.nth mem i else return None)\n          k) =\n       result_of\n        (let i = to_index a\n         in if i < size then Array.nth mem i else return None)\n        k", "by (auto simp: execute_simps Let_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       Array.length m mem = size \\<Longrightarrow>\n       heap_mem_defs.map_of_heap local.mem_lookup\n        (heap_of (local.mem_update k v) m) \\<subseteq>\\<^sub>m\n       heap_mem_defs.map_of_heap local.mem_lookup m(k \\<mapsto> v)", "subgoal for heap k"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length heap mem = size \\<Longrightarrow>\n    heap_mem_defs.map_of_heap local.mem_lookup\n     (heap_of (local.mem_update k v_) heap) \\<subseteq>\\<^sub>m\n    heap_mem_defs.map_of_heap local.mem_lookup heap(k \\<mapsto> v_)", "unfolding heap_mem_defs.map_of_heap_def map_le_def mem_lookup_def mem_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length heap mem = size \\<Longrightarrow>\n    \\<forall>a\\<in>dom (\\<lambda>ka.\n                           result_of\n                            (let i = to_index ka\n                             in if i < size then Array.nth mem i\n                                else return None)\n                            (heap_of\n                              (let i = to_index k\n                               in if i < size\n                                  then Array.upd i (Some v_) mem \\<bind>\n (\\<lambda>_. return ())\n                                  else return ())\n                              heap)).\n       result_of\n        (let i = to_index a\n         in if i < size then Array.nth mem i else return None)\n        (heap_of\n          (let i = to_index k\n           in if i < size\n              then Array.upd i (Some v_) mem \\<bind> (\\<lambda>_. return ())\n              else return ())\n          heap) =\n       ((\\<lambda>k.\n            result_of\n             (let i = to_index k\n              in if i < size then Array.nth mem i else return None)\n             heap)\n        (k \\<mapsto> v_))\n        a", "apply (auto simp: execute_simps Let_def length_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y.\n       \\<lbrakk>size = length (Array.get heap mem);\n        to_index k < length (Array.get heap mem);\n        (Array.get heap mem)[to_index k := Some v_] ! to_index a = Some y;\n        to_index a < length (Array.get heap mem); a \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> Some y = Array.get heap mem ! to_index a", "apply (subst (asm) nth_list_update_neq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a y.\n       \\<lbrakk>to_index a < length (Array.get heap mem); a \\<noteq> k;\n        size = length (Array.get heap mem);\n        to_index k < length (Array.get heap mem)\\<rbrakk>\n       \\<Longrightarrow> to_index k \\<noteq> to_index a\n 2. \\<And>a y.\n       \\<lbrakk>size = length (Array.get heap mem);\n        to_index k < length (Array.get heap mem);\n        Array.get heap mem ! to_index a = Some y;\n        to_index a < length (Array.get heap mem); a \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> Some y = Array.get heap mem ! to_index a", "using injective[unfolded injective_def]"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     to_index a = to_index b \\<and>\n     to_index a < size \\<and> to_index b < size \\<longrightarrow>\n     a = b\n\ngoal (2 subgoals):\n 1. \\<And>a y.\n       \\<lbrakk>to_index a < length (Array.get heap mem); a \\<noteq> k;\n        size = length (Array.get heap mem);\n        to_index k < length (Array.get heap mem)\\<rbrakk>\n       \\<Longrightarrow> to_index k \\<noteq> to_index a\n 2. \\<And>a y.\n       \\<lbrakk>size = length (Array.get heap mem);\n        to_index k < length (Array.get heap mem);\n        Array.get heap mem ! to_index a = Some y;\n        to_index a < length (Array.get heap mem); a \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> Some y = Array.get heap mem ! to_index a", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas mem_heap_correct = heap_correct_axioms"], ["", "context\n  assumes [simp]: \"mem = result_of mem_empty Heap.empty\"\nbegin"], ["", "interpretation heap_correct_empty\n  \"\\<lambda>heap. Array.length heap mem = size\" mem_update mem_lookup\n  \"heap_of (mem_empty :: 'v option array Heap) Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_correct_empty (\\<lambda>heap. Array.length heap mem = size)\n     local.mem_update local.mem_lookup (heap_of local.mem_empty Heap.empty)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_of_heap (heap_of local.mem_empty Heap.empty) \\<subseteq>\\<^sub>m\n    Map.empty\n 2. Array.length (heap_of local.mem_empty Heap.empty) mem = size", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_heap (heap_of local.mem_empty Heap.empty) \\<subseteq>\\<^sub>m\n    Map.empty", "apply (rule map_emptyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. map_of_heap (heap_of local.mem_empty Heap.empty) x = None", "unfolding map_of_heap_def mem_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       result_of\n        (let i = to_index x\n         in if i < size then Array.nth mem i else return None)\n        (heap_of local.mem_empty Heap.empty) =\n       None", "by (auto simp: Let_def nth_mem_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length (heap_of local.mem_empty Heap.empty) mem = size", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length (heap_of local.mem_empty Heap.empty) mem = size", "by (simp add: length_mem_empty)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas array_heap_emptyI = heap_correct_empty_axioms"], ["", "context\n  fixes dp :: \"'k2 \\<Rightarrow> 'v\"\nbegin"], ["", "interpretation dp_consistency_heap_empty\n  \"\\<lambda>heap. Array.length heap mem = size\" mem_update mem_lookup dp\n  \"heap_of (mem_empty :: 'v option array Heap) Heap.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_empty (\\<lambda>heap. Array.length heap mem = size)\n     local.mem_update local.mem_lookup (heap_of local.mem_empty Heap.empty)", "by standard"], ["", "lemmas array_consistentI = dp_consistency_heap_empty_axioms"], ["", "end"], ["", "end"], ["", "(* Empty Memory *)"], ["", "end"], ["", "(* Injectivity *)"], ["", "end"], ["", "(* Fixed array *)"], ["", "lemma execute_bind_success':\n  assumes \"success f h\" \"execute (f \\<bind> g) h = Some (y, h'')\"\n  obtains x h' where \"execute f h = Some (x, h')\" \"execute (g x) h' = Some (y, h'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x h'.\n        \\<lbrakk>execute f h = Some (x, h');\n         execute (g x) h' = Some (y, h'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  success f h\n  execute (f \\<bind> g) h = Some (y, h'')\n\ngoal (1 subgoal):\n 1. (\\<And>x h'.\n        \\<lbrakk>execute f h = Some (x, h');\n         execute (g x) h' = Some (y, h'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: execute_simps elim: successE)"], ["", "lemma success_bind_I:\n  assumes \"success f h\"\n    and \"\\<And> x h'. execute f h = Some (x, h') \\<Longrightarrow> success (g x) h'\"\n  shows \"success (f \\<bind> g) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success (f \\<bind> g) h", "by (rule successE[OF assms(1)]) (auto elim: assms(2) intro: success_bind_executeI)"], ["", "definition\n  \"alloc_pair a b \\<equiv> do {\n    r1 \\<leftarrow> ref a;\n    r2 \\<leftarrow> ref b;\n    return (r1, r2)\n  }\""], ["", "lemma alloc_pair_alloc:\n  \"Ref.get heap' r1 = a\" \"Ref.get heap' r2 = b\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.get heap' r1 = a &&& Ref.get heap' r2 = b", "using that"], ["proof (prove)\nusing this:\n  execute (alloc_pair a b) heap = Some ((r1, r2), heap')\n\ngoal (1 subgoal):\n 1. Ref.get heap' r1 = a &&& Ref.get heap' r2 = b", "unfolding alloc_pair_def"], ["proof (prove)\nusing this:\n  execute\n   (ref a \\<bind>\n    (\\<lambda>r1. ref b \\<bind> (\\<lambda>r2. return (r1, r2))))\n   heap =\n  Some ((r1, r2), heap')\n\ngoal (1 subgoal):\n 1. Ref.get heap' r1 = a &&& Ref.get heap' r2 = b", "by (auto simp: execute_simps elim!: execute_bind_success'[OF success_refI])\n     (metis Ref.get_alloc fst_conv get_alloc_neq next_present present_alloc_neq snd_conv)+"], ["", "lemma alloc_pairD1:\n  \"r =!= r1 \\<and> r =!= r2 \\<and> Ref.present heap' r\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\" \"Ref.present heap r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r =!= r1 \\<and> r =!= r2 \\<and> Ref.present heap' r", "using that"], ["proof (prove)\nusing this:\n  execute (alloc_pair a b) heap = Some ((r1, r2), heap')\n  Ref.present heap r\n\ngoal (1 subgoal):\n 1. r =!= r1 \\<and> r =!= r2 \\<and> Ref.present heap' r", "unfolding alloc_pair_def"], ["proof (prove)\nusing this:\n  execute\n   (ref a \\<bind>\n    (\\<lambda>r1. ref b \\<bind> (\\<lambda>r2. return (r1, r2))))\n   heap =\n  Some ((r1, r2), heap')\n  Ref.present heap r\n\ngoal (1 subgoal):\n 1. r =!= r1 \\<and> r =!= r2 \\<and> Ref.present heap' r", "by (auto simp: execute_simps elim!: execute_bind_success'[OF success_refI])\n     (metis next_fresh noteq_I Ref.present_alloc snd_conv)+"], ["", "lemma alloc_pairD2:\n  \"r1 =!= r2 \\<and> Ref.present heap' r2 \\<and> Ref.present heap' r1\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1 =!= r2 \\<and> Ref.present heap' r2 \\<and> Ref.present heap' r1", "using that"], ["proof (prove)\nusing this:\n  execute (alloc_pair a b) heap = Some ((r1, r2), heap')\n\ngoal (1 subgoal):\n 1. r1 =!= r2 \\<and> Ref.present heap' r2 \\<and> Ref.present heap' r1", "unfolding alloc_pair_def"], ["proof (prove)\nusing this:\n  execute\n   (ref a \\<bind>\n    (\\<lambda>r1. ref b \\<bind> (\\<lambda>r2. return (r1, r2))))\n   heap =\n  Some ((r1, r2), heap')\n\ngoal (1 subgoal):\n 1. r1 =!= r2 \\<and> Ref.present heap' r2 \\<and> Ref.present heap' r1", "by (auto simp: execute_simps elim!: execute_bind_success'[OF success_refI])\n     (metis next_fresh next_present noteq_I Ref.present_alloc snd_conv)+"], ["", "lemma alloc_pairD3:\n  \"Array.present heap' r\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\" \"Array.present heap r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.present heap' r", "using that"], ["proof (prove)\nusing this:\n  execute (alloc_pair a b) heap = Some ((r1, r2), heap')\n  Array.present heap r\n\ngoal (1 subgoal):\n 1. Array.present heap' r", "unfolding alloc_pair_def"], ["proof (prove)\nusing this:\n  execute\n   (ref a \\<bind>\n    (\\<lambda>r1. ref b \\<bind> (\\<lambda>r2. return (r1, r2))))\n   heap =\n  Some ((r1, r2), heap')\n  Array.present heap r\n\ngoal (1 subgoal):\n 1. Array.present heap' r", "by (auto simp: execute_simps elim!: execute_bind_success'[OF success_refI])\n     (metis array_present_alloc snd_conv)"], ["", "lemma alloc_pairD4:\n  \"Ref.get heap' r = x\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\"\n     \"Ref.get heap r = x\" \"Ref.present heap r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.get heap' r = x", "using that"], ["proof (prove)\nusing this:\n  execute (alloc_pair a b) heap = Some ((r1, r2), heap')\n  Ref.get heap r = x\n  Ref.present heap r\n\ngoal (1 subgoal):\n 1. Ref.get heap' r = x", "unfolding alloc_pair_def"], ["proof (prove)\nusing this:\n  execute\n   (ref a \\<bind>\n    (\\<lambda>r1. ref b \\<bind> (\\<lambda>r2. return (r1, r2))))\n   heap =\n  Some ((r1, r2), heap')\n  Ref.get heap r = x\n  Ref.present heap r\n\ngoal (1 subgoal):\n 1. Ref.get heap' r = x", "by (auto simp: execute_simps elim!: execute_bind_success'[OF success_refI])\n     (metis Ref.not_present_alloc Ref.present_alloc get_alloc_neq noteq_I snd_conv)"], ["", "lemma alloc_pair_array_get:\n  \"Array.get heap' r = x\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\" \"Array.get heap r = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.get heap' r = x", "using that"], ["proof (prove)\nusing this:\n  execute (alloc_pair a b) heap = Some ((r1, r2), heap')\n  Array.get heap r = x\n\ngoal (1 subgoal):\n 1. Array.get heap' r = x", "unfolding alloc_pair_def"], ["proof (prove)\nusing this:\n  execute\n   (ref a \\<bind>\n    (\\<lambda>r1. ref b \\<bind> (\\<lambda>r2. return (r1, r2))))\n   heap =\n  Some ((r1, r2), heap')\n  Array.get heap r = x\n\ngoal (1 subgoal):\n 1. Array.get heap' r = x", "by (auto simp: execute_simps elim!: execute_bind_success'[OF success_refI])\n (metis array_get_alloc snd_conv)"], ["", "lemma alloc_pair_array_length:\n  \"Array.length heap' r = Array.length heap r\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length heap' r = Array.length heap r", "using that"], ["proof (prove)\nusing this:\n  execute (alloc_pair a b) heap = Some ((r1, r2), heap')\n\ngoal (1 subgoal):\n 1. Array.length heap' r = Array.length heap r", "unfolding alloc_pair_def"], ["proof (prove)\nusing this:\n  execute\n   (ref a \\<bind>\n    (\\<lambda>r1. ref b \\<bind> (\\<lambda>r2. return (r1, r2))))\n   heap =\n  Some ((r1, r2), heap')\n\ngoal (1 subgoal):\n 1. Array.length heap' r = Array.length heap r", "by (auto simp: execute_simps elim!: execute_bind_success'[OF success_refI])\n     (metis Ref.length_alloc snd_conv)"], ["", "lemma alloc_pair_nth:\n  \"result_of (Array.nth r i) heap' = result_of (Array.nth r i) heap\"\n  if \"execute (alloc_pair a b) heap = Some ((r1, r2), heap')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result_of (Array.nth r i) heap' = result_of (Array.nth r i) heap", "using alloc_pair_array_get[OF that(1) HOL.refl, of r] alloc_pair_array_length[OF that(1), of r]"], ["proof (prove)\nusing this:\n  Array.get heap' r = Array.get heap r\n  Array.length heap' r = Array.length heap r\n\ngoal (1 subgoal):\n 1. result_of (Array.nth r i) heap' = result_of (Array.nth r i) heap", "by (cases \"(\\<lambda>h. i < Array.length h r) heap\"; simp add: execute_simps Array.nth_def)"], ["", "lemma succes_alloc_pair[intro]:\n  \"success (alloc_pair a b) heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success (alloc_pair a b) heap", "unfolding alloc_pair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. success\n     (ref a \\<bind>\n      (\\<lambda>r1. ref b \\<bind> (\\<lambda>r2. return (r1, r2))))\n     heap", "by (auto intro: success_intros success_bind_I)"], ["", "definition\n  \"init_state_inner k1 k2 m1 m2 \\<equiv>  do {\n    (k_ref1, k_ref2) \\<leftarrow> alloc_pair k1 k2;\n    (m_ref1, m_ref2) \\<leftarrow> alloc_pair m1 m2;\n    return (k_ref1, k_ref2, m_ref1, m_ref2)\n  }\n  \""], ["", "lemma init_state_inner_alloc:\n  assumes\n    \"execute (init_state_inner k1 k2 m1 m2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Ref.get heap' k_ref1 = k1\" \"Ref.get heap' k_ref2 = k2\"\n    \"Ref.get heap' m_ref1 = m1\" \"Ref.get heap' m_ref2 = m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ref.get heap' k_ref1 = k1 &&& Ref.get heap' k_ref2 = k2) &&&\n    Ref.get heap' m_ref1 = m1 &&& Ref.get heap' m_ref2 = m2", "using assms"], ["proof (prove)\nusing this:\n  execute (init_state_inner k1 k2 m1 m2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. (Ref.get heap' k_ref1 = k1 &&& Ref.get heap' k_ref2 = k2) &&&\n    Ref.get heap' m_ref1 = m1 &&& Ref.get heap' m_ref2 = m2", "unfolding init_state_inner_def"], ["proof (prove)\nusing this:\n  execute\n   (alloc_pair k1 k2 \\<bind>\n    (\\<lambda>(k_ref1, k_ref2).\n        alloc_pair m1 m2 \\<bind>\n        (\\<lambda>(m_ref1, m_ref2).\n            return (k_ref1, k_ref2, m_ref1, m_ref2))))\n   heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. (Ref.get heap' k_ref1 = k1 &&& Ref.get heap' k_ref2 = k2) &&&\n    Ref.get heap' m_ref1 = m1 &&& Ref.get heap' m_ref2 = m2", "by (auto simp: execute_simps elim!: execute_bind_success'[OF succes_alloc_pair])\n     (auto intro: alloc_pair_alloc dest: alloc_pairD2 elim: alloc_pairD4)"], ["", "lemma init_state_inner_distinct:\n  assumes\n    \"execute (init_state_inner k1 k2 m1 m2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"m_ref1 =!= m_ref2 \\<and> m_ref1 =!= k_ref1 \\<and> m_ref1 =!= k_ref2 \\<and> m_ref2 =!= k_ref1\n   \\<and> m_ref2 =!= k_ref2 \\<and> k_ref1 =!= k_ref2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m_ref1 =!= m_ref2 \\<and>\n    m_ref1 =!= k_ref1 \\<and>\n    m_ref1 =!= k_ref2 \\<and>\n    m_ref2 =!= k_ref1 \\<and> m_ref2 =!= k_ref2 \\<and> k_ref1 =!= k_ref2", "using assms"], ["proof (prove)\nusing this:\n  execute (init_state_inner k1 k2 m1 m2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. m_ref1 =!= m_ref2 \\<and>\n    m_ref1 =!= k_ref1 \\<and>\n    m_ref1 =!= k_ref2 \\<and>\n    m_ref2 =!= k_ref1 \\<and> m_ref2 =!= k_ref2 \\<and> k_ref1 =!= k_ref2", "unfolding init_state_inner_def"], ["proof (prove)\nusing this:\n  execute\n   (alloc_pair k1 k2 \\<bind>\n    (\\<lambda>(k_ref1, k_ref2).\n        alloc_pair m1 m2 \\<bind>\n        (\\<lambda>(m_ref1, m_ref2).\n            return (k_ref1, k_ref2, m_ref1, m_ref2))))\n   heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. m_ref1 =!= m_ref2 \\<and>\n    m_ref1 =!= k_ref1 \\<and>\n    m_ref1 =!= k_ref2 \\<and>\n    m_ref2 =!= k_ref1 \\<and> m_ref2 =!= k_ref2 \\<and> k_ref1 =!= k_ref2", "by (auto simp: execute_simps elim!: execute_bind_success'[OF succes_alloc_pair])\n     (blast dest: alloc_pairD1 alloc_pairD2 intro: noteq_sym)+"], ["", "lemma init_state_inner_present:\n  assumes\n    \"execute (init_state_inner k1 k2 m1 m2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Ref.present heap' k_ref1\" \"Ref.present heap' k_ref2\"\n    \"Ref.present heap' m_ref1\" \"Ref.present heap' m_ref2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ref.present heap' k_ref1 &&& Ref.present heap' k_ref2) &&&\n    Ref.present heap' m_ref1 &&& Ref.present heap' m_ref2", "using assms"], ["proof (prove)\nusing this:\n  execute (init_state_inner k1 k2 m1 m2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. (Ref.present heap' k_ref1 &&& Ref.present heap' k_ref2) &&&\n    Ref.present heap' m_ref1 &&& Ref.present heap' m_ref2", "unfolding init_state_inner_def"], ["proof (prove)\nusing this:\n  execute\n   (alloc_pair k1 k2 \\<bind>\n    (\\<lambda>(k_ref1, k_ref2).\n        alloc_pair m1 m2 \\<bind>\n        (\\<lambda>(m_ref1, m_ref2).\n            return (k_ref1, k_ref2, m_ref1, m_ref2))))\n   heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. (Ref.present heap' k_ref1 &&& Ref.present heap' k_ref2) &&&\n    Ref.present heap' m_ref1 &&& Ref.present heap' m_ref2", "by (auto simp: execute_simps elim!: execute_bind_success'[OF succes_alloc_pair])\n     (blast dest: alloc_pairD1 alloc_pairD2)+"], ["", "lemma inite_state_inner_present':\n  assumes\n    \"execute (init_state_inner k1 k2 m1 m2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n    \"Array.present heap a\"\n  shows\n    \"Array.present heap' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.present heap' a", "using assms"], ["proof (prove)\nusing this:\n  execute (init_state_inner k1 k2 m1 m2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n  Array.present heap a\n\ngoal (1 subgoal):\n 1. Array.present heap' a", "unfolding init_state_inner_def"], ["proof (prove)\nusing this:\n  execute\n   (alloc_pair k1 k2 \\<bind>\n    (\\<lambda>(k_ref1, k_ref2).\n        alloc_pair m1 m2 \\<bind>\n        (\\<lambda>(m_ref1, m_ref2).\n            return (k_ref1, k_ref2, m_ref1, m_ref2))))\n   heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n  Array.present heap a\n\ngoal (1 subgoal):\n 1. Array.present heap' a", "by (auto simp: execute_simps elim!: execute_bind_success'[OF succes_alloc_pair] alloc_pairD3)"], ["", "lemma succes_init_state_inner[intro]:\n  \"success (init_state_inner k1 k2 m1 m2) heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success (init_state_inner k1 k2 m1 m2) heap", "unfolding init_state_inner_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. success\n     (alloc_pair k1 k2 \\<bind>\n      (\\<lambda>(k_ref1, k_ref2).\n          alloc_pair m1 m2 \\<bind>\n          (\\<lambda>(m_ref1, m_ref2).\n              return (k_ref1, k_ref2, m_ref1, m_ref2))))\n     heap", "by (auto 4 3 intro: success_intros success_bind_I)"], ["", "lemma init_state_inner_nth:\n  \"result_of (Array.nth r i) heap' = result_of (Array.nth r i) heap\"\n  if \"execute (init_state_inner k1 k2 m1 m2) heap = Some ((r1, r2), heap')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result_of (Array.nth r i) heap' = result_of (Array.nth r i) heap", "using that"], ["proof (prove)\nusing this:\n  execute (init_state_inner k1 k2 m1 m2) heap = Some ((r1, r2), heap')\n\ngoal (1 subgoal):\n 1. result_of (Array.nth r i) heap' = result_of (Array.nth r i) heap", "unfolding init_state_inner_def"], ["proof (prove)\nusing this:\n  execute\n   (alloc_pair k1 k2 \\<bind>\n    (\\<lambda>(k_ref1, k_ref2).\n        alloc_pair m1 m2 \\<bind>\n        (\\<lambda>(m_ref1, m_ref2).\n            return (k_ref1, k_ref2, m_ref1, m_ref2))))\n   heap =\n  Some ((r1, r2), heap')\n\ngoal (1 subgoal):\n 1. result_of (Array.nth r i) heap' = result_of (Array.nth r i) heap", "by (auto simp: execute_simps alloc_pair_nth elim!: execute_bind_success'[OF succes_alloc_pair])"], ["", "definition\n  \"init_state k1 k2 \\<equiv> do {\n    m1 \\<leftarrow> mem_empty;\n    m2 \\<leftarrow> mem_empty;\n    init_state_inner k1 k2 m1 m2\n  }\""], ["", "lemma succes_init_state[intro]:\n  \"success (init_state k1 k2) heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success (local.init_state k1 k2) heap", "unfolding init_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. success\n     (local.mem_empty \\<bind>\n      (\\<lambda>m1. local.mem_empty \\<bind> init_state_inner k1 k2 m1))\n     heap", "by (auto intro: success_intros success_bind_I)"], ["", "definition\n  \"inv_distinct k_ref1 k_ref2 m_ref1 m_ref2 \\<equiv>\n     m_ref1 =!= m_ref2 \\<and> m_ref1 =!= k_ref1 \\<and> m_ref1 =!= k_ref2 \\<and> m_ref2 =!= k_ref1\n   \\<and> m_ref2 =!= k_ref2 \\<and> k_ref1 =!= k_ref2\n  \""], ["", "lemma init_state_distinct:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"inv_distinct k_ref1 k_ref2 m_ref1 m_ref2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_distinct k_ref1 k_ref2 m_ref1 m_ref2", "using assms"], ["proof (prove)\nusing this:\n  execute (local.init_state k1 k2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. inv_distinct k_ref1 k_ref2 m_ref1 m_ref2", "unfolding init_state_def inv_distinct_def"], ["proof (prove)\nusing this:\n  execute\n   (local.mem_empty \\<bind>\n    (\\<lambda>m1. local.mem_empty \\<bind> init_state_inner k1 k2 m1))\n   heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. m_ref1 =!= m_ref2 \\<and>\n    m_ref1 =!= k_ref1 \\<and>\n    m_ref1 =!= k_ref2 \\<and>\n    m_ref2 =!= k_ref1 \\<and> m_ref2 =!= k_ref2 \\<and> k_ref1 =!= k_ref2", "by (elim execute_bind_success'[OF success_empty] init_state_inner_distinct)"], ["", "lemma init_state_present:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Ref.present heap' k_ref1\" \"Ref.present heap' k_ref2\"\n    \"Ref.present heap' m_ref1\" \"Ref.present heap' m_ref2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ref.present heap' k_ref1 &&& Ref.present heap' k_ref2) &&&\n    Ref.present heap' m_ref1 &&& Ref.present heap' m_ref2", "using assms"], ["proof (prove)\nusing this:\n  execute (local.init_state k1 k2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. (Ref.present heap' k_ref1 &&& Ref.present heap' k_ref2) &&&\n    Ref.present heap' m_ref1 &&& Ref.present heap' m_ref2", "unfolding init_state_def"], ["proof (prove)\nusing this:\n  execute\n   (local.mem_empty \\<bind>\n    (\\<lambda>m1. local.mem_empty \\<bind> init_state_inner k1 k2 m1))\n   heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. (Ref.present heap' k_ref1 &&& Ref.present heap' k_ref2) &&&\n    Ref.present heap' m_ref1 &&& Ref.present heap' m_ref2", "by (auto\n        simp: execute_simps elim!: execute_bind_success'[OF success_empty]\n        dest: init_state_inner_present\n     )"], ["", "lemma empty_present:\n  \"Array.present h' x\" if \"execute mem_empty heap = Some (x, h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.present h' x", "using that"], ["proof (prove)\nusing this:\n  execute local.mem_empty heap = Some (x, h')\n\ngoal (1 subgoal):\n 1. Array.present h' x", "unfolding mem_empty_def"], ["proof (prove)\nusing this:\n  execute (Array.new size None) heap = Some (x, h')\n\ngoal (1 subgoal):\n 1. Array.present h' x", "by (auto simp: execute_simps) (metis Array.present_alloc fst_conv snd_conv)"], ["", "lemma empty_present':\n  \"Array.present h' a\" if \"execute mem_empty heap = Some (x, h')\" \"Array.present heap a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.present h' a", "using that"], ["proof (prove)\nusing this:\n  execute local.mem_empty heap = Some (x, h')\n  Array.present heap a\n\ngoal (1 subgoal):\n 1. Array.present h' a", "unfolding mem_empty_def"], ["proof (prove)\nusing this:\n  execute (Array.new size None) heap = Some (x, h')\n  Array.present heap a\n\ngoal (1 subgoal):\n 1. Array.present h' a", "by (auto simp: execute_simps Array.present_def Array.alloc_def Array.set_def Let_def)"], ["", "lemma init_state_present2:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Array.present heap' (Ref.get heap' m_ref1)\" \"Array.present heap' (Ref.get heap' m_ref2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.present heap' (Ref.get heap' m_ref1) &&&\n    Array.present heap' (Ref.get heap' m_ref2)", "using assms"], ["proof (prove)\nusing this:\n  execute (local.init_state k1 k2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. Array.present heap' (Ref.get heap' m_ref1) &&&\n    Array.present heap' (Ref.get heap' m_ref2)", "unfolding init_state_def"], ["proof (prove)\nusing this:\n  execute\n   (local.mem_empty \\<bind>\n    (\\<lambda>m1. local.mem_empty \\<bind> init_state_inner k1 k2 m1))\n   heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. Array.present heap' (Ref.get heap' m_ref1) &&&\n    Array.present heap' (Ref.get heap' m_ref2)", "by (auto 4 3\n        simp: execute_simps init_state_inner_alloc elim!: execute_bind_success'[OF success_empty]\n        dest: inite_state_inner_present' empty_present empty_present'\n     )"], ["", "lemma init_state_neq:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Ref.get heap' m_ref1 =!!= Ref.get heap' m_ref2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.get heap' m_ref1 =!!= Ref.get heap' m_ref2", "using assms"], ["proof (prove)\nusing this:\n  execute (local.init_state k1 k2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. Ref.get heap' m_ref1 =!!= Ref.get heap' m_ref2", "unfolding init_state_def"], ["proof (prove)\nusing this:\n  execute\n   (local.mem_empty \\<bind>\n    (\\<lambda>m1. local.mem_empty \\<bind> init_state_inner k1 k2 m1))\n   heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. Ref.get heap' m_ref1 =!!= Ref.get heap' m_ref2", "by (auto 4 3\n        simp: execute_simps init_state_inner_alloc elim!: execute_bind_success'[OF success_empty]\n        dest: inite_state_inner_present' empty_present empty_present'\n     )\n    (metis empty_present execute_new fst_conv mem_empty_def option.inject present_alloc_noteq)"], ["", "lemma present_alloc_get:\n  \"Array.get heap' a = Array.get heap a\"\n  if \"Array.alloc xs heap = (a', heap')\" \"Array.present heap a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.get heap' a = Array.get heap a", "using that"], ["proof (prove)\nusing this:\n  Array.alloc xs heap = (a', heap')\n  Array.present heap a\n\ngoal (1 subgoal):\n 1. Array.get heap' a = Array.get heap a", "by (auto simp: Array.alloc_def Array.present_def Array.get_def Let_def Array.set_def)"], ["", "lemma init_state_length:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows\n    \"Array.length heap' (Ref.get heap' m_ref1) = size\"\n    \"Array.length heap' (Ref.get heap' m_ref2) = size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length heap' (Ref.get heap' m_ref1) = size &&&\n    Array.length heap' (Ref.get heap' m_ref2) = size", "using assms"], ["proof (prove)\nusing this:\n  execute (local.init_state k1 k2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. Array.length heap' (Ref.get heap' m_ref1) = size &&&\n    Array.length heap' (Ref.get heap' m_ref2) = size", "unfolding init_state_def"], ["proof (prove)\nusing this:\n  execute\n   (local.mem_empty \\<bind>\n    (\\<lambda>m1. local.mem_empty \\<bind> init_state_inner k1 k2 m1))\n   heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. Array.length heap' (Ref.get heap' m_ref1) = size &&&\n    Array.length heap' (Ref.get heap' m_ref2) = size", "apply (auto\n        simp: execute_simps init_state_inner_alloc elim!: execute_bind_success'[OF success_empty]\n        dest: inite_state_inner_present' empty_present empty_present'\n     )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x h' xa h'a.\n       \\<lbrakk>execute local.mem_empty heap = Some (x, h');\n        execute local.mem_empty h' = Some (xa, h'a);\n        execute (init_state_inner k1 k2 x xa) h'a =\n        Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\\<rbrakk>\n       \\<Longrightarrow> Array.length heap' x = size\n 2. \\<And>x h' xa h'a.\n       \\<lbrakk>execute local.mem_empty heap = Some (x, h');\n        execute local.mem_empty h' = Some (xa, h'a);\n        execute (init_state_inner k1 k2 x xa) h'a =\n        Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\\<rbrakk>\n       \\<Longrightarrow> Array.length heap' xa = size", "apply (auto\n      simp: execute_simps init_state_inner_def alloc_pair_def mem_empty_def Array.length_def\n      elim!: execute_bind_success'[OF success_refI]\n     )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x h' xa h'a h'b h'c h'd.\n       \\<lbrakk>Array.alloc (replicate size None) heap = (x, h');\n        Array.alloc (replicate size None) h' = (xa, h'a);\n        Ref.alloc k1 h'a = (k_ref1, h'b); Ref.alloc k2 h'b = (k_ref2, h'c);\n        Ref.alloc x h'c = (m_ref1, h'd);\n        Ref.alloc xa h'd = (m_ref2, heap')\\<rbrakk>\n       \\<Longrightarrow> length (Array.get heap' x) = size\n 2. \\<And>x h' xa h'a h'b h'c h'd.\n       \\<lbrakk>Array.alloc (replicate size None) heap = (x, h');\n        Array.alloc (replicate size None) h' = (xa, h'a);\n        Ref.alloc k1 h'a = (k_ref1, h'b); Ref.alloc k2 h'b = (k_ref2, h'c);\n        Ref.alloc x h'c = (m_ref1, h'd);\n        Ref.alloc xa h'd = (m_ref2, heap')\\<rbrakk>\n       \\<Longrightarrow> length (Array.get heap' xa) = size", "apply (metis\n      Array.alloc_def Array.get_set_eq Array.present_alloc array_get_alloc fst_conv length_replicate\n      present_alloc_get snd_conv\n     )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context\n  fixes key1 :: \"'k \\<Rightarrow> ('k1 :: heap)\" and key2 :: \"'k \\<Rightarrow> 'k2\"\n    and m_ref1 m_ref2 :: \"('v :: heap) option array ref\"\n    and k_ref1 k_ref2 :: \"('k1 :: heap) ref\"\nbegin"], ["", "text \\<open>We assume that look-ups happen on the older row, so this is biased towards the second entry.\\<close>"], ["", "definition\n  \"lookup_pair k = do {\n    let k' = key1 k;\n    k2 \\<leftarrow> !k_ref2;\n    if k' = k2 then\n      do {\n        m2 \\<leftarrow> !m_ref2;\n        mem_lookup m2 (key2 k)\n      }\n    else\n      do {\n      k1 \\<leftarrow> !k_ref1;\n      if k' = k1 then\n        do {\n          m1 \\<leftarrow> !m_ref1;\n          mem_lookup m1 (key2 k)\n        }\n      else\n        return None\n    }\n  }\n   \""], ["", "text \\<open>We assume that updates happen on the newer row, so this is biased towards the first entry.\\<close>"], ["", "definition\n  \"update_pair k v = do {\n    let k' = key1 k;\n      k1 \\<leftarrow> !k_ref1;\n      if k' = k1 then do {\n        m \\<leftarrow> !m_ref1;\n        mem_update m (key2 k) v\n      }\n      else do {\n        k2 \\<leftarrow> !k_ref2;\n        if k' = k2 then do {\n          m \\<leftarrow> !m_ref2;\n          mem_update m (key2 k) v\n        }\n        else do {\n          do {\n            k1 \\<leftarrow> !k_ref1;\n            m \\<leftarrow> mem_empty;\n            m1 \\<leftarrow> !m_ref1;\n            k_ref2 := k1;\n            k_ref1 := k';\n            m_ref2 := m1;\n            m_ref1 := m\n          }\n        ;\n        m \\<leftarrow> !m_ref1;\n        mem_update m (key2 k) v\n      }\n    }\n   }\n   \""], ["", "definition\n  \"inv_pair_weak heap = (\n    let\n      m1 = Ref.get heap m_ref1;\n      m2 = Ref.get heap m_ref2\n    in Array.length heap m1 = size \\<and> Array.length heap m2 = size\n      \\<and> Ref.present heap k_ref1 \\<and> Ref.present heap k_ref2\n      \\<and> Ref.present heap m_ref1 \\<and> Ref.present heap m_ref2\n      \\<and> Array.present heap m1 \\<and> Array.present heap m2\n      \\<and> m1 =!!= m2\n  )\""], ["", "(* TODO: Remove? *)"], ["", "definition\n  \"inv_pair heap \\<equiv> inv_pair_weak heap \\<and> inv_distinct k_ref1 k_ref2 m_ref1 m_ref2\""], ["", "lemma init_state_inv:\n  assumes\n    \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\n  shows \"inv_pair_weak heap'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.inv_pair_weak heap'", "using assms"], ["proof (prove)\nusing this:\n  execute (local.init_state k1 k2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. local.inv_pair_weak heap'", "unfolding inv_pair_weak_def Let_def"], ["proof (prove)\nusing this:\n  execute (local.init_state k1 k2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. Array.length heap' (Ref.get heap' m_ref1) = size \\<and>\n    Array.length heap' (Ref.get heap' m_ref2) = size \\<and>\n    Ref.present heap' k_ref1 \\<and>\n    Ref.present heap' k_ref2 \\<and>\n    Ref.present heap' m_ref1 \\<and>\n    Ref.present heap' m_ref2 \\<and>\n    Array.present heap' (Ref.get heap' m_ref1) \\<and>\n    Array.present heap' (Ref.get heap' m_ref2) \\<and>\n    Ref.get heap' m_ref1 =!!= Ref.get heap' m_ref2", "by (auto intro:\n      init_state_present init_state_present2 init_state_neq init_state_length\n      init_state_distinct\n     )"], ["", "lemma inv_pair_lengthD1:\n  \"Array.length heap (Ref.get heap m_ref1) = size\" if \"inv_pair_weak heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length heap (Ref.get heap m_ref1) = size", "using that"], ["proof (prove)\nusing this:\n  local.inv_pair_weak heap\n\ngoal (1 subgoal):\n 1. Array.length heap (Ref.get heap m_ref1) = size", "unfolding inv_pair_weak_def"], ["proof (prove)\nusing this:\n  let m1 = Ref.get heap m_ref1; m2 = Ref.get heap m_ref2\n  in Array.length heap m1 = size \\<and>\n     Array.length heap m2 = size \\<and>\n     Ref.present heap k_ref1 \\<and>\n     Ref.present heap k_ref2 \\<and>\n     Ref.present heap m_ref1 \\<and>\n     Ref.present heap m_ref2 \\<and>\n     Array.present heap m1 \\<and> Array.present heap m2 \\<and> m1 =!!= m2\n\ngoal (1 subgoal):\n 1. Array.length heap (Ref.get heap m_ref1) = size", "by (auto simp: Let_def)"], ["", "lemma inv_pair_lengthD2:\n  \"Array.length heap (Ref.get heap m_ref2) = size\" if \"inv_pair_weak heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length heap (Ref.get heap m_ref2) = size", "using that"], ["proof (prove)\nusing this:\n  local.inv_pair_weak heap\n\ngoal (1 subgoal):\n 1. Array.length heap (Ref.get heap m_ref2) = size", "unfolding inv_pair_weak_def"], ["proof (prove)\nusing this:\n  let m1 = Ref.get heap m_ref1; m2 = Ref.get heap m_ref2\n  in Array.length heap m1 = size \\<and>\n     Array.length heap m2 = size \\<and>\n     Ref.present heap k_ref1 \\<and>\n     Ref.present heap k_ref2 \\<and>\n     Ref.present heap m_ref1 \\<and>\n     Ref.present heap m_ref2 \\<and>\n     Array.present heap m1 \\<and> Array.present heap m2 \\<and> m1 =!!= m2\n\ngoal (1 subgoal):\n 1. Array.length heap (Ref.get heap m_ref2) = size", "by (auto simp: Let_def)"], ["", "lemma inv_pair_presentD:\n  \"Array.present heap (Ref.get heap m_ref1)\" \"Array.present heap (Ref.get heap m_ref2)\"\n  if \"inv_pair_weak heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.present heap (Ref.get heap m_ref1) &&&\n    Array.present heap (Ref.get heap m_ref2)", "using that"], ["proof (prove)\nusing this:\n  local.inv_pair_weak heap\n\ngoal (1 subgoal):\n 1. Array.present heap (Ref.get heap m_ref1) &&&\n    Array.present heap (Ref.get heap m_ref2)", "unfolding inv_pair_weak_def"], ["proof (prove)\nusing this:\n  let m1 = Ref.get heap m_ref1; m2 = Ref.get heap m_ref2\n  in Array.length heap m1 = size \\<and>\n     Array.length heap m2 = size \\<and>\n     Ref.present heap k_ref1 \\<and>\n     Ref.present heap k_ref2 \\<and>\n     Ref.present heap m_ref1 \\<and>\n     Ref.present heap m_ref2 \\<and>\n     Array.present heap m1 \\<and> Array.present heap m2 \\<and> m1 =!!= m2\n\ngoal (1 subgoal):\n 1. Array.present heap (Ref.get heap m_ref1) &&&\n    Array.present heap (Ref.get heap m_ref2)", "by (auto simp: Let_def)"], ["", "lemma inv_pair_presentD2:\n  \"Ref.present heap m_ref1\" \"Ref.present heap m_ref2\"\n  \"Ref.present heap k_ref1\" \"Ref.present heap k_ref2\"\n  if \"inv_pair_weak heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ref.present heap m_ref1 &&& Ref.present heap m_ref2) &&&\n    Ref.present heap k_ref1 &&& Ref.present heap k_ref2", "using that"], ["proof (prove)\nusing this:\n  local.inv_pair_weak heap\n\ngoal (1 subgoal):\n 1. (Ref.present heap m_ref1 &&& Ref.present heap m_ref2) &&&\n    Ref.present heap k_ref1 &&& Ref.present heap k_ref2", "unfolding inv_pair_weak_def"], ["proof (prove)\nusing this:\n  let m1 = Ref.get heap m_ref1; m2 = Ref.get heap m_ref2\n  in Array.length heap m1 = size \\<and>\n     Array.length heap m2 = size \\<and>\n     Ref.present heap k_ref1 \\<and>\n     Ref.present heap k_ref2 \\<and>\n     Ref.present heap m_ref1 \\<and>\n     Ref.present heap m_ref2 \\<and>\n     Array.present heap m1 \\<and> Array.present heap m2 \\<and> m1 =!!= m2\n\ngoal (1 subgoal):\n 1. (Ref.present heap m_ref1 &&& Ref.present heap m_ref2) &&&\n    Ref.present heap k_ref1 &&& Ref.present heap k_ref2", "by (auto simp: Let_def)"], ["", "lemma inv_pair_not_eqD:\n  \"Ref.get heap m_ref1 =!!= Ref.get heap m_ref2\" if \"inv_pair_weak heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.get heap m_ref1 =!!= Ref.get heap m_ref2", "using that"], ["proof (prove)\nusing this:\n  local.inv_pair_weak heap\n\ngoal (1 subgoal):\n 1. Ref.get heap m_ref1 =!!= Ref.get heap m_ref2", "unfolding inv_pair_weak_def"], ["proof (prove)\nusing this:\n  let m1 = Ref.get heap m_ref1; m2 = Ref.get heap m_ref2\n  in Array.length heap m1 = size \\<and>\n     Array.length heap m2 = size \\<and>\n     Ref.present heap k_ref1 \\<and>\n     Ref.present heap k_ref2 \\<and>\n     Ref.present heap m_ref1 \\<and>\n     Ref.present heap m_ref2 \\<and>\n     Array.present heap m1 \\<and> Array.present heap m2 \\<and> m1 =!!= m2\n\ngoal (1 subgoal):\n 1. Ref.get heap m_ref1 =!!= Ref.get heap m_ref2", "by (auto simp: Let_def)"], ["", "definition \"lookup1 k \\<equiv> state_of (do {m \\<leftarrow> !m_ref1; mem_lookup m k})\""], ["", "definition \"lookup2 k \\<equiv> state_of (do {m \\<leftarrow> !m_ref2; mem_lookup m k})\""], ["", "definition \"update1 k v \\<equiv> state_of (do {m \\<leftarrow> !m_ref1; mem_update m k v})\""], ["", "definition \"update2 k v \\<equiv> state_of (do {m \\<leftarrow> !m_ref2; mem_update m k v})\""], ["", "definition \"move12 k \\<equiv> state_of (do {\n    k1 \\<leftarrow> !k_ref1;\n    m \\<leftarrow> mem_empty;\n    m1 \\<leftarrow> !m_ref1;\n    k_ref2 := k1;\n    k_ref1 := k;\n    m_ref2 := m1;\n    m_ref1 := m\n  })\n  \""], ["", "definition \"get_k1 \\<equiv> state_of (!k_ref1)\""], ["", "definition \"get_k2 \\<equiv> state_of (!k_ref2)\""], ["", "lemma run_state_state_of[simp]:\n  \"State_Monad.run_state (state_of p) m = the (execute p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (state_of p) m = the (execute p m)", "unfolding state_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (State (\\<lambda>heap. the (execute p heap))) m =\n    the (execute p m)", "by simp"], ["", "context assumes injective: \"injective size to_index\"\nbegin"], ["", "context\n  assumes inv_distinct: \"inv_distinct k_ref1 k_ref2 m_ref1 m_ref2\"\nbegin"], ["", "lemma disjoint[simp]:\n  \"m_ref1 =!= m_ref2\" \"m_ref1 =!= k_ref1\" \"m_ref1 =!= k_ref2\"\n  \"m_ref2 =!= k_ref1\" \"m_ref2 =!= k_ref2\"\n  \"k_ref1 =!= k_ref2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m_ref1 =!= m_ref2 &&& m_ref1 =!= k_ref1 &&& m_ref1 =!= k_ref2) &&&\n    m_ref2 =!= k_ref1 &&& m_ref2 =!= k_ref2 &&& k_ref1 =!= k_ref2", "using inv_distinct"], ["proof (prove)\nusing this:\n  inv_distinct k_ref1 k_ref2 m_ref1 m_ref2\n\ngoal (1 subgoal):\n 1. (m_ref1 =!= m_ref2 &&& m_ref1 =!= k_ref1 &&& m_ref1 =!= k_ref2) &&&\n    m_ref2 =!= k_ref1 &&& m_ref2 =!= k_ref2 &&& k_ref1 =!= k_ref2", "unfolding inv_distinct_def"], ["proof (prove)\nusing this:\n  m_ref1 =!= m_ref2 \\<and>\n  m_ref1 =!= k_ref1 \\<and>\n  m_ref1 =!= k_ref2 \\<and>\n  m_ref2 =!= k_ref1 \\<and> m_ref2 =!= k_ref2 \\<and> k_ref1 =!= k_ref2\n\ngoal (1 subgoal):\n 1. (m_ref1 =!= m_ref2 &&& m_ref1 =!= k_ref1 &&& m_ref1 =!= k_ref2) &&&\n    m_ref2 =!= k_ref1 &&& m_ref2 =!= k_ref2 &&& k_ref1 =!= k_ref2", "by auto"], ["", "lemmas [simp] = disjoint[THEN noteq_sym]"], ["", "lemma [simp]:\n  \"Array.get (snd (Array.alloc xs heap)) a = Array.get heap a\" if \"Array.present heap a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.get (snd (Array.alloc xs heap)) a = Array.get heap a", "using that"], ["proof (prove)\nusing this:\n  Array.present heap a\n\ngoal (1 subgoal):\n 1. Array.get (snd (Array.alloc xs heap)) a = Array.get heap a", "unfolding Array.alloc_def Array.present_def"], ["proof (prove)\nusing this:\n  addr_of_array a < lim heap\n\ngoal (1 subgoal):\n 1. Array.get\n     (snd (let l = lim heap; r = Array l\n           in Let (Array.set r xs (heap\\<lparr>lim := l + 1\\<rparr>))\n               (Pair r)))\n     a =\n    Array.get heap a", "apply (simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_of_array a < lim heap \\<Longrightarrow>\n    Array.get\n     (Array.set (Array (lim heap)) xs\n       (heap\\<lparr>lim := Suc (lim heap)\\<rparr>))\n     a =\n    Array.get heap a", "apply (subst Array.get_set_neq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. addr_of_array a < lim heap \\<Longrightarrow> a =!!= Array (lim heap)\n 2. addr_of_array a < lim heap \\<Longrightarrow>\n    Array.get (heap\\<lparr>lim := Suc (lim heap)\\<rparr>) a =\n    Array.get heap a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_of_array a < lim heap \\<Longrightarrow> a =!!= Array (lim heap)", "by (simp add: Array.noteq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_of_array a < lim heap \\<Longrightarrow>\n    Array.get (heap\\<lparr>lim := Suc (lim heap)\\<rparr>) a =\n    Array.get heap a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_of_array a < lim heap \\<Longrightarrow>\n    Array.get (heap\\<lparr>lim := Suc (lim heap)\\<rparr>) a =\n    Array.get heap a", "unfolding Array.get_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_of_array a < lim heap \\<Longrightarrow>\n    map from_nat\n     (arrays (heap\\<lparr>lim := Suc (lim heap)\\<rparr>) TYPEREP('a)\n       (addr_of_array a)) =\n    map from_nat (arrays heap TYPEREP('a) (addr_of_array a))", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]:\n  \"Ref.get (snd (Array.alloc xs heap)) r = Ref.get heap r\" if \"Ref.present heap r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.get (snd (Array.alloc xs heap)) r = Ref.get heap r", "using that"], ["proof (prove)\nusing this:\n  Ref.present heap r\n\ngoal (1 subgoal):\n 1. Ref.get (snd (Array.alloc xs heap)) r = Ref.get heap r", "unfolding Array.alloc_def Ref.present_def"], ["proof (prove)\nusing this:\n  addr_of_ref r < lim heap\n\ngoal (1 subgoal):\n 1. Ref.get\n     (snd (let l = lim heap; r = Array l\n           in Let (Array.set r xs (heap\\<lparr>lim := l + 1\\<rparr>))\n               (Pair r)))\n     r =\n    Ref.get heap r", "by (simp add: Let_def Ref.get_def Array.set_def)"], ["", "lemma alloc_present:\n  \"Array.present (snd (Array.alloc xs heap)) a\" if \"Array.present heap a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.present (snd (Array.alloc xs heap)) a", "using that"], ["proof (prove)\nusing this:\n  Array.present heap a\n\ngoal (1 subgoal):\n 1. Array.present (snd (Array.alloc xs heap)) a", "unfolding Array.present_def Array.alloc_def"], ["proof (prove)\nusing this:\n  addr_of_array a < lim heap\n\ngoal (1 subgoal):\n 1. addr_of_array a\n    < lim (snd (let l = lim heap; r = Array l\n                in Let (Array.set r xs (heap\\<lparr>lim := l + 1\\<rparr>))\n                    (Pair r)))", "by (simp add: Let_def Array.set_def)"], ["", "lemma alloc_present':\n  \"Ref.present (snd (Array.alloc xs heap)) r\" if \"Ref.present heap r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.present (snd (Array.alloc xs heap)) r", "using that"], ["proof (prove)\nusing this:\n  Ref.present heap r\n\ngoal (1 subgoal):\n 1. Ref.present (snd (Array.alloc xs heap)) r", "unfolding Ref.present_def Array.alloc_def"], ["proof (prove)\nusing this:\n  addr_of_ref r < lim heap\n\ngoal (1 subgoal):\n 1. addr_of_ref r\n    < lim (snd (let l = lim heap; r = Array l\n                in Let (Array.set r xs (heap\\<lparr>lim := l + 1\\<rparr>))\n                    (Pair r)))", "by (simp add: Let_def Array.set_def)"], ["", "lemma length_get_upd[simp]:\n  \"length (Array.get (Array.update a i x heap) r) = length (Array.get heap r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Array.get (Array.update a i x heap) r) =\n    length (Array.get heap r)", "unfolding Array.get_def Array.update_def Array.set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map from_nat\n       (arrays\n         (arrays_update\n           (\\<lambda>h. h\n               (TYPEREP('b) := (h TYPEREP('b))\n                  (addr_of_array a :=\n                     map to_nat\n                      ((map from_nat\n                         (arrays heap TYPEREP('b) (addr_of_array a)))\n                       [i := x]))))\n           heap)\n         TYPEREP('a) (addr_of_array r))) =\n    length (map from_nat (arrays heap TYPEREP('a) (addr_of_array r)))", "by simp"], ["", "method solve1 =\n  (frule inv_pair_lengthD1, frule inv_pair_lengthD2, frule inv_pair_not_eqD)?,\n  auto split: if_split_asm dest: Array.noteq_sym"], ["", "interpretation pair: pair_mem lookup1 lookup2 update1 update2 move12 get_k1 get_k2 inv_pair_weak"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_mem local.lookup1 local.lookup2 local.update1 local.update2\n     local.move12 local.get_k1 local.get_k2 local.inv_pair_weak", "supply [simp] =\n    mem_empty_def state_mem_defs.map_of_def map_le_def\n    move12_def update1_def update2_def lookup1_def lookup2_def get_k1_def get_k2_def\n    mem_update_def mem_lookup_def\n    execute_bind_success[OF success_newI] execute_simps Let_def Array.get_alloc length_def\n    inv_pair_presentD inv_pair_presentD2\n    Memory_Heap.lookup1_def Memory_Heap.lookup2_def Memory_Heap.mem_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_mem local.lookup1 local.lookup2 local.update1 local.update2\n     local.move12 local.get_k1 local.get_k2 local.inv_pair_weak", "apply standard"], ["proof (prove)\ngoal (27 subgoals):\n 1. \\<And>m k m'.\n       run_state local.get_k1 m = (k, m') \\<Longrightarrow> m' = m\n 2. \\<And>m k m'.\n       run_state local.get_k2 m = (k, m') \\<Longrightarrow> m' = m\n 3. \\<And>m k1 x m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.move12 k1) m = (x, m')\\<rbrakk>\n       \\<Longrightarrow> state_mem_defs.map_of local.lookup1\n                          m' \\<subseteq>\\<^sub>m\n                         Map.empty\n 4. \\<And>m k1 x m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.move12 k1) m = (x, m')\\<rbrakk>\n       \\<Longrightarrow> state_mem_defs.map_of local.lookup2\n                          m' \\<subseteq>\\<^sub>m\n                         state_mem_defs.map_of local.lookup1 m\n 5. \\<And>k1 m x m'.\n       run_state (local.move12 k1) m = (x, m') \\<Longrightarrow>\n       fst (run_state local.get_k1 m') = k1\n 6. \\<And>k1 m x m'.\n       run_state (local.move12 k1) m = (x, m') \\<Longrightarrow>\n       fst (run_state local.get_k2 m') = fst (run_state local.get_k1 m)\n 7. \\<And>k1. DP_CRelVS.lift_p local.inv_pair_weak (local.move12 k1)\n 8. \\<And>k'. DP_CRelVS.lift_p local.inv_pair_weak (local.lookup1 k')\n 9. \\<And>k'. DP_CRelVS.lift_p local.inv_pair_weak (local.lookup2 k')\n 10. \\<And>k' v. DP_CRelVS.lift_p local.inv_pair_weak (local.update1 k' v)\nA total of 27 subgoals...", "apply (solve1; fail)+"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>k1. DP_CRelVS.lift_p local.inv_pair_weak (local.move12 k1)\n 2. \\<And>k'. DP_CRelVS.lift_p local.inv_pair_weak (local.lookup1 k')\n 3. \\<And>k'. DP_CRelVS.lift_p local.inv_pair_weak (local.lookup2 k')\n 4. \\<And>k' v. DP_CRelVS.lift_p local.inv_pair_weak (local.update1 k' v)\n 5. \\<And>k' v. DP_CRelVS.lift_p local.inv_pair_weak (local.update2 k' v)\n 6. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup1 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k1 m') =\n                         fst (run_state local.get_k1 m)\n 7. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup1 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k2 m') =\n                         fst (run_state local.get_k2 m)\n 8. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup2 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k1 m') =\n                         fst (run_state local.get_k1 m)\n 9. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup2 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k2 m') =\n                         fst (run_state local.get_k2 m)\n 10. \\<And>m k' v x m'.\n        \\<lbrakk>local.inv_pair_weak m;\n         run_state (local.update1 k' v) m = (x, m')\\<rbrakk>\n        \\<Longrightarrow> fst (run_state local.get_k1 m') =\n                          fst (run_state local.get_k1 m)\nA total of 21 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak (local.move12 k1_)", "apply (rule lift_pI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>heap x heap'.\n       \\<lbrakk>local.inv_pair_weak heap;\n        run_state (local.move12 k1_) heap = (x, heap')\\<rbrakk>\n       \\<Longrightarrow> local.inv_pair_weak heap'", "unfolding inv_pair_weak_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>heap x heap'.\n       \\<lbrakk>let m1 = Ref.get heap m_ref1; m2 = Ref.get heap m_ref2\n                in Array.length heap m1 = size \\<and>\n                   Array.length heap m2 = size \\<and>\n                   Ref.present heap k_ref1 \\<and>\n                   Ref.present heap k_ref2 \\<and>\n                   Ref.present heap m_ref1 \\<and>\n                   Ref.present heap m_ref2 \\<and>\n                   Array.present heap m1 \\<and>\n                   Array.present heap m2 \\<and> m1 =!!= m2;\n        run_state (local.move12 k1_) heap = (x, heap')\\<rbrakk>\n       \\<Longrightarrow> let m1 = Ref.get heap' m_ref1;\n                             m2 = Ref.get heap' m_ref2\n                         in Array.length heap' m1 = size \\<and>\n                            Array.length heap' m2 = size \\<and>\n                            Ref.present heap' k_ref1 \\<and>\n                            Ref.present heap' k_ref2 \\<and>\n                            Ref.present heap' m_ref1 \\<and>\n                            Ref.present heap' m_ref2 \\<and>\n                            Array.present heap' m1 \\<and>\n                            Array.present heap' m2 \\<and> m1 =!!= m2", "apply (auto simp:\n        intro: alloc_present alloc_present'\n        elim: present_alloc_noteq[THEN Array.noteq_sym]\n        )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>k'. DP_CRelVS.lift_p local.inv_pair_weak (local.lookup1 k')\n 2. \\<And>k'. DP_CRelVS.lift_p local.inv_pair_weak (local.lookup2 k')\n 3. \\<And>k' v. DP_CRelVS.lift_p local.inv_pair_weak (local.update1 k' v)\n 4. \\<And>k' v. DP_CRelVS.lift_p local.inv_pair_weak (local.update2 k' v)\n 5. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup1 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k1 m') =\n                         fst (run_state local.get_k1 m)\n 6. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup1 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k2 m') =\n                         fst (run_state local.get_k2 m)\n 7. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup2 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k1 m') =\n                         fst (run_state local.get_k1 m)\n 8. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup2 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k2 m') =\n                         fst (run_state local.get_k2 m)\n 9. \\<And>m k' v x m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.update1 k' v) m = (x, m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k1 m') =\n                         fst (run_state local.get_k1 m)\n 10. \\<And>m k' v x m'.\n        \\<lbrakk>local.inv_pair_weak m;\n         run_state (local.update1 k' v) m = (x, m')\\<rbrakk>\n        \\<Longrightarrow> fst (run_state local.get_k2 m') =\n                          fst (run_state local.get_k2 m)\nA total of 20 subgoals...", "apply (rule lift_pI, unfold inv_pair_weak_def, auto split: if_split_asm; fail)+"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup1 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k1 m') =\n                         fst (run_state local.get_k1 m)\n 2. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup1 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k2 m') =\n                         fst (run_state local.get_k2 m)\n 3. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup2 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k1 m') =\n                         fst (run_state local.get_k1 m)\n 4. \\<And>m k' v' m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.lookup2 k') m = (v', m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k2 m') =\n                         fst (run_state local.get_k2 m)\n 5. \\<And>m k' v x m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.update1 k' v) m = (x, m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k1 m') =\n                         fst (run_state local.get_k1 m)\n 6. \\<And>m k' v x m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.update1 k' v) m = (x, m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k2 m') =\n                         fst (run_state local.get_k2 m)\n 7. \\<And>m k' v x m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.update2 k' v) m = (x, m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k1 m') =\n                         fst (run_state local.get_k1 m)\n 8. \\<And>m k' v x m'.\n       \\<lbrakk>local.inv_pair_weak m;\n        run_state (local.update2 k' v) m = (x, m')\\<rbrakk>\n       \\<Longrightarrow> fst (run_state local.get_k2 m') =\n                         fst (run_state local.get_k2 m)\n 9. \\<And>m k'.\n       local.inv_pair_weak m \\<Longrightarrow>\n       state_mem_defs.map_of local.lookup1\n        (snd (run_state (local.lookup1 k') m)) \\<subseteq>\\<^sub>m\n       state_mem_defs.map_of local.lookup1 m\n 10. \\<And>m k'.\n        local.inv_pair_weak m \\<Longrightarrow>\n        state_mem_defs.map_of local.lookup2\n         (snd (run_state (local.lookup1 k') m)) \\<subseteq>\\<^sub>m\n        state_mem_defs.map_of local.lookup2 m\nA total of 16 subgoals...", "apply (solve1; fail)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m k' v.\n       local.inv_pair_weak m \\<Longrightarrow>\n       state_mem_defs.map_of local.lookup1\n        (snd (run_state (local.update1 k' v) m)) \\<subseteq>\\<^sub>m\n       state_mem_defs.map_of local.lookup1 m(k' \\<mapsto> v)\n 2. \\<And>m k' v.\n       local.inv_pair_weak m \\<Longrightarrow>\n       state_mem_defs.map_of local.lookup2\n        (snd (run_state (local.update2 k' v) m)) \\<subseteq>\\<^sub>m\n       state_mem_defs.map_of local.lookup2 m(k' \\<mapsto> v)\n 3. \\<And>m k' v.\n       local.inv_pair_weak m \\<Longrightarrow>\n       state_mem_defs.map_of local.lookup2\n        (snd (run_state (local.update1 k' v) m)) \\<subseteq>\\<^sub>m\n       state_mem_defs.map_of local.lookup2 m\n 4. \\<And>m k' v.\n       local.inv_pair_weak m \\<Longrightarrow>\n       state_mem_defs.map_of local.lookup1\n        (snd (run_state (local.update2 k' v) m)) \\<subseteq>\\<^sub>m\n       state_mem_defs.map_of local.lookup1 m", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.inv_pair_weak m_ \\<Longrightarrow>\n    state_mem_defs.map_of local.lookup1\n     (snd (run_state (local.update1 k'_ v_) m_)) \\<subseteq>\\<^sub>m\n    state_mem_defs.map_of local.lookup1 m_(k'_ \\<mapsto> v_)", "using injective[unfolded injective_def]"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     to_index a = to_index b \\<and>\n     to_index a < size \\<and> to_index b < size \\<longrightarrow>\n     a = b\n\ngoal (1 subgoal):\n 1. local.inv_pair_weak m_ \\<Longrightarrow>\n    state_mem_defs.map_of local.lookup1\n     (snd (run_state (local.update1 k'_ v_) m_)) \\<subseteq>\\<^sub>m\n    state_mem_defs.map_of local.lookup1 m_(k'_ \\<mapsto> v_)", "by - (solve1, subst (asm) nth_list_update_neq, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m k' v.\n       local.inv_pair_weak m \\<Longrightarrow>\n       state_mem_defs.map_of local.lookup2\n        (snd (run_state (local.update2 k' v) m)) \\<subseteq>\\<^sub>m\n       state_mem_defs.map_of local.lookup2 m(k' \\<mapsto> v)\n 2. \\<And>m k' v.\n       local.inv_pair_weak m \\<Longrightarrow>\n       state_mem_defs.map_of local.lookup2\n        (snd (run_state (local.update1 k' v) m)) \\<subseteq>\\<^sub>m\n       state_mem_defs.map_of local.lookup2 m\n 3. \\<And>m k' v.\n       local.inv_pair_weak m \\<Longrightarrow>\n       state_mem_defs.map_of local.lookup1\n        (snd (run_state (local.update2 k' v) m)) \\<subseteq>\\<^sub>m\n       state_mem_defs.map_of local.lookup1 m", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.inv_pair_weak m_ \\<Longrightarrow>\n    state_mem_defs.map_of local.lookup2\n     (snd (run_state (local.update2 k'_ v_) m_)) \\<subseteq>\\<^sub>m\n    state_mem_defs.map_of local.lookup2 m_(k'_ \\<mapsto> v_)", "using injective[unfolded injective_def]"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     to_index a = to_index b \\<and>\n     to_index a < size \\<and> to_index b < size \\<longrightarrow>\n     a = b\n\ngoal (1 subgoal):\n 1. local.inv_pair_weak m_ \\<Longrightarrow>\n    state_mem_defs.map_of local.lookup2\n     (snd (run_state (local.update2 k'_ v_) m_)) \\<subseteq>\\<^sub>m\n    state_mem_defs.map_of local.lookup2 m_(k'_ \\<mapsto> v_)", "by - (solve1, subst (asm) nth_list_update_neq, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k' v.\n       local.inv_pair_weak m \\<Longrightarrow>\n       state_mem_defs.map_of local.lookup2\n        (snd (run_state (local.update1 k' v) m)) \\<subseteq>\\<^sub>m\n       state_mem_defs.map_of local.lookup2 m\n 2. \\<And>m k' v.\n       local.inv_pair_weak m \\<Longrightarrow>\n       state_mem_defs.map_of local.lookup1\n        (snd (run_state (local.update2 k' v) m)) \\<subseteq>\\<^sub>m\n       state_mem_defs.map_of local.lookup1 m", "apply (solve1; fail)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas mem_correct_pair = pair.mem_correct_pair"], ["", "definition\n  \"mem_lookup1 k = do {m \\<leftarrow> !m_ref1; mem_lookup m k}\""], ["", "definition\n  \"mem_lookup2 k = do {m \\<leftarrow> !m_ref2; mem_lookup m k}\""], ["", "definition \"get_k1' \\<equiv> !k_ref1\""], ["", "definition \"get_k2' \\<equiv> !k_ref2\""], ["", "definition \"update1' k v \\<equiv> do {m \\<leftarrow> !m_ref1; mem_update m k v}\""], ["", "definition \"update2' k v \\<equiv> do {m \\<leftarrow> !m_ref2; mem_update m k v}\""], ["", "definition \"move12' k \\<equiv> do {\n    k1 \\<leftarrow> !k_ref1;\n    m \\<leftarrow> mem_empty;\n    m1 \\<leftarrow> !m_ref1;\n    k_ref2 := k1;\n    k_ref1 := k;\n    m_ref2 := m1;\n    m_ref1 := m\n  }\""], ["", "interpretation heap_mem_defs inv_pair_weak lookup_pair update_pair"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma rel_state_ofI:\n  \"rel_state (=) (state_of m) m\" if\n  \"\\<forall> heap. inv_pair_weak heap \\<longrightarrow> success m heap\"\n  \"lift_p inv_pair_weak m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_state (=) (state_of m) m", "using that"], ["proof (prove)\nusing this:\n  \\<forall>heap. local.inv_pair_weak heap \\<longrightarrow> success m heap\n  State_Heap.lift_p local.inv_pair_weak m\n\ngoal (1 subgoal):\n 1. local.rel_state (=) (state_of m) m", "unfolding rel_state_def"], ["proof (prove)\nusing this:\n  \\<forall>heap. local.inv_pair_weak heap \\<longrightarrow> success m heap\n  State_Heap.lift_p local.inv_pair_weak m\n\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       local.inv_pair_weak heap \\<longrightarrow>\n       (case run_state (state_of m) heap of\n        (v1, heap1) \\<Rightarrow>\n          case execute m heap of None \\<Rightarrow> False\n          | Some (v2, heap2) \\<Rightarrow>\n              v1 = v2 \\<and> heap1 = heap2 \\<and> local.inv_pair_weak heap2)", "by (auto split: option.split intro: lift_p_P'' simp: success_def)"], ["", "lemma inv_pair_iff:\n  \"inv_pair_weak = inv_pair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.inv_pair_weak = local.inv_pair", "unfolding inv_pair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.inv_pair_weak =\n    (\\<lambda>heap.\n        local.inv_pair_weak heap \\<and>\n        inv_distinct k_ref1 k_ref2 m_ref1 m_ref2)", "using inv_distinct"], ["proof (prove)\nusing this:\n  inv_distinct k_ref1 k_ref2 m_ref1 m_ref2\n\ngoal (1 subgoal):\n 1. local.inv_pair_weak =\n    (\\<lambda>heap.\n        local.inv_pair_weak heap \\<and>\n        inv_distinct k_ref1 k_ref2 m_ref1 m_ref2)", "by simp"], ["", "lemma lift_p_inv_pairI:\n  \"State_Heap.lift_p inv_pair m\" if \"State_Heap.lift_p inv_pair_weak m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Heap.lift_p local.inv_pair m", "using that"], ["proof (prove)\nusing this:\n  State_Heap.lift_p local.inv_pair_weak m\n\ngoal (1 subgoal):\n 1. State_Heap.lift_p local.inv_pair m", "unfolding inv_pair_iff"], ["proof (prove)\nusing this:\n  State_Heap.lift_p local.inv_pair m\n\ngoal (1 subgoal):\n 1. State_Heap.lift_p local.inv_pair m", "by simp"], ["", "lemma lift_p_success:\n  \"State_Heap.lift_p inv_pair_weak m\"\n  if \"DP_CRelVS.lift_p inv_pair_weak (state_of m)\" \"\\<forall> heap. inv_pair_weak heap \\<longrightarrow> success m heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Heap.lift_p local.inv_pair_weak m", "using that"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak (state_of m)\n  \\<forall>heap. local.inv_pair_weak heap \\<longrightarrow> success m heap\n\ngoal (1 subgoal):\n 1. State_Heap.lift_p local.inv_pair_weak m", "unfolding lift_p_def DP_CRelVS.lift_p_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     local.inv_pair_weak heap \\<longrightarrow>\n     (case run_state (state_of m) heap of\n      (x, xa) \\<Rightarrow> local.inv_pair_weak xa)\n  \\<forall>heap. local.inv_pair_weak heap \\<longrightarrow> success m heap\n\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       local.inv_pair_weak heap \\<longrightarrow>\n       (case execute m heap of None \\<Rightarrow> False\n        | Some (xa, xb) \\<Rightarrow> local.inv_pair_weak xb)", "by (auto simp: success_def split: option.split)"], ["", "lemma rel_state_ofI2:\n  \"rel_state (=) (state_of m) m\" if\n  \"\\<forall> heap. inv_pair_weak heap \\<longrightarrow> success m heap\"\n  \"DP_CRelVS.lift_p inv_pair_weak (state_of m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_state (=) (state_of m) m", "using that"], ["proof (prove)\nusing this:\n  \\<forall>heap. local.inv_pair_weak heap \\<longrightarrow> success m heap\n  DP_CRelVS.lift_p local.inv_pair_weak (state_of m)\n\ngoal (1 subgoal):\n 1. local.rel_state (=) (state_of m) m", "by (blast intro: rel_state_ofI lift_p_success)"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma [transfer_rule]:\n  \"((=) ===> rel_state (=)) move12 move12'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (=)) local.move12 local.move12'", "unfolding move12_def move12'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (=))\n     (\\<lambda>k.\n         state_of\n          (!k_ref1 \\<bind>\n           (\\<lambda>k1.\n               local.mem_empty \\<bind>\n               (\\<lambda>m.\n                   !m_ref1 \\<bind>\n                   (\\<lambda>m1.\n                       k_ref2 := k1 \\<bind>\n                       (\\<lambda>_.\n                           k_ref1 := k \\<bind>\n                           (\\<lambda>_.\n                               m_ref2 := m1 \\<bind>\n                               (\\<lambda>_. m_ref1 := m))))))))\n     (\\<lambda>k.\n         !k_ref1 \\<bind>\n         (\\<lambda>k1.\n             local.mem_empty \\<bind>\n             (\\<lambda>m.\n                 !m_ref1 \\<bind>\n                 (\\<lambda>m1.\n                     k_ref2 := k1 \\<bind>\n                     (\\<lambda>_.\n                         k_ref1 := k \\<bind>\n                         (\\<lambda>_.\n                             m_ref2 := m1 \\<bind>\n                             (\\<lambda>_. m_ref1 := m)))))))", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x = y \\<Longrightarrow>\n       local.rel_state (=)\n        (state_of\n          (!k_ref1 \\<bind>\n           (\\<lambda>k1.\n               local.mem_empty \\<bind>\n               (\\<lambda>m.\n                   !m_ref1 \\<bind>\n                   (\\<lambda>m1.\n                       k_ref2 := k1 \\<bind>\n                       (\\<lambda>_.\n                           k_ref1 := x \\<bind>\n                           (\\<lambda>_.\n                               m_ref2 := m1 \\<bind>\n                               (\\<lambda>_. m_ref1 := m))))))))\n        (!k_ref1 \\<bind>\n         (\\<lambda>k1.\n             local.mem_empty \\<bind>\n             (\\<lambda>m.\n                 !m_ref1 \\<bind>\n                 (\\<lambda>m1.\n                     k_ref2 := k1 \\<bind>\n                     (\\<lambda>_.\n                         k_ref1 := y \\<bind>\n                         (\\<lambda>_.\n                             m_ref2 := m1 \\<bind>\n                             (\\<lambda>_. m_ref1 := m)))))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       local.rel_state (=)\n        (state_of\n          (!k_ref1 \\<bind>\n           (\\<lambda>k1.\n               local.mem_empty \\<bind>\n               (\\<lambda>m.\n                   !m_ref1 \\<bind>\n                   (\\<lambda>m1.\n                       k_ref2 := k1 \\<bind>\n                       (\\<lambda>_.\n                           k_ref1 := x \\<bind>\n                           (\\<lambda>_.\n                               m_ref2 := m1 \\<bind>\n                               (\\<lambda>_. m_ref1 := m))))))))\n        (!k_ref1 \\<bind>\n         (\\<lambda>k1.\n             local.mem_empty \\<bind>\n             (\\<lambda>m.\n                 !m_ref1 \\<bind>\n                 (\\<lambda>m1.\n                     k_ref2 := k1 \\<bind>\n                     (\\<lambda>_.\n                         k_ref1 := x \\<bind>\n                         (\\<lambda>_.\n                             m_ref2 := m1 \\<bind>\n                             (\\<lambda>_. m_ref1 := m)))))))", "apply (rule rel_state_ofI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>heap.\n          local.inv_pair_weak heap \\<longrightarrow>\n          success\n           (!k_ref1 \\<bind>\n            (\\<lambda>k1.\n                local.mem_empty \\<bind>\n                (\\<lambda>m.\n                    !m_ref1 \\<bind>\n                    (\\<lambda>m1.\n                        k_ref2 := k1 \\<bind>\n                        (\\<lambda>_.\n                            k_ref1 := x \\<bind>\n                            (\\<lambda>_.\n                                m_ref2 := m1 \\<bind>\n                                (\\<lambda>_. m_ref1 := m)))))))\n           heap\n 2. \\<And>x.\n       DP_CRelVS.lift_p local.inv_pair_weak\n        (state_of\n          (!k_ref1 \\<bind>\n           (\\<lambda>k1.\n               local.mem_empty \\<bind>\n               (\\<lambda>m.\n                   !m_ref1 \\<bind>\n                   (\\<lambda>m1.\n                       k_ref2 := k1 \\<bind>\n                       (\\<lambda>_.\n                           k_ref1 := x \\<bind>\n                           (\\<lambda>_.\n                               m_ref2 := m1 \\<bind>\n                               (\\<lambda>_. m_ref1 := m))))))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       local.inv_pair_weak heap \\<longrightarrow>\n       success\n        (!k_ref1 \\<bind>\n         (\\<lambda>k1.\n             local.mem_empty \\<bind>\n             (\\<lambda>m.\n                 !m_ref1 \\<bind>\n                 (\\<lambda>m1.\n                     k_ref2 := k1 \\<bind>\n                     (\\<lambda>_.\n                         k_ref1 := x_ \\<bind>\n                         (\\<lambda>_.\n                             m_ref2 := m1 \\<bind>\n                             (\\<lambda>_. m_ref1 := m)))))))\n        heap", "by (auto\n        simp: mem_empty_def inv_pair_lengthD1 execute_simps Let_def\n        intro: success_intros intro!: success_bind_I\n       )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       DP_CRelVS.lift_p local.inv_pair_weak\n        (state_of\n          (!k_ref1 \\<bind>\n           (\\<lambda>k1.\n               local.mem_empty \\<bind>\n               (\\<lambda>m.\n                   !m_ref1 \\<bind>\n                   (\\<lambda>m1.\n                       k_ref2 := k1 \\<bind>\n                       (\\<lambda>_.\n                           k_ref1 := x \\<bind>\n                           (\\<lambda>_.\n                               m_ref2 := m1 \\<bind>\n                               (\\<lambda>_. m_ref1 := m))))))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of\n       (!k_ref1 \\<bind>\n        (\\<lambda>k1.\n            local.mem_empty \\<bind>\n            (\\<lambda>m.\n                !m_ref1 \\<bind>\n                (\\<lambda>m1.\n                    k_ref2 := k1 \\<bind>\n                    (\\<lambda>_.\n                        k_ref1 := x_ \\<bind>\n                        (\\<lambda>_.\n                            m_ref2 := m1 \\<bind>\n                            (\\<lambda>_. m_ref1 := m))))))))", "using pair.move12_inv"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak (local.move12 ?k1.0)\n\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of\n       (!k_ref1 \\<bind>\n        (\\<lambda>k1.\n            local.mem_empty \\<bind>\n            (\\<lambda>m.\n                !m_ref1 \\<bind>\n                (\\<lambda>m1.\n                    k_ref2 := k1 \\<bind>\n                    (\\<lambda>_.\n                        k_ref1 := x_ \\<bind>\n                        (\\<lambda>_.\n                            m_ref2 := m1 \\<bind>\n                            (\\<lambda>_. m_ref1 := m))))))))", "unfolding move12_def"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak\n   (state_of\n     (!k_ref1 \\<bind>\n      (\\<lambda>k1.\n          local.mem_empty \\<bind>\n          (\\<lambda>m.\n              !m_ref1 \\<bind>\n              (\\<lambda>m1.\n                  k_ref2 := k1 \\<bind>\n                  (\\<lambda>_.\n                      k_ref1 := ?k1.0 \\<bind>\n                      (\\<lambda>_.\n                          m_ref2 := m1 \\<bind>\n                          (\\<lambda>_. m_ref1 := m))))))))\n\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of\n       (!k_ref1 \\<bind>\n        (\\<lambda>k1.\n            local.mem_empty \\<bind>\n            (\\<lambda>m.\n                !m_ref1 \\<bind>\n                (\\<lambda>m1.\n                    k_ref2 := k1 \\<bind>\n                    (\\<lambda>_.\n                        k_ref1 := x_ \\<bind>\n                        (\\<lambda>_.\n                            m_ref2 := m1 \\<bind>\n                            (\\<lambda>_. m_ref1 := m))))))))", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [transfer_rule]:\n  \"((=) ===> rel_state (rel_option (=))) lookup1 mem_lookup1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (rel_option (=))) local.lookup1\n     local.mem_lookup1", "unfolding lookup1_def mem_lookup1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (rel_option (=)))\n     (\\<lambda>k.\n         state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m k)))\n     (\\<lambda>k. !m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m k))", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x = y \\<Longrightarrow>\n       local.rel_state (rel_option (=))\n        (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x)))\n        (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m y))", "apply (simp add: option.rel_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       local.rel_state (=)\n        (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x)))\n        (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x))", "apply (rule rel_state_ofI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>heap.\n          local.inv_pair_weak heap \\<longrightarrow>\n          success (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x)) heap\n 2. \\<And>x.\n       DP_CRelVS.lift_p local.inv_pair_weak\n        (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       local.inv_pair_weak heap \\<longrightarrow>\n       success (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x_)) heap", "by (auto 4 4\n        simp: mem_lookup_def inv_pair_lengthD1 execute_simps Let_def\n        intro: success_bind_executeI success_returnI Array.success_nthI\n       )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       DP_CRelVS.lift_p local.inv_pair_weak\n        (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x_)))", "using pair.lookup_inv(1)"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak (local.lookup1 ?k')\n\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x_)))", "unfolding lookup1_def"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak\n   (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m ?k')))\n\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x_)))", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [transfer_rule]:\n  \"((=) ===> rel_state (rel_option (=))) lookup2 mem_lookup2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (rel_option (=))) local.lookup2\n     local.mem_lookup2", "unfolding lookup2_def mem_lookup2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (rel_option (=)))\n     (\\<lambda>k.\n         state_of (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m k)))\n     (\\<lambda>k. !m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m k))", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x = y \\<Longrightarrow>\n       local.rel_state (rel_option (=))\n        (state_of (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m x)))\n        (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m y))", "apply (simp add: option.rel_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       local.rel_state (=)\n        (state_of (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m x)))\n        (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m x))", "apply (rule rel_state_ofI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>heap.\n          local.inv_pair_weak heap \\<longrightarrow>\n          success (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m x)) heap\n 2. \\<And>x.\n       DP_CRelVS.lift_p local.inv_pair_weak\n        (state_of (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m x)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       local.inv_pair_weak heap \\<longrightarrow>\n       success (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m x_)) heap", "by (auto 4 3\n        simp: mem_lookup_def inv_pair_lengthD2 execute_simps Let_def\n        intro: success_intros intro!: success_bind_I\n       )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       DP_CRelVS.lift_p local.inv_pair_weak\n        (state_of (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m x)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m x_)))", "using pair.lookup_inv(2)"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak (local.lookup2 ?k')\n\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m x_)))", "unfolding lookup2_def"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak\n   (state_of (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m ?k')))\n\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of (!m_ref2 \\<bind> (\\<lambda>m. local.mem_lookup m x_)))", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [transfer_rule]:\n  \"rel_state (=) get_k1 get_k1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_state (=) local.get_k1 local.get_k1'", "unfolding get_k1_def get_k1'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_state (=) (state_of (!k_ref1)) (!k_ref1)", "apply (rule rel_state_ofI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>heap.\n       local.inv_pair_weak heap \\<longrightarrow> success (!k_ref1) heap\n 2. DP_CRelVS.lift_p local.inv_pair_weak (state_of (!k_ref1))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       local.inv_pair_weak heap \\<longrightarrow> success (!k_ref1) heap", "by (auto intro: success_lookupI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak (state_of (!k_ref1))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak (state_of (!k_ref1))", "unfolding get_k1_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak local.get_k1", "by (auto dest: pair.get_state(1) intro: lift_pI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [transfer_rule]:\n  \"rel_state (=) get_k2 get_k2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_state (=) local.get_k2 local.get_k2'", "unfolding get_k2_def get_k2'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_state (=) (state_of (!k_ref2)) (!k_ref2)", "apply (rule rel_state_ofI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>heap.\n       local.inv_pair_weak heap \\<longrightarrow> success (!k_ref2) heap\n 2. DP_CRelVS.lift_p local.inv_pair_weak (state_of (!k_ref2))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       local.inv_pair_weak heap \\<longrightarrow> success (!k_ref2) heap", "by (auto intro: success_lookupI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak (state_of (!k_ref2))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak (state_of (!k_ref2))", "unfolding get_k2_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak local.get_k2", "by (auto dest: pair.get_state(2) intro: lift_pI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [transfer_rule]:\n  \"((=) ===> (=) ===> rel_state (=)) update1 update1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> local.rel_state (=)) local.update1 local.update1'", "unfolding update1_def update1'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> local.rel_state (=))\n     (\\<lambda>k v.\n         state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_update m k v)))\n     (\\<lambda>k v. !m_ref1 \\<bind> (\\<lambda>m. local.mem_update m k v))", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> local.rel_state (=)\n                          (state_of\n                            (!m_ref1 \\<bind>\n                             (\\<lambda>m. local.mem_update m x xa)))\n                          (!m_ref1 \\<bind>\n                           (\\<lambda>m. local.mem_update m y ya))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> local.rel_state (=)\n                          (state_of\n                            (!m_ref1 \\<bind>\n                             (\\<lambda>m. local.mem_update m y ya)))\n                          (!m_ref1 \\<bind>\n                           (\\<lambda>m. local.mem_update m y ya))", "apply (rule rel_state_ofI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> \\<forall>heap.\n                            local.inv_pair_weak heap \\<longrightarrow>\n                            success\n                             (!m_ref1 \\<bind>\n                              (\\<lambda>m. local.mem_update m y ya))\n                             heap\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> DP_CRelVS.lift_p local.inv_pair_weak\n                          (state_of\n                            (!m_ref1 \\<bind>\n                             (\\<lambda>m. local.mem_update m y ya)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ = y_; xa_ = ya_\\<rbrakk>\n    \\<Longrightarrow> \\<forall>heap.\n                         local.inv_pair_weak heap \\<longrightarrow>\n                         success\n                          (!m_ref1 \\<bind>\n                           (\\<lambda>m. local.mem_update m y_ ya_))\n                          heap", "by (auto 4 3\n        simp: mem_update_def inv_pair_lengthD1 execute_simps Let_def\n        intro: success_intros intro!: success_bind_I\n       )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> DP_CRelVS.lift_p local.inv_pair_weak\n                          (state_of\n                            (!m_ref1 \\<bind>\n                             (\\<lambda>m. local.mem_update m y ya)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ = y_; xa_ = ya_\\<rbrakk>\n    \\<Longrightarrow> DP_CRelVS.lift_p local.inv_pair_weak\n                       (state_of\n                         (!m_ref1 \\<bind>\n                          (\\<lambda>m. local.mem_update m y_ ya_)))", "using pair.update_inv(1)"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak (local.update1 ?k' ?v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ = y_; xa_ = ya_\\<rbrakk>\n    \\<Longrightarrow> DP_CRelVS.lift_p local.inv_pair_weak\n                       (state_of\n                         (!m_ref1 \\<bind>\n                          (\\<lambda>m. local.mem_update m y_ ya_)))", "unfolding update1_def"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak\n   (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_update m ?k' ?v)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ = y_; xa_ = ya_\\<rbrakk>\n    \\<Longrightarrow> DP_CRelVS.lift_p local.inv_pair_weak\n                       (state_of\n                         (!m_ref1 \\<bind>\n                          (\\<lambda>m. local.mem_update m y_ ya_)))", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [transfer_rule]:\n  \"((=) ===> (=) ===> rel_state (=)) update2 update2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> local.rel_state (=)) local.update2 local.update2'", "unfolding update2_def update2'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> local.rel_state (=))\n     (\\<lambda>k v.\n         state_of (!m_ref2 \\<bind> (\\<lambda>m. local.mem_update m k v)))\n     (\\<lambda>k v. !m_ref2 \\<bind> (\\<lambda>m. local.mem_update m k v))", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> local.rel_state (=)\n                          (state_of\n                            (!m_ref2 \\<bind>\n                             (\\<lambda>m. local.mem_update m x xa)))\n                          (!m_ref2 \\<bind>\n                           (\\<lambda>m. local.mem_update m y ya))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> local.rel_state (=)\n                          (state_of\n                            (!m_ref2 \\<bind>\n                             (\\<lambda>m. local.mem_update m y ya)))\n                          (!m_ref2 \\<bind>\n                           (\\<lambda>m. local.mem_update m y ya))", "apply (rule rel_state_ofI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> \\<forall>heap.\n                            local.inv_pair_weak heap \\<longrightarrow>\n                            success\n                             (!m_ref2 \\<bind>\n                              (\\<lambda>m. local.mem_update m y ya))\n                             heap\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> DP_CRelVS.lift_p local.inv_pair_weak\n                          (state_of\n                            (!m_ref2 \\<bind>\n                             (\\<lambda>m. local.mem_update m y ya)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ = y_; xa_ = ya_\\<rbrakk>\n    \\<Longrightarrow> \\<forall>heap.\n                         local.inv_pair_weak heap \\<longrightarrow>\n                         success\n                          (!m_ref2 \\<bind>\n                           (\\<lambda>m. local.mem_update m y_ ya_))\n                          heap", "by (auto 4 3\n        simp: mem_update_def inv_pair_lengthD2 execute_simps Let_def\n        intro: success_intros intro!: success_bind_I\n       )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> DP_CRelVS.lift_p local.inv_pair_weak\n                          (state_of\n                            (!m_ref2 \\<bind>\n                             (\\<lambda>m. local.mem_update m y ya)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ = y_; xa_ = ya_\\<rbrakk>\n    \\<Longrightarrow> DP_CRelVS.lift_p local.inv_pair_weak\n                       (state_of\n                         (!m_ref2 \\<bind>\n                          (\\<lambda>m. local.mem_update m y_ ya_)))", "using pair.update_inv(2)"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak (local.update2 ?k' ?v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ = y_; xa_ = ya_\\<rbrakk>\n    \\<Longrightarrow> DP_CRelVS.lift_p local.inv_pair_weak\n                       (state_of\n                         (!m_ref2 \\<bind>\n                          (\\<lambda>m. local.mem_update m y_ ya_)))", "unfolding update2_def"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak\n   (state_of (!m_ref2 \\<bind> (\\<lambda>m. local.mem_update m ?k' ?v)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ = y_; xa_ = ya_\\<rbrakk>\n    \\<Longrightarrow> DP_CRelVS.lift_p local.inv_pair_weak\n                       (state_of\n                         (!m_ref2 \\<bind>\n                          (\\<lambda>m. local.mem_update m y_ ya_)))", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [transfer_rule]:\n  \"((=) ===> rel_state (rel_option (=))) lookup1 mem_lookup1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (rel_option (=))) local.lookup1\n     local.mem_lookup1", "unfolding lookup1_def mem_lookup1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (rel_option (=)))\n     (\\<lambda>k.\n         state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m k)))\n     (\\<lambda>k. !m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m k))", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x = y \\<Longrightarrow>\n       local.rel_state (rel_option (=))\n        (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x)))\n        (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m y))", "apply (simp add: option.rel_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       local.rel_state (=)\n        (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x)))\n        (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x))", "apply (rule rel_state_ofI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>heap.\n          local.inv_pair_weak heap \\<longrightarrow>\n          success (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x)) heap\n 2. \\<And>x.\n       DP_CRelVS.lift_p local.inv_pair_weak\n        (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       local.inv_pair_weak heap \\<longrightarrow>\n       success (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x_)) heap", "by (auto 4 3\n        simp: mem_lookup_def inv_pair_lengthD1 execute_simps Let_def\n        intro: success_intros intro!: success_bind_I\n       )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       DP_CRelVS.lift_p local.inv_pair_weak\n        (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x_)))", "using pair.lookup_inv(1)"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak (local.lookup1 ?k')\n\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x_)))", "unfolding lookup1_def"], ["proof (prove)\nusing this:\n  DP_CRelVS.lift_p local.inv_pair_weak\n   (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m ?k')))\n\ngoal (1 subgoal):\n 1. DP_CRelVS.lift_p local.inv_pair_weak\n     (state_of (!m_ref1 \\<bind> (\\<lambda>m. local.mem_lookup m x_)))", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_state_lookup:\n  \"((=) ===> rel_state (=)) pair.lookup_pair lookup_pair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (=)) pair.lookup_pair local.lookup_pair", "unfolding pair.lookup_pair_def lookup_pair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (=))\n     (\\<lambda>k.\n         let k' = key1 k\n         in local.get_k2 \\<bind>\n            (\\<lambda>k2.\n                if k' = k2 then local.lookup2 (key2 k)\n                else local.get_k1 \\<bind>\n                     (\\<lambda>k1.\n                         if k' = k1 then local.lookup1 (key2 k)\n                         else State_Monad.return None)))\n     (\\<lambda>k.\n         let k' = key1 k\n         in !k_ref2 \\<bind>\n            (\\<lambda>k2.\n                if k' = k2\n                then !m_ref2 \\<bind>\n                     (\\<lambda>m2. local.mem_lookup m2 (key2 k))\n                else !k_ref1 \\<bind>\n                     (\\<lambda>k1.\n                         if k' = k1\n                         then !m_ref1 \\<bind>\n                              (\\<lambda>m1. local.mem_lookup m1 (key2 k))\n                         else return None)))", "unfolding\n    mem_lookup1_def[symmetric] mem_lookup2_def[symmetric]\n    get_k2_def[symmetric] get_k2'_def[symmetric]\n    get_k1_def[symmetric] get_k1'_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> local.rel_state (=))\n     (\\<lambda>k.\n         let k' = key1 k\n         in local.get_k2 \\<bind>\n            (\\<lambda>k2.\n                if k' = k2 then local.lookup2 (key2 k)\n                else local.get_k1 \\<bind>\n                     (\\<lambda>k1.\n                         if k' = k1 then local.lookup1 (key2 k)\n                         else State_Monad.return None)))\n     (\\<lambda>k.\n         let k' = key1 k\n         in local.get_k2' \\<bind>\n            (\\<lambda>k2.\n                if k' = k2 then local.mem_lookup2 (key2 k)\n                else local.get_k1' \\<bind>\n                     (\\<lambda>k1.\n                         if k' = k1 then local.mem_lookup1 (key2 k)\n                         else return None)))", "by transfer_prover"], ["", "lemma rel_state_update:\n  \"((=) ===> (=) ===> rel_state (=)) pair.update_pair update_pair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> local.rel_state (=)) pair.update_pair\n     local.update_pair", "unfolding pair.update_pair_def update_pair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> local.rel_state (=))\n     (\\<lambda>k v.\n         let k' = key1 k\n         in local.get_k1 \\<bind>\n            (\\<lambda>k1.\n                if k' = k1 then local.update1 (key2 k) v\n                else local.get_k2 \\<bind>\n                     (\\<lambda>k2.\n                         if k' = k2 then local.update2 (key2 k) v\n                         else local.move12 k' \\<bind>\n                              (\\<lambda>_. local.update1 (key2 k) v))))\n     (\\<lambda>k v.\n         let k' = key1 k\n         in !k_ref1 \\<bind>\n            (\\<lambda>k1.\n                if k' = k1\n                then !m_ref1 \\<bind>\n                     (\\<lambda>m. local.mem_update m (key2 k) v)\n                else !k_ref2 \\<bind>\n                     (\\<lambda>k2.\n                         if k' = k2\n                         then !m_ref2 \\<bind>\n                              (\\<lambda>m. local.mem_update m (key2 k) v)\n                         else !k_ref1 \\<bind>\n                              (\\<lambda>k1.\n                                  local.mem_empty \\<bind>\n                                  (\\<lambda>m.\n!m_ref1 \\<bind>\n(\\<lambda>m1.\n    k_ref2 := k1 \\<bind>\n    (\\<lambda>_.\n        k_ref1 := k' \\<bind>\n        (\\<lambda>_.\n            m_ref2 := m1 \\<bind> (\\<lambda>_. m_ref1 := m)))))) \\<bind>\n                              (\\<lambda>_.\n                                  !m_ref1 \\<bind>\n                                  (\\<lambda>m.\nlocal.mem_update m (key2 k) v)))))", "unfolding move12'_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> local.rel_state (=))\n     (\\<lambda>k v.\n         let k' = key1 k\n         in local.get_k1 \\<bind>\n            (\\<lambda>k1.\n                if k' = k1 then local.update1 (key2 k) v\n                else local.get_k2 \\<bind>\n                     (\\<lambda>k2.\n                         if k' = k2 then local.update2 (key2 k) v\n                         else local.move12 k' \\<bind>\n                              (\\<lambda>_. local.update1 (key2 k) v))))\n     (\\<lambda>k v.\n         let k' = key1 k\n         in !k_ref1 \\<bind>\n            (\\<lambda>k1.\n                if k' = k1\n                then !m_ref1 \\<bind>\n                     (\\<lambda>m. local.mem_update m (key2 k) v)\n                else !k_ref2 \\<bind>\n                     (\\<lambda>k2.\n                         if k' = k2\n                         then !m_ref2 \\<bind>\n                              (\\<lambda>m. local.mem_update m (key2 k) v)\n                         else local.move12' k' \\<bind>\n                              (\\<lambda>_.\n                                  !m_ref1 \\<bind>\n                                  (\\<lambda>m.\nlocal.mem_update m (key2 k) v)))))", "unfolding\n    update1'_def[symmetric] update2'_def[symmetric]\n    get_k2_def[symmetric] get_k2'_def[symmetric]\n    get_k1_def[symmetric] get_k1'_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> local.rel_state (=))\n     (\\<lambda>k v.\n         let k' = key1 k\n         in local.get_k1 \\<bind>\n            (\\<lambda>k1.\n                if k' = k1 then local.update1 (key2 k) v\n                else local.get_k2 \\<bind>\n                     (\\<lambda>k2.\n                         if k' = k2 then local.update2 (key2 k) v\n                         else local.move12 k' \\<bind>\n                              (\\<lambda>_. local.update1 (key2 k) v))))\n     (\\<lambda>k v.\n         let k' = key1 k\n         in local.get_k1' \\<bind>\n            (\\<lambda>k1.\n                if k' = k1 then local.update1' (key2 k) v\n                else local.get_k2' \\<bind>\n                     (\\<lambda>k2.\n                         if k' = k2 then local.update2' (key2 k) v\n                         else local.move12' k' \\<bind>\n                              (\\<lambda>_. local.update1' (key2 k) v))))", "by transfer_prover"], ["", "interpretation mem: heap_mem_defs pair.inv_pair lookup_pair update_pair"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma inv_pairD:\n  \"inv_pair_weak heap\" if \"pair.inv_pair heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.inv_pair_weak heap", "using that"], ["proof (prove)\nusing this:\n  pair.inv_pair heap\n\ngoal (1 subgoal):\n 1. local.inv_pair_weak heap", "unfolding pair.inv_pair_def"], ["proof (prove)\nusing this:\n  let k1 = fst (run_state local.get_k1 heap);\n      k2 = fst (run_state local.get_k2 heap)\n  in (\\<forall>k\\<in>dom (pair.mem1.map_of heap).\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>dom (pair.mem2.map_of heap).\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> local.inv_pair_weak heap\n\ngoal (1 subgoal):\n 1. local.inv_pair_weak heap", "by (auto simp: Let_def)"], ["", "lemma mem_rel_state_ofI:\n  \"mem.rel_state (=) m' m\" if\n  \"rel_state (=) m' m\"\n  \"\\<And> heap. pair.inv_pair heap \\<Longrightarrow>\n    (case State_Monad.run_state m' heap of (_, heap) \\<Rightarrow> inv_pair_weak heap \\<longrightarrow> pair.inv_pair heap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem.rel_state (=) m' m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mem.rel_state (=) m' m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mem.rel_state (=) m' m", "apply (rule mem.rel_state_intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>heap v heap'.\n       \\<lbrakk>pair.inv_pair heap; run_state m' heap = (v, heap')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'.\n                            v = v' \\<and> execute m heap = Some (v', heap')\n 2. \\<And>heap v heap'.\n       \\<lbrakk>pair.inv_pair heap; run_state m' heap = (v, heap')\\<rbrakk>\n       \\<Longrightarrow> pair.inv_pair heap'", "subgoal for heap v heap'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pair.inv_pair heap; run_state m' heap = (v, heap')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v'.\n                         v = v' \\<and> execute m heap = Some (v', heap')", "by (auto elim: rel_state_elim[OF that(1)] dest!: inv_pairD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>heap v heap'.\n       \\<lbrakk>pair.inv_pair heap; run_state m' heap = (v, heap')\\<rbrakk>\n       \\<Longrightarrow> pair.inv_pair heap'", "subgoal premises prems for heap v heap'"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.inv_pair heap'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pair.inv_pair heap'", "from prems that(1)"], ["proof (chain)\npicking this:\n  pair.inv_pair heap\n  run_state m' heap = (v, heap')\n  local.rel_state (=) m' m", "have \"inv_pair_weak heap'\""], ["proof (prove)\nusing this:\n  pair.inv_pair heap\n  run_state m' heap = (v, heap')\n  local.rel_state (=) m' m\n\ngoal (1 subgoal):\n 1. local.inv_pair_weak heap'", "by (fastforce elim: rel_state_elim dest: inv_pairD)"], ["proof (state)\nthis:\n  local.inv_pair_weak heap'\n\ngoal (1 subgoal):\n 1. pair.inv_pair heap'", "with prems"], ["proof (chain)\npicking this:\n  pair.inv_pair heap\n  run_state m' heap = (v, heap')\n  local.inv_pair_weak heap'", "show ?thesis"], ["proof (prove)\nusing this:\n  pair.inv_pair heap\n  run_state m' heap = (v, heap')\n  local.inv_pair_weak heap'\n\ngoal (1 subgoal):\n 1. pair.inv_pair heap'", "by (auto dest: that(2))"], ["proof (state)\nthis:\n  pair.inv_pair heap'\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mem.rel_state (=) m' m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_rel_state_ofI':\n  \"mem.rel_state (=) m' m\" if\n  \"rel_state (=) m' m\"\n  \"DP_CRelVS.lift_p pair.inv_pair m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem.rel_state (=) m' m", "using that"], ["proof (prove)\nusing this:\n  local.rel_state (=) m' m\n  DP_CRelVS.lift_p pair.inv_pair m'\n\ngoal (1 subgoal):\n 1. mem.rel_state (=) m' m", "by (auto elim: DP_CRelVS.lift_p_P intro: mem_rel_state_ofI)"], ["", "context\n  assumes keys: \"\\<forall>k k'. key1 k = key1 k' \\<and> key2 k = key2 k' \\<longrightarrow> k = k'\"\nbegin"], ["", "interpretation mem_correct pair.lookup_pair pair.update_pair pair.inv_pair"], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct pair.lookup_pair pair.update_pair pair.inv_pair", "by (rule mem_correct_pair[OF keys])"], ["", "lemma rel_state_lookup':\n  \"((=) ===> mem.rel_state (=)) pair.lookup_pair lookup_pair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> mem.rel_state (=)) pair.lookup_pair local.lookup_pair", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x = y \\<Longrightarrow>\n       mem.rel_state (=) (pair.lookup_pair x) (local.lookup_pair y)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. mem.rel_state (=) (pair.lookup_pair x) (local.lookup_pair x)", "apply (rule mem_rel_state_ofI')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. local.rel_state (=) (pair.lookup_pair x) (local.lookup_pair x)\n 2. \\<And>x. DP_CRelVS.lift_p pair.inv_pair (pair.lookup_pair x)", "using rel_state_lookup"], ["proof (prove)\nusing this:\n  ((=) ===> local.rel_state (=)) pair.lookup_pair local.lookup_pair\n\ngoal (2 subgoals):\n 1. \\<And>x. local.rel_state (=) (pair.lookup_pair x) (local.lookup_pair x)\n 2. \\<And>x. DP_CRelVS.lift_p pair.inv_pair (pair.lookup_pair x)", "apply (rule rel_funD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x = x\n 2. \\<And>x. DP_CRelVS.lift_p pair.inv_pair (pair.lookup_pair x)", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. DP_CRelVS.lift_p pair.inv_pair (pair.lookup_pair x)", "apply (rule lookup_inv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_state_update':\n  \"((=) ===> (=) ===> mem.rel_state (=)) pair.update_pair update_pair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> mem.rel_state (=)) pair.update_pair local.update_pair", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> mem.rel_state (=) (pair.update_pair x xa)\n                          (local.update_pair y ya)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> mem.rel_state (=) (pair.update_pair y ya)\n                          (local.update_pair y ya)", "apply (rule mem_rel_state_ofI')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> local.rel_state (=) (pair.update_pair y ya)\n                          (local.update_pair y ya)\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> DP_CRelVS.lift_p pair.inv_pair\n                          (pair.update_pair y ya)", "subgoal for x y a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = y; a = b\\<rbrakk>\n    \\<Longrightarrow> local.rel_state (=) (pair.update_pair y b)\n                       (local.update_pair y b)", "using rel_state_update"], ["proof (prove)\nusing this:\n  ((=) ===> (=) ===> local.rel_state (=)) pair.update_pair local.update_pair\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = y; a = b\\<rbrakk>\n    \\<Longrightarrow> local.rel_state (=) (pair.update_pair y b)\n                       (local.update_pair y b)", "by (blast dest: rel_funD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> DP_CRelVS.lift_p pair.inv_pair\n                          (pair.update_pair y ya)", "by (rule update_inv)"], ["", "interpretation heap_correct pair.inv_pair update_pair lookup_pair"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_correct pair.inv_pair local.update_pair local.lookup_pair", "by (rule mem.mem_correct_heap_correct[OF _ rel_state_lookup' rel_state_update']) standard"], ["", "lemmas heap_correct_pairI = heap_correct_axioms"], ["", "(* TODO: Generalize *)"], ["", "lemma mem_rel_state_resultD:\n  \"result_of m heap = fst (run_state m' heap)\" if \"mem.rel_state (=) m' m\" \"pair.inv_pair heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result_of m heap = fst (run_state m' heap)", "by (metis (mono_tags, lifting) mem.rel_state_elim option.sel that)"], ["", "lemma map_of_heap_eq:\n  \"mem.map_of_heap heap = pair.pair.map_of heap\" if \"pair.inv_pair heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem.map_of_heap heap = pair.pair.map_of heap", "unfolding mem.map_of_heap_def pair.pair.map_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. result_of (local.lookup_pair k) heap) =\n    (\\<lambda>k. fst (run_state (pair.lookup_pair k) heap))", "using that"], ["proof (prove)\nusing this:\n  pair.inv_pair heap\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. result_of (local.lookup_pair k) heap) =\n    (\\<lambda>k. fst (run_state (pair.lookup_pair k) heap))", "by (simp add: mem_rel_state_resultD[OF rel_state_lookup'[THEN rel_funD]])"], ["", "context\n  fixes k1 k2 heap heap'\n  assumes init: \"execute (init_state k1 k2) heap = Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\"\nbegin"], ["", "lemma init_state_empty1:\n  \"pair.mem1.map_of heap' k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.mem1.map_of heap' k = None", "using init"], ["proof (prove)\nusing this:\n  execute (local.init_state k1 k2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. pair.mem1.map_of heap' k = None", "unfolding pair.mem1.map_of_def lookup1_def mem_lookup_def init_state_def"], ["proof (prove)\nusing this:\n  execute\n   (local.mem_empty \\<bind>\n    (\\<lambda>m1. local.mem_empty \\<bind> init_state_inner k1 k2 m1))\n   heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. fst (run_state\n          (state_of\n            (!m_ref1 \\<bind>\n             (\\<lambda>m.\n                 let i = to_index k\n                 in if i < size then Array.nth m i else return None)))\n          heap') =\n    None", "by (auto\n        simp: init_state_inner_nth init_state_inner_alloc(3) execute_simps Let_def\n        elim!: execute_bind_success'[OF success_empty])\n     (metis\n        Array.present_alloc Memory_Heap.length_mem_empty execute_new execute_nth(1) fst_conv\n        length_def mem_empty_def nth_mem_empty option.sel present_alloc_get snd_conv\n     )"], ["", "lemma init_state_empty2:\n  \"pair.mem2.map_of heap' k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.mem2.map_of heap' k = None", "using init"], ["proof (prove)\nusing this:\n  execute (local.init_state k1 k2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. pair.mem2.map_of heap' k = None", "unfolding pair.mem2.map_of_def lookup2_def mem_lookup_def init_state_def"], ["proof (prove)\nusing this:\n  execute\n   (local.mem_empty \\<bind>\n    (\\<lambda>m1. local.mem_empty \\<bind> init_state_inner k1 k2 m1))\n   heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. fst (run_state\n          (state_of\n            (!m_ref2 \\<bind>\n             (\\<lambda>m.\n                 let i = to_index k\n                 in if i < size then Array.nth m i else return None)))\n          heap') =\n    None", "by (auto\n        simp: execute_simps init_state_inner_nth init_state_inner_alloc(4) Let_def\n        elim!: execute_bind_success'[OF success_empty]\n     )\n     (metis fst_conv nth_mem_empty option.sel snd_conv)"], ["", "lemma\n  shows init_state_k1: \"result_of (!k_ref1) heap' = k1\"\n    and init_state_k2: \"result_of (!k_ref2) heap' = k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result_of (!k_ref1) heap' = k1 &&& result_of (!k_ref2) heap' = k2", "using init init_state_inner_alloc"], ["proof (prove)\nusing this:\n  execute (local.init_state k1 k2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n  execute (init_state_inner ?k1.0 ?k2.0 ?m1.0 ?m2.0) ?heap =\n  Some\n   ((?k_ref1.0, ?k_ref2.0, ?m_ref1.0, ?m_ref2.0), ?heap') \\<Longrightarrow>\n  Ref.get ?heap' ?k_ref1.0 = ?k1.0\n  execute (init_state_inner ?k1.0 ?k2.0 ?m1.0 ?m2.0) ?heap =\n  Some\n   ((?k_ref1.0, ?k_ref2.0, ?m_ref1.0, ?m_ref2.0), ?heap') \\<Longrightarrow>\n  Ref.get ?heap' ?k_ref2.0 = ?k2.0\n  execute (init_state_inner ?k1.0 ?k2.0 ?m1.0 ?m2.0) ?heap =\n  Some\n   ((?k_ref1.0, ?k_ref2.0, ?m_ref1.0, ?m_ref2.0), ?heap') \\<Longrightarrow>\n  Ref.get ?heap' ?m_ref1.0 = ?m1.0\n  execute (init_state_inner ?k1.0 ?k2.0 ?m1.0 ?m2.0) ?heap =\n  Some\n   ((?k_ref1.0, ?k_ref2.0, ?m_ref1.0, ?m_ref2.0), ?heap') \\<Longrightarrow>\n  Ref.get ?heap' ?m_ref2.0 = ?m2.0\n\ngoal (1 subgoal):\n 1. result_of (!k_ref1) heap' = k1 &&& result_of (!k_ref2) heap' = k2", "by (auto simp: execute_simps init_state_def elim!: execute_bind_success'[OF success_empty])"], ["", "context\n  assumes neq: \"k1 \\<noteq> k2\"\nbegin"], ["", "lemma init_state_inv':\n  \"pair.inv_pair heap'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.inv_pair heap'", "unfolding pair.inv_pair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let k1 = fst (run_state local.get_k1 heap');\n        k2 = fst (run_state local.get_k2 heap')\n    in (\\<forall>k\\<in>dom (pair.mem1.map_of heap').\n           \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n       (\\<forall>k\\<in>dom (pair.mem2.map_of heap').\n           \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n       k1 \\<noteq> k2 \\<and> local.inv_pair_weak heap'", "apply (auto simp: Let_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k y.\n       pair.mem1.map_of heap' k = Some y \\<Longrightarrow>\n       \\<exists>k'.\n          key1 k' = fst (run_state local.get_k1 heap') \\<and> key2 k' = k\n 2. \\<And>k y.\n       pair.mem2.map_of heap' k = Some y \\<Longrightarrow>\n       \\<exists>k'.\n          key1 k' = fst (run_state local.get_k2 heap') \\<and> key2 k' = k\n 3. fst (run_state local.get_k1 heap') =\n    fst (run_state local.get_k2 heap') \\<Longrightarrow>\n    False\n 4. local.inv_pair_weak heap'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.mem1.map_of heap' k_ = Some y_ \\<Longrightarrow>\n    \\<exists>k'.\n       key1 k' = fst (run_state local.get_k1 heap') \\<and> key2 k' = k_", "using init_state_empty1"], ["proof (prove)\nusing this:\n  pair.mem1.map_of heap' ?k = None\n\ngoal (1 subgoal):\n 1. pair.mem1.map_of heap' k_ = Some y_ \\<Longrightarrow>\n    \\<exists>k'.\n       key1 k' = fst (run_state local.get_k1 heap') \\<and> key2 k' = k_", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k y.\n       pair.mem2.map_of heap' k = Some y \\<Longrightarrow>\n       \\<exists>k'.\n          key1 k' = fst (run_state local.get_k2 heap') \\<and> key2 k' = k\n 2. fst (run_state local.get_k1 heap') =\n    fst (run_state local.get_k2 heap') \\<Longrightarrow>\n    False\n 3. local.inv_pair_weak heap'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.mem2.map_of heap' k_ = Some y_ \\<Longrightarrow>\n    \\<exists>k'.\n       key1 k' = fst (run_state local.get_k2 heap') \\<and> key2 k' = k_", "using init_state_empty2"], ["proof (prove)\nusing this:\n  pair.mem2.map_of heap' ?k = None\n\ngoal (1 subgoal):\n 1. pair.mem2.map_of heap' k_ = Some y_ \\<Longrightarrow>\n    \\<exists>k'.\n       key1 k' = fst (run_state local.get_k2 heap') \\<and> key2 k' = k_", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. fst (run_state local.get_k1 heap') =\n    fst (run_state local.get_k2 heap') \\<Longrightarrow>\n    False\n 2. local.inv_pair_weak heap'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (run_state local.get_k1 heap') =\n    fst (run_state local.get_k2 heap') \\<Longrightarrow>\n    False", "using neq init"], ["proof (prove)\nusing this:\n  k1 \\<noteq> k2\n  execute (local.init_state k1 k2) heap =\n  Some ((k_ref1, k_ref2, m_ref1, m_ref2), heap')\n\ngoal (1 subgoal):\n 1. fst (run_state local.get_k1 heap') =\n    fst (run_state local.get_k2 heap') \\<Longrightarrow>\n    False", "by (simp add: get_k1_def get_k2_def init_state_k1 init_state_k2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.inv_pair_weak heap'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.inv_pair_weak heap'", "by (rule init_state_inv[OF init])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma init_state_empty:\n  \"pair.pair.map_of heap' \\<subseteq>\\<^sub>m Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.pair.map_of heap' \\<subseteq>\\<^sub>m Map.empty", "using neq"], ["proof (prove)\nusing this:\n  k1 \\<noteq> k2\n\ngoal (1 subgoal):\n 1. pair.pair.map_of heap' \\<subseteq>\\<^sub>m Map.empty", "by (intro pair.emptyI init_state_inv' map_emptyI init_state_empty1 init_state_empty2)"], ["", "interpretation heap_correct_empty pair.inv_pair update_pair lookup_pair heap'"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_correct_empty pair.inv_pair local.update_pair local.lookup_pair\n     heap'", "apply (rule heap_correct_empty.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. heap_correct pair.inv_pair local.update_pair local.lookup_pair\n 2. heap_correct_empty_axioms pair.inv_pair local.lookup_pair heap'", "apply (rule heap_correct_pairI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_correct_empty_axioms pair.inv_pair local.lookup_pair heap'", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. mem.map_of_heap heap' \\<subseteq>\\<^sub>m Map.empty\n 2. pair.inv_pair heap'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mem.map_of_heap heap' \\<subseteq>\\<^sub>m Map.empty", "by (subst map_of_heap_eq; intro init_state_inv' init_state_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.inv_pair heap'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.inv_pair heap'", "by (rule init_state_inv')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas heap_correct_empty_pairI = heap_correct_empty_axioms"], ["", "context\n  fixes dp :: \"'k \\<Rightarrow> 'v\"\nbegin"], ["", "interpretation dp_consistency_heap_empty\n  pair.inv_pair update_pair lookup_pair dp heap'"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_heap_empty pair.inv_pair local.update_pair\n     local.lookup_pair heap'", "by standard"], ["", "lemmas consistent_empty_pairI = dp_consistency_heap_empty_axioms"], ["", "end"], ["", "(* DP *)"], ["", "end"], ["", "(* Unequal Keys *)"], ["", "end"], ["", "(* Init State *)"], ["", "end"], ["", "(* Keys injective *)"], ["", "end"], ["", "(* Lifting Syntax *)"], ["", "end"], ["", "(* Disjoint *)"], ["", "end"], ["", "(* Injectivity *)"], ["", "end"], ["", "(* Refs *)"], ["", "end"], ["", "(* Key functions & Size *)"], ["", "end"], ["", "(* Theory *)"]]}