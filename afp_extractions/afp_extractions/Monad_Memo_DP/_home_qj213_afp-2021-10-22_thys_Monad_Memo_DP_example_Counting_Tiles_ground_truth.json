{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/example/Counting_Tiles.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma lists_of_len_fin1:\n  \"finite (lists A \\<inter> {l. length l = n})\" if \"finite A\"", "lemma disjE1:\n  \"A \\<or> B \\<Longrightarrow> (A \\<Longrightarrow> P) \\<Longrightarrow> (\\<not> A \\<Longrightarrow> B \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma valid_valid':\n  \"valid l \\<Longrightarrow> valid' l\"", "lemmas valid_red = valid.intros(3)[OF valid.intros(1), simplified]", "lemma valid'_valid:\n  \"valid' l \\<Longrightarrow> valid l\"", "lemma valid_eq_valid':\n  \"valid' l = valid l\"", "lemma replicate_iff:\n  \"(\\<forall>i<length l. l ! i = R) \\<longleftrightarrow> (\\<exists> n. l = replicate n R)\"", "lemma replicate_iff2:\n  \"(\\<forall>i<n. l ! i = R) \\<longleftrightarrow> (\\<exists> l'. l = replicate n R @ l')\" if \"n < length l\"", "lemma replicate_Cons_eq:\n  \"replicate n x = y # ys \\<longleftrightarrow> (\\<exists> n'. n = Suc n' \\<and> x = y \\<and> replicate n' x = ys)\"", "lemma valid_split:\n  \"valid l \\<longleftrightarrow>\n    l = [] \\<or>\n    (l!0 = B \\<and> valid (tl l)) \\<or>\n    length l \\<ge> m \\<and> (\\<forall> i < length l. l ! i = R) \\<or>\n    (\\<exists> j < length l. j \\<ge> m \\<and> (\\<forall> i < j. l ! i = R) \\<and> l ! j = B \\<and> valid (drop (j + 1) l))\"", "lemma valid_line_just_B:\n  \"valid (replicate n B)\"", "lemma F_base_0_aux:\n  \"{l. l = [] \\<and> valid l} = {[]}\"", "lemma F_base_0: \"F 0 = 1\"", "lemma F_base_aux: \"{l. length l=n \\<and> valid l} = {replicate n B}\" if \"n > 0\" \"n < m\"", "lemma F_base_1:\n  \"F n = 1\" if \"n > 0\" \"n < m\"", "lemma valid_m_Rs [simp]:\n  \"valid (replicate m R)\"", "lemma F_base_aux_2: \"{l. length l=m \\<and> valid l} = {replicate m R, replicate m B}\"", "lemma F_base_2:\n  \"F m = 2\" if \"0 < m\"", "lemma finite_valid_length:\n  \"finite {l. length l = n \\<and> valid l}\" (is \"finite ?S\")", "lemma valid_line_aux:\n  \"{l. length l = n \\<and> valid l} \\<noteq> {}\" (is \"?S \\<noteq> {}\")", "lemma replicate_unequal_aux:\n  \"replicate x R @ B # l \\<noteq> replicate y R @ B # l'\" (is \"?l \\<noteq> ?r\") if \\<open>x < y\\<close> for l l'", "lemma valid_prepend_B_iff:\n  \"valid (B # xs) \\<longleftrightarrow> valid xs\" if \"m > 0\"", "lemma F_rec: \"F n = F (n-1) + 1 + (\\<Sum>i=m..<n. F (n-i-1))\" if \\<open>n>m\\<close> \"m > 0\"", "lemmas [simp del] = lcount.simps", "lemma lcount_correct:\n  \"lcount n = F n\" if \"m > 0\"", "lemmas [code] = lcount\\<^sub>m.memoized_correct", "theorem\n  \"(LEAST n. F 50 n > 1000000) = 168\""], "translations": [["", "lemma lists_of_len_fin1:\n  \"finite (lists A \\<inter> {l. length l = n})\" if \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lists A \\<inter> {l. length l = n})", "using that"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (lists A \\<inter> {l. length l = n})", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> finite (lists A \\<inter> {l. length l = 0})\n 2. \\<And>n.\n       \\<lbrakk>finite A \\<Longrightarrow>\n                finite (lists A \\<inter> {l. length l = n});\n        finite A\\<rbrakk>\n       \\<Longrightarrow> finite (lists A \\<inter> {l. length l = Suc n})", "case 0"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> finite (lists A \\<inter> {l. length l = 0})\n 2. \\<And>n.\n       \\<lbrakk>finite A \\<Longrightarrow>\n                finite (lists A \\<inter> {l. length l = n});\n        finite A\\<rbrakk>\n       \\<Longrightarrow> finite (lists A \\<inter> {l. length l = Suc n})", "thus ?case"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (lists A \\<inter> {l. length l = 0})", "by auto"], ["proof (state)\nthis:\n  finite (lists A \\<inter> {l. length l = 0})\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite A \\<Longrightarrow>\n                finite (lists A \\<inter> {l. length l = n});\n        finite A\\<rbrakk>\n       \\<Longrightarrow> finite (lists A \\<inter> {l. length l = Suc n})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite A \\<Longrightarrow>\n                finite (lists A \\<inter> {l. length l = n});\n        finite A\\<rbrakk>\n       \\<Longrightarrow> finite (lists A \\<inter> {l. length l = Suc n})", "case (Suc n)"], ["proof (state)\nthis:\n  finite A \\<Longrightarrow> finite (lists A \\<inter> {l. length l = n})\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite A \\<Longrightarrow>\n                finite (lists A \\<inter> {l. length l = n});\n        finite A\\<rbrakk>\n       \\<Longrightarrow> finite (lists A \\<inter> {l. length l = Suc n})", "have \"lists A \\<inter> { l. length l = Suc n } = (\\<lambda>(a,l). a#l) ` (A \\<times> (lists A \\<inter> {l. length l = n}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists A \\<inter> {l. length l = Suc n} =\n    (\\<lambda>(a, l). a # l) `\n    (A \\<times> (lists A \\<inter> {l. length l = n}))", "by (auto simp: length_Suc_conv)"], ["proof (state)\nthis:\n  lists A \\<inter> {l. length l = Suc n} =\n  (\\<lambda>(a, l). a # l) `\n  (A \\<times> (lists A \\<inter> {l. length l = n}))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite A \\<Longrightarrow>\n                finite (lists A \\<inter> {l. length l = n});\n        finite A\\<rbrakk>\n       \\<Longrightarrow> finite (lists A \\<inter> {l. length l = Suc n})", "moreover"], ["proof (state)\nthis:\n  lists A \\<inter> {l. length l = Suc n} =\n  (\\<lambda>(a, l). a # l) `\n  (A \\<times> (lists A \\<inter> {l. length l = n}))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite A \\<Longrightarrow>\n                finite (lists A \\<inter> {l. length l = n});\n        finite A\\<rbrakk>\n       \\<Longrightarrow> finite (lists A \\<inter> {l. length l = Suc n})", "from Suc"], ["proof (chain)\npicking this:\n  finite A \\<Longrightarrow> finite (lists A \\<inter> {l. length l = n})\n  finite A", "have \"finite \\<dots>\""], ["proof (prove)\nusing this:\n  finite A \\<Longrightarrow> finite (lists A \\<inter> {l. length l = n})\n  finite A\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(a, l). a # l) `\n      (A \\<times> (lists A \\<inter> {l. length l = n})))", "by auto"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(a, l). a # l) `\n    (A \\<times> (lists A \\<inter> {l. length l = n})))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>finite A \\<Longrightarrow>\n                finite (lists A \\<inter> {l. length l = n});\n        finite A\\<rbrakk>\n       \\<Longrightarrow> finite (lists A \\<inter> {l. length l = Suc n})", "ultimately"], ["proof (chain)\npicking this:\n  lists A \\<inter> {l. length l = Suc n} =\n  (\\<lambda>(a, l). a # l) `\n  (A \\<times> (lists A \\<inter> {l. length l = n}))\n  finite\n   ((\\<lambda>(a, l). a # l) `\n    (A \\<times> (lists A \\<inter> {l. length l = n})))", "show ?case"], ["proof (prove)\nusing this:\n  lists A \\<inter> {l. length l = Suc n} =\n  (\\<lambda>(a, l). a # l) `\n  (A \\<times> (lists A \\<inter> {l. length l = n}))\n  finite\n   ((\\<lambda>(a, l). a # l) `\n    (A \\<times> (lists A \\<inter> {l. length l = n})))\n\ngoal (1 subgoal):\n 1. finite (lists A \\<inter> {l. length l = Suc n})", "by simp"], ["proof (state)\nthis:\n  finite (lists A \\<inter> {l. length l = Suc n})\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Duplicate from Refine_Misc *)"], ["", "lemma disjE1:\n  \"A \\<or> B \\<Longrightarrow> (A \\<Longrightarrow> P) \\<Longrightarrow> (\\<not> A \\<Longrightarrow> B \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or> B; A \\<Longrightarrow> P;\n     \\<lbrakk>\\<not> A; B\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by metis"], ["", "subsubsection \\<open>Problem Specification\\<close>"], ["", "text \\<open>Colors\\<close>"], ["", "datatype color = R | B"], ["", "text \\<open>Direct natural definition of a valid line\\<close>"], ["", "context\n  fixes m :: nat\nbegin"], ["", "inductive valid where\n  \"valid []\" |\n  \"valid xs \\<Longrightarrow> valid (B # xs)\" |\n  \"valid xs \\<Longrightarrow> n \\<ge> m \\<Longrightarrow> valid (replicate n R @ xs)\""], ["", "text \\<open>Definition of the fill-count function\\<close>"], ["", "definition \"F n = card {l. length l = n \\<and> valid l}\""], ["", "subsubsection \\<open>Combinatorial Identities\\<close>"], ["", "text \\<open>This alternative variant helps us to prove the split lemma below.\\<close>"], ["", "inductive valid' where\n  \"valid' []\" |\n  \"n \\<ge> m \\<Longrightarrow> valid' (replicate n R)\" |\n  \"valid' xs \\<Longrightarrow> valid' (B # xs)\" |\n  \"valid' xs \\<Longrightarrow> n \\<ge> m \\<Longrightarrow> valid' (replicate n R @ B # xs)\""], ["", "lemma valid_valid':\n  \"valid l \\<Longrightarrow> valid' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid l \\<Longrightarrow> local.valid' l", "by (induction rule: valid.induct)\n     (auto 4 4 intro: valid'.intros elim: valid'.cases\n       simp: replicate_add[symmetric] append_assoc[symmetric]\n     )"], ["", "lemmas valid_red = valid.intros(3)[OF valid.intros(1), simplified]"], ["", "lemma valid'_valid:\n  \"valid' l \\<Longrightarrow> valid l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid' l \\<Longrightarrow> local.valid l", "by (induction rule: valid'.induct) (auto intro: valid.intros valid_red)"], ["", "lemma valid_eq_valid':\n  \"valid' l = valid l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid' l = local.valid l", "using valid_valid' valid'_valid"], ["proof (prove)\nusing this:\n  local.valid ?l \\<Longrightarrow> local.valid' ?l\n  local.valid' ?l \\<Longrightarrow> local.valid ?l\n\ngoal (1 subgoal):\n 1. local.valid' l = local.valid l", "by metis"], ["", "text \\<open>Additional Facts on Replicate\\<close>"], ["", "lemma replicate_iff:\n  \"(\\<forall>i<length l. l ! i = R) \\<longleftrightarrow> (\\<exists> n. l = replicate n R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<length l. l ! i = R) = (\\<exists>n. l = replicate n R)", "by auto (metis (full_types) in_set_conv_nth replicate_eqI)"], ["", "lemma replicate_iff2:\n  \"(\\<forall>i<n. l ! i = R) \\<longleftrightarrow> (\\<exists> l'. l = replicate n R @ l')\" if \"n < length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<n. l ! i = R) = (\\<exists>l'. l = replicate n R @ l')", "using that"], ["proof (prove)\nusing this:\n  n < length l\n\ngoal (1 subgoal):\n 1. (\\<forall>i<n. l ! i = R) = (\\<exists>l'. l = replicate n R @ l')", "by (auto simp: list_eq_iff_nth_eq nth_append intro: exI[where x = \"drop n l\"])"], ["", "lemma replicate_Cons_eq:\n  \"replicate n x = y # ys \\<longleftrightarrow> (\\<exists> n'. n = Suc n' \\<and> x = y \\<and> replicate n' x = ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate n x = y # ys) =\n    (\\<exists>n'. n = Suc n' \\<and> x = y \\<and> replicate n' x = ys)", "by (cases n) auto"], ["", "text \\<open>Main Case Analysis on \\<open>@term valid\\<close>\\<close>"], ["", "lemma valid_split:\n  \"valid l \\<longleftrightarrow>\n    l = [] \\<or>\n    (l!0 = B \\<and> valid (tl l)) \\<or>\n    length l \\<ge> m \\<and> (\\<forall> i < length l. l ! i = R) \\<or>\n    (\\<exists> j < length l. j \\<ge> m \\<and> (\\<forall> i < j. l ! i = R) \\<and> l ! j = B \\<and> valid (drop (j + 1) l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid l =\n    (l = [] \\<or>\n     l ! 0 = B \\<and> local.valid (tl l) \\<or>\n     m \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n     (\\<exists>j<length l.\n         m \\<le> j \\<and>\n         (\\<forall>i<j. l ! i = R) \\<and>\n         l ! j = B \\<and> local.valid (drop (j + 1) l)))", "unfolding valid_eq_valid'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid' l =\n    (l = [] \\<or>\n     l ! 0 = B \\<and> local.valid' (tl l) \\<or>\n     m \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n     (\\<exists>j<length l.\n         m \\<le> j \\<and>\n         (\\<forall>i<j. l ! i = R) \\<and>\n         l ! j = B \\<and> local.valid' (drop (j + 1) l)))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. local.valid' l \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> local.valid' (tl l) \\<or>\n    m \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        m \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> local.valid' (drop (j + 1) l))\n 2. l = [] \\<or>\n    l ! 0 = B \\<and> local.valid' (tl l) \\<or>\n    m \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        m \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> local.valid' (drop (j + 1) l)) \\<Longrightarrow>\n    local.valid' l", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid' l \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> local.valid' (tl l) \\<or>\n    m \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        m \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> local.valid' (drop (j + 1) l))", "by (erule valid'.cases) (auto simp: nth_append nth_Cons split: nat.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = [] \\<or>\n    l ! 0 = B \\<and> local.valid' (tl l) \\<or>\n    m \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        m \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> local.valid' (drop (j + 1) l)) \\<Longrightarrow>\n    local.valid' l", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = [] \\<or>\n    l ! 0 = B \\<and> local.valid' (tl l) \\<or>\n    m \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        m \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> local.valid' (drop (j + 1) l)) \\<Longrightarrow>\n    local.valid' l", "apply (auto intro: valid'.intros simp: replicate_iff elim!: disjE1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>l \\<noteq> []; l ! 0 = B; local.valid' (tl l)\\<rbrakk>\n    \\<Longrightarrow> local.valid' l\n 2. \\<And>j.\n       \\<lbrakk>l \\<noteq> []; j < length l; m \\<le> j;\n        \\<forall>i<j. l ! i = R; l ! j = B; local.valid' (drop (Suc j) l);\n        \\<not> local.valid' l; l ! 0 \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. l = replicate n R\n 3. \\<And>j.\n       \\<lbrakk>l \\<noteq> []; j < length l; m \\<le> j;\n        \\<forall>i<j. l ! i = R; l ! j = B; local.valid' (drop (Suc j) l);\n        \\<not> local.valid' l; \\<not> local.valid' (tl l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. l = replicate n R", "apply (fastforce intro: valid'.intros simp: neq_Nil_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>l \\<noteq> []; j < length l; m \\<le> j;\n        \\<forall>i<j. l ! i = R; l ! j = B; local.valid' (drop (Suc j) l);\n        \\<not> local.valid' l; l ! 0 \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. l = replicate n R\n 2. \\<And>j.\n       \\<lbrakk>l \\<noteq> []; j < length l; m \\<le> j;\n        \\<forall>i<j. l ! i = R; l ! j = B; local.valid' (drop (Suc j) l);\n        \\<not> local.valid' l; \\<not> local.valid' (tl l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. l = replicate n R", "apply (subst (asm) replicate_iff2; fastforce intro: valid'.intros simp: neq_Nil_conv nth_append)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Base cases\\<close>"], ["", "lemma valid_line_just_B:\n  \"valid (replicate n B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid (replicate n B)", "by (induction n) (auto intro: valid.intros)"], ["", "lemma F_base_0_aux:\n  \"{l. l = [] \\<and> valid l} = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. l = [] \\<and> local.valid l} = {[]}", "by (auto intro: valid.intros)"], ["", "lemma F_base_0: \"F 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.F 0 = 1", "by (auto simp: F_base_0_aux F_def)"], ["", "lemma F_base_aux: \"{l. length l=n \\<and> valid l} = {replicate n B}\" if \"n > 0\" \"n < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> local.valid l} = {replicate n B}", "using that"], ["proof (prove)\nusing this:\n  0 < n\n  n < m\n\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> local.valid l} = {replicate n B}", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < 0; 0 < m\\<rbrakk>\n    \\<Longrightarrow> {l. length l = 0 \\<and> local.valid l} =\n                      {replicate 0 B}\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < n; n < m\\<rbrakk>\n                \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                                  {replicate n B};\n        0 < Suc n; Suc n < m\\<rbrakk>\n       \\<Longrightarrow> {l. length l = Suc n \\<and> local.valid l} =\n                         {replicate (Suc n) B}", "case 0"], ["proof (state)\nthis:\n  0 < 0\n  0 < m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < 0; 0 < m\\<rbrakk>\n    \\<Longrightarrow> {l. length l = 0 \\<and> local.valid l} =\n                      {replicate 0 B}\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < n; n < m\\<rbrakk>\n                \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                                  {replicate n B};\n        0 < Suc n; Suc n < m\\<rbrakk>\n       \\<Longrightarrow> {l. length l = Suc n \\<and> local.valid l} =\n                         {replicate (Suc n) B}", "then"], ["proof (chain)\npicking this:\n  0 < 0\n  0 < m", "show ?case"], ["proof (prove)\nusing this:\n  0 < 0\n  0 < m\n\ngoal (1 subgoal):\n 1. {l. length l = 0 \\<and> local.valid l} = {replicate 0 B}", "by simp"], ["proof (state)\nthis:\n  {l. length l = 0 \\<and> local.valid l} = {replicate 0 B}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < n; n < m\\<rbrakk>\n                \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                                  {replicate n B};\n        0 < Suc n; Suc n < m\\<rbrakk>\n       \\<Longrightarrow> {l. length l = Suc n \\<and> local.valid l} =\n                         {replicate (Suc n) B}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < n; n < m\\<rbrakk>\n                \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                                  {replicate n B};\n        0 < Suc n; Suc n < m\\<rbrakk>\n       \\<Longrightarrow> {l. length l = Suc n \\<and> local.valid l} =\n                         {replicate (Suc n) B}", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < n; n < m\\<rbrakk>\n  \\<Longrightarrow> {l. length l = n \\<and> local.valid l} = {replicate n B}\n  0 < Suc n\n  Suc n < m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < n; n < m\\<rbrakk>\n                \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                                  {replicate n B};\n        0 < Suc n; Suc n < m\\<rbrakk>\n       \\<Longrightarrow> {l. length l = Suc n \\<and> local.valid l} =\n                         {replicate (Suc n) B}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}", "with Suc.prems"], ["proof (chain)\npicking this:\n  0 < Suc n\n  Suc n < m\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < Suc n\n  Suc n < m\n  n = 0\n\ngoal (1 subgoal):\n 1. {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}", "by (auto intro: valid.intros elim: valid.cases)"], ["proof (state)\nthis:\n  {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}", "with Suc.prems"], ["proof (chain)\npicking this:\n  0 < Suc n\n  Suc n < m\n  n \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < Suc n\n  Suc n < m\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n; x \\<notin> {};\n        length x = Suc n; local.valid x\\<rbrakk>\n       \\<Longrightarrow> x = replicate (Suc n) B\n 2. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> length (replicate (Suc n) B) = Suc n\n 3. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> local.valid (replicate (Suc n) B)", "using Suc.IH"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < n; n < m\\<rbrakk>\n  \\<Longrightarrow> {l. length l = n \\<and> local.valid l} = {replicate n B}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n; x \\<notin> {};\n        length x = Suc n; local.valid x\\<rbrakk>\n       \\<Longrightarrow> x = replicate (Suc n) B\n 2. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> length (replicate (Suc n) B) = Suc n\n 3. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> local.valid (replicate (Suc n) B)", "apply -"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n; x \\<notin> {};\n        length x = Suc n; local.valid x;\n        \\<lbrakk>0 < n; n < m\\<rbrakk>\n        \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                          {replicate n B}\\<rbrakk>\n       \\<Longrightarrow> x = replicate (Suc n) B\n 2. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n;\n        \\<lbrakk>0 < n; n < m\\<rbrakk>\n        \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                          {replicate n B}\\<rbrakk>\n       \\<Longrightarrow> length (replicate (Suc n) B) = Suc n\n 3. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n;\n        \\<lbrakk>0 < n; n < m\\<rbrakk>\n        \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                          {replicate n B}\\<rbrakk>\n       \\<Longrightarrow> local.valid (replicate (Suc n) B)", "apply (erule valid.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n; x \\<notin> {};\n        length x = Suc n;\n        \\<lbrakk>0 < n; n < m\\<rbrakk>\n        \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                          {replicate n B};\n        x = []\\<rbrakk>\n       \\<Longrightarrow> x = replicate (Suc n) B\n 2. \\<And>x xs.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n; x \\<notin> {};\n        length x = Suc n;\n        \\<lbrakk>0 < n; n < m\\<rbrakk>\n        \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                          {replicate n B};\n        x = B # xs; local.valid xs\\<rbrakk>\n       \\<Longrightarrow> x = replicate (Suc n) B\n 3. \\<And>x xs n.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n; x \\<notin> {};\n        length x = Suc n;\n        \\<lbrakk>0 < n; n < m\\<rbrakk>\n        \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                          {replicate n B};\n        x = replicate n R @ xs; local.valid xs; m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> x = replicate (Suc n) B\n 4. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n;\n        \\<lbrakk>0 < n; n < m\\<rbrakk>\n        \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                          {replicate n B}\\<rbrakk>\n       \\<Longrightarrow> length (replicate (Suc n) B) = Suc n\n 5. \\<And>x.\n       \\<lbrakk>0 < Suc n; Suc n < m; 0 < n;\n        \\<lbrakk>0 < n; n < m\\<rbrakk>\n        \\<Longrightarrow> {l. length l = n \\<and> local.valid l} =\n                          {replicate n B}\\<rbrakk>\n       \\<Longrightarrow> local.valid (replicate (Suc n) B)", "apply (auto intro: valid.intros elim: valid.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {l. length l = Suc n \\<and> local.valid l} = {replicate (Suc n) B}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma F_base_1:\n  \"F n = 1\" if \"n > 0\" \"n < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.F n = 1", "using that"], ["proof (prove)\nusing this:\n  0 < n\n  n < m\n\ngoal (1 subgoal):\n 1. local.F n = 1", "unfolding F_def"], ["proof (prove)\nusing this:\n  0 < n\n  n < m\n\ngoal (1 subgoal):\n 1. card {l. length l = n \\<and> local.valid l} = 1", "by (simp add: F_base_aux)"], ["", "lemma valid_m_Rs [simp]:\n  \"valid (replicate m R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid (replicate m R)", "using valid_red[of m, simplified]"], ["proof (prove)\nusing this:\n  local.valid (replicate m R)\n\ngoal (1 subgoal):\n 1. local.valid (replicate m R)", "by simp"], ["", "lemma F_base_aux_2: \"{l. length l=m \\<and> valid l} = {replicate m R, replicate m B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = m \\<and> local.valid l} = {replicate m R, replicate m B}", "apply (auto simp: valid_line_just_B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> replicate (length x) R;\n        Counting_Tiles.valid (length x) x; m = length x\\<rbrakk>\n       \\<Longrightarrow> x = replicate (length x) B", "apply (erule Counting_Tiles.valid.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> replicate (length x) R; m = length x;\n        x = []\\<rbrakk>\n       \\<Longrightarrow> x = replicate (length x) B\n 2. \\<And>x xs.\n       \\<lbrakk>x \\<noteq> replicate (length x) R; m = length x; x = B # xs;\n        Counting_Tiles.valid (length x) xs\\<rbrakk>\n       \\<Longrightarrow> x = replicate (length x) B\n 3. \\<And>x xs n.\n       \\<lbrakk>x \\<noteq> replicate (length x) R; m = length x;\n        x = replicate n R @ xs; Counting_Tiles.valid (length x) xs;\n        length x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> x = replicate (length x) B", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>m = Suc (length xs);\n        Counting_Tiles.valid (Suc (length xs)) xs\\<rbrakk>\n       \\<Longrightarrow> xs = replicate (length xs) B", "subgoal for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m = Suc (length xs);\n     Counting_Tiles.valid (Suc (length xs)) xs\\<rbrakk>\n    \\<Longrightarrow> xs = replicate (length xs) B", "using F_base_aux[of \"length xs\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length xs; length xs < m\\<rbrakk>\n  \\<Longrightarrow> {l. length l = length xs \\<and> local.valid l} =\n                    {replicate (length xs) B}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m = Suc (length xs);\n     Counting_Tiles.valid (Suc (length xs)) xs\\<rbrakk>\n    \\<Longrightarrow> xs = replicate (length xs) B", "by (cases \"xs = []\") auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma F_base_2:\n  \"F m = 2\" if \"0 < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.F m = 2", "using that"], ["proof (prove)\nusing this:\n  0 < m\n\ngoal (1 subgoal):\n 1. local.F m = 2", "unfolding F_def"], ["proof (prove)\nusing this:\n  0 < m\n\ngoal (1 subgoal):\n 1. card {l. length l = m \\<and> local.valid l} = 2", "by (simp add: F_base_aux_2)"], ["", "text \\<open>The recursion case\\<close>"], ["", "lemma finite_valid_length:\n  \"finite {l. length l = n \\<and> valid l}\" (is \"finite ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> local.valid l}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> local.valid l}", "have \"?S \\<subseteq> lists {R, B} \\<inter> {l. length l = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> local.valid l}\n    \\<subseteq> lists {R, B} \\<inter> {l. length l = n}", "by (auto intro: color.exhaust)"], ["proof (state)\nthis:\n  {l. length l = n \\<and> local.valid l}\n  \\<subseteq> lists {R, B} \\<inter> {l. length l = n}\n\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> local.valid l}", "moreover"], ["proof (state)\nthis:\n  {l. length l = n \\<and> local.valid l}\n  \\<subseteq> lists {R, B} \\<inter> {l. length l = n}\n\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> local.valid l}", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lists {R, B} \\<inter> {l. length l = n})", "by (auto intro: lists_of_len_fin1)"], ["proof (state)\nthis:\n  finite (lists {R, B} \\<inter> {l. length l = n})\n\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> local.valid l}", "ultimately"], ["proof (chain)\npicking this:\n  {l. length l = n \\<and> local.valid l}\n  \\<subseteq> lists {R, B} \\<inter> {l. length l = n}\n  finite (lists {R, B} \\<inter> {l. length l = n})", "show ?thesis"], ["proof (prove)\nusing this:\n  {l. length l = n \\<and> local.valid l}\n  \\<subseteq> lists {R, B} \\<inter> {l. length l = n}\n  finite (lists {R, B} \\<inter> {l. length l = n})\n\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> local.valid l}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {l. length l = n \\<and> local.valid l}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_line_aux:\n  \"{l. length l = n \\<and> valid l} \\<noteq> {}\" (is \"?S \\<noteq> {}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> local.valid l} \\<noteq> {}", "using valid_line_just_B[of n]"], ["proof (prove)\nusing this:\n  local.valid (replicate n B)\n\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> local.valid l} \\<noteq> {}", "by force"], ["", "lemma replicate_unequal_aux:\n  \"replicate x R @ B # l \\<noteq> replicate y R @ B # l'\" (is \"?l \\<noteq> ?r\") if \\<open>x < y\\<close> for l l'"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate x R @ B # l \\<noteq> replicate y R @ B # l'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. replicate x R @ B # l \\<noteq> replicate y R @ B # l'", "have \"?l ! x = B\" \"?r ! x = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate x R @ B # l) ! x = B &&& (replicate y R @ B # l') ! x = R", "using that"], ["proof (prove)\nusing this:\n  x < y\n\ngoal (1 subgoal):\n 1. (replicate x R @ B # l) ! x = B &&& (replicate y R @ B # l') ! x = R", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  (replicate x R @ B # l) ! x = B\n  (replicate y R @ B # l') ! x = R\n\ngoal (1 subgoal):\n 1. replicate x R @ B # l \\<noteq> replicate y R @ B # l'", "then"], ["proof (chain)\npicking this:\n  (replicate x R @ B # l) ! x = B\n  (replicate y R @ B # l') ! x = R", "show ?thesis"], ["proof (prove)\nusing this:\n  (replicate x R @ B # l) ! x = B\n  (replicate y R @ B # l') ! x = R\n\ngoal (1 subgoal):\n 1. replicate x R @ B # l \\<noteq> replicate y R @ B # l'", "by auto"], ["proof (state)\nthis:\n  replicate x R @ B # l \\<noteq> replicate y R @ B # l'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_prepend_B_iff:\n  \"valid (B # xs) \\<longleftrightarrow> valid xs\" if \"m > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.valid (B # xs) = local.valid xs", "using that"], ["proof (prove)\nusing this:\n  0 < m\n\ngoal (1 subgoal):\n 1. local.valid (B # xs) = local.valid xs", "by (auto 4 3 intro: valid.intros elim: valid.cases simp: Cons_replicate_eq Cons_eq_append_conv)"], ["", "lemma F_rec: \"F n = F (n-1) + 1 + (\\<Sum>i=m..<n. F (n-i-1))\" if \\<open>n>m\\<close> \"m > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "have \"{l. length l = n \\<and> valid l}\n          = {l. length l = n \\<and> valid (tl l) \\<and> l!0=B}\n          \\<union> {l. length l = n \\<and>\n              (\\<exists> i. i < n \\<and> i \\<ge> m \\<and> (\\<forall> k < i. l!k = R) \\<and> l!i = B \\<and> valid (drop (i + 1) l))}\n          \\<union> {l. length l = n \\<and> (\\<forall>i<n. l!i=R)}\n          \" (is \"?A = ?B \\<union> ?D \\<union> ?C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> local.valid l} =\n    {l. length l = n \\<and> local.valid (tl l) \\<and> l ! 0 = B} \\<union>\n    {l. length l = n \\<and>\n        (\\<exists>i<n.\n            m \\<le> i \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> local.valid (drop (i + 1) l))} \\<union>\n    {l. length l = n \\<and> (\\<forall>i<n. l ! i = R)}", "using \\<open>n > m\\<close>"], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> local.valid l} =\n    {l. length l = n \\<and> local.valid (tl l) \\<and> l ! 0 = B} \\<union>\n    {l. length l = n \\<and>\n        (\\<exists>i<n.\n            m \\<le> i \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> local.valid (drop (i + 1) l))} \\<union>\n    {l. length l = n \\<and> (\\<forall>i<n. l ! i = R)}", "by (subst valid_split) auto"], ["proof (state)\nthis:\n  {l. length l = n \\<and> local.valid l} =\n  {l. length l = n \\<and> local.valid (tl l) \\<and> l ! 0 = B} \\<union>\n  {l. length l = n \\<and>\n      (\\<exists>i<n.\n          m \\<le> i \\<and>\n          (\\<forall>k<i. l ! k = R) \\<and>\n          l ! i = B \\<and> local.valid (drop (i + 1) l))} \\<union>\n  {l. length l = n \\<and> (\\<forall>i<n. l ! i = R)}\n\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "let ?B1 = \"((#) B) ` {l. length l = n - Suc 0 \\<and> valid l}\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "from \\<open>n > m\\<close>"], ["proof (chain)\npicking this:\n  m < n", "have \"?B = ?B1\""], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> local.valid (tl l) \\<and> l ! 0 = B} =\n    (#) B ` {l. length l = n - Suc 0 \\<and> local.valid l}", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>m < length x; n = length x; local.valid (tl x);\n        x ! 0 = B\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (#) B `\n                                 {l. length l = length x - Suc 0 \\<and>\n                                     local.valid l}\n 2. \\<And>x xa.\n       \\<lbrakk>m < n; length xa = n - Suc 0; local.valid xa\\<rbrakk>\n       \\<Longrightarrow> length (B # xa) = n\n 3. \\<And>x xa.\n       \\<lbrakk>m < n; length xa = n - Suc 0; local.valid xa\\<rbrakk>\n       \\<Longrightarrow> local.valid (tl (B # xa))\n 4. \\<And>x xa.\n       \\<lbrakk>m < n; length xa = n - Suc 0; local.valid xa\\<rbrakk>\n       \\<Longrightarrow> (B # xa) ! 0 = B", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < length l; n = length l; local.valid (tl l);\n     l ! 0 = B\\<rbrakk>\n    \\<Longrightarrow> l \\<in> (#) B `\n                              {la.\n                               length la = length l - Suc 0 \\<and>\n                               local.valid la}", "by (cases l) (auto simp: valid_prepend_B_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>m < n; length xa = n - Suc 0; local.valid xa\\<rbrakk>\n       \\<Longrightarrow> length (B # xa) = n\n 2. \\<And>x xa.\n       \\<lbrakk>m < n; length xa = n - Suc 0; local.valid xa\\<rbrakk>\n       \\<Longrightarrow> local.valid (tl (B # xa))\n 3. \\<And>x xa.\n       \\<lbrakk>m < n; length xa = n - Suc 0; local.valid xa\\<rbrakk>\n       \\<Longrightarrow> (B # xa) ! 0 = B", "by auto"], ["proof (state)\nthis:\n  {l. length l = n \\<and> local.valid (tl l) \\<and> l ! 0 = B} =\n  (#) B ` {l. length l = n - Suc 0 \\<and> local.valid l}\n\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "have 1: \"card ?B1 = F (n-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l}) =\n    local.F (n - 1)", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l}) =\n    card {l. length l = n - 1 \\<and> local.valid l}", "by (auto intro: card_image)"], ["proof (state)\nthis:\n  card ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l}) =\n  local.F (n - 1)\n\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "have \"?C = {replicate n R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> (\\<forall>i<n. l ! i = R)} = {replicate n R}", "by (auto simp: nth_equalityI)"], ["proof (state)\nthis:\n  {l. length l = n \\<and> (\\<forall>i<n. l ! i = R)} = {replicate n R}\n\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "have 2: \"card {replicate n R} = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {replicate n R} = 1", "by auto"], ["proof (state)\nthis:\n  card {replicate n R} = 1\n\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "let ?D1=\"(\\<Union> i \\<in> {m..<n}. (\\<lambda> l. replicate i R @ B # l)` {l. length l = n - i - 1 \\<and> valid l})\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "have \"?D =\n        (\\<Union>i \\<in> {m..<n}. {l. length l = n \\<and> (\\<forall> k < i. l!k = R) \\<and> l!i = B \\<and> valid (drop (i + 1) l)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and>\n        (\\<exists>i<n.\n            m \\<le> i \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> local.valid (drop (i + 1) l))} =\n    (\\<Union>i\\<in>{m..<n}.\n        {l. length l = n \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> local.valid (drop (i + 1) l)})", "by auto"], ["proof (state)\nthis:\n  {l. length l = n \\<and>\n      (\\<exists>i<n.\n          m \\<le> i \\<and>\n          (\\<forall>k<i. l ! k = R) \\<and>\n          l ! i = B \\<and> local.valid (drop (i + 1) l))} =\n  (\\<Union>i\\<in>{m..<n}.\n      {l. length l = n \\<and>\n          (\\<forall>k<i. l ! k = R) \\<and>\n          l ! i = B \\<and> local.valid (drop (i + 1) l)})\n\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "have \"{l. length l = n \\<and> (\\<forall> k < i. l!k = R) \\<and> l!i = B \\<and> valid (drop (i + 1) l)}\n              = (\\<lambda> l. replicate i R @ B # l)` {l. length l = n - i - 1 \\<and> valid l}\"\n    if \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and>\n        (\\<forall>k<i. l ! k = R) \\<and>\n        l ! i = B \\<and> local.valid (drop (i + 1) l)} =\n    (\\<lambda>l. replicate i R @ B # l) `\n    {l. length l = n - i - 1 \\<and> local.valid l}", "apply safe"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n = length x; \\<forall>k<i. x ! k = R; x ! i = B;\n        local.valid (drop (i + 1) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>l. replicate i R @ B # l) `\n                                 {l. length l = length x - i - 1 \\<and>\n                                     local.valid l}\n 2. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; local.valid l\\<rbrakk>\n       \\<Longrightarrow> length (replicate i R @ B # l) = n\n 3. \\<And>x l k.\n       \\<lbrakk>length l = n - i - 1; local.valid l; k < i\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! k = R\n 4. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; local.valid l\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! i = B\n 5. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; local.valid l\\<rbrakk>\n       \\<Longrightarrow> local.valid (drop (i + 1) (replicate i R @ B # l))", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     local.valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> l \\<in> (\\<lambda>l. replicate i R @ B # l) `\n                              {la.\n                               length la = length l - i - 1 \\<and>\n                               local.valid la}", "apply (rule image_eqI[where x = \"drop (i + 1) l\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     local.valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> l = replicate i R @ B # drop (i + 1) l\n 2. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     local.valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> drop (i + 1) l\n                      \\<in> {la.\n                             length la = length l - i - 1 \\<and>\n                             local.valid la}", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     local.valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> length l = length (replicate i R @ B # drop (i + 1) l)\n 2. \\<And>ia.\n       \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n        local.valid (drop (i + 1) l); ia < length l\\<rbrakk>\n       \\<Longrightarrow> l ! ia = (replicate i R @ B # drop (i + 1) l) ! ia\n 3. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     local.valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> drop (i + 1) l\n                      \\<in> {la.\n                             length la = length l - i - 1 \\<and>\n                             local.valid la}", "using that"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     local.valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> length l = length (replicate i R @ B # drop (i + 1) l)\n 2. \\<And>ia.\n       \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n        local.valid (drop (i + 1) l); ia < length l\\<rbrakk>\n       \\<Longrightarrow> l ! ia = (replicate i R @ B # drop (i + 1) l) ! ia\n 3. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     local.valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> drop (i + 1) l\n                      \\<in> {la.\n                             length la = length l - i - 1 \\<and>\n                             local.valid la}", "apply (simp_all split: nat.split add: nth_Cons nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n        local.valid (drop (Suc i) l); ia < length l; i < length l\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x2.\n                            ia - i = Suc x2 \\<longrightarrow>\n                            \\<not> ia < i \\<longrightarrow>\n                            l ! ia = l ! Suc (i + x2)", "using add_diff_inverse_nat"], ["proof (prove)\nusing this:\n  \\<not> ?m < ?n \\<Longrightarrow> ?n + (?m - ?n) = ?m\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n        local.valid (drop (Suc i) l); ia < length l; i < length l\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x2.\n                            ia - i = Suc x2 \\<longrightarrow>\n                            \\<not> ia < i \\<longrightarrow>\n                            l ! ia = l ! Suc (i + x2)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; local.valid l\\<rbrakk>\n       \\<Longrightarrow> length (replicate i R @ B # l) = n\n 2. \\<And>x l k.\n       \\<lbrakk>length l = n - i - 1; local.valid l; k < i\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! k = R\n 3. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; local.valid l\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! i = B\n 4. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; local.valid l\\<rbrakk>\n       \\<Longrightarrow> local.valid (drop (i + 1) (replicate i R @ B # l))", "using that"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (4 subgoals):\n 1. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; local.valid l\\<rbrakk>\n       \\<Longrightarrow> length (replicate i R @ B # l) = n\n 2. \\<And>x l k.\n       \\<lbrakk>length l = n - i - 1; local.valid l; k < i\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! k = R\n 3. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; local.valid l\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! i = B\n 4. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; local.valid l\\<rbrakk>\n       \\<Longrightarrow> local.valid (drop (i + 1) (replicate i R @ B # l))", "by (simp add: nth_append; fail)+"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow>\n  {l. length l = n \\<and>\n      (\\<forall>k<?i. l ! k = R) \\<and>\n      l ! ?i = B \\<and> local.valid (drop (?i + 1) l)} =\n  (\\<lambda>l. replicate ?i R @ B # l) `\n  {l. length l = n - ?i - 1 \\<and> local.valid l}\n\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "then"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow>\n  {l. length l = n \\<and>\n      (\\<forall>k<?i. l ! k = R) \\<and>\n      l ! ?i = B \\<and> local.valid (drop (?i + 1) l)} =\n  (\\<lambda>l. replicate ?i R @ B # l) `\n  {l. length l = n - ?i - 1 \\<and> local.valid l}", "have D_eq: \"?D = ?D1\""], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow>\n  {l. length l = n \\<and>\n      (\\<forall>k<?i. l ! k = R) \\<and>\n      l ! ?i = B \\<and> local.valid (drop (?i + 1) l)} =\n  (\\<lambda>l. replicate ?i R @ B # l) `\n  {l. length l = n - ?i - 1 \\<and> local.valid l}\n\ngoal (1 subgoal):\n 1. {l. length l = n \\<and>\n        (\\<exists>i<n.\n            m \\<le> i \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> local.valid (drop (i + 1) l))} =\n    (\\<Union>i\\<in>{m..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> local.valid l})", "unfolding \\<open>?D = _\\<close>"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow>\n  {l. length l = n \\<and>\n      (\\<forall>k<?i. l ! k = R) \\<and>\n      l ! ?i = B \\<and> local.valid (drop (?i + 1) l)} =\n  (\\<lambda>l. replicate ?i R @ B # l) `\n  {l. length l = n - ?i - 1 \\<and> local.valid l}\n\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>{m..<n}.\n        {l. length l = n \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> local.valid (drop (i + 1) l)}) =\n    (\\<Union>i\\<in>{m..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> local.valid l})", "by auto"], ["proof (state)\nthis:\n  {l. length l = n \\<and>\n      (\\<exists>i<n.\n          m \\<le> i \\<and>\n          (\\<forall>k<i. l ! k = R) \\<and>\n          l ! i = B \\<and> local.valid (drop (i + 1) l))} =\n  (\\<Union>i\\<in>{m..<n}.\n      (\\<lambda>l. replicate i R @ B # l) `\n      {l. length l = n - i - 1 \\<and> local.valid l})\n\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "have inj: \"inj_on (\\<lambda>l. replicate x R @ B # l) {l. length l = n - Suc x \\<and> valid l}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>l. replicate x R @ B # l)\n     {l. length l = n - Suc x \\<and> local.valid l}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>{l. length l = n - Suc x \\<and> local.valid l}.\n       \\<forall>y\\<in>{l. length l = n - Suc x \\<and> local.valid l}.\n          replicate x R @ B # xa = replicate x R @ B # y \\<longrightarrow>\n          xa = y", "by auto"], ["proof (state)\nthis:\n  inj_on (\\<lambda>l. replicate ?x R @ B # l)\n   {l. length l = n - Suc ?x \\<and> local.valid l}\n\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "have *:\n    \"(\\<lambda>l. replicate x R @ B # l) ` {l. length l = n - Suc x \\<and> valid l} \\<inter>\n         (\\<lambda>l. replicate y R @ B # l) ` {l. length l = n - Suc y \\<and> valid l} = {}\"\n    if \"m \\<le> x\" \"x < y\" \"y < n\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l. replicate x R @ B # l) `\n    {l. length l = n - Suc x \\<and> local.valid l} \\<inter>\n    (\\<lambda>l. replicate y R @ B # l) `\n    {l. length l = n - Suc y \\<and> local.valid l} =\n    {}", "using that replicate_unequal_aux[OF \\<open>x < y\\<close>]"], ["proof (prove)\nusing this:\n  m \\<le> x\n  x < y\n  y < n\n  replicate x R @ B # ?l \\<noteq> replicate y R @ B # ?l'\n\ngoal (1 subgoal):\n 1. (\\<lambda>l. replicate x R @ B # l) `\n    {l. length l = n - Suc x \\<and> local.valid l} \\<inter>\n    (\\<lambda>l. replicate y R @ B # l) `\n    {l. length l = n - Suc y \\<and> local.valid l} =\n    {}", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>m \\<le> ?x; ?x < ?y; ?y < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>l. replicate ?x R @ B # l) `\n                    {l. length l = n - Suc ?x \\<and> local.valid l} \\<inter>\n                    (\\<lambda>l. replicate ?y R @ B # l) `\n                    {l. length l = n - Suc ?y \\<and> local.valid l} =\n                    {}\n\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "have 3: \"card ?D1 = (\\<Sum>i=m..<n. F (n-i-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l}) =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "proof (subst card_Union_disjoint, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. pairwise disjnt\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}) `\n      {m..<n})\n 2. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> local.valid l}) `\n               {m..<n} \\<Longrightarrow>\n       finite A\n 3. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}) `\n      {m..<n}) =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. pairwise disjnt\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}) `\n      {m..<n})\n 2. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> local.valid l}) `\n               {m..<n} \\<Longrightarrow>\n       finite A\n 3. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}) `\n      {m..<n}) =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise disjnt\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}) `\n      {m..<n})", "unfolding pairwise_def disjnt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>(\\<lambda>i.\n                       (\\<lambda>l. replicate i R @ B # l) `\n                       {l. length l = n - i - 1 \\<and> local.valid l}) `\n                   {m..<n}.\n       \\<forall>y\\<in>(\\<lambda>i.\n                          (\\<lambda>l. replicate i R @ B # l) `\n                          {l. length l = n - i - 1 \\<and> local.valid l}) `\n                      {m..<n}.\n          x \\<noteq> y \\<longrightarrow> x \\<inter> y = {}", "proof (clarsimp, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n                {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n                (\\<lambda>x. replicate y R @ B # x) `\n                {l. length l = n - Suc y \\<and> local.valid l};\n        m \\<le> x; x < n; m \\<le> y; y < n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                         {l. length l = n - Suc x \\<and>\n                             local.valid l} \\<inter>\n                         (\\<lambda>x. replicate y R @ B # x) `\n                         {l. length l = n - Suc y \\<and> local.valid l} =\n                         {}", "case prems: (1 x y)"], ["proof (state)\nthis:\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> local.valid l}\n  m \\<le> x\n  x < n\n  m \\<le> y\n  y < n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n                {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n                (\\<lambda>x. replicate y R @ B # x) `\n                {l. length l = n - Suc y \\<and> local.valid l};\n        m \\<le> x; x < n; m \\<le> y; y < n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                         {l. length l = n - Suc x \\<and>\n                             local.valid l} \\<inter>\n                         (\\<lambda>x. replicate y R @ B # x) `\n                         {l. length l = n - Suc y \\<and> local.valid l} =\n                         {}", "from prems"], ["proof (chain)\npicking this:\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> local.valid l}\n  m \\<le> x\n  x < n\n  m \\<le> y\n  y < n", "show ?case"], ["proof (prove)\nusing this:\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> local.valid l}\n  m \\<le> x\n  x < n\n  m \\<le> y\n  y < n\n\ngoal (1 subgoal):\n 1. (\\<lambda>xa. replicate x R @ B # xa) `\n    {l. length l = n - Suc x \\<and> local.valid l} \\<inter>\n    (\\<lambda>x. replicate y R @ B # x) `\n    {l. length l = n - Suc y \\<and> local.valid l} =\n    {}", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> local.valid l};\n     m \\<le> x; x < n; m \\<le> y; y < n\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and>\n                          local.valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> local.valid l} =\n                      {}", "apply (rule linorder_cases[of x y])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> local.valid l};\n     m \\<le> x; x < n; m \\<le> y; y < n; x < y\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and>\n                          local.valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> local.valid l} =\n                      {}\n 2. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> local.valid l};\n     m \\<le> x; x < n; m \\<le> y; y < n; x = y\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and>\n                          local.valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> local.valid l} =\n                      {}\n 3. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> local.valid l};\n     m \\<le> x; x < n; m \\<le> y; y < n; y < x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and>\n                          local.valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> local.valid l} =\n                      {}", "apply (rule *; assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> local.valid l};\n     m \\<le> x; x < n; m \\<le> y; y < n; x = y\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and>\n                          local.valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> local.valid l} =\n                      {}\n 2. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> local.valid l};\n     m \\<le> x; x < n; m \\<le> y; y < n; y < x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and>\n                          local.valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> local.valid l} =\n                      {}", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> local.valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> local.valid l};\n     m \\<le> x; x < n; m \\<le> y; y < n; y < x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and>\n                          local.valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> local.valid l} =\n                      {}", "apply (subst Int_commute; rule *; assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> local.valid l} \\<inter>\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> local.valid l} =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pairwise disjnt\n   ((\\<lambda>i.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> local.valid l}) `\n    {m..<n})\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> local.valid l}) `\n               {m..<n} \\<Longrightarrow>\n       finite A\n 2. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}) `\n      {m..<n}) =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> local.valid l}) `\n               {m..<n} \\<Longrightarrow>\n       finite A\n 2. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}) `\n      {m..<n}) =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> local.valid l}) `\n               {m..<n} \\<Longrightarrow>\n       finite A\n 2. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}) `\n      {m..<n}) =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}) `\n      {m..<n}) =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "proof (subst sum.reindex, unfold inj_on_def, clarsimp, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n                {l. length l = n - Suc x \\<and> local.valid l} =\n                (\\<lambda>x. replicate y R @ B # x) `\n                {l. length l = n - Suc y \\<and> local.valid l};\n        m \\<le> x; x < n; m \\<le> y; y < n\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> local.valid l}))\n     {m..<n} =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "case prems: (1 x y)"], ["proof (state)\nthis:\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> local.valid l} =\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> local.valid l}\n  m \\<le> x\n  x < n\n  m \\<le> y\n  y < n\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n                {l. length l = n - Suc x \\<and> local.valid l} =\n                (\\<lambda>x. replicate y R @ B # x) `\n                {l. length l = n - Suc y \\<and> local.valid l};\n        m \\<le> x; x < n; m \\<le> y; y < n\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> local.valid l}))\n     {m..<n} =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "with *[of y x] *[of x y] valid_line_aux[of \"n - Suc x\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>m \\<le> y; y < x; x < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>l. replicate y R @ B # l) `\n                    {l. length l = n - Suc y \\<and> local.valid l} \\<inter>\n                    (\\<lambda>l. replicate x R @ B # l) `\n                    {l. length l = n - Suc x \\<and> local.valid l} =\n                    {}\n  \\<lbrakk>m \\<le> x; x < y; y < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>l. replicate x R @ B # l) `\n                    {l. length l = n - Suc x \\<and> local.valid l} \\<inter>\n                    (\\<lambda>l. replicate y R @ B # l) `\n                    {l. length l = n - Suc y \\<and> local.valid l} =\n                    {}\n  {l. length l = n - Suc x \\<and> local.valid l} \\<noteq> {}\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> local.valid l} =\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> local.valid l}\n  m \\<le> x\n  x < n\n  m \\<le> y\n  y < n", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>m \\<le> y; y < x; x < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>l. replicate y R @ B # l) `\n                    {l. length l = n - Suc y \\<and> local.valid l} \\<inter>\n                    (\\<lambda>l. replicate x R @ B # l) `\n                    {l. length l = n - Suc x \\<and> local.valid l} =\n                    {}\n  \\<lbrakk>m \\<le> x; x < y; y < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>l. replicate x R @ B # l) `\n                    {l. length l = n - Suc x \\<and> local.valid l} \\<inter>\n                    (\\<lambda>l. replicate y R @ B # l) `\n                    {l. length l = n - Suc y \\<and> local.valid l} =\n                    {}\n  {l. length l = n - Suc x \\<and> local.valid l} \\<noteq> {}\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> local.valid l} =\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> local.valid l}\n  m \\<le> x\n  x < n\n  m \\<le> y\n  y < n\n\ngoal (1 subgoal):\n 1. x = y", "by - (rule linorder_cases[of x y], auto)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> local.valid l}))\n     {m..<n} =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> local.valid l}))\n     {m..<n} =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> local.valid l}))\n     {m..<n} =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> local.valid l}))\n     {m..<n} =\n    (\\<Sum>i = m..<n. local.F (n - i - 1))", "by (simp add: F_def card_image[OF inj])"], ["proof (state)\nthis:\n  sum (card \\<circ>\n       (\\<lambda>i.\n           (\\<lambda>l. replicate i R @ B # l) `\n           {l. length l = n - i - 1 \\<and> local.valid l}))\n   {m..<n} =\n  (\\<Sum>i = m..<n. local.F (n - i - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum card\n   ((\\<lambda>i.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> local.valid l}) `\n    {m..<n}) =\n  (\\<Sum>i = m..<n. local.F (n - i - 1))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> local.valid l}) `\n               {m..<n} \\<Longrightarrow>\n       finite A", "qed (auto intro: finite_subset[OF _ finite_valid_length])"], ["proof (state)\nthis:\n  card\n   (\\<Union>i\\<in>{m..<n}.\n       (\\<lambda>l. replicate i R @ B # l) `\n       {l. length l = n - i - 1 \\<and> local.valid l}) =\n  (\\<Sum>i = m..<n. local.F (n - i - 1))\n\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "apply (subst F_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {l. length l = n \\<and> local.valid l} =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "unfolding \\<open>?A = _\\<close> \\<open>?B = _\\<close> \\<open>?C = _\\<close> D_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n      (\\<Union>i\\<in>{m..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}) \\<union>\n      {replicate n R}) =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "apply (subst card_Un_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite\n     ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n      (\\<Union>i\\<in>{m..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}))\n 2. finite {replicate n R}\n 3. ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l})) \\<inter>\n    {replicate n R} =\n    {}\n 4. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n      (\\<Union>i\\<in>{m..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l})) +\n    card {replicate n R} =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "(* Finiteness *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite\n     ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n      (\\<Union>i\\<in>{m..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l}))\n 2. finite {replicate n R}\n 3. ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l})) \\<inter>\n    {replicate n R} =\n    {}\n 4. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n      (\\<Union>i\\<in>{m..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l})) +\n    card {replicate n R} =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "apply (blast intro: finite_subset[OF _ finite_valid_length])+"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l})) \\<inter>\n    {replicate n R} =\n    {}\n 2. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n      (\\<Union>i\\<in>{m..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l})) +\n    card {replicate n R} =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "(* Disjointness *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l})) \\<inter>\n    {replicate n R} =\n    {}\n 2. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n      (\\<Union>i\\<in>{m..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l})) +\n    card {replicate n R} =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l})) \\<inter>\n    {replicate n R} =\n    {}", "using Cons_replicate_eq[of B _ n R] replicate_unequal_aux"], ["proof (prove)\nusing this:\n  (B # ?xs = replicate n R) =\n  (B = R \\<and> 0 < n \\<and> ?xs = replicate (n - 1) B)\n  ?x < ?y \\<Longrightarrow>\n  replicate ?x R @ B # ?l \\<noteq> replicate ?y R @ B # ?l'\n\ngoal (1 subgoal):\n 1. ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l})) \\<inter>\n    {replicate n R} =\n    {}", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<union>\n      (\\<Union>i\\<in>{m..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> local.valid l})) +\n    card {replicate n R} =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "apply (subst card_Un_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l})\n 2. finite\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l})\n 3. (#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<inter>\n    (\\<Union>i\\<in>{m..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> local.valid l}) =\n    {}\n 4. card ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l}) +\n    card\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l}) +\n    card {replicate n R} =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "(* Finiteness *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l})\n 2. finite\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l})\n 3. (#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<inter>\n    (\\<Union>i\\<in>{m..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> local.valid l}) =\n    {}\n 4. card ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l}) +\n    card\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l}) +\n    card {replicate n R} =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "apply (blast intro: finite_subset[OF _ finite_valid_length])+"], ["proof (prove)\ngoal (2 subgoals):\n 1. (#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<inter>\n    (\\<Union>i\\<in>{m..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> local.valid l}) =\n    {}\n 2. card ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l}) +\n    card\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l}) +\n    card {replicate n R} =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "(* Disjointness & final rewriting *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<inter>\n    (\\<Union>i\\<in>{m..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> local.valid l}) =\n    {}\n 2. card ((#) B ` {l. length l = n - Suc 0 \\<and> local.valid l}) +\n    card\n     (\\<Union>i\\<in>{m..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> local.valid l}) +\n    card {replicate n R} =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "unfolding 1 2 3"], ["proof (prove)\ngoal (2 subgoals):\n 1. (#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<inter>\n    (\\<Union>i\\<in>{m..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> local.valid l}) =\n    {}\n 2. local.F (n - 1) + (\\<Sum>i = m..<n. local.F (n - i - 1)) + 1 =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "using \\<open>m > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < m\n\ngoal (2 subgoals):\n 1. (#) B ` {l. length l = n - Suc 0 \\<and> local.valid l} \\<inter>\n    (\\<Union>i\\<in>{m..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> local.valid l}) =\n    {}\n 2. local.F (n - 1) + (\\<Sum>i = m..<n. local.F (n - i - 1)) + 1 =\n    local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))", "by (auto simp: Cons_replicate_eq Cons_eq_append_conv)"], ["proof (state)\nthis:\n  local.F n = local.F (n - 1) + 1 + (\\<Sum>i = m..<n. local.F (n - i - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Computing the Fill-Count Function\\<close>"], ["", "fun lcount :: \"nat \\<Rightarrow> nat\" where\n  \"lcount n = (\n    if n < m then 1\n    else if n = m then 2\n    else lcount (n - 1) + 1 + (\\<Sum>i \\<leftarrow> [m..<n]. lcount (n - i - 1))\n  )\""], ["", "lemmas [simp del] = lcount.simps"], ["", "lemma lcount_correct:\n  \"lcount n = F n\" if \"m > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lcount n = local.F n", "proof (induction n rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           local.lcount y = local.F y) \\<Longrightarrow>\n       local.lcount x = local.F x", "case (less n)"], ["proof (state)\nthis:\n  ?y < n \\<Longrightarrow> local.lcount ?y = local.F ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           local.lcount y = local.F y) \\<Longrightarrow>\n       local.lcount x = local.F x", "from \\<open>m > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < m", "show ?case"], ["proof (prove)\nusing this:\n  0 < m\n\ngoal (1 subgoal):\n 1. local.lcount n = local.F n", "apply (cases \"n = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; n = 0\\<rbrakk>\n    \\<Longrightarrow> local.lcount n = local.F n\n 2. \\<lbrakk>0 < m; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> local.lcount n = local.F n", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; n = 0\\<rbrakk>\n    \\<Longrightarrow> local.lcount n = local.F n", "by (simp add: lcount.simps F_base_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> local.lcount n = local.F n", "by (subst lcount.simps)\n      (simp add: less.IH F_base_1 F_base_2 F_rec interv_sum_list_conv_sum_set_nat)"], ["proof (state)\nthis:\n  local.lcount n = local.F n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Memoization\\<close>"], ["", "memoize_fun lcount\\<^sub>m: lcount with_memory dp_consistency_mapping"], ["", "monadifies (state) lcount.simps"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) local.lcount local.lcount\\<^sub>m'", "by memoize_prover"], ["", "lemmas [code] = lcount\\<^sub>m.memoized_correct"], ["", "end"], ["", "(* Fixed block size *)"], ["", "subsubsection \\<open>Problem solutions\\<close>"], ["", "text \\<open>Example and solution for problem \\<open>#\\<close>114\\<close>"], ["", "value \"lcount 3 7\""], ["", "value \"lcount 3 50\""], ["", "text \\<open>Examples for problem \\<open>#\\<close>115\\<close>"], ["", "value \"lcount 3 29\""], ["", "value \"lcount 3 30\""], ["", "value \"lcount 10 56\""], ["", "value \"lcount 10 57\""], ["", "text \\<open>Binary search for the solution of problem \\<open>#\\<close>115\\<close>"], ["", "value \"lcount 50 100\""], ["", "value \"lcount 50 150\""], ["", "value \"lcount 50 163\""], ["", "value \"lcount 50 166\""], ["", "value \"lcount 50 167\""], ["", "value \"lcount 50 168\" \\<comment> \\<open>The solution\\<close>"], ["", "value \"lcount 50 169\""], ["", "value \"lcount 50 175\""], ["", "value \"lcount 50 200\""], ["", "value \"lcount 50 300\""], ["", "value \"lcount 50 500\""], ["", "value \"lcount 50 1000\""], ["", "text \\<open>We prove that 168 is the solution for problem \\<open>#\\<close>115\\<close>"], ["", "theorem\n  \"(LEAST n. F 50 n > 1000000) = 168\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. 1000000 < F 50 n) = 168", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. 1000000 < F 50 n) = 168", "have \"lcount 50 168 > 1000000\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1000000 < lcount 50 168", "by eval"], ["proof (state)\nthis:\n  1000000 < lcount 50 168\n\ngoal (1 subgoal):\n 1. (LEAST n. 1000000 < F 50 n) = 168", "moreover"], ["proof (state)\nthis:\n  1000000 < lcount 50 168\n\ngoal (1 subgoal):\n 1. (LEAST n. 1000000 < F 50 n) = 168", "have \"\\<forall> n \\<in> {0..<168}. lcount 50 n < 1000000\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{0..<168}. lcount 50 n < 1000000", "by eval"], ["proof (state)\nthis:\n  \\<forall>n\\<in>{0..<168}. lcount 50 n < 1000000\n\ngoal (1 subgoal):\n 1. (LEAST n. 1000000 < F 50 n) = 168", "ultimately"], ["proof (chain)\npicking this:\n  1000000 < lcount 50 168\n  \\<forall>n\\<in>{0..<168}. lcount 50 n < 1000000", "show ?thesis"], ["proof (prove)\nusing this:\n  1000000 < lcount 50 168\n  \\<forall>n\\<in>{0..<168}. lcount 50 n < 1000000\n\ngoal (1 subgoal):\n 1. (LEAST n. 1000000 < F 50 n) = 168", "by - (rule Least_equality; rule ccontr; force simp: not_le lcount_correct)"], ["proof (state)\nthis:\n  (LEAST n. 1000000 < F 50 n) = 168\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}