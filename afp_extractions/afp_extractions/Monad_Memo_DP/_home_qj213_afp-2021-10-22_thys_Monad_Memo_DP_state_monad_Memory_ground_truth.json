{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/state_monad/Memory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma lift_pI[intro?]:\n  \"lift_p P f\" if \"\\<And> heap x heap'. P heap \\<Longrightarrow> run_state f heap = (x, heap') \\<Longrightarrow> P heap'\"", "lemma mem_correct_default:\n  \"mem_correct\n    (\\<lambda> k. do {m \\<leftarrow> State_Monad.get; State_Monad.return (m k)})\n    (\\<lambda> k v. do {m \\<leftarrow> State_Monad.get; State_Monad.set (m(k\\<mapsto>v))})\n    (\\<lambda> _. True)\"", "lemma mem_correct_rbt_mapping:\n  \"mem_correct\n    (\\<lambda> k. do {m \\<leftarrow> State_Monad.get; State_Monad.return (Mapping.lookup m k)})\n    (\\<lambda> k v. do {m \\<leftarrow> State_Monad.get; State_Monad.set (Mapping.update k v m)})\n    (\\<lambda> _. True)\"", "lemma (in mem_correct_empty) dom_empty[simp]:\n  \"dom (map_of empty) = {}\"", "lemma mem_correct_empty_default:\n  \"mem_correct_empty\n    (\\<lambda> k. do {m \\<leftarrow> State_Monad.get; State_Monad.return (m k)})\n    (\\<lambda> k v. do {m \\<leftarrow> State_Monad.get; State_Monad.set (m(k\\<mapsto>v))})\n    (\\<lambda> _. True)\n    Map.empty\"", "lemma mem_correct_rbt_empty_mapping:\n  \"mem_correct_empty\n    (\\<lambda> k. do {m \\<leftarrow> State_Monad.get; State_Monad.return (Mapping.lookup m k)})\n    (\\<lambda> k v. do {m \\<leftarrow> State_Monad.get; State_Monad.set (Mapping.update k v m)})\n    (\\<lambda> _. True)\n    Mapping.empty\"", "lemma cmem_empty:\n  \"cmem empty\"", "lemma memoized:\n  \"dp x = fst (State_Monad.run_state (dp\\<^sub>T x) empty)\" if \"consistentDP dp\\<^sub>T\"", "lemma cmem_result:\n  \"cmem (snd (State_Monad.run_state (dp\\<^sub>T x) empty))\" if \"consistentDP dp\\<^sub>T\"", "lemma map_of_simp:\n  \"state_mem_defs.map_of lookup_trace = map_of o snd\"", "lemma mem_correct_tracing: \"mem_correct lookup_trace update_trace (P o snd)\"", "lemma mem_correct_tracing_empty:\n  \"mem_correct_empty lookup_trace update_trace (P o snd) ([], empty)\""], "translations": [["", "lemma lift_pI[intro?]:\n  \"lift_p P f\" if \"\\<And> heap x heap'. P heap \\<Longrightarrow> run_state f heap = (x, heap') \\<Longrightarrow> P heap'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_p P f", "unfolding lift_p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       P heap \\<longrightarrow>\n       (case run_state f heap of (x, xa) \\<Rightarrow> P xa)", "by (auto intro: that)"], ["", "lemma mem_correct_default:\n  \"mem_correct\n    (\\<lambda> k. do {m \\<leftarrow> State_Monad.get; State_Monad.return (m k)})\n    (\\<lambda> k v. do {m \\<leftarrow> State_Monad.get; State_Monad.set (m(k\\<mapsto>v))})\n    (\\<lambda> _. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct\n     (\\<lambda>k.\n         State_Monad.get \\<bind> (\\<lambda>m. State_Monad.return (m k)))\n     (\\<lambda>k v.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.set (m(k \\<mapsto> v))))\n     (\\<lambda>_. True)", "by standard\n    (auto simp: map_le_def state_mem_defs.map_of_def State_Monad.bind_def State_Monad.get_def State_Monad.return_def State_Monad.set_def lift_p_def)"], ["", "lemma mem_correct_rbt_mapping:\n  \"mem_correct\n    (\\<lambda> k. do {m \\<leftarrow> State_Monad.get; State_Monad.return (Mapping.lookup m k)})\n    (\\<lambda> k v. do {m \\<leftarrow> State_Monad.get; State_Monad.set (Mapping.update k v m)})\n    (\\<lambda> _. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>k v.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.set (Mapping.update k v m)))\n     (\\<lambda>_. True)", "by standard\n     (auto simp:\n        map_le_def state_mem_defs.map_of_def State_Monad.bind_def State_Monad.get_def State_Monad.return_def State_Monad.set_def lookup_update' lift_p_def\n     )"], ["", "locale mem_correct_empty = mem_correct +\n  fixes empty\n  assumes empty_correct: \"map_of empty \\<subseteq>\\<^sub>m Map.empty\" and P_empty: \"P empty\""], ["", "lemma (in mem_correct_empty) dom_empty[simp]:\n  \"dom (map_of empty) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (local.map_of empty) = {}", "using empty_correct"], ["proof (prove)\nusing this:\n  local.map_of empty \\<subseteq>\\<^sub>m Map.empty\n\ngoal (1 subgoal):\n 1. dom (local.map_of empty) = {}", "by (auto dest: map_le_implies_dom_le)"], ["", "lemma mem_correct_empty_default:\n  \"mem_correct_empty\n    (\\<lambda> k. do {m \\<leftarrow> State_Monad.get; State_Monad.return (m k)})\n    (\\<lambda> k v. do {m \\<leftarrow> State_Monad.get; State_Monad.set (m(k\\<mapsto>v))})\n    (\\<lambda> _. True)\n    Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct_empty\n     (\\<lambda>k.\n         State_Monad.get \\<bind> (\\<lambda>m. State_Monad.return (m k)))\n     (\\<lambda>k v.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.set (m(k \\<mapsto> v))))\n     (\\<lambda>_. True) Map.empty", "by (intro mem_correct_empty.intro[OF mem_correct_default] mem_correct_empty_axioms.intro)\n     (auto simp: state_mem_defs.map_of_def map_le_def State_Monad.bind_def State_Monad.get_def State_Monad.return_def)"], ["", "lemma mem_correct_rbt_empty_mapping:\n  \"mem_correct_empty\n    (\\<lambda> k. do {m \\<leftarrow> State_Monad.get; State_Monad.return (Mapping.lookup m k)})\n    (\\<lambda> k v. do {m \\<leftarrow> State_Monad.get; State_Monad.set (Mapping.update k v m)})\n    (\\<lambda> _. True)\n    Mapping.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct_empty\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>k v.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.set (Mapping.update k v m)))\n     (\\<lambda>_. True) Mapping.empty", "by (intro mem_correct_empty.intro[OF mem_correct_rbt_mapping] mem_correct_empty_axioms.intro)\n     (auto simp: state_mem_defs.map_of_def map_le_def State_Monad.bind_def State_Monad.get_def State_Monad.return_def lookup_empty)"], ["", "locale dp_consistency_empty =\n  dp_consistency + mem_correct_empty\nbegin"], ["", "lemma cmem_empty:\n  \"cmem empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmem empty", "using empty_correct"], ["proof (prove)\nusing this:\n  local.map_of empty \\<subseteq>\\<^sub>m Map.empty\n\ngoal (1 subgoal):\n 1. cmem empty", "unfolding cmem_def"], ["proof (prove)\nusing this:\n  local.map_of empty \\<subseteq>\\<^sub>m Map.empty\n\ngoal (1 subgoal):\n 1. \\<forall>param\\<in>dom (local.map_of empty).\n       local.map_of empty param = Some (dp param)", "by auto"], ["", "corollary memoization_correct:\n  \"dp x = v\" \"cmem m\" if \"consistentDP dp\\<^sub>T\" \"State_Monad.run_state (dp\\<^sub>T x) empty = (v, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp x = v &&& cmem m", "using that"], ["proof (prove)\nusing this:\n  consistentDP dp\\<^sub>T\n  run_state (dp\\<^sub>T x) empty = (v, m)\n\ngoal (1 subgoal):\n 1. dp x = v &&& cmem m", "unfolding consistentDP_def"], ["proof (prove)\nusing this:\n  ((=) ===>\\<^sub>T (=)) dp dp\\<^sub>T\n  run_state (dp\\<^sub>T x) empty = (v, m)\n\ngoal (1 subgoal):\n 1. dp x = v &&& cmem m", "by (auto dest!: rel_funD[where x = x] elim!: crel_vs_elim intro: P_empty cmem_empty)"], ["", "lemma memoized:\n  \"dp x = fst (State_Monad.run_state (dp\\<^sub>T x) empty)\" if \"consistentDP dp\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp x = fst (run_state (dp\\<^sub>T x) empty)", "using surjective_pairing memoization_correct(1)[OF that]"], ["proof (prove)\nusing this:\n  ?t = (fst ?t, snd ?t)\n  run_state (dp\\<^sub>T ?x) empty = (?v, ?m) \\<Longrightarrow> dp ?x = ?v\n\ngoal (1 subgoal):\n 1. dp x = fst (run_state (dp\\<^sub>T x) empty)", "by blast"], ["", "lemma cmem_result:\n  \"cmem (snd (State_Monad.run_state (dp\\<^sub>T x) empty))\" if \"consistentDP dp\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmem (snd (run_state (dp\\<^sub>T x) empty))", "using surjective_pairing memoization_correct(2)[OF that]"], ["proof (prove)\nusing this:\n  ?t = (fst ?t, snd ?t)\n  run_state (dp\\<^sub>T ?x) empty = (?v, ?m) \\<Longrightarrow> cmem ?m\n\ngoal (1 subgoal):\n 1. cmem (snd (run_state (dp\\<^sub>T x) empty))", "by blast"], ["", "end"], ["", "(* DP Consistency Empty *)"], ["", "locale dp_consistency_default =\n  fixes dp :: \"'param \\<Rightarrow> 'result\"\nbegin"], ["", "sublocale dp_consistency_empty\n  \"\\<lambda> k. do {(m::'param \\<rightharpoonup> 'result) \\<leftarrow> State_Monad.get; State_Monad.return (m k)}\"\n  \"\\<lambda> k v. do {m \\<leftarrow> State_Monad.get; State_Monad.set (m(k\\<mapsto>v))}\"\n  \"\\<lambda> (_::'param \\<rightharpoonup> 'result). True\"\n  dp\n  Map.empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_empty\n     (\\<lambda>k.\n         State_Monad.get \\<bind> (\\<lambda>m. State_Monad.return (m k)))\n     (\\<lambda>k v.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.set (m(k \\<mapsto> v))))\n     (\\<lambda>_. True) Map.empty", "by (intro\n      dp_consistency_empty.intro dp_consistency.intro mem_correct_default mem_correct_empty_default\n     )"], ["", "end"], ["", "(* DP Consistency Default *)"], ["", "locale dp_consistency_mapping =\n  fixes dp :: \"'param \\<Rightarrow> 'result\"\nbegin"], ["", "sublocale dp_consistency_empty\n  \"(\\<lambda> k. do {(m::('param,'result) mapping) \\<leftarrow> State_Monad.get; State_Monad.return (Mapping.lookup m k)})\"\n    \"(\\<lambda> k v. do {m \\<leftarrow> State_Monad.get; State_Monad.set (Mapping.update k v m)})\"\n    \"(\\<lambda> _::('param,'result) mapping. True)\" dp Mapping.empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_empty\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>k v.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.set (Mapping.update k v m)))\n     (\\<lambda>_. True) Mapping.empty", "by (intro\n      dp_consistency_empty.intro dp_consistency.intro mem_correct_rbt_mapping\n      mem_correct_rbt_empty_mapping\n     )"], ["", "end"], ["", "(* DP Consistency RBT *)"], ["", "subsubsection \\<open>Tracing Memory\\<close>"], ["", "context state_mem_defs\nbegin"], ["", "definition\n  \"lookup_trace k =\n  State (\\<lambda> (log, m). case State_Monad.run_state (lookup k) m of\n    (None, m) \\<Rightarrow> (None, ((''Missed'', k) # log, m)) |\n    (Some v, m) \\<Rightarrow> (Some v, ((''Found'', k) # log, m))\n  )\""], ["", "definition\n  \"update_trace k v =\n  State (\\<lambda> (log, m). case State_Monad.run_state (update k v) m of\n    (_, m) \\<Rightarrow> ((), ((''Stored'', k) # log, m))\n  )\""], ["", "end"], ["", "context mem_correct\nbegin"], ["", "lemma map_of_simp:\n  \"state_mem_defs.map_of lookup_trace = map_of o snd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_mem_defs.map_of lookup_trace = local.map_of \\<circ> snd", "unfolding state_mem_defs.map_of_def lookup_trace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>heap k.\n        fst (run_state\n              (State\n                (\\<lambda>(log, m).\n                    case run_state (lookup k) m of\n                    (None, m) \\<Rightarrow> (None, (''Missed'', k) # log, m)\n                    | (Some v, m) \\<Rightarrow>\n                        (Some v, (''Found'', k) # log, m)))\n              heap)) =\n    (\\<lambda>heap k. fst (run_state (lookup k) heap)) \\<circ> snd", "by (rule ext) (auto split: prod.split option.split)"], ["", "lemma mem_correct_tracing: \"mem_correct lookup_trace update_trace (P o snd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct lookup_trace update_trace (P \\<circ> snd)", "by standard\n    (auto\n      intro!: lift_pI\n      elim: lift_p_P[OF lookup_inv]\n      simp: lookup_trace_def update_trace_def state_mem_defs.map_of_def map_of_simp\n      split: prod.splits option.splits;\n      metis snd_conv lookup_correct update_correct lift_p_P update_inv lookup_inv lift_p_P\n   )+"], ["", "end"], ["", "context mem_correct_empty\nbegin"], ["", "lemma mem_correct_tracing_empty:\n  \"mem_correct_empty lookup_trace update_trace (P o snd) ([], empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct_empty lookup_trace update_trace (P \\<circ> snd) ([], empty)", "by (intro mem_correct_empty.intro mem_correct_tracing mem_correct_empty_axioms.intro)\n     (simp add: map_of_simp empty_correct P_empty)+"], ["", "end"], ["", "locale dp_consistency_mapping_tracing =\n  fixes dp :: \"'param \\<Rightarrow> 'result\"\nbegin"], ["", "interpretation mapping: dp_consistency_mapping"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale dp_consistency_empty\n  mapping.lookup_trace mapping.update_trace \"(\\<lambda> _. True) o snd\" dp \"([], Mapping.empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency_empty\n     (state_mem_defs.lookup_trace\n       (\\<lambda>k.\n           State_Monad.get \\<bind>\n           (\\<lambda>m. State_Monad.return (Mapping.lookup m k))))\n     (state_mem_defs.update_trace\n       (\\<lambda>k v.\n           State_Monad.get \\<bind>\n           (\\<lambda>m. State_Monad.set (Mapping.update k v m))))\n     ((\\<lambda>_. True) \\<circ> snd) ([], Mapping.empty)", "by (rule\n      dp_consistency_empty.intro dp_consistency.intro\n      mapping.mem_correct_tracing_empty mem_correct_empty.axioms(1)\n     )+"], ["", "end"], ["", "(* DP Consistency RBT *)"], ["", "end"], ["", "(* Theory *)"]]}