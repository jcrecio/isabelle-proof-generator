{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/heap_monad/Pair_Memory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma map_add_mono:\n  \"(m1 ++ m2) \\<subseteq>\\<^sub>m (m1' ++ m2')\" if \"m1 \\<subseteq>\\<^sub>m m1'\" \"m2 \\<subseteq>\\<^sub>m m2'\" \"dom m1 \\<inter> dom m2' = {}\"", "lemma map_add_upd2:\n  \"f(x \\<mapsto> y) ++ g = (f ++ g)(x \\<mapsto> y)\" if \"dom f \\<inter> dom g = {}\" \"x \\<notin> dom g\"", "lemma map_of_le_pair:\n  \"pair.map_of m \\<subseteq>\\<^sub>m map_of1 m ++ map_of2 m\"\n  if \"inv_pair m\"", "lemma pair_le_map_of:\n  \"map_of1 m ++ map_of2 m \\<subseteq>\\<^sub>m pair.map_of m\"\n  if \"inv_pair m\"", "lemma map_of_eq_pair:\n  \"map_of1 m ++ map_of2 m = pair.map_of m\"\n  if \"inv_pair m\"", "lemma inv_pair_neq[simp]:\n  False if \"inv_pair m\" \"fst (State_Monad.run_state get_k1 m) = fst (State_Monad.run_state get_k2 m)\"", "lemma inv_pair_P_D:\n  \"P m\" if \"inv_pair m\"", "lemma inv_pair_domD[intro]:\n  \"dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\" if \"inv_pair m\"", "lemma move12_correct1:\n  \"map_of1 heap' \\<subseteq>\\<^sub>m Map.empty\" if \"State_Monad.run_state (move12 k1) heap = (x, heap')\" \"P heap\"", "lemma move12_correct2:\n  \"map_of2 heap' \\<subseteq>\\<^sub>m map_of1 heap\" if \"State_Monad.run_state (move12 k1) heap = (x, heap')\" \"P heap\"", "lemma dom_empty[simp]:\n  \"dom (map_of1 heap') = {}\" if \"State_Monad.run_state (move12 k1) heap = (x, heap')\" \"P heap\"", "lemma inv_pair_lookup1:\n  \"inv_pair m'\" if \"State_Monad.run_state (lookup1 k) m = (v, m')\" \"inv_pair m\"", "lemma inv_pair_lookup2:\n  \"inv_pair m'\" if \"State_Monad.run_state (lookup2 k) m = (v, m')\" \"inv_pair m\"", "lemma inv_pair_update1:\n  \"inv_pair m'\"\n  if \"State_Monad.run_state (update1 (key2 k) v) m = (v', m')\" \"inv_pair m\" \"fst (State_Monad.run_state get_k1 m) = key1 k\"", "lemma inv_pair_update2:\n  \"inv_pair m'\"\n  if \"State_Monad.run_state (update2 (key2 k) v) m = (v', m')\" \"inv_pair m\" \"fst (State_Monad.run_state get_k2 m) = key1 k\"", "lemma inv_pair_move12:\n  \"inv_pair m'\"\n  if \"State_Monad.run_state (move12 k) m = (v', m')\" \"inv_pair m\" \"fst (State_Monad.run_state get_k1 m) \\<noteq> k\"", "lemma mem_correct_pair:\n  \"mem_correct lookup_pair update_pair inv_pair\"\n  if injective: \"\\<forall> k k'. key1 k = key1 k' \\<and> key2 k = key2 k' \\<longrightarrow> k = k'\"", "lemma emptyI:\n  assumes \"inv_pair m\" \"mem1.map_of m \\<subseteq>\\<^sub>m Map.empty\" \"mem2.map_of m \\<subseteq>\\<^sub>m Map.empty\"\n  shows \"pair.map_of m \\<subseteq>\\<^sub>m Map.empty\"", "lemma map_of_le_pair:\n  \"pair.map_of (Pair_Storage k1 k2 m1 m2) \\<subseteq>\\<^sub>m (map_of m1 ++ map_of m2)\"\n  if \"inv_pair (Pair_Storage k1 k2 m1 m2)\"", "lemma pair_le_map_of:\n  \"map_of m1 ++ map_of m2 \\<subseteq>\\<^sub>m pair.map_of (Pair_Storage k1 k2 m1 m2)\"\n  if \"inv_pair (Pair_Storage k1 k2 m1 m2)\"", "lemma map_of_eq_pair:\n  \"map_of m1 ++ map_of m2 = pair.map_of (Pair_Storage k1 k2 m1 m2)\"\n  if \"inv_pair (Pair_Storage k1 k2 m1 m2)\"", "lemma inv_pair_neq[simp, dest]:\n  False if \"inv_pair (Pair_Storage k k x y)\"", "lemma inv_pair_P_D1:\n  \"P m1\" if \"inv_pair (Pair_Storage k1 k2 m1 m2)\"", "lemma inv_pair_P_D2:\n  \"P m2\" if \"inv_pair (Pair_Storage k1 k2 m1 m2)\"", "lemma inv_pair_domD[intro]:\n  \"dom (map_of m1) \\<inter> dom (map_of m2) = {}\" if \"inv_pair (Pair_Storage k1 k2 m1 m2)\"", "lemma mem_correct_pair:\n  \"mem_correct lookup_pair update_pair inv_pair\""], "translations": [["", "lemma map_add_mono:\n  \"(m1 ++ m2) \\<subseteq>\\<^sub>m (m1' ++ m2')\" if \"m1 \\<subseteq>\\<^sub>m m1'\" \"m2 \\<subseteq>\\<^sub>m m2'\" \"dom m1 \\<inter> dom m2' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 ++ m2 \\<subseteq>\\<^sub>m m1' ++ m2'", "using that"], ["proof (prove)\nusing this:\n  m1 \\<subseteq>\\<^sub>m m1'\n  m2 \\<subseteq>\\<^sub>m m2'\n  dom m1 \\<inter> dom m2' = {}\n\ngoal (1 subgoal):\n 1. m1 ++ m2 \\<subseteq>\\<^sub>m m1' ++ m2'", "unfolding map_le_def map_add_def dom_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>{a. m1 a \\<noteq> None}. m1 a = m1' a\n  \\<forall>a\\<in>{a. m2 a \\<noteq> None}. m2 a = m2' a\n  {a. m1 a \\<noteq> None} \\<inter> {a. m2' a \\<noteq> None} = {}\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{a. (case m2 a of None \\<Rightarrow> m1 a\n                        | Some x \\<Rightarrow> Some x) \\<noteq>\n                       None}.\n       (case m2 a of None \\<Rightarrow> m1 a\n        | Some x \\<Rightarrow> Some x) =\n       (case m2' a of None \\<Rightarrow> m1' a\n        | Some x \\<Rightarrow> Some x)", "by (auto split: option.splits)"], ["", "lemma map_add_upd2:\n  \"f(x \\<mapsto> y) ++ g = (f ++ g)(x \\<mapsto> y)\" if \"dom f \\<inter> dom g = {}\" \"x \\<notin> dom g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f(x \\<mapsto> y) ++ g = (f ++ g)(x \\<mapsto> y)", "apply (subst map_add_comm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dom (f(x \\<mapsto> y)) \\<inter> dom g = {}\n 2. g ++ f(x \\<mapsto> y) = (f ++ g)(x \\<mapsto> y)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. g ++ f(x \\<mapsto> y) = (f ++ g)(x \\<mapsto> y)\n 2. dom (f(x \\<mapsto> y)) \\<inter> dom g = {}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (g ++ f)(x \\<mapsto> y) = (f ++ g)(x \\<mapsto> y)\n 2. dom (f(x \\<mapsto> y)) \\<inter> dom g = {}", "apply (subst map_add_comm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. dom g \\<inter> dom f = {}\n 2. (f ++ g)(x \\<mapsto> y) = (f ++ g)(x \\<mapsto> y)\n 3. dom (f(x \\<mapsto> y)) \\<inter> dom g = {}", "using that"], ["proof (prove)\nusing this:\n  dom f \\<inter> dom g = {}\n  x \\<notin> dom g\n\ngoal (3 subgoals):\n 1. dom g \\<inter> dom f = {}\n 2. (f ++ g)(x \\<mapsto> y) = (f ++ g)(x \\<mapsto> y)\n 3. dom (f(x \\<mapsto> y)) \\<inter> dom g = {}", "by auto"], ["", "locale pair_mem_defs =\n  fixes lookup1 lookup2 :: \"'a \\<Rightarrow> ('mem, 'v option) state\"\n    and update1 update2 :: \"'a \\<Rightarrow> 'v \\<Rightarrow> ('mem, unit) state\"\n    and move12 :: \"'k1 \\<Rightarrow> ('mem, unit) state\"\n    and get_k1 get_k2 :: \"('mem, 'k1) state\"\n    and P :: \"'mem \\<Rightarrow> bool\"\n  fixes key1 :: \"'k \\<Rightarrow> 'k1\" and key2 :: \"'k \\<Rightarrow> 'a\"\nbegin"], ["", "text \\<open>We assume that look-ups happen on the older row, so it is biased towards the second entry.\\<close>"], ["", "definition\n  \"lookup_pair k = do {\n     let k' = key1 k;\n     k2 \\<leftarrow> get_k2;\n     if k' = k2\n     then lookup2 (key2 k)\n     else do {\n       k1 \\<leftarrow> get_k1;\n       if k' = k1\n       then lookup1 (key2 k)\n       else State_Monad.return None\n     }\n   }\n   \""], ["", "text \\<open>We assume that updates happen on the newer row, so it is biased towards the first entry.\\<close>"], ["", "definition\n  \"update_pair k v = do {\n    let k' = key1 k;\n    k1 \\<leftarrow> get_k1;\n    if k' = k1\n    then update1 (key2 k) v\n    else do {\n      k2 \\<leftarrow> get_k2;\n      if k' = k2\n      then update2 (key2 k) v\n      else (move12 k' \\<then> update1 (key2 k) v)\n    }\n  }\n  \""], ["", "sublocale pair: state_mem_defs lookup_pair update_pair"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale mem1: state_mem_defs lookup1 update1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale mem2: state_mem_defs lookup2 update2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition\n  \"inv_pair heap \\<equiv>\n    let\n      k1 = fst (State_Monad.run_state get_k1 heap);\n      k2 = fst (State_Monad.run_state get_k2 heap)\n    in\n    (\\<forall> k \\<in> dom (mem1.map_of heap). \\<exists> k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n    (\\<forall> k \\<in> dom (mem2.map_of heap). \\<exists> k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n    k1 \\<noteq> k2 \\<and> P heap\n  \""], ["", "definition\n  \"map_of1 m k = (if key1 k = fst (State_Monad.run_state get_k1 m) then mem1.map_of m (key2 k) else None)\""], ["", "definition\n  \"map_of2 m k = (if key1 k = fst (State_Monad.run_state get_k2 m) then mem2.map_of m (key2 k) else None)\""], ["", "end"], ["", "(* Pair Mem Defs *)"], ["", "locale pair_mem = pair_mem_defs +\n  assumes get_state:\n    \"State_Monad.run_state get_k1 m = (k, m') \\<Longrightarrow> m' = m\"\n    \"State_Monad.run_state get_k2 m = (k, m') \\<Longrightarrow> m' = m\"\n  assumes move12_correct:\n    \"P m \\<Longrightarrow> State_Monad.run_state (move12 k1) m = (x, m') \\<Longrightarrow> mem1.map_of m' \\<subseteq>\\<^sub>m Map.empty\"\n    \"P m \\<Longrightarrow> State_Monad.run_state (move12 k1) m = (x, m') \\<Longrightarrow> mem2.map_of m' \\<subseteq>\\<^sub>m mem1.map_of m\"\n  assumes move12_keys:\n    \"State_Monad.run_state (move12 k1) m = (x, m') \\<Longrightarrow> fst (State_Monad.run_state get_k1 m') = k1\"\n    \"State_Monad.run_state (move12 k1) m = (x, m') \\<Longrightarrow> fst (State_Monad.run_state get_k2 m') = fst (State_Monad.run_state get_k1 m)\"\n  assumes move12_inv:\n    \"lift_p P (move12 k1)\"\n  assumes lookup_inv:\n    \"lift_p P (lookup1 k')\" \"lift_p P (lookup2 k')\"\n  assumes update_inv:\n    \"lift_p P (update1 k' v)\" \"lift_p P (update2 k' v)\"\n  assumes lookup_keys:\n    \"P m \\<Longrightarrow> State_Monad.run_state (lookup1 k') m = (v', m') \\<Longrightarrow>\n     fst (State_Monad.run_state get_k1 m') = fst (State_Monad.run_state get_k1 m)\"\n    \"P m \\<Longrightarrow> State_Monad.run_state (lookup1 k') m = (v', m') \\<Longrightarrow>\n     fst (State_Monad.run_state get_k2 m') = fst (State_Monad.run_state get_k2 m)\"\n    \"P m \\<Longrightarrow> State_Monad.run_state (lookup2 k') m = (v', m') \\<Longrightarrow>\n     fst (State_Monad.run_state get_k1 m') = fst (State_Monad.run_state get_k1 m)\"\n    \"P m \\<Longrightarrow> State_Monad.run_state (lookup2 k') m = (v', m') \\<Longrightarrow>\n     fst (State_Monad.run_state get_k2 m') = fst (State_Monad.run_state get_k2 m)\"\n  assumes update_keys:\n    \"P m \\<Longrightarrow> State_Monad.run_state (update1 k' v) m = (x, m') \\<Longrightarrow>\n     fst (State_Monad.run_state get_k1 m') = fst (State_Monad.run_state get_k1 m)\"\n    \"P m \\<Longrightarrow> State_Monad.run_state (update1 k' v) m = (x, m') \\<Longrightarrow>\n     fst (State_Monad.run_state get_k2 m') = fst (State_Monad.run_state get_k2 m)\"\n    \"P m \\<Longrightarrow> State_Monad.run_state (update2 k' v) m = (x, m') \\<Longrightarrow>\n     fst (State_Monad.run_state get_k1 m') = fst (State_Monad.run_state get_k1 m)\"\n    \"P m \\<Longrightarrow> State_Monad.run_state (update2 k' v) m = (x, m') \\<Longrightarrow>\n     fst (State_Monad.run_state get_k2 m') = fst (State_Monad.run_state get_k2 m)\"\n  assumes\n    lookup_correct:\n      \"P m \\<Longrightarrow> mem1.map_of (snd (State_Monad.run_state (lookup1 k') m)) \\<subseteq>\\<^sub>m (mem1.map_of m)\"\n      \"P m \\<Longrightarrow> mem2.map_of (snd (State_Monad.run_state (lookup1 k') m)) \\<subseteq>\\<^sub>m (mem2.map_of m)\"\n      \"P m \\<Longrightarrow> mem1.map_of (snd (State_Monad.run_state (lookup2 k') m)) \\<subseteq>\\<^sub>m (mem1.map_of m)\"\n      \"P m \\<Longrightarrow> mem2.map_of (snd (State_Monad.run_state (lookup2 k') m)) \\<subseteq>\\<^sub>m (mem2.map_of m)\"\n  assumes\n    update_correct:\n      \"P m \\<Longrightarrow> mem1.map_of (snd (State_Monad.run_state (update1 k' v) m)) \\<subseteq>\\<^sub>m (mem1.map_of m)(k' \\<mapsto> v)\"\n      \"P m \\<Longrightarrow> mem2.map_of (snd (State_Monad.run_state (update2 k' v) m)) \\<subseteq>\\<^sub>m (mem2.map_of m)(k' \\<mapsto> v)\"\n      \"P m \\<Longrightarrow> mem2.map_of (snd (State_Monad.run_state (update1 k' v) m)) \\<subseteq>\\<^sub>m mem2.map_of m\"\n      \"P m \\<Longrightarrow> mem1.map_of (snd (State_Monad.run_state (update2 k' v) m)) \\<subseteq>\\<^sub>m mem1.map_of m\"\nbegin"], ["", "lemma map_of_le_pair:\n  \"pair.map_of m \\<subseteq>\\<^sub>m map_of1 m ++ map_of2 m\"\n  if \"inv_pair m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.map_of m \\<subseteq>\\<^sub>m map_of1 m ++ map_of2 m", "using that"], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. pair.map_of m \\<subseteq>\\<^sub>m map_of1 m ++ map_of2 m", "unfolding pair.map_of_def map_of1_def map_of2_def"], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. fst (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n    (\\<lambda>k.\n        if key1 k = fst (run_state get_k1 m) then mem1.map_of m (key2 k)\n        else None) ++\n    (\\<lambda>k.\n        if key1 k = fst (run_state get_k2 m) then mem2.map_of m (key2 k)\n        else None)", "unfolding lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def"], ["proof (prove)\nusing this:\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>{a. mem1.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>{a. mem2.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{a. fst (run_state\n                             (let k' = key1 a\n                              in get_k2 \\<bind>\n                                 (\\<lambda>k2.\n                                     if k' = k2 then lookup2 (key2 a)\n                                     else get_k1 \\<bind>\n    (\\<lambda>k1.\n        if k' = k1 then lookup1 (key2 a) else State_Monad.return None)))\n                             m) \\<noteq>\n                       None}.\n       fst (run_state\n             (let k' = key1 a\n              in get_k2 \\<bind>\n                 (\\<lambda>k2.\n                     if k' = k2 then lookup2 (key2 a)\n                     else get_k1 \\<bind>\n                          (\\<lambda>k1.\n                              if k' = k1 then lookup1 (key2 a)\n                              else State_Monad.return None)))\n             m) =\n       (case if key1 a = fst (run_state get_k2 m)\n             then mem2.map_of m (key2 a) else None of\n        None \\<Rightarrow>\n          if key1 a = fst (run_state get_k1 m) then mem1.map_of m (key2 a)\n          else None\n        | Some x \\<Rightarrow> Some x)", "unfolding State_Monad.bind_def"], ["proof (prove)\nusing this:\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>{a. mem1.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>{a. mem2.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{a. fst (run_state\n                             (let k' = key1 a\n                              in State\n                                  (\\<lambda>s.\ncase run_state get_k2 s of\n(aa, x) \\<Rightarrow>\n  run_state\n   (if k' = aa then lookup2 (key2 a)\n    else State\n          (\\<lambda>s.\n              case run_state get_k1 s of\n              (aa, x) \\<Rightarrow>\n                run_state\n                 (if k' = aa then lookup1 (key2 a)\n                  else State_Monad.return None)\n                 x))\n   x))\n                             m) \\<noteq>\n                       None}.\n       fst (run_state\n             (let k' = key1 a\n              in State\n                  (\\<lambda>s.\n                      case run_state get_k2 s of\n                      (aa, x) \\<Rightarrow>\n                        run_state\n                         (if k' = aa then lookup2 (key2 a)\n                          else State\n                                (\\<lambda>s.\n                                    case run_state get_k1 s of\n                                    (aa, x) \\<Rightarrow>\nrun_state (if k' = aa then lookup1 (key2 a) else State_Monad.return None)\n x))\n                         x))\n             m) =\n       (case if key1 a = fst (run_state get_k2 m)\n             then mem2.map_of m (key2 a) else None of\n        None \\<Rightarrow>\n          if key1 a = fst (run_state get_k1 m) then mem1.map_of m (key2 a)\n          else None\n        | Some x \\<Rightarrow> Some x)", "by (auto 4 4\n        simp: mem2.map_of_def mem1.map_of_def Let_def\n        dest: get_state split: prod.split_asm if_split_asm\n     )"], ["", "lemma pair_le_map_of:\n  \"map_of1 m ++ map_of2 m \\<subseteq>\\<^sub>m pair.map_of m\"\n  if \"inv_pair m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of1 m ++ map_of2 m \\<subseteq>\\<^sub>m pair.map_of m", "using that"], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. map_of1 m ++ map_of2 m \\<subseteq>\\<^sub>m pair.map_of m", "unfolding pair.map_of_def map_of1_def map_of2_def"], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        if key1 k = fst (run_state get_k1 m) then mem1.map_of m (key2 k)\n        else None) ++\n    (\\<lambda>k.\n        if key1 k = fst (run_state get_k2 m) then mem2.map_of m (key2 k)\n        else None) \\<subseteq>\\<^sub>m\n    (\\<lambda>k. fst (run_state (lookup_pair k) m))", "unfolding lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def"], ["proof (prove)\nusing this:\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>{a. mem1.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>{a. mem2.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{a. (case if key1 a = fst (run_state get_k2 m)\n                             then mem2.map_of m (key2 a) else None of\n                        None \\<Rightarrow>\n                          if key1 a = fst (run_state get_k1 m)\n                          then mem1.map_of m (key2 a) else None\n                        | Some x \\<Rightarrow> Some x) \\<noteq>\n                       None}.\n       (case if key1 a = fst (run_state get_k2 m)\n             then mem2.map_of m (key2 a) else None of\n        None \\<Rightarrow>\n          if key1 a = fst (run_state get_k1 m) then mem1.map_of m (key2 a)\n          else None\n        | Some x \\<Rightarrow> Some x) =\n       fst (run_state\n             (let k' = key1 a\n              in get_k2 \\<bind>\n                 (\\<lambda>k2.\n                     if k' = k2 then lookup2 (key2 a)\n                     else get_k1 \\<bind>\n                          (\\<lambda>k1.\n                              if k' = k1 then lookup1 (key2 a)\n                              else State_Monad.return None)))\n             m)", "unfolding State_Monad.bind_def"], ["proof (prove)\nusing this:\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>{a. mem1.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>{a. mem2.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{a. (case if key1 a = fst (run_state get_k2 m)\n                             then mem2.map_of m (key2 a) else None of\n                        None \\<Rightarrow>\n                          if key1 a = fst (run_state get_k1 m)\n                          then mem1.map_of m (key2 a) else None\n                        | Some x \\<Rightarrow> Some x) \\<noteq>\n                       None}.\n       (case if key1 a = fst (run_state get_k2 m)\n             then mem2.map_of m (key2 a) else None of\n        None \\<Rightarrow>\n          if key1 a = fst (run_state get_k1 m) then mem1.map_of m (key2 a)\n          else None\n        | Some x \\<Rightarrow> Some x) =\n       fst (run_state\n             (let k' = key1 a\n              in State\n                  (\\<lambda>s.\n                      case run_state get_k2 s of\n                      (aa, x) \\<Rightarrow>\n                        run_state\n                         (if k' = aa then lookup2 (key2 a)\n                          else State\n                                (\\<lambda>s.\n                                    case run_state get_k1 s of\n                                    (aa, x) \\<Rightarrow>\nrun_state (if k' = aa then lookup1 (key2 a) else State_Monad.return None)\n x))\n                         x))\n             m)", "by (auto\n        simp: mem2.map_of_def mem1.map_of_def State_Monad.run_state_return Let_def\n        dest: get_state split: prod.splits if_split_asm option.split\n     )"], ["", "lemma map_of_eq_pair:\n  \"map_of1 m ++ map_of2 m = pair.map_of m\"\n  if \"inv_pair m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of1 m ++ map_of2 m = pair.map_of m", "using that"], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. map_of1 m ++ map_of2 m = pair.map_of m", "unfolding pair.map_of_def map_of1_def map_of2_def"], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        if key1 k = fst (run_state get_k1 m) then mem1.map_of m (key2 k)\n        else None) ++\n    (\\<lambda>k.\n        if key1 k = fst (run_state get_k2 m) then mem2.map_of m (key2 k)\n        else None) =\n    (\\<lambda>k. fst (run_state (lookup_pair k) m))", "unfolding lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def"], ["proof (prove)\nusing this:\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>{a. mem1.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>{a. mem2.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case if key1 x = fst (run_state get_k2 m)\n             then mem2.map_of m (key2 x) else None of\n        None \\<Rightarrow>\n          if key1 x = fst (run_state get_k1 m) then mem1.map_of m (key2 x)\n          else None\n        | Some x \\<Rightarrow> Some x) =\n    (\\<lambda>k.\n        fst (run_state\n              (let k' = key1 k\n               in get_k2 \\<bind>\n                  (\\<lambda>k2.\n                      if k' = k2 then lookup2 (key2 k)\n                      else get_k1 \\<bind>\n                           (\\<lambda>k1.\n                               if k' = k1 then lookup1 (key2 k)\n                               else State_Monad.return None)))\n              m))", "unfolding State_Monad.bind_def"], ["proof (prove)\nusing this:\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>{a. mem1.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>{a. mem2.map_of m a \\<noteq> None}.\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case if key1 x = fst (run_state get_k2 m)\n             then mem2.map_of m (key2 x) else None of\n        None \\<Rightarrow>\n          if key1 x = fst (run_state get_k1 m) then mem1.map_of m (key2 x)\n          else None\n        | Some x \\<Rightarrow> Some x) =\n    (\\<lambda>k.\n        fst (run_state\n              (let k' = key1 k\n               in State\n                   (\\<lambda>s.\n                       case run_state get_k2 s of\n                       (a, x) \\<Rightarrow>\n                         run_state\n                          (if k' = a then lookup2 (key2 k)\n                           else State\n                                 (\\<lambda>s.\n                                     case run_state get_k1 s of\n                                     (a, x) \\<Rightarrow>\n run_state (if k' = a then lookup1 (key2 k) else State_Monad.return None)\n  x))\n                          x))\n              m))", "by (auto 4 4\n        simp: mem2.map_of_def mem1.map_of_def State_Monad.run_state_return Let_def\n        dest: get_state split: prod.splits option.split\n     )"], ["", "lemma inv_pair_neq[simp]:\n  False if \"inv_pair m\" \"fst (State_Monad.run_state get_k1 m) = fst (State_Monad.run_state get_k2 m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  inv_pair m\n  fst (run_state get_k1 m) = fst (run_state get_k2 m)\n\ngoal (1 subgoal):\n 1. False", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>dom (mem1.map_of m).\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>dom (mem2.map_of m).\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n  fst (run_state get_k1 m) = fst (run_state get_k2 m)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["", "lemma inv_pair_P_D:\n  \"P m\" if \"inv_pair m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P m", "using that"], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. P m", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>dom (mem1.map_of m).\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>dom (mem2.map_of m).\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n\ngoal (1 subgoal):\n 1. P m", "by (auto simp: Let_def)"], ["", "lemma inv_pair_domD[intro]:\n  \"dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\" if \"inv_pair m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of1 m) \\<inter> dom (map_of2 m) = {}", "using that"], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. dom (map_of1 m) \\<inter> dom (map_of2 m) = {}", "unfolding inv_pair_def map_of1_def map_of2_def"], ["proof (prove)\nusing this:\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>dom (mem1.map_of m).\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>dom (mem2.map_of m).\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n\ngoal (1 subgoal):\n 1. dom (\\<lambda>k.\n            if key1 k = fst (run_state get_k1 m) then mem1.map_of m (key2 k)\n            else None) \\<inter>\n    dom (\\<lambda>k.\n            if key1 k = fst (run_state get_k2 m) then mem2.map_of m (key2 k)\n            else None) =\n    {}", "by (auto split: if_split_asm)"], ["", "lemma move12_correct1:\n  \"map_of1 heap' \\<subseteq>\\<^sub>m Map.empty\" if \"State_Monad.run_state (move12 k1) heap = (x, heap')\" \"P heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of1 heap' \\<subseteq>\\<^sub>m Map.empty", "using move12_correct[OF that(2,1)]"], ["proof (prove)\nusing this:\n  mem1.map_of heap' \\<subseteq>\\<^sub>m Map.empty\n  mem2.map_of heap' \\<subseteq>\\<^sub>m mem1.map_of heap\n\ngoal (1 subgoal):\n 1. map_of1 heap' \\<subseteq>\\<^sub>m Map.empty", "unfolding map_of1_def"], ["proof (prove)\nusing this:\n  mem1.map_of heap' \\<subseteq>\\<^sub>m Map.empty\n  mem2.map_of heap' \\<subseteq>\\<^sub>m mem1.map_of heap\n\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        if key1 k = fst (run_state get_k1 heap')\n        then mem1.map_of heap' (key2 k) else None) \\<subseteq>\\<^sub>m\n    Map.empty", "by (auto simp: move12_keys map_le_def)"], ["", "lemma move12_correct2:\n  \"map_of2 heap' \\<subseteq>\\<^sub>m map_of1 heap\" if \"State_Monad.run_state (move12 k1) heap = (x, heap')\" \"P heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of2 heap' \\<subseteq>\\<^sub>m map_of1 heap", "using move12_correct(2)[OF that(2,1)] that"], ["proof (prove)\nusing this:\n  mem2.map_of heap' \\<subseteq>\\<^sub>m mem1.map_of heap\n  run_state (move12 k1) heap = (x, heap')\n  P heap\n\ngoal (1 subgoal):\n 1. map_of2 heap' \\<subseteq>\\<^sub>m map_of1 heap", "unfolding map_of1_def map_of2_def"], ["proof (prove)\nusing this:\n  mem2.map_of heap' \\<subseteq>\\<^sub>m mem1.map_of heap\n  run_state (move12 k1) heap = (x, heap')\n  P heap\n\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        if key1 k = fst (run_state get_k2 heap')\n        then mem2.map_of heap' (key2 k) else None) \\<subseteq>\\<^sub>m\n    (\\<lambda>k.\n        if key1 k = fst (run_state get_k1 heap)\n        then mem1.map_of heap (key2 k) else None)", "by (auto simp: move12_keys map_le_def)"], ["", "lemma dom_empty[simp]:\n  \"dom (map_of1 heap') = {}\" if \"State_Monad.run_state (move12 k1) heap = (x, heap')\" \"P heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of1 heap') = {}", "using move12_correct1[OF that]"], ["proof (prove)\nusing this:\n  map_of1 heap' \\<subseteq>\\<^sub>m Map.empty\n\ngoal (1 subgoal):\n 1. dom (map_of1 heap') = {}", "by (auto dest: map_le_implies_dom_le)"], ["", "lemma inv_pair_lookup1:\n  \"inv_pair m'\" if \"State_Monad.run_state (lookup1 k) m = (v, m')\" \"inv_pair m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair m'", "using that lookup_inv[of k] inv_pair_P_D[OF \\<open>inv_pair m\\<close>]"], ["proof (prove)\nusing this:\n  run_state (lookup1 k) m = (v, m')\n  inv_pair m\n  lift_p P (lookup1 k)\n  lift_p P (lookup2 k)\n  P m\n\ngoal (1 subgoal):\n 1. inv_pair m'", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  run_state (lookup1 k) m = (v, m')\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>dom (mem1.map_of m).\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>dom (mem2.map_of m).\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n  lift_p P (lookup1 k)\n  lift_p P (lookup2 k)\n  P m\n\ngoal (1 subgoal):\n 1. let k1 = fst (run_state get_k1 m'); k2 = fst (run_state get_k2 m')\n    in (\\<forall>k\\<in>dom (mem1.map_of m').\n           \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n       (\\<forall>k\\<in>dom (mem2.map_of m').\n           \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n       k1 \\<noteq> k2 \\<and> P m'", "by (auto 4 4\n        simp: Let_def lookup_keys\n        dest: lift_p_P lookup_correct[of _ k, THEN map_le_implies_dom_le]\n     )"], ["", "lemma inv_pair_lookup2:\n  \"inv_pair m'\" if \"State_Monad.run_state (lookup2 k) m = (v, m')\" \"inv_pair m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair m'", "using that lookup_inv[of k] inv_pair_P_D[OF \\<open>inv_pair m\\<close>]"], ["proof (prove)\nusing this:\n  run_state (lookup2 k) m = (v, m')\n  inv_pair m\n  lift_p P (lookup1 k)\n  lift_p P (lookup2 k)\n  P m\n\ngoal (1 subgoal):\n 1. inv_pair m'", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  run_state (lookup2 k) m = (v, m')\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>dom (mem1.map_of m).\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>dom (mem2.map_of m).\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n  lift_p P (lookup1 k)\n  lift_p P (lookup2 k)\n  P m\n\ngoal (1 subgoal):\n 1. let k1 = fst (run_state get_k1 m'); k2 = fst (run_state get_k2 m')\n    in (\\<forall>k\\<in>dom (mem1.map_of m').\n           \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n       (\\<forall>k\\<in>dom (mem2.map_of m').\n           \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n       k1 \\<noteq> k2 \\<and> P m'", "by (auto 4 4\n        simp: Let_def lookup_keys\n        dest: lift_p_P lookup_correct[of _ k, THEN map_le_implies_dom_le]\n     )"], ["", "lemma inv_pair_update1:\n  \"inv_pair m'\"\n  if \"State_Monad.run_state (update1 (key2 k) v) m = (v', m')\" \"inv_pair m\" \"fst (State_Monad.run_state get_k1 m) = key1 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair m'", "using that update_inv[of \"key2 k\" v] inv_pair_P_D[OF \\<open>inv_pair m\\<close>]"], ["proof (prove)\nusing this:\n  run_state (update1 (key2 k) v) m = (v', m')\n  inv_pair m\n  fst (run_state get_k1 m) = key1 k\n  lift_p P (update1 (key2 k) v)\n  lift_p P (update2 (key2 k) v)\n  P m\n\ngoal (1 subgoal):\n 1. inv_pair m'", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  run_state (update1 (key2 k) v) m = (v', m')\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>dom (mem1.map_of m).\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>dom (mem2.map_of m).\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n  fst (run_state get_k1 m) = key1 k\n  lift_p P (update1 (key2 k) v)\n  lift_p P (update2 (key2 k) v)\n  P m\n\ngoal (1 subgoal):\n 1. let k1 = fst (run_state get_k1 m'); k2 = fst (run_state get_k2 m')\n    in (\\<forall>k\\<in>dom (mem1.map_of m').\n           \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n       (\\<forall>k\\<in>dom (mem2.map_of m').\n           \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n       k1 \\<noteq> k2 \\<and> P m'", "apply (auto\n        simp: Let_def update_keys\n        dest: lift_p_P update_correct[of _ \"key2 k\" v, THEN map_le_implies_dom_le]\n     )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ka y.\n       \\<lbrakk>run_state (update1 (key2 k) v) m = ((), m');\n        fst (run_state get_k1 m) = key1 k; lift_p P (update1 (key2 k) v);\n        lift_p P (update2 (key2 k) v); P m;\n        \\<forall>ka\\<in>dom (mem1.map_of m).\n           \\<exists>k'. key1 k' = key1 k \\<and> key2 k' = ka;\n        \\<forall>k\\<in>dom (mem2.map_of m).\n           \\<exists>k'.\n              key1 k' = fst (run_state get_k2 m) \\<and> key2 k' = k;\n        key1 k \\<noteq> fst (run_state get_k2 m);\n        mem1.map_of m' ka = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k'. key1 k' = key1 k \\<and> key2 k' = ka\n 2. \\<And>ka y.\n       \\<lbrakk>run_state (update1 (key2 k) v) m = ((), m');\n        fst (run_state get_k1 m) = key1 k; lift_p P (update1 (key2 k) v);\n        lift_p P (update2 (key2 k) v); P m;\n        \\<forall>ka\\<in>dom (mem1.map_of m).\n           \\<exists>k'. key1 k' = key1 k \\<and> key2 k' = ka;\n        \\<forall>k\\<in>dom (mem2.map_of m).\n           \\<exists>k'.\n              key1 k' = fst (run_state get_k2 m) \\<and> key2 k' = k;\n        key1 k \\<noteq> fst (run_state get_k2 m);\n        mem2.map_of m' ka = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k'.\n                            key1 k' = fst (run_state get_k2 m) \\<and>\n                            key2 k' = ka", "apply (frule update_correct[of _ \"key2 k\" v, THEN map_le_implies_dom_le]; auto 13 2; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka y.\n       \\<lbrakk>run_state (update1 (key2 k) v) m = ((), m');\n        fst (run_state get_k1 m) = key1 k; lift_p P (update1 (key2 k) v);\n        lift_p P (update2 (key2 k) v); P m;\n        \\<forall>ka\\<in>dom (mem1.map_of m).\n           \\<exists>k'. key1 k' = key1 k \\<and> key2 k' = ka;\n        \\<forall>k\\<in>dom (mem2.map_of m).\n           \\<exists>k'.\n              key1 k' = fst (run_state get_k2 m) \\<and> key2 k' = k;\n        key1 k \\<noteq> fst (run_state get_k2 m);\n        mem2.map_of m' ka = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k'.\n                            key1 k' = fst (run_state get_k2 m) \\<and>\n                            key2 k' = ka", "apply (frule update_correct[of _ \"key2 k\" v, THEN map_le_implies_dom_le]; auto 13 2; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_pair_update2:\n  \"inv_pair m'\"\n  if \"State_Monad.run_state (update2 (key2 k) v) m = (v', m')\" \"inv_pair m\" \"fst (State_Monad.run_state get_k2 m) = key1 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair m'", "using that update_inv[of \"key2 k\" v] inv_pair_P_D[OF \\<open>inv_pair m\\<close>]"], ["proof (prove)\nusing this:\n  run_state (update2 (key2 k) v) m = (v', m')\n  inv_pair m\n  fst (run_state get_k2 m) = key1 k\n  lift_p P (update1 (key2 k) v)\n  lift_p P (update2 (key2 k) v)\n  P m\n\ngoal (1 subgoal):\n 1. inv_pair m'", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  run_state (update2 (key2 k) v) m = (v', m')\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>dom (mem1.map_of m).\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>dom (mem2.map_of m).\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n  fst (run_state get_k2 m) = key1 k\n  lift_p P (update1 (key2 k) v)\n  lift_p P (update2 (key2 k) v)\n  P m\n\ngoal (1 subgoal):\n 1. let k1 = fst (run_state get_k1 m'); k2 = fst (run_state get_k2 m')\n    in (\\<forall>k\\<in>dom (mem1.map_of m').\n           \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n       (\\<forall>k\\<in>dom (mem2.map_of m').\n           \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n       k1 \\<noteq> k2 \\<and> P m'", "apply (auto\n        simp: Let_def update_keys\n        dest: lift_p_P update_correct[of _ \"key2 k\" v, THEN map_le_implies_dom_le]\n     )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ka y.\n       \\<lbrakk>run_state (update2 (key2 k) v) m = ((), m');\n        fst (run_state get_k2 m) = key1 k; lift_p P (update1 (key2 k) v);\n        lift_p P (update2 (key2 k) v); P m;\n        \\<forall>k\\<in>dom (mem1.map_of m).\n           \\<exists>k'.\n              key1 k' = fst (run_state get_k1 m) \\<and> key2 k' = k;\n        \\<forall>ka\\<in>dom (mem2.map_of m).\n           \\<exists>k'. key1 k' = key1 k \\<and> key2 k' = ka;\n        fst (run_state get_k1 m) \\<noteq> key1 k;\n        mem1.map_of m' ka = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k'.\n                            key1 k' = fst (run_state get_k1 m) \\<and>\n                            key2 k' = ka\n 2. \\<And>ka y.\n       \\<lbrakk>run_state (update2 (key2 k) v) m = ((), m');\n        fst (run_state get_k2 m) = key1 k; lift_p P (update1 (key2 k) v);\n        lift_p P (update2 (key2 k) v); P m;\n        \\<forall>k\\<in>dom (mem1.map_of m).\n           \\<exists>k'.\n              key1 k' = fst (run_state get_k1 m) \\<and> key2 k' = k;\n        \\<forall>ka\\<in>dom (mem2.map_of m).\n           \\<exists>k'. key1 k' = key1 k \\<and> key2 k' = ka;\n        fst (run_state get_k1 m) \\<noteq> key1 k;\n        mem2.map_of m' ka = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k'. key1 k' = key1 k \\<and> key2 k' = ka", "apply (frule update_correct[of _ \"key2 k\" v, THEN map_le_implies_dom_le]; auto 13 2; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka y.\n       \\<lbrakk>run_state (update2 (key2 k) v) m = ((), m');\n        fst (run_state get_k2 m) = key1 k; lift_p P (update1 (key2 k) v);\n        lift_p P (update2 (key2 k) v); P m;\n        \\<forall>k\\<in>dom (mem1.map_of m).\n           \\<exists>k'.\n              key1 k' = fst (run_state get_k1 m) \\<and> key2 k' = k;\n        \\<forall>ka\\<in>dom (mem2.map_of m).\n           \\<exists>k'. key1 k' = key1 k \\<and> key2 k' = ka;\n        fst (run_state get_k1 m) \\<noteq> key1 k;\n        mem2.map_of m' ka = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k'. key1 k' = key1 k \\<and> key2 k' = ka", "apply (frule update_correct[of _ \"key2 k\" v, THEN map_le_implies_dom_le]; auto 13 2; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_pair_move12:\n  \"inv_pair m'\"\n  if \"State_Monad.run_state (move12 k) m = (v', m')\" \"inv_pair m\" \"fst (State_Monad.run_state get_k1 m) \\<noteq> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair m'", "using that move12_inv[of \"k\"] inv_pair_P_D[OF \\<open>inv_pair m\\<close>]"], ["proof (prove)\nusing this:\n  run_state (move12 k) m = (v', m')\n  inv_pair m\n  fst (run_state get_k1 m) \\<noteq> k\n  lift_p P (move12 k)\n  P m\n\ngoal (1 subgoal):\n 1. inv_pair m'", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  run_state (move12 k) m = (v', m')\n  let k1 = fst (run_state get_k1 m); k2 = fst (run_state get_k2 m)\n  in (\\<forall>k\\<in>dom (mem1.map_of m).\n         \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n     (\\<forall>k\\<in>dom (mem2.map_of m).\n         \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n     k1 \\<noteq> k2 \\<and> P m\n  fst (run_state get_k1 m) \\<noteq> k\n  lift_p P (move12 k)\n  P m\n\ngoal (1 subgoal):\n 1. let k1 = fst (run_state get_k1 m'); k2 = fst (run_state get_k2 m')\n    in (\\<forall>k\\<in>dom (mem1.map_of m').\n           \\<exists>k'. key1 k' = k1 \\<and> key2 k' = k) \\<and>\n       (\\<forall>k\\<in>dom (mem2.map_of m').\n           \\<exists>k'. key1 k' = k2 \\<and> key2 k' = k) \\<and>\n       k1 \\<noteq> k2 \\<and> P m'", "apply (auto\n        simp: Let_def move12_keys\n        dest: lift_p_P move12_correct[of _ \"k\", THEN map_le_implies_dom_le]\n     )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka y.\n       \\<lbrakk>run_state (move12 k) m = ((), m');\n        fst (run_state get_k1 m) \\<noteq> k; lift_p P (move12 k); P m;\n        \\<forall>k\\<in>dom (mem1.map_of m).\n           \\<exists>k'.\n              key1 k' = fst (run_state get_k1 m) \\<and> key2 k' = k;\n        \\<forall>k\\<in>dom (mem2.map_of m).\n           \\<exists>k'.\n              key1 k' = fst (run_state get_k2 m) \\<and> key2 k' = k;\n        fst (run_state get_k1 m) \\<noteq> fst (run_state get_k2 m);\n        mem2.map_of m' ka = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k'.\n                            key1 k' = fst (run_state get_k1 m) \\<and>\n                            key2 k' = ka", "apply (blast dest: move12_correct[of _ \"k\", THEN map_le_implies_dom_le])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mem_correct_pair:\n  \"mem_correct lookup_pair update_pair inv_pair\"\n  if injective: \"\\<forall> k k'. key1 k = key1 k' \\<and> key2 k = key2 k' \\<longrightarrow> k = k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct lookup_pair update_pair inv_pair", "proof (standard, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>k. lift_p inv_pair (lookup_pair k)\n 2. \\<And>k v. lift_p inv_pair (update_pair k v)\n 3. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 4. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "case (1 k) \\<comment> \\<open>Lookup invariant\\<close>"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>k. lift_p inv_pair (lookup_pair k)\n 2. \\<And>k v. lift_p inv_pair (update_pair k v)\n 3. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 4. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_p inv_pair (lookup_pair k)", "unfolding lookup_pair_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_p inv_pair\n     (get_k2 \\<bind>\n      (\\<lambda>k2.\n          if key1 k = k2 then lookup2 (key2 k)\n          else get_k1 \\<bind>\n               (\\<lambda>k1.\n                   if key1 k = k1 then lookup1 (key2 k)\n                   else State_Monad.return None)))", "by (auto 4 4\n        intro!: lift_pI\n        dest: get_state inv_pair_lookup1 inv_pair_lookup2\n        simp: State_Monad.bind_def State_Monad.run_state_return\n        split: if_split_asm prod.split_asm\n        )"], ["proof (state)\nthis:\n  lift_p inv_pair (lookup_pair k)\n\ngoal (3 subgoals):\n 1. \\<And>k v. lift_p inv_pair (update_pair k v)\n 2. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 3. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k v. lift_p inv_pair (update_pair k v)\n 2. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 3. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "case (2 k v) \\<comment> \\<open>Update invariant\\<close>"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>k v. lift_p inv_pair (update_pair k v)\n 2. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 3. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_p inv_pair (update_pair k v)", "unfolding update_pair_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_p inv_pair\n     (get_k1 \\<bind>\n      (\\<lambda>k1.\n          if key1 k = k1 then update1 (key2 k) v\n          else get_k2 \\<bind>\n               (\\<lambda>k2.\n                   if key1 k = k2 then update2 (key2 k) v\n                   else move12 (key1 k) \\<bind>\n                        (\\<lambda>_. update1 (key2 k) v))))", "apply (auto 4 4\n        intro!: lift_pI intro: inv_pair_update1 inv_pair_update2\n        dest: get_state\n        simp: State_Monad.bind_def get_state State_Monad.run_state_return\n        split: if_split_asm prod.split_asm\n        )+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>heap heap' x1 x2 x1a x2a x2b.\n       \\<lbrakk>inv_pair heap; run_state get_k1 heap = (x1, x2);\n        key1 k \\<noteq> x1; run_state get_k2 x2 = (x1a, x2a);\n        key1 k \\<noteq> x1a; run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state (update1 (key2 k) v) x2b = ((), heap')\\<rbrakk>\n       \\<Longrightarrow> inv_pair heap'", "apply (elim inv_pair_update1 inv_pair_move12)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>heap heap' x1 x2 x1a x2a x2b.\n       \\<lbrakk>inv_pair heap; run_state get_k1 heap = (x1, x2);\n        key1 k \\<noteq> x1; run_state get_k2 x2 = (x1a, x2a);\n        key1 k \\<noteq> x1a\\<rbrakk>\n       \\<Longrightarrow> inv_pair x2a\n 2. \\<And>heap heap' x1 x2 x1a x2a x2b.\n       \\<lbrakk>inv_pair heap; run_state get_k1 heap = (x1, x2);\n        key1 k \\<noteq> x1; run_state get_k2 x2 = (x1a, x2a);\n        key1 k \\<noteq> x1a\\<rbrakk>\n       \\<Longrightarrow> fst (run_state get_k1 x2a) \\<noteq> key1 k\n 3. \\<And>heap heap' x1 x2 x1a x2a x2b.\n       \\<lbrakk>inv_pair heap; run_state get_k1 heap = (x1, x2);\n        key1 k \\<noteq> x1; run_state get_k2 x2 = (x1a, x2a);\n        key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b)\\<rbrakk>\n       \\<Longrightarrow> fst (run_state get_k1 x2b) = key1 k", "apply (((subst get_state, assumption)+)?, auto intro: move12_keys dest: get_state; fail)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lift_p inv_pair (update_pair k v)\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "case (3 m k)"], ["proof (state)\nthis:\n  inv_pair m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "{"], ["proof (state)\nthis:\n  inv_pair m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "let ?m = \"snd (State_Monad.run_state (lookup2 (key2 k)) m)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have \"map_of1 ?m \\<subseteq>\\<^sub>m map_of1 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of1 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n    map_of1 m", "by (smt 3 domIff inv_pair_P_D local.lookup_keys lookup_correct map_le_def map_of1_def surjective_pairing)"], ["proof (state)\nthis:\n  map_of1 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  map_of1 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have \"map_of2 ?m \\<subseteq>\\<^sub>m map_of2 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n    map_of2 m", "by (smt 3 domIff inv_pair_P_D local.lookup_keys lookup_correct map_le_def map_of2_def surjective_pairing)"], ["proof (state)\nthis:\n  map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have \"dom (map_of1 ?m) \\<inter> dom (map_of2 m) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n    dom (map_of2 m) =\n    {}", "using 3 \\<open>map_of1 ?m \\<subseteq>\\<^sub>m map_of1 m\\<close> inv_pair_domD map_le_implies_dom_le"], ["proof (prove)\nusing this:\n  inv_pair m\n  map_of1 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  inv_pair ?m \\<Longrightarrow>\n  dom (map_of1 ?m) \\<inter> dom (map_of2 ?m) = {}\n  ?f \\<subseteq>\\<^sub>m ?g \\<Longrightarrow> dom ?f \\<subseteq> dom ?g\n\ngoal (1 subgoal):\n 1. dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n    dom (map_of2 m) =\n    {}", "by fastforce"], ["proof (state)\nthis:\n  dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have \"inv_pair ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair (snd (run_state (lookup2 (key2 k)) m))", "using 3 inv_pair_lookup2 surjective_pairing"], ["proof (prove)\nusing this:\n  inv_pair m\n  \\<lbrakk>run_state (lookup2 ?k) ?m = (?v, ?m'); inv_pair ?m\\<rbrakk>\n  \\<Longrightarrow> inv_pair ?m'\n  ?t = (fst ?t, snd ?t)\n\ngoal (1 subgoal):\n 1. inv_pair (snd (run_state (lookup2 (key2 k)) m))", "by metis"], ["proof (state)\nthis:\n  inv_pair (snd (run_state (lookup2 (key2 k)) m))\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "ultimately"], ["proof (chain)\npicking this:\n  map_of1 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n  dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n  inv_pair (snd (run_state (lookup2 (key2 k)) m))", "have \"pair.map_of ?m \\<subseteq>\\<^sub>m pair.map_of m\""], ["proof (prove)\nusing this:\n  map_of1 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n  dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n  inv_pair (snd (run_state (lookup2 (key2 k)) m))\n\ngoal (1 subgoal):\n 1. pair.map_of (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n    pair.map_of m", "apply (subst map_of_eq_pair[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup2 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (lookup2 (key2 k)) m))\n 2. \\<lbrakk>map_of1\n              (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup2 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (lookup2 (key2 k)) m)) ++\n                      map_of2\n                       (snd (run_state (lookup2 (key2 k))\n                              m)) \\<subseteq>\\<^sub>m\n                      pair.map_of m", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup2 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (lookup2 (key2 k)) m)) ++\n                      map_of2\n                       (snd (run_state (lookup2 (key2 k))\n                              m)) \\<subseteq>\\<^sub>m\n                      pair.map_of m\n 2. \\<lbrakk>map_of1\n              (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup2 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (lookup2 (key2 k)) m))", "apply (subst map_of_eq_pair[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup2 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair m\n 2. \\<lbrakk>map_of1\n              (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup2 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (lookup2 (key2 k)) m)) ++\n                      map_of2\n                       (snd (run_state (lookup2 (key2 k))\n                              m)) \\<subseteq>\\<^sub>m\n                      map_of1 m ++ map_of2 m\n 3. \\<lbrakk>map_of1\n              (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup2 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup2 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (lookup2 (key2 k)) m))", "by (auto intro: 3 map_add_mono)"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "}"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "{"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "let ?m = \"snd (State_Monad.run_state (lookup1 (key2 k)) m)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have \"map_of1 ?m \\<subseteq>\\<^sub>m map_of1 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of1 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n    map_of1 m", "by (smt 3 domIff inv_pair_P_D local.lookup_keys lookup_correct map_le_def map_of1_def surjective_pairing)"], ["proof (state)\nthis:\n  map_of1 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  map_of1 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have \"map_of2 ?m \\<subseteq>\\<^sub>m map_of2 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n    map_of2 m", "by (smt 3 domIff inv_pair_P_D local.lookup_keys lookup_correct map_le_def map_of2_def surjective_pairing)"], ["proof (state)\nthis:\n  map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have \"dom (map_of1 ?m) \\<inter> dom (map_of2 m) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n    dom (map_of2 m) =\n    {}", "using 3 \\<open>map_of1 ?m \\<subseteq>\\<^sub>m map_of1 m\\<close> inv_pair_domD map_le_implies_dom_le"], ["proof (prove)\nusing this:\n  inv_pair m\n  map_of1 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  inv_pair ?m \\<Longrightarrow>\n  dom (map_of1 ?m) \\<inter> dom (map_of2 ?m) = {}\n  ?f \\<subseteq>\\<^sub>m ?g \\<Longrightarrow> dom ?f \\<subseteq> dom ?g\n\ngoal (1 subgoal):\n 1. dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n    dom (map_of2 m) =\n    {}", "by fastforce"], ["proof (state)\nthis:\n  dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have \"inv_pair ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair (snd (run_state (lookup1 (key2 k)) m))", "using 3 inv_pair_lookup1 surjective_pairing"], ["proof (prove)\nusing this:\n  inv_pair m\n  \\<lbrakk>run_state (lookup1 ?k) ?m = (?v, ?m'); inv_pair ?m\\<rbrakk>\n  \\<Longrightarrow> inv_pair ?m'\n  ?t = (fst ?t, snd ?t)\n\ngoal (1 subgoal):\n 1. inv_pair (snd (run_state (lookup1 (key2 k)) m))", "by metis"], ["proof (state)\nthis:\n  inv_pair (snd (run_state (lookup1 (key2 k)) m))\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "ultimately"], ["proof (chain)\npicking this:\n  map_of1 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n  dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n  inv_pair (snd (run_state (lookup1 (key2 k)) m))", "have \"pair.map_of ?m \\<subseteq>\\<^sub>m pair.map_of m\""], ["proof (prove)\nusing this:\n  map_of1 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n  dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n  inv_pair (snd (run_state (lookup1 (key2 k)) m))\n\ngoal (1 subgoal):\n 1. pair.map_of (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n    pair.map_of m", "apply (subst map_of_eq_pair[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup1 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (lookup1 (key2 k)) m))\n 2. \\<lbrakk>map_of1\n              (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup1 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (lookup1 (key2 k)) m)) ++\n                      map_of2\n                       (snd (run_state (lookup1 (key2 k))\n                              m)) \\<subseteq>\\<^sub>m\n                      pair.map_of m", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup1 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (lookup1 (key2 k)) m)) ++\n                      map_of2\n                       (snd (run_state (lookup1 (key2 k))\n                              m)) \\<subseteq>\\<^sub>m\n                      pair.map_of m\n 2. \\<lbrakk>map_of1\n              (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup1 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (lookup1 (key2 k)) m))", "apply (subst map_of_eq_pair[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup1 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair m\n 2. \\<lbrakk>map_of1\n              (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup1 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (lookup1 (key2 k)) m)) ++\n                      map_of2\n                       (snd (run_state (lookup1 (key2 k))\n                              m)) \\<subseteq>\\<^sub>m\n                      map_of1 m ++ map_of2 m\n 3. \\<lbrakk>map_of1\n              (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n             map_of1 m;\n     map_of2 (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (lookup1 (key2 k)) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     inv_pair (snd (run_state (lookup1 (key2 k)) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (lookup1 (key2 k)) m))", "by (auto intro: 3 map_add_mono)"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "}"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "ultimately"], ["proof (chain)\npicking this:\n  pair.map_of (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m\n  pair.map_of (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m", "show ?case"], ["proof (prove)\nusing this:\n  pair.map_of (snd (run_state (lookup2 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m\n  pair.map_of (snd (run_state (lookup1 (key2 k)) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m\n\ngoal (1 subgoal):\n 1. pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n    pair.map_of m", "by (auto\n        split:if_split prod.split\n        simp: Let_def lookup_pair_def State_Monad.bind_def State_Monad.run_state_return dest: get_state intro: map_le_refl\n        )"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "case prems: (4 m k v)"], ["proof (state)\nthis:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "let ?m1 = \"snd (State_Monad.run_state (update1 (key2 k) v) m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "let ?m2 = \"snd (State_Monad.run_state (update2 (key2 k) v) m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "from prems"], ["proof (chain)\npicking this:\n  inv_pair m", "have disjoint: \"dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\""], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. dom (map_of1 m) \\<inter> dom (map_of2 m) = {}", "by (simp add: inv_pair_domD)"], ["proof (state)\nthis:\n  dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n    pair.map_of m(k \\<mapsto> v)", "apply (auto\n        intro: map_le_refl dest: get_state\n        split: prod.split\n        simp: Let_def update_pair_def State_Monad.bind_def State_Monad.run_state_return\n        )"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "proof goal_cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "case (1 m')"], ["proof (state)\nthis:\n  run_state get_k1 m = (key1 k, m')\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "then"], ["proof (chain)\npicking this:\n  run_state get_k1 m = (key1 k, m')", "have \"m' = m\""], ["proof (prove)\nusing this:\n  run_state get_k1 m = (key1 k, m')\n\ngoal (1 subgoal):\n 1. m' = m", "by (rule get_state)"], ["proof (state)\nthis:\n  m' = m\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from 1 prems"], ["proof (chain)\npicking this:\n  run_state get_k1 m = (key1 k, m')\n  inv_pair m", "have \"map_of1 ?m1 \\<subseteq>\\<^sub>m map_of1 m(k \\<mapsto> v)\""], ["proof (prove)\nusing this:\n  run_state get_k1 m = (key1 k, m')\n  inv_pair m\n\ngoal (1 subgoal):\n 1. map_of1 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n    map_of1 m(k \\<mapsto> v)", "by (smt inv_pair_P_D map_le_def map_of1_def surjective_pairing domIff\n          fst_conv fun_upd_apply injective update_correct update_keys\n          )"], ["proof (state)\nthis:\n  map_of1 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of1 m(k \\<mapsto> v)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  map_of1 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of1 m(k \\<mapsto> v)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from prems"], ["proof (chain)\npicking this:\n  inv_pair m", "have \"map_of2 ?m1 \\<subseteq>\\<^sub>m map_of2 m\""], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n    map_of2 m", "by (smt domIff inv_pair_P_D update_correct update_keys map_le_def map_of2_def surjective_pairing)"], ["proof (state)\nthis:\n  map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from prems"], ["proof (chain)\npicking this:\n  inv_pair m", "have \"dom (map_of1 ?m1) \\<inter> dom (map_of2 m) = {}\""], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n    dom (map_of2 m) =\n    {}", "by (smt inv_pair_P_D[OF \\<open>inv_pair m\\<close>] domIff Int_emptyI eq_snd_iff inv_pair_neq \n          map_of1_def map_of2_def update_keys(1)\n          )"], ["proof (state)\nthis:\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from 1 prems"], ["proof (chain)\npicking this:\n  run_state get_k1 m = (key1 k, m')\n  inv_pair m", "have \"k \\<notin> dom (map_of2 m)\""], ["proof (prove)\nusing this:\n  run_state get_k1 m = (key1 k, m')\n  inv_pair m\n\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of2 m)", "using inv_pair_neq map_of2_def"], ["proof (prove)\nusing this:\n  run_state get_k1 m = (key1 k, m')\n  inv_pair m\n  \\<lbrakk>inv_pair ?m;\n   fst (run_state get_k1 ?m) = fst (run_state get_k2 ?m)\\<rbrakk>\n  \\<Longrightarrow> False\n  map_of2 ?m ?k =\n  (if key1 ?k = fst (run_state get_k2 ?m) then mem2.map_of ?m (key2 ?k)\n   else None)\n\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of2 m)", "by fastforce"], ["proof (state)\nthis:\n  k \\<notin> dom (map_of2 m)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  k \\<notin> dom (map_of2 m)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from 1 prems"], ["proof (chain)\npicking this:\n  run_state get_k1 m = (key1 k, m')\n  inv_pair m", "have \"inv_pair ?m1\""], ["proof (prove)\nusing this:\n  run_state get_k1 m = (key1 k, m')\n  inv_pair m\n\ngoal (1 subgoal):\n 1. inv_pair (snd (run_state (update1 (key2 k) v) m))", "using inv_pair_update1 fst_conv surjective_pairing"], ["proof (prove)\nusing this:\n  run_state get_k1 m = (key1 k, m')\n  inv_pair m\n  \\<lbrakk>run_state (update1 (key2 ?k) ?v) ?m = (?v', ?m'); inv_pair ?m;\n   fst (run_state get_k1 ?m) = key1 ?k\\<rbrakk>\n  \\<Longrightarrow> inv_pair ?m'\n  fst (?x1.0, ?x2.0) = ?x1.0\n  ?t = (fst ?t, snd ?t)\n\ngoal (1 subgoal):\n 1. inv_pair (snd (run_state (update1 (key2 k) v) m))", "by metis"], ["proof (state)\nthis:\n  inv_pair (snd (run_state (update1 (key2 k) v) m))\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       run_state get_k1 m = (key1 k, x2) \\<Longrightarrow>\n       pair.map_of\n        (snd (run_state (update1 (key2 k) v) x2)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 3. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "ultimately"], ["proof (chain)\npicking this:\n  map_of1 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of1 m(k \\<mapsto> v)\n  map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n  k \\<notin> dom (map_of2 m)\n  inv_pair (snd (run_state (update1 (key2 k) v) m))", "show \"pair.map_of (snd (State_Monad.run_state (update1 (key2 k) v) m')) \\<subseteq>\\<^sub>m pair.map_of m(k \\<mapsto> v)\""], ["proof (prove)\nusing this:\n  map_of1 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of1 m(k \\<mapsto> v)\n  map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n  k \\<notin> dom (map_of2 m)\n  inv_pair (snd (run_state (update1 (key2 k) v) m))\n\ngoal (1 subgoal):\n 1. pair.map_of\n     (snd (run_state (update1 (key2 k) v) m')) \\<subseteq>\\<^sub>m\n    pair.map_of m(k \\<mapsto> v)", "unfolding \\<open>m' = m\\<close>"], ["proof (prove)\nusing this:\n  map_of1 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of1 m(k \\<mapsto> v)\n  map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n  k \\<notin> dom (map_of2 m)\n  inv_pair (snd (run_state (update1 (key2 k) v) m))\n\ngoal (1 subgoal):\n 1. pair.map_of (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n    pair.map_of m(k \\<mapsto> v)", "using disjoint"], ["proof (prove)\nusing this:\n  map_of1 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of1 m(k \\<mapsto> v)\n  map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of2 m\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n  dom (map_of2 m) =\n  {}\n  k \\<notin> dom (map_of2 m)\n  inv_pair (snd (run_state (update1 (key2 k) v) m))\n  dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\n\ngoal (1 subgoal):\n 1. pair.map_of (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n    pair.map_of m(k \\<mapsto> v)", "apply (subst map_of_eq_pair[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of1 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     k \\<notin> dom (map_of2 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update1 (key2 k) v) m))\n 2. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of1 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     k \\<notin> dom (map_of2 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update1 (key2 k) v) m)) ++\n                      map_of2\n                       (snd (run_state (update1 (key2 k) v)\n                              m)) \\<subseteq>\\<^sub>m\n                      pair.map_of m(k \\<mapsto> v)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of1 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     k \\<notin> dom (map_of2 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update1 (key2 k) v) m)) ++\n                      map_of2\n                       (snd (run_state (update1 (key2 k) v)\n                              m)) \\<subseteq>\\<^sub>m\n                      pair.map_of m(k \\<mapsto> v)\n 2. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of1 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     k \\<notin> dom (map_of2 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update1 (key2 k) v) m))", "apply (subst map_of_eq_pair[symmetric], rule prems)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of1 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     k \\<notin> dom (map_of2 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update1 (key2 k) v) m)) ++\n                      map_of2\n                       (snd (run_state (update1 (key2 k) v)\n                              m)) \\<subseteq>\\<^sub>m\n                      (map_of1 m ++ map_of2 m)(k \\<mapsto> v)\n 2. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of1 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     k \\<notin> dom (map_of2 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update1 (key2 k) v) m))", "apply (subst map_add_upd2[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of1 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     k \\<notin> dom (map_of2 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\n 2. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of1 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     k \\<notin> dom (map_of2 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> k \\<notin> dom (map_of2 m)\n 3. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of1 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     k \\<notin> dom (map_of2 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update1 (key2 k) v) m)) ++\n                      map_of2\n                       (snd (run_state (update1 (key2 k) v)\n                              m)) \\<subseteq>\\<^sub>m\n                      map_of1 m(k \\<mapsto> v) ++ map_of2 m\n 4. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of1 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of2 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m) =\n     {};\n     k \\<notin> dom (map_of2 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update1 (key2 k) v) m))", "by (auto intro: map_add_mono)"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (update1 (key2 k) v) m')) \\<subseteq>\\<^sub>m\n  pair.map_of m(k \\<mapsto> v)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "case (2 k1 m' m'')"], ["proof (state)\nthis:\n  key1 k \\<noteq> k1\n  run_state get_k2 m' = (key1 k, m'')\n  run_state get_k1 m = (k1, m')\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "then"], ["proof (chain)\npicking this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m' = (key1 k, m'')\n  run_state get_k1 m = (k1, m')", "have \"m' = m\" \"m'' = m\""], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m' = (key1 k, m'')\n  run_state get_k1 m = (k1, m')\n\ngoal (1 subgoal):\n 1. m' = m &&& m'' = m", "by (auto dest: get_state)"], ["proof (state)\nthis:\n  m' = m\n  m'' = m\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from 2 prems"], ["proof (chain)\npicking this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m' = (key1 k, m'')\n  run_state get_k1 m = (k1, m')\n  inv_pair m", "have \"map_of2 ?m2 \\<subseteq>\\<^sub>m map_of2 m(k \\<mapsto> v)\""], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m' = (key1 k, m'')\n  run_state get_k1 m = (k1, m')\n  inv_pair m\n\ngoal (1 subgoal):\n 1. map_of2 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n    map_of2 m(k \\<mapsto> v)", "unfolding \\<open>m' = m\\<close> \\<open>m'' = m\\<close>"], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m = (key1 k, m)\n  run_state get_k1 m = (k1, m)\n  inv_pair m\n\ngoal (1 subgoal):\n 1. map_of2 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n    map_of2 m(k \\<mapsto> v)", "by (smt inv_pair_P_D map_le_def map_of2_def surjective_pairing domIff\n          fst_conv fun_upd_apply injective update_correct update_keys\n          )"], ["proof (state)\nthis:\n  map_of2 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of2 m(k \\<mapsto> v)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  map_of2 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of2 m(k \\<mapsto> v)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from prems"], ["proof (chain)\npicking this:\n  inv_pair m", "have \"map_of1 ?m2 \\<subseteq>\\<^sub>m map_of1 m\""], ["proof (prove)\nusing this:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n    map_of1 m", "by (smt domIff inv_pair_P_D update_correct update_keys map_le_def map_of1_def surjective_pairing)"], ["proof (state)\nthis:\n  map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from 2"], ["proof (chain)\npicking this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m' = (key1 k, m'')\n  run_state get_k1 m = (k1, m')", "have \"dom (map_of1 ?m2) \\<inter> dom (map_of2 m(k \\<mapsto> v)) = {}\""], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m' = (key1 k, m'')\n  run_state get_k1 m = (k1, m')\n\ngoal (1 subgoal):\n 1. dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n    dom (map_of2 m(k \\<mapsto> v)) =\n    {}", "unfolding \\<open>m' = m\\<close>"], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m = (key1 k, m'')\n  run_state get_k1 m = (k1, m)\n\ngoal (1 subgoal):\n 1. dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n    dom (map_of2 m(k \\<mapsto> v)) =\n    {}", "by (smt domIff \\<open>map_of1 ?m2 \\<subseteq>\\<^sub>m map_of1 m\\<close> disjoint_iff_not_equal fst_conv fun_upd_apply\n          map_le_def map_of1_def map_of2_def\n          )"], ["proof (state)\nthis:\n  dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n  dom (map_of2 m(k \\<mapsto> v)) =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n  dom (map_of2 m(k \\<mapsto> v)) =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from 2 prems"], ["proof (chain)\npicking this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m' = (key1 k, m'')\n  run_state get_k1 m = (k1, m')\n  inv_pair m", "have \"inv_pair ?m2\""], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m' = (key1 k, m'')\n  run_state get_k1 m = (k1, m')\n  inv_pair m\n\ngoal (1 subgoal):\n 1. inv_pair (snd (run_state (update2 (key2 k) v) m))", "unfolding \\<open>m' = m\\<close>"], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m = (key1 k, m'')\n  run_state get_k1 m = (k1, m)\n  inv_pair m\n\ngoal (1 subgoal):\n 1. inv_pair (snd (run_state (update2 (key2 k) v) m))", "using inv_pair_update2 fst_conv surjective_pairing"], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  run_state get_k2 m = (key1 k, m'')\n  run_state get_k1 m = (k1, m)\n  inv_pair m\n  \\<lbrakk>run_state (update2 (key2 ?k) ?v) ?m = (?v', ?m'); inv_pair ?m;\n   fst (run_state get_k2 ?m) = key1 ?k\\<rbrakk>\n  \\<Longrightarrow> inv_pair ?m'\n  fst (?x1.0, ?x2.0) = ?x1.0\n  ?t = (fst ?t, snd ?t)\n\ngoal (1 subgoal):\n 1. inv_pair (snd (run_state (update2 (key2 k) v) m))", "by metis"], ["proof (state)\nthis:\n  inv_pair (snd (run_state (update2 (key2 k) v) m))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x2a.\n       \\<lbrakk>key1 k \\<noteq> x1; run_state get_k2 x2 = (key1 k, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update2 (key2 k) v)\n                                 x2a)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)\n 2. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "ultimately"], ["proof (chain)\npicking this:\n  map_of2 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of2 m(k \\<mapsto> v)\n  map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n  dom (map_of2 m(k \\<mapsto> v)) =\n  {}\n  inv_pair (snd (run_state (update2 (key2 k) v) m))", "show \"pair.map_of (snd (State_Monad.run_state (update2 (key2 k) v) m'')) \\<subseteq>\\<^sub>m pair.map_of m(k \\<mapsto> v)\""], ["proof (prove)\nusing this:\n  map_of2 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of2 m(k \\<mapsto> v)\n  map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n  dom (map_of2 m(k \\<mapsto> v)) =\n  {}\n  inv_pair (snd (run_state (update2 (key2 k) v) m))\n\ngoal (1 subgoal):\n 1. pair.map_of\n     (snd (run_state (update2 (key2 k) v) m'')) \\<subseteq>\\<^sub>m\n    pair.map_of m(k \\<mapsto> v)", "unfolding \\<open>m' = m\\<close> \\<open>m'' = m\\<close>"], ["proof (prove)\nusing this:\n  map_of2 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of2 m(k \\<mapsto> v)\n  map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n  dom (map_of2 m(k \\<mapsto> v)) =\n  {}\n  inv_pair (snd (run_state (update2 (key2 k) v) m))\n\ngoal (1 subgoal):\n 1. pair.map_of (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n    pair.map_of m(k \\<mapsto> v)", "apply (subst map_of_eq_pair[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of2\n              (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m(k \\<mapsto> v)) =\n     {};\n     inv_pair (snd (run_state (update2 (key2 k) v) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update2 (key2 k) v) m))\n 2. \\<lbrakk>map_of2\n              (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m(k \\<mapsto> v)) =\n     {};\n     inv_pair (snd (run_state (update2 (key2 k) v) m))\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update2 (key2 k) v) m)) ++\n                      map_of2\n                       (snd (run_state (update2 (key2 k) v)\n                              m)) \\<subseteq>\\<^sub>m\n                      pair.map_of m(k \\<mapsto> v)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of2\n              (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m(k \\<mapsto> v)) =\n     {};\n     inv_pair (snd (run_state (update2 (key2 k) v) m))\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update2 (key2 k) v) m)) ++\n                      map_of2\n                       (snd (run_state (update2 (key2 k) v)\n                              m)) \\<subseteq>\\<^sub>m\n                      pair.map_of m(k \\<mapsto> v)\n 2. \\<lbrakk>map_of2\n              (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m(k \\<mapsto> v)) =\n     {};\n     inv_pair (snd (run_state (update2 (key2 k) v) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update2 (key2 k) v) m))", "apply (subst map_of_eq_pair[symmetric], rule prems)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of2\n              (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m(k \\<mapsto> v)) =\n     {};\n     inv_pair (snd (run_state (update2 (key2 k) v) m))\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update2 (key2 k) v) m)) ++\n                      map_of2\n                       (snd (run_state (update2 (key2 k) v)\n                              m)) \\<subseteq>\\<^sub>m\n                      (map_of1 m ++ map_of2 m)(k \\<mapsto> v)\n 2. \\<lbrakk>map_of2\n              (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m(k \\<mapsto> v)) =\n     {};\n     inv_pair (snd (run_state (update2 (key2 k) v) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update2 (key2 k) v) m))", "apply (subst map_add_upd[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of2\n              (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m(k \\<mapsto> v)) =\n     {};\n     inv_pair (snd (run_state (update2 (key2 k) v) m))\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update2 (key2 k) v) m)) ++\n                      map_of2\n                       (snd (run_state (update2 (key2 k) v)\n                              m)) \\<subseteq>\\<^sub>m\n                      map_of1 m ++ map_of2 m(k \\<mapsto> v)\n 2. \\<lbrakk>map_of2\n              (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of1 (snd (run_state (update2 (key2 k) v) m)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update2 (key2 k) v) m))) \\<inter>\n     dom (map_of2 m(k \\<mapsto> v)) =\n     {};\n     inv_pair (snd (run_state (update2 (key2 k) v) m))\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update2 (key2 k) v) m))", "by (rule map_add_mono)"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (update2 (key2 k) v) m'')) \\<subseteq>\\<^sub>m\n  pair.map_of m(k \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "case (3 k1 m1 k2 m2 m3)"], ["proof (state)\nthis:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "then"], ["proof (chain)\npicking this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)", "have \"m1 = m\" \"m2 = m\""], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)\n\ngoal (1 subgoal):\n 1. m1 = m &&& m2 = m", "by (auto dest: get_state)"], ["proof (state)\nthis:\n  m1 = m\n  m2 = m\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "let ?m3 = \"snd (State_Monad.run_state (update1 (key2 k) v) m3)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from 3 prems"], ["proof (chain)\npicking this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)\n  inv_pair m", "have \"map_of1 ?m3 \\<subseteq>\\<^sub>m map_of2 m(k \\<mapsto> v)\""], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)\n  inv_pair m\n\ngoal (1 subgoal):\n 1. map_of1 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n    map_of2 m(k \\<mapsto> v)", "unfolding \\<open>m2 = m\\<close>"], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m = ((), m3)\n  run_state get_k2 m1 = (k2, m)\n  run_state get_k1 m = (k1, m1)\n  inv_pair m\n\ngoal (1 subgoal):\n 1. map_of1 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n    map_of2 m(k \\<mapsto> v)", "by (smt inv_pair_P_D map_le_def map_of1_def surjective_pairing domIff\n          fst_conv fun_upd_apply injective\n          inv_pair_move12 move12_correct move12_keys update_correct update_keys\n          )"], ["proof (state)\nthis:\n  map_of1 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of2 m(k \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  map_of1 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of2 m(k \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "have \"map_of2 ?m3 \\<subseteq>\\<^sub>m map_of1 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n    map_of1 m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n    map_of1 m", "from prems 3"], ["proof (chain)\npicking this:\n  inv_pair m\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)", "have \"P m\" \"P m3\""], ["proof (prove)\nusing this:\n  inv_pair m\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)\n\ngoal (1 subgoal):\n 1. P m &&& P m3", "unfolding \\<open>m1 = m\\<close> \\<open>m2 = m\\<close>"], ["proof (prove)\nusing this:\n  inv_pair m\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m = ((), m3)\n  run_state get_k2 m = (k2, m)\n  run_state get_k1 m = (k1, m)\n\ngoal (1 subgoal):\n 1. P m &&& P m3", "using inv_pair_P_D[OF prems]"], ["proof (prove)\nusing this:\n  inv_pair m\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m = ((), m3)\n  run_state get_k2 m = (k2, m)\n  run_state get_k1 m = (k1, m)\n  P m\n\ngoal (1 subgoal):\n 1. P m &&& P m3", "by (auto elim: lift_p_P[OF move12_inv])"], ["proof (state)\nthis:\n  P m\n  P m3\n\ngoal (1 subgoal):\n 1. map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n    map_of1 m", "from 3(3)[unfolded \\<open>m2 = m\\<close>]"], ["proof (chain)\npicking this:\n  run_state (move12 (key1 k)) m = ((), m3)", "have \"mem2.map_of ?m3 \\<subseteq>\\<^sub>m mem1.map_of m\""], ["proof (prove)\nusing this:\n  run_state (move12 (key1 k)) m = ((), m3)\n\ngoal (1 subgoal):\n 1. mem2.map_of\n     (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n    mem1.map_of m", "by - (erule map_le_trans[OF update_correct(3)[OF \\<open>P m3\\<close>] move12_correct(2)[OF \\<open>P m\\<close>]])"], ["proof (state)\nthis:\n  mem2.map_of (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  mem1.map_of m\n\ngoal (1 subgoal):\n 1. map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n    map_of1 m", "with 3 prems"], ["proof (chain)\npicking this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)\n  inv_pair m\n  mem2.map_of (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  mem1.map_of m", "show ?thesis"], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)\n  inv_pair m\n  mem2.map_of (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  mem1.map_of m\n\ngoal (1 subgoal):\n 1. map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n    map_of1 m", "unfolding \\<open>m1 = m\\<close> \\<open>m2 = m\\<close> map_le_def map_of2_def"], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m = ((), m3)\n  run_state get_k2 m = (k2, m)\n  run_state get_k1 m = (k1, m)\n  inv_pair m\n  \\<forall>a\\<in>dom (mem2.map_of\n                       (snd (run_state (update1 (key2 k) v) m3))).\n     mem2.map_of (snd (run_state (update1 (key2 k) v) m3)) a =\n     mem1.map_of m a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom (\\<lambda>ka.\n                           if key1 ka =\n                              fst (run_state get_k2\n                                    (snd\n(run_state (update1 (key2 k) v) m3)))\n                           then mem2.map_of\n                                 (snd (run_state (update1 (key2 k) v) m3))\n                                 (key2 ka)\n                           else None).\n       (if key1 a =\n           fst (run_state get_k2 (snd (run_state (update1 (key2 k) v) m3)))\n        then mem2.map_of (snd (run_state (update1 (key2 k) v) m3)) (key2 a)\n        else None) =\n       map_of1 m a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y.\n       \\<lbrakk>key1 k \\<noteq> k1; key1 k \\<noteq> k2;\n        run_state (move12 (key1 k)) m = ((), m3);\n        run_state get_k2 m = (k2, m); run_state get_k1 m = (k1, m);\n        inv_pair m;\n        \\<forall>a\\<in>dom (mem2.map_of\n                             (snd (run_state (update1 (key2 k) v) m3))).\n           mem2.map_of (snd (run_state (update1 (key2 k) v) m3)) a =\n           mem1.map_of m a;\n        mem2.map_of (snd (run_state (update1 (key2 k) v) m3)) (key2 a) =\n        Some y;\n        key1 a =\n        fst (run_state get_k2\n              (snd (run_state (update1 (key2 k) v) m3)))\\<rbrakk>\n       \\<Longrightarrow> Some y = map_of1 m a", "apply (frule move12_keys(2), simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y.\n       \\<lbrakk>key1 k \\<noteq> k1; key1 k \\<noteq> k2;\n        run_state (move12 (key1 k)) m = ((), m3);\n        run_state get_k2 m = (k2, m); run_state get_k1 m = (k1, m);\n        inv_pair m;\n        \\<forall>a\\<in>dom (mem2.map_of\n                             (snd (run_state (update1 (key2 k) v) m3))).\n           mem2.map_of (snd (run_state (update1 (key2 k) v) m3)) a =\n           mem1.map_of m a;\n        mem2.map_of (snd (run_state (update1 (key2 k) v) m3)) (key2 a) =\n        Some y;\n        key1 a =\n        fst (run_state get_k2 (snd (run_state (update1 (key2 k) v) m3)));\n        fst (run_state get_k2 m3) = k1\\<rbrakk>\n       \\<Longrightarrow> Some y = map_of1 m a", "by (metis\n            domI inv_pair_def map_of1_def surjective_pairing\n            inv_pair_move12 move12_keys(2) update_keys(2)\n            )"], ["proof (state)\nthis:\n  map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of1 m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of1 m\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of1 m\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from prems 3"], ["proof (chain)\npicking this:\n  inv_pair m\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)", "have \"dom (map_of1 ?m3) \\<inter> dom (map_of1 m) = {}\""], ["proof (prove)\nusing this:\n  inv_pair m\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)\n\ngoal (1 subgoal):\n 1. dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n    dom (map_of1 m) =\n    {}", "unfolding \\<open>m1 = m\\<close> \\<open>m2 = m\\<close>"], ["proof (prove)\nusing this:\n  inv_pair m\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m = ((), m3)\n  run_state get_k2 m = (k2, m)\n  run_state get_k1 m = (k1, m)\n\ngoal (1 subgoal):\n 1. dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n    dom (map_of1 m) =\n    {}", "by (smt inv_pair_P_D disjoint_iff_not_equal map_of1_def surjective_pairing domIff\n          fst_conv inv_pair_move12 move12_keys update_keys\n          )"], ["proof (state)\nthis:\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n  dom (map_of1 m) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n  dom (map_of1 m) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from 3"], ["proof (chain)\npicking this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)", "have \"k \\<notin> dom (map_of1 m)\""], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)\n\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of1 m)", "by (simp add: domIff map_of1_def)"], ["proof (state)\nthis:\n  k \\<notin> dom (map_of1 m)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  k \\<notin> dom (map_of1 m)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "from 3 prems"], ["proof (chain)\npicking this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)\n  inv_pair m", "have \"inv_pair ?m3\""], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m2 = ((), m3)\n  run_state get_k2 m1 = (k2, m2)\n  run_state get_k1 m = (k1, m1)\n  inv_pair m\n\ngoal (1 subgoal):\n 1. inv_pair (snd (run_state (update1 (key2 k) v) m3))", "unfolding \\<open>m2 = m\\<close>"], ["proof (prove)\nusing this:\n  key1 k \\<noteq> k1\n  key1 k \\<noteq> k2\n  run_state (move12 (key1 k)) m = ((), m3)\n  run_state get_k2 m1 = (k2, m)\n  run_state get_k1 m = (k1, m1)\n  inv_pair m\n\ngoal (1 subgoal):\n 1. inv_pair (snd (run_state (update1 (key2 k) v) m3))", "by (metis inv_pair_move12 inv_pair_update1 move12_keys(1) fst_conv surjective_pairing)"], ["proof (state)\nthis:\n  inv_pair (snd (run_state (update1 (key2 k) v) m3))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x2b.\n       \\<lbrakk>key1 k \\<noteq> x1; key1 k \\<noteq> x1a;\n        run_state (move12 (key1 k)) x2a = ((), x2b);\n        run_state get_k2 x2 = (x1a, x2a);\n        run_state get_k1 m = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pair.map_of\n                          (snd (run_state (update1 (key2 k) v)\n                                 x2b)) \\<subseteq>\\<^sub>m\n                         pair.map_of m(k \\<mapsto> v)", "ultimately"], ["proof (chain)\npicking this:\n  map_of1 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of2 m(k \\<mapsto> v)\n  map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n  dom (map_of1 m) =\n  {}\n  k \\<notin> dom (map_of1 m)\n  inv_pair (snd (run_state (update1 (key2 k) v) m3))", "show ?case"], ["proof (prove)\nusing this:\n  map_of1 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of2 m(k \\<mapsto> v)\n  map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n  dom (map_of1 m) =\n  {}\n  k \\<notin> dom (map_of1 m)\n  inv_pair (snd (run_state (update1 (key2 k) v) m3))\n\ngoal (1 subgoal):\n 1. pair.map_of\n     (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n    pair.map_of m(k \\<mapsto> v)", "unfolding \\<open>m1 = m\\<close> \\<open>m2 = m\\<close>"], ["proof (prove)\nusing this:\n  map_of1 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of2 m(k \\<mapsto> v)\n  map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n  dom (map_of1 m) =\n  {}\n  k \\<notin> dom (map_of1 m)\n  inv_pair (snd (run_state (update1 (key2 k) v) m3))\n\ngoal (1 subgoal):\n 1. pair.map_of\n     (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n    pair.map_of m(k \\<mapsto> v)", "using disjoint"], ["proof (prove)\nusing this:\n  map_of1 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of2 m(k \\<mapsto> v)\n  map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  map_of1 m\n  dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n  dom (map_of1 m) =\n  {}\n  k \\<notin> dom (map_of1 m)\n  inv_pair (snd (run_state (update1 (key2 k) v) m3))\n  dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\n\ngoal (1 subgoal):\n 1. pair.map_of\n     (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n    pair.map_of m(k \\<mapsto> v)", "apply (subst map_of_eq_pair[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update1 (key2 k) v) m3))\n 2. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update1 (key2 k) v) m3)) ++\n                      map_of2\n                       (snd (run_state (update1 (key2 k) v)\n                              m3)) \\<subseteq>\\<^sub>m\n                      pair.map_of m(k \\<mapsto> v)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update1 (key2 k) v) m3)) ++\n                      map_of2\n                       (snd (run_state (update1 (key2 k) v)\n                              m3)) \\<subseteq>\\<^sub>m\n                      pair.map_of m(k \\<mapsto> v)\n 2. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update1 (key2 k) v) m3))", "apply (subst map_of_eq_pair[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair m\n 2. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update1 (key2 k) v) m3)) ++\n                      map_of2\n                       (snd (run_state (update1 (key2 k) v)\n                              m3)) \\<subseteq>\\<^sub>m\n                      (map_of1 m ++ map_of2 m)(k \\<mapsto> v)\n 3. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update1 (key2 k) v) m3))", "apply (rule prems)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update1 (key2 k) v) m3)) ++\n                      map_of2\n                       (snd (run_state (update1 (key2 k) v)\n                              m3)) \\<subseteq>\\<^sub>m\n                      (map_of1 m ++ map_of2 m)(k \\<mapsto> v)\n 2. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update1 (key2 k) v) m3))", "apply (subst (2) map_add_comm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\n 2. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update1 (key2 k) v) m3)) ++\n                      map_of2\n                       (snd (run_state (update1 (key2 k) v)\n                              m3)) \\<subseteq>\\<^sub>m\n                      (map_of2 m ++ map_of1 m)(k \\<mapsto> v)\n 3. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update1 (key2 k) v) m3))", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update1 (key2 k) v) m3)) ++\n                      map_of2\n                       (snd (run_state (update1 (key2 k) v)\n                              m3)) \\<subseteq>\\<^sub>m\n                      (map_of2 m ++ map_of1 m)(k \\<mapsto> v)\n 2. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update1 (key2 k) v) m3))\n 3. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> dom (map_of1 m) \\<inter> dom (map_of2 m) = {}", "apply (subst map_add_upd2[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> dom (map_of2 m) \\<inter> dom (map_of1 m) = {}\n 2. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> k \\<notin> dom (map_of1 m)\n 3. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> map_of1 (snd (run_state (update1 (key2 k) v) m3)) ++\n                      map_of2\n                       (snd (run_state (update1 (key2 k) v)\n                              m3)) \\<subseteq>\\<^sub>m\n                      map_of2 m(k \\<mapsto> v) ++ map_of1 m\n 4. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> inv_pair (snd (run_state (update1 (key2 k) v) m3))\n 5. \\<lbrakk>map_of1\n              (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n             map_of2 m(k \\<mapsto> v);\n     map_of2 (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n     map_of1 m;\n     dom (map_of1 (snd (run_state (update1 (key2 k) v) m3))) \\<inter>\n     dom (map_of1 m) =\n     {};\n     k \\<notin> dom (map_of1 m);\n     inv_pair (snd (run_state (update1 (key2 k) v) m3));\n     dom (map_of1 m) \\<inter> dom (map_of2 m) = {}\\<rbrakk>\n    \\<Longrightarrow> dom (map_of1 m) \\<inter> dom (map_of2 m) = {}", "apply (auto intro: map_add_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (update1 (key2 k) v) m3)) \\<subseteq>\\<^sub>m\n  pair.map_of m(k \\<mapsto> v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m(k \\<mapsto> v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emptyI:\n  assumes \"inv_pair m\" \"mem1.map_of m \\<subseteq>\\<^sub>m Map.empty\" \"mem2.map_of m \\<subseteq>\\<^sub>m Map.empty\"\n  shows \"pair.map_of m \\<subseteq>\\<^sub>m Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.map_of m \\<subseteq>\\<^sub>m Map.empty", "using assms"], ["proof (prove)\nusing this:\n  inv_pair m\n  mem1.map_of m \\<subseteq>\\<^sub>m Map.empty\n  mem2.map_of m \\<subseteq>\\<^sub>m Map.empty\n\ngoal (1 subgoal):\n 1. pair.map_of m \\<subseteq>\\<^sub>m Map.empty", "by (auto simp: map_of1_def map_of2_def map_le_def map_of_eq_pair[symmetric])"], ["", "end"], ["", "(* Pair Mem *)"], ["", "datatype ('k, 'v) pair_storage = Pair_Storage 'k 'k 'v 'v"], ["", "context mem_correct_empty\nbegin"], ["", "context\n  fixes key :: \"'a \\<Rightarrow> 'k\"\nbegin"], ["", "text \\<open>We assume that look-ups happen on the older row, so it is biased towards the second entry.\\<close>"], ["", "definition\n  \"lookup_pair k =\n    State (\\<lambda> mem.\n    (\n      case mem of Pair_Storage k1 k2 m1 m2 \\<Rightarrow> let k' = key k in\n        if k' = k2 then case State_Monad.run_state (lookup k) m2 of (v, m) \\<Rightarrow> (v, Pair_Storage k1 k2 m1 m)\n        else if k' = k1 then case State_Monad.run_state (lookup k) m1 of (v, m) \\<Rightarrow> (v, Pair_Storage k1 k2 m m2)\n        else (None, mem)\n    )\n    )\n  \""], ["", "text \\<open>We assume that updates happen on the newer row, so it is biased towards the first entry.\\<close>"], ["", "definition\n  \"update_pair k v =\n    State (\\<lambda> mem.\n    (\n      case mem of Pair_Storage k1 k2 m1 m2 \\<Rightarrow> let k' = key k in\n        if k' = k1 then case State_Monad.run_state (update k v) m1 of (_, m) \\<Rightarrow> ((), Pair_Storage k1 k2 m m2)\n        else if k' = k2 then case State_Monad.run_state (update k v) m2 of (_, m) \\<Rightarrow> ((),Pair_Storage k1 k2 m1 m)\n        else case State_Monad.run_state (update k v) empty of (_, m) \\<Rightarrow> ((), Pair_Storage k' k1 m m1)\n    )\n    )\n  \""], ["", "interpretation pair: state_mem_defs lookup_pair update_pair"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition\n  \"inv_pair p = (case p of Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (map_of m1) \\<subseteq> {k1} \\<and> key ` dom (map_of m2) \\<subseteq> {k2} \\<and> k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n  )\""], ["", "lemma map_of_le_pair:\n  \"pair.map_of (Pair_Storage k1 k2 m1 m2) \\<subseteq>\\<^sub>m (map_of m1 ++ map_of m2)\"\n  if \"inv_pair (Pair_Storage k1 k2 m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage k1 k2 m1 m2) \\<subseteq>\\<^sub>m\n    local.map_of m1 ++ local.map_of m2", "using that"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage k1 k2 m1 m2) \\<subseteq>\\<^sub>m\n    local.map_of m1 ++ local.map_of m2", "unfolding pair.map_of_def"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        fst (run_state (lookup_pair k)\n              (Pair_Storage k1 k2 m1 m2))) \\<subseteq>\\<^sub>m\n    local.map_of m1 ++ local.map_of m2", "unfolding lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` {a. fst (run_state (lookup a) m1) \\<noteq> None}\n    \\<subseteq> {k1} \\<and>\n    key ` {a. fst (run_state (lookup a) m2) \\<noteq> None}\n    \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{a. fst (run_state\n                             (State\n                               (\\<lambda>mem.\n                                   case mem of\n                                   Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n                                     let k' = key a\n                                     in if k' = k2\n  then case run_state (lookup a) m2 of\n       (v, m) \\<Rightarrow> (v, Pair_Storage k1 k2 m1 m)\n  else if k' = k1\n       then case run_state (lookup a) m1 of\n            (v, m) \\<Rightarrow> (v, Pair_Storage k1 k2 m m2)\n       else (None, mem)))\n                             (Pair_Storage k1 k2 m1 m2)) \\<noteq>\n                       None}.\n       fst (run_state\n             (State\n               (\\<lambda>mem.\n                   case mem of\n                   Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n                     let k' = key a\n                     in if k' = k2\n                        then case run_state (lookup a) m2 of\n                             (v, m) \\<Rightarrow>\n                               (v, Pair_Storage k1 k2 m1 m)\n                        else if k' = k1\n                             then case run_state (lookup a) m1 of\n                                  (v, m) \\<Rightarrow>\n                                    (v, Pair_Storage k1 k2 m m2)\n                             else (None, mem)))\n             (Pair_Storage k1 k2 m1 m2)) =\n       (case fst (run_state (lookup a) m2) of\n        None \\<Rightarrow> fst (run_state (lookup a) m1)\n        | Some x \\<Rightarrow> Some x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y.\n       \\<lbrakk>key `\n                {a. \\<exists>y. fst (run_state (lookup a) m1) = Some y}\n                \\<subseteq> {k1};\n        key ` {a. \\<exists>y. fst (run_state (lookup a) m2) = Some y}\n        \\<subseteq> {k2};\n        k1 \\<noteq> k2; P m1; P m2;\n        fst (let k' = key a\n             in if k' = k2\n                then case run_state (lookup a) m2 of\n                     (v, m) \\<Rightarrow> (v, Pair_Storage k1 k2 m1 m)\n                else if k' = k1\n                     then case run_state (lookup a) m1 of\n                          (v, m) \\<Rightarrow> (v, Pair_Storage k1 k2 m m2)\n                     else (None, Pair_Storage k1 k2 m1 m2)) =\n        Some y\\<rbrakk>\n       \\<Longrightarrow> Some y =\n                         (case fst (run_state (lookup a) m2) of\n                          None \\<Rightarrow> fst (run_state (lookup a) m1)\n                          | Some x \\<Rightarrow> Some x)", "apply (auto 4 6 split: prod.split_asm if_split_asm option.split simp: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pair_le_map_of:\n  \"map_of m1 ++ map_of m2 \\<subseteq>\\<^sub>m pair.map_of (Pair_Storage k1 k2 m1 m2)\"\n  if \"inv_pair (Pair_Storage k1 k2 m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map_of m1 ++ local.map_of m2 \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage k1 k2 m1 m2)", "using that"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. local.map_of m1 ++ local.map_of m2 \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage k1 k2 m1 m2)", "unfolding pair.map_of_def"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. local.map_of m1 ++ local.map_of m2 \\<subseteq>\\<^sub>m\n    (\\<lambda>k. fst (run_state (lookup_pair k) (Pair_Storage k1 k2 m1 m2)))", "unfolding lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` {a. fst (run_state (lookup a) m1) \\<noteq> None}\n    \\<subseteq> {k1} \\<and>\n    key ` {a. fst (run_state (lookup a) m2) \\<noteq> None}\n    \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{a. (case fst (run_state (lookup a) m2) of\n                        None \\<Rightarrow> fst (run_state (lookup a) m1)\n                        | Some x \\<Rightarrow> Some x) \\<noteq>\n                       None}.\n       (case fst (run_state (lookup a) m2) of\n        None \\<Rightarrow> fst (run_state (lookup a) m1)\n        | Some x \\<Rightarrow> Some x) =\n       fst (run_state\n             (State\n               (\\<lambda>mem.\n                   case mem of\n                   Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n                     let k' = key a\n                     in if k' = k2\n                        then case run_state (lookup a) m2 of\n                             (v, m) \\<Rightarrow>\n                               (v, Pair_Storage k1 k2 m1 m)\n                        else if k' = k1\n                             then case run_state (lookup a) m1 of\n                                  (v, m) \\<Rightarrow>\n                                    (v, Pair_Storage k1 k2 m m2)\n                             else (None, mem)))\n             (Pair_Storage k1 k2 m1 m2))", "by (auto 4 5 split: prod.split_asm if_split_asm option.split simp: Let_def)"], ["", "lemma map_of_eq_pair:\n  \"map_of m1 ++ map_of m2 = pair.map_of (Pair_Storage k1 k2 m1 m2)\"\n  if \"inv_pair (Pair_Storage k1 k2 m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map_of m1 ++ local.map_of m2 =\n    pair.map_of (Pair_Storage k1 k2 m1 m2)", "using that"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. local.map_of m1 ++ local.map_of m2 =\n    pair.map_of (Pair_Storage k1 k2 m1 m2)", "unfolding pair.map_of_def"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. local.map_of m1 ++ local.map_of m2 =\n    (\\<lambda>k. fst (run_state (lookup_pair k) (Pair_Storage k1 k2 m1 m2)))", "unfolding lookup_pair_def inv_pair_def map_of_def map_le_def dom_def map_add_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` {a. fst (run_state (lookup a) m1) \\<noteq> None}\n    \\<subseteq> {k1} \\<and>\n    key ` {a. fst (run_state (lookup a) m2) \\<noteq> None}\n    \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case fst (run_state (lookup x) m2) of\n        None \\<Rightarrow> fst (run_state (lookup x) m1)\n        | Some x \\<Rightarrow> Some x) =\n    (\\<lambda>k.\n        fst (run_state\n              (State\n                (\\<lambda>mem.\n                    case mem of\n                    Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n                      let k' = key k\n                      in if k' = k2\n                         then case run_state (lookup k) m2 of\n                              (v, m) \\<Rightarrow>\n                                (v, Pair_Storage k1 k2 m1 m)\n                         else if k' = k1\n                              then case run_state (lookup k) m1 of\n                                   (v, m) \\<Rightarrow>\n                                     (v, Pair_Storage k1 k2 m m2)\n                              else (None, mem)))\n              (Pair_Storage k1 k2 m1 m2)))", "by (auto 4 7 split: prod.split_asm if_split_asm option.split simp: Let_def)"], ["", "lemma inv_pair_neq[simp, dest]:\n  False if \"inv_pair (Pair_Storage k k x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k k x y)\n\ngoal (1 subgoal):\n 1. False", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k k x y of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["", "lemma inv_pair_P_D1:\n  \"P m1\" if \"inv_pair (Pair_Storage k1 k2 m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P m1", "using that"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. P m1", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. P m1", "by auto"], ["", "lemma inv_pair_P_D2:\n  \"P m2\" if \"inv_pair (Pair_Storage k1 k2 m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P m2", "using that"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. P m2", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. P m2", "by auto"], ["", "lemma inv_pair_domD[intro]:\n  \"dom (map_of m1) \\<inter> dom (map_of m2) = {}\" if \"inv_pair (Pair_Storage k1 k2 m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (local.map_of m1) \\<inter> dom (local.map_of m2) = {}", "using that"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. dom (local.map_of m1) \\<inter> dom (local.map_of m2) = {}", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. dom (local.map_of m1) \\<inter> dom (local.map_of m2) = {}", "by fastforce"], ["", "lemma mem_correct_pair:\n  \"mem_correct lookup_pair update_pair inv_pair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct lookup_pair update_pair inv_pair", "proof (standard, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>k. lift_p inv_pair (lookup_pair k)\n 2. \\<And>k v. lift_p inv_pair (update_pair k v)\n 3. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 4. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "case (1 k) \\<comment> \\<open>Lookup invariant\\<close>"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>k. lift_p inv_pair (lookup_pair k)\n 2. \\<And>k v. lift_p inv_pair (update_pair k v)\n 3. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 4. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "with lookup_inv[of k]"], ["proof (chain)\npicking this:\n  lift_p P (lookup k)", "show ?case"], ["proof (prove)\nusing this:\n  lift_p P (lookup k)\n\ngoal (1 subgoal):\n 1. lift_p inv_pair (lookup_pair k)", "unfolding lookup_pair_def Let_def"], ["proof (prove)\nusing this:\n  lift_p P (lookup k)\n\ngoal (1 subgoal):\n 1. lift_p inv_pair\n     (State\n       (\\<lambda>mem.\n           case mem of\n           Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n             if key k = k2\n             then case run_state (lookup k) m2 of\n                  (v, m) \\<Rightarrow> (v, Pair_Storage k1 k2 m1 m)\n             else if key k = k1\n                  then case run_state (lookup k) m1 of\n                       (v, m) \\<Rightarrow> (v, Pair_Storage k1 k2 m m2)\n                  else (None, mem)))", "by (auto intro!: lift_pI split: pair_storage.split_asm if_split_asm prod.split_asm)\n       (auto dest: lift_p_P simp: inv_pair_def,\n         (force dest!: lookup_correct[of _ k] map_le_implies_dom_le)+\n       )"], ["proof (state)\nthis:\n  lift_p inv_pair (lookup_pair k)\n\ngoal (3 subgoals):\n 1. \\<And>k v. lift_p inv_pair (update_pair k v)\n 2. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 3. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k v. lift_p inv_pair (update_pair k v)\n 2. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 3. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "case (2 k v) \\<comment> \\<open>Update invariant\\<close>"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>k v. lift_p inv_pair (update_pair k v)\n 2. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 3. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "with update_inv[of k v] update_correct[OF P_empty, of k v] P_empty"], ["proof (chain)\npicking this:\n  lift_p P (update k v)\n  local.map_of (snd (run_state (update k v) empty)) \\<subseteq>\\<^sub>m\n  local.map_of empty(k \\<mapsto> v)\n  P empty", "show ?case"], ["proof (prove)\nusing this:\n  lift_p P (update k v)\n  local.map_of (snd (run_state (update k v) empty)) \\<subseteq>\\<^sub>m\n  local.map_of empty(k \\<mapsto> v)\n  P empty\n\ngoal (1 subgoal):\n 1. lift_p inv_pair (update_pair k v)", "unfolding update_pair_def Let_def"], ["proof (prove)\nusing this:\n  lift_p P (update k v)\n  local.map_of (snd (run_state (update k v) empty)) \\<subseteq>\\<^sub>m\n  local.map_of empty(k \\<mapsto> v)\n  P empty\n\ngoal (1 subgoal):\n 1. lift_p inv_pair\n     (State\n       (case_pair_storage\n         (\\<lambda>k1 k2 m1 m2.\n             if key k = k1\n             then case run_state (update k v) m1 of\n                  (x, m) \\<Rightarrow> ((), Pair_Storage k1 k2 m m2)\n             else if key k = k2\n                  then case run_state (update k v) m2 of\n                       (x, m) \\<Rightarrow> ((), Pair_Storage k1 k2 m1 m)\n                  else case run_state (update k v) empty of\n                       (x, m) \\<Rightarrow>\n                         ((), Pair_Storage (key k) k1 m m1))))", "by (auto intro!: lift_pI split: pair_storage.split_asm if_split_asm prod.split_asm)\n       (auto dest: lift_p_P simp: inv_pair_def,\n         (force dest: lift_p_P dest!: update_correct[of _ k v] map_le_implies_dom_le)+\n       )"], ["proof (state)\nthis:\n  lift_p inv_pair (update_pair k v)\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "case (3 m k)"], ["proof (state)\nthis:\n  inv_pair m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "{"], ["proof (state)\nthis:\n  inv_pair m\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "fix m1 v1 m1' m2 v2 m2' k1 k2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "assume assms:\n      \"State_Monad.run_state (lookup k) m1 = (v1, m1')\" \"State_Monad.run_state (lookup k) m2 = (v2, m2')\"\n      \"inv_pair (Pair_Storage k1 k2 m1 m2)\""], ["proof (state)\nthis:\n  run_state (lookup k) m1 = (v1, m1')\n  run_state (lookup k) m2 = (v2, m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "from assms"], ["proof (chain)\npicking this:\n  run_state (lookup k) m1 = (v1, m1')\n  run_state (lookup k) m2 = (v2, m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)", "have \"P m1\" \"P m2\""], ["proof (prove)\nusing this:\n  run_state (lookup k) m1 = (v1, m1')\n  run_state (lookup k) m2 = (v2, m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. P m1 &&& P m2", "by (auto intro: inv_pair_P_D1 inv_pair_P_D2)"], ["proof (state)\nthis:\n  P m1\n  P m2\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have [intro]: \"map_of m1' \\<subseteq>\\<^sub>m map_of m1\" \"map_of m2' \\<subseteq>\\<^sub>m map_of m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map_of m1' \\<subseteq>\\<^sub>m local.map_of m1 &&&\n    local.map_of m2' \\<subseteq>\\<^sub>m local.map_of m2", "using lookup_correct[OF \\<open>P m1\\<close>, of k] lookup_correct[OF \\<open>P m2\\<close>, of k] assms"], ["proof (prove)\nusing this:\n  local.map_of (snd (run_state (lookup k) m1)) \\<subseteq>\\<^sub>m\n  local.map_of m1\n  local.map_of (snd (run_state (lookup k) m2)) \\<subseteq>\\<^sub>m\n  local.map_of m2\n  run_state (lookup k) m1 = (v1, m1')\n  run_state (lookup k) m2 = (v2, m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. local.map_of m1' \\<subseteq>\\<^sub>m local.map_of m1 &&&\n    local.map_of m2' \\<subseteq>\\<^sub>m local.map_of m2", "by auto"], ["proof (state)\nthis:\n  local.map_of m1' \\<subseteq>\\<^sub>m local.map_of m1\n  local.map_of m2' \\<subseteq>\\<^sub>m local.map_of m2\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "from inv_pair_domD[OF assms(3)]"], ["proof (chain)\npicking this:\n  dom (local.map_of m1) \\<inter> dom (local.map_of m2) = {}", "have 1: \"dom (map_of m1') \\<inter> dom (map_of m2) = {}\""], ["proof (prove)\nusing this:\n  dom (local.map_of m1) \\<inter> dom (local.map_of m2) = {}\n\ngoal (1 subgoal):\n 1. dom (local.map_of m1') \\<inter> dom (local.map_of m2) = {}", "by (metis (no_types) \\<open>map_of m1' \\<subseteq>\\<^sub>m map_of m1\\<close> disjoint_iff_not_equal domIff map_le_def)"], ["proof (state)\nthis:\n  dom (local.map_of m1') \\<inter> dom (local.map_of m2) = {}\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have inv1: \"inv_pair (Pair_Storage (key k) k2 m1' m2)\" if \"k2 \\<noteq> key k\" \"k1 = key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair (Pair_Storage (key k) k2 m1' m2)", "using that \\<open>P m1\\<close> \\<open>P m2\\<close>"], ["proof (prove)\nusing this:\n  k2 \\<noteq> key k\n  k1 = key k\n  P m1\n  P m2\n\ngoal (1 subgoal):\n 1. inv_pair (Pair_Storage (key k) k2 m1' m2)", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  k2 \\<noteq> key k\n  k1 = key k\n  P m1\n  P m2\n\ngoal (1 subgoal):\n 1. case Pair_Storage (key k) k2 m1' m2 of\n    Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n      key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n      key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n      k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> key ` dom (local.map_of m1')\n                      \\<subseteq> {key k} \\<and>\n                      key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n                      P m1'", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m1' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = key k\n 2. \\<And>x xa y.\n       \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m2 xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = k2\n 3. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m1'", "subgoal for x' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1' y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = key k", "using assms(1,3) lookup_correct[OF \\<open>P m1\\<close>, of k, THEN map_le_implies_dom_le]"], ["proof (prove)\nusing this:\n  run_state (lookup k) m1 = (v1, m1')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n  dom (local.map_of (snd (run_state (lookup k) m1)))\n  \\<subseteq> dom (local.map_of m1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1' y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = key k", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  run_state (lookup k) m1 = (v1, m1')\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n  dom (local.map_of (snd (run_state (lookup k) m1)))\n  \\<subseteq> dom (local.map_of m1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1' y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = key k", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m2 xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = k2\n 2. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m1'", "subgoal for x' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m2 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k2", "using assms(3)"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m2 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k2", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m2 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k2", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m1'", "using lookup_inv[of k] assms"], ["proof (prove)\nusing this:\n  lift_p P (lookup k)\n  run_state (lookup k) m1 = (v1, m1')\n  run_state (lookup k) m2 = (v2, m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m1'", "unfolding lift_p_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<longrightarrow>\n     (case run_state (lookup k) heap of (x, xa) \\<Rightarrow> P xa)\n  run_state (lookup k) m1 = (v1, m1')\n  run_state (lookup k) m2 = (v2, m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m1'", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>k2 \\<noteq> key k; k1 = key k\\<rbrakk>\n  \\<Longrightarrow> inv_pair (Pair_Storage (key k) k2 m1' m2)\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have inv2: \"inv_pair (Pair_Storage k1 (key k) m1 m2')\" if \"k2 = key k\" \"k1 \\<noteq> key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair (Pair_Storage k1 (key k) m1 m2')", "using that \\<open>P m1\\<close> \\<open>P m2\\<close>"], ["proof (prove)\nusing this:\n  k2 = key k\n  k1 \\<noteq> key k\n  P m1\n  P m2\n\ngoal (1 subgoal):\n 1. inv_pair (Pair_Storage k1 (key k) m1 m2')", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  k2 = key k\n  k1 \\<noteq> key k\n  P m1\n  P m2\n\ngoal (1 subgoal):\n 1. case Pair_Storage k1 (key k) m1 m2' of\n    Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n      key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n      key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n      k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n                      key ` dom (local.map_of m2')\n                      \\<subseteq> {key k} \\<and>\n                      P m2'", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m1 xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = k1\n 2. \\<And>x xa y.\n       \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m2' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = key k\n 3. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m2'", "subgoal for x' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k1", "using assms(3)"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k1", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k1", "by fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m2' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = key k\n 2. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m2'", "subgoal for x x' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key x' \\<notin> {};\n     local.map_of m2' x' = Some y\\<rbrakk>\n    \\<Longrightarrow> key x' = key k", "using assms(2,3) lookup_correct[OF \\<open>P m2\\<close>, of k, THEN map_le_implies_dom_le]"], ["proof (prove)\nusing this:\n  run_state (lookup k) m2 = (v2, m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n  dom (local.map_of (snd (run_state (lookup k) m2)))\n  \\<subseteq> dom (local.map_of m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key x' \\<notin> {};\n     local.map_of m2' x' = Some y\\<rbrakk>\n    \\<Longrightarrow> key x' = key k", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  run_state (lookup k) m2 = (v2, m2')\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n  dom (local.map_of (snd (run_state (lookup k) m2)))\n  \\<subseteq> dom (local.map_of m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key x' \\<notin> {};\n     local.map_of m2' x' = Some y\\<rbrakk>\n    \\<Longrightarrow> key x' = key k", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m2'", "using lookup_inv[of k] assms"], ["proof (prove)\nusing this:\n  lift_p P (lookup k)\n  run_state (lookup k) m1 = (v1, m1')\n  run_state (lookup k) m2 = (v2, m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m2'", "unfolding lift_p_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<longrightarrow>\n     (case run_state (lookup k) heap of (x, xa) \\<Rightarrow> P xa)\n  run_state (lookup k) m1 = (v1, m1')\n  run_state (lookup k) m2 = (v2, m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m2'", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>k2 = key k; k1 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> inv_pair (Pair_Storage k1 (key k) m1 m2')\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have A:\n      \"pair.map_of (Pair_Storage (key k) k2 m1' m2) \\<subseteq>\\<^sub>m pair.map_of (Pair_Storage (key k) k2 m1 m2)\"\n      if \"k2 \\<noteq> key k\" \"k1 = key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage (key k) k2 m1' m2) \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage (key k) k2 m1 m2)", "using inv1 assms(3) 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>k2 \\<noteq> key k; k1 = key k\\<rbrakk>\n  \\<Longrightarrow> inv_pair (Pair_Storage (key k) k2 m1' m2)\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n  dom (local.map_of m1') \\<inter> dom (local.map_of m2) = {}\n\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage (key k) k2 m1' m2) \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage (key k) k2 m1 m2)", "by (auto intro: map_add_mono map_le_refl simp: that map_of_eq_pair[symmetric])"], ["proof (state)\nthis:\n  \\<lbrakk>k2 \\<noteq> key k; k1 = key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) k2 m1' m2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage (key k) k2 m1 m2)\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have B:\n      \"pair.map_of (Pair_Storage k1 (key k) m1 m2') \\<subseteq>\\<^sub>m pair.map_of (Pair_Storage k1 (key k) m1 m2)\"\n      if \"k2 = key k\" \"k1 \\<noteq> key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage k1 (key k) m1 m2') \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage k1 (key k) m1 m2)", "using inv2 assms(3) that"], ["proof (prove)\nusing this:\n  \\<lbrakk>k2 = key k; k1 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> inv_pair (Pair_Storage k1 (key k) m1 m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n  k2 = key k\n  k1 \\<noteq> key k\n\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage k1 (key k) m1 m2') \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage k1 (key k) m1 m2)", "by (auto intro: map_add_mono map_le_refl simp: map_of_eq_pair[symmetric] dest: inv_pair_domD)"], ["proof (state)\nthis:\n  \\<lbrakk>k2 = key k; k1 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage k1 (key k) m1 m2') \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage k1 (key k) m1 m2)\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "note A B"], ["proof (state)\nthis:\n  \\<lbrakk>k2 \\<noteq> key k; k1 = key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) k2 m1' m2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage (key k) k2 m1 m2)\n  \\<lbrakk>k2 = key k; k1 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage k1 (key k) m1 m2') \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage k1 (key k) m1 m2)\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>run_state (lookup k) ?m1.2 = (?v1.2, ?m1'2);\n   run_state (lookup k) ?m2.2 = (?v2.2, ?m2'2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 \\<noteq> key k;\n   ?k1.2 = key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) ?k2.2 ?m1'2\n                       ?m2.2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage (key k) ?k2.2 ?m1.2 ?m2.2)\n  \\<lbrakk>run_state (lookup k) ?m1.2 = (?v1.2, ?m1'2);\n   run_state (lookup k) ?m2.2 = (?v2.2, ?m2'2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 = key k;\n   ?k1.2 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage ?k1.2 (key k) ?m1.2\n                       ?m2'2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage ?k1.2 (key k) ?m1.2 ?m2.2)\n\ngoal (2 subgoals):\n 1. \\<And>m k.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m\n 2. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "with \\<open>inv_pair m\\<close>"], ["proof (chain)\npicking this:\n  inv_pair m\n  \\<lbrakk>run_state (lookup k) ?m1.2 = (?v1.2, ?m1'2);\n   run_state (lookup k) ?m2.2 = (?v2.2, ?m2'2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 \\<noteq> key k;\n   ?k1.2 = key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) ?k2.2 ?m1'2\n                       ?m2.2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage (key k) ?k2.2 ?m1.2 ?m2.2)\n  \\<lbrakk>run_state (lookup k) ?m1.2 = (?v1.2, ?m1'2);\n   run_state (lookup k) ?m2.2 = (?v2.2, ?m2'2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 = key k;\n   ?k1.2 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage ?k1.2 (key k) ?m1.2\n                       ?m2'2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage ?k1.2 (key k) ?m1.2 ?m2.2)", "show ?case"], ["proof (prove)\nusing this:\n  inv_pair m\n  \\<lbrakk>run_state (lookup k) ?m1.2 = (?v1.2, ?m1'2);\n   run_state (lookup k) ?m2.2 = (?v2.2, ?m2'2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 \\<noteq> key k;\n   ?k1.2 = key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) ?k2.2 ?m1'2\n                       ?m2.2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage (key k) ?k2.2 ?m1.2 ?m2.2)\n  \\<lbrakk>run_state (lookup k) ?m1.2 = (?v1.2, ?m1'2);\n   run_state (lookup k) ?m2.2 = (?v2.2, ?m2'2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 = key k;\n   ?k1.2 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage ?k1.2 (key k) ?m1.2\n                       ?m2'2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage ?k1.2 (key k) ?m1.2 ?m2.2)\n\ngoal (1 subgoal):\n 1. pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n    pair.map_of m", "by (auto split: pair_storage.split if_split prod.split simp: Let_def lookup_pair_def)"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (lookup_pair k) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "case (4 m k v)"], ["proof (state)\nthis:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "{"], ["proof (state)\nthis:\n  inv_pair m\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "fix m1 v1 m1' m2 v2 m2' m3 k1 k2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "assume assms:\n      \"State_Monad.run_state (update k v) m1 = ((), m1')\" \"State_Monad.run_state (update k v) m2 = ((), m2')\"\n      \"State_Monad.run_state (update k v) empty = ((), m3)\"\n      \"inv_pair (Pair_Storage k1 k2 m1 m2)\""], ["proof (state)\nthis:\n  run_state (update k v) m1 = ((), m1')\n  run_state (update k v) m2 = ((), m2')\n  run_state (update k v) empty = ((), m3)\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "from assms"], ["proof (chain)\npicking this:\n  run_state (update k v) m1 = ((), m1')\n  run_state (update k v) m2 = ((), m2')\n  run_state (update k v) empty = ((), m3)\n  inv_pair (Pair_Storage k1 k2 m1 m2)", "have \"P m1\" \"P m2\""], ["proof (prove)\nusing this:\n  run_state (update k v) m1 = ((), m1')\n  run_state (update k v) m2 = ((), m2')\n  run_state (update k v) empty = ((), m3)\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. P m1 &&& P m2", "by (auto intro: inv_pair_P_D1 inv_pair_P_D2)"], ["proof (state)\nthis:\n  P m1\n  P m2\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "from assms(3) P_empty update_inv[of k v]"], ["proof (chain)\npicking this:\n  run_state (update k v) empty = ((), m3)\n  P empty\n  lift_p P (update k v)", "have \"P m3\""], ["proof (prove)\nusing this:\n  run_state (update k v) empty = ((), m3)\n  P empty\n  lift_p P (update k v)\n\ngoal (1 subgoal):\n 1. P m3", "unfolding lift_p_def"], ["proof (prove)\nusing this:\n  run_state (update k v) empty = ((), m3)\n  P empty\n  \\<forall>heap.\n     P heap \\<longrightarrow>\n     (case run_state (update k v) heap of (x, xa) \\<Rightarrow> P xa)\n\ngoal (1 subgoal):\n 1. P m3", "by auto"], ["proof (state)\nthis:\n  P m3\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have [intro]: \"map_of m1' \\<subseteq>\\<^sub>m map_of m1(k \\<mapsto> v)\" \"map_of m2' \\<subseteq>\\<^sub>m map_of m2(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map_of m1' \\<subseteq>\\<^sub>m local.map_of m1(k \\<mapsto> v) &&&\n    local.map_of m2' \\<subseteq>\\<^sub>m local.map_of m2(k \\<mapsto> v)", "using update_correct[OF \\<open>P m1\\<close>, of k v] update_correct[OF \\<open>P m2\\<close>, of k v] assms"], ["proof (prove)\nusing this:\n  local.map_of (snd (run_state (update k v) m1)) \\<subseteq>\\<^sub>m\n  local.map_of m1(k \\<mapsto> v)\n  local.map_of (snd (run_state (update k v) m2)) \\<subseteq>\\<^sub>m\n  local.map_of m2(k \\<mapsto> v)\n  run_state (update k v) m1 = ((), m1')\n  run_state (update k v) m2 = ((), m2')\n  run_state (update k v) empty = ((), m3)\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. local.map_of m1' \\<subseteq>\\<^sub>m local.map_of m1(k \\<mapsto> v) &&&\n    local.map_of m2' \\<subseteq>\\<^sub>m local.map_of m2(k \\<mapsto> v)", "by auto"], ["proof (state)\nthis:\n  local.map_of m1' \\<subseteq>\\<^sub>m local.map_of m1(k \\<mapsto> v)\n  local.map_of m2' \\<subseteq>\\<^sub>m local.map_of m2(k \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have \"map_of m3 \\<subseteq>\\<^sub>m map_of empty(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map_of m3 \\<subseteq>\\<^sub>m local.map_of empty(k \\<mapsto> v)", "using assms(3) update_correct[OF P_empty, of k v]"], ["proof (prove)\nusing this:\n  run_state (update k v) empty = ((), m3)\n  local.map_of (snd (run_state (update k v) empty)) \\<subseteq>\\<^sub>m\n  local.map_of empty(k \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. local.map_of m3 \\<subseteq>\\<^sub>m local.map_of empty(k \\<mapsto> v)", "by auto"], ["proof (state)\nthis:\n  local.map_of m3 \\<subseteq>\\<^sub>m local.map_of empty(k \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "also"], ["proof (state)\nthis:\n  local.map_of m3 \\<subseteq>\\<^sub>m local.map_of empty(k \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have \"\\<dots> \\<subseteq>\\<^sub>m map_of m2(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map_of empty(k \\<mapsto> v) \\<subseteq>\\<^sub>m local.map_of m2(k \n    \\<mapsto> v)", "using empty_correct"], ["proof (prove)\nusing this:\n  local.map_of empty \\<subseteq>\\<^sub>m Map.empty\n\ngoal (1 subgoal):\n 1. local.map_of empty(k \\<mapsto> v) \\<subseteq>\\<^sub>m local.map_of m2(k \n    \\<mapsto> v)", "by (auto elim: map_le_trans intro!: map_le_upd)"], ["proof (state)\nthis:\n  local.map_of empty(k \\<mapsto> v) \\<subseteq>\\<^sub>m local.map_of m2(k \n  \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "finally"], ["proof (chain)\npicking this:\n  local.map_of m3 \\<subseteq>\\<^sub>m local.map_of m2(k \\<mapsto> v)", "have \"map_of m3 \\<subseteq>\\<^sub>m map_of m2(k \\<mapsto> v)\""], ["proof (prove)\nusing this:\n  local.map_of m3 \\<subseteq>\\<^sub>m local.map_of m2(k \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. local.map_of m3 \\<subseteq>\\<^sub>m local.map_of m2(k \\<mapsto> v)", "."], ["proof (state)\nthis:\n  local.map_of m3 \\<subseteq>\\<^sub>m local.map_of m2(k \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have 1: \"dom (map_of m1) \\<inter> dom (map_of m2(k \\<mapsto> v)) = {}\" if \"k1 \\<noteq> key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (local.map_of m1) \\<inter> dom (local.map_of m2(k \\<mapsto> v)) = {}", "using assms(4) that"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n  k1 \\<noteq> key k\n\ngoal (1 subgoal):\n 1. dom (local.map_of m1) \\<inter> dom (local.map_of m2(k \\<mapsto> v)) = {}", "by (force simp: inv_pair_def)"], ["proof (state)\nthis:\n  k1 \\<noteq> key k \\<Longrightarrow>\n  dom (local.map_of m1) \\<inter> dom (local.map_of m2(k \\<mapsto> v)) = {}\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have 2: \"dom (map_of m3) \\<inter> dom (map_of m1) = {}\" if \"k1 \\<noteq> key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (local.map_of m3) \\<inter> dom (local.map_of m1) = {}", "using \\<open>local.map_of m3 \\<subseteq>\\<^sub>m local.map_of empty(k \\<mapsto> v)\\<close> assms(4) that"], ["proof (prove)\nusing this:\n  local.map_of m3 \\<subseteq>\\<^sub>m local.map_of empty(k \\<mapsto> v)\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n  k1 \\<noteq> key k\n\ngoal (1 subgoal):\n 1. dom (local.map_of m3) \\<inter> dom (local.map_of m1) = {}", "by (fastforce dest!: map_le_implies_dom_le simp: inv_pair_def)"], ["proof (state)\nthis:\n  k1 \\<noteq> key k \\<Longrightarrow>\n  dom (local.map_of m3) \\<inter> dom (local.map_of m1) = {}\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have inv: \"inv_pair (Pair_Storage (key k) k1 m3 m1)\" if \"k2 \\<noteq> key k\" \"k1 \\<noteq> key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair (Pair_Storage (key k) k1 m3 m1)", "using that \\<open>P m1\\<close> \\<open>P m2\\<close> \\<open>P m3\\<close>"], ["proof (prove)\nusing this:\n  k2 \\<noteq> key k\n  k1 \\<noteq> key k\n  P m1\n  P m2\n  P m3\n\ngoal (1 subgoal):\n 1. inv_pair (Pair_Storage (key k) k1 m3 m1)", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  k2 \\<noteq> key k\n  k1 \\<noteq> key k\n  P m1\n  P m2\n  P m3\n\ngoal (1 subgoal):\n 1. case Pair_Storage (key k) k1 m3 m1 of\n    Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n      key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n      key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n      k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k; P m1; P m2; P m3\\<rbrakk>\n    \\<Longrightarrow> key ` dom (local.map_of m3) \\<subseteq> {key k} \\<and>\n                      key ` dom (local.map_of m1) \\<subseteq> {k1}", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k; P m1; P m2; P m3;\n        key xa \\<notin> {}; local.map_of m3 xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = key k\n 2. \\<And>x xa y.\n       \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k; P m1; P m2; P m3;\n        key xa \\<notin> {}; local.map_of m1 xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = k1", "subgoal for x x' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k; P m1; P m2; P m3;\n     key x' \\<notin> {}; local.map_of m3 x' = Some y\\<rbrakk>\n    \\<Longrightarrow> key x' = key k", "using assms(3) update_correct[OF P_empty, of k v, THEN map_le_implies_dom_le]\n          empty_correct"], ["proof (prove)\nusing this:\n  run_state (update k v) empty = ((), m3)\n  dom (local.map_of (snd (run_state (update k v) empty)))\n  \\<subseteq> dom (local.map_of empty(k \\<mapsto> v))\n  local.map_of empty \\<subseteq>\\<^sub>m Map.empty\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k; P m1; P m2; P m3;\n     key x' \\<notin> {}; local.map_of m3 x' = Some y\\<rbrakk>\n    \\<Longrightarrow> key x' = key k", "by (auto dest: map_le_implies_dom_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa y.\n       \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k; P m1; P m2; P m3;\n        key xa \\<notin> {}; local.map_of m1 xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = k1", "subgoal for x x' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k; P m1; P m2; P m3;\n     key x' \\<notin> {}; local.map_of m1 x' = Some y\\<rbrakk>\n    \\<Longrightarrow> key x' = k1", "using assms(4)"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k; P m1; P m2; P m3;\n     key x' \\<notin> {}; local.map_of m1 x' = Some y\\<rbrakk>\n    \\<Longrightarrow> key x' = k1", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k; P m1; P m2; P m3;\n     key x' \\<notin> {}; local.map_of m1 x' = Some y\\<rbrakk>\n    \\<Longrightarrow> key x' = k1", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> inv_pair (Pair_Storage (key k) k1 m3 m1)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have A:\n      \"pair.map_of (Pair_Storage (key k) k1 m3 m1) \\<subseteq>\\<^sub>m pair.map_of (Pair_Storage k1 k2 m1 m2)(k \\<mapsto> v)\"\n      if \"k2 \\<noteq> key k\" \"k1 \\<noteq> key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage (key k) k1 m3 m1) \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage k1 k2 m1 m2)(k \\<mapsto> v)", "using inv assms(4) \\<open>map_of m3 \\<subseteq>\\<^sub>m map_of m2(k \\<mapsto> v)\\<close> 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> inv_pair (Pair_Storage (key k) k1 m3 m1)\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n  local.map_of m3 \\<subseteq>\\<^sub>m local.map_of m2(k \\<mapsto> v)\n  k1 \\<noteq> key k \\<Longrightarrow>\n  dom (local.map_of m1) \\<inter> dom (local.map_of m2(k \\<mapsto> v)) = {}\n\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage (key k) k1 m3 m1) \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage k1 k2 m1 m2)(k \\<mapsto> v)", "apply (simp add: that map_of_eq_pair[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_pair (Pair_Storage (key k) k1 m3 m1);\n     inv_pair (Pair_Storage k1 k2 m1 m2);\n     local.map_of m3 \\<subseteq>\\<^sub>m local.map_of m2(k \\<mapsto> v);\n     k \\<notin> dom (local.map_of m1) \\<and>\n     dom (local.map_of m1) \\<inter> dom (local.map_of m2) = {}\\<rbrakk>\n    \\<Longrightarrow> local.map_of m3 ++ local.map_of m1 \\<subseteq>\\<^sub>m\n                      (local.map_of m1 ++ local.map_of m2)(k \\<mapsto> v)", "apply (subst map_add_upd[symmetric], subst Map.map_add_comm, rule 2, rule that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_pair (Pair_Storage (key k) k1 m3 m1);\n     inv_pair (Pair_Storage k1 k2 m1 m2);\n     local.map_of m3 \\<subseteq>\\<^sub>m local.map_of m2(k \\<mapsto> v);\n     k \\<notin> dom (local.map_of m1) \\<and>\n     dom (local.map_of m1) \\<inter> dom (local.map_of m2) = {}\\<rbrakk>\n    \\<Longrightarrow> local.map_of m1 ++ local.map_of m3 \\<subseteq>\\<^sub>m\n                      local.map_of m1 ++ local.map_of m2(k \\<mapsto> v)", "by (rule map_add_mono; auto)"], ["proof (state)\nthis:\n  \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) k1 m3 m1) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage k1 k2 m1 m2)(k \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have inv1: \"inv_pair (Pair_Storage (key k) k2 m1' m2)\" if \"k2 \\<noteq> key k\" \"k1 = key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair (Pair_Storage (key k) k2 m1' m2)", "using that \\<open>P m1\\<close> \\<open>P m2\\<close>"], ["proof (prove)\nusing this:\n  k2 \\<noteq> key k\n  k1 = key k\n  P m1\n  P m2\n\ngoal (1 subgoal):\n 1. inv_pair (Pair_Storage (key k) k2 m1' m2)", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  k2 \\<noteq> key k\n  k1 = key k\n  P m1\n  P m2\n\ngoal (1 subgoal):\n 1. case Pair_Storage (key k) k2 m1' m2 of\n    Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n      key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n      key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n      k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> key ` dom (local.map_of m1')\n                      \\<subseteq> {key k} \\<and>\n                      key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n                      P m1'", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m1' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = key k\n 2. \\<And>x xa y.\n       \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m2 xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = k2\n 3. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m1'", "subgoal for x' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1' y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = key k", "using assms(1,4) update_correct[OF \\<open>P m1\\<close>, of k v, THEN map_le_implies_dom_le]"], ["proof (prove)\nusing this:\n  run_state (update k v) m1 = ((), m1')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n  dom (local.map_of (snd (run_state (update k v) m1)))\n  \\<subseteq> dom (local.map_of m1(k \\<mapsto> v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1' y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = key k", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  run_state (update k v) m1 = ((), m1')\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n  dom (local.map_of (snd (run_state (update k v) m1)))\n  \\<subseteq> dom (local.map_of m1(k \\<mapsto> v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1' y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = key k", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m2 xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = k2\n 2. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m1'", "subgoal for x' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m2 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k2", "using assms(4)"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m2 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k2", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m2 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k2", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m1'", "using update_inv[of k v] assms"], ["proof (prove)\nusing this:\n  lift_p P (update k v)\n  run_state (update k v) m1 = ((), m1')\n  run_state (update k v) m2 = ((), m2')\n  run_state (update k v) empty = ((), m3)\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m1'", "unfolding lift_p_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<longrightarrow>\n     (case run_state (update k v) heap of (x, xa) \\<Rightarrow> P xa)\n  run_state (update k v) m1 = ((), m1')\n  run_state (update k v) m2 = ((), m2')\n  run_state (update k v) empty = ((), m3)\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 \\<noteq> key k; k1 = key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m1'", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>k2 \\<noteq> key k; k1 = key k\\<rbrakk>\n  \\<Longrightarrow> inv_pair (Pair_Storage (key k) k2 m1' m2)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have inv2: \"inv_pair (Pair_Storage k1 (key k) m1 m2')\" if \"k2 = key k\" \"k1 \\<noteq> key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_pair (Pair_Storage k1 (key k) m1 m2')", "using that \\<open>P m1\\<close> \\<open>P m2\\<close>"], ["proof (prove)\nusing this:\n  k2 = key k\n  k1 \\<noteq> key k\n  P m1\n  P m2\n\ngoal (1 subgoal):\n 1. inv_pair (Pair_Storage k1 (key k) m1 m2')", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  k2 = key k\n  k1 \\<noteq> key k\n  P m1\n  P m2\n\ngoal (1 subgoal):\n 1. case Pair_Storage k1 (key k) m1 m2' of\n    Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n      key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n      key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n      k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n                      key ` dom (local.map_of m2')\n                      \\<subseteq> {key k} \\<and>\n                      P m2'", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m1 xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = k1\n 2. \\<And>x xa y.\n       \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m2' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = key k\n 3. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m2'", "subgoal for x' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k1", "using assms(4)"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k1", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key y \\<notin> {};\n     local.map_of m1 y = Some y_\\<rbrakk>\n    \\<Longrightarrow> key y = k1", "by fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2;\n        key xa \\<notin> {}; local.map_of m2' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> key xa = key k\n 2. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m2'", "subgoal for x x' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key x' \\<notin> {};\n     local.map_of m2' x' = Some y\\<rbrakk>\n    \\<Longrightarrow> key x' = key k", "using assms(2,4) update_correct[OF \\<open>P m2\\<close>, of k v, THEN map_le_implies_dom_le]"], ["proof (prove)\nusing this:\n  run_state (update k v) m2 = ((), m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n  dom (local.map_of (snd (run_state (update k v) m2)))\n  \\<subseteq> dom (local.map_of m2(k \\<mapsto> v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key x' \\<notin> {};\n     local.map_of m2' x' = Some y\\<rbrakk>\n    \\<Longrightarrow> key x' = key k", "unfolding inv_pair_def"], ["proof (prove)\nusing this:\n  run_state (update k v) m2 = ((), m2')\n  case Pair_Storage k1 k2 m1 m2 of\n  Pair_Storage k1 k2 m1 m2 \\<Rightarrow>\n    key ` dom (local.map_of m1) \\<subseteq> {k1} \\<and>\n    key ` dom (local.map_of m2) \\<subseteq> {k2} \\<and>\n    k1 \\<noteq> k2 \\<and> P m1 \\<and> P m2\n  dom (local.map_of (snd (run_state (update k v) m2)))\n  \\<subseteq> dom (local.map_of m2(k \\<mapsto> v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2; key x' \\<notin> {};\n     local.map_of m2' x' = Some y\\<rbrakk>\n    \\<Longrightarrow> key x' = key k", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m2'", "using update_inv[of k v] assms"], ["proof (prove)\nusing this:\n  lift_p P (update k v)\n  run_state (update k v) m1 = ((), m1')\n  run_state (update k v) m2 = ((), m2')\n  run_state (update k v) empty = ((), m3)\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m2'", "unfolding lift_p_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<longrightarrow>\n     (case run_state (update k v) heap of (x, xa) \\<Rightarrow> P xa)\n  run_state (update k v) m1 = ((), m1')\n  run_state (update k v) m2 = ((), m2')\n  run_state (update k v) empty = ((), m3)\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k2 = key k; k1 \\<noteq> key k; P m1; P m2\\<rbrakk>\n    \\<Longrightarrow> P m2'", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>k2 = key k; k1 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> inv_pair (Pair_Storage k1 (key k) m1 m2')\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have C:\n      \"pair.map_of (Pair_Storage (key k) k2 m1' m2) \\<subseteq>\\<^sub>m\n       pair.map_of (Pair_Storage (key k) k2 m1 m2)(k \\<mapsto> v)\"\n      if \"k2 \\<noteq> key k\" \"k1 = key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage (key k) k2 m1' m2) \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage (key k) k2 m1 m2)(k \\<mapsto> v)", "using inv1[OF that] assms(4) \\<open>inv_pair m\\<close>"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage (key k) k2 m1' m2)\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n  inv_pair m\n\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage (key k) k2 m1' m2) \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage (key k) k2 m1 m2)(k \\<mapsto> v)", "by (simp add: that map_of_eq_pair[symmetric])\n         (subst map_add_upd2[symmetric]; force simp: inv_pair_def intro: map_add_mono map_le_refl)"], ["proof (state)\nthis:\n  \\<lbrakk>k2 \\<noteq> key k; k1 = key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) k2 m1' m2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage (key k) k2 m1 m2)(k \\<mapsto>\n                    v)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "have B:\n      \"pair.map_of (Pair_Storage k1 (key k) m1 m2') \\<subseteq>\\<^sub>m\n       pair.map_of (Pair_Storage k1 (key k) m1 m2)(k \\<mapsto> v)\"\n      if \"k2 = key k\" \"k1 \\<noteq> key k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage k1 (key k) m1 m2') \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage k1 (key k) m1 m2)(k \\<mapsto> v)", "using inv2[OF that] assms(4)"], ["proof (prove)\nusing this:\n  inv_pair (Pair_Storage k1 (key k) m1 m2')\n  inv_pair (Pair_Storage k1 k2 m1 m2)\n\ngoal (1 subgoal):\n 1. pair.map_of (Pair_Storage k1 (key k) m1 m2') \\<subseteq>\\<^sub>m\n    pair.map_of (Pair_Storage k1 (key k) m1 m2)(k \\<mapsto> v)", "by (simp add: that map_of_eq_pair[symmetric])\n         (subst map_add_upd[symmetric]; rule map_add_mono; force simp: inv_pair_def)"], ["proof (state)\nthis:\n  \\<lbrakk>k2 = key k; k1 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage k1 (key k) m1 m2') \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage k1 (key k) m1 m2)(k \\<mapsto>\n                    v)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "note A B C"], ["proof (state)\nthis:\n  \\<lbrakk>k2 \\<noteq> key k; k1 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) k1 m3 m1) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage k1 k2 m1 m2)(k \\<mapsto> v)\n  \\<lbrakk>k2 = key k; k1 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage k1 (key k) m1 m2') \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage k1 (key k) m1 m2)(k \\<mapsto>\n                    v)\n  \\<lbrakk>k2 \\<noteq> key k; k1 = key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) k2 m1' m2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage (key k) k2 m1 m2)(k \\<mapsto>\n                    v)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>run_state (update k v) ?m1.2 = ((), ?m1'2);\n   run_state (update k v) ?m2.2 = ((), ?m2'2);\n   run_state (update k v) empty = ((), ?m3.2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 \\<noteq> key k;\n   ?k1.2 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) ?k1.2 ?m3.2\n                       ?m1.2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2)(k \n                    \\<mapsto> v)\n  \\<lbrakk>run_state (update k v) ?m1.2 = ((), ?m1'2);\n   run_state (update k v) ?m2.2 = ((), ?m2'2);\n   run_state (update k v) empty = ((), ?m3.2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 = key k;\n   ?k1.2 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage ?k1.2 (key k) ?m1.2\n                       ?m2'2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage ?k1.2 (key k) ?m1.2 ?m2.2)(k \n                    \\<mapsto> v)\n  \\<lbrakk>run_state (update k v) ?m1.2 = ((), ?m1'2);\n   run_state (update k v) ?m2.2 = ((), ?m2'2);\n   run_state (update k v) empty = ((), ?m3.2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 \\<noteq> key k;\n   ?k1.2 = key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) ?k2.2 ?m1'2\n                       ?m2.2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage (key k) ?k2.2 ?m1.2 ?m2.2)(k \n                    \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. \\<And>m k v.\n       inv_pair m \\<Longrightarrow>\n       pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n       pair.map_of m(k \\<mapsto> v)", "with \\<open>inv_pair m\\<close>"], ["proof (chain)\npicking this:\n  inv_pair m\n  \\<lbrakk>run_state (update k v) ?m1.2 = ((), ?m1'2);\n   run_state (update k v) ?m2.2 = ((), ?m2'2);\n   run_state (update k v) empty = ((), ?m3.2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 \\<noteq> key k;\n   ?k1.2 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) ?k1.2 ?m3.2\n                       ?m1.2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2)(k \n                    \\<mapsto> v)\n  \\<lbrakk>run_state (update k v) ?m1.2 = ((), ?m1'2);\n   run_state (update k v) ?m2.2 = ((), ?m2'2);\n   run_state (update k v) empty = ((), ?m3.2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 = key k;\n   ?k1.2 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage ?k1.2 (key k) ?m1.2\n                       ?m2'2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage ?k1.2 (key k) ?m1.2 ?m2.2)(k \n                    \\<mapsto> v)\n  \\<lbrakk>run_state (update k v) ?m1.2 = ((), ?m1'2);\n   run_state (update k v) ?m2.2 = ((), ?m2'2);\n   run_state (update k v) empty = ((), ?m3.2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 \\<noteq> key k;\n   ?k1.2 = key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) ?k2.2 ?m1'2\n                       ?m2.2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage (key k) ?k2.2 ?m1.2 ?m2.2)(k \n                    \\<mapsto> v)", "show ?case"], ["proof (prove)\nusing this:\n  inv_pair m\n  \\<lbrakk>run_state (update k v) ?m1.2 = ((), ?m1'2);\n   run_state (update k v) ?m2.2 = ((), ?m2'2);\n   run_state (update k v) empty = ((), ?m3.2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 \\<noteq> key k;\n   ?k1.2 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) ?k1.2 ?m3.2\n                       ?m1.2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2)(k \n                    \\<mapsto> v)\n  \\<lbrakk>run_state (update k v) ?m1.2 = ((), ?m1'2);\n   run_state (update k v) ?m2.2 = ((), ?m2'2);\n   run_state (update k v) empty = ((), ?m3.2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 = key k;\n   ?k1.2 \\<noteq> key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage ?k1.2 (key k) ?m1.2\n                       ?m2'2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage ?k1.2 (key k) ?m1.2 ?m2.2)(k \n                    \\<mapsto> v)\n  \\<lbrakk>run_state (update k v) ?m1.2 = ((), ?m1'2);\n   run_state (update k v) ?m2.2 = ((), ?m2'2);\n   run_state (update k v) empty = ((), ?m3.2);\n   inv_pair (Pair_Storage ?k1.2 ?k2.2 ?m1.2 ?m2.2); ?k2.2 \\<noteq> key k;\n   ?k1.2 = key k\\<rbrakk>\n  \\<Longrightarrow> pair.map_of\n                     (Pair_Storage (key k) ?k2.2 ?m1'2\n                       ?m2.2) \\<subseteq>\\<^sub>m\n                    pair.map_of (Pair_Storage (key k) ?k2.2 ?m1.2 ?m2.2)(k \n                    \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n    pair.map_of m(k \\<mapsto> v)", "by (auto split: pair_storage.split if_split prod.split simp: Let_def update_pair_def)"], ["proof (state)\nthis:\n  pair.map_of (snd (run_state (update_pair k v) m)) \\<subseteq>\\<^sub>m\n  pair.map_of m(k \\<mapsto> v)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* Key function *)"], ["", "end"], ["", "(* Lookup & Update w/ Empty *)"], ["", "end"], ["", "(* Theory *)"]]}