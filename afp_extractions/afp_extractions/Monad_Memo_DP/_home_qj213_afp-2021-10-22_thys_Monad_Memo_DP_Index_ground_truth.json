{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/Index.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma index_mono:\n  fixes a b a0 b0 :: nat\n  assumes a: \"a < a0\" and b: \"b < b0\"\n  shows \"a * b0 + b < a0 * b0\"", "lemma index_eq_iff:\n  fixes a b c d b0 :: nat\n  assumes \"b < b0\" \"d < b0\" \"a * b0 + b = c * b0 + d\"\n  shows \"a = c \\<and> b = d\"", "lemma checked_idx_injective:\n  \"injective size checked_idx\"", "lemmas size_int = size.simps", "lemmas size_prod = size.simps", "lemma bound_int_simp[code]:\n  \"bounded_index.size (Bound (l1, l2) (u1, u2)) = nat (u1 - l1) * nat (u2 - l2)\"", "lemmas [code] = bounded_index.size_def bounded_index.checked_idx_def", "lemmas [code] =\n  nat_index_def.size.simps\n  nat_index_def.idx.simps", "lemmas [code] =\n  int_index_def.size.simps\n  int_index_def.idx.simps", "lemmas [code] =\n  prod_index_def.size.simps\n  prod_index_def.idx.simps", "lemmas [code] =\n  prod_order_def.less_eq.simps\n  prod_order_def.less.simps", "lemmas index_size_defs =\n  prod_index_def.size.simps int_index_def.size.simps nat_index_def.size.simps bounded_index.size_def"], "translations": [["", "lemma index_mono:\n  fixes a b a0 b0 :: nat\n  assumes a: \"a < a0\" and b: \"b < b0\"\n  shows \"a * b0 + b < a0 * b0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b0 + b < a0 * b0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a * b0 + b < a0 * b0", "have \"a * b0 + b < (Suc a) * b0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b0 + b < Suc a * b0", "using b"], ["proof (prove)\nusing this:\n  b < b0\n\ngoal (1 subgoal):\n 1. a * b0 + b < Suc a * b0", "by auto"], ["proof (state)\nthis:\n  a * b0 + b < Suc a * b0\n\ngoal (1 subgoal):\n 1. a * b0 + b < a0 * b0", "also"], ["proof (state)\nthis:\n  a * b0 + b < Suc a * b0\n\ngoal (1 subgoal):\n 1. a * b0 + b < a0 * b0", "have \"\\<dots> \\<le> a0 * b0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc a * b0 \\<le> a0 * b0", "using a[THEN Suc_leI, THEN mult_le_mono1]"], ["proof (prove)\nusing this:\n  Suc a * ?k \\<le> a0 * ?k\n\ngoal (1 subgoal):\n 1. Suc a * b0 \\<le> a0 * b0", "."], ["proof (state)\nthis:\n  Suc a * b0 \\<le> a0 * b0\n\ngoal (1 subgoal):\n 1. a * b0 + b < a0 * b0", "finally"], ["proof (chain)\npicking this:\n  a * b0 + b < a0 * b0", "show ?thesis"], ["proof (prove)\nusing this:\n  a * b0 + b < a0 * b0\n\ngoal (1 subgoal):\n 1. a * b0 + b < a0 * b0", "."], ["proof (state)\nthis:\n  a * b0 + b < a0 * b0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_eq_iff:\n  fixes a b c d b0 :: nat\n  assumes \"b < b0\" \"d < b0\" \"a * b0 + b = c * b0 + d\"\n  shows \"a = c \\<and> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "fix a b c d :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "assume ac: \"a < c\" and b: \"b < b0\""], ["proof (state)\nthis:\n  a < c\n  b < b0\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "have \"a * b0 + b < (Suc a) * b0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b0 + b < Suc a * b0", "using b"], ["proof (prove)\nusing this:\n  b < b0\n\ngoal (1 subgoal):\n 1. a * b0 + b < Suc a * b0", "by auto"], ["proof (state)\nthis:\n  a * b0 + b < Suc a * b0\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "also"], ["proof (state)\nthis:\n  a * b0 + b < Suc a * b0\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "have \"\\<dots> \\<le> c * b0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc a * b0 \\<le> c * b0", "using ac[THEN Suc_leI, THEN mult_le_mono1]"], ["proof (prove)\nusing this:\n  Suc a * ?k \\<le> c * ?k\n\ngoal (1 subgoal):\n 1. Suc a * b0 \\<le> c * b0", "."], ["proof (state)\nthis:\n  Suc a * b0 \\<le> c * b0\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "also"], ["proof (state)\nthis:\n  Suc a * b0 \\<le> c * b0\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "have \"\\<dots> \\<le> c * b0 + d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * b0 \\<le> c * b0 + d", "by auto"], ["proof (state)\nthis:\n  c * b0 \\<le> c * b0 + d\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "finally"], ["proof (chain)\npicking this:\n  a * b0 + b < c * b0 + d", "have \"a * b0 + b \\<noteq> c * b0 + d\""], ["proof (prove)\nusing this:\n  a * b0 + b < c * b0 + d\n\ngoal (1 subgoal):\n 1. a * b0 + b \\<noteq> c * b0 + d", "by auto"], ["proof (state)\nthis:\n  a * b0 + b \\<noteq> c * b0 + d\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?aa2 < ?ca2; ?ba2 < b0\\<rbrakk>\n  \\<Longrightarrow> ?aa2 * b0 + ?ba2 \\<noteq> ?ca2 * b0 + ?da2\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "note ac = this"], ["proof (state)\nthis:\n  \\<lbrakk>?aa2 < ?ca2; ?ba2 < b0\\<rbrakk>\n  \\<Longrightarrow> ?aa2 * b0 + ?ba2 \\<noteq> ?ca2 * b0 + ?da2\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?aa2 < ?ca2; ?ba2 < b0\\<rbrakk>\n  \\<Longrightarrow> ?aa2 * b0 + ?ba2 \\<noteq> ?ca2 * b0 + ?da2\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "assume \"a \\<noteq> c\""], ["proof (state)\nthis:\n  a \\<noteq> c\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> c", "consider (le) \"a < c\" | (ge) \"a > c\""], ["proof (prove)\nusing this:\n  a \\<noteq> c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < c \\<Longrightarrow> thesis;\n     c < a \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>a < c \\<Longrightarrow> ?thesis;\n   c < a \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "hence False"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < c \\<Longrightarrow> ?thesis;\n   c < a \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. a < c \\<Longrightarrow> False\n 2. c < a \\<Longrightarrow> False", "case le"], ["proof (state)\nthis:\n  a < c\n\ngoal (2 subgoals):\n 1. a < c \\<Longrightarrow> False\n 2. c < a \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using ac[OF le assms(1)] assms(3)"], ["proof (prove)\nusing this:\n  a * b0 + b \\<noteq> c * b0 + ?da2\n  a * b0 + b = c * b0 + d\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. c < a \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c < a \\<Longrightarrow> False", "case ge"], ["proof (state)\nthis:\n  c < a\n\ngoal (1 subgoal):\n 1. c < a \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using ac[OF ge assms(2)] assms(3)[symmetric]"], ["proof (prove)\nusing this:\n  c * b0 + d \\<noteq> a * b0 + ?da2\n  c * b0 + d = a * b0 + b\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "}"], ["proof (state)\nthis:\n  a \\<noteq> c \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. a = c\n 2. b = d", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> c \\<Longrightarrow> False", "show \"a = c\""], ["proof (prove)\nusing this:\n  a \\<noteq> c \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a = c", "by auto"], ["proof (state)\nthis:\n  a = c\n\ngoal (1 subgoal):\n 1. b = d", "with assms(3)"], ["proof (chain)\npicking this:\n  a * b0 + b = c * b0 + d\n  a = c", "show \"b = d\""], ["proof (prove)\nusing this:\n  a * b0 + b = c * b0 + d\n  a = c\n\ngoal (1 subgoal):\n 1. b = d", "by auto"], ["proof (state)\nthis:\n  b = d\n\ngoal:\nNo subgoals!", "qed"], ["", "locale prod_order_def =\n  order0: ord less_eq0 less0 +\n  order1: ord less_eq1 less1\n  for less_eq0 less0 less_eq1 less1\nbegin"], ["", "fun less :: \"'a \\<times> 'b \\<Rightarrow> 'a \\<times> 'b \\<Rightarrow> bool\" where\n  \"less (a,b) (c,d) \\<longleftrightarrow> less0 a c \\<and> less1 b d\""], ["", "fun less_eq :: \"'a \\<times> 'b \\<Rightarrow> 'a \\<times> 'b \\<Rightarrow> bool\" where\n  \"less_eq ab cd \\<longleftrightarrow> less ab cd \\<or> ab = cd\""], ["", "end"], ["", "locale prod_order =\n  prod_order_def less_eq0 less0 less_eq1 less1 +\n  order0: order less_eq0 less0 +\n  order1: order less_eq1 less1\n  for less_eq0 less0 less_eq1 less1\nbegin"], ["", "sublocale order less_eq less"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order local.less_eq local.less", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       local.less x y = (local.less_eq x y \\<and> \\<not> local.less_eq y x)\n 2. \\<And>x. local.less_eq x x\n 3. \\<And>x y z.\n       \\<lbrakk>local.less_eq x y; local.less_eq y z\\<rbrakk>\n       \\<Longrightarrow> local.less_eq x z\n 4. \\<And>x y.\n       \\<lbrakk>local.less_eq x y; local.less_eq y x\\<rbrakk>\n       \\<Longrightarrow> x = y", "qed fastforce+"], ["", "end"], ["", "locale option_order =\n  order0: order less_eq0 less0\n  for less_eq0 less0\nbegin"], ["", "fun less_eq_option :: \"'a option \\<Rightarrow> 'a option \\<Rightarrow> bool\" where\n  \"less_eq_option None _ \\<longleftrightarrow> True\"\n| \"less_eq_option (Some _) None \\<longleftrightarrow> False\"\n| \"less_eq_option (Some a) (Some b) \\<longleftrightarrow> less_eq0 a b\""], ["", "fun less_option :: \"'a option \\<Rightarrow> 'a option \\<Rightarrow> bool\" where\n  \"less_option ao bo \\<longleftrightarrow> less_eq_option ao bo \\<and> ao \\<noteq> bo\""], ["", "sublocale order less_eq_option less_option"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order less_eq_option less_option", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       less_option x y =\n       (less_eq_option x y \\<and> \\<not> less_eq_option y x)\n 2. \\<And>x. less_eq_option x x\n 3. \\<And>x y z.\n       \\<lbrakk>less_eq_option x y; less_eq_option y z\\<rbrakk>\n       \\<Longrightarrow> less_eq_option x z\n 4. \\<And>x y.\n       \\<lbrakk>less_eq_option x y; less_eq_option y x\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. less_option x y = (less_eq_option x y \\<and> \\<not> less_eq_option y x)", "by (cases x; cases y) auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. less_eq_option x x\n 2. \\<And>x y z.\n       \\<lbrakk>less_eq_option x y; less_eq_option y z\\<rbrakk>\n       \\<Longrightarrow> less_eq_option x z\n 3. \\<And>x y.\n       \\<lbrakk>less_eq_option x y; less_eq_option y x\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. less_eq_option x x", "by (cases x) auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>less_eq_option x y; less_eq_option y z\\<rbrakk>\n       \\<Longrightarrow> less_eq_option x z\n 2. \\<And>x y.\n       \\<lbrakk>less_eq_option x y; less_eq_option y x\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>less_eq_option x y; less_eq_option y z\\<rbrakk>\n    \\<Longrightarrow> less_eq_option x z", "by (cases x; cases y; cases z) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>less_eq_option x y; less_eq_option y x\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>less_eq_option x y; less_eq_option y x\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (cases x; cases y) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "datatype 'a bound = Bound (lower: 'a) (upper:'a)"], ["", "definition in_bound :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a bound \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"in_bound less_eq less bound x \\<equiv> case bound of Bound l r \\<Rightarrow> less_eq l x \\<and> less x r\" for less_eq less"], ["", "locale index_locale_def = ord less_eq less for less_eq less :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" +\n  fixes idx :: \"'a bound \\<Rightarrow> 'a \\<Rightarrow> nat\"\n    and size :: \"'a bound \\<Rightarrow> nat\""], ["", "locale index_locale = index_locale_def + idx_ord: order +\n  assumes idx_valid: \"in_bound less_eq less bound x \\<Longrightarrow> idx bound x < size bound\"\n    and idx_inj : \"\\<lbrakk>in_bound less_eq less bound x; in_bound less_eq less bound y; idx bound x = idx bound y\\<rbrakk> \\<Longrightarrow> x = y\""], ["", "locale prod_index_def =\n  index0: index_locale_def less_eq0 less0 idx0 size0 +\n  index1: index_locale_def less_eq1 less1 idx1 size1\n  for less_eq0 less0 idx0 size0 less_eq1 less1 idx1 size1\nbegin"], ["", "fun idx :: \"('a \\<times> 'b) bound \\<Rightarrow> 'a \\<times> 'b \\<Rightarrow> nat\" where\n  \"idx (Bound (l0, r0) (l1, r1)) (a, b) = (idx0 (Bound l0 l1) a) * (size1 (Bound r0 r1)) + idx1 (Bound r0 r1) b\""], ["", "fun size :: \"('a \\<times> 'b) bound \\<Rightarrow> nat\" where\n  \"size (Bound (l0, r0) (l1, r1)) = size0 (Bound l0 l1) * size1 (Bound r0 r1)\""], ["", "end"], ["", "locale prod_index = prod_index_def less_eq0 less0 idx0 size0 less_eq1 less1 idx1 size1 +\n  index0: index_locale less_eq0 less0 idx0 size0 +\n  index1: index_locale less_eq1 less1 idx1 size1\n  for less_eq0 less0 idx0 size0 less_eq1 less1 idx1 size1\nbegin"], ["", "sublocale prod_order less_eq0 less0 less_eq1 less1"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_order less_eq0 less0 less_eq1 less1", ".."], ["", "sublocale index_locale less_eq less idx size"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_locale local.less_eq local.less idx local.size", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bound x.\n       in_bound local.less_eq local.less bound x \\<Longrightarrow>\n       idx bound x < local.size bound\n 2. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bound x.\n       in_bound local.less_eq local.less bound x \\<Longrightarrow>\n       idx bound x < local.size bound\n 2. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix ab :: \"'a \\<times> 'b\" and bound :: \"('a \\<times> 'b) bound\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bound x.\n       in_bound local.less_eq local.less bound x \\<Longrightarrow>\n       idx bound x < local.size bound\n 2. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume bound: \"in_bound less_eq less bound ab\""], ["proof (state)\nthis:\n  in_bound local.less_eq local.less bound ab\n\ngoal (2 subgoals):\n 1. \\<And>bound x.\n       in_bound local.less_eq local.less bound x \\<Longrightarrow>\n       idx bound x < local.size bound\n 2. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "obtain a b l0 r0 l1 r1 where defs:\"ab = (a, b)\" \"bound = Bound (l0, r0) (l1, r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b l0 r0 l1 r1.\n        \\<lbrakk>ab = (a, b); bound = Bound (l0, r0) (l1, r1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ab; cases bound) auto"], ["proof (state)\nthis:\n  ab = (a, b)\n  bound = Bound (l0, r0) (l1, r1)\n\ngoal (2 subgoals):\n 1. \\<And>bound x.\n       in_bound local.less_eq local.less bound x \\<Longrightarrow>\n       idx bound x < local.size bound\n 2. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with bound"], ["proof (chain)\npicking this:\n  in_bound local.less_eq local.less bound ab\n  ab = (a, b)\n  bound = Bound (l0, r0) (l1, r1)", "have a: \"in_bound less_eq0 less0 (Bound l0 l1) a\" and b: \"in_bound less_eq1 less1 (Bound r0 r1) b\""], ["proof (prove)\nusing this:\n  in_bound local.less_eq local.less bound ab\n  ab = (a, b)\n  bound = Bound (l0, r0) (l1, r1)\n\ngoal (1 subgoal):\n 1. in_bound less_eq0 less0 (Bound l0 l1) a &&&\n    in_bound less_eq1 less1 (Bound r0 r1) b", "unfolding in_bound_def"], ["proof (prove)\nusing this:\n  case bound of\n  Bound l r \\<Rightarrow> local.less_eq l ab \\<and> local.less ab r\n  ab = (a, b)\n  bound = Bound (l0, r0) (l1, r1)\n\ngoal (1 subgoal):\n 1. case Bound l0 l1 of\n    Bound l r \\<Rightarrow> less_eq0 l a \\<and> less0 a r &&&\n    case Bound r0 r1 of\n    Bound l r \\<Rightarrow> less_eq1 l b \\<and> less1 b r", "by auto"], ["proof (state)\nthis:\n  in_bound less_eq0 less0 (Bound l0 l1) a\n  in_bound less_eq1 less1 (Bound r0 r1) b\n\ngoal (2 subgoals):\n 1. \\<And>bound x.\n       in_bound local.less_eq local.less bound x \\<Longrightarrow>\n       idx bound x < local.size bound\n 2. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"idx (Bound (l0, r0) (l1, r1)) (a, b) < size (Bound (l0, r0) (l1, r1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx (Bound (l0, r0) (l1, r1)) (a, b)\n    < local.size (Bound (l0, r0) (l1, r1))", "using index_mono[OF index0.idx_valid[OF a] index1.idx_valid[OF b]]"], ["proof (prove)\nusing this:\n  idx0 (Bound l0 l1) a * size1 (Bound r0 r1) + idx1 (Bound r0 r1) b\n  < size0 (Bound l0 l1) * size1 (Bound r0 r1)\n\ngoal (1 subgoal):\n 1. idx (Bound (l0, r0) (l1, r1)) (a, b)\n    < local.size (Bound (l0, r0) (l1, r1))", "by auto"], ["proof (state)\nthis:\n  idx (Bound (l0, r0) (l1, r1)) (a, b)\n  < local.size (Bound (l0, r0) (l1, r1))\n\ngoal (2 subgoals):\n 1. \\<And>bound x.\n       in_bound local.less_eq local.less bound x \\<Longrightarrow>\n       idx bound x < local.size bound\n 2. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"idx bound ab < size bound\""], ["proof (prove)\nusing this:\n  idx (Bound (l0, r0) (l1, r1)) (a, b)\n  < local.size (Bound (l0, r0) (l1, r1))\n\ngoal (1 subgoal):\n 1. idx bound ab < local.size bound", "unfolding defs"], ["proof (prove)\nusing this:\n  idx (Bound (l0, r0) (l1, r1)) (a, b)\n  < local.size (Bound (l0, r0) (l1, r1))\n\ngoal (1 subgoal):\n 1. idx (Bound (l0, r0) (l1, r1)) (a, b)\n    < local.size (Bound (l0, r0) (l1, r1))", "."], ["proof (state)\nthis:\n  idx bound ab < local.size bound\n\ngoal (1 subgoal):\n 1. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "}"], ["proof (state)\nthis:\n  in_bound local.less_eq local.less ?bound3 ?ab3 \\<Longrightarrow>\n  idx ?bound3 ?ab3 < local.size ?bound3\n\ngoal (1 subgoal):\n 1. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "{"], ["proof (state)\nthis:\n  in_bound local.less_eq local.less ?bound3 ?ab3 \\<Longrightarrow>\n  idx ?bound3 ?ab3 < local.size ?bound3\n\ngoal (1 subgoal):\n 1. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix ab cd :: \"'a \\<times> 'b\" and bound :: \"('a \\<times> 'b) bound\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume bound: \"in_bound less_eq less bound ab\" \"in_bound less_eq less bound cd\"\n      and idx_eq: \"idx bound ab = idx bound cd\""], ["proof (state)\nthis:\n  in_bound local.less_eq local.less bound ab\n  in_bound local.less_eq local.less bound cd\n  idx bound ab = idx bound cd\n\ngoal (1 subgoal):\n 1. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "obtain a b c d l0 r0 l1 r1 where\n      defs: \"ab = (a, b)\" \"cd = (c, d)\" \"bound = Bound (l0, l1) (r0, r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b c d l0 l1 r0 r1.\n        \\<lbrakk>ab = (a, b); cd = (c, d);\n         bound = Bound (l0, l1) (r0, r1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ab; cases cd; cases bound) auto"], ["proof (state)\nthis:\n  ab = (a, b)\n  cd = (c, d)\n  bound = Bound (l0, l1) (r0, r1)\n\ngoal (1 subgoal):\n 1. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from defs bound"], ["proof (chain)\npicking this:\n  ab = (a, b)\n  cd = (c, d)\n  bound = Bound (l0, l1) (r0, r1)\n  in_bound local.less_eq local.less bound ab\n  in_bound local.less_eq local.less bound cd", "have\n          a: \"in_bound less_eq0 less0 (Bound l0 r0) a\"\n      and b: \"in_bound less_eq1 less1 (Bound l1 r1) b\"\n      and c: \"in_bound less_eq0 less0 (Bound l0 r0) c\"\n      and d: \"in_bound less_eq1 less1 (Bound l1 r1) d\""], ["proof (prove)\nusing this:\n  ab = (a, b)\n  cd = (c, d)\n  bound = Bound (l0, l1) (r0, r1)\n  in_bound local.less_eq local.less bound ab\n  in_bound local.less_eq local.less bound cd\n\ngoal (1 subgoal):\n 1. (in_bound less_eq0 less0 (Bound l0 r0) a &&&\n     in_bound less_eq1 less1 (Bound l1 r1) b) &&&\n    in_bound less_eq0 less0 (Bound l0 r0) c &&&\n    in_bound less_eq1 less1 (Bound l1 r1) d", "unfolding in_bound_def"], ["proof (prove)\nusing this:\n  ab = (a, b)\n  cd = (c, d)\n  bound = Bound (l0, l1) (r0, r1)\n  case bound of\n  Bound l r \\<Rightarrow> local.less_eq l ab \\<and> local.less ab r\n  case bound of\n  Bound l r \\<Rightarrow> local.less_eq l cd \\<and> local.less cd r\n\ngoal (1 subgoal):\n 1. (case Bound l0 r0 of\n     Bound l r \\<Rightarrow> less_eq0 l a \\<and> less0 a r &&&\n     case Bound l1 r1 of\n     Bound l r \\<Rightarrow> less_eq1 l b \\<and> less1 b r) &&&\n    case Bound l0 r0 of\n    Bound l r \\<Rightarrow> less_eq0 l c \\<and> less0 c r &&&\n    case Bound l1 r1 of\n    Bound l r \\<Rightarrow> less_eq1 l d \\<and> less1 d r", "by auto"], ["proof (state)\nthis:\n  in_bound less_eq0 less0 (Bound l0 r0) a\n  in_bound less_eq1 less1 (Bound l1 r1) b\n  in_bound less_eq0 less0 (Bound l0 r0) c\n  in_bound less_eq1 less1 (Bound l1 r1) d\n\ngoal (1 subgoal):\n 1. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from index_eq_iff[OF index1.idx_valid[OF b] index1.idx_valid[OF d] idx_eq[unfolded defs, simplified]]"], ["proof (chain)\npicking this:\n  idx0 (Bound l0 r0) a = idx0 (Bound l0 r0) c \\<and>\n  idx1 (Bound l1 r1) b = idx1 (Bound l1 r1) d", "have ac: \"idx0 (Bound l0 r0) a = idx0 (Bound l0 r0) c\" and bd: \"idx1 (Bound l1 r1) b = idx1 (Bound l1 r1) d\""], ["proof (prove)\nusing this:\n  idx0 (Bound l0 r0) a = idx0 (Bound l0 r0) c \\<and>\n  idx1 (Bound l1 r1) b = idx1 (Bound l1 r1) d\n\ngoal (1 subgoal):\n 1. idx0 (Bound l0 r0) a = idx0 (Bound l0 r0) c &&&\n    idx1 (Bound l1 r1) b = idx1 (Bound l1 r1) d", "by auto"], ["proof (state)\nthis:\n  idx0 (Bound l0 r0) a = idx0 (Bound l0 r0) c\n  idx1 (Bound l1 r1) b = idx1 (Bound l1 r1) d\n\ngoal (1 subgoal):\n 1. \\<And>bound x y.\n       \\<lbrakk>in_bound local.less_eq local.less bound x;\n        in_bound local.less_eq local.less bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"ab = cd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ab = cd", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) = (c, d)", "using index0.idx_inj[OF a c ac] index1.idx_inj[OF b d bd]"], ["proof (prove)\nusing this:\n  a = c\n  b = d\n\ngoal (1 subgoal):\n 1. (a, b) = (c, d)", "by auto"], ["proof (state)\nthis:\n  ab = cd\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>in_bound local.less_eq local.less ?bound3 ?ab3;\n   in_bound local.less_eq local.less ?bound3 ?cd3;\n   idx ?bound3 ?ab3 = idx ?bound3 ?cd3\\<rbrakk>\n  \\<Longrightarrow> ?ab3 = ?cd3\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale option_index =\n  index0: index_locale less_eq0 less0 idx0 size0\n  for less_eq0 less0 idx0 size0\nbegin"], ["", "fun idx :: \"'a option bound \\<Rightarrow> 'a option \\<Rightarrow> nat\" where\n  \"idx (Bound (Some l) (Some r)) (Some a) = idx0 (Bound l r) a\"\n| \"idx _ _ = undefined\""], ["", "(* option is NOT an index *)"], ["", "end"], ["", "locale nat_index_def = ord \"(\\<le>) :: nat \\<Rightarrow> nat \\<Rightarrow> bool\" \"(<)\"\nbegin"], ["", "fun idx :: \"nat bound \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"idx (Bound l _) i = i - l\""], ["", "fun size :: \"nat bound \\<Rightarrow> nat\" where\n  \"size (Bound l r) = r - l\""], ["", "sublocale index_locale \"(\\<le>)\" \"(<)\" idx size"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_locale (\\<le>) (<) idx local.size", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bound x.\n       in_bound (\\<le>) (<) bound x \\<Longrightarrow>\n       idx bound x < local.size bound\n 2. \\<And>bound x y.\n       \\<lbrakk>in_bound (\\<le>) (<) bound x; in_bound (\\<le>) (<) bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "qed (auto simp: in_bound_def split: bound.splits)"], ["", "end"], ["", "locale nat_index = nat_index_def + order \"(\\<le>) :: nat \\<Rightarrow> nat \\<Rightarrow> bool\" \"(<)\""], ["", "locale int_index_def = ord \"(\\<le>) :: int \\<Rightarrow> int \\<Rightarrow> bool\" \"(<)\"\nbegin"], ["", "fun idx :: \"int bound \\<Rightarrow> int \\<Rightarrow> nat\" where\n  \"idx (Bound l _) i = nat (i - l)\""], ["", "fun size :: \"int bound \\<Rightarrow> nat\" where\n  \"size (Bound l r) = nat (r - l)\""], ["", "sublocale index_locale \"(\\<le>)\" \"(<)\" idx size"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_locale (\\<le>) (<) idx local.size", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bound x.\n       in_bound (\\<le>) (<) bound x \\<Longrightarrow>\n       idx bound x < local.size bound\n 2. \\<And>bound x y.\n       \\<lbrakk>in_bound (\\<le>) (<) bound x; in_bound (\\<le>) (<) bound y;\n        idx bound x = idx bound y\\<rbrakk>\n       \\<Longrightarrow> x = y", "qed (auto simp: in_bound_def split: bound.splits)"], ["", "end"], ["", "locale int_index = int_index_def + order \"(\\<le>) :: int \\<Rightarrow> int \\<Rightarrow> bool\" \"(<)\""], ["", "class index =\n  fixes less_eq less :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\n    and idx :: \"'a bound \\<Rightarrow> 'a \\<Rightarrow> nat\"\n    and size :: \"'a bound \\<Rightarrow> nat\"\n  assumes is_locale: \"index_locale less_eq less idx size\""], ["", "locale bounded_index =\n  fixes bound :: \"'k :: index bound\"\nbegin"], ["", "interpretation index_locale less_eq less idx size"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_locale index_class.less_eq index_class.less idx index_class.size", "using is_locale"], ["proof (prove)\nusing this:\n  index_locale index_class.less_eq index_class.less idx index_class.size\n\ngoal (1 subgoal):\n 1. index_locale index_class.less_eq index_class.less idx index_class.size", "."], ["", "definition \"size \\<equiv> index_class.size bound\" for size"], ["", "definition \"checked_idx x \\<equiv> if in_bound less_eq less bound x then idx bound x else size\""], ["", "lemma checked_idx_injective:\n  \"injective size checked_idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective local.size checked_idx", "unfolding injective_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       checked_idx a = checked_idx b \\<and>\n       checked_idx a < local.size \\<and>\n       checked_idx b < local.size \\<longrightarrow>\n       a = b", "unfolding checked_idx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       (if in_bound index_class.less_eq index_class.less bound a\n        then idx bound a else local.size) =\n       (if in_bound index_class.less_eq index_class.less bound b\n        then idx bound b else local.size) \\<and>\n       (if in_bound index_class.less_eq index_class.less bound a\n        then idx bound a else local.size)\n       < local.size \\<and>\n       (if in_bound index_class.less_eq index_class.less bound b\n        then idx bound b else local.size)\n       < local.size \\<longrightarrow>\n       a = b", "using idx_inj"], ["proof (prove)\nusing this:\n  \\<lbrakk>in_bound index_class.less_eq index_class.less ?bound ?x;\n   in_bound index_class.less_eq index_class.less ?bound ?y;\n   idx ?bound ?x = idx ?bound ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       (if in_bound index_class.less_eq index_class.less bound a\n        then idx bound a else local.size) =\n       (if in_bound index_class.less_eq index_class.less bound b\n        then idx bound b else local.size) \\<and>\n       (if in_bound index_class.less_eq index_class.less bound a\n        then idx bound a else local.size)\n       < local.size \\<and>\n       (if in_bound index_class.less_eq index_class.less bound b\n        then idx bound b else local.size)\n       < local.size \\<longrightarrow>\n       a = b", "by (fastforce split: if_splits)"], ["", "end"], ["", "instantiation nat :: index\nbegin"], ["", "interpretation nat_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_index", ".."], ["", "thm index_locale_axioms"], ["", "definition [simp]: \"less_eq_nat \\<equiv> (\\<le>) :: nat \\<Rightarrow> nat \\<Rightarrow> bool\""], ["", "definition [simp]: \"less_nat \\<equiv> (<) :: nat \\<Rightarrow> nat \\<Rightarrow> bool\""], ["", "definition [simp]: \"idx_nat \\<equiv> idx\""], ["", "definition size_nat where [simp]: \"size_nat \\<equiv> size\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, index_class)", "by (standard, simp, fact index_locale_axioms)"], ["", "end"], ["", "instantiation int :: index\nbegin"], ["", "interpretation int_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_index", ".."], ["", "thm index_locale_axioms"], ["", "definition [simp]: \"less_eq_int \\<equiv> (\\<le>) :: int \\<Rightarrow> int \\<Rightarrow> bool\""], ["", "definition [simp]: \"less_int \\<equiv> (<) :: int \\<Rightarrow> int \\<Rightarrow> bool\""], ["", "definition [simp]: \"idx_int \\<equiv> idx\""], ["", "definition [simp]: \"size_int \\<equiv> size\""], ["", "lemmas size_int = size.simps"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, index_class)", "by (standard, simp, fact index_locale_axioms)"], ["", "end"], ["", "instantiation prod :: (index, index) index\nbegin"], ["", "interpretation prod_index\n  \"less_eq::'a \\<Rightarrow> 'a \\<Rightarrow> bool\" less idx size\n  \"less_eq::'b \\<Rightarrow> 'b \\<Rightarrow> bool\" less idx size"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_index index_class.less_eq index_class.less idx index_class.size\n     index_class.less_eq index_class.less idx index_class.size", "by (rule prod_index.intro; fact is_locale)"], ["", "thm index_locale_axioms"], ["", "definition [simp]: \"less_eq_prod \\<equiv> less_eq\""], ["", "definition [simp]: \"less_prod \\<equiv> less\""], ["", "definition [simp]: \"idx_prod \\<equiv> idx\""], ["", "definition [simp]: \"size_prod \\<equiv> size\" for size_prod"], ["", "lemmas size_prod = size.simps"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, index_class)", "by (standard, simp, fact index_locale_axioms)"], ["", "end"], ["", "lemma bound_int_simp[code]:\n  \"bounded_index.size (Bound (l1, l2) (u1, u2)) = nat (u1 - l1) * nat (u2 - l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_index.size (Bound (l1, l2) (u1, u2)) =\n    nat (u1 - l1) * nat (u2 - l2)", "by (simp add: bounded_index.size_def,unfold size_int_def[symmetric] size_prod,simp add: size_int)"], ["", "lemmas [code] = bounded_index.size_def bounded_index.checked_idx_def"], ["", "lemmas [code] =\n  nat_index_def.size.simps\n  nat_index_def.idx.simps"], ["", "lemmas [code] =\n  int_index_def.size.simps\n  int_index_def.idx.simps"], ["", "lemmas [code] =\n  prod_index_def.size.simps\n  prod_index_def.idx.simps"], ["", "lemmas [code] =\n  prod_order_def.less_eq.simps\n  prod_order_def.less.simps"], ["", "lemmas index_size_defs =\n  prod_index_def.size.simps int_index_def.size.simps nat_index_def.size.simps bounded_index.size_def"], ["", "end"]]}