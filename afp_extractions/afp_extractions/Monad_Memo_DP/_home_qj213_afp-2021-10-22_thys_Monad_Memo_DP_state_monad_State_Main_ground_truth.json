{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/state_monad/State_Main.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma ifT_cong:\n  assumes \"b = c\" \"c \\<Longrightarrow> x = u\" \"\\<not>c \\<Longrightarrow> y = v\"\n  shows \"State_Monad_Ext.if\\<^sub>T \\<langle>b\\<rangle> x y = State_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> u v\"", "lemma return_app_return_cong:\n  assumes \"f x = g y\"\n  shows \"\\<langle>f\\<rangle> . \\<langle>x\\<rangle> = \\<langle>g\\<rangle> . \\<langle>y\\<rangle>\"", "lemmas [fundef_cong] =\n  return_app_return_cong\n  ifT_cong", "lemma (in dp_consistency) comp\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R1 ===>\\<^sub>T R2) ===>\\<^sub>T (R0 ===>\\<^sub>T R1) ===>\\<^sub>T (R0 ===>\\<^sub>T R2)) comp comp\\<^sub>T\"", "lemma (in dp_consistency) map\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R0 ===>\\<^sub>T R1) ===>\\<^sub>T list_all2 R0 ===>\\<^sub>T list_all2 R1) map map\\<^sub>T\"", "lemma (in dp_consistency) fold\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) ===>\\<^sub>T list_all2 R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) fold fold\\<^sub>T\"", "lemma mapT_cong:\n  assumes \"xs = ys\" \"\\<And>x. x\\<in>set ys \\<Longrightarrow> f x = g x\"\n  shows \"map\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> = map\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>\"", "lemma foldT_cong:\n  assumes \"xs = ys\" \"\\<And>x. x\\<in>set ys \\<Longrightarrow> f x = g x\"\n  shows \"fold\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> = fold\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>\"", "lemma abs_unit_cong:\n  (* for lazy checkmem *)\n  assumes \"x = y\"\n  shows \"(\\<lambda>_::unit. x) = (\\<lambda>_. y)\"", "lemmas [fundef_cong] =\n  return_app_return_cong\n  ifT_cong\n  mapT_cong\n  foldT_cong\n  abs_unit_cong", "lemma if\\<^sub>T_cong2:\n  assumes \"Rel (=) b c\" \"c \\<Longrightarrow> Rel (crel_vs R) x x\\<^sub>T\" \"\\<not>c \\<Longrightarrow> Rel (crel_vs R) y y\\<^sub>T\"\n  shows \"Rel (crel_vs R) (if (Wrap b) then x else y) (State_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> x\\<^sub>T y\\<^sub>T)\"", "lemma map\\<^sub>T_cong2:\n  assumes\n    \"is_equality R\"\n    \"Rel R xs ys\"\n    \"\\<And>x. x\\<in>set ys \\<Longrightarrow> Rel (crel_vs S) (f x) (f\\<^sub>T' x)\"\n  shows \"Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap xs)) (map\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)\"", "lemma fold\\<^sub>T_cong2:\n  assumes\n    \"is_equality R\"\n    \"Rel R xs ys\"\n    \"\\<And>x. x\\<in>set ys \\<Longrightarrow> Rel (crel_vs (S ===> crel_vs S)) (f x) (f\\<^sub>T' x)\"\n  shows\n    \"Rel (crel_vs (S ===> crel_vs S)) (fold f xs) (fold\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)\"", "lemma refl2:\n  \"is_equality R \\<Longrightarrow> Rel R x x\"", "lemma rel_fun2:\n  assumes \"is_equality R0\" \"\\<And>x. Rel R1 (f x) (g x)\"\n  shows \"Rel (rel_fun R0 R1) f g\"", "lemma crel_vs_return_app_return:\n  assumes \"Rel R (f x) (g x)\"\n  shows \"Rel R (App (Wrap f) (Wrap x)) (\\<langle>g\\<rangle> . \\<langle>x\\<rangle>)\"", "lemma option_case_cong':\n\"Rel (=) option' option \\<Longrightarrow>\n(option = None \\<Longrightarrow> Rel R f1 g1) \\<Longrightarrow>\n(\\<And>x2. option = Some x2 \\<Longrightarrow> Rel R (f2 x2) (g2 x2)) \\<Longrightarrow>\nRel R (case option' of None \\<Rightarrow> f1 | Some x2 \\<Rightarrow> f2 x2)\n(case option of None \\<Rightarrow> g1 | Some x2 \\<Rightarrow> g2 x2)\"", "lemma prod_case_cong': fixes prod prod' shows\n\"Rel (=) prod prod' \\<Longrightarrow>\n(\\<And>x1 x2. prod' = (x1, x2) \\<Longrightarrow> Rel R (f x1 x2) (g x1 x2)) \\<Longrightarrow>\nRel R (case prod of (x1, x2) \\<Rightarrow> f x1 x2)\n(case prod' of (x1, x2) \\<Rightarrow> g x1 x2)\"", "lemma nat_case_cong': fixes nat nat' shows\n\"Rel (=) nat nat' \\<Longrightarrow>\n(nat' = 0 \\<Longrightarrow> Rel R f1 g1) \\<Longrightarrow>\n(\\<And>x2. nat' = Suc x2 \\<Longrightarrow> Rel R (f2 x2) (g2 x2)) \\<Longrightarrow>\nRel R (case nat of 0 \\<Rightarrow> f1 | Suc x2 \\<Rightarrow> f2 x2) (case nat' of 0 \\<Rightarrow> g1 | Suc x2 \\<Rightarrow> g2 x2)\"", "lemmas [dp_match_rule] =\n  prod_case_cong'\n  option_case_cong'\n  nat_case_cong'", "lemmas [dp_match_rule] =\n  crel_vs_return_app_return", "lemmas [dp_match_rule] =\n  map\\<^sub>T_cong2\n  fold\\<^sub>T_cong2\n  if\\<^sub>T_cong2", "lemmas [dp_match_rule] =\n  crel_vs_return\n  crel_vs_fun_app\n  refl2\n  rel_fun2", "lemmas [code_unfold] =\n  state_mem_defs.checkmem_checkmem'[symmetric]\n  state_mem_defs.checkmem'_def\n  map\\<^sub>T_def"], "translations": [["", "lemma ifT_cong:\n  assumes \"b = c\" \"c \\<Longrightarrow> x = u\" \"\\<not>c \\<Longrightarrow> y = v\"\n  shows \"State_Monad_Ext.if\\<^sub>T \\<langle>b\\<rangle> x y = State_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad_Ext.if\\<^sub>T \\<langle>b\\<rangle> x y =\n    State_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> u v", "unfolding State_Monad_Ext.if\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>b\\<rangle> \\<bind> (\\<lambda>b. if b then x else y) =\n    \\<langle>c\\<rangle> \\<bind> (\\<lambda>b. if b then u else v)", "unfolding bind_left_identity"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then x else y) = (if c then u else v)", "using if_cong[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>c \\<Longrightarrow> c;\n   \\<not> c \\<Longrightarrow> \\<not> c\\<rbrakk>\n  \\<Longrightarrow> (if b then x else y) = (if c then u else v)\n\ngoal (1 subgoal):\n 1. (if b then x else y) = (if c then u else v)", "."], ["", "lemma return_app_return_cong:\n  assumes \"f x = g y\"\n  shows \"\\<langle>f\\<rangle> . \\<langle>x\\<rangle> = \\<langle>g\\<rangle> . \\<langle>y\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>f\\<rangle> . \\<langle>x\\<rangle> =\n    \\<langle>g\\<rangle> . \\<langle>y\\<rangle>", "unfolding State_Monad_Ext.return_app_return_meta assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. g y = g y", ".."], ["", "lemmas [fundef_cong] =\n  return_app_return_cong\n  ifT_cong"], ["", "end"], ["", "memoize_fun comp\\<^sub>T: comp"], ["", "monadifies (state) comp_def"], ["", "lemma (in dp_consistency) comp\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R1 ===>\\<^sub>T R2) ===>\\<^sub>T (R0 ===>\\<^sub>T R1) ===>\\<^sub>T (R0 ===>\\<^sub>T R2)) comp comp\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs\n     ((R1 ===>\\<^sub>T R2) ===>\\<^sub>T\n      (R0 ===>\\<^sub>T R1) ===>\\<^sub>T R0 ===>\\<^sub>T R2)\n     (\\<circ>) comp\\<^sub>T", "apply memoize_combinator_init"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x uu_ xa uua_.\n       \\<lbrakk>(R1 ===>\\<^sub>T R2) x uu_;\n        (R0 ===>\\<^sub>T R1) xa uua_\\<rbrakk>\n       \\<Longrightarrow> crel_vs (R0 ===>\\<^sub>T R2) (x \\<circ> xa)\n                          (comp\\<^sub>T' uu_ uua_)", "subgoal premises IH [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (R0 ===>\\<^sub>T R2) (x_ \\<circ> xa_) (comp\\<^sub>T' uu_ uua_)", "by memoize_unfold_defs transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "memoize_fun map\\<^sub>T: map"], ["", "monadifies (state) list.map"], ["", "lemma (in dp_consistency) map\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R0 ===>\\<^sub>T R1) ===>\\<^sub>T list_all2 R0 ===>\\<^sub>T list_all2 R1) map map\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs\n     ((R0 ===>\\<^sub>T R1) ===>\\<^sub>T\n      list_all2 R0 ===>\\<^sub>T list_all2 R1)\n     map map\\<^sub>T", "apply memoize_combinator_init"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x uu_ xa uua_.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1) x uu_; list_all2 R0 xa uua_\\<rbrakk>\n       \\<Longrightarrow> crel_vs (list_all2 R1) (map x xa)\n                          (map\\<^sub>T' uu_ uua_)", "apply (erule list_all2_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x uu_ xa _.\n       (R0 ===>\\<^sub>T R1) x uu_ \\<Longrightarrow>\n       crel_vs (list_all2 R1) (map x []) (map\\<^sub>T' uu_ [])\n 2. \\<And>x uu_ xa _ xb xs y ys.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1) x uu_; R0 xb y; list_all2 R0 xs ys;\n        crel_vs (list_all2 R1) (map x xs) (map\\<^sub>T' uu_ ys)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (list_all2 R1) (map x (xb # xs))\n                          (map\\<^sub>T' uu_ (y # ys))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 R1) (map x_ []) (map\\<^sub>T' uu_ [])", "by memoize_unfold_defs transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x uu_ xa _ xb xs y ys.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1) x uu_; R0 xb y; list_all2 R0 xs ys;\n        crel_vs (list_all2 R1) (map x xs) (map\\<^sub>T' uu_ ys)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (list_all2 R1) (map x (xb # xs))\n                          (map\\<^sub>T' uu_ (y # ys))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 R1) (map x_ (xb_ # xs_))\n     (map\\<^sub>T' uu_ (y_ # ys_))", "by memoize_unfold_defs transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "memoize_fun fold\\<^sub>T: fold"], ["", "monadifies (state) fold.simps"], ["", "lemma (in dp_consistency) fold\\<^sub>T_transfer[transfer_rule]:\n  \"crel_vs ((R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) ===>\\<^sub>T list_all2 R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) fold fold\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs\n     ((R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) ===>\\<^sub>T\n      list_all2 R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1)\n     fold fold\\<^sub>T", "apply memoize_combinator_init"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x uu_ xa uua_.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) x uu_;\n        list_all2 R0 xa uua_\\<rbrakk>\n       \\<Longrightarrow> crel_vs (R1 ===>\\<^sub>T R1) (fold x xa)\n                          (fold\\<^sub>T' uu_ uua_)", "apply (erule list_all2_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x uu_ xa _.\n       (R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) x uu_ \\<Longrightarrow>\n       crel_vs (R1 ===>\\<^sub>T R1) (fold x []) (fold\\<^sub>T' uu_ [])\n 2. \\<And>x uu_ xa _ xb xs y ys.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) x uu_; R0 xb y;\n        list_all2 R0 xs ys;\n        crel_vs (R1 ===>\\<^sub>T R1) (fold x xs)\n         (fold\\<^sub>T' uu_ ys)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (R1 ===>\\<^sub>T R1) (fold x (xb # xs))\n                          (fold\\<^sub>T' uu_ (y # ys))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (R1 ===>\\<^sub>T R1) (fold x_ []) (fold\\<^sub>T' uu_ [])", "by memoize_unfold_defs transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x uu_ xa _ xb xs y ys.\n       \\<lbrakk>(R0 ===>\\<^sub>T R1 ===>\\<^sub>T R1) x uu_; R0 xb y;\n        list_all2 R0 xs ys;\n        crel_vs (R1 ===>\\<^sub>T R1) (fold x xs)\n         (fold\\<^sub>T' uu_ ys)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (R1 ===>\\<^sub>T R1) (fold x (xb # xs))\n                          (fold\\<^sub>T' uu_ (y # ys))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (R1 ===>\\<^sub>T R1) (fold x_ (xb_ # xs_))\n     (fold\\<^sub>T' uu_ (y_ # ys_))", "by memoize_unfold_defs transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context includes state_monad_syntax begin"], ["", "thm map_cong"], ["", "lemma mapT_cong:\n  assumes \"xs = ys\" \"\\<And>x. x\\<in>set ys \\<Longrightarrow> f x = g x\"\n  shows \"map\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> = map\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> =\n    map\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>", "unfolding map\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>xs\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "unfolding assms(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>ys\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "using assms(2)"], ["proof (prove)\nusing this:\n  ?x \\<in> set ys \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>ys\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "by (induction ys) (auto simp: State_Monad_Ext.return_app_return_meta)"], ["", "thm fold_cong"], ["", "lemma foldT_cong:\n  assumes \"xs = ys\" \"\\<And>x. x\\<in>set ys \\<Longrightarrow> f x = g x\"\n  shows \"fold\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> = fold\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\\<^sub>T . \\<langle>f\\<rangle> . \\<langle>xs\\<rangle> =\n    fold\\<^sub>T . \\<langle>g\\<rangle> . \\<langle>ys\\<rangle>", "unfolding fold\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>xs\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "unfolding assms(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>ys\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "using assms(2)"], ["proof (prove)\nusing this:\n  ?x \\<in> set ys \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>f\\<rangle> .\n    \\<langle>ys\\<rangle> =\n    \\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n    \\<langle>g\\<rangle> .\n    \\<langle>ys\\<rangle>", "by (induction ys) (auto simp: State_Monad_Ext.return_app_return_meta)"], ["", "lemma abs_unit_cong:\n  (* for lazy checkmem *)\n  assumes \"x = y\"\n  shows \"(\\<lambda>_::unit. x) = (\\<lambda>_. y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. x) = (\\<lambda>_. y)", "using assms"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. (\\<lambda>_. x) = (\\<lambda>_. y)", ".."], ["", "lemmas [fundef_cong] =\n  return_app_return_cong\n  ifT_cong\n  mapT_cong\n  foldT_cong\n  abs_unit_cong"], ["", "end"], ["", "context dp_consistency begin"], ["", "context includes lifting_syntax state_monad_syntax begin"], ["", "named_theorems dp_match_rule"], ["", "thm if_cong"], ["", "lemma if\\<^sub>T_cong2:\n  assumes \"Rel (=) b c\" \"c \\<Longrightarrow> Rel (crel_vs R) x x\\<^sub>T\" \"\\<not>c \\<Longrightarrow> Rel (crel_vs R) y y\\<^sub>T\"\n  shows \"Rel (crel_vs R) (if (Wrap b) then x else y) (State_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> x\\<^sub>T y\\<^sub>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs R) (if Wrap b then x else y)\n     (State_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> x\\<^sub>T y\\<^sub>T)", "using assms"], ["proof (prove)\nusing this:\n  Rel (=) b c\n  c \\<Longrightarrow> Rel (crel_vs R) x x\\<^sub>T\n  \\<not> c \\<Longrightarrow> Rel (crel_vs R) y y\\<^sub>T\n\ngoal (1 subgoal):\n 1. Rel (crel_vs R) (if Wrap b then x else y)\n     (State_Monad_Ext.if\\<^sub>T \\<langle>c\\<rangle> x\\<^sub>T y\\<^sub>T)", "unfolding State_Monad_Ext.if\\<^sub>T_def bind_left_identity Rel_def Wrap_def"], ["proof (prove)\nusing this:\n  b = c\n  c \\<Longrightarrow> crel_vs R x x\\<^sub>T\n  \\<not> c \\<Longrightarrow> crel_vs R y y\\<^sub>T\n\ngoal (1 subgoal):\n 1. crel_vs R (if b then x else y) (if c then x\\<^sub>T else y\\<^sub>T)", "by (auto split: if_split)"], ["", "lemma map\\<^sub>T_cong2:\n  assumes\n    \"is_equality R\"\n    \"Rel R xs ys\"\n    \"\\<And>x. x\\<in>set ys \\<Longrightarrow> Rel (crel_vs S) (f x) (f\\<^sub>T' x)\"\n  shows \"Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap xs)) (map\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap xs))\n     (map\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)", "unfolding map\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap xs))\n     (\\<langle>\\<lambda>uu_. \\<langle>map\\<^sub>T' uu_\\<rangle>\\<rangle> .\n      \\<langle>f\\<^sub>T'\\<rangle> .\n      \\<langle>ys\\<rangle>)", "unfolding State_Monad_Ext.return_app_return_meta"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap xs))\n     (map\\<^sub>T' f\\<^sub>T' ys)", "unfolding assms(2)[unfolded Rel_def assms(1)[unfolded is_equality_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap ys))\n     (map\\<^sub>T' f\\<^sub>T' ys)", "using assms(3)"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set ys \\<Longrightarrow>\n  Rel (crel_vs S) (f ?x2) (f\\<^sub>T' ?x2)\n\ngoal (1 subgoal):\n 1. Rel (crel_vs (list_all2 S)) (App (App map (Wrap f)) (Wrap ys))\n     (map\\<^sub>T' f\\<^sub>T' ys)", "unfolding Rel_def Wrap_def App_def"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set ys \\<Longrightarrow> crel_vs S (f ?x2) (f\\<^sub>T' ?x2)\n\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S) (map f ys) (map\\<^sub>T' f\\<^sub>T' ys)", "apply (induction ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        crel_vs S (f x) (f\\<^sub>T' x)) \\<Longrightarrow>\n    crel_vs (list_all2 S) (map f []) (map\\<^sub>T' f\\<^sub>T' [])\n 2. \\<And>a ys.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ys \\<Longrightarrow>\n                    crel_vs S (f x) (f\\<^sub>T' x)) \\<Longrightarrow>\n                crel_vs (list_all2 S) (map f ys)\n                 (map\\<^sub>T' f\\<^sub>T' ys);\n        \\<And>x.\n           x \\<in> set (a # ys) \\<Longrightarrow>\n           crel_vs S (f x) (f\\<^sub>T' x)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (list_all2 S) (map f (a # ys))\n                          (map\\<^sub>T' f\\<^sub>T' (a # ys))", "subgoal premises"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S) (map f []) (map\\<^sub>T' f\\<^sub>T' [])", "by (memoize_unfold_defs (state) map) transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ys \\<Longrightarrow>\n                    crel_vs S (f x) (f\\<^sub>T' x)) \\<Longrightarrow>\n                crel_vs (list_all2 S) (map f ys)\n                 (map\\<^sub>T' f\\<^sub>T' ys);\n        \\<And>x.\n           x \\<in> set (a # ys) \\<Longrightarrow>\n           crel_vs S (f x) (f\\<^sub>T' x)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (list_all2 S) (map f (a # ys))\n                          (map\\<^sub>T' f\\<^sub>T' (a # ys))", "subgoal premises prems for a ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S) (map f (a # ys))\n     (map\\<^sub>T' f\\<^sub>T' (a # ys))", "apply (memoize_unfold_defs (state) map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S)\n     (App (App (Wrap (\\<lambda>x. Wrap (\\<lambda>xa. Wrap (x # xa))))\n            (App (Wrap f) (Wrap a)))\n       (map f ys))\n     (\\<langle>\\<lambda>a.\n                  \\<langle>\\<lambda>b.\n                              \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n      (\\<langle>f\\<^sub>T'\\<rangle> . \\<langle>a\\<rangle>) .\n      (map\\<^sub>T' f\\<^sub>T' ys))", "apply (unfold State_Monad_Ext.return_app_return_meta Wrap_App_Wrap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S)\n     (App (App (Wrap (\\<lambda>x. Wrap (\\<lambda>xa. Wrap (x # xa)))) (f a))\n       (map f ys))\n     (\\<langle>\\<lambda>a.\n                  \\<langle>\\<lambda>b.\n                              \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n      (f\\<^sub>T' a) .\n      (map\\<^sub>T' f\\<^sub>T' ys))", "supply [transfer_rule] =\n      prems(2)[OF list.set_intros(1)]\n      prems(1)[OF prems(2)[OF list.set_intros(2)], simplified]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (list_all2 S)\n     (App (App (Wrap (\\<lambda>x. Wrap (\\<lambda>xa. Wrap (x # xa)))) (f a))\n       (map f ys))\n     (\\<langle>\\<lambda>a.\n                  \\<langle>\\<lambda>b.\n                              \\<langle>a # b\\<rangle>\\<rangle>\\<rangle> .\n      (f\\<^sub>T' a) .\n      (map\\<^sub>T' f\\<^sub>T' ys))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fold\\<^sub>T_cong2:\n  assumes\n    \"is_equality R\"\n    \"Rel R xs ys\"\n    \"\\<And>x. x\\<in>set ys \\<Longrightarrow> Rel (crel_vs (S ===> crel_vs S)) (f x) (f\\<^sub>T' x)\"\n  shows\n    \"Rel (crel_vs (S ===> crel_vs S)) (fold f xs) (fold\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (S ===>\\<^sub>T S)) (fold f xs)\n     (fold\\<^sub>T . \\<langle>f\\<^sub>T'\\<rangle> . \\<langle>ys\\<rangle>)", "unfolding fold\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (S ===>\\<^sub>T S)) (fold f xs)\n     (\\<langle>\\<lambda>uu_. \\<langle>fold\\<^sub>T' uu_\\<rangle>\\<rangle> .\n      \\<langle>f\\<^sub>T'\\<rangle> .\n      \\<langle>ys\\<rangle>)", "unfolding State_Monad_Ext.return_app_return_meta"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (S ===>\\<^sub>T S)) (fold f xs)\n     (fold\\<^sub>T' f\\<^sub>T' ys)", "unfolding assms(2)[unfolded Rel_def assms(1)[unfolded is_equality_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs (S ===>\\<^sub>T S)) (fold f ys)\n     (fold\\<^sub>T' f\\<^sub>T' ys)", "using assms(3)"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set ys \\<Longrightarrow>\n  Rel (crel_vs (S ===>\\<^sub>T S)) (f ?x2) (f\\<^sub>T' ?x2)\n\ngoal (1 subgoal):\n 1. Rel (crel_vs (S ===>\\<^sub>T S)) (fold f ys)\n     (fold\\<^sub>T' f\\<^sub>T' ys)", "unfolding Rel_def"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set ys \\<Longrightarrow>\n  crel_vs (S ===>\\<^sub>T S) (f ?x2) (f\\<^sub>T' ?x2)\n\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S) (fold f ys) (fold\\<^sub>T' f\\<^sub>T' ys)", "apply (induction ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        crel_vs (S ===>\\<^sub>T S) (f x) (f\\<^sub>T' x)) \\<Longrightarrow>\n    crel_vs (S ===>\\<^sub>T S) (fold f []) (fold\\<^sub>T' f\\<^sub>T' [])\n 2. \\<And>a ys.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ys \\<Longrightarrow>\n                    crel_vs (S ===>\\<^sub>T S) (f x)\n                     (f\\<^sub>T' x)) \\<Longrightarrow>\n                crel_vs (S ===>\\<^sub>T S) (fold f ys)\n                 (fold\\<^sub>T' f\\<^sub>T' ys);\n        \\<And>x.\n           x \\<in> set (a # ys) \\<Longrightarrow>\n           crel_vs (S ===>\\<^sub>T S) (f x) (f\\<^sub>T' x)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (S ===>\\<^sub>T S) (fold f (a # ys))\n                          (fold\\<^sub>T' f\\<^sub>T' (a # ys))", "subgoal premises"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S) (fold f []) (fold\\<^sub>T' f\\<^sub>T' [])", "by (memoize_unfold_defs (state) fold) transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ys \\<Longrightarrow>\n                    crel_vs (S ===>\\<^sub>T S) (f x)\n                     (f\\<^sub>T' x)) \\<Longrightarrow>\n                crel_vs (S ===>\\<^sub>T S) (fold f ys)\n                 (fold\\<^sub>T' f\\<^sub>T' ys);\n        \\<And>x.\n           x \\<in> set (a # ys) \\<Longrightarrow>\n           crel_vs (S ===>\\<^sub>T S) (f x) (f\\<^sub>T' x)\\<rbrakk>\n       \\<Longrightarrow> crel_vs (S ===>\\<^sub>T S) (fold f (a # ys))\n                          (fold\\<^sub>T' f\\<^sub>T' (a # ys))", "subgoal premises prems for a ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S) (fold f (a # ys))\n     (fold\\<^sub>T' f\\<^sub>T' (a # ys))", "apply (memoize_unfold_defs (state) fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S)\n     (App (App (\\<circ>) (fold f ys)) (App (Wrap f) (Wrap a)))\n     (comp\\<^sub>T . (fold\\<^sub>T' f\\<^sub>T' ys) .\n      (\\<langle>f\\<^sub>T'\\<rangle> . \\<langle>a\\<rangle>))", "apply (unfold State_Monad_Ext.return_app_return_meta Wrap_App_Wrap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S) (App (App (\\<circ>) (fold f ys)) (f a))\n     (comp\\<^sub>T . (fold\\<^sub>T' f\\<^sub>T' ys) . (f\\<^sub>T' a))", "supply [transfer_rule] =\n      prems(2)[OF list.set_intros(1)]\n      prems(1)[OF prems(2)[OF list.set_intros(2)], simplified]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (S ===>\\<^sub>T S) (App (App (\\<circ>) (fold f ys)) (f a))\n     (comp\\<^sub>T . (fold\\<^sub>T' f\\<^sub>T' ys) . (f\\<^sub>T' a))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma refl2:\n  \"is_equality R \\<Longrightarrow> Rel R x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_equality R \\<Longrightarrow> Rel R x x", "unfolding is_equality_def Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. R = (=) \\<Longrightarrow> R x x", "by simp"], ["", "lemma rel_fun2:\n  assumes \"is_equality R0\" \"\\<And>x. Rel R1 (f x) (g x)\"\n  shows \"Rel (rel_fun R0 R1) f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (R0 ===> R1) f g", "using assms"], ["proof (prove)\nusing this:\n  is_equality R0\n  Rel R1 (f ?x2) (g ?x2)\n\ngoal (1 subgoal):\n 1. Rel (R0 ===> R1) f g", "unfolding is_equality_def Rel_def"], ["proof (prove)\nusing this:\n  R0 = (=)\n  R1 (f ?x2) (g ?x2)\n\ngoal (1 subgoal):\n 1. (R0 ===> R1) f g", "by auto"], ["", "lemma crel_vs_return_app_return:\n  assumes \"Rel R (f x) (g x)\"\n  shows \"Rel R (App (Wrap f) (Wrap x)) (\\<langle>g\\<rangle> . \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel R (App (Wrap f) (Wrap x))\n     (\\<langle>g\\<rangle> . \\<langle>x\\<rangle>)", "using assms"], ["proof (prove)\nusing this:\n  Rel R (f x) (g x)\n\ngoal (1 subgoal):\n 1. Rel R (App (Wrap f) (Wrap x))\n     (\\<langle>g\\<rangle> . \\<langle>x\\<rangle>)", "unfolding State_Monad_Ext.return_app_return_meta Wrap_App_Wrap"], ["proof (prove)\nusing this:\n  Rel R (f x) (g x)\n\ngoal (1 subgoal):\n 1. Rel R (f x) (g x)", "."], ["", "thm option.case_cong[no_vars]"], ["", "lemma option_case_cong':\n\"Rel (=) option' option \\<Longrightarrow>\n(option = None \\<Longrightarrow> Rel R f1 g1) \\<Longrightarrow>\n(\\<And>x2. option = Some x2 \\<Longrightarrow> Rel R (f2 x2) (g2 x2)) \\<Longrightarrow>\nRel R (case option' of None \\<Rightarrow> f1 | Some x2 \\<Rightarrow> f2 x2)\n(case option of None \\<Rightarrow> g1 | Some x2 \\<Rightarrow> g2 x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rel (=) option' option;\n     option = None \\<Longrightarrow> Rel R f1 g1;\n     \\<And>x2.\n        option = Some x2 \\<Longrightarrow> Rel R (f2 x2) (g2 x2)\\<rbrakk>\n    \\<Longrightarrow> Rel R\n                       (case option' of None \\<Rightarrow> f1\n                        | Some x2 \\<Rightarrow> f2 x2)\n                       (case option of None \\<Rightarrow> g1\n                        | Some x2 \\<Rightarrow> g2 x2)", "unfolding Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>option' = option; option = None \\<Longrightarrow> R f1 g1;\n     \\<And>x2. option = Some x2 \\<Longrightarrow> R (f2 x2) (g2 x2)\\<rbrakk>\n    \\<Longrightarrow> R (case option' of None \\<Rightarrow> f1\n                         | Some x2 \\<Rightarrow> f2 x2)\n                       (case option of None \\<Rightarrow> g1\n                        | Some x2 \\<Rightarrow> g2 x2)", "by (auto split: option.split)"], ["", "thm prod.case_cong[no_vars]"], ["", "lemma prod_case_cong': fixes prod prod' shows\n\"Rel (=) prod prod' \\<Longrightarrow>\n(\\<And>x1 x2. prod' = (x1, x2) \\<Longrightarrow> Rel R (f x1 x2) (g x1 x2)) \\<Longrightarrow>\nRel R (case prod of (x1, x2) \\<Rightarrow> f x1 x2)\n(case prod' of (x1, x2) \\<Rightarrow> g x1 x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rel (=) prod prod';\n     \\<And>x1 x2.\n        prod' = (x1, x2) \\<Longrightarrow>\n        Rel R (f x1 x2) (g x1 x2)\\<rbrakk>\n    \\<Longrightarrow> Rel R (case prod of (x1, x2) \\<Rightarrow> f x1 x2)\n                       (case prod' of (x1, x2) \\<Rightarrow> g x1 x2)", "unfolding Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prod = prod';\n     \\<And>x1 x2.\n        prod' = (x1, x2) \\<Longrightarrow> R (f x1 x2) (g x1 x2)\\<rbrakk>\n    \\<Longrightarrow> R (case prod of (x1, x2) \\<Rightarrow> f x1 x2)\n                       (case prod' of (x1, x2) \\<Rightarrow> g x1 x2)", "by (auto split: prod.splits)"], ["", "thm nat.case_cong[no_vars]"], ["", "lemma nat_case_cong': fixes nat nat' shows\n\"Rel (=) nat nat' \\<Longrightarrow>\n(nat' = 0 \\<Longrightarrow> Rel R f1 g1) \\<Longrightarrow>\n(\\<And>x2. nat' = Suc x2 \\<Longrightarrow> Rel R (f2 x2) (g2 x2)) \\<Longrightarrow>\nRel R (case nat of 0 \\<Rightarrow> f1 | Suc x2 \\<Rightarrow> f2 x2) (case nat' of 0 \\<Rightarrow> g1 | Suc x2 \\<Rightarrow> g2 x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rel (=) nat nat'; nat' = 0 \\<Longrightarrow> Rel R f1 g1;\n     \\<And>x2.\n        nat' = Suc x2 \\<Longrightarrow> Rel R (f2 x2) (g2 x2)\\<rbrakk>\n    \\<Longrightarrow> Rel R\n                       (case nat of 0 \\<Rightarrow> f1\n                        | Suc x2 \\<Rightarrow> f2 x2)\n                       (case nat' of 0 \\<Rightarrow> g1\n                        | Suc x2 \\<Rightarrow> g2 x2)", "unfolding Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nat = nat'; nat' = 0 \\<Longrightarrow> R f1 g1;\n     \\<And>x2. nat' = Suc x2 \\<Longrightarrow> R (f2 x2) (g2 x2)\\<rbrakk>\n    \\<Longrightarrow> R (case nat of 0 \\<Rightarrow> f1\n                         | Suc x2 \\<Rightarrow> f2 x2)\n                       (case nat' of 0 \\<Rightarrow> g1\n                        | Suc x2 \\<Rightarrow> g2 x2)", "by (auto split: nat.splits)"], ["", "lemmas [dp_match_rule] =\n  prod_case_cong'\n  option_case_cong'\n  nat_case_cong'"], ["", "lemmas [dp_match_rule] =\n  crel_vs_return_app_return"], ["", "lemmas [dp_match_rule] =\n  map\\<^sub>T_cong2\n  fold\\<^sub>T_cong2\n  if\\<^sub>T_cong2"], ["", "lemmas [dp_match_rule] =\n  crel_vs_return\n  crel_vs_fun_app\n  refl2\n  rel_fun2"], ["", "(*\nlemmas [dp_match_rule] =\n  crel_vs_checkmem_tupled\n*)"], ["", "end"], ["", "(* context lifting_syntax *)"], ["", "end"], ["", "(* context dp_consistency *)"], ["", "subsubsection \\<open>Code Setup\\<close>"], ["", "lemmas [code_unfold] =\n  state_mem_defs.checkmem_checkmem'[symmetric]\n  state_mem_defs.checkmem'_def\n  map\\<^sub>T_def"], ["", "end"], ["", "(* theory *)"]]}