{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/state_monad/DP_CRelVS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma run_state_cases:\n  \"case State_Monad.run_state f heap of (_, heap) \\<Rightarrow> P heap\"", "lemma lift_p_P:\n  \"P heap'\" if \"State_Monad.run_state f heap = (v, heap')\"", "lemma checkmem_checkmem':\n  \"checkmem' param (\\<lambda>_. calc) = checkmem param calc\"", "lemma checkmem_eq_alt:\n  \"checkmem_eq dp param calc = (dp param = checkmem' param (\\<lambda> _. calc))\"", "lemma cmem_intro:\n  assumes \"\\<And>param v M'. State_Monad.run_state (lookup param) M = (Some v, M') \\<Longrightarrow> v = dp param\"\n  shows \"cmem M\"", "lemma cmem_elim:\n  assumes \"cmem M\" \"State_Monad.run_state (lookup param) M = (Some v, M')\"\n  obtains \"dp param = v\"", "lemma crel_vs_intro:\n  assumes \"\\<And>M v' M'. \\<lbrakk>cmem M; P M; State_Monad.run_state v\\<^sub>T M = (v', M')\\<rbrakk> \\<Longrightarrow> R v v' \\<and> cmem M' \\<and> P M'\"\n  shows \"crel_vs R v v\\<^sub>T\"", "lemma crel_vs_elim:\n  assumes \"crel_vs R v v\\<^sub>T\" \"cmem M\" \"P M\"\n  obtains v' M' where \"State_Monad.run_state v\\<^sub>T M = (v', M')\" \"R v v'\" \"cmem M'\" \"P M'\"", "lemma consistentDP_intro:\n  assumes \"\\<And>param. Transfer.Rel (crel_vs (=)) (dp param) (dp\\<^sub>T param)\"\n  shows \"consistentDP dp\\<^sub>T\"", "lemma crel_vs_return:\n  \"\\<lbrakk>Transfer.Rel R x y\\<rbrakk> \\<Longrightarrow> Transfer.Rel (crel_vs R) (Wrap x) (State_Monad.return y)\"", "lemma crel_vs_return_ext:\n  \"\\<lbrakk>Transfer.Rel R x y\\<rbrakk> \\<Longrightarrow> Transfer.Rel (crel_vs R) x (State_Monad.return y)\"", "lemma cmem_upd:\n  \"cmem M'\" if \"cmem M\" \"P M\" \"State_Monad.run_state (update param (dp param)) M = (v, M')\"", "lemma P_upd:\n  \"P M'\" if \"P M\" \"State_Monad.run_state (update param (dp param)) M = (v, M')\"", "lemma crel_vs_get:\n  \"\\<lbrakk>\\<And>M. cmem M \\<Longrightarrow> crel_vs R v (sf M)\\<rbrakk> \\<Longrightarrow> crel_vs R v (State_Monad.get \\<bind> sf)\"", "lemma crel_vs_set:\n  \"\\<lbrakk>crel_vs R v sf; cmem M; P M\\<rbrakk> \\<Longrightarrow> crel_vs R v (State_Monad.set M \\<then> sf)\"", "lemma crel_vs_bind_eq:\n  \"\\<lbrakk>crel_vs (=) v s; crel_vs R (f v) (sf v)\\<rbrakk> \\<Longrightarrow> crel_vs R (f v) (s \\<bind> sf)\"", "lemma bind_transfer[transfer_rule]:\n  \"(crel_vs R0 ===> (R0 ===>\\<^sub>T R1) ===> crel_vs R1) (\\<lambda>v f. f v) (\\<bind>)\"", "lemma cmem_lookup:\n  \"cmem M'\" if \"cmem M\" \"P M\" \"State_Monad.run_state (lookup param) M = (v, M')\"", "lemma P_lookup:\n  \"P M'\" if \"P M\" \"State_Monad.run_state (lookup param) M = (v, M')\"", "lemma crel_vs_lookup:\n  \"crel_vs (\\<lambda> v v'. case v' of None \\<Rightarrow> True | Some v' \\<Rightarrow> v = v' \\<and> v = dp param) (dp param) (lookup param)\"", "lemma crel_vs_update:\n  \"crel_vs (=) () (update param (dp param))\"", "lemma crel_vs_checkmem:\n  \"\\<lbrakk>is_equality R; Transfer.Rel (crel_vs R) (dp param) s\\<rbrakk>\n  \\<Longrightarrow> Transfer.Rel (crel_vs R) (dp param) (checkmem param s)\"", "lemma crel_vs_checkmem_tupled:\n  assumes \"v = dp param\"\n  shows \"\\<lbrakk>is_equality R; Transfer.Rel (crel_vs R) v s\\<rbrakk>\n        \\<Longrightarrow> Transfer.Rel (crel_vs R) v (checkmem param s)\"", "lemma return_transfer[transfer_rule]:\n  \"(R ===>\\<^sub>T R) Wrap State_Monad.return\"", "lemma fun_app_lifted_transfer[transfer_rule]:\n  \"(crel_vs (R0 ===>\\<^sub>T R1) ===> crel_vs R0 ===> crel_vs R1) App (.)\"", "lemma crel_vs_fun_app:\n  \"\\<lbrakk>Transfer.Rel (crel_vs R0) x x\\<^sub>T; Transfer.Rel (crel_vs (R0 ===>\\<^sub>T R1)) f f\\<^sub>T\\<rbrakk> \\<Longrightarrow> Transfer.Rel (crel_vs R1) (App f x) (f\\<^sub>T . x\\<^sub>T)\"", "lemma if\\<^sub>T_transfer[transfer_rule]:\n  \"(crel_vs (=) ===> crel_vs R ===> crel_vs R ===> crel_vs R) If State_Monad_Ext.if\\<^sub>T\""], "translations": [["", "lemma run_state_cases:\n  \"case State_Monad.run_state f heap of (_, heap) \\<Rightarrow> P heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case run_state f heap of (x, heap) \\<Rightarrow> P heap", "using lift P"], ["proof (prove)\nusing this:\n  lift_p P f\n  P heap\n\ngoal (1 subgoal):\n 1. case run_state f heap of (x, heap) \\<Rightarrow> P heap", "unfolding lift_p_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<longrightarrow>\n     (case run_state f heap of (x, xa) \\<Rightarrow> P xa)\n  P heap\n\ngoal (1 subgoal):\n 1. case run_state f heap of (x, heap) \\<Rightarrow> P heap", "by auto"], ["", "lemma lift_p_P:\n  \"P heap'\" if \"State_Monad.run_state f heap = (v, heap')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P heap'", "using that run_state_cases"], ["proof (prove)\nusing this:\n  run_state f heap = (v, heap')\n  case run_state f heap of (x, heap) \\<Rightarrow> P heap\n\ngoal (1 subgoal):\n 1. P heap'", "by auto"], ["", "end"], ["", "locale state_mem_defs =\n  fixes lookup :: \"'param \\<Rightarrow> ('mem, 'result option) state\"\n    and update :: \"'param \\<Rightarrow> 'result \\<Rightarrow> ('mem, unit) state\"\nbegin"], ["", "definition checkmem :: \"'param \\<Rightarrow> ('mem, 'result) state \\<Rightarrow> ('mem, 'result) state\" where\n  \"checkmem param calc \\<equiv> do {\n    x \\<leftarrow> lookup param;\n    case x of\n      Some x \\<Rightarrow> State_Monad.return x\n    | None \\<Rightarrow> do {\n        x \\<leftarrow> calc;\n        update param x;\n        State_Monad.return x\n      }\n  }\""], ["", "abbreviation checkmem_eq ::\n  \"('param \\<Rightarrow> ('mem, 'result) state) \\<Rightarrow> 'param \\<Rightarrow> ('mem, 'result) state \\<Rightarrow> bool\"\n  (\"_$ _ =CHECKMEM= _\" [1000,51] 51) where\n  \"(dp\\<^sub>T$ param =CHECKMEM= calc) \\<equiv> (dp\\<^sub>T param = checkmem param calc)\""], ["", "term 0"], ["", "(**)"], ["", "definition map_of where\n  \"map_of heap k = fst (run_state (lookup k) heap)\""], ["", "definition checkmem' :: \"'param \\<Rightarrow> (unit \\<Rightarrow> ('mem, 'result) state) \\<Rightarrow> ('mem, 'result) state\" where\n  \"checkmem' param calc \\<equiv> do {\n    x \\<leftarrow> lookup param;\n    case x of\n      Some x \\<Rightarrow> State_Monad.return x\n    | None \\<Rightarrow> do {\n        x \\<leftarrow> calc ();\n        update param x;\n        State_Monad.return x\n      }\n  }\""], ["", "lemma checkmem_checkmem':\n  \"checkmem' param (\\<lambda>_. calc) = checkmem param calc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checkmem' param (\\<lambda>_. calc) = checkmem param calc", "unfolding checkmem'_def checkmem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup param \\<bind>\n    (\\<lambda>x.\n        case x of\n        None \\<Rightarrow>\n          calc \\<bind>\n          (\\<lambda>x.\n              update param x \\<bind> (\\<lambda>_. State_Monad.return x))\n        | Some x \\<Rightarrow> State_Monad.return x) =\n    lookup param \\<bind>\n    (\\<lambda>x.\n        case x of\n        None \\<Rightarrow>\n          calc \\<bind>\n          (\\<lambda>x.\n              update param x \\<bind> (\\<lambda>_. State_Monad.return x))\n        | Some x \\<Rightarrow> State_Monad.return x)", ".."], ["", "lemma checkmem_eq_alt:\n  \"checkmem_eq dp param calc = (dp param = checkmem' param (\\<lambda> _. calc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp$ param =CHECKMEM= calc =\n    (dp param = checkmem' param (\\<lambda>_. calc))", "unfolding checkmem_checkmem'"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp$ param =CHECKMEM= calc = dp$ param =CHECKMEM= calc", ".."], ["", "end"], ["", "(* Mem Defs *)"], ["", "locale mem_correct = state_mem_defs +\n  fixes P\n  assumes lookup_inv: \"lift_p P (lookup k)\" and update_inv: \"lift_p P (update k v)\"\n  assumes\n    lookup_correct: \"P m \\<Longrightarrow> map_of (snd (State_Monad.run_state (lookup k) m)) \\<subseteq>\\<^sub>m (map_of m)\"\n      and\n    update_correct: \"P m \\<Longrightarrow> map_of (snd (State_Monad.run_state (update k v) m)) \\<subseteq>\\<^sub>m (map_of m)(k \\<mapsto> v)\""], ["", "(* assumes correct: \"lookup (update m k v) \\<subseteq>\\<^sub>m (lookup m)(k \\<mapsto> v)\" *)"], ["", "locale dp_consistency =\n  mem_correct lookup update P\n  for lookup :: \"'param \\<Rightarrow> ('mem, 'result option) state\" and update and P +\n  fixes dp :: \"'param \\<Rightarrow> 'result\"\nbegin"], ["", "context\n  includes lifting_syntax state_monad_syntax\nbegin"], ["", "definition cmem :: \"'mem \\<Rightarrow> bool\" where\n  \"cmem M \\<equiv> \\<forall>param\\<in>dom (map_of M). map_of M param = Some (dp param)\""], ["", "definition crel_vs :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> ('mem, 'b) state \\<Rightarrow> bool\" where\n  \"crel_vs R v s \\<equiv> \\<forall>M. cmem M \\<and> P M \\<longrightarrow> (case State_Monad.run_state s M of (v', M') \\<Rightarrow> R v v' \\<and> cmem M' \\<and> P M')\""], ["", "abbreviation rel_fun_lifted :: \"('a \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> 'd \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('c ==_\\<Longrightarrow> 'd) \\<Rightarrow> bool\" (infixr \"===>\\<^sub>T\" 55) where\n  \"rel_fun_lifted R R' \\<equiv> R ===> crel_vs R'\""], ["", "term 0"], ["", "(**)"], ["", "definition consistentDP :: \"('param == 'mem \\<Longrightarrow> 'result) \\<Rightarrow> bool\" where\n  \"consistentDP \\<equiv> ((=) ===> crel_vs (=)) dp\""], ["", "term 0"], ["", "(**)\n  \n  (* cmem *)\nprivate"], ["", "lemma cmem_intro:\n  assumes \"\\<And>param v M'. State_Monad.run_state (lookup param) M = (Some v, M') \\<Longrightarrow> v = dp param\"\n  shows \"cmem M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmem M", "unfolding cmem_def map_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>param\\<in>dom (\\<lambda>k. fst (run_state (lookup k) M)).\n       fst (run_state (lookup param) M) = Some (dp param)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>param y.\n       fst (run_state (lookup param) M) = Some y \\<Longrightarrow>\n       fst (run_state (lookup param) M) = Some (dp param)", "subgoal for param y"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (run_state (lookup param) M) = Some y \\<Longrightarrow>\n    fst (run_state (lookup param) M) = Some (dp param)", "by (cases \"State_Monad.run_state (lookup param) M\") (auto intro: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cmem_elim:\n  assumes \"cmem M\" \"State_Monad.run_state (lookup param) M = (Some v, M')\"\n  obtains \"dp param = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dp param = v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  cmem M\n  run_state (lookup param) M = (Some v, M')\n\ngoal (1 subgoal):\n 1. (dp param = v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding cmem_def dom_def map_of_def"], ["proof (prove)\nusing this:\n  \\<forall>param\\<in>{a. fst (run_state (lookup a) M) \\<noteq> None}.\n     fst (run_state (lookup param) M) = Some (dp param)\n  run_state (lookup param) M = (Some v, M')\n\ngoal (1 subgoal):\n 1. (dp param = v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto (metis fst_conv option.inject)"], ["", "term 0"], ["", "(**)\n  \n  (* crel_vs *)"], ["", "lemma crel_vs_intro:\n  assumes \"\\<And>M v' M'. \\<lbrakk>cmem M; P M; State_Monad.run_state v\\<^sub>T M = (v', M')\\<rbrakk> \\<Longrightarrow> R v v' \\<and> cmem M' \\<and> P M'\"\n  shows \"crel_vs R v v\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs R v v\\<^sub>T", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>cmem ?M2; P ?M2; run_state v\\<^sub>T ?M2 = (?v'2, ?M'2)\\<rbrakk>\n  \\<Longrightarrow> R v ?v'2 \\<and> cmem ?M'2 \\<and> P ?M'2\n\ngoal (1 subgoal):\n 1. crel_vs R v v\\<^sub>T", "unfolding crel_vs_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>cmem ?M2; P ?M2; run_state v\\<^sub>T ?M2 = (?v'2, ?M'2)\\<rbrakk>\n  \\<Longrightarrow> R v ?v'2 \\<and> cmem ?M'2 \\<and> P ?M'2\n\ngoal (1 subgoal):\n 1. \\<forall>M.\n       cmem M \\<and> P M \\<longrightarrow>\n       (case run_state v\\<^sub>T M of\n        (v', M') \\<Rightarrow> R v v' \\<and> cmem M' \\<and> P M')", "by blast"], ["", "term 0"], ["", "(**)"], ["", "lemma crel_vs_elim:\n  assumes \"crel_vs R v v\\<^sub>T\" \"cmem M\" \"P M\"\n  obtains v' M' where \"State_Monad.run_state v\\<^sub>T M = (v', M')\" \"R v v'\" \"cmem M'\" \"P M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v' M'.\n        \\<lbrakk>run_state v\\<^sub>T M = (v', M'); R v v'; cmem M';\n         P M'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  crel_vs R v v\\<^sub>T\n  cmem M\n  P M\n\ngoal (1 subgoal):\n 1. (\\<And>v' M'.\n        \\<lbrakk>run_state v\\<^sub>T M = (v', M'); R v v'; cmem M';\n         P M'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding crel_vs_def"], ["proof (prove)\nusing this:\n  \\<forall>M.\n     cmem M \\<and> P M \\<longrightarrow>\n     (case run_state v\\<^sub>T M of\n      (v', M') \\<Rightarrow> R v v' \\<and> cmem M' \\<and> P M')\n  cmem M\n  P M\n\ngoal (1 subgoal):\n 1. (\\<And>v' M'.\n        \\<lbrakk>run_state v\\<^sub>T M = (v', M'); R v v'; cmem M';\n         P M'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "term 0"], ["", "(**)\n  \n  (* consistentDP *)"], ["", "lemma consistentDP_intro:\n  assumes \"\\<And>param. Transfer.Rel (crel_vs (=)) (dp param) (dp\\<^sub>T param)\"\n  shows \"consistentDP dp\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistentDP dp\\<^sub>T", "using assms"], ["proof (prove)\nusing this:\n  Rel (crel_vs (=)) (dp ?param2) (dp\\<^sub>T ?param2)\n\ngoal (1 subgoal):\n 1. consistentDP dp\\<^sub>T", "unfolding consistentDP_def Rel_def"], ["proof (prove)\nusing this:\n  crel_vs (=) (dp ?param2) (dp\\<^sub>T ?param2)\n\ngoal (1 subgoal):\n 1. ((=) ===>\\<^sub>T (=)) dp dp\\<^sub>T", "by blast"], ["", "lemma crel_vs_return:\n  \"\\<lbrakk>Transfer.Rel R x y\\<rbrakk> \\<Longrightarrow> Transfer.Rel (crel_vs R) (Wrap x) (State_Monad.return y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel R x y \\<Longrightarrow> Rel (crel_vs R) (Wrap x) \\<langle>y\\<rangle>", "unfolding State_Monad.return_def Wrap_def Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. R x y \\<Longrightarrow> crel_vs R x (State (Pair y))", "by (fastforce intro: crel_vs_intro)"], ["", "term 0"], ["", "(**)"], ["", "lemma crel_vs_return_ext:\n  \"\\<lbrakk>Transfer.Rel R x y\\<rbrakk> \\<Longrightarrow> Transfer.Rel (crel_vs R) x (State_Monad.return y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel R x y \\<Longrightarrow> Rel (crel_vs R) x \\<langle>y\\<rangle>", "by (fact crel_vs_return[unfolded Wrap_def])"], ["", "term 0"], ["", "(**)\n\n  (* Low level operators *)\nprivate"], ["", "lemma cmem_upd:\n  \"cmem M'\" if \"cmem M\" \"P M\" \"State_Monad.run_state (update param (dp param)) M = (v, M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmem M'", "using update_correct[of M param \"dp param\"] that"], ["proof (prove)\nusing this:\n  P M \\<Longrightarrow>\n  local.map_of\n   (snd (run_state (update param (dp param)) M)) \\<subseteq>\\<^sub>m\n  local.map_of M(param \\<mapsto> dp param)\n  cmem M\n  P M\n  run_state (update param (dp param)) M = (v, M')\n\ngoal (1 subgoal):\n 1. cmem M'", "unfolding cmem_def map_le_def"], ["proof (prove)\nusing this:\n  P M \\<Longrightarrow>\n  \\<forall>a\\<in>dom (local.map_of\n                       (snd (run_state (update param (dp param)) M))).\n     local.map_of (snd (run_state (update param (dp param)) M)) a =\n     (local.map_of M(param \\<mapsto> dp param)) a\n  \\<forall>param\\<in>dom (local.map_of M).\n     local.map_of M param = Some (dp param)\n  P M\n  run_state (update param (dp param)) M = (v, M')\n\ngoal (1 subgoal):\n 1. \\<forall>param\\<in>dom (local.map_of M').\n       local.map_of M' param = Some (dp param)", "by simp force"], ["", "private"], ["", "lemma P_upd:\n  \"P M'\" if \"P M\" \"State_Monad.run_state (update param (dp param)) M = (v, M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P M'", "by (meson lift_p_P that update_inv)"], ["", "private"], ["", "lemma crel_vs_get:\n  \"\\<lbrakk>\\<And>M. cmem M \\<Longrightarrow> crel_vs R v (sf M)\\<rbrakk> \\<Longrightarrow> crel_vs R v (State_Monad.get \\<bind> sf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M. cmem M \\<Longrightarrow> crel_vs R v (sf M)) \\<Longrightarrow>\n    crel_vs R v (State_Monad.get \\<bind> sf)", "unfolding State_Monad.get_def State_Monad.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M. cmem M \\<Longrightarrow> crel_vs R v (sf M)) \\<Longrightarrow>\n    crel_vs R v\n     (State\n       (\\<lambda>s.\n           case run_state (State (\\<lambda>s. (s, s))) s of\n           (a, x) \\<Rightarrow> run_state (sf a) x))", "by (fastforce intro: crel_vs_intro elim: crel_vs_elim split: prod.split)"], ["", "term 0"], ["", "(**)\n  \nprivate"], ["", "lemma crel_vs_set:\n  \"\\<lbrakk>crel_vs R v sf; cmem M; P M\\<rbrakk> \\<Longrightarrow> crel_vs R v (State_Monad.set M \\<then> sf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>crel_vs R v sf; cmem M; P M\\<rbrakk>\n    \\<Longrightarrow> crel_vs R v\n                       (State_Monad.set M \\<bind> (\\<lambda>_. sf))", "unfolding State_Monad.set_def State_Monad.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>crel_vs R v sf; cmem M; P M\\<rbrakk>\n    \\<Longrightarrow> crel_vs R v\n                       (State\n                         (\\<lambda>s.\n                             case run_state (State (\\<lambda>_. ((), M)))\n                                   s of\n                             (a, x) \\<Rightarrow> run_state sf x))", "by (fastforce intro: crel_vs_intro elim: crel_vs_elim split: prod.split)"], ["", "term 0"], ["", "(**)\n  \nprivate"], ["", "lemma crel_vs_bind_eq:\n  \"\\<lbrakk>crel_vs (=) v s; crel_vs R (f v) (sf v)\\<rbrakk> \\<Longrightarrow> crel_vs R (f v) (s \\<bind> sf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>crel_vs (=) v s; crel_vs R (f v) (sf v)\\<rbrakk>\n    \\<Longrightarrow> crel_vs R (f v) (s \\<bind> sf)", "unfolding State_Monad.bind_def rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>crel_vs (=) v s; crel_vs R (f v) (sf v)\\<rbrakk>\n    \\<Longrightarrow> crel_vs R (f v)\n                       (State\n                         (\\<lambda>sa.\n                             case run_state s sa of\n                             (a, x) \\<Rightarrow> run_state (sf a) x))", "by (fastforce intro: crel_vs_intro elim: crel_vs_elim split: prod.split)"], ["", "term 0"], ["", "(**)"], ["", "lemma bind_transfer[transfer_rule]:\n  \"(crel_vs R0 ===> (R0 ===>\\<^sub>T R1) ===> crel_vs R1) (\\<lambda>v f. f v) (\\<bind>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (crel_vs R0 ===> (R0 ===>\\<^sub>T R1) ===>\\<^sub>T R1)\n     (\\<lambda>v f. f v) (\\<bind>)", "unfolding State_Monad.bind_def rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       crel_vs R0 x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<forall>x y.\n               R0 x y \\<longrightarrow>\n               crel_vs R1 (xa x) (ya y)) \\<longrightarrow>\n           crel_vs R1 (xa x)\n            (State\n              (\\<lambda>s.\n                  case run_state y s of\n                  (a, x) \\<Rightarrow> run_state (ya a) x)))", "by (fastforce intro: crel_vs_intro elim: crel_vs_elim split: prod.split)"], ["", "private"], ["", "lemma cmem_lookup:\n  \"cmem M'\" if \"cmem M\" \"P M\" \"State_Monad.run_state (lookup param) M = (v, M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmem M'", "using lookup_correct[of M param] that"], ["proof (prove)\nusing this:\n  P M \\<Longrightarrow>\n  local.map_of (snd (run_state (lookup param) M)) \\<subseteq>\\<^sub>m\n  local.map_of M\n  cmem M\n  P M\n  run_state (lookup param) M = (v, M')\n\ngoal (1 subgoal):\n 1. cmem M'", "unfolding cmem_def map_le_def"], ["proof (prove)\nusing this:\n  P M \\<Longrightarrow>\n  \\<forall>a\\<in>dom (local.map_of (snd (run_state (lookup param) M))).\n     local.map_of (snd (run_state (lookup param) M)) a = local.map_of M a\n  \\<forall>param\\<in>dom (local.map_of M).\n     local.map_of M param = Some (dp param)\n  P M\n  run_state (lookup param) M = (v, M')\n\ngoal (1 subgoal):\n 1. \\<forall>param\\<in>dom (local.map_of M').\n       local.map_of M' param = Some (dp param)", "by force"], ["", "private"], ["", "lemma P_lookup:\n  \"P M'\" if \"P M\" \"State_Monad.run_state (lookup param) M = (v, M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P M'", "by (meson lift_p_P that lookup_inv)"], ["", "lemma crel_vs_lookup:\n  \"crel_vs (\\<lambda> v v'. case v' of None \\<Rightarrow> True | Some v' \\<Rightarrow> v = v' \\<and> v = dp param) (dp param) (lookup param)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs\n     (\\<lambda>v v'.\n         case v' of None \\<Rightarrow> True\n         | Some v' \\<Rightarrow> v = v' \\<and> v = dp param)\n     (dp param) (lookup param)", "by (auto elim: cmem_elim intro: cmem_lookup crel_vs_intro P_lookup split: option.split)"], ["", "lemma crel_vs_update:\n  \"crel_vs (=) () (update param (dp param))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (=) () (update param (dp param))", "by (auto intro: cmem_upd crel_vs_intro P_upd)"], ["", "private"], ["", "lemma crel_vs_checkmem:\n  \"\\<lbrakk>is_equality R; Transfer.Rel (crel_vs R) (dp param) s\\<rbrakk>\n  \\<Longrightarrow> Transfer.Rel (crel_vs R) (dp param) (checkmem param s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_equality R; Rel (crel_vs R) (dp param) s\\<rbrakk>\n    \\<Longrightarrow> Rel (crel_vs R) (dp param) (checkmem param s)", "unfolding checkmem_def Rel_def is_equality_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R = (=); crel_vs R (dp param) s\\<rbrakk>\n    \\<Longrightarrow> crel_vs R (dp param)\n                       (lookup param \\<bind>\n                        (\\<lambda>x.\n                            case x of\n                            None \\<Rightarrow>\n                              s \\<bind>\n                              (\\<lambda>x.\n                                  update param x \\<bind>\n                                  (\\<lambda>_. \\<langle>x\\<rangle>))\n                            | Some x \\<Rightarrow> \\<langle>x\\<rangle>))", "by (rule bind_transfer[unfolded rel_fun_def, rule_format, OF crel_vs_lookup])\n     (auto 4 3 intro: crel_vs_lookup crel_vs_update crel_vs_return[unfolded Rel_def Wrap_def] crel_vs_bind_eq\n               split: option.split_asm\n     )"], ["", "lemma crel_vs_checkmem_tupled:\n  assumes \"v = dp param\"\n  shows \"\\<lbrakk>is_equality R; Transfer.Rel (crel_vs R) v s\\<rbrakk>\n        \\<Longrightarrow> Transfer.Rel (crel_vs R) v (checkmem param s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_equality R; Rel (crel_vs R) v s\\<rbrakk>\n    \\<Longrightarrow> Rel (crel_vs R) v (checkmem param s)", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_equality R; Rel (crel_vs R) (dp param) s\\<rbrakk>\n    \\<Longrightarrow> Rel (crel_vs R) (dp param) (checkmem param s)", "by (fact crel_vs_checkmem)"], ["", "(** Transfer rules **)\n  (* Basics *)"], ["", "lemma return_transfer[transfer_rule]:\n  \"(R ===>\\<^sub>T R) Wrap State_Monad.return\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===>\\<^sub>T R) Wrap State_Monad.return", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       R x y \\<longrightarrow> crel_vs R (Wrap x) \\<langle>y\\<rangle>", "by (metis crel_vs_return Rel_def)"], ["", "lemma fun_app_lifted_transfer[transfer_rule]:\n  \"(crel_vs (R0 ===>\\<^sub>T R1) ===> crel_vs R0 ===> crel_vs R1) App (.)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (crel_vs (R0 ===>\\<^sub>T R1) ===> crel_vs R0 ===>\\<^sub>T R1) App (.)", "unfolding App_def fun_app_lifted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (crel_vs (R0 ===>\\<^sub>T R1) ===> crel_vs R0 ===>\\<^sub>T R1)\n     (\\<lambda>f. f)\n     (\\<lambda>f\\<^sub>T x\\<^sub>T. f\\<^sub>T \\<bind> (\\<bind>) x\\<^sub>T)", "by transfer_prover"], ["", "lemma crel_vs_fun_app:\n  \"\\<lbrakk>Transfer.Rel (crel_vs R0) x x\\<^sub>T; Transfer.Rel (crel_vs (R0 ===>\\<^sub>T R1)) f f\\<^sub>T\\<rbrakk> \\<Longrightarrow> Transfer.Rel (crel_vs R1) (App f x) (f\\<^sub>T . x\\<^sub>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rel (crel_vs R0) x x\\<^sub>T;\n     Rel (crel_vs (R0 ===>\\<^sub>T R1)) f f\\<^sub>T\\<rbrakk>\n    \\<Longrightarrow> Rel (crel_vs R1) (App f x) (f\\<^sub>T . x\\<^sub>T)", "unfolding Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>crel_vs R0 x x\\<^sub>T;\n     crel_vs (R0 ===>\\<^sub>T R1) f f\\<^sub>T\\<rbrakk>\n    \\<Longrightarrow> crel_vs R1 (App f x) (f\\<^sub>T . x\\<^sub>T)", "using fun_app_lifted_transfer[THEN rel_funD, THEN rel_funD]"], ["proof (prove)\nusing this:\n  \\<lbrakk>crel_vs (?R0.2 ===>\\<^sub>T ?R1.2) ?x1 ?y1;\n   crel_vs ?R0.2 ?x ?y\\<rbrakk>\n  \\<Longrightarrow> crel_vs ?R1.2 (App ?x1 ?x) (?y1 . ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>crel_vs R0 x x\\<^sub>T;\n     crel_vs (R0 ===>\\<^sub>T R1) f f\\<^sub>T\\<rbrakk>\n    \\<Longrightarrow> crel_vs R1 (App f x) (f\\<^sub>T . x\\<^sub>T)", "."], ["", "(* HOL *)"], ["", "lemma if\\<^sub>T_transfer[transfer_rule]:\n  \"(crel_vs (=) ===> crel_vs R ===> crel_vs R ===> crel_vs R) If State_Monad_Ext.if\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (crel_vs (=) ===> crel_vs R ===> crel_vs R ===>\\<^sub>T R) If\n     State_Monad_Ext.if\\<^sub>T", "unfolding State_Monad_Ext.if\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (crel_vs (=) ===> crel_vs R ===> crel_vs R ===>\\<^sub>T R) If\n     (\\<lambda>b\\<^sub>T x\\<^sub>T y\\<^sub>T.\n         b\\<^sub>T \\<bind> (\\<lambda>b. if b then x\\<^sub>T else y\\<^sub>T))", "by transfer_prover"], ["", "end"], ["", "(* Lifting Syntax *)"], ["", "end"], ["", "(* Consistency *)"], ["", "end"], ["", "(* Theory *)"]]}