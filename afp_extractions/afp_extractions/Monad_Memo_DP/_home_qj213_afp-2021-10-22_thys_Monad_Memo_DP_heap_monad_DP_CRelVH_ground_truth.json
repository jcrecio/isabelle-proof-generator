{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/heap_monad/DP_CRelVH.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma consistentDP_intro:\n  assumes \"\\<And>param. Transfer.Rel (crel_vs (=)) (dp param) (dp\\<^sub>T param)\"\n  shows \"consistentDP dp\\<^sub>T\"", "lemma crel_vs_execute_None:\n  False if \"crel_vs R a b\" \"execute b heap = None\" \"P heap\" \"Q heap\" \"state_dp_consistency.cmem heap\"", "lemma crel_vs_execute_Some:\n  assumes \"crel_vs R a b\" \"P heap\" \"Q heap\" \"state_dp_consistency.cmem heap\"\n  obtains x heap' where \"execute b heap = Some (x, heap')\" \"P heap'\" \"Q heap'\"", "lemma crel_vs_executeD:\n  assumes \"crel_vs R a b\" \"P heap\" \"Q heap\" \"state_dp_consistency.cmem heap\"\n  obtains x heap' where\n    \"execute b heap = Some (x, heap')\" \"P heap'\" \"Q heap'\" \"state_dp_consistency.cmem heap'\" \"R a x\"", "lemma crel_vs_success:\n  assumes \"crel_vs R a b\" \"P heap\" \"Q heap\" \"state_dp_consistency.cmem heap\"\n  shows \"success b heap\"", "lemma crel_vsI: \"crel_vs R a b\" if \"(state_dp_consistency.crel_vs R OO rel_state (=)) a b\"", "lemma transfer'_return[transfer_rule]:\n  \"(R ===> crel_vs R) Wrap return\"", "lemma crel_vs_return:\n  \"Transfer.Rel (crel_vs R) (Wrap x) (return y)\" if \"Transfer.Rel R x y\"", "lemma crel_vs_return_ext:\n  \"\\<lbrakk>Transfer.Rel R x y\\<rbrakk> \\<Longrightarrow> Transfer.Rel (crel_vs R) x (Heap_Monad.return y)\"", "lemma bind_transfer[transfer_rule]:\n  \"(crel_vs R0 ===> (R0 ===> crel_vs R1) ===> crel_vs R1) (\\<lambda>v f. f v) (\\<bind>)\"", "lemma crel_vs_update:\n  \"crel_vs (=) () (update param (dp param))\"", "lemma crel_vs_lookup:\n  \"crel_vs\n    (\\<lambda> v v'. case v' of None \\<Rightarrow> True | Some v' \\<Rightarrow> v = v' \\<and> v = dp param) (dp param) (lookup param)\"", "lemma crel_vs_eq_eq_onp:\n  \"crel_vs (eq_onp (\\<lambda> x. x = v)) v s\" if \"crel_vs (=) v s\"", "lemma crel_vs_bind_eq:\n  \"\\<lbrakk>crel_vs (=) v s; crel_vs R (f v) (sf v)\\<rbrakk> \\<Longrightarrow> crel_vs R (f v) (s \\<bind> sf)\"", "lemma crel_vs_checkmem:\n  \"Transfer.Rel (crel_vs R) (dp param) (checkmem param s)\" if \"is_equality R\" \"Transfer.Rel (crel_vs R) (dp param) s\"", "lemma crel_vs_checkmem_tupled:\n  assumes \"v = dp param\"\n  shows \"\\<lbrakk>is_equality R; Transfer.Rel (crel_vs R) v s\\<rbrakk>\n        \\<Longrightarrow> Transfer.Rel (crel_vs R) v (checkmem param s)\"", "lemma transfer_fun_app_lifted[transfer_rule]:\n  \"(crel_vs (R0 ===> crel_vs R1) ===> crel_vs R0 ===> crel_vs R1)\n    App Heap_Monad_Ext.fun_app_lifted\"", "lemma crel_vs_fun_app:\n  \"\\<lbrakk>Transfer.Rel (crel_vs R0) x x\\<^sub>T; Transfer.Rel (crel_vs (R0 ===>\\<^sub>T R1)) f f\\<^sub>T\\<rbrakk> \\<Longrightarrow> Transfer.Rel (crel_vs R1) (App f x) (f\\<^sub>T . x\\<^sub>T)\"", "lemma dp_heap: \"dp_heap P P lookup lookup' update update'\"", "lemma cmem_empty:\n  \"state_dp_consistency.cmem empty\"", "lemma memoized_success:\n  \"success (dp\\<^sub>T x) empty\" if \"consistentDP dp\\<^sub>T\"", "lemma memoized:\n  \"dp x = fst (the (Heap_Monad.execute (dp\\<^sub>T x) empty))\" if \"consistentDP dp\\<^sub>T\"", "lemma cmem_result:\n  \"state_dp_consistency.cmem (snd (the (Heap_Monad.execute (dp\\<^sub>T x) empty)))\" if \"consistentDP dp\\<^sub>T\""], "translations": [["", "lemma consistentDP_intro:\n  assumes \"\\<And>param. Transfer.Rel (crel_vs (=)) (dp param) (dp\\<^sub>T param)\"\n  shows \"consistentDP dp\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistentDP dp\\<^sub>T", "using assms"], ["proof (prove)\nusing this:\n  Rel (crel_vs (=)) (dp ?param4) (dp\\<^sub>T ?param4)\n\ngoal (1 subgoal):\n 1. consistentDP dp\\<^sub>T", "unfolding consistentDP_def Rel_def"], ["proof (prove)\nusing this:\n  crel_vs (=) (dp ?param4) (dp\\<^sub>T ?param4)\n\ngoal (1 subgoal):\n 1. ((=) ===>\\<^sub>T (=)) dp dp\\<^sub>T", "by blast"], ["", "lemma crel_vs_execute_None:\n  False if \"crel_vs R a b\" \"execute b heap = None\" \"P heap\" \"Q heap\" \"state_dp_consistency.cmem heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  crel_vs R a b\n  execute b heap = None\n  P heap\n  Q heap\n  state_dp_consistency.cmem heap\n\ngoal (1 subgoal):\n 1. False", "unfolding crel_vs_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<and>\n     Q heap \\<and> state_dp_consistency.cmem heap \\<longrightarrow>\n     (case execute b heap of None \\<Rightarrow> False\n      | Some (v', heap') \\<Rightarrow>\n          P heap' \\<and>\n          Q heap' \\<and> R a v' \\<and> state_dp_consistency.cmem heap')\n  execute b heap = None\n  P heap\n  Q heap\n  state_dp_consistency.cmem heap\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["", "lemma crel_vs_execute_Some:\n  assumes \"crel_vs R a b\" \"P heap\" \"Q heap\" \"state_dp_consistency.cmem heap\"\n  obtains x heap' where \"execute b heap = Some (x, heap')\" \"P heap'\" \"Q heap'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x heap'.\n        \\<lbrakk>execute b heap = Some (x, heap'); P heap'; Q heap'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  crel_vs R a b\n  P heap\n  Q heap\n  state_dp_consistency.cmem heap\n\ngoal (1 subgoal):\n 1. (\\<And>x heap'.\n        \\<lbrakk>execute b heap = Some (x, heap'); P heap'; Q heap'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding crel_vs_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<and>\n     Q heap \\<and> state_dp_consistency.cmem heap \\<longrightarrow>\n     (case execute b heap of None \\<Rightarrow> False\n      | Some (v', heap') \\<Rightarrow>\n          P heap' \\<and>\n          Q heap' \\<and> R a v' \\<and> state_dp_consistency.cmem heap')\n  P heap\n  Q heap\n  state_dp_consistency.cmem heap\n\ngoal (1 subgoal):\n 1. (\\<And>x heap'.\n        \\<lbrakk>execute b heap = Some (x, heap'); P heap'; Q heap'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"execute b heap\") auto"], ["", "lemma crel_vs_executeD:\n  assumes \"crel_vs R a b\" \"P heap\" \"Q heap\" \"state_dp_consistency.cmem heap\"\n  obtains x heap' where\n    \"execute b heap = Some (x, heap')\" \"P heap'\" \"Q heap'\" \"state_dp_consistency.cmem heap'\" \"R a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x heap'.\n        \\<lbrakk>execute b heap = Some (x, heap'); P heap'; Q heap';\n         state_dp_consistency.cmem heap'; R a x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  crel_vs R a b\n  P heap\n  Q heap\n  state_dp_consistency.cmem heap\n\ngoal (1 subgoal):\n 1. (\\<And>x heap'.\n        \\<lbrakk>execute b heap = Some (x, heap'); P heap'; Q heap';\n         state_dp_consistency.cmem heap'; R a x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding crel_vs_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<and>\n     Q heap \\<and> state_dp_consistency.cmem heap \\<longrightarrow>\n     (case execute b heap of None \\<Rightarrow> False\n      | Some (v', heap') \\<Rightarrow>\n          P heap' \\<and>\n          Q heap' \\<and> R a v' \\<and> state_dp_consistency.cmem heap')\n  P heap\n  Q heap\n  state_dp_consistency.cmem heap\n\ngoal (1 subgoal):\n 1. (\\<And>x heap'.\n        \\<lbrakk>execute b heap = Some (x, heap'); P heap'; Q heap';\n         state_dp_consistency.cmem heap'; R a x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"execute b heap\") auto"], ["", "lemma crel_vs_success:\n  assumes \"crel_vs R a b\" \"P heap\" \"Q heap\" \"state_dp_consistency.cmem heap\"\n  shows \"success b heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success b heap", "using assms"], ["proof (prove)\nusing this:\n  crel_vs R a b\n  P heap\n  Q heap\n  state_dp_consistency.cmem heap\n\ngoal (1 subgoal):\n 1. success b heap", "unfolding success_def"], ["proof (prove)\nusing this:\n  crel_vs R a b\n  P heap\n  Q heap\n  state_dp_consistency.cmem heap\n\ngoal (1 subgoal):\n 1. execute b heap \\<noteq> None", "by (auto elim: crel_vs_executeD)"], ["", "lemma crel_vsI: \"crel_vs R a b\" if \"(state_dp_consistency.crel_vs R OO rel_state (=)) a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs R a b", "using that"], ["proof (prove)\nusing this:\n  (state_dp_consistency.crel_vs R OO local.rel_state (=)) a b\n\ngoal (1 subgoal):\n 1. crel_vs R a b", "by (auto 4 3 elim: state_dp_consistency.crel_vs_elim rel_state_elim simp: crel_vs_def)"], ["", "lemma transfer'_return[transfer_rule]:\n  \"(R ===> crel_vs R) Wrap return\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===>\\<^sub>T R) Wrap return", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (R ===>\\<^sub>T R) Wrap return", "have \"(R ===> (state_dp_consistency.crel_vs R OO rel_state (=))) Wrap return\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> state_dp_consistency.crel_vs R OO local.rel_state (=)) Wrap\n     return", "by (rule rel_fun_comp1 state_dp_consistency.return_transfer transfer_return)+ auto"], ["proof (state)\nthis:\n  (R ===> state_dp_consistency.crel_vs R OO local.rel_state (=)) Wrap return\n\ngoal (1 subgoal):\n 1. (R ===>\\<^sub>T R) Wrap return", "then"], ["proof (chain)\npicking this:\n  (R ===> state_dp_consistency.crel_vs R OO local.rel_state (=)) Wrap return", "show ?thesis"], ["proof (prove)\nusing this:\n  (R ===> state_dp_consistency.crel_vs R OO local.rel_state (=)) Wrap return\n\ngoal (1 subgoal):\n 1. (R ===>\\<^sub>T R) Wrap return", "by (blast intro: rel_fun_mono crel_vsI)"], ["proof (state)\nthis:\n  (R ===>\\<^sub>T R) Wrap return\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crel_vs_return:\n  \"Transfer.Rel (crel_vs R) (Wrap x) (return y)\" if \"Transfer.Rel R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs R) (Wrap x) \\<langle>y\\<rangle>", "using that"], ["proof (prove)\nusing this:\n  Rel R x y\n\ngoal (1 subgoal):\n 1. Rel (crel_vs R) (Wrap x) \\<langle>y\\<rangle>", "unfolding Rel_def"], ["proof (prove)\nusing this:\n  R x y\n\ngoal (1 subgoal):\n 1. crel_vs R (Wrap x) \\<langle>y\\<rangle>", "by (rule transfer'_return[unfolded rel_fun_def, rule_format])"], ["", "lemma crel_vs_return_ext:\n  \"\\<lbrakk>Transfer.Rel R x y\\<rbrakk> \\<Longrightarrow> Transfer.Rel (crel_vs R) x (Heap_Monad.return y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel R x y \\<Longrightarrow> Rel (crel_vs R) x \\<langle>y\\<rangle>", "by (fact crel_vs_return[unfolded Wrap_def])"], ["", "term 0"], ["", "(**)"], ["", "lemma bind_transfer[transfer_rule]:\n  \"(crel_vs R0 ===> (R0 ===> crel_vs R1) ===> crel_vs R1) (\\<lambda>v f. f v) (\\<bind>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (crel_vs R0 ===> (R0 ===>\\<^sub>T R1) ===>\\<^sub>T R1)\n     (\\<lambda>v f. f v) (\\<bind>)", "unfolding rel_fun_def bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       crel_vs R0 x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<forall>x y.\n               R0 x y \\<longrightarrow>\n               crel_vs R1 (xa x) (ya y)) \\<longrightarrow>\n           crel_vs R1 (xa x)\n            (Heap.Heap\n              (\\<lambda>h.\n                  case execute y h of None \\<Rightarrow> None\n                  | Some (xa, xb) \\<Rightarrow> execute (ya xa) xb)))", "by safe (subst crel_vs_def, auto 4 4 elim: crel_vs_execute_Some elim!: crel_vs_executeD)"], ["", "lemma crel_vs_update:\n  \"crel_vs (=) () (update param (dp param))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (=) () (update param (dp param))", "by (rule\n      crel_vsI relcomppI state_dp_consistency.crel_vs_update\n      rel_state_update[unfolded rel_fun_def, rule_format] HOL.refl\n     )+"], ["", "lemma crel_vs_lookup:\n  \"crel_vs\n    (\\<lambda> v v'. case v' of None \\<Rightarrow> True | Some v' \\<Rightarrow> v = v' \\<and> v = dp param) (dp param) (lookup param)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs\n     (\\<lambda>v v'.\n         case v' of None \\<Rightarrow> True\n         | Some v' \\<Rightarrow> v = v' \\<and> v = dp param)\n     (dp param) (lookup param)", "by (rule\n      crel_vsI relcomppI state_dp_consistency.crel_vs_lookup\n      rel_state_lookup[unfolded rel_fun_def, rule_format] HOL.refl\n     )+"], ["", "lemma crel_vs_eq_eq_onp:\n  \"crel_vs (eq_onp (\\<lambda> x. x = v)) v s\" if \"crel_vs (=) v s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (eq_onp (\\<lambda>x. x = v)) v s", "using that"], ["proof (prove)\nusing this:\n  crel_vs (=) v s\n\ngoal (1 subgoal):\n 1. crel_vs (eq_onp (\\<lambda>x. x = v)) v s", "unfolding crel_vs_def"], ["proof (prove)\nusing this:\n  \\<forall>heap.\n     P heap \\<and>\n     Q heap \\<and> state_dp_consistency.cmem heap \\<longrightarrow>\n     (case execute s heap of None \\<Rightarrow> False\n      | Some (v', heap') \\<Rightarrow>\n          P heap' \\<and>\n          Q heap' \\<and> v = v' \\<and> state_dp_consistency.cmem heap')\n\ngoal (1 subgoal):\n 1. \\<forall>heap.\n       P heap \\<and>\n       Q heap \\<and> state_dp_consistency.cmem heap \\<longrightarrow>\n       (case execute s heap of None \\<Rightarrow> False\n        | Some (v', heap') \\<Rightarrow>\n            P heap' \\<and>\n            Q heap' \\<and>\n            eq_onp (\\<lambda>x. x = v) v v' \\<and>\n            state_dp_consistency.cmem heap')", "by (auto split: option.split simp: eq_onp_def)"], ["", "lemma crel_vs_bind_eq:\n  \"\\<lbrakk>crel_vs (=) v s; crel_vs R (f v) (sf v)\\<rbrakk> \\<Longrightarrow> crel_vs R (f v) (s \\<bind> sf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>crel_vs (=) v s; crel_vs R (f v) (sf v)\\<rbrakk>\n    \\<Longrightarrow> crel_vs R (f v) (s \\<bind> sf)", "by (erule bind_transfer[unfolded rel_fun_def, rule_format, OF crel_vs_eq_eq_onp])\n     (auto simp: eq_onp_def)"], ["", "lemma crel_vs_checkmem:\n  \"Transfer.Rel (crel_vs R) (dp param) (checkmem param s)\" if \"is_equality R\" \"Transfer.Rel (crel_vs R) (dp param) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel (crel_vs R) (dp param) (checkmem param s)", "unfolding checkmem_def Rel_def that(1)[unfolded is_equality_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. crel_vs (=) (dp param)\n     (lookup param \\<bind>\n      (\\<lambda>x.\n          case x of\n          None \\<Rightarrow>\n            s \\<bind>\n            (\\<lambda>x.\n                update param x \\<bind> (\\<lambda>_. \\<langle>x\\<rangle>))\n          | Some x \\<Rightarrow> \\<langle>x\\<rangle>))", "by (rule bind_transfer[unfolded rel_fun_def, rule_format, OF crel_vs_lookup])\n     (auto 4 3 split: option.split_asm intro: crel_vs_bind_eq crel_vs_update crel_vs_return[unfolded Wrap_def Rel_def] that(2)[unfolded Rel_def that(1)[unfolded is_equality_def]])"], ["", "lemma crel_vs_checkmem_tupled:\n  assumes \"v = dp param\"\n  shows \"\\<lbrakk>is_equality R; Transfer.Rel (crel_vs R) v s\\<rbrakk>\n        \\<Longrightarrow> Transfer.Rel (crel_vs R) v (checkmem param s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_equality R; Rel (crel_vs R) v s\\<rbrakk>\n    \\<Longrightarrow> Rel (crel_vs R) v (checkmem param s)", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_equality R; Rel (crel_vs R) (dp param) s\\<rbrakk>\n    \\<Longrightarrow> Rel (crel_vs R) (dp param) (checkmem param s)", "by (fact crel_vs_checkmem)"], ["", "lemma transfer_fun_app_lifted[transfer_rule]:\n  \"(crel_vs (R0 ===> crel_vs R1) ===> crel_vs R0 ===> crel_vs R1)\n    App Heap_Monad_Ext.fun_app_lifted\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (crel_vs (R0 ===>\\<^sub>T R1) ===> crel_vs R0 ===>\\<^sub>T R1) App (.)", "unfolding Heap_Monad_Ext.fun_app_lifted_def App_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (crel_vs (R0 ===>\\<^sub>T R1) ===> crel_vs R0 ===>\\<^sub>T R1)\n     (\\<lambda>f. f)\n     (\\<lambda>f\\<^sub>T x\\<^sub>T. f\\<^sub>T \\<bind> (\\<bind>) x\\<^sub>T)", "by transfer_prover"], ["", "lemma crel_vs_fun_app:\n  \"\\<lbrakk>Transfer.Rel (crel_vs R0) x x\\<^sub>T; Transfer.Rel (crel_vs (R0 ===>\\<^sub>T R1)) f f\\<^sub>T\\<rbrakk> \\<Longrightarrow> Transfer.Rel (crel_vs R1) (App f x) (f\\<^sub>T . x\\<^sub>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rel (crel_vs R0) x x\\<^sub>T;\n     Rel (crel_vs (R0 ===>\\<^sub>T R1)) f f\\<^sub>T\\<rbrakk>\n    \\<Longrightarrow> Rel (crel_vs R1) (App f x) (f\\<^sub>T . x\\<^sub>T)", "unfolding Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>crel_vs R0 x x\\<^sub>T;\n     crel_vs (R0 ===>\\<^sub>T R1) f f\\<^sub>T\\<rbrakk>\n    \\<Longrightarrow> crel_vs R1 (App f x) (f\\<^sub>T . x\\<^sub>T)", "using transfer_fun_app_lifted[THEN rel_funD, THEN rel_funD]"], ["proof (prove)\nusing this:\n  \\<lbrakk>crel_vs (?R0.2 ===>\\<^sub>T ?R1.2) ?x1 ?y1;\n   crel_vs ?R0.2 ?x ?y\\<rbrakk>\n  \\<Longrightarrow> crel_vs ?R1.2 (App ?x1 ?x) (?y1 . ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>crel_vs R0 x x\\<^sub>T;\n     crel_vs (R0 ===>\\<^sub>T R1) f f\\<^sub>T\\<rbrakk>\n    \\<Longrightarrow> crel_vs R1 (App f x) (f\\<^sub>T . x\\<^sub>T)", "."], ["", "end"], ["", "(* Lifting Syntax *)"], ["", "end"], ["", "(* Dynamic Programming Problem *)"], ["", "locale dp_consistency_heap = heap_correct +\n  fixes dp :: \"'a \\<Rightarrow> 'b\"\nbegin"], ["", "interpretation state_mem_correct: mem_correct lookup' update' P"], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_correct lookup' update' P", "by (rule mem_correct_heap)"], ["", "interpretation state_dp_consistency: dp_consistency lookup' update' P dp"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency lookup' update' P", ".."], ["", "lemma dp_heap: \"dp_heap P P lookup lookup' update update'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_heap P P lookup lookup' update update'", "by (standard; rule transfer_lookup transfer_update)"], ["", "sublocale dp_heap P P dp lookup lookup' update update'"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_heap P P lookup lookup' update update'", "by (rule dp_heap)"], ["", "notation rel_fun_lifted (infixr \"===>\\<^sub>T\" 55)"], ["", "end"], ["", "locale heap_correct_empty = heap_correct +\n  fixes empty\n  assumes empty_correct: \"map_of_heap empty \\<subseteq>\\<^sub>m Map.empty\" and P_empty: \"P empty\""], ["", "locale dp_consistency_heap_empty =\n  dp_consistency_heap + heap_correct_empty\nbegin"], ["", "lemma cmem_empty:\n  \"state_dp_consistency.cmem empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_dp_consistency.cmem empty", "using empty_correct"], ["proof (prove)\nusing this:\n  map_of_heap empty \\<subseteq>\\<^sub>m Map.empty\n\ngoal (1 subgoal):\n 1. state_dp_consistency.cmem empty", "unfolding state_dp_consistency.cmem_def"], ["proof (prove)\nusing this:\n  map_of_heap empty \\<subseteq>\\<^sub>m Map.empty\n\ngoal (1 subgoal):\n 1. \\<forall>param\\<in>dom (state_dp_consistency.map_of empty).\n       state_dp_consistency.map_of empty param = Some (dp param)", "unfolding map_of_heap_def"], ["proof (prove)\nusing this:\n  (\\<lambda>k. fst (the (execute (lookup k) empty))) \\<subseteq>\\<^sub>m\n  Map.empty\n\ngoal (1 subgoal):\n 1. \\<forall>param\\<in>dom (state_dp_consistency.map_of empty).\n       state_dp_consistency.map_of empty param = Some (dp param)", "unfolding state_dp_consistency.map_of_def"], ["proof (prove)\nusing this:\n  (\\<lambda>k. fst (the (execute (lookup k) empty))) \\<subseteq>\\<^sub>m\n  Map.empty\n\ngoal (1 subgoal):\n 1. \\<forall>param\\<in>dom (\\<lambda>k. fst (run_state (lookup' k) empty)).\n       fst (run_state (lookup' param) empty) = Some (dp param)", "unfolding lookup'_def"], ["proof (prove)\nusing this:\n  (\\<lambda>k. fst (the (execute (lookup k) empty))) \\<subseteq>\\<^sub>m\n  Map.empty\n\ngoal (1 subgoal):\n 1. \\<forall>param\n             \\<in>dom (\\<lambda>k.\n                          fst (run_state\n                                (State\n                                  (\\<lambda>heap.\nthe (execute (lookup k) heap)))\n                                empty)).\n       fst (run_state\n             (State (\\<lambda>heap. the (execute (lookup param) heap)))\n             empty) =\n       Some (dp param)", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>dom (\\<lambda>k. fst (the (execute (lookup k) empty))).\n     fst (the (execute (lookup a) empty)) = None\n\ngoal (1 subgoal):\n 1. \\<forall>param\n             \\<in>dom (\\<lambda>k.\n                          fst (run_state\n                                (State\n                                  (\\<lambda>heap.\nthe (execute (lookup k) heap)))\n                                empty)).\n       fst (run_state\n             (State (\\<lambda>heap. the (execute (lookup param) heap)))\n             empty) =\n       Some (dp param)", "by auto"], ["", "corollary memoization_correct:\n  \"dp x = v\" \"state_dp_consistency.cmem m\" if\n  \"consistentDP dp\\<^sub>T\" \"Heap_Monad.execute (dp\\<^sub>T x) empty = Some (v, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp x = v &&& state_dp_consistency.cmem m", "using that"], ["proof (prove)\nusing this:\n  consistentDP dp\\<^sub>T\n  execute (dp\\<^sub>T x) empty = Some (v, m)\n\ngoal (1 subgoal):\n 1. dp x = v &&& state_dp_consistency.cmem m", "unfolding consistentDP_def"], ["proof (prove)\nusing this:\n  ((=) ===>\\<^sub>T (=)) dp dp\\<^sub>T\n  execute (dp\\<^sub>T x) empty = Some (v, m)\n\ngoal (1 subgoal):\n 1. dp x = v &&& state_dp_consistency.cmem m", "by (auto dest!: rel_funD[where x = x] elim!: crel_vs_executeD intro: P_empty cmem_empty)"], ["", "lemma memoized_success:\n  \"success (dp\\<^sub>T x) empty\" if \"consistentDP dp\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success (dp\\<^sub>T x) empty", "using that cmem_empty P_empty"], ["proof (prove)\nusing this:\n  consistentDP dp\\<^sub>T\n  state_dp_consistency.cmem empty\n  P empty\n\ngoal (1 subgoal):\n 1. success (dp\\<^sub>T x) empty", "by (auto dest!: rel_funD intro: crel_vs_success simp: consistentDP_def)"], ["", "lemma memoized:\n  \"dp x = fst (the (Heap_Monad.execute (dp\\<^sub>T x) empty))\" if \"consistentDP dp\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dp x = fst (the (execute (dp\\<^sub>T x) empty))", "using surjective_pairing memoization_correct(1)[OF that]\n    memoized_success[OF that, unfolded success_def]"], ["proof (prove)\nusing this:\n  ?t = (fst ?t, snd ?t)\n  execute (dp\\<^sub>T ?x) empty = Some (?v, ?m) \\<Longrightarrow> dp ?x = ?v\n  execute (dp\\<^sub>T ?x) empty \\<noteq> None\n\ngoal (1 subgoal):\n 1. dp x = fst (the (execute (dp\\<^sub>T x) empty))", "by (cases \"execute (dp\\<^sub>T x) empty\"; auto)"], ["", "lemma cmem_result:\n  \"state_dp_consistency.cmem (snd (the (Heap_Monad.execute (dp\\<^sub>T x) empty)))\" if \"consistentDP dp\\<^sub>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_dp_consistency.cmem (snd (the (execute (dp\\<^sub>T x) empty)))", "using surjective_pairing memoization_correct(2)[OF that(1)]\n    memoized_success[OF that, unfolded success_def]"], ["proof (prove)\nusing this:\n  ?t = (fst ?t, snd ?t)\n  execute (dp\\<^sub>T ?x) empty = Some (?v, ?m) \\<Longrightarrow>\n  state_dp_consistency.cmem ?m\n  execute (dp\\<^sub>T ?x) empty \\<noteq> None\n\ngoal (1 subgoal):\n 1. state_dp_consistency.cmem (snd (the (execute (dp\\<^sub>T x) empty)))", "by (cases \"execute (dp\\<^sub>T x) empty\"; auto)"], ["", "end"], ["", "end"], ["", "(* Theory *)"]]}