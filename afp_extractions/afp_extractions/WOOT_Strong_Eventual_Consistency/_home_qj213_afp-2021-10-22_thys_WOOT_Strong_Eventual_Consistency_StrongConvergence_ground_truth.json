{"file_name": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency/StrongConvergence.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency", "problem_names": ["lemma  (in dist_execution) happened_before_same:\n  assumes \"i < j\"\n  assumes \"j < length (events k)\"\n  shows \"(happened_immediately_before)\\<^sup>+\\<^sup>+ (k,i) (k,j)\"", "lemma make_set_nil [simp]: \"make_set 0 p = {}\"", "lemma make_set_suc [simp]: \"make_set (Suc k) p = make_set k p \\<union> {x. p k x}\"", "lemma (in dist_execution) received_messages_eff:\n  assumes \"is_valid_state_id (i,j)\"\n  shows \"set (received_messages (i,j)) = make_set j (\\<lambda>k x. (\\<exists>s. event_at (i, k) (Receive s x)))\"", "lemma (in dist_execution) finite_valid_event_ids:\n  \"finite {i. is_valid_event_id i}\"", "lemma (in dist_execution) send_insert_id_1:\n  \"state i \\<bind> (\\<lambda>s. create_insert s n \\<sigma> i) = Inr (Insert m) \\<Longrightarrow> I m = i\"", "lemma (in dist_execution) send_insert_id_2:\n  \"state i \\<bind> (\\<lambda>s. create_delete s n) = Inr (Insert m) \\<Longrightarrow> False\"", "lemma (in dist_execution) send_insert_id:\n  \"event_at i (Send (Insert m)) \\<Longrightarrow> I m = i\"", "lemma (in dist_execution) recv_insert_once:\n  \"event_at (i,j) (Receive s (Insert m)) \\<Longrightarrow> event_at (i,k) (Receive t (Insert m)) \\<Longrightarrow> j = k\"", "lemma foldM_rev: \"foldM f s (li@[ll]) = foldM f s li \\<bind> (\\<lambda>t. f t ll)\"", "lemma  (in dist_execution) state_is_associated_string':\n  fixes i M\n  assumes \"j \\<le> length (events i)\"\n  assumes \"consistent M\"\n  assumes \"make_set j (\\<lambda>k m. \\<exists>s. event_at (i,k) (Receive s m)) \\<subseteq> M\"\n  shows \"is_certified_associated_string (make_set j (\\<lambda>k m. \\<exists>s. event_at (i,k) (Receive s m))) (state (i,j))\"", "lemma  (in dist_execution) sent_before_recv:\n  assumes \"event_at (i,k) (Receive s m)\"\n  assumes \"j < length (events i)\"\n  assumes \"k < j\" \n  shows \"event_at s (Send m) \\<and> happened_immediately_before\\<^sup>+\\<^sup>+ s (i,j)\"", "lemma (in dist_execution) irrefl_p: \"irreflp (happened_immediately_before\\<^sup>+\\<^sup>+)\"", "lemma (in dist_execution) new_messages_keep_consistency:\n  assumes \"consistent M\"\n  assumes \"event_at i (Send m)\"\n  assumes \"set (received_messages i) \\<subseteq> M\"\n  assumes \"i \\<notin> I ` insert_messages M\"\n  shows \"consistent (insert m M)\"", "lemma (in dist_execution) sent_messages_consistent:\n  \"consistent {m. (\\<exists>i. event_at i (Send m))}\"", "lemma (in dist_execution) received_messages_were_sent:\n  assumes \"is_valid_state_id (i,j)\"\n  shows \"make_set j (\\<lambda>k m. (\\<exists>s. event_at (i, k) (Receive s m))) \\<subseteq> {m. \\<exists>i. event_at i (Send m)}\"", "lemma (in dist_execution) state_is_associated_string:\n  assumes \"is_valid_state_id i\"\n  shows \"is_certified_associated_string (set (received_messages i)) (state i)\""], "translations": [["", "lemma  (in dist_execution) happened_before_same:\n  assumes \"i < j\"\n  assumes \"j < length (events k)\"\n  shows \"(happened_immediately_before)\\<^sup>+\\<^sup>+ (k,i) (k,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, j)", "obtain v where v_def: \"j = Suc i + v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. j = Suc i + v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) less_iff_Suc_add"], ["proof (prove)\nusing this:\n  i < j\n  (?m < ?n) = (\\<exists>k. ?n = Suc (?m + k))\n\ngoal (1 subgoal):\n 1. (\\<And>v. j = Suc i + v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j = Suc i + v\n\ngoal (1 subgoal):\n 1. happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, j)", "have \"is_valid_event_id (k, Suc i + v) \\<longrightarrow> (happened_immediately_before)\\<^sup>+\\<^sup>+ (k,i) (k, Suc i + v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_event_id (k, Suc i + v) \\<longrightarrow>\n    happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, Suc i + v)", "apply (induction v, simp add: tranclp.r_into_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       is_valid_event_id (k, Suc i + v) \\<longrightarrow>\n       happened_immediately_before\\<^sup>+\\<^sup>+ (k, i)\n        (k, Suc i + v) \\<Longrightarrow>\n       is_valid_event_id (k, Suc i + Suc v) \\<longrightarrow>\n       happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, Suc i + Suc v)", "by (metis Suc_lessD add_Suc_right fst_conv happened_immediately_before.elims(3) \n        is_valid_event_id.simps snd_conv tranclp.simps)"], ["proof (state)\nthis:\n  is_valid_event_id (k, Suc i + v) \\<longrightarrow>\n  happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, Suc i + v)\n\ngoal (1 subgoal):\n 1. happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, j)", "then"], ["proof (chain)\npicking this:\n  is_valid_event_id (k, Suc i + v) \\<longrightarrow>\n  happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, Suc i + v)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_valid_event_id (k, Suc i + v) \\<longrightarrow>\n  happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, Suc i + v)\n\ngoal (1 subgoal):\n 1. happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, j)", "using is_valid_event_id.simps v_def assms"], ["proof (prove)\nusing this:\n  is_valid_event_id (k, Suc i + v) \\<longrightarrow>\n  happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, Suc i + v)\n  is_valid_event_id (?i, ?j) = (?j < length (events ?i))\n  j = Suc i + v\n  i < j\n  j < length (events k)\n\ngoal (1 subgoal):\n 1. happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, j)", "by blast"], ["proof (state)\nthis:\n  happened_immediately_before\\<^sup>+\\<^sup>+ (k, i) (k, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition make_set where \"make_set (k :: nat) p = {x. \\<exists>j. p j x \\<and> j < k}\""], ["", "lemma make_set_nil [simp]: \"make_set 0 p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_set 0 p = {}", "by (simp add:make_set_def)"], ["", "lemma make_set_suc [simp]: \"make_set (Suc k) p = make_set k p \\<union> {x. p k x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_set (Suc k) p = make_set k p \\<union> {x. p k x}", "using less_Suc_eq"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. make_set (Suc k) p = make_set k p \\<union> {x. p k x}", "by (simp add:make_set_def, blast)"], ["", "lemma (in dist_execution) received_messages_eff:\n  assumes \"is_valid_state_id (i,j)\"\n  shows \"set (received_messages (i,j)) = make_set j (\\<lambda>k x. (\\<exists>s. event_at (i, k) (Receive s x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (received_messages (i, j)) =\n    make_set j (\\<lambda>k x. \\<exists>s. event_at (i, k) (Receive s x))", "using assms"], ["proof (prove)\nusing this:\n  is_valid_state_id (i, j)\n\ngoal (1 subgoal):\n 1. set (received_messages (i, j)) =\n    make_set j (\\<lambda>k x. \\<exists>s. event_at (i, k) (Receive s x))", "by (induction j, simp add:make_set_def, simp add: take_Suc_conv_app_nth)"], ["", "lemma (in dist_execution) finite_valid_event_ids:\n  \"finite {i. is_valid_event_id i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect is_valid_event_id)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect is_valid_event_id)", "define X where \"X = {p. events p = events p}\""], ["proof (state)\nthis:\n  X = {p. events p = events p}\n\ngoal (1 subgoal):\n 1. finite (Collect is_valid_event_id)", "have \"finite X \\<Longrightarrow> \\<exists>m. (\\<forall>p \\<in> X. (length (events p)) < m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow>\n    \\<exists>m. \\<forall>p\\<in>X. length (events p) < m", "apply (induction rule:finite_induct, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>m. \\<forall>p\\<in>F. length (events p) < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<forall>p\\<in>insert x F. length (events p) < m", "by (metis gt_ex insert_iff le_less_trans less_imp_not_less not_le_imp_less)"], ["proof (state)\nthis:\n  finite X \\<Longrightarrow>\n  \\<exists>m. \\<forall>p\\<in>X. length (events p) < m\n\ngoal (1 subgoal):\n 1. finite (Collect is_valid_event_id)", "then"], ["proof (chain)\npicking this:\n  finite X \\<Longrightarrow>\n  \\<exists>m. \\<forall>p\\<in>X. length (events p) < m", "obtain m where m_def: \"\\<And>p. length (events p) < m\""], ["proof (prove)\nusing this:\n  finite X \\<Longrightarrow>\n  \\<exists>m. \\<forall>p\\<in>X. length (events p) < m\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        (\\<And>p. length (events p) < m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using X_def fin_peers"], ["proof (prove)\nusing this:\n  finite X \\<Longrightarrow>\n  \\<exists>m. \\<forall>p\\<in>X. length (events p) < m\n  X = {p. events p = events p}\n  finite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        (\\<And>p. length (events p) < m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length (events ?p) < m\n\ngoal (1 subgoal):\n 1. finite (Collect is_valid_event_id)", "have \"{(i,j). is_valid_event_id (i,j)} \\<subseteq> {(i,j). j < m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i, j). is_valid_event_id (i, j)} \\<subseteq> {(i, j). j < m}", "using m_def"], ["proof (prove)\nusing this:\n  length (events ?p) < m\n\ngoal (1 subgoal):\n 1. {(i, j). is_valid_event_id (i, j)} \\<subseteq> {(i, j). j < m}", "by (simp add: Collect_mono_iff less_trans)"], ["proof (state)\nthis:\n  {(i, j). is_valid_event_id (i, j)} \\<subseteq> {(i, j). j < m}\n\ngoal (1 subgoal):\n 1. finite (Collect is_valid_event_id)", "also"], ["proof (state)\nthis:\n  {(i, j). is_valid_event_id (i, j)} \\<subseteq> {(i, j). j < m}\n\ngoal (1 subgoal):\n 1. finite (Collect is_valid_event_id)", "have \"... \\<subseteq> X \\<times> {j. j < m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i, j). j < m} \\<subseteq> X \\<times> {j. j < m}", "using X_def"], ["proof (prove)\nusing this:\n  X = {p. events p = events p}\n\ngoal (1 subgoal):\n 1. {(i, j). j < m} \\<subseteq> X \\<times> {j. j < m}", "by blast"], ["proof (state)\nthis:\n  {(i, j). j < m} \\<subseteq> X \\<times> {j. j < m}\n\ngoal (1 subgoal):\n 1. finite (Collect is_valid_event_id)", "finally"], ["proof (chain)\npicking this:\n  {(i, j). is_valid_event_id (i, j)} \\<subseteq> X \\<times> {j. j < m}", "have \"{i. is_valid_event_id i} \\<subseteq> X \\<times> {j. j < m}\""], ["proof (prove)\nusing this:\n  {(i, j). is_valid_event_id (i, j)} \\<subseteq> X \\<times> {j. j < m}\n\ngoal (1 subgoal):\n 1. Collect is_valid_event_id \\<subseteq> X \\<times> {j. j < m}", "by (simp add: subset_iff)"], ["proof (state)\nthis:\n  Collect is_valid_event_id \\<subseteq> X \\<times> {j. j < m}\n\ngoal (1 subgoal):\n 1. finite (Collect is_valid_event_id)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Collect is_valid_event_id \\<subseteq> X \\<times> {j. j < m}\n\ngoal (1 subgoal):\n 1. finite (Collect is_valid_event_id)", "using fin_peers finite_Collect_less_nat finite_cartesian_product\n        infinite_super subset_eq"], ["proof (prove)\nusing this:\n  Collect is_valid_event_id \\<subseteq> X \\<times> {j. j < m}\n  finite UNIV\n  finite {n. n < ?k}\n  \\<lbrakk>finite ?A; finite ?B\\<rbrakk>\n  \\<Longrightarrow> finite (?A \\<times> ?B)\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n  (?A \\<subseteq> ?B) = (\\<forall>x\\<in>?A. x \\<in> ?B)\n\ngoal (1 subgoal):\n 1. finite (Collect is_valid_event_id)", "by (metis UNIV_I)"], ["proof (state)\nthis:\n  finite (Collect is_valid_event_id)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in dist_execution) send_insert_id_1:\n  \"state i \\<bind> (\\<lambda>s. create_insert s n \\<sigma> i) = Inr (Insert m) \\<Longrightarrow> I m = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state i \\<bind> (\\<lambda>s. create_insert s n \\<sigma> i) =\n    Inr (Insert m) \\<Longrightarrow>\n    I m = i", "by fastforce"], ["", "lemma (in dist_execution) send_insert_id_2:\n  \"state i \\<bind> (\\<lambda>s. create_delete s n) = Inr (Insert m) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state i \\<bind> (\\<lambda>s. create_delete s n) =\n    Inr (Insert m) \\<Longrightarrow>\n    False", "by fastforce"], ["", "lemma (in dist_execution) send_insert_id:\n  \"event_at i (Send (Insert m)) \\<Longrightarrow> I m = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. event_at i (Send (Insert m)) \\<Longrightarrow> I m = i", "using send_correct send_insert_id_1 send_insert_id_2"], ["proof (prove)\nusing this:\n  event_at ?i (Send ?m) \\<Longrightarrow>\n  (\\<exists>n \\<sigma>.\n      Inr ?m =\n      state ?i \\<bind> (\\<lambda>s. create_insert s n \\<sigma> ?i)) \\<or>\n  (\\<exists>n. Inr ?m = state ?i \\<bind> (\\<lambda>s. create_delete s n))\n  state ?i \\<bind> (\\<lambda>s. create_insert s ?n ?\\<sigma> ?i) =\n  Inr (Insert ?m) \\<Longrightarrow>\n  I ?m = ?i\n  state ?i \\<bind> (\\<lambda>s. create_delete s ?n) =\n  Inr (Insert ?m) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. event_at i (Send (Insert m)) \\<Longrightarrow> I m = i", "by metis"], ["", "lemma (in dist_execution) recv_insert_once:\n  \"event_at (i,j) (Receive s (Insert m)) \\<Longrightarrow> event_at (i,k) (Receive t (Insert m)) \\<Longrightarrow> j = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>event_at (i, j) (Receive s (Insert m));\n     event_at (i, k) (Receive t (Insert m))\\<rbrakk>\n    \\<Longrightarrow> j = k", "using no_data_corruption send_insert_id at_most_once"], ["proof (prove)\nusing this:\n  event_at ?i (Receive ?s ?m) \\<Longrightarrow> event_at ?s (Send ?m)\n  event_at ?i (Send (Insert ?m)) \\<Longrightarrow> I ?m = ?i\n  \\<lbrakk>event_at ?i (Receive ?s ?m); event_at ?j (Receive ?s ?m);\n   fst ?i = fst ?j\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>event_at (i, j) (Receive s (Insert m));\n     event_at (i, k) (Receive t (Insert m))\\<rbrakk>\n    \\<Longrightarrow> j = k", "by (simp, metis (mono_tags) Pair_inject event_pred.simps fst_conv is_valid_event_id.simps)"], ["", "proposition integrate_insert_commute':\n  fixes M m s\n  assumes \"consistent M\"\n  assumes \"is_delete m \\<or> m \\<notin> T\"\n  assumes \"m \\<in> M\"\n  assumes \"T \\<subseteq> M\"\n  assumes \"deps m \\<subseteq> I ` insert_messages T\" \n  assumes \"is_certified_associated_string T s\"\n  shows \"is_certified_associated_string (T \\<union> {m}) (s \\<bind> (\\<lambda>t. integrate t m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string (T \\<union> {m})\n     (s \\<bind> (\\<lambda>t. integrate t m))", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       is_certified_associated_string (T \\<union> {m})\n        (s \\<bind> (\\<lambda>t. integrate t m))\n 2. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       is_certified_associated_string (T \\<union> {m})\n        (s \\<bind> (\\<lambda>t. integrate t m))", "case (Inl a)"], ["proof (state)\nthis:\n  s = Inl a\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       is_certified_associated_string (T \\<union> {m})\n        (s \\<bind> (\\<lambda>t. integrate t m))\n 2. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       is_certified_associated_string (T \\<union> {m})\n        (s \\<bind> (\\<lambda>t. integrate t m))", "then"], ["proof (chain)\npicking this:\n  s = Inl a", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Inl a\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (T \\<union> {m})\n     (s \\<bind> (\\<lambda>t. integrate t m))", "using assms"], ["proof (prove)\nusing this:\n  s = Inl a\n  consistent M\n  is_delete m \\<or> m \\<notin> T\n  m \\<in> M\n  T \\<subseteq> M\n  deps m \\<subseteq> I ` insert_messages T\n  is_certified_associated_string T s\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (T \\<union> {m})\n     (s \\<bind> (\\<lambda>t. integrate t m))", "by simp"], ["proof (state)\nthis:\n  is_certified_associated_string (T \\<union> {m})\n   (s \\<bind> (\\<lambda>t. integrate t m))\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       is_certified_associated_string (T \\<union> {m})\n        (s \\<bind> (\\<lambda>t. integrate t m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       is_certified_associated_string (T \\<union> {m})\n        (s \\<bind> (\\<lambda>t. integrate t m))", "case (Inr b)"], ["proof (state)\nthis:\n  s = Inr b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       is_certified_associated_string (T \\<union> {m})\n        (s \\<bind> (\\<lambda>t. integrate t m))", "have \"T \\<union> {m} \\<subseteq> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<union> {m} \\<subseteq> M", "using assms(3) assms(4)"], ["proof (prove)\nusing this:\n  m \\<in> M\n  T \\<subseteq> M\n\ngoal (1 subgoal):\n 1. T \\<union> {m} \\<subseteq> M", "by simp"], ["proof (state)\nthis:\n  T \\<union> {m} \\<subseteq> M\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       is_certified_associated_string (T \\<union> {m})\n        (s \\<bind> (\\<lambda>t. integrate t m))", "moreover"], ["proof (state)\nthis:\n  T \\<union> {m} \\<subseteq> M\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       is_certified_associated_string (T \\<union> {m})\n        (s \\<bind> (\\<lambda>t. integrate t m))", "have \"\\<Union> (deps ` (T \\<union> {m})) \\<subseteq> I ` insert_messages (T \\<union> {m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (deps ` (T \\<union> {m}))\n    \\<subseteq> I ` insert_messages (T \\<union> {m})", "using assms(5) assms(6) Inr"], ["proof (prove)\nusing this:\n  deps m \\<subseteq> I ` insert_messages T\n  is_certified_associated_string T s\n  s = Inr b\n\ngoal (1 subgoal):\n 1. \\<Union> (deps ` (T \\<union> {m}))\n    \\<subseteq> I ` insert_messages (T \\<union> {m})", "apply (simp add:is_associated_string_def consistent_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deps m \\<subseteq> I ` insert_messages T;\n     inj_on I (insert_messages T) \\<and>\n     \\<Union> (deps ` T) \\<subseteq> I ` insert_messages T \\<and>\n     wfP (depends_on (insert_messages T)) \\<and>\n     Ex (a_conditions (insert_messages T)) \\<and>\n     set b = to_woot_character T ` insert_messages T \\<and>\n     (\\<forall>a.\n         a_conditions (insert_messages T) a \\<longrightarrow>\n         sorted_wrt (<) (map a (ext_ids b)));\n     s = Inr b\\<rbrakk>\n    \\<Longrightarrow> deps m\n                      \\<subseteq> I ` insert_messages (insert m T) \\<and>\n                      \\<Union> (deps ` T)\n                      \\<subseteq> I ` insert_messages (insert m T)", "by (meson dual_order.trans subset_insertI subset_mono)"], ["proof (state)\nthis:\n  \\<Union> (deps ` (T \\<union> {m}))\n  \\<subseteq> I ` insert_messages (T \\<union> {m})\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       is_certified_associated_string (T \\<union> {m})\n        (s \\<bind> (\\<lambda>t. integrate t m))", "ultimately"], ["proof (chain)\npicking this:\n  T \\<union> {m} \\<subseteq> M\n  \\<Union> (deps ` (T \\<union> {m}))\n  \\<subseteq> I ` insert_messages (T \\<union> {m})", "have \"consistent (T \\<union> {m})\""], ["proof (prove)\nusing this:\n  T \\<union> {m} \\<subseteq> M\n  \\<Union> (deps ` (T \\<union> {m}))\n  \\<subseteq> I ` insert_messages (T \\<union> {m})\n\ngoal (1 subgoal):\n 1. consistent (T \\<union> {m})", "using assms consistent_subset"], ["proof (prove)\nusing this:\n  T \\<union> {m} \\<subseteq> M\n  \\<Union> (deps ` (T \\<union> {m}))\n  \\<subseteq> I ` insert_messages (T \\<union> {m})\n  consistent M\n  is_delete m \\<or> m \\<notin> T\n  m \\<in> M\n  T \\<subseteq> M\n  deps m \\<subseteq> I ` insert_messages T\n  is_certified_associated_string T s\n  \\<lbrakk>consistent ?N; ?M \\<subseteq> ?N;\n   \\<Union> (deps ` ?M) \\<subseteq> I ` insert_messages ?M\\<rbrakk>\n  \\<Longrightarrow> consistent ?M\n\ngoal (1 subgoal):\n 1. consistent (T \\<union> {m})", "by force"], ["proof (state)\nthis:\n  consistent (T \\<union> {m})\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       is_certified_associated_string (T \\<union> {m})\n        (s \\<bind> (\\<lambda>t. integrate t m))", "then"], ["proof (chain)\npicking this:\n  consistent (T \\<union> {m})", "show ?thesis"], ["proof (prove)\nusing this:\n  consistent (T \\<union> {m})\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (T \\<union> {m})\n     (s \\<bind> (\\<lambda>t. integrate t m))", "using integrate_insert_commute assms(2) assms(6) Inr"], ["proof (prove)\nusing this:\n  consistent (T \\<union> {m})\n  \\<lbrakk>consistent (?M \\<union> {?m}); is_delete ?m \\<or> ?m \\<notin> ?M;\n   is_associated_string ?M ?s\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string (?M \\<union> {?m})\n                     (integrate ?s ?m)\n  is_delete m \\<or> m \\<notin> T\n  is_certified_associated_string T s\n  s = Inr b\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (T \\<union> {m})\n     (s \\<bind> (\\<lambda>t. integrate t m))", "by auto"], ["proof (state)\nthis:\n  is_certified_associated_string (T \\<union> {m})\n   (s \\<bind> (\\<lambda>t. integrate t m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foldM_rev: \"foldM f s (li@[ll]) = foldM f s li \\<bind> (\\<lambda>t. f t ll)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldM f s (li @ [ll]) = foldM f s li \\<bind> (\\<lambda>t. f t ll)", "by (induction li arbitrary:s, simp+)"], ["", "lemma  (in dist_execution) state_is_associated_string':\n  fixes i M\n  assumes \"j \\<le> length (events i)\"\n  assumes \"consistent M\"\n  assumes \"make_set j (\\<lambda>k m. \\<exists>s. event_at (i,k) (Receive s m)) \\<subseteq> M\"\n  shows \"is_certified_associated_string (make_set j (\\<lambda>k m. \\<exists>s. event_at (i,k) (Receive s m))) (state (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string\n     (make_set j (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n     (state (i, j))", "using assms"], ["proof (prove)\nusing this:\n  j \\<le> length (events i)\n  consistent M\n  make_set j (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n  \\<subseteq> M\n\ngoal (1 subgoal):\n 1. is_certified_associated_string\n     (make_set j (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n     (state (i, j))", "proof (induction j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> length (events i); consistent M;\n     make_set 0 (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n     \\<subseteq> M\\<rbrakk>\n    \\<Longrightarrow> is_certified_associated_string\n                       (make_set 0\n                         (\\<lambda>k m.\n                             \\<exists>s. event_at (i, k) (Receive s m)))\n                       (state (i, 0))\n 2. \\<And>j.\n       \\<lbrakk>\\<lbrakk>j \\<le> length (events i); consistent M;\n                 make_set j\n                  (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n                 \\<subseteq> M\\<rbrakk>\n                \\<Longrightarrow> is_certified_associated_string\n                                   (make_set j\n                                     (\\<lambda>k m.\n   \\<exists>s. event_at (i, k) (Receive s m)))\n                                   (state (i, j));\n        Suc j \\<le> length (events i); consistent M;\n        make_set (Suc j)\n         (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n        \\<subseteq> M\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string\n                          (make_set (Suc j)\n                            (\\<lambda>k m.\n                                \\<exists>s. event_at (i, k) (Receive s m)))\n                          (state (i, Suc j))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> length (events i)\n  consistent M\n  make_set 0 (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n  \\<subseteq> M\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> length (events i); consistent M;\n     make_set 0 (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n     \\<subseteq> M\\<rbrakk>\n    \\<Longrightarrow> is_certified_associated_string\n                       (make_set 0\n                         (\\<lambda>k m.\n                             \\<exists>s. event_at (i, k) (Receive s m)))\n                       (state (i, 0))\n 2. \\<And>j.\n       \\<lbrakk>\\<lbrakk>j \\<le> length (events i); consistent M;\n                 make_set j\n                  (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n                 \\<subseteq> M\\<rbrakk>\n                \\<Longrightarrow> is_certified_associated_string\n                                   (make_set j\n                                     (\\<lambda>k m.\n   \\<exists>s. event_at (i, k) (Receive s m)))\n                                   (state (i, j));\n        Suc j \\<le> length (events i); consistent M;\n        make_set (Suc j)\n         (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n        \\<subseteq> M\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string\n                          (make_set (Suc j)\n                            (\\<lambda>k m.\n                                \\<exists>s. event_at (i, k) (Receive s m)))\n                          (state (i, Suc j))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> length (events i)\n  consistent M\n  make_set 0 (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n  \\<subseteq> M", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> length (events i)\n  consistent M\n  make_set 0 (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n  \\<subseteq> M\n\ngoal (1 subgoal):\n 1. is_certified_associated_string\n     (make_set 0 (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n     (state (i, 0))", "by (simp add: empty_associated)"], ["proof (state)\nthis:\n  is_certified_associated_string\n   (make_set 0 (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n   (state (i, 0))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>j \\<le> length (events i); consistent M;\n                 make_set j\n                  (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n                 \\<subseteq> M\\<rbrakk>\n                \\<Longrightarrow> is_certified_associated_string\n                                   (make_set j\n                                     (\\<lambda>k m.\n   \\<exists>s. event_at (i, k) (Receive s m)))\n                                   (state (i, j));\n        Suc j \\<le> length (events i); consistent M;\n        make_set (Suc j)\n         (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n        \\<subseteq> M\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string\n                          (make_set (Suc j)\n                            (\\<lambda>k m.\n                                \\<exists>s. event_at (i, k) (Receive s m)))\n                          (state (i, Suc j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>j \\<le> length (events i); consistent M;\n                 make_set j\n                  (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n                 \\<subseteq> M\\<rbrakk>\n                \\<Longrightarrow> is_certified_associated_string\n                                   (make_set j\n                                     (\\<lambda>k m.\n   \\<exists>s. event_at (i, k) (Receive s m)))\n                                   (state (i, j));\n        Suc j \\<le> length (events i); consistent M;\n        make_set (Suc j)\n         (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n        \\<subseteq> M\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string\n                          (make_set (Suc j)\n                            (\\<lambda>k m.\n                                \\<exists>s. event_at (i, k) (Receive s m)))\n                          (state (i, Suc j))", "case (Suc j)"], ["proof (state)\nthis:\n  \\<lbrakk>j \\<le> length (events i); consistent M;\n   make_set j (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n   \\<subseteq> M\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string\n                     (make_set j\n                       (\\<lambda>k m.\n                           \\<exists>s. event_at (i, k) (Receive s m)))\n                     (state (i, j))\n  Suc j \\<le> length (events i)\n  consistent M\n  make_set (Suc j) (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n  \\<subseteq> M\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>j \\<le> length (events i); consistent M;\n                 make_set j\n                  (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n                 \\<subseteq> M\\<rbrakk>\n                \\<Longrightarrow> is_certified_associated_string\n                                   (make_set j\n                                     (\\<lambda>k m.\n   \\<exists>s. event_at (i, k) (Receive s m)))\n                                   (state (i, j));\n        Suc j \\<le> length (events i); consistent M;\n        make_set (Suc j)\n         (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n        \\<subseteq> M\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string\n                          (make_set (Suc j)\n                            (\\<lambda>k m.\n                                \\<exists>s. event_at (i, k) (Receive s m)))\n                          (state (i, Suc j))", "have b:\"j < length (events i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length (events i)", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<le> length (events i); consistent M;\n   make_set j (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n   \\<subseteq> M\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string\n                     (make_set j\n                       (\\<lambda>k m.\n                           \\<exists>s. event_at (i, k) (Receive s m)))\n                     (state (i, j))\n  Suc j \\<le> length (events i)\n  consistent M\n  make_set (Suc j) (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n  \\<subseteq> M\n\ngoal (1 subgoal):\n 1. j < length (events i)", "by auto"], ["proof (state)\nthis:\n  j < length (events i)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>j \\<le> length (events i); consistent M;\n                 make_set j\n                  (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n                 \\<subseteq> M\\<rbrakk>\n                \\<Longrightarrow> is_certified_associated_string\n                                   (make_set j\n                                     (\\<lambda>k m.\n   \\<exists>s. event_at (i, k) (Receive s m)))\n                                   (state (i, j));\n        Suc j \\<le> length (events i); consistent M;\n        make_set (Suc j)\n         (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n        \\<subseteq> M\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string\n                          (make_set (Suc j)\n                            (\\<lambda>k m.\n                                \\<exists>s. event_at (i, k) (Receive s m)))\n                          (state (i, Suc j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string\n     (make_set (Suc j)\n       (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n     (state (i, Suc j))", "proof (cases \"events i ! j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       events i ! j = Send x1 \\<Longrightarrow>\n       is_certified_associated_string\n        (make_set (Suc j)\n          (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n        (state (i, Suc j))\n 2. \\<And>x21 x22.\n       events i ! j = Receive x21 x22 \\<Longrightarrow>\n       is_certified_associated_string\n        (make_set (Suc j)\n          (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n        (state (i, Suc j))", "case (Send m)"], ["proof (state)\nthis:\n  events i ! j = Send m\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       events i ! j = Send x1 \\<Longrightarrow>\n       is_certified_associated_string\n        (make_set (Suc j)\n          (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n        (state (i, Suc j))\n 2. \\<And>x21 x22.\n       events i ! j = Receive x21 x22 \\<Longrightarrow>\n       is_certified_associated_string\n        (make_set (Suc j)\n          (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n        (state (i, Suc j))", "then"], ["proof (chain)\npicking this:\n  events i ! j = Send m", "show ?thesis"], ["proof (prove)\nusing this:\n  events i ! j = Send m\n\ngoal (1 subgoal):\n 1. is_certified_associated_string\n     (make_set (Suc j)\n       (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n     (state (i, Suc j))", "using Suc"], ["proof (prove)\nusing this:\n  events i ! j = Send m\n  \\<lbrakk>j \\<le> length (events i); consistent M;\n   make_set j (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n   \\<subseteq> M\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string\n                     (make_set j\n                       (\\<lambda>k m.\n                           \\<exists>s. event_at (i, k) (Receive s m)))\n                     (state (i, j))\n  Suc j \\<le> length (events i)\n  consistent M\n  make_set (Suc j) (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n  \\<subseteq> M\n\ngoal (1 subgoal):\n 1. is_certified_associated_string\n     (make_set (Suc j)\n       (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n     (state (i, Suc j))", "by (simp add: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  is_certified_associated_string\n   (make_set (Suc j)\n     (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n   (state (i, Suc j))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       events i ! j = Receive x21 x22 \\<Longrightarrow>\n       is_certified_associated_string\n        (make_set (Suc j)\n          (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n        (state (i, Suc j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       events i ! j = Receive x21 x22 \\<Longrightarrow>\n       is_certified_associated_string\n        (make_set (Suc j)\n          (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n        (state (i, Suc j))", "case (Receive s m)"], ["proof (state)\nthis:\n  events i ! j = Receive s m\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       events i ! j = Receive x21 x22 \\<Longrightarrow>\n       is_certified_associated_string\n        (make_set (Suc j)\n          (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n        (state (i, Suc j))", "moreover"], ["proof (state)\nthis:\n  events i ! j = Receive s m\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       events i ! j = Receive x21 x22 \\<Longrightarrow>\n       is_certified_associated_string\n        (make_set (Suc j)\n          (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n        (state (i, Suc j))", "have \"is_delete m \\<or> m \\<notin> (make_set j (\\<lambda>k m. \\<exists>s. event_at (i,k) (Receive s m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_delete m \\<or>\n    m \\<notin> make_set j\n                (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))", "apply (cases m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       m = Insert x1 \\<Longrightarrow>\n       is_delete m \\<or>\n       m \\<notin> make_set j\n                   (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n 2. \\<And>x2.\n       m = Delete x2 \\<Longrightarrow>\n       is_delete m \\<or>\n       m \\<notin> make_set j\n                   (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))", "using recv_insert_once Receive b"], ["proof (prove)\nusing this:\n  \\<lbrakk>event_at (?i, ?j) (Receive ?s (Insert ?m));\n   event_at (?i, ?k) (Receive ?t (Insert ?m))\\<rbrakk>\n  \\<Longrightarrow> ?j = ?k\n  events i ! j = Receive s m\n  j < length (events i)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       m = Insert x1 \\<Longrightarrow>\n       is_delete m \\<or>\n       m \\<notin> make_set j\n                   (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n 2. \\<And>x2.\n       m = Delete x2 \\<Longrightarrow>\n       is_delete m \\<or>\n       m \\<notin> make_set j\n                   (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))", "apply (simp add: make_set_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>m = Insert x1;\n        \\<And>i j s m k t.\n           \\<lbrakk>j < length (events i) \\<and>\n                    Receive s (Insert m) = events i ! j;\n            k < length (events i) \\<and>\n            Receive t (Insert m) = events i ! k\\<rbrakk>\n           \\<Longrightarrow> j = k;\n        events i ! j = Receive s (Insert x1); j < length (events i)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<length (events i).\n                            (\\<forall>a b.\n                                Receive (a, b) (Insert x1) \\<noteq>\n                                events i ! j) \\<or>\n                            \\<not> j < j\n 2. \\<And>x2.\n       m = Delete x2 \\<Longrightarrow>\n       is_delete m \\<or>\n       m \\<notin> make_set j\n                   (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))", "apply (metis nat_neq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       m = Delete x2 \\<Longrightarrow>\n       is_delete m \\<or>\n       m \\<notin> make_set j\n                   (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))", "by (simp)"], ["proof (state)\nthis:\n  is_delete m \\<or>\n  m \\<notin> make_set j\n              (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       events i ! j = Receive x21 x22 \\<Longrightarrow>\n       is_certified_associated_string\n        (make_set (Suc j)\n          (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n        (state (i, Suc j))", "moreover"], ["proof (state)\nthis:\n  is_delete m \\<or>\n  m \\<notin> make_set j\n              (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       events i ! j = Receive x21 x22 \\<Longrightarrow>\n       is_certified_associated_string\n        (make_set (Suc j)\n          (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n        (state (i, Suc j))", "have \"deps m \\<subseteq> I ` insert_messages (make_set j (\\<lambda>k m. \\<exists>s. event_at (i,k) (Receive s m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deps m\n    \\<subseteq> I `\n                insert_messages\n                 (make_set j\n                   (\\<lambda>k m.\n                       \\<exists>s. event_at (i, k) (Receive s m)))", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> deps m \\<Longrightarrow>\n       x \\<in> I `\n               insert_messages\n                (make_set j\n                  (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))", "using semantic_causal_delivery Receive b"], ["proof (prove)\nusing this:\n  \\<lbrakk>event_at (?i, ?j) (Receive ?s ?m); ?i' \\<in> deps ?m\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s' j' m'.\n                       event_at (?i, j') (Receive s' (Insert m')) \\<and>\n                       j' < ?j \\<and> I m' = ?i'\n  events i ! j = Receive s m\n  j < length (events i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> deps m \\<Longrightarrow>\n       x \\<in> I `\n               insert_messages\n                (make_set j\n                  (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))", "apply (simp add:insert_messages_def image_iff make_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> deps m;\n        \\<And>i j s m i'.\n           \\<lbrakk>j < length (events i) \\<and> Receive s m = events i ! j;\n            i' \\<in> deps m\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a b j'.\n                                j' < length (events i) \\<and>\n                                (\\<exists>m'.\n                                    Receive (a, b) (Insert m') =\n                                    events i ! j' \\<and>\n                                    j' < j \\<and> I m' = i');\n        events i ! j = Receive s m; j < length (events i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>j<length (events i).\n                                (\\<exists>a b.\n                                    Receive (a, b) (Insert xa) =\n                                    events i ! j) \\<and>\n                                j < j) \\<and>\n                            x = I xa", "by metis"], ["proof (state)\nthis:\n  deps m\n  \\<subseteq> I `\n              insert_messages\n               (make_set j\n                 (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       events i ! j = Receive x21 x22 \\<Longrightarrow>\n       is_certified_associated_string\n        (make_set (Suc j)\n          (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n        (state (i, Suc j))", "ultimately"], ["proof (chain)\npicking this:\n  events i ! j = Receive s m\n  is_delete m \\<or>\n  m \\<notin> make_set j\n              (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n  deps m\n  \\<subseteq> I `\n              insert_messages\n               (make_set j\n                 (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))", "show ?thesis"], ["proof (prove)\nusing this:\n  events i ! j = Receive s m\n  is_delete m \\<or>\n  m \\<notin> make_set j\n              (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n  deps m\n  \\<subseteq> I `\n              insert_messages\n               (make_set j\n                 (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n\ngoal (1 subgoal):\n 1. is_certified_associated_string\n     (make_set (Suc j)\n       (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n     (state (i, Suc j))", "using Suc"], ["proof (prove)\nusing this:\n  events i ! j = Receive s m\n  is_delete m \\<or>\n  m \\<notin> make_set j\n              (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n  deps m\n  \\<subseteq> I `\n              insert_messages\n               (make_set j\n                 (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n  \\<lbrakk>j \\<le> length (events i); consistent M;\n   make_set j (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n   \\<subseteq> M\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string\n                     (make_set j\n                       (\\<lambda>k m.\n                           \\<exists>s. event_at (i, k) (Receive s m)))\n                     (state (i, j))\n  Suc j \\<le> length (events i)\n  consistent M\n  make_set (Suc j) (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n  \\<subseteq> M\n\ngoal (1 subgoal):\n 1. is_certified_associated_string\n     (make_set (Suc j)\n       (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n     (state (i, Suc j))", "apply (cases s, simp add:take_Suc_conv_app_nth foldM_rev)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>is_delete m \\<or>\n                m \\<notin> make_set j\n                            (\\<lambda>k m.\n                                k < length (events i) \\<and>\n                                (\\<exists>a b.\n                                    Receive (a, b) m = events i ! k));\n        deps m\n        \\<subseteq> I `\n                    insert_messages\n                     (make_set j\n                       (\\<lambda>k m.\n                           k < length (events i) \\<and>\n                           (\\<exists>a b.\n                               Receive (a, b) m = events i ! k)));\n        is_certified_associated_string\n         (make_set j\n           (\\<lambda>k m.\n               k < length (events i) \\<and>\n               (\\<exists>a b. Receive (a, b) m = events i ! k)))\n         (foldM integrate []\n           (concat\n             (map (case_event (\\<lambda>message. []) (\\<lambda>x m. [m]))\n               (take j (events i)))));\n        m \\<in> M \\<and>\n        make_set j\n         (\\<lambda>k m.\n             k < length (events i) \\<and>\n             (\\<exists>a b. Receive (a, b) m = events i ! k))\n        \\<subseteq> M;\n        s = (a, b); events i ! j = Receive (a, b) m;\n        Suc j \\<le> length (events i); consistent M\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string\n                          (insert m\n                            (make_set j\n                              (\\<lambda>k m.\n                                  k < length (events i) \\<and>\n                                  (\\<exists>a b.\nReceive (a, b) m = events i ! k))))\n                          (foldM integrate []\n                            (concat\n                              (map (case_event (\\<lambda>message. [])\n                                     (\\<lambda>x m. [m]))\n                                (take j (events i)))) \\<bind>\n                           (\\<lambda>t. integrate t m))", "using integrate_insert_commute'"], ["proof (prove)\nusing this:\n  \\<lbrakk>consistent ?M; is_delete ?m \\<or> ?m \\<notin> ?T; ?m \\<in> ?M;\n   ?T \\<subseteq> ?M; deps ?m \\<subseteq> I ` insert_messages ?T;\n   is_certified_associated_string ?T ?s\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string (?T \\<union> {?m})\n                     (?s \\<bind> (\\<lambda>t. integrate t ?m))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>is_delete m \\<or>\n                m \\<notin> make_set j\n                            (\\<lambda>k m.\n                                k < length (events i) \\<and>\n                                (\\<exists>a b.\n                                    Receive (a, b) m = events i ! k));\n        deps m\n        \\<subseteq> I `\n                    insert_messages\n                     (make_set j\n                       (\\<lambda>k m.\n                           k < length (events i) \\<and>\n                           (\\<exists>a b.\n                               Receive (a, b) m = events i ! k)));\n        is_certified_associated_string\n         (make_set j\n           (\\<lambda>k m.\n               k < length (events i) \\<and>\n               (\\<exists>a b. Receive (a, b) m = events i ! k)))\n         (foldM integrate []\n           (concat\n             (map (case_event (\\<lambda>message. []) (\\<lambda>x m. [m]))\n               (take j (events i)))));\n        m \\<in> M \\<and>\n        make_set j\n         (\\<lambda>k m.\n             k < length (events i) \\<and>\n             (\\<exists>a b. Receive (a, b) m = events i ! k))\n        \\<subseteq> M;\n        s = (a, b); events i ! j = Receive (a, b) m;\n        Suc j \\<le> length (events i); consistent M\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string\n                          (insert m\n                            (make_set j\n                              (\\<lambda>k m.\n                                  k < length (events i) \\<and>\n                                  (\\<exists>a b.\nReceive (a, b) m = events i ! k))))\n                          (foldM integrate []\n                            (concat\n                              (map (case_event (\\<lambda>message. [])\n                                     (\\<lambda>x m. [m]))\n                                (take j (events i)))) \\<bind>\n                           (\\<lambda>t. integrate t m))", "by fastforce"], ["proof (state)\nthis:\n  is_certified_associated_string\n   (make_set (Suc j)\n     (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n   (state (i, Suc j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_certified_associated_string\n   (make_set (Suc j)\n     (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m)))\n   (state (i, Suc j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  (in dist_execution) sent_before_recv:\n  assumes \"event_at (i,k) (Receive s m)\"\n  assumes \"j < length (events i)\"\n  assumes \"k < j\" \n  shows \"event_at s (Send m) \\<and> happened_immediately_before\\<^sup>+\\<^sup>+ s (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. event_at s (Send m) \\<and>\n    happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. event_at s (Send m) \\<and>\n    happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)", "have a:\"event_at s (Send m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. event_at s (Send m)", "using assms no_data_corruption"], ["proof (prove)\nusing this:\n  event_at (i, k) (Receive s m)\n  j < length (events i)\n  k < j\n  event_at ?i (Receive ?s ?m) \\<Longrightarrow> event_at ?s (Send ?m)\n\ngoal (1 subgoal):\n 1. event_at s (Send m)", "by blast"], ["proof (state)\nthis:\n  event_at s (Send m)\n\ngoal (1 subgoal):\n 1. event_at s (Send m) \\<and>\n    happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)", "hence \"happened_immediately_before s (i,k)\""], ["proof (prove)\nusing this:\n  event_at s (Send m)\n\ngoal (1 subgoal):\n 1. happened_immediately_before s (i, k)", "using assms"], ["proof (prove)\nusing this:\n  event_at s (Send m)\n  event_at (i, k) (Receive s m)\n  j < length (events i)\n  k < j\n\ngoal (1 subgoal):\n 1. happened_immediately_before s (i, k)", "by (cases s, simp, metis (mono_tags, lifting) event.simps(6))"], ["proof (state)\nthis:\n  happened_immediately_before s (i, k)\n\ngoal (1 subgoal):\n 1. event_at s (Send m) \\<and>\n    happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)", "hence \"(happened_immediately_before)\\<^sup>+\\<^sup>+ s (i,j)\""], ["proof (prove)\nusing this:\n  happened_immediately_before s (i, k)\n\ngoal (1 subgoal):\n 1. happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)", "using happened_before_same"], ["proof (prove)\nusing this:\n  happened_immediately_before s (i, k)\n  \\<lbrakk>?i < ?j; ?j < length (events ?k)\\<rbrakk>\n  \\<Longrightarrow> happened_immediately_before\\<^sup>+\\<^sup>+ (?k, ?i)\n                     (?k, ?j)\n\ngoal (1 subgoal):\n 1. happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)", "by (meson assms(2) assms(3) tranclp_into_tranclp2)"], ["proof (state)\nthis:\n  happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)\n\ngoal (1 subgoal):\n 1. event_at s (Send m) \\<and>\n    happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)\n\ngoal (1 subgoal):\n 1. event_at s (Send m) \\<and>\n    happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)", "using a"], ["proof (prove)\nusing this:\n  happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)\n  event_at s (Send m)\n\ngoal (1 subgoal):\n 1. event_at s (Send m) \\<and>\n    happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)", "by blast"], ["proof (state)\nthis:\n  event_at s (Send m) \\<and>\n  happened_immediately_before\\<^sup>+\\<^sup>+ s (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in dist_execution) irrefl_p: \"irreflp (happened_immediately_before\\<^sup>+\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflp happened_immediately_before\\<^sup>+\\<^sup>+", "by (meson acyclic_def dist_execution.acyclic_happened_before\n      dist_execution_axioms irreflpI tranclp_unfold)"], ["", "lemma (in dist_execution) new_messages_keep_consistency:\n  assumes \"consistent M\"\n  assumes \"event_at i (Send m)\"\n  assumes \"set (received_messages i) \\<subseteq> M\"\n  assumes \"i \\<notin> I ` insert_messages M\"\n  shows \"consistent (insert m M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (insert m M)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent (insert m M)", "have a:\"is_valid_state_id i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_state_id i", "using assms(2)"], ["proof (prove)\nusing this:\n  event_at i (Send m)\n\ngoal (1 subgoal):\n 1. is_valid_state_id i", "by (cases i, simp)"], ["proof (state)\nthis:\n  is_valid_state_id i\n\ngoal (1 subgoal):\n 1. consistent (insert m M)", "consider \n    (1) \"(\\<exists>n \\<sigma>. Inr m = (state i) \\<bind> (\\<lambda>s. create_insert s n \\<sigma> i))\" |\n    (2) \"(\\<exists>n.   Inr m = (state i) \\<bind> (\\<lambda>s. create_delete s n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>n \\<sigma>.\n                Inr m =\n                state i \\<bind>\n                (\\<lambda>s. create_insert s n \\<sigma> i) \\<Longrightarrow>\n             thesis;\n     \\<exists>n.\n        Inr m =\n        state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis (full_types) send_correct assms(2))"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>n \\<sigma>.\n              Inr m =\n              state i \\<bind>\n              (\\<lambda>s. create_insert s n \\<sigma> i) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>n.\n      Inr m =\n      state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. consistent (insert m M)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<exists>n \\<sigma>.\n              Inr m =\n              state i \\<bind>\n              (\\<lambda>s. create_insert s n \\<sigma> i) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>n.\n      Inr m =\n      state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>n \\<sigma>.\n              Inr m =\n              state i \\<bind>\n              (\\<lambda>s. create_insert s n \\<sigma> i) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>n.\n      Inr m =\n      state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. consistent (insert m M)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n \\<sigma>.\n       Inr m =\n       state i \\<bind>\n       (\\<lambda>s. create_insert s n \\<sigma> i) \\<Longrightarrow>\n    consistent (insert m M)\n 2. \\<exists>n.\n       Inr m =\n       state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n    consistent (insert m M)", "case 1"], ["proof (state)\nthis:\n  \\<exists>n \\<sigma>.\n     Inr m = state i \\<bind> (\\<lambda>s. create_insert s n \\<sigma> i)\n\ngoal (2 subgoals):\n 1. \\<exists>n \\<sigma>.\n       Inr m =\n       state i \\<bind>\n       (\\<lambda>s. create_insert s n \\<sigma> i) \\<Longrightarrow>\n    consistent (insert m M)\n 2. \\<exists>n.\n       Inr m =\n       state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n    consistent (insert m M)", "then"], ["proof (chain)\npicking this:\n  \\<exists>n \\<sigma>.\n     Inr m = state i \\<bind> (\\<lambda>s. create_insert s n \\<sigma> i)", "obtain s n' \\<sigma> where s_def:\n      \"Inr s = state i\" \"Inr m = create_insert s n' \\<sigma> i\""], ["proof (prove)\nusing this:\n  \\<exists>n \\<sigma>.\n     Inr m = state i \\<bind> (\\<lambda>s. create_insert s n \\<sigma> i)\n\ngoal (1 subgoal):\n 1. (\\<And>s n' \\<sigma>.\n        \\<lbrakk>Inr s = state i;\n         Inr m = create_insert s n' \\<sigma> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"state i\", simp, simp add:bind_def, blast)"], ["proof (state)\nthis:\n  Inr s = state i\n  Inr m = create_insert s n' \\<sigma> i\n\ngoal (2 subgoals):\n 1. \\<exists>n \\<sigma>.\n       Inr m =\n       state i \\<bind>\n       (\\<lambda>s. create_insert s n \\<sigma> i) \\<Longrightarrow>\n    consistent (insert m M)\n 2. \\<exists>n.\n       Inr m =\n       state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n    consistent (insert m M)", "moreover"], ["proof (state)\nthis:\n  Inr s = state i\n  Inr m = create_insert s n' \\<sigma> i\n\ngoal (2 subgoals):\n 1. \\<exists>n \\<sigma>.\n       Inr m =\n       state i \\<bind>\n       (\\<lambda>s. create_insert s n \\<sigma> i) \\<Longrightarrow>\n    consistent (insert m M)\n 2. \\<exists>n.\n       Inr m =\n       state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n    consistent (insert m M)", "have \"is_associated_string (set (received_messages i)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_associated_string (set (received_messages i)) s", "using a assms(1) assms(3)"], ["proof (prove)\nusing this:\n  is_valid_state_id i\n  consistent M\n  set (received_messages i) \\<subseteq> M\n\ngoal (1 subgoal):\n 1. is_associated_string (set (received_messages i)) s", "apply (cases i, simp only:received_messages_eff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>is_valid_state_id (a, b); True;\n        make_set b (\\<lambda>k x. \\<exists>s. event_at (a, k) (Receive s x))\n        \\<subseteq> M;\n        i = (a, b); True; consistent M; True\\<rbrakk>\n       \\<Longrightarrow> is_associated_string\n                          (make_set b\n                            (\\<lambda>k x.\n                                \\<exists>s. event_at (a, k) (Receive s x)))\n                          s", "using s_def(1) state_is_associated_string'"], ["proof (prove)\nusing this:\n  Inr s = state i\n  \\<lbrakk>?j \\<le> length (events ?i); consistent ?M;\n   make_set ?j (\\<lambda>k m. \\<exists>s. event_at (?i, k) (Receive s m))\n   \\<subseteq> ?M\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string\n                     (make_set ?j\n                       (\\<lambda>k m.\n                           \\<exists>s. event_at (?i, k) (Receive s m)))\n                     (state (?i, ?j))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>is_valid_state_id (a, b); True;\n        make_set b (\\<lambda>k x. \\<exists>s. event_at (a, k) (Receive s x))\n        \\<subseteq> M;\n        i = (a, b); True; consistent M; True\\<rbrakk>\n       \\<Longrightarrow> is_associated_string\n                          (make_set b\n                            (\\<lambda>k x.\n                                \\<exists>s. event_at (a, k) (Receive s x)))\n                          s", "by (simp, metis (mono_tags, lifting) is_certified_associated_string.simps(1))"], ["proof (state)\nthis:\n  is_associated_string (set (received_messages i)) s\n\ngoal (2 subgoals):\n 1. \\<exists>n \\<sigma>.\n       Inr m =\n       state i \\<bind>\n       (\\<lambda>s. create_insert s n \\<sigma> i) \\<Longrightarrow>\n    consistent (insert m M)\n 2. \\<exists>n.\n       Inr m =\n       state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n    consistent (insert m M)", "ultimately"], ["proof (chain)\npicking this:\n  Inr s = state i\n  Inr m = create_insert s n' \\<sigma> i\n  is_associated_string (set (received_messages i)) s", "show ?thesis"], ["proof (prove)\nusing this:\n  Inr s = state i\n  Inr m = create_insert s n' \\<sigma> i\n  is_associated_string (set (received_messages i)) s\n\ngoal (1 subgoal):\n 1. consistent (insert m M)", "using create_insert_consistent s_def assms"], ["proof (prove)\nusing this:\n  Inr s = state i\n  Inr m = create_insert s n' \\<sigma> i\n  is_associated_string (set (received_messages i)) s\n  \\<lbrakk>consistent ?M; is_associated_string ?N ?s; ?N \\<subseteq> ?M;\n   Inr ?m = create_insert ?s ?n ?\\<sigma> ?new_id;\n   ?new_id \\<notin> I ` insert_messages ?M\\<rbrakk>\n  \\<Longrightarrow> consistent (?M \\<union> {?m})\n  Inr s = state i\n  Inr m = create_insert s n' \\<sigma> i\n  consistent M\n  event_at i (Send m)\n  set (received_messages i) \\<subseteq> M\n  i \\<notin> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. consistent (insert m M)", "by (metis Un_insert_right sup_bot.right_neutral)"], ["proof (state)\nthis:\n  consistent (insert m M)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Inr m =\n       state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n    consistent (insert m M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Inr m =\n       state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n    consistent (insert m M)", "case 2"], ["proof (state)\nthis:\n  \\<exists>n. Inr m = state i \\<bind> (\\<lambda>s. create_delete s n)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Inr m =\n       state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n    consistent (insert m M)", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. Inr m = state i \\<bind> (\\<lambda>s. create_delete s n)", "obtain s n' where s_def:\n      \"Inr s = state i\" \"Inr m = create_delete s n'\""], ["proof (prove)\nusing this:\n  \\<exists>n. Inr m = state i \\<bind> (\\<lambda>s. create_delete s n)\n\ngoal (1 subgoal):\n 1. (\\<And>s n'.\n        \\<lbrakk>Inr s = state i; Inr m = create_delete s n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"state i\", simp, simp add:bind_def, blast)"], ["proof (state)\nthis:\n  Inr s = state i\n  Inr m = create_delete s n'\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Inr m =\n       state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n    consistent (insert m M)", "moreover"], ["proof (state)\nthis:\n  Inr s = state i\n  Inr m = create_delete s n'\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Inr m =\n       state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n    consistent (insert m M)", "have \"is_associated_string (set (received_messages i)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_associated_string (set (received_messages i)) s", "using a assms(1) assms(3)"], ["proof (prove)\nusing this:\n  is_valid_state_id i\n  consistent M\n  set (received_messages i) \\<subseteq> M\n\ngoal (1 subgoal):\n 1. is_associated_string (set (received_messages i)) s", "apply (cases i, simp only:received_messages_eff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>is_valid_state_id (a, b); True;\n        make_set b (\\<lambda>k x. \\<exists>s. event_at (a, k) (Receive s x))\n        \\<subseteq> M;\n        i = (a, b); True; consistent M; True\\<rbrakk>\n       \\<Longrightarrow> is_associated_string\n                          (make_set b\n                            (\\<lambda>k x.\n                                \\<exists>s. event_at (a, k) (Receive s x)))\n                          s", "using s_def(1) state_is_associated_string'"], ["proof (prove)\nusing this:\n  Inr s = state i\n  \\<lbrakk>?j \\<le> length (events ?i); consistent ?M;\n   make_set ?j (\\<lambda>k m. \\<exists>s. event_at (?i, k) (Receive s m))\n   \\<subseteq> ?M\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string\n                     (make_set ?j\n                       (\\<lambda>k m.\n                           \\<exists>s. event_at (?i, k) (Receive s m)))\n                     (state (?i, ?j))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>is_valid_state_id (a, b); True;\n        make_set b (\\<lambda>k x. \\<exists>s. event_at (a, k) (Receive s x))\n        \\<subseteq> M;\n        i = (a, b); True; consistent M; True\\<rbrakk>\n       \\<Longrightarrow> is_associated_string\n                          (make_set b\n                            (\\<lambda>k x.\n                                \\<exists>s. event_at (a, k) (Receive s x)))\n                          s", "by (simp, metis (mono_tags, lifting) is_certified_associated_string.simps(1))"], ["proof (state)\nthis:\n  is_associated_string (set (received_messages i)) s\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Inr m =\n       state i \\<bind> (\\<lambda>s. create_delete s n) \\<Longrightarrow>\n    consistent (insert m M)", "ultimately"], ["proof (chain)\npicking this:\n  Inr s = state i\n  Inr m = create_delete s n'\n  is_associated_string (set (received_messages i)) s", "show ?thesis"], ["proof (prove)\nusing this:\n  Inr s = state i\n  Inr m = create_delete s n'\n  is_associated_string (set (received_messages i)) s\n\ngoal (1 subgoal):\n 1. consistent (insert m M)", "using create_delete_consistent s_def assms"], ["proof (prove)\nusing this:\n  Inr s = state i\n  Inr m = create_delete s n'\n  is_associated_string (set (received_messages i)) s\n  \\<lbrakk>consistent ?M; is_associated_string ?N ?s; ?N \\<subseteq> ?M;\n   Inr ?m = create_delete ?s ?n\\<rbrakk>\n  \\<Longrightarrow> consistent (?M \\<union> {?m})\n  Inr s = state i\n  Inr m = create_delete s n'\n  consistent M\n  event_at i (Send m)\n  set (received_messages i) \\<subseteq> M\n  i \\<notin> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. consistent (insert m M)", "by (metis Un_insert_right sup_bot.right_neutral)"], ["proof (state)\nthis:\n  consistent (insert m M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  consistent (insert m M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in dist_execution) sent_messages_consistent:\n  \"consistent {m. (\\<exists>i. event_at i (Send m))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent {m. \\<exists>i. event_at i (Send m)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent {m. \\<exists>i. event_at i (Send m)}", "obtain ids where ids_def: \"set ids = {i. is_valid_event_id i} \\<and> \n    sorted_wrt (to_ord (happened_immediately_before)) ids \\<and> distinct ids\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ids.\n        set ids = Collect is_valid_event_id \\<and>\n        sorted_wrt (to_ord happened_immediately_before) ids \\<and>\n        distinct ids \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using top_sort finite_valid_event_ids"], ["proof (prove)\nusing this:\n  acyclicP ?r \\<Longrightarrow>\n  finite ?s \\<longrightarrow>\n  (\\<exists>l. set l = ?s \\<and> sorted_wrt (to_ord ?r) l \\<and> distinct l)\n  finite (Collect is_valid_event_id)\n\ngoal (1 subgoal):\n 1. (\\<And>ids.\n        set ids = Collect is_valid_event_id \\<and>\n        sorted_wrt (to_ord happened_immediately_before) ids \\<and>\n        distinct ids \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis acyclic_happened_before)"], ["proof (state)\nthis:\n  set ids = Collect is_valid_event_id \\<and>\n  sorted_wrt (to_ord happened_immediately_before) ids \\<and> distinct ids\n\ngoal (1 subgoal):\n 1. consistent {m. \\<exists>i. event_at i (Send m)}", "have \"\\<And>x y. happened_immediately_before\\<^sup>+\\<^sup>+ x y \\<Longrightarrow> x \\<in> set ids \\<and> y \\<in> set ids\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       happened_immediately_before\\<^sup>+\\<^sup>+ x y \\<Longrightarrow>\n       x \\<in> set ids \\<and> y \\<in> set ids", "using converse_tranclpE ids_def tranclp.cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r\\<^sup>+\\<^sup>+ ?x ?z; ?r ?x ?z \\<Longrightarrow> ?P;\n   \\<And>y.\n      \\<lbrakk>?r ?x y; ?r\\<^sup>+\\<^sup>+ y ?z\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  set ids = Collect is_valid_event_id \\<and>\n  sorted_wrt (to_ord happened_immediately_before) ids \\<and> distinct ids\n  \\<lbrakk>?r\\<^sup>+\\<^sup>+ ?a1.0 ?a2.0;\n   \\<And>a b.\n      \\<lbrakk>?a1.0 = a; ?a2.0 = b; ?r a b\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>a b c.\n      \\<lbrakk>?a1.0 = a; ?a2.0 = c; ?r\\<^sup>+\\<^sup>+ a b; ?r b c\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       happened_immediately_before\\<^sup>+\\<^sup>+ x y \\<Longrightarrow>\n       x \\<in> set ids \\<and> y \\<in> set ids", "by fastforce"], ["proof (state)\nthis:\n  happened_immediately_before\\<^sup>+\\<^sup>+ ?x ?y \\<Longrightarrow>\n  ?x \\<in> set ids \\<and> ?y \\<in> set ids\n\ngoal (1 subgoal):\n 1. consistent {m. \\<exists>i. event_at i (Send m)}", "hence a:\"\\<And>x y. happened_immediately_before\\<^sup>+\\<^sup>+ x y \\<Longrightarrow>\n    (\\<exists>i j. i < j \\<and> j < length ids \\<and> ids ! i = x \\<and> ids ! j = y)\""], ["proof (prove)\nusing this:\n  happened_immediately_before\\<^sup>+\\<^sup>+ ?x ?y \\<Longrightarrow>\n  ?x \\<in> set ids \\<and> ?y \\<in> set ids\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       happened_immediately_before\\<^sup>+\\<^sup>+ x y \\<Longrightarrow>\n       \\<exists>i j.\n          i < j \\<and> j < length ids \\<and> ids ! i = x \\<and> ids ! j = y", "by (metis top_sort_eff ids_def  distinct_Ex1 irrefl_p)"], ["proof (state)\nthis:\n  happened_immediately_before\\<^sup>+\\<^sup>+ ?x ?y \\<Longrightarrow>\n  \\<exists>i j.\n     i < j \\<and> j < length ids \\<and> ids ! i = ?x \\<and> ids ! j = ?y\n\ngoal (1 subgoal):\n 1. consistent {m. \\<exists>i. event_at i (Send m)}", "define n where \"n = length ids\""], ["proof (state)\nthis:\n  n = length ids\n\ngoal (1 subgoal):\n 1. consistent {m. \\<exists>i. event_at i (Send m)}", "have \"n \\<le> length ids \\<Longrightarrow> consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length ids \\<Longrightarrow>\n    consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length ids \\<Longrightarrow>\n    consistent (make_set 0 (\\<lambda>k x. event_at (ids ! k) (Send x)))\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> length ids\n\ngoal (2 subgoals):\n 1. 0 \\<le> length ids \\<Longrightarrow>\n    consistent (make_set 0 (\\<lambda>k x. event_at (ids ! k) (Send x)))\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> length ids", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> length ids\n\ngoal (1 subgoal):\n 1. consistent (make_set 0 (\\<lambda>k x. event_at (ids ! k) (Send x)))", "using empty_consistent"], ["proof (prove)\nusing this:\n  0 \\<le> length ids\n  consistent {}\n\ngoal (1 subgoal):\n 1. consistent (make_set 0 (\\<lambda>k x. event_at (ids ! k) (Send x)))", "by simp"], ["proof (state)\nthis:\n  consistent (make_set 0 (\\<lambda>k x. event_at (ids ! k) (Send x)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> length ids \\<Longrightarrow>\n  consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n  Suc n \\<le> length ids\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "moreover"], ["proof (state)\nthis:\n  n \\<le> length ids \\<Longrightarrow>\n  consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n  Suc n \\<le> length ids\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "obtain i j where ij_def: \n      \"ids ! n = (i,j)\" \"n < length ids\"\n      \"is_valid_event_id (i,j)\" \"is_valid_state_id (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>ids ! n = (i, j); n < length ids; is_valid_event_id (i, j);\n         is_valid_state_id (i, j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc.prems Suc_le_lessD ids_def is_valid_event_id.elims(2) is_valid_state_id.simps\n          le_eq_less_or_eq mem_Collect_eq nth_mem)"], ["proof (state)\nthis:\n  ids ! n = (i, j)\n  n < length ids\n  is_valid_event_id (i, j)\n  is_valid_state_id (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "moreover"], ["proof (state)\nthis:\n  ids ! n = (i, j)\n  n < length ids\n  is_valid_event_id (i, j)\n  is_valid_state_id (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "have \"set (received_messages (i,j)) \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (received_messages (i, j))\n    \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x))", "using ij_def"], ["proof (prove)\nusing this:\n  ids ! n = (i, j)\n  n < length ids\n  is_valid_event_id (i, j)\n  is_valid_state_id (i, j)\n\ngoal (1 subgoal):\n 1. set (received_messages (i, j))\n    \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x))", "apply (simp add:received_messages_eff del:received_messages.simps, rule_tac subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ids ! n = (i, j); n < length ids; j < length (events i);\n        ids ! n = (i, j); n < length ids; is_valid_event_id (i, j);\n        is_valid_state_id (i, j);\n        x \\<in> make_set j\n                 (\\<lambda>k x.\n                     k < length (events i) \\<and>\n                     (\\<exists>a b.\n                         Receive (a, b) x = events i ! k))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> make_set n\n                                  (\\<lambda>k x.\nevent_pred (ids ! k) ((=) (Send x)))", "using sent_before_recv a"], ["proof (prove)\nusing this:\n  \\<lbrakk>event_at (?i, ?k) (Receive ?s ?m); ?j < length (events ?i);\n   ?k < ?j\\<rbrakk>\n  \\<Longrightarrow> event_at ?s (Send ?m) \\<and>\n                    happened_immediately_before\\<^sup>+\\<^sup>+ ?s (?i, ?j)\n  happened_immediately_before\\<^sup>+\\<^sup>+ ?x ?y \\<Longrightarrow>\n  \\<exists>i j.\n     i < j \\<and> j < length ids \\<and> ids ! i = ?x \\<and> ids ! j = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ids ! n = (i, j); n < length ids; j < length (events i);\n        ids ! n = (i, j); n < length ids; is_valid_event_id (i, j);\n        is_valid_state_id (i, j);\n        x \\<in> make_set j\n                 (\\<lambda>k x.\n                     k < length (events i) \\<and>\n                     (\\<exists>a b.\n                         Receive (a, b) x = events i ! k))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> make_set n\n                                  (\\<lambda>k x.\nevent_pred (ids ! k) ((=) (Send x)))", "apply (simp add:make_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>j < length (events i); ids ! n = (i, j); n < length ids;\n        \\<exists>ja<length (events i).\n           (\\<exists>a b. Receive (a, b) x = events i ! ja) \\<and> ja < j;\n        \\<And>i k s m j.\n           \\<lbrakk>Receive s m = events i ! k; j < length (events i);\n            k < j\\<rbrakk>\n           \\<Longrightarrow> event_pred s ((=) (Send m)) \\<and>\n                             happened_immediately_before\\<^sup>+\\<^sup>+ s\n                              (i, j);\n        \\<And>x y.\n           happened_immediately_before\\<^sup>+\\<^sup>+ x y \\<Longrightarrow>\n           \\<exists>i j.\n              i < j \\<and>\n              j < length ids \\<and> ids ! i = x \\<and> ids ! j = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            event_pred (ids ! j) ((=) (Send x)) \\<and> j < n", "by (metis (no_types, hide_lams) distinct_Ex1 ids_def in_set_conv_nth)"], ["proof (state)\nthis:\n  set (received_messages (i, j))\n  \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "moreover"], ["proof (state)\nthis:\n  set (received_messages (i, j))\n  \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "have \"(i,j) \\<notin> I ` insert_messages (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i, j)\n    \\<notin> I `\n             insert_messages\n              (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))", "apply (simp add:insert_messages_def image_iff make_set_def del:event_at.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<forall>j.\n           event_at (ids ! j) (Send (Insert x)) \\<longrightarrow>\n           \\<not> j < n) \\<or>\n       (i, j) \\<noteq> I x", "using ids_def le_eq_less_or_eq nth_eq_iff_index_eq send_insert_id"], ["proof (prove)\nusing this:\n  set ids = Collect is_valid_event_id \\<and>\n  sorted_wrt (to_ord happened_immediately_before) ids \\<and> distinct ids\n  (?m \\<le> ?n) = (?m < ?n \\<or> ?m = ?n)\n  \\<lbrakk>distinct ?xs; ?i < length ?xs; ?j < length ?xs\\<rbrakk>\n  \\<Longrightarrow> (?xs ! ?i = ?xs ! ?j) = (?i = ?j)\n  event_at ?i (Send (Insert ?m)) \\<Longrightarrow> I ?m = ?i\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<forall>j.\n           event_at (ids ! j) (Send (Insert x)) \\<longrightarrow>\n           \\<not> j < n) \\<or>\n       (i, j) \\<noteq> I x", "by (metis dual_order.strict_trans1 ij_def(1) ij_def(2) less_not_refl)"], ["proof (state)\nthis:\n  (i, j)\n  \\<notin> I `\n           insert_messages\n            (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "ultimately"], ["proof (chain)\npicking this:\n  n \\<le> length ids \\<Longrightarrow>\n  consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n  Suc n \\<le> length ids\n  ids ! n = (i, j)\n  n < length ids\n  is_valid_event_id (i, j)\n  is_valid_state_id (i, j)\n  set (received_messages (i, j))\n  \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x))\n  (i, j)\n  \\<notin> I `\n           insert_messages\n            (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))", "show ?case"], ["proof (prove)\nusing this:\n  n \\<le> length ids \\<Longrightarrow>\n  consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n  Suc n \\<le> length ids\n  ids ! n = (i, j)\n  n < length ids\n  is_valid_event_id (i, j)\n  is_valid_state_id (i, j)\n  set (received_messages (i, j))\n  \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x))\n  (i, j)\n  \\<notin> I `\n           insert_messages\n            (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n\ngoal (1 subgoal):\n 1. consistent\n     (make_set (Suc n) (\\<lambda>k x. event_at (ids ! k) (Send x)))", "using Suc"], ["proof (prove)\nusing this:\n  n \\<le> length ids \\<Longrightarrow>\n  consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n  Suc n \\<le> length ids\n  ids ! n = (i, j)\n  n < length ids\n  is_valid_event_id (i, j)\n  is_valid_state_id (i, j)\n  set (received_messages (i, j))\n  \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x))\n  (i, j)\n  \\<notin> I `\n           insert_messages\n            (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n  n \\<le> length ids \\<Longrightarrow>\n  consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n  Suc n \\<le> length ids\n\ngoal (1 subgoal):\n 1. consistent\n     (make_set (Suc n) (\\<lambda>k x. event_at (ids ! k) (Send x)))", "apply (cases \"events i ! j\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids; ids ! n = (i, j); n < length ids;\n        is_valid_event_id (i, j); is_valid_state_id (i, j);\n        set (received_messages (i, j))\n        \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x));\n        (i, j)\n        \\<notin> I `\n                 insert_messages\n                  (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        n \\<le> length ids \\<Longrightarrow>\n        consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids; events i ! j = Send x1\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids; ids ! n = (i, j); n < length ids;\n        is_valid_event_id (i, j); is_valid_state_id (i, j);\n        set (received_messages (i, j))\n        \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x));\n        (i, j)\n        \\<notin> I `\n                 insert_messages\n                  (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        n \\<le> length ids \\<Longrightarrow>\n        consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids; events i ! j = Receive x21 x22\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "using new_messages_keep_consistency [where i = \"(i,j)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>consistent ?M; event_at (i, j) (Send ?m);\n   set (received_messages (i, j)) \\<subseteq> ?M;\n   (i, j) \\<notin> I ` insert_messages ?M\\<rbrakk>\n  \\<Longrightarrow> consistent (insert ?m ?M)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids; ids ! n = (i, j); n < length ids;\n        is_valid_event_id (i, j); is_valid_state_id (i, j);\n        set (received_messages (i, j))\n        \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x));\n        (i, j)\n        \\<notin> I `\n                 insert_messages\n                  (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        n \\<le> length ids \\<Longrightarrow>\n        consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids; events i ! j = Send x1\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>n \\<le> length ids \\<Longrightarrow>\n                consistent\n                 (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids; ids ! n = (i, j); n < length ids;\n        is_valid_event_id (i, j); is_valid_state_id (i, j);\n        set (received_messages (i, j))\n        \\<subseteq> make_set n (\\<lambda>k x. event_at (ids ! k) (Send x));\n        (i, j)\n        \\<notin> I `\n                 insert_messages\n                  (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        n \\<le> length ids \\<Longrightarrow>\n        consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)));\n        Suc n \\<le> length ids; events i ! j = Receive x21 x22\\<rbrakk>\n       \\<Longrightarrow> consistent\n                          (make_set (Suc n)\n                            (\\<lambda>k x. event_at (ids ! k) (Send x)))", "by simp+"], ["proof (state)\nthis:\n  consistent (make_set (Suc n) (\\<lambda>k x. event_at (ids ! k) (Send x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<le> length ids \\<Longrightarrow>\n  consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n\ngoal (1 subgoal):\n 1. consistent {m. \\<exists>i. event_at i (Send m)}", "moreover"], ["proof (state)\nthis:\n  n \\<le> length ids \\<Longrightarrow>\n  consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n\ngoal (1 subgoal):\n 1. consistent {m. \\<exists>i. event_at i (Send m)}", "have \"make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)) = {x. (\\<exists>i. event_at i (Send x))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)) =\n    {x. \\<exists>i. event_at i (Send x)}", "apply (simp add:make_set_def n_def, rule set_eqI, subst surjective_pairing, simp only:event_pred.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> {x. \\<exists>j.\n                       (is_valid_event_id\n                         (fst (ids ! j), snd (ids ! j)) \\<and>\n                        Send x =\n                        events (fst (ids ! j)) ! snd (ids ! j)) \\<and>\n                       j < length ids}) =\n       (x \\<in> {x. \\<exists>a b.\n                       b < length (events a) \\<and> Send x = events a ! b})", "using ids_def"], ["proof (prove)\nusing this:\n  set ids = Collect is_valid_event_id \\<and>\n  sorted_wrt (to_ord happened_immediately_before) ids \\<and> distinct ids\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> {x. \\<exists>j.\n                       (is_valid_event_id\n                         (fst (ids ! j), snd (ids ! j)) \\<and>\n                        Send x =\n                        events (fst (ids ! j)) ! snd (ids ! j)) \\<and>\n                       j < length ids}) =\n       (x \\<in> {x. \\<exists>a b.\n                       b < length (events a) \\<and> Send x = events a ! b})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       set ids = Collect is_valid_event_id \\<and>\n       sorted_wrt (to_ord happened_immediately_before) ids \\<and>\n       distinct ids \\<Longrightarrow>\n       (\\<exists>j.\n           is_valid_event_id (ids ! j) \\<and>\n           Send x = events (fst (ids ! j)) ! snd (ids ! j) \\<and>\n           j < length ids) =\n       (\\<exists>a b. b < length (events a) \\<and> Send x = events a ! b)", "by (metis fst_conv in_set_conv_nth is_valid_event_id.simps mem_Collect_eq prod.exhaust_sel snd_conv)"], ["proof (state)\nthis:\n  make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)) =\n  {x. \\<exists>i. event_at i (Send x)}\n\ngoal (1 subgoal):\n 1. consistent {m. \\<exists>i. event_at i (Send m)}", "ultimately"], ["proof (chain)\npicking this:\n  n \\<le> length ids \\<Longrightarrow>\n  consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n  make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)) =\n  {x. \\<exists>i. event_at i (Send x)}", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> length ids \\<Longrightarrow>\n  consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n  make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)) =\n  {x. \\<exists>i. event_at i (Send x)}\n\ngoal (1 subgoal):\n 1. consistent {m. \\<exists>i. event_at i (Send m)}", "using ids_def n_def"], ["proof (prove)\nusing this:\n  n \\<le> length ids \\<Longrightarrow>\n  consistent (make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)))\n  make_set n (\\<lambda>k x. event_at (ids ! k) (Send x)) =\n  {x. \\<exists>i. event_at i (Send x)}\n  set ids = Collect is_valid_event_id \\<and>\n  sorted_wrt (to_ord happened_immediately_before) ids \\<and> distinct ids\n  n = length ids\n\ngoal (1 subgoal):\n 1. consistent {m. \\<exists>i. event_at i (Send m)}", "by simp"], ["proof (state)\nthis:\n  consistent {m. \\<exists>i. event_at i (Send m)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in dist_execution) received_messages_were_sent:\n  assumes \"is_valid_state_id (i,j)\"\n  shows \"make_set j (\\<lambda>k m. (\\<exists>s. event_at (i, k) (Receive s m))) \\<subseteq> {m. \\<exists>i. event_at i (Send m)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_set j (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n    \\<subseteq> {m. \\<exists>i. event_at i (Send m)}", "using no_data_corruption"], ["proof (prove)\nusing this:\n  event_at ?i (Receive ?s ?m) \\<Longrightarrow> event_at ?s (Send ?m)\n\ngoal (1 subgoal):\n 1. make_set j (\\<lambda>k m. \\<exists>s. event_at (i, k) (Receive s m))\n    \\<subseteq> {m. \\<exists>i. event_at i (Send m)}", "by (simp add:make_set_def, rule_tac subsetI, fastforce)"], ["", "lemma (in dist_execution) state_is_associated_string:\n  assumes \"is_valid_state_id i\"\n  shows \"is_certified_associated_string (set (received_messages i)) (state i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string (set (received_messages i)) (state i)", "using state_is_associated_string' received_messages_eff\n    sent_messages_consistent received_messages_were_sent assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j \\<le> length (events ?i); consistent ?M;\n   make_set ?j (\\<lambda>k m. \\<exists>s. event_at (?i, k) (Receive s m))\n   \\<subseteq> ?M\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string\n                     (make_set ?j\n                       (\\<lambda>k m.\n                           \\<exists>s. event_at (?i, k) (Receive s m)))\n                     (state (?i, ?j))\n  is_valid_state_id (?i, ?j) \\<Longrightarrow>\n  set (received_messages (?i, ?j)) =\n  make_set ?j (\\<lambda>k x. \\<exists>s. event_at (?i, k) (Receive s x))\n  consistent {m. \\<exists>i. event_at i (Send m)}\n  is_valid_state_id (?i, ?j) \\<Longrightarrow>\n  make_set ?j (\\<lambda>k m. \\<exists>s. event_at (?i, k) (Receive s m))\n  \\<subseteq> {m. \\<exists>i. event_at i (Send m)}\n  is_valid_state_id i\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (set (received_messages i)) (state i)", "by (cases i, simp)"], ["", "end"]]}