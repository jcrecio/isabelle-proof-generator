{"file_name": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency/IntegrateAlgorithm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency", "problem_names": ["lemma fromSome_ok_simp [simp]: \"(fromSome x = Inr y) = (x = Some y)\""], "translations": [["", "lemma fromSome_ok_simp [simp]: \"(fromSome x = Inr y) = (x = Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fromSome x = Inr y) = (x = Some y)", "by (cases x, simp+)"], ["", "fun substr :: \"'a list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list\" where\n  \"substr s l u = take (u - (Suc l)) (drop l s)\""], ["", "fun concurrent ::\n  \"('a, 's) woot_character list\n  \\<Rightarrow> nat\n  \\<Rightarrow> nat\n  \\<Rightarrow> ('a, 's) woot_character\n  \\<Rightarrow> error + ('a extended list)\"\n  where\n    \"concurrent s l u w =\n      do {\n        p_pos \\<leftarrow> idx s (P w);\n        s_pos \\<leftarrow> idx s (S w);\n        return (if (p_pos \\<le> l \\<and> s_pos \\<ge> u) then [\\<lbrakk>I w\\<rbrakk>] else [])\n      }\""], ["", "function integrate_insert\n  where\n    \"integrate_insert m w p s =\n      do {\n        l \\<leftarrow> idx w p;\n        u \\<leftarrow> idx w s;\n        assert (l < u);\n        if Suc l = u then\n          return ((take l w)@[to_woot_char m]@(drop l w))\n        else do {\n          d \\<leftarrow> mapM (concurrent w l u) (substr w l u);\n          assert (concat d \\<noteq> []);\n          (p', s') \\<leftarrow> fromSome (find ((\\<lambda>x.\\<lbrakk>I m\\<rbrakk> < x \\<or> x = s) \\<circ> snd) \n                        (zip (p#concat d) (concat d@[s])));\n          integrate_insert m w p' s'\n        }\n      }\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>m w p s.\n           x = (m, w, p, s) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>m w p s ma wa pa sa.\n       (m, w, p, s) = (ma, wa, pa, sa) \\<Longrightarrow>\n       idx w p \\<bind>\n       (\\<lambda>l.\n           idx w s \\<bind>\n           (\\<lambda>u.\n               assert (l < u) \\<bind>\n               (\\<lambda>_.\n                   if Suc l = u\n                   then Inr (take l w @ [to_woot_char m] @ drop l w)\n                   else mapM (concurrent w l u) (substr w l u) \\<bind>\n                        (\\<lambda>d.\n                            assert (concat d \\<noteq> []) \\<bind>\n                            (\\<lambda>_.\n                                fromSome\n                                 (find\n                                   ((\\<lambda>x.\n  \\<lbrakk>I m\\<rbrakk> < x \\<or> x = s) \\<circ>\n                                    snd)\n                                   (zip (p # concat d)\n                                     (concat d @ [s]))) \\<bind>\n                                (\\<lambda>(x2, x3).\n                                    integrate_insert_sumC\n                                     (m, w, x2, x3))))))) =\n       idx wa pa \\<bind>\n       (\\<lambda>l.\n           idx wa sa \\<bind>\n           (\\<lambda>u.\n               assert (l < u) \\<bind>\n               (\\<lambda>_.\n                   if Suc l = u\n                   then Inr (take l wa @ [to_woot_char ma] @ drop l wa)\n                   else mapM (concurrent wa l u) (substr wa l u) \\<bind>\n                        (\\<lambda>d.\n                            assert (concat d \\<noteq> []) \\<bind>\n                            (\\<lambda>_.\n                                fromSome\n                                 (find\n                                   ((\\<lambda>x.\n  \\<lbrakk>I ma\\<rbrakk> < x \\<or> x = sa) \\<circ>\n                                    snd)\n                                   (zip (pa # concat d)\n                                     (concat d @ [sa]))) \\<bind>\n                                (\\<lambda>(x2, x3).\n                                    integrate_insert_sumC\n                                     (ma, wa, x2, x3)))))))", "by fastforce+"], ["", "fun integrate_delete ::\n  \"('a :: linorder) delete_message\n  \\<Rightarrow> ('a, 's) woot_character list\n  \\<Rightarrow> error + ('a, 's) woot_character list\"\n  where\n    \"integrate_delete (DeleteMessage i) s =\n      do {\n        k \\<leftarrow> idx s \\<lbrakk>i\\<rbrakk>;\n        w \\<leftarrow> nth s k;\n        list_update s k \n          (case w of (InsertMessage p i u _) \\<Rightarrow> InsertMessage p i u None)\n      }\""], ["", "fun integrate ::\n  \"('a, 's) woot_character list\n  \\<Rightarrow> ('a :: linorder, 's) message\n  \\<Rightarrow> error + ('a, 's) woot_character list\"\n  where\n    \"integrate s (Insert m) = integrate_insert m s (P m) (S m)\" |\n    \"integrate s (Delete m) = integrate_delete m s\""], ["", "text \\<open>Algorithm @{term integrate} describes the main function that is called when a new message\n  @{term m} has to be integrated into the state @{term s} of a peer.\n  It is called both when @{term m} was generated locally or received from another peer.\n  Note that we require that the antecedant messages have already been integrated. See also \n  Section \\ref{sec:networkModel} for the delivery assumptions that ensure this requirement.\n\n  Algorithm @{term integrate_delete} describes the procedure to integrate a delete message:\n  @{term \"DeleteMessage i\"}.\n  The algorithm just replaces the symbol of the W-character with identifier @{term i} with the value\n  @{term \"None\"}.\n  It is not possible to entirely remove a W-character if it is deleted, since there might be \n  unreceived insertion messages that depend on its position.\n\n  Algorithm @{term integrate_insert} describes the procedure to integrate an insert message:\n  @{term \"m = InsertMessage p i s \\<sigma>\"}.\n  Since insertion operations can happen concurrently and the order of message delivery is not fixed,\n  it can happen that a remote peer receiving @{term m} finds multiple possible insertion points \n  between the predecessor @{term p} and successor @{term s} that were recorded when the message \n  was generated.\n  An example of this situation is the conflict between\n  @{term \"InsertMessage \\<turnstile> (A,0 :: nat) \\<stileturn> (CHR ''I'')\"} and @{term \"InsertMessage \\<turnstile> (B,0 :: nat) \\<stileturn> (CHR ''N'')\"}\n  in Figure~\\ref{fig:session}.\n\n  A first attempt to resolve this would be to insert the W-characters by choosing an insertion point\n  using the order induced by their identifiers to achieve a consistent ordering.\n  But this method fails in some cases: a counter-example was found by \n  Oster et al.~\\cite[section 2]{oster2006data}.\n\n  The solution introduced by the authors of WOOT is to restrict the identifier comparison to the \n  set of W-characters in the range @{term \"substr l u s\"} whose predecessor and successor are\n  outside of the possible range, i.e. @{text \"idx s (P w) \\<le> l\"} and @{text \"idx s (S w) \\<ge> u\"}.\n\n  New narrowed bounds are selected by finding the first W-character within that restricted set \n  with an identifier strictly larger than the identifier of the new W-character.\n\n  This leads to a narrowed range where the found character forms an upper bound and its immediately\n  preceeding character the lower bound. The method is applied recursively until the insertion point \n  is uniquely determined.\n\n  Note that the fact that this strategy leads to a consistent ordering has only been verified for a\n  bounded model.\n  One of the contributions of this paper is to provide a complete proof for it.\\<close>"], ["", "end"]]}