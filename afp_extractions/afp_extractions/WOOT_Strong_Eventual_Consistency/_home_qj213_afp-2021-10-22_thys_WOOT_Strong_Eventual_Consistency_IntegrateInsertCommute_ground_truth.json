{"file_name": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency/IntegrateInsertCommute.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency", "problem_names": ["lemma substr_simp [simp]: \"substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\"", "lemma int_ins_loop_term_1:\n  assumes \"isOK (mapM (concurrent w l u) t)\"\n  assumes \"x \\<in> set (concat (projr (mapM (concurrent w l u) t)))\"\n  shows \"x \\<in> (InString \\<circ> I) ` (set t)\"", "lemma fromSingleton_simp: \"(fromSingleton xs = Inr x) = ([x] = xs)\"", "lemma filt_simp: \"([b] = filter p [0..<n]) =\n   (p b \\<and> b < n \\<and> (\\<forall>y < n. p y \\<longrightarrow> b = y))\"", "lemma substr_eff: \n  assumes \"x \\<in> (InString \\<circ> I) ` set (substr w l u)\"\n  assumes \"isOK (idx w x)\"\n  shows \"l < (projr (idx w x)) \\<and> (projr (idx w x)) < u\"", "lemma find_zip:\n  assumes \"find (cond \\<circ> snd) (zip (p#v) (v@[s])) = Some (x,y)\" \n  assumes \"v \\<noteq> []\"\n  shows\n    \"cond y\"\n    \"x \\<in> set v \\<or> y \\<in> set v\"\n    \"x = p \\<or> (x \\<in> set v \\<and> \\<not>(cond x))\"\n    \"y = s \\<or> (y \\<in> set v)\"", "lemma int_ins_loop_term:\n  assumes \"idx w p = Inr l\"\n  assumes \"idx w s = Inr u\"\n  assumes \"mapM (concurrent w l u) (substr w l u) = Inr d\" \n  assumes \"concat d \\<noteq> []\"\n  assumes \"find ((\\<lambda>x.\\<lbrakk>I m\\<rbrakk> < x \\<or> x = s) \\<circ> snd) \n    (zip (p#concat d) (concat d@[s])) = Some r\"\n  shows \"int_ins_measure (m, w, r) < u - l\"", "lemma assert_ok_simp [simp]: \"(assert p = Inr z) = p\"", "lemma dist_ext_ids: \"distinct (ext_ids s)\"", "lemma I_inj_on_S:\n  \"l < length s \\<and> u < length s \\<and> I(s ! l) = I(s ! u) \\<Longrightarrow> l = u\"", "lemma idx_find: \n  assumes \"x < length (ext_ids s)\"\n  assumes \"ext_ids s ! x = i\"\n  shows \"idx s i = Inr x\"", "lemma obtain_idx:\n  assumes \"x \\<in> set (ext_ids s)\" \n  shows \"\\<exists>i. idx s x = Inr i\"", "lemma sorted_a:\n  assumes \"idx s x = Inr l\"\n  assumes \"idx s y = Inr u\"\n  shows \"(l \\<le> u) = (a x \\<le> a y)\"", "lemma sorted_a_le: \"idx s x = Inr l \\<Longrightarrow> idx s y = Inr u \\<Longrightarrow> (l < u) = (a x < a y)\"", "lemma idx_intro_ext: \"i < length (ext_ids s) \\<Longrightarrow> idx s (ext_ids s ! i) = Inr i\"", "lemma idx_intro:\n  assumes \"i < length s\"\n  shows \"idx s \\<lbrakk>I (s ! i)\\<rbrakk> = Inr (Suc i)\"", "lemma no_id_collision: \"I m \\<notin> I ` insert_messages M\"", "lemma not_deleted: \"to_woot_char m = to_woot_character M m\"", "lemma invariant_imp_sorted:\n  assumes \"Suc l < length (ext_ids s)\"\n  assumes \"a(ext_ids s ! l) < a \\<lbrakk>I m\\<rbrakk> \\<and> a \\<lbrakk>I m\\<rbrakk> < a(ext_ids s ! (l+1))\"\n  shows \"sorted_wrt (<) (map a (ext_ids ((take l s)@to_woot_char m#drop l s)))\"", "lemma no_self_dep: \"\\<not> depends_on (insert_messages M \\<union> {m}) m m\"", "lemma pred_succ_order:\n  \"m' \\<in> (insert_messages M \\<union> {m}) \\<Longrightarrow> a(P m') < a \\<lbrakk>I m'\\<rbrakk> \\<and> a(S m') > a \\<lbrakk>I m'\\<rbrakk>\"", "lemma find_dep:\n  assumes \"Insert m' \\<in> (M \\<union> {Insert m})\"\n  assumes \"i \\<in> deps (Insert m')\"\n  shows \"\\<lbrakk>i\\<rbrakk> \\<in> set (ext_ids s)\"", "lemma find_pred:\n  \"m' \\<in> (insert_messages M \\<union> {m}) \\<Longrightarrow> P m' \\<in> set (ext_ids s)\"", "lemma find_succ:\n  \"m' \\<in> (insert_messages M \\<union> {m}) \\<Longrightarrow> S m' \\<in> set (ext_ids s)\"", "lemma integrate_insert_final_step:\n  assumes \"invariant pm sm\"\n  assumes \"idx s pm = Inr l\"\n  assumes \"idx s sm = Inr (Suc l)\" \n  shows \"is_certified_associated_string' (Inr (take l s@(to_woot_char m)#drop l s))\"", "lemma concurrent_eff:\n  assumes \"idx s pm = Inr l\"\n  assumes \"idx s sm = Inr u\"\n  obtains d where \"mapM (concurrent s l u) (substr s l u) = Inr d \\<and> \n    set (concat d) = InString ` I ` {x. is_concurrent pm sm x}\"", "lemma concurrent_eff_2:\n  assumes \"invariant pm sm\" \n  assumes \"is_concurrent pm sm x\"\n  shows \"preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk> (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)\"", "lemma concurrent_eff_3:\n  assumes \"idx s pm = Inr l\"\n  assumes \"idx s sm = Inr u\"\n  assumes \"Suc l < u\"\n  shows \"{x. is_concurrent pm sm x} \\<noteq> {}\"", "lemma integrate_insert_result_helper:\n  \"invariant pm sm \\<Longrightarrow> m' = m \\<Longrightarrow> s' = s \\<Longrightarrow> \n  is_certified_associated_string' (integrate_insert m' s' pm sm)\"", "lemma integrate_insert_result:\n  \"is_certified_associated_string' (integrate_insert m s (P m) (S m))\"", "lemma integrate_insert_result:\n  assumes \"consistent (M \\<union> {Insert m})\"\n  assumes \"Insert m \\<notin> M\"\n  assumes \"is_associated_string M s\"\n  shows \"is_certified_associated_string (M \\<union> {Insert m}) (integrate_insert m s (P m) (S m))\"", "lemma set_s: \"set s = to_woot_character M ` insert_messages M\"", "lemma delete_only_m_effect:\n  \"delete_only_m (to_woot_character M x) = to_woot_character (M \\<union> {Delete m}) x\"", "lemma integrate_delete_result:\n  \"is_certified_associated_string (M \\<union> {Delete m}) (integrate_delete m s)\"", "lemma integrate_delete_result:\n  assumes \"consistent (M \\<union> {Delete m})\"\n  assumes \"is_associated_string M s\"\n  shows \"is_certified_associated_string (M \\<union> {Delete m}) (integrate_delete m s)\""], "translations": [["", "lemma substr_simp [simp]: \"substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "proof (cases \"l \\<le> length s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\n 2. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "case True"], ["proof (state)\nthis:\n  l \\<le> length s\n\ngoal (2 subgoals):\n 1. l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\n 2. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "have \"set (nths (take l s) {k. l < Suc k \\<and> Suc k < u}) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (nths (take l s) {k. l < Suc k \\<and> Suc k < u}) = {}", "by (simp add:set_nths)"], ["proof (state)\nthis:\n  set (nths (take l s) {k. l < Suc k \\<and> Suc k < u}) = {}\n\ngoal (2 subgoals):\n 1. l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\n 2. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "hence \"nths (take l s) {k. l < Suc k \\<and> Suc k < u} = []\""], ["proof (prove)\nusing this:\n  set (nths (take l s) {k. l < Suc k \\<and> Suc k < u}) = {}\n\ngoal (1 subgoal):\n 1. nths (take l s) {k. l < Suc k \\<and> Suc k < u} = []", "by blast"], ["proof (state)\nthis:\n  nths (take l s) {k. l < Suc k \\<and> Suc k < u} = []\n\ngoal (2 subgoals):\n 1. l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\n 2. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "moreover"], ["proof (state)\nthis:\n  nths (take l s) {k. l < Suc k \\<and> Suc k < u} = []\n\ngoal (2 subgoals):\n 1. l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\n 2. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "have \"{j. Suc (j + l) < u} = {..<(u-Suc l)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {j. Suc (j + l) < u} = {..<u - Suc l}", "by auto"], ["proof (state)\nthis:\n  {j. Suc (j + l) < u} = {..<u - Suc l}\n\ngoal (2 subgoals):\n 1. l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\n 2. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "moreover"], ["proof (state)\nthis:\n  {j. Suc (j + l) < u} = {..<u - Suc l}\n\ngoal (2 subgoals):\n 1. l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\n 2. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "have \"min (length s) l = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (length s) l = l", "using True"], ["proof (prove)\nusing this:\n  l \\<le> length s\n\ngoal (1 subgoal):\n 1. min (length s) l = l", "by auto"], ["proof (state)\nthis:\n  min (length s) l = l\n\ngoal (2 subgoals):\n 1. l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\n 2. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "ultimately"], ["proof (chain)\npicking this:\n  nths (take l s) {k. l < Suc k \\<and> Suc k < u} = []\n  {j. Suc (j + l) < u} = {..<u - Suc l}\n  min (length s) l = l", "have \"nths (take l s @ drop l s) {k. l < Suc k \\<and> Suc k < u} = substr s l u\""], ["proof (prove)\nusing this:\n  nths (take l s) {k. l < Suc k \\<and> Suc k < u} = []\n  {j. Suc (j + l) < u} = {..<u - Suc l}\n  min (length s) l = l\n\ngoal (1 subgoal):\n 1. nths (take l s @ drop l s) {k. l < Suc k \\<and> Suc k < u} =\n    substr s l u", "by (simp add:nths_append del:append_take_drop_id)"], ["proof (state)\nthis:\n  nths (take l s @ drop l s) {k. l < Suc k \\<and> Suc k < u} = substr s l u\n\ngoal (2 subgoals):\n 1. l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\n 2. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "then"], ["proof (chain)\npicking this:\n  nths (take l s @ drop l s) {k. l < Suc k \\<and> Suc k < u} = substr s l u", "show ?thesis"], ["proof (prove)\nusing this:\n  nths (take l s @ drop l s) {k. l < Suc k \\<and> Suc k < u} = substr s l u\n\ngoal (1 subgoal):\n 1. substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "by simp"], ["proof (state)\nthis:\n  substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "case False"], ["proof (state)\nthis:\n  \\<not> l \\<le> length s\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "hence \"set (nths s {k. l < Suc k \\<and> Suc k < u}) = {}\""], ["proof (prove)\nusing this:\n  \\<not> l \\<le> length s\n\ngoal (1 subgoal):\n 1. set (nths s {k. l < Suc k \\<and> Suc k < u}) = {}", "by (simp add:set_nths)"], ["proof (state)\nthis:\n  set (nths s {k. l < Suc k \\<and> Suc k < u}) = {}\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "hence \"nths s {k. l < Suc k \\<and> Suc k < u} = []\""], ["proof (prove)\nusing this:\n  set (nths s {k. l < Suc k \\<and> Suc k < u}) = {}\n\ngoal (1 subgoal):\n 1. nths s {k. l < Suc k \\<and> Suc k < u} = []", "by blast"], ["proof (state)\nthis:\n  nths s {k. l < Suc k \\<and> Suc k < u} = []\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> length s \\<Longrightarrow>\n    substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "thus ?thesis"], ["proof (prove)\nusing this:\n  nths s {k. l < Suc k \\<and> Suc k < u} = []\n\ngoal (1 subgoal):\n 1. substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "using False"], ["proof (prove)\nusing this:\n  nths s {k. l < Suc k \\<and> Suc k < u} = []\n  \\<not> l \\<le> length s\n\ngoal (1 subgoal):\n 1. substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}", "by simp"], ["proof (state)\nthis:\n  substr s l u = nths s {k. l < Suc k \\<and> Suc k < u}\n\ngoal:\nNo subgoals!", "qed"], ["", "declare substr.simps [simp del]"], ["", "text \\<open>Instead of simplifying @{term substr} with its definition we use @{thm [source] substr_simp}\n  as a simplification rule. The right hand side of @{thm [source] substr_simp} is a better\n  representation within proofs. However, we cannot directly define @{term substr} using the right\n  hand side as it is not constructible term for Isabelle.\\<close>"], ["", "lemma int_ins_loop_term_1:\n  assumes \"isOK (mapM (concurrent w l u) t)\"\n  assumes \"x \\<in> set (concat (projr (mapM (concurrent w l u) t)))\"\n  shows \"x \\<in> (InString \\<circ> I) ` (set t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (InString \\<circ> I) ` set t", "using assms"], ["proof (prove)\nusing this:\n  isOK (mapM (concurrent w l u) t)\n  x \\<in> set (concat (projr (mapM (concurrent w l u) t)))\n\ngoal (1 subgoal):\n 1. x \\<in> (InString \\<circ> I) ` set t", "by (induction t, simp, simp add: bind_simp del:idx.simps set_concat, blast)"], ["", "lemma fromSingleton_simp: \"(fromSingleton xs = Inr x) = ([x] = xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fromSingleton xs = Inr x) = ([x] = xs)", "by (cases xs rule: fromSingleton.cases, auto)"], ["", "lemma filt_simp: \"([b] = filter p [0..<n]) =\n   (p b \\<and> b < n \\<and> (\\<forall>y < n. p y \\<longrightarrow> b = y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([b] = filter p [0..<n]) =\n    (p b \\<and> b < n \\<and> (\\<forall>y<n. p y \\<longrightarrow> b = y))", "apply (induction n, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ([b] = filter p [0..<n]) =\n       (p b \\<and>\n        b < n \\<and>\n        (\\<forall>y<n. p y \\<longrightarrow> b = y)) \\<Longrightarrow>\n       (p n \\<longrightarrow>\n        ([] = filter p [0..<n] \\<and> b = n) =\n        (p b \\<and>\n         b < Suc n \\<and>\n         (\\<forall>y<Suc n. p y \\<longrightarrow> b = y))) \\<and>\n       (\\<not> p n \\<longrightarrow>\n        (p b \\<and>\n         b < n \\<and> (\\<forall>y<n. p y \\<longrightarrow> b = y)) =\n        (p b \\<and>\n         b < Suc n \\<and> (\\<forall>y<Suc n. p y \\<longrightarrow> b = y)))", "by (metis atLeast_upt cancel_comm_monoid_add_class.diff_cancel \n      filter_empty_conv lessThan_iff less_Suc_eq neq0_conv zero_less_diff)"], ["", "lemma substr_eff: \n  assumes \"x \\<in> (InString \\<circ> I) ` set (substr w l u)\"\n  assumes \"isOK (idx w x)\"\n  shows \"l < (projr (idx w x)) \\<and> (projr (idx w x)) < u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < projr (idx w x) \\<and> projr (idx w x) < u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l < projr (idx w x) \\<and> projr (idx w x) < u", "obtain i where i_def: \"idx w x = Inr i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. idx w x = Inr i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  isOK (idx w x)\n\ngoal (1 subgoal):\n 1. (\\<And>i. idx w x = Inr i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  idx w x = Inr i\n\ngoal (1 subgoal):\n 1. l < projr (idx w x) \\<and> projr (idx w x) < u", "then"], ["proof (chain)\npicking this:\n  idx w x = Inr i", "have \"l < i \\<and> i < u\""], ["proof (prove)\nusing this:\n  idx w x = Inr i\n\ngoal (1 subgoal):\n 1. l < i \\<and> i < u", "using assms(1)"], ["proof (prove)\nusing this:\n  idx w x = Inr i\n  x \\<in> (InString \\<circ> I) ` set (substr w l u)\n\ngoal (1 subgoal):\n 1. l < i \\<and> i < u", "apply (simp add: set_nths image_iff fromSingleton_simp filt_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ext_ids w ! i = x \\<and>\n             i < length (ext_ids w) \\<and>\n             (\\<forall>y<length (ext_ids w).\n                 ext_ids w ! y = x \\<longrightarrow> i = y);\n     \\<exists>xa.\n        (\\<exists>i.\n            xa = w ! i \\<and>\n            i < length w \\<and> l < Suc i \\<and> Suc i < u) \\<and>\n        x = \\<lbrakk>I xa\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> l < i \\<and> i < u", "apply (simp add:ext_ids_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<turnstile> #\n              map (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>) w @ [\\<stileturn>]) !\n             i =\n             x \\<and>\n             i < Suc (Suc (length w)) \\<and>\n             (\\<forall>y<Suc (Suc (length w)).\n                 (\\<turnstile> #\n                  map (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>) w @\n                  [\\<stileturn>]) !\n                 y =\n                 x \\<longrightarrow>\n                 i = y);\n     \\<exists>xa.\n        (\\<exists>i.\n            xa = w ! i \\<and>\n            i < length w \\<and> l < Suc i \\<and> Suc i < u) \\<and>\n        x = \\<lbrakk>I xa\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> l < i \\<and> i < u", "by (metis (no_types, lifting) Suc_mono length_map less_SucI list_update_id\n        list_update_same_conv map_update nth_Cons_Suc nth_append)"], ["proof (state)\nthis:\n  l < i \\<and> i < u\n\ngoal (1 subgoal):\n 1. l < projr (idx w x) \\<and> projr (idx w x) < u", "thus ?thesis"], ["proof (prove)\nusing this:\n  l < i \\<and> i < u\n\ngoal (1 subgoal):\n 1. l < projr (idx w x) \\<and> projr (idx w x) < u", "using i_def"], ["proof (prove)\nusing this:\n  l < i \\<and> i < u\n  idx w x = Inr i\n\ngoal (1 subgoal):\n 1. l < projr (idx w x) \\<and> projr (idx w x) < u", "by auto"], ["proof (state)\nthis:\n  l < projr (idx w x) \\<and> projr (idx w x) < u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_zip:\n  assumes \"find (cond \\<circ> snd) (zip (p#v) (v@[s])) = Some (x,y)\" \n  assumes \"v \\<noteq> []\"\n  shows\n    \"cond y\"\n    \"x \\<in> set v \\<or> y \\<in> set v\"\n    \"x = p \\<or> (x \\<in> set v \\<and> \\<not>(cond x))\"\n    \"y = s \\<or> (y \\<in> set v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cond y &&& x \\<in> set v \\<or> y \\<in> set v) &&&\n    x = p \\<or> x \\<in> set v \\<and> \\<not> cond x &&&\n    y = s \\<or> y \\<in> set v", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. cond y\n 2. x \\<in> set v \\<or> y \\<in> set v\n 3. x = p \\<or> x \\<in> set v \\<and> \\<not> cond x\n 4. y = s \\<or> y \\<in> set v", "obtain i where i_def:\n    \"i < Suc (length v)\"\n    \"(zip (p#v) (v@[s])) ! i = (x,y)\"\n    \"cond y\"\n    \"\\<forall>j. j < i \\<longrightarrow> \\<not>(cond ((v@[s])!j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < Suc (length v); zip (p # v) (v @ [s]) ! i = (x, y);\n         cond y; \\<forall>j<i. \\<not> cond ((v @ [s]) ! j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  find (cond \\<circ> snd) (zip (p # v) (v @ [s])) = Some (x, y)\n  v \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < Suc (length v); zip (p # v) (v @ [s]) ! i = (x, y);\n         cond y; \\<forall>j<i. \\<not> cond ((v @ [s]) ! j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (simp add:find_Some_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>i < Suc (length v);\n                 (p # v) ! i = x \\<and> (v @ [s]) ! i = y; cond y;\n                 \\<forall>j<i. \\<not> cond ((v @ [s]) ! j)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>i<Suc (length v).\n        cond (snd (zip (p # v) (v @ [s]) ! i)) \\<and>\n        (x, y) = zip (p # v) (v @ [s]) ! i \\<and>\n        (\\<forall>j<i. \\<not> cond (snd (zip (p # v) (v @ [s]) ! j)));\n     v \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  i < Suc (length v)\n  zip (p # v) (v @ [s]) ! i = (x, y)\n  cond y\n  \\<forall>j<i. \\<not> cond ((v @ [s]) ! j)\n\ngoal (4 subgoals):\n 1. cond y\n 2. x \\<in> set v \\<or> y \\<in> set v\n 3. x = p \\<or> x \\<in> set v \\<and> \\<not> cond x\n 4. y = s \\<or> y \\<in> set v", "show \"cond y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond y", "using i_def"], ["proof (prove)\nusing this:\n  i < Suc (length v)\n  zip (p # v) (v @ [s]) ! i = (x, y)\n  cond y\n  \\<forall>j<i. \\<not> cond ((v @ [s]) ! j)\n\ngoal (1 subgoal):\n 1. cond y", "by auto"], ["proof (state)\nthis:\n  cond y\n\ngoal (3 subgoals):\n 1. x \\<in> set v \\<or> y \\<in> set v\n 2. x = p \\<or> x \\<in> set v \\<and> \\<not> cond x\n 3. y = s \\<or> y \\<in> set v", "show \"x \\<in> set v \\<or> y \\<in> set v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set v \\<or> y \\<in> set v", "using assms(2) i_def(1,2)"], ["proof (prove)\nusing this:\n  v \\<noteq> []\n  i < Suc (length v)\n  zip (p # v) (v @ [s]) ! i = (x, y)\n\ngoal (1 subgoal):\n 1. x \\<in> set v \\<or> y \\<in> set v", "by (metis fst_conv in_set_conv_nth length_0_conv length_Cons length_append_singleton\n        less_Suc_eq less_Suc_eq_0_disj nth_Cons_Suc nth_append nth_zip snd_conv)"], ["proof (state)\nthis:\n  x \\<in> set v \\<or> y \\<in> set v\n\ngoal (2 subgoals):\n 1. x = p \\<or> x \\<in> set v \\<and> \\<not> cond x\n 2. y = s \\<or> y \\<in> set v", "show \"x = p \\<or> (x \\<in> set v \\<and> (\\<not>(cond x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = p \\<or> x \\<in> set v \\<and> \\<not> cond x", "apply (cases i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> x = p \\<or> x \\<in> set v \\<and> \\<not> cond x\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       x = p \\<or> x \\<in> set v \\<and> \\<not> cond x", "using i_def(2)"], ["proof (prove)\nusing this:\n  zip (p # v) (v @ [s]) ! i = (x, y)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> x = p \\<or> x \\<in> set v \\<and> \\<not> cond x\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       x = p \\<or> x \\<in> set v \\<and> \\<not> cond x", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       x = p \\<or> x \\<in> set v \\<and> \\<not> cond x", "by (metis Suc_less_eq fst_conv i_def(1,2,4) length_Cons\n        length_append_singleton lessI nth_Cons_Suc nth_append nth_mem nth_zip)"], ["proof (state)\nthis:\n  x = p \\<or> x \\<in> set v \\<and> \\<not> cond x\n\ngoal (1 subgoal):\n 1. y = s \\<or> y \\<in> set v", "show \"y = s \\<or> y \\<in> set v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = s \\<or> y \\<in> set v", "by (metis diff_is_0_eq' i_def(1,2) in_set_conv_nth length_Cons\n        length_append_singleton less_Suc_eq_le nth_Cons_0 nth_append nth_zip snd_conv)"], ["proof (state)\nthis:\n  y = s \\<or> y \\<in> set v\n\ngoal:\nNo subgoals!", "qed"], ["", "fun int_ins_measure'\n  where\n    \"int_ins_measure' (m,w,p,s) = (\n      do {\n        l \\<leftarrow> idx w p;\n        u \\<leftarrow> idx w s;\n        assert (l < u);\n        return (u - l)\n      })\""], ["", "fun int_ins_measure\n  where\n    \"int_ins_measure (m,w,p,s) = case_sum (\\<lambda>e. 0) id (int_ins_measure' (m,w,p,s))\""], ["", "text \\<open>We show that during the iteration of @{term integrate_insert}, the arguments are decreasing\n  with respect to @{term int_ins_measure}. Note, this means that the distance between the\n  W-characters with identifiers @{term p} (resp. @{term s}) is decreasing.\\<close>"], ["", "lemma int_ins_loop_term:\n  assumes \"idx w p = Inr l\"\n  assumes \"idx w s = Inr u\"\n  assumes \"mapM (concurrent w l u) (substr w l u) = Inr d\" \n  assumes \"concat d \\<noteq> []\"\n  assumes \"find ((\\<lambda>x.\\<lbrakk>I m\\<rbrakk> < x \\<or> x = s) \\<circ> snd) \n    (zip (p#concat d) (concat d@[s])) = Some r\"\n  shows \"int_ins_measure (m, w, r) < u - l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_ins_measure (m, w, r) < u - l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int_ins_measure (m, w, r) < u - l", "have a: \"\\<And>x y. x \\<in> set (concat d) \\<Longrightarrow> idx w x = Inr y \\<Longrightarrow> l < y \\<and> y < u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (concat d); idx w x = Inr y\\<rbrakk>\n       \\<Longrightarrow> l < y \\<and> y < u", "using int_ins_loop_term_1 substr_eff assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>isOK (mapM (concurrent ?w ?l ?u) ?t);\n   ?x \\<in> set (concat (projr (mapM (concurrent ?w ?l ?u) ?t)))\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> (InString \\<circ> I) ` set ?t\n  \\<lbrakk>?x \\<in> (InString \\<circ> I) ` set (substr ?w ?l ?u);\n   isOK (idx ?w ?x)\\<rbrakk>\n  \\<Longrightarrow> ?l < projr (idx ?w ?x) \\<and> projr (idx ?w ?x) < ?u\n  mapM (concurrent w l u) (substr w l u) = Inr d\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (concat d); idx w x = Inr y\\<rbrakk>\n       \\<Longrightarrow> l < y \\<and> y < u", "by (metis isOK_I sum.sel(2))"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (concat d); idx w ?x = Inr ?y\\<rbrakk>\n  \\<Longrightarrow> l < ?y \\<and> ?y < u\n\ngoal (1 subgoal):\n 1. int_ins_measure (m, w, r) < u - l", "hence b: \"l < u\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (concat d); idx w ?x = Inr ?y\\<rbrakk>\n  \\<Longrightarrow> l < ?y \\<and> ?y < u\n\ngoal (1 subgoal):\n 1. l < u", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (concat d); idx w ?x = Inr ?y\\<rbrakk>\n  \\<Longrightarrow> l < ?y \\<and> ?y < u\n  idx w p = Inr l\n  idx w s = Inr u\n  mapM (concurrent w l u) (substr w l u) = Inr d\n  concat d \\<noteq> []\n  find ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = s) \\<circ> snd)\n   (zip (p # concat d) (concat d @ [s])) =\n  Some r\n\ngoal (1 subgoal):\n 1. l < u", "by (metis concat.simps(1) diff_is_0_eq less_imp_le_nat\n        mapM.simps(1) not_less_eq substr.simps sum.sel(2) take0)"], ["proof (state)\nthis:\n  l < u\n\ngoal (1 subgoal):\n 1. int_ins_measure (m, w, r) < u - l", "obtain p' s' where ps_def: \"r = (p', s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p' s'. r = (p', s') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r, simp+)"], ["proof (state)\nthis:\n  r = (p', s')\n\ngoal (1 subgoal):\n 1. int_ins_measure (m, w, r) < u - l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_ins_measure (m, w, r) < u - l", "proof (cases \"int_ins_measure' (m, w, r)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       int_ins_measure' (m, w, r) = Inl a \\<Longrightarrow>\n       int_ins_measure (m, w, r) < u - l\n 2. \\<And>b.\n       int_ins_measure' (m, w, r) = Inr b \\<Longrightarrow>\n       int_ins_measure (m, w, r) < u - l", "case (Inl a)"], ["proof (state)\nthis:\n  int_ins_measure' (m, w, r) = Inl a\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       int_ins_measure' (m, w, r) = Inl a \\<Longrightarrow>\n       int_ins_measure (m, w, r) < u - l\n 2. \\<And>b.\n       int_ins_measure' (m, w, r) = Inr b \\<Longrightarrow>\n       int_ins_measure (m, w, r) < u - l", "then"], ["proof (chain)\npicking this:\n  int_ins_measure' (m, w, r) = Inl a", "show ?thesis"], ["proof (prove)\nusing this:\n  int_ins_measure' (m, w, r) = Inl a\n\ngoal (1 subgoal):\n 1. int_ins_measure (m, w, r) < u - l", "using b"], ["proof (prove)\nusing this:\n  int_ins_measure' (m, w, r) = Inl a\n  l < u\n\ngoal (1 subgoal):\n 1. int_ins_measure (m, w, r) < u - l", "by (simp add:ps_def)"], ["proof (state)\nthis:\n  int_ins_measure (m, w, r) < u - l\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       int_ins_measure' (m, w, r) = Inr b \\<Longrightarrow>\n       int_ins_measure (m, w, r) < u - l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       int_ins_measure' (m, w, r) = Inr b \\<Longrightarrow>\n       int_ins_measure (m, w, r) < u - l", "case (Inr b)"], ["proof (state)\nthis:\n  int_ins_measure' (m, w, r) = Inr b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       int_ins_measure' (m, w, r) = Inr b \\<Longrightarrow>\n       int_ins_measure (m, w, r) < u - l", "then"], ["proof (chain)\npicking this:\n  int_ins_measure' (m, w, r) = Inr b", "obtain l' u' where ps'_def: \"idx w p' = Inr l'\" \"idx w s' = Inr u'\""], ["proof (prove)\nusing this:\n  int_ins_measure' (m, w, r) = Inr b\n\ngoal (1 subgoal):\n 1. (\\<And>l' u'.\n        \\<lbrakk>idx w p' = Inr l'; idx w s' = Inr u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ps_def"], ["proof (prove)\nusing this:\n  int_ins_measure' (m, w, r) = Inr b\n  r = (p', s')\n\ngoal (1 subgoal):\n 1. (\\<And>l' u'.\n        \\<lbrakk>idx w p' = Inr l'; idx w s' = Inr u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (simp add:bind_simp del:idx.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l' u'.\n                \\<lbrakk>idx w p' = Inr l'; idx w s' = Inr u'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     idx w p' \\<bind>\n     (\\<lambda>l.\n         idx w s' \\<bind>\n         (\\<lambda>u. assert (l < u) \\<bind> (\\<lambda>_. Inr (u - l)))) =\n     Inr b;\n     r = (p', s')\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  idx w p' = Inr l'\n  idx w s' = Inr u'\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       int_ins_measure' (m, w, r) = Inr b \\<Longrightarrow>\n       int_ins_measure (m, w, r) < u - l", "then"], ["proof (chain)\npicking this:\n  idx w p' = Inr l'\n  idx w s' = Inr u'", "have \"l' \\<ge> l \\<and> l' < u \\<and> u' > l \\<and> u' \\<le> u \\<and> (l' > l \\<or> u' < u)\""], ["proof (prove)\nusing this:\n  idx w p' = Inr l'\n  idx w s' = Inr u'\n\ngoal (1 subgoal):\n 1. l \\<le> l' \\<and>\n    l' < u \\<and> l < u' \\<and> u' \\<le> u \\<and> (l < l' \\<or> u' < u)", "using a b ps_def find_zip(2,3,4) assms(1,2,4,5)"], ["proof (prove)\nusing this:\n  idx w p' = Inr l'\n  idx w s' = Inr u'\n  \\<lbrakk>?x \\<in> set (concat d); idx w ?x = Inr ?y\\<rbrakk>\n  \\<Longrightarrow> l < ?y \\<and> ?y < u\n  l < u\n  r = (p', s')\n  \\<lbrakk>find (?cond \\<circ> snd) (zip (?p # ?v) (?v @ [?s])) =\n           Some (?x, ?y);\n   ?v \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> set ?v \\<or> ?y \\<in> set ?v\n  \\<lbrakk>find (?cond \\<circ> snd) (zip (?p # ?v) (?v @ [?s])) =\n           Some (?x, ?y);\n   ?v \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?x = ?p \\<or> ?x \\<in> set ?v \\<and> \\<not> ?cond ?x\n  \\<lbrakk>find (?cond \\<circ> snd) (zip (?p # ?v) (?v @ [?s])) =\n           Some (?x, ?y);\n   ?v \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?y = ?s \\<or> ?y \\<in> set ?v\n  idx w p = Inr l\n  idx w s = Inr u\n  concat d \\<noteq> []\n  find ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = s) \\<circ> snd)\n   (zip (p # concat d) (concat d @ [s])) =\n  Some r\n\ngoal (1 subgoal):\n 1. l \\<le> l' \\<and>\n    l' < u \\<and> l < u' \\<and> u' \\<le> u \\<and> (l < l' \\<or> u' < u)", "by (metis (no_types, lifting) Inr_inject order.order_iff_strict)"], ["proof (state)\nthis:\n  l \\<le> l' \\<and>\n  l' < u \\<and> l < u' \\<and> u' \\<le> u \\<and> (l < l' \\<or> u' < u)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       int_ins_measure' (m, w, r) = Inr b \\<Longrightarrow>\n       int_ins_measure (m, w, r) < u - l", "thus ?thesis"], ["proof (prove)\nusing this:\n  l \\<le> l' \\<and>\n  l' < u \\<and> l < u' \\<and> u' \\<le> u \\<and> (l < l' \\<or> u' < u)\n\ngoal (1 subgoal):\n 1. int_ins_measure (m, w, r) < u - l", "using ps_def ps'_def"], ["proof (prove)\nusing this:\n  l \\<le> l' \\<and>\n  l' < u \\<and> l < u' \\<and> u' \\<le> u \\<and> (l < l' \\<or> u' < u)\n  r = (p', s')\n  idx w p' = Inr l'\n  idx w s' = Inr u'\n\ngoal (1 subgoal):\n 1. int_ins_measure (m, w, r) < u - l", "apply (simp add:bind_simp del:idx.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<le> l' \\<and>\n             l' < u \\<and>\n             l < u' \\<and> u' \\<le> u \\<and> (l < l' \\<or> u' < u);\n     r = (p', s'); idx w p' = Inr l'; idx w s' = Inr u'\\<rbrakk>\n    \\<Longrightarrow> (case assert (l' < u') \\<bind>\n                            (\\<lambda>_. Inr (u' - l')) of\n                       Inl e \\<Rightarrow> 0 | Inr x \\<Rightarrow> id x)\n                      < u - l", "by (cases \"l' < u'\", simp del:idx.simps, linarith, simp del:idx.simps)"], ["proof (state)\nthis:\n  int_ins_measure (m, w, r) < u - l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int_ins_measure (m, w, r) < u - l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assert_ok_simp [simp]: \"(assert p = Inr z) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (assert p = Inr z) = p", "by (cases p, simp+)"], ["", "termination integrate_insert"], ["proof (prove)\ngoal (1 subgoal):\n 1. All integrate_insert_dom", "apply (relation \"measure int_ins_measure\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m w p s y ya yb yba yc yd x ye.\n       \\<lbrakk>idx w p = Inr y; idx w s = Inr ya; assert (y < ya) = Inr yb;\n        Suc y \\<noteq> ya;\n        mapM (concurrent w y ya) (substr w y ya) = Inr yba;\n        assert (concat yba \\<noteq> []) = Inr yc;\n        fromSome\n         (find\n           ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = s) \\<circ> snd)\n           (zip (p # concat yba) (concat yba @ [s]))) =\n        Inr yd;\n        (x, ye) = yd\\<rbrakk>\n       \\<Longrightarrow> ((m, w, x, ye), m, w, p, s)\n                         \\<in> measure int_ins_measure", "using int_ins_loop_term"], ["proof (prove)\nusing this:\n  \\<lbrakk>idx ?w ?p = Inr ?l; idx ?w ?s = Inr ?u;\n   mapM (concurrent ?w ?l ?u) (substr ?w ?l ?u) = Inr ?d;\n   concat ?d \\<noteq> [];\n   find ((\\<lambda>x. \\<lbrakk>I ?m\\<rbrakk> < x \\<or> x = ?s) \\<circ> snd)\n    (zip (?p # concat ?d) (concat ?d @ [?s])) =\n   Some ?r\\<rbrakk>\n  \\<Longrightarrow> int_ins_measure (?m, ?w, ?r) < ?u - ?l\n\ngoal (1 subgoal):\n 1. \\<And>m w p s y ya yb yba yc yd x ye.\n       \\<lbrakk>idx w p = Inr y; idx w s = Inr ya; assert (y < ya) = Inr yb;\n        Suc y \\<noteq> ya;\n        mapM (concurrent w y ya) (substr w y ya) = Inr yba;\n        assert (concat yba \\<noteq> []) = Inr yc;\n        fromSome\n         (find\n           ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = s) \\<circ> snd)\n           (zip (p # concat yba) (concat yba @ [s]))) =\n        Inr yd;\n        (x, ye) = yd\\<rbrakk>\n       \\<Longrightarrow> ((m, w, x, ye), m, w, p, s)\n                         \\<in> measure int_ins_measure", "by (simp del:idx.simps, blast)"], ["", "subsection \\<open>Integrate Commutes\\<close>"], ["", "locale integrate_insert_commute =\n  fixes M :: \"('a :: linorder, 's) message set\"\n  fixes a :: \"'a extended \\<Rightarrow> 'a position\"\n  fixes s :: \"('a, 's) woot_character list\"\n  assumes associated_string_assm: \"is_associated_string M s\"\n  assumes a_conditions_assm: \"a_conditions (insert_messages M) a\"\nbegin"], ["", "lemma dist_ext_ids: \"distinct (ext_ids s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ext_ids s)", "using associated_string_assm a_conditions_assm"], ["proof (prove)\nusing this:\n  is_associated_string M s\n  a_conditions (insert_messages M) a\n\ngoal (1 subgoal):\n 1. distinct (ext_ids s)", "apply (simp add:is_associated_string_def sorted_wrt_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent M \\<and>\n             set s = to_woot_character M ` insert_messages M \\<and>\n             (\\<forall>a.\n                 a_conditions (insert_messages M) a \\<longrightarrow>\n                 sorted_wrt (\\<lambda>x y. a x < a y) (ext_ids s));\n     a_conditions (insert_messages M) a\\<rbrakk>\n    \\<Longrightarrow> distinct (ext_ids s)", "by (metis (mono_tags) irreflp_def le_less not_le sorted_wrt_irrefl_distinct)"], ["", "lemma I_inj_on_S:\n  \"l < length s \\<and> u < length s \\<and> I(s ! l) = I(s ! u) \\<Longrightarrow> l = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < length s \\<and>\n    u < length s \\<and> I (s ! l) = I (s ! u) \\<Longrightarrow>\n    l = u", "using dist_ext_ids"], ["proof (prove)\nusing this:\n  distinct (ext_ids s)\n\ngoal (1 subgoal):\n 1. l < length s \\<and>\n    u < length s \\<and> I (s ! l) = I (s ! u) \\<Longrightarrow>\n    l = u", "apply (simp add:ext_ids_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < length s \\<and> u < length s \\<and> I (s ! l) = I (s ! u);\n     \\<turnstile>\n     \\<notin> (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>) ` set s \\<and>\n     distinct (map (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>) s) \\<and>\n     \\<stileturn>\n     \\<notin> (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>) ` set s\\<rbrakk>\n    \\<Longrightarrow> l = u", "using nth_eq_iff_index_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?xs; ?i < length ?xs; ?j < length ?xs\\<rbrakk>\n  \\<Longrightarrow> (?xs ! ?i = ?xs ! ?j) = (?i = ?j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l < length s \\<and> u < length s \\<and> I (s ! l) = I (s ! u);\n     \\<turnstile>\n     \\<notin> (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>) ` set s \\<and>\n     distinct (map (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>) s) \\<and>\n     \\<stileturn>\n     \\<notin> (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>) ` set s\\<rbrakk>\n    \\<Longrightarrow> l = u", "by fastforce"], ["", "lemma idx_find: \n  assumes \"x < length (ext_ids s)\"\n  assumes \"ext_ids s ! x = i\"\n  shows \"idx s i = Inr x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx s i = Inr x", "using assms dist_ext_ids nth_eq_iff_index_eq"], ["proof (prove)\nusing this:\n  x < length (ext_ids s)\n  ext_ids s ! x = i\n  distinct (ext_ids s)\n  \\<lbrakk>distinct ?xs; ?i < length ?xs; ?j < length ?xs\\<rbrakk>\n  \\<Longrightarrow> (?xs ! ?i = ?xs ! ?j) = (?i = ?j)\n\ngoal (1 subgoal):\n 1. idx s i = Inr x", "by (simp add:filt_simp fromSingleton_simp, blast)"], ["", "lemma obtain_idx:\n  assumes \"x \\<in> set (ext_ids s)\" \n  shows \"\\<exists>i. idx s x = Inr i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. idx s x = Inr i", "using idx_find assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < length (ext_ids s); ext_ids s ! ?x = ?i\\<rbrakk>\n  \\<Longrightarrow> idx s ?i = Inr ?x\n  x \\<in> set (ext_ids s)\n\ngoal (1 subgoal):\n 1. \\<exists>i. idx s x = Inr i", "by (metis in_set_conv_nth)"], ["", "lemma sorted_a:\n  assumes \"idx s x = Inr l\"\n  assumes \"idx s y = Inr u\"\n  shows \"(l \\<le> u) = (a x \\<le> a y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l \\<le> u) = (a x \\<le> a y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (l \\<le> u) = (a x \\<le> a y)", "have \"sorted_wrt (<) (map a (ext_ids s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids s))", "using associated_string_assm a_conditions_assm is_associated_string_def"], ["proof (prove)\nusing this:\n  is_associated_string M s\n  a_conditions (insert_messages M) a\n  is_associated_string ?M ?s \\<equiv>\n  consistent ?M \\<and>\n  set ?s = to_woot_character ?M ` insert_messages ?M \\<and>\n  (\\<forall>a.\n      a_conditions (insert_messages ?M) a \\<longrightarrow>\n      sorted_wrt (<) (map a (ext_ids ?s)))\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids s))", "by blast"], ["proof (state)\nthis:\n  sorted_wrt (<) (map a (ext_ids s))\n\ngoal (1 subgoal):\n 1. (l \\<le> u) = (a x \\<le> a y)", "then"], ["proof (chain)\npicking this:\n  sorted_wrt (<) (map a (ext_ids s))", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt (<) (map a (ext_ids s))\n\ngoal (1 subgoal):\n 1. (l \\<le> u) = (a x \\<le> a y)", "using assms"], ["proof (prove)\nusing this:\n  sorted_wrt (<) (map a (ext_ids s))\n  idx s x = Inr l\n  idx s y = Inr u\n\ngoal (1 subgoal):\n 1. (l \\<le> u) = (a x \\<le> a y)", "apply (simp add:filt_simp fromSingleton_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt (<) (map a (ext_ids s));\n     ext_ids s ! l = x \\<and>\n     l < length (ext_ids s) \\<and>\n     (\\<forall>y<length (ext_ids s).\n         ext_ids s ! y = x \\<longrightarrow> l = y);\n     ext_ids s ! u = y \\<and>\n     u < length (ext_ids s) \\<and>\n     (\\<forall>ya<length (ext_ids s).\n         ext_ids s ! ya = y \\<longrightarrow> u = ya)\\<rbrakk>\n    \\<Longrightarrow> (l \\<le> u) = (a x \\<le> a y)", "by (metis leD leI le_less length_map nth_map sorted_wrt_nth_less)"], ["proof (state)\nthis:\n  (l \\<le> u) = (a x \\<le> a y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_a_le: \"idx s x = Inr l \\<Longrightarrow> idx s y = Inr u \\<Longrightarrow> (l < u) = (a x < a y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>idx s x = Inr l; idx s y = Inr u\\<rbrakk>\n    \\<Longrightarrow> (l < u) = (a x < a y)", "by (meson sorted_a not_le)"], ["", "lemma idx_intro_ext: \"i < length (ext_ids s) \\<Longrightarrow> idx s (ext_ids s ! i) = Inr i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (ext_ids s) \\<Longrightarrow> idx s (ext_ids s ! i) = Inr i", "using dist_ext_ids"], ["proof (prove)\nusing this:\n  distinct (ext_ids s)\n\ngoal (1 subgoal):\n 1. i < length (ext_ids s) \\<Longrightarrow> idx s (ext_ids s ! i) = Inr i", "by (simp add:fromSingleton_simp filt_simp  nth_eq_iff_index_eq)"], ["", "lemma idx_intro:\n  assumes \"i < length s\"\n  shows \"idx s \\<lbrakk>I (s ! i)\\<rbrakk> = Inr (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx s \\<lbrakk>I (s ! i)\\<rbrakk> = Inr (Suc i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. idx s \\<lbrakk>I (s ! i)\\<rbrakk> = Inr (Suc i)", "have \"ext_ids s  ! (Suc i) = \\<lbrakk>I (s ! i)\\<rbrakk> \\<and> Suc i < length (ext_ids s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ext_ids s ! Suc i = \\<lbrakk>I (s ! i)\\<rbrakk> \\<and>\n    Suc i < length (ext_ids s)", "using assms"], ["proof (prove)\nusing this:\n  i < length s\n\ngoal (1 subgoal):\n 1. ext_ids s ! Suc i = \\<lbrakk>I (s ! i)\\<rbrakk> \\<and>\n    Suc i < length (ext_ids s)", "by (simp add:ext_ids_def nth_append)"], ["proof (state)\nthis:\n  ext_ids s ! Suc i = \\<lbrakk>I (s ! i)\\<rbrakk> \\<and>\n  Suc i < length (ext_ids s)\n\ngoal (1 subgoal):\n 1. idx s \\<lbrakk>I (s ! i)\\<rbrakk> = Inr (Suc i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ext_ids s ! Suc i = \\<lbrakk>I (s ! i)\\<rbrakk> \\<and>\n  Suc i < length (ext_ids s)\n\ngoal (1 subgoal):\n 1. idx s \\<lbrakk>I (s ! i)\\<rbrakk> = Inr (Suc i)", "using idx_intro_ext"], ["proof (prove)\nusing this:\n  ext_ids s ! Suc i = \\<lbrakk>I (s ! i)\\<rbrakk> \\<and>\n  Suc i < length (ext_ids s)\n  ?i < length (ext_ids s) \\<Longrightarrow> idx s (ext_ids s ! ?i) = Inr ?i\n\ngoal (1 subgoal):\n 1. idx s \\<lbrakk>I (s ! i)\\<rbrakk> = Inr (Suc i)", "by force"], ["proof (state)\nthis:\n  idx s \\<lbrakk>I (s ! i)\\<rbrakk> = Inr (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale integrate_insert_commute_insert = integrate_insert_commute +\n  fixes m\n  assumes consistent_assm: \"consistent (M \\<union> {Insert m})\"\n  assumes insert_assm: \"Insert m \\<notin> M\"\n  assumes a_conditions_assm_2: \n    \"a_conditions (insert_messages (M \\<union> {Insert m})) a\"\nbegin"], ["", "definition invariant where \n  \"invariant pm sm = (pm \\<in> set (ext_ids s) \\<and> sm \\<in> set (ext_ids s) \\<and>\n   subset (a pm, a sm) (a (P m), a (S m)) \\<and> \n   elem (a \\<lbrakk>I m\\<rbrakk>) (a pm, a sm))\""], ["", "fun is_concurrent where \n  \"is_concurrent pm sm x = (x \\<in> set s \\<and> \n   subset (a pm, a sm) (a (P x), a (S x)) \\<and> \n   elem (a \\<lbrakk>I x\\<rbrakk>) (a pm, a sm))\""], ["", "lemma no_id_collision: \"I m \\<notin> I ` insert_messages M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I m \\<notin> I ` insert_messages M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I m \\<notin> I ` insert_messages M", "have \"inj_on I (insert_messages (M \\<union> {Insert m}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on I (insert_messages (M \\<union> {Insert m}))", "using consistent_def consistent_assm"], ["proof (prove)\nusing this:\n  consistent ?M \\<equiv>\n  inj_on I (insert_messages ?M) \\<and>\n  \\<Union> (deps ` ?M) \\<subseteq> I ` insert_messages ?M \\<and>\n  wfP (depends_on (insert_messages ?M)) \\<and>\n  (\\<exists>a. a_conditions (insert_messages ?M) a)\n  consistent (M \\<union> {Insert m})\n\ngoal (1 subgoal):\n 1. inj_on I (insert_messages (M \\<union> {Insert m}))", "by fastforce"], ["proof (state)\nthis:\n  inj_on I (insert_messages (M \\<union> {Insert m}))\n\ngoal (1 subgoal):\n 1. I m \\<notin> I ` insert_messages M", "hence \"I m \\<in> I ` insert_messages M \\<longrightarrow> Insert m \\<in> M\""], ["proof (prove)\nusing this:\n  inj_on I (insert_messages (M \\<union> {Insert m}))\n\ngoal (1 subgoal):\n 1. I m \\<in> I ` insert_messages M \\<longrightarrow> Insert m \\<in> M", "by (simp add: image_iff inj_on_eq_iff insert_messages_def)"], ["proof (state)\nthis:\n  I m \\<in> I ` insert_messages M \\<longrightarrow> Insert m \\<in> M\n\ngoal (1 subgoal):\n 1. I m \\<notin> I ` insert_messages M", "thus ?thesis"], ["proof (prove)\nusing this:\n  I m \\<in> I ` insert_messages M \\<longrightarrow> Insert m \\<in> M\n\ngoal (1 subgoal):\n 1. I m \\<notin> I ` insert_messages M", "using insert_assm"], ["proof (prove)\nusing this:\n  I m \\<in> I ` insert_messages M \\<longrightarrow> Insert m \\<in> M\n  Insert m \\<notin> M\n\ngoal (1 subgoal):\n 1. I m \\<notin> I ` insert_messages M", "by blast"], ["proof (state)\nthis:\n  I m \\<notin> I ` insert_messages M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_deleted: \"to_woot_char m = to_woot_character M m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_woot_char m = to_woot_character M m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. to_woot_char m = to_woot_character M m", "have \"Delete (DeleteMessage (I m)) \\<notin> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Delete (DeleteMessage (I m)) \\<notin> M", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Delete (DeleteMessage (I m)) \\<in> M \\<Longrightarrow> False", "assume \"Delete (DeleteMessage (I m)) \\<in> M\""], ["proof (state)\nthis:\n  Delete (DeleteMessage (I m)) \\<in> M\n\ngoal (1 subgoal):\n 1. Delete (DeleteMessage (I m)) \\<in> M \\<Longrightarrow> False", "hence \"deps (Delete (DeleteMessage (I m))) \\<subseteq> I ` insert_messages M\""], ["proof (prove)\nusing this:\n  Delete (DeleteMessage (I m)) \\<in> M\n\ngoal (1 subgoal):\n 1. deps (Delete (DeleteMessage (I m))) \\<subseteq> I ` insert_messages M", "using consistent_assm associated_string_assm"], ["proof (prove)\nusing this:\n  Delete (DeleteMessage (I m)) \\<in> M\n  consistent (M \\<union> {Insert m})\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. deps (Delete (DeleteMessage (I m))) \\<subseteq> I ` insert_messages M", "apply (simp add:consistent_def is_associated_string_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Delete (DeleteMessage (I m)) \\<in> M;\n     inj_on I (insert_messages (insert (Insert m) M)) \\<and>\n     deps (Insert m)\n     \\<subseteq> I ` insert_messages (insert (Insert m) M) \\<and>\n     \\<Union> (deps ` M)\n     \\<subseteq> I ` insert_messages (insert (Insert m) M) \\<and>\n     wfP (depends_on (insert_messages (insert (Insert m) M))) \\<and>\n     Ex (a_conditions (insert_messages (insert (Insert m) M)));\n     inj_on I (insert_messages M) \\<and>\n     \\<Union> (deps ` M) \\<subseteq> I ` insert_messages M \\<and>\n     wfP (depends_on (insert_messages M)) \\<and>\n     Ex (a_conditions (insert_messages M)) \\<and>\n     set s = to_woot_character M ` insert_messages M \\<and>\n     (\\<forall>a.\n         a_conditions (insert_messages M) a \\<longrightarrow>\n         sorted_wrt (<) (map a (ext_ids s)))\\<rbrakk>\n    \\<Longrightarrow> I m \\<in> I ` insert_messages M", "using image_subset_iff"], ["proof (prove)\nusing this:\n  (?f ` ?A \\<subseteq> ?B) = (\\<forall>x\\<in>?A. ?f x \\<in> ?B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Delete (DeleteMessage (I m)) \\<in> M;\n     inj_on I (insert_messages (insert (Insert m) M)) \\<and>\n     deps (Insert m)\n     \\<subseteq> I ` insert_messages (insert (Insert m) M) \\<and>\n     \\<Union> (deps ` M)\n     \\<subseteq> I ` insert_messages (insert (Insert m) M) \\<and>\n     wfP (depends_on (insert_messages (insert (Insert m) M))) \\<and>\n     Ex (a_conditions (insert_messages (insert (Insert m) M)));\n     inj_on I (insert_messages M) \\<and>\n     \\<Union> (deps ` M) \\<subseteq> I ` insert_messages M \\<and>\n     wfP (depends_on (insert_messages M)) \\<and>\n     Ex (a_conditions (insert_messages M)) \\<and>\n     set s = to_woot_character M ` insert_messages M \\<and>\n     (\\<forall>a.\n         a_conditions (insert_messages M) a \\<longrightarrow>\n         sorted_wrt (<) (map a (ext_ids s)))\\<rbrakk>\n    \\<Longrightarrow> I m \\<in> I ` insert_messages M", "by fastforce"], ["proof (state)\nthis:\n  deps (Delete (DeleteMessage (I m))) \\<subseteq> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. Delete (DeleteMessage (I m)) \\<in> M \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  deps (Delete (DeleteMessage (I m))) \\<subseteq> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. False", "using no_id_collision"], ["proof (prove)\nusing this:\n  deps (Delete (DeleteMessage (I m))) \\<subseteq> I ` insert_messages M\n  I m \\<notin> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Delete (DeleteMessage (I m)) \\<notin> M\n\ngoal (1 subgoal):\n 1. to_woot_char m = to_woot_character M m", "thus \"to_woot_char m = to_woot_character M m\""], ["proof (prove)\nusing this:\n  Delete (DeleteMessage (I m)) \\<notin> M\n\ngoal (1 subgoal):\n 1. to_woot_char m = to_woot_character M m", "by (cases m, simp add:to_woot_character_def delete_maybe_def)"], ["proof (state)\nthis:\n  to_woot_char m = to_woot_character M m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invariant_imp_sorted:\n  assumes \"Suc l < length (ext_ids s)\"\n  assumes \"a(ext_ids s ! l) < a \\<lbrakk>I m\\<rbrakk> \\<and> a \\<lbrakk>I m\\<rbrakk> < a(ext_ids s ! (l+1))\"\n  shows \"sorted_wrt (<) (map a (ext_ids ((take l s)@to_woot_char m#drop l s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids (take l s @ to_woot_char m # drop l s)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids (take l s @ to_woot_char m # drop l s)))", "have \"l \\<le> length s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> length s", "using assms(1)"], ["proof (prove)\nusing this:\n  Suc l < length (ext_ids s)\n\ngoal (1 subgoal):\n 1. l \\<le> length s", "by (simp add:ext_ids_def)"], ["proof (state)\nthis:\n  l \\<le> length s\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids (take l s @ to_woot_char m # drop l s)))", "hence \"ext_ids (take l s@to_woot_char m#drop l s) = \n        (take (Suc l) (ext_ids s))@\\<lbrakk>I m\\<rbrakk>#(drop (Suc l) (ext_ids s))\""], ["proof (prove)\nusing this:\n  l \\<le> length s\n\ngoal (1 subgoal):\n 1. ext_ids (take l s @ to_woot_char m # drop l s) =\n    take (Suc l) (ext_ids s) @\n    \\<lbrakk>I m\\<rbrakk> # drop (Suc l) (ext_ids s)", "by (cases m, simp add:ext_ids_def take_map drop_map)"], ["proof (state)\nthis:\n  ext_ids (take l s @ to_woot_char m # drop l s) =\n  take (Suc l) (ext_ids s) @\n  \\<lbrakk>I m\\<rbrakk> # drop (Suc l) (ext_ids s)\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids (take l s @ to_woot_char m # drop l s)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ext_ids (take l s @ to_woot_char m # drop l s) =\n  take (Suc l) (ext_ids s) @\n  \\<lbrakk>I m\\<rbrakk> # drop (Suc l) (ext_ids s)\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids (take l s @ to_woot_char m # drop l s)))", "using assms associated_string_assm is_associated_string_def a_conditions_assm"], ["proof (prove)\nusing this:\n  ext_ids (take l s @ to_woot_char m # drop l s) =\n  take (Suc l) (ext_ids s) @\n  \\<lbrakk>I m\\<rbrakk> # drop (Suc l) (ext_ids s)\n  Suc l < length (ext_ids s)\n  a (ext_ids s ! l) < a \\<lbrakk>I m\\<rbrakk> \\<and>\n  a \\<lbrakk>I m\\<rbrakk> < a (ext_ids s ! (l + 1))\n  is_associated_string M s\n  is_associated_string ?M ?s \\<equiv>\n  consistent ?M \\<and>\n  set ?s = to_woot_character ?M ` insert_messages ?M \\<and>\n  (\\<forall>a.\n      a_conditions (insert_messages ?M) a \\<longrightarrow>\n      sorted_wrt (<) (map a (ext_ids ?s)))\n  a_conditions (insert_messages M) a\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids (take l s @ to_woot_char m # drop l s)))", "apply (simp flip:take_map drop_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ext_ids (take l s @ to_woot_char m # drop l s) =\n             take (Suc l) (ext_ids s) @\n             \\<lbrakk>I m\\<rbrakk> # drop (Suc l) (ext_ids s);\n     Suc l < length (ext_ids s);\n     a (ext_ids s ! l) < a \\<lbrakk>I m\\<rbrakk> \\<and>\n     a \\<lbrakk>I m\\<rbrakk> < a (ext_ids s ! Suc l);\n     is_associated_string M s;\n     \\<And>M s.\n        is_associated_string M s \\<equiv>\n        consistent M \\<and>\n        set s = to_woot_character M ` insert_messages M \\<and>\n        (\\<forall>a.\n            a_conditions (insert_messages M) a \\<longrightarrow>\n            sorted_wrt (<) (map a (ext_ids s)));\n     a_conditions (insert_messages M) a\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt (<)\n                       (take (Suc l) (map a (ext_ids s)) @\n                        a \\<lbrakk>I m\\<rbrakk> #\n                        drop (Suc l) (map a (ext_ids s)))", "by (rule insort, simp+, blast)"], ["proof (state)\nthis:\n  sorted_wrt (<) (map a (ext_ids (take l s @ to_woot_char m # drop l s)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_self_dep: \"\\<not> depends_on (insert_messages M \\<union> {m}) m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> depends_on (insert_messages M \\<union> {m}) m m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> depends_on (insert_messages M \\<union> {m}) m m", "have \"wfP (depends_on (insert_messages M \\<union> {m}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (depends_on (insert_messages M \\<union> {m}))", "using consistent_assm"], ["proof (prove)\nusing this:\n  consistent (M \\<union> {Insert m})\n\ngoal (1 subgoal):\n 1. wfP (depends_on (insert_messages M \\<union> {m}))", "apply (simp add:consistent_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on I (insert_messages (insert (Insert m) M)) \\<and>\n    deps (Insert m)\n    \\<subseteq> I ` insert_messages (insert (Insert m) M) \\<and>\n    \\<Union> (deps ` M)\n    \\<subseteq> I ` insert_messages (insert (Insert m) M) \\<and>\n    wfP (depends_on (insert_messages (insert (Insert m) M))) \\<and>\n    Ex (a_conditions\n         (insert_messages (insert (Insert m) M))) \\<Longrightarrow>\n    wfP (depends_on (insert m (insert_messages M)))", "by (metis Un_insert_right insert_insert_message sup_bot.right_neutral)"], ["proof (state)\nthis:\n  wfP (depends_on (insert_messages M \\<union> {m}))\n\ngoal (1 subgoal):\n 1. \\<not> depends_on (insert_messages M \\<union> {m}) m m", "thus ?thesis"], ["proof (prove)\nusing this:\n  wfP (depends_on (insert_messages M \\<union> {m}))\n\ngoal (1 subgoal):\n 1. \\<not> depends_on (insert_messages M \\<union> {m}) m m", "by (metis mem_Collect_eq wfP_eq_minimal)"], ["proof (state)\nthis:\n  \\<not> depends_on (insert_messages M \\<union> {m}) m m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pred_succ_order:\n  \"m' \\<in> (insert_messages M \\<union> {m}) \\<Longrightarrow> a(P m') < a \\<lbrakk>I m'\\<rbrakk> \\<and> a(S m') > a \\<lbrakk>I m'\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n    a (P m') < a \\<lbrakk>I m'\\<rbrakk> \\<and>\n    a \\<lbrakk>I m'\\<rbrakk> < a (S m')", "by (metis elem.simps is_interval.simps psi_elem a_conditions_def \n      a_conditions_assm_2 insert_insert_message)"], ["", "lemma find_dep:\n  assumes \"Insert m' \\<in> (M \\<union> {Insert m})\"\n  assumes \"i \\<in> deps (Insert m')\"\n  shows \"\\<lbrakk>i\\<rbrakk> \\<in> set (ext_ids s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i\\<rbrakk> \\<in> set (ext_ids s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i\\<rbrakk> \\<in> set (ext_ids s)", "have \"i \\<in> I ` insert_messages M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> I ` insert_messages M", "proof (cases \"m' = m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m' = m \\<Longrightarrow> i \\<in> I ` insert_messages M\n 2. m' \\<noteq> m \\<Longrightarrow> i \\<in> I ` insert_messages M", "case True"], ["proof (state)\nthis:\n  m' = m\n\ngoal (2 subgoals):\n 1. m' = m \\<Longrightarrow> i \\<in> I ` insert_messages M\n 2. m' \\<noteq> m \\<Longrightarrow> i \\<in> I ` insert_messages M", "hence \"i \\<in> I ` insert_messages (M \\<union> {Insert m})\""], ["proof (prove)\nusing this:\n  m' = m\n\ngoal (1 subgoal):\n 1. i \\<in> I ` insert_messages (M \\<union> {Insert m})", "using assms consistent_assm"], ["proof (prove)\nusing this:\n  m' = m\n  Insert m' \\<in> M \\<union> {Insert m}\n  i \\<in> deps (Insert m')\n  consistent (M \\<union> {Insert m})\n\ngoal (1 subgoal):\n 1. i \\<in> I ` insert_messages (M \\<union> {Insert m})", "by (simp add:consistent_def, blast)"], ["proof (state)\nthis:\n  i \\<in> I ` insert_messages (M \\<union> {Insert m})\n\ngoal (2 subgoals):\n 1. m' = m \\<Longrightarrow> i \\<in> I ` insert_messages M\n 2. m' \\<noteq> m \\<Longrightarrow> i \\<in> I ` insert_messages M", "moreover"], ["proof (state)\nthis:\n  i \\<in> I ` insert_messages (M \\<union> {Insert m})\n\ngoal (2 subgoals):\n 1. m' = m \\<Longrightarrow> i \\<in> I ` insert_messages M\n 2. m' \\<noteq> m \\<Longrightarrow> i \\<in> I ` insert_messages M", "have \"i \\<noteq> I m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> I m", "using assms True no_self_dep"], ["proof (prove)\nusing this:\n  Insert m' \\<in> M \\<union> {Insert m}\n  i \\<in> deps (Insert m')\n  m' = m\n  \\<not> depends_on (insert_messages M \\<union> {m}) m m\n\ngoal (1 subgoal):\n 1. i \\<noteq> I m", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> I m\n\ngoal (2 subgoals):\n 1. m' = m \\<Longrightarrow> i \\<in> I ` insert_messages M\n 2. m' \\<noteq> m \\<Longrightarrow> i \\<in> I ` insert_messages M", "ultimately"], ["proof (chain)\npicking this:\n  i \\<in> I ` insert_messages (M \\<union> {Insert m})\n  i \\<noteq> I m", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> I ` insert_messages (M \\<union> {Insert m})\n  i \\<noteq> I m\n\ngoal (1 subgoal):\n 1. i \\<in> I ` insert_messages M", "by (metis (no_types, lifting) UnE image_Un image_empty image_insert \n          insert_insert_message singletonD)"], ["proof (state)\nthis:\n  i \\<in> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. m' \\<noteq> m \\<Longrightarrow> i \\<in> I ` insert_messages M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m' \\<noteq> m \\<Longrightarrow> i \\<in> I ` insert_messages M", "case False"], ["proof (state)\nthis:\n  m' \\<noteq> m\n\ngoal (1 subgoal):\n 1. m' \\<noteq> m \\<Longrightarrow> i \\<in> I ` insert_messages M", "hence \"Insert m' \\<in> M\""], ["proof (prove)\nusing this:\n  m' \\<noteq> m\n\ngoal (1 subgoal):\n 1. Insert m' \\<in> M", "using assms"], ["proof (prove)\nusing this:\n  m' \\<noteq> m\n  Insert m' \\<in> M \\<union> {Insert m}\n  i \\<in> deps (Insert m')\n\ngoal (1 subgoal):\n 1. Insert m' \\<in> M", "by simp"], ["proof (state)\nthis:\n  Insert m' \\<in> M\n\ngoal (1 subgoal):\n 1. m' \\<noteq> m \\<Longrightarrow> i \\<in> I ` insert_messages M", "then"], ["proof (chain)\npicking this:\n  Insert m' \\<in> M", "show \"i \\<in> I ` insert_messages M\""], ["proof (prove)\nusing this:\n  Insert m' \\<in> M\n\ngoal (1 subgoal):\n 1. i \\<in> I ` insert_messages M", "using assms is_associated_string_def associated_string_assm consistent_def"], ["proof (prove)\nusing this:\n  Insert m' \\<in> M\n  Insert m' \\<in> M \\<union> {Insert m}\n  i \\<in> deps (Insert m')\n  is_associated_string ?M ?s \\<equiv>\n  consistent ?M \\<and>\n  set ?s = to_woot_character ?M ` insert_messages ?M \\<and>\n  (\\<forall>a.\n      a_conditions (insert_messages ?M) a \\<longrightarrow>\n      sorted_wrt (<) (map a (ext_ids ?s)))\n  is_associated_string M s\n  consistent ?M \\<equiv>\n  inj_on I (insert_messages ?M) \\<and>\n  \\<Union> (deps ` ?M) \\<subseteq> I ` insert_messages ?M \\<and>\n  wfP (depends_on (insert_messages ?M)) \\<and>\n  (\\<exists>a. a_conditions (insert_messages ?M) a)\n\ngoal (1 subgoal):\n 1. i \\<in> I ` insert_messages M", "by (metis (no_types, hide_lams) Union_iff contra_subsetD image_iff)"], ["proof (state)\nthis:\n  i \\<in> I ` insert_messages M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<in> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i\\<rbrakk> \\<in> set (ext_ids s)", "hence \"i \\<in> I ` (set s)\""], ["proof (prove)\nusing this:\n  i \\<in> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. i \\<in> I ` set s", "using associated_string_assm"], ["proof (prove)\nusing this:\n  i \\<in> I ` insert_messages M\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. i \\<in> I ` set s", "by (simp add:is_associated_string_def)"], ["proof (state)\nthis:\n  i \\<in> I ` set s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i\\<rbrakk> \\<in> set (ext_ids s)", "thus \"\\<lbrakk>i\\<rbrakk> \\<in> set (ext_ids s)\""], ["proof (prove)\nusing this:\n  i \\<in> I ` set s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i\\<rbrakk> \\<in> set (ext_ids s)", "by (simp add:ext_ids_def image_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>i\\<rbrakk> \\<in> set (ext_ids s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_pred:\n  \"m' \\<in> (insert_messages M \\<union> {m}) \\<Longrightarrow> P m' \\<in> set (ext_ids s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n    P m' \\<in> set (ext_ids s)", "using find_dep"], ["proof (prove)\nusing this:\n  \\<lbrakk>Insert ?m' \\<in> M \\<union> {Insert m};\n   ?i \\<in> deps (Insert ?m')\\<rbrakk>\n  \\<Longrightarrow> \\<lbrakk>?i\\<rbrakk> \\<in> set (ext_ids s)\n\ngoal (1 subgoal):\n 1. m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n    P m' \\<in> set (ext_ids s)", "by (cases \"P m'\", (simp add:ext_ids_def insert_messages_def pred_is_dep)+)"], ["", "lemma find_succ:\n  \"m' \\<in> (insert_messages M \\<union> {m}) \\<Longrightarrow> S m' \\<in> set (ext_ids s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n    S m' \\<in> set (ext_ids s)", "using find_dep"], ["proof (prove)\nusing this:\n  \\<lbrakk>Insert ?m' \\<in> M \\<union> {Insert m};\n   ?i \\<in> deps (Insert ?m')\\<rbrakk>\n  \\<Longrightarrow> \\<lbrakk>?i\\<rbrakk> \\<in> set (ext_ids s)\n\ngoal (1 subgoal):\n 1. m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n    S m' \\<in> set (ext_ids s)", "by (cases \"S m'\", (simp add:ext_ids_def insert_messages_def succ_is_dep)+)"], ["", "fun is_certified_associated_string' where\n  \"is_certified_associated_string' (Inr v) = (\n    set v = to_woot_character (M \\<union> {Insert m}) ` \n      (insert_messages (M \\<union> {Insert m})) \\<and>\n    sorted_wrt (<) (map a (ext_ids v)))\" |\n  \"is_certified_associated_string' (Inl _) = False\""], ["", "lemma integrate_insert_final_step:\n  assumes \"invariant pm sm\"\n  assumes \"idx s pm = Inr l\"\n  assumes \"idx s sm = Inr (Suc l)\" \n  shows \"is_certified_associated_string' (Inr (take l s@(to_woot_char m)#drop l s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "define t where \"t = (take l s@(to_woot_char m)#drop l s)\""], ["proof (state)\nthis:\n  t = take l s @ to_woot_char m # drop l s\n\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "hence \"set t = set s \\<union> {to_woot_char m}\""], ["proof (prove)\nusing this:\n  t = take l s @ to_woot_char m # drop l s\n\ngoal (1 subgoal):\n 1. set t = set s \\<union> {to_woot_char m}", "by (metis Un_insert_right append_take_drop_id list.simps(15) \n        set_append sup_bot.right_neutral)"], ["proof (state)\nthis:\n  set t = set s \\<union> {to_woot_char m}\n\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "hence \n    \"set t = to_woot_character M ` insert_messages M \\<union> {to_woot_character M m}\""], ["proof (prove)\nusing this:\n  set t = set s \\<union> {to_woot_char m}\n\ngoal (1 subgoal):\n 1. set t =\n    to_woot_character M ` insert_messages M \\<union> {to_woot_character M m}", "using not_deleted"], ["proof (prove)\nusing this:\n  set t = set s \\<union> {to_woot_char m}\n  to_woot_char m = to_woot_character M m\n\ngoal (1 subgoal):\n 1. set t =\n    to_woot_character M ` insert_messages M \\<union> {to_woot_character M m}", "by (metis associated_string_assm is_associated_string_def)"], ["proof (state)\nthis:\n  set t =\n  to_woot_character M ` insert_messages M \\<union> {to_woot_character M m}\n\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "hence \n    \"set t = to_woot_character (M \\<union> {Insert m}) ` insert_messages (M \\<union> {Insert m})\""], ["proof (prove)\nusing this:\n  set t =\n  to_woot_character M ` insert_messages M \\<union> {to_woot_character M m}\n\ngoal (1 subgoal):\n 1. set t =\n    to_woot_character (M \\<union> {Insert m}) `\n    insert_messages (M \\<union> {Insert m})", "apply (simp add: to_woot_character_insert_no_eff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set t =\n    insert (to_woot_character M m)\n     (to_woot_character M ` insert_messages M) \\<Longrightarrow>\n    insert (to_woot_character M m)\n     (to_woot_character M ` insert_messages M) =\n    to_woot_character M ` insert_messages (insert (Insert m) M)", "using insert_insert_message"], ["proof (prove)\nusing this:\n  insert_messages (?M \\<union> {Insert ?m}) =\n  insert_messages ?M \\<union> {?m}\n\ngoal (1 subgoal):\n 1. set t =\n    insert (to_woot_character M m)\n     (to_woot_character M ` insert_messages M) \\<Longrightarrow>\n    insert (to_woot_character M m)\n     (to_woot_character M ` insert_messages M) =\n    to_woot_character M ` insert_messages (insert (Insert m) M)", "by fastforce"], ["proof (state)\nthis:\n  set t =\n  to_woot_character (M \\<union> {Insert m}) `\n  insert_messages (M \\<union> {Insert m})\n\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "moreover"], ["proof (state)\nthis:\n  set t =\n  to_woot_character (M \\<union> {Insert m}) `\n  insert_messages (M \\<union> {Insert m})\n\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "have \"sorted_wrt (<) (map a (ext_ids t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids t))", "using assms invariant_imp_sorted"], ["proof (prove)\nusing this:\n  invariant pm sm\n  idx s pm = Inr l\n  idx s sm = Inr (Suc l)\n  \\<lbrakk>Suc ?l < length (ext_ids s);\n   a (ext_ids s ! ?l) < a \\<lbrakk>I m\\<rbrakk> \\<and>\n   a \\<lbrakk>I m\\<rbrakk> < a (ext_ids s ! (?l + 1))\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt (<)\n                     (map a\n                       (ext_ids (take ?l s @ to_woot_char m # drop ?l s)))\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids t))", "by (simp add:invariant_def fromSingleton_simp filt_simp t_def)"], ["proof (state)\nthis:\n  sorted_wrt (<) (map a (ext_ids t))\n\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "ultimately"], ["proof (chain)\npicking this:\n  set t =\n  to_woot_character (M \\<union> {Insert m}) `\n  insert_messages (M \\<union> {Insert m})\n  sorted_wrt (<) (map a (ext_ids t))", "show ?thesis"], ["proof (prove)\nusing this:\n  set t =\n  to_woot_character (M \\<union> {Insert m}) `\n  insert_messages (M \\<union> {Insert m})\n  sorted_wrt (<) (map a (ext_ids t))\n\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "using t_def associated_string_assm"], ["proof (prove)\nusing this:\n  set t =\n  to_woot_character (M \\<union> {Insert m}) `\n  insert_messages (M \\<union> {Insert m})\n  sorted_wrt (<) (map a (ext_ids t))\n  t = take l s @ to_woot_char m # drop l s\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "by (simp add:is_associated_string_def)"], ["proof (state)\nthis:\n  is_certified_associated_string'\n   (Inr (take l s @ to_woot_char m # drop l s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma concurrent_eff:\n  assumes \"idx s pm = Inr l\"\n  assumes \"idx s sm = Inr u\"\n  obtains d where \"mapM (concurrent s l u) (substr s l u) = Inr d \\<and> \n    set (concat d) = InString ` I ` {x. is_concurrent pm sm x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        mapM (concurrent s l u) (substr s l u) = Inr d \\<and>\n        set (concat d) =\n        InString ` I ` {x. is_concurrent pm sm x} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        mapM (concurrent s l u) (substr s l u) = Inr d \\<and>\n        set (concat d) =\n        InString ` I ` {x. is_concurrent pm sm x} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define t where \"t = substr s l u\""], ["proof (state)\nthis:\n  t = substr s l u\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        mapM (concurrent s l u) (substr s l u) = Inr d \\<and>\n        set (concat d) =\n        InString ` I ` {x. is_concurrent pm sm x} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"set t \\<subseteq> set s \\<Longrightarrow> (isOK (mapM (concurrent s l u) t) \\<and>\n    set (concat (projr (mapM (concurrent s l u) t))) = \n    InString ` I ` {x. x \\<in> set t \\<and> a (P x) \\<le> a pm \\<and> a (S x) \\<ge> a sm})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set t \\<subseteq> set s \\<Longrightarrow>\n    isOK (mapM (concurrent s l u) t) \\<and>\n    set (concat (projr (mapM (concurrent s l u) t))) =\n    InString `\n    I ` {x \\<in> set t. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set s \\<Longrightarrow>\n    isOK (mapM (concurrent s l u) []) \\<and>\n    set (concat (projr (mapM (concurrent s l u) []))) =\n    InString `\n    I ` {x \\<in> set []. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n 2. \\<And>aa t.\n       \\<lbrakk>set t \\<subseteq> set s \\<Longrightarrow>\n                isOK (mapM (concurrent s l u) t) \\<and>\n                set (concat (projr (mapM (concurrent s l u) t))) =\n                InString `\n                I `\n                {x \\<in> set t.\n                 a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)};\n        set (aa # t) \\<subseteq> set s\\<rbrakk>\n       \\<Longrightarrow> isOK (mapM (concurrent s l u) (aa # t)) \\<and>\n                         set (concat\n                               (projr (mapM (concurrent s l u) (aa # t)))) =\n                         InString `\n                         I `\n                         {x \\<in> set (aa # t).\n                          a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> set s\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set s \\<Longrightarrow>\n    isOK (mapM (concurrent s l u) []) \\<and>\n    set (concat (projr (mapM (concurrent s l u) []))) =\n    InString `\n    I ` {x \\<in> set []. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n 2. \\<And>aa t.\n       \\<lbrakk>set t \\<subseteq> set s \\<Longrightarrow>\n                isOK (mapM (concurrent s l u) t) \\<and>\n                set (concat (projr (mapM (concurrent s l u) t))) =\n                InString `\n                I `\n                {x \\<in> set t.\n                 a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)};\n        set (aa # t) \\<subseteq> set s\\<rbrakk>\n       \\<Longrightarrow> isOK (mapM (concurrent s l u) (aa # t)) \\<and>\n                         set (concat\n                               (projr (mapM (concurrent s l u) (aa # t)))) =\n                         InString `\n                         I `\n                         {x \\<in> set (aa # t).\n                          a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "then"], ["proof (chain)\npicking this:\n  set [] \\<subseteq> set s", "show ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> set s\n\ngoal (1 subgoal):\n 1. isOK (mapM (concurrent s l u) []) \\<and>\n    set (concat (projr (mapM (concurrent s l u) []))) =\n    InString `\n    I ` {x \\<in> set []. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "by simp"], ["proof (state)\nthis:\n  isOK (mapM (concurrent s l u) []) \\<and>\n  set (concat (projr (mapM (concurrent s l u) []))) =\n  InString `\n  I ` {x \\<in> set []. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n\ngoal (1 subgoal):\n 1. \\<And>aa t.\n       \\<lbrakk>set t \\<subseteq> set s \\<Longrightarrow>\n                isOK (mapM (concurrent s l u) t) \\<and>\n                set (concat (projr (mapM (concurrent s l u) t))) =\n                InString `\n                I `\n                {x \\<in> set t.\n                 a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)};\n        set (aa # t) \\<subseteq> set s\\<rbrakk>\n       \\<Longrightarrow> isOK (mapM (concurrent s l u) (aa # t)) \\<and>\n                         set (concat\n                               (projr (mapM (concurrent s l u) (aa # t)))) =\n                         InString `\n                         I `\n                         {x \\<in> set (aa # t).\n                          a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa t.\n       \\<lbrakk>set t \\<subseteq> set s \\<Longrightarrow>\n                isOK (mapM (concurrent s l u) t) \\<and>\n                set (concat (projr (mapM (concurrent s l u) t))) =\n                InString `\n                I `\n                {x \\<in> set t.\n                 a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)};\n        set (aa # t) \\<subseteq> set s\\<rbrakk>\n       \\<Longrightarrow> isOK (mapM (concurrent s l u) (aa # t)) \\<and>\n                         set (concat\n                               (projr (mapM (concurrent s l u) (aa # t)))) =\n                         InString `\n                         I `\n                         {x \\<in> set (aa # t).\n                          a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "case (Cons th tt)"], ["proof (state)\nthis:\n  set tt \\<subseteq> set s \\<Longrightarrow>\n  isOK (mapM (concurrent s l u) tt) \\<and>\n  set (concat (projr (mapM (concurrent s l u) tt))) =\n  InString `\n  I ` {x \\<in> set tt. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n  set (th # tt) \\<subseteq> set s\n\ngoal (1 subgoal):\n 1. \\<And>aa t.\n       \\<lbrakk>set t \\<subseteq> set s \\<Longrightarrow>\n                isOK (mapM (concurrent s l u) t) \\<and>\n                set (concat (projr (mapM (concurrent s l u) t))) =\n                InString `\n                I `\n                {x \\<in> set t.\n                 a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)};\n        set (aa # t) \\<subseteq> set s\\<rbrakk>\n       \\<Longrightarrow> isOK (mapM (concurrent s l u) (aa # t)) \\<and>\n                         set (concat\n                               (projr (mapM (concurrent s l u) (aa # t)))) =\n                         InString `\n                         I `\n                         {x \\<in> set (aa # t).\n                          a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "hence \"th \\<in> to_woot_character M ` insert_messages M\""], ["proof (prove)\nusing this:\n  set tt \\<subseteq> set s \\<Longrightarrow>\n  isOK (mapM (concurrent s l u) tt) \\<and>\n  set (concat (projr (mapM (concurrent s l u) tt))) =\n  InString `\n  I ` {x \\<in> set tt. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n  set (th # tt) \\<subseteq> set s\n\ngoal (1 subgoal):\n 1. th \\<in> to_woot_character M ` insert_messages M", "using associated_string_assm"], ["proof (prove)\nusing this:\n  set tt \\<subseteq> set s \\<Longrightarrow>\n  isOK (mapM (concurrent s l u) tt) \\<and>\n  set (concat (projr (mapM (concurrent s l u) tt))) =\n  InString `\n  I ` {x \\<in> set tt. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n  set (th # tt) \\<subseteq> set s\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. th \\<in> to_woot_character M ` insert_messages M", "by (simp add: is_associated_string_def)"], ["proof (state)\nthis:\n  th \\<in> to_woot_character M ` insert_messages M\n\ngoal (1 subgoal):\n 1. \\<And>aa t.\n       \\<lbrakk>set t \\<subseteq> set s \\<Longrightarrow>\n                isOK (mapM (concurrent s l u) t) \\<and>\n                set (concat (projr (mapM (concurrent s l u) t))) =\n                InString `\n                I `\n                {x \\<in> set t.\n                 a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)};\n        set (aa # t) \\<subseteq> set s\\<rbrakk>\n       \\<Longrightarrow> isOK (mapM (concurrent s l u) (aa # t)) \\<and>\n                         set (concat\n                               (projr (mapM (concurrent s l u) (aa # t)))) =\n                         InString `\n                         I `\n                         {x \\<in> set (aa # t).\n                          a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "then"], ["proof (chain)\npicking this:\n  th \\<in> to_woot_character M ` insert_messages M", "obtain th' where th'_def: \n      \"th' \\<in> insert_messages M \\<and> P th' = P th \\<and> S th' = S th\""], ["proof (prove)\nusing this:\n  th \\<in> to_woot_character M ` insert_messages M\n\ngoal (1 subgoal):\n 1. (\\<And>th'.\n        th' \\<in> insert_messages M \\<and>\n        P th' = P th \\<and> S th' = S th \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis image_iff to_woot_character_keeps_P to_woot_character_keeps_S)"], ["proof (state)\nthis:\n  th' \\<in> insert_messages M \\<and> P th' = P th \\<and> S th' = S th\n\ngoal (1 subgoal):\n 1. \\<And>aa t.\n       \\<lbrakk>set t \\<subseteq> set s \\<Longrightarrow>\n                isOK (mapM (concurrent s l u) t) \\<and>\n                set (concat (projr (mapM (concurrent s l u) t))) =\n                InString `\n                I `\n                {x \\<in> set t.\n                 a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)};\n        set (aa # t) \\<subseteq> set s\\<rbrakk>\n       \\<Longrightarrow> isOK (mapM (concurrent s l u) (aa # t)) \\<and>\n                         set (concat\n                               (projr (mapM (concurrent s l u) (aa # t)))) =\n                         InString `\n                         I `\n                         {x \\<in> set (aa # t).\n                          a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "obtain l' where l'_def: \"idx s (P th) = Inr l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        idx s (P th) = Inr l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using th'_def find_pred obtain_idx"], ["proof (prove)\nusing this:\n  th' \\<in> insert_messages M \\<and> P th' = P th \\<and> S th' = S th\n  ?m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n  P ?m' \\<in> set (ext_ids s)\n  ?x \\<in> set (ext_ids s) \\<Longrightarrow> \\<exists>i. idx s ?x = Inr i\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        idx s (P th) = Inr l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  idx s (P th) = Inr l'\n\ngoal (1 subgoal):\n 1. \\<And>aa t.\n       \\<lbrakk>set t \\<subseteq> set s \\<Longrightarrow>\n                isOK (mapM (concurrent s l u) t) \\<and>\n                set (concat (projr (mapM (concurrent s l u) t))) =\n                InString `\n                I `\n                {x \\<in> set t.\n                 a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)};\n        set (aa # t) \\<subseteq> set s\\<rbrakk>\n       \\<Longrightarrow> isOK (mapM (concurrent s l u) (aa # t)) \\<and>\n                         set (concat\n                               (projr (mapM (concurrent s l u) (aa # t)))) =\n                         InString `\n                         I `\n                         {x \\<in> set (aa # t).\n                          a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "obtain u' where u'_def: \"idx s (S th) = Inr u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        idx s (S th) = Inr u' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using th'_def find_succ obtain_idx"], ["proof (prove)\nusing this:\n  th' \\<in> insert_messages M \\<and> P th' = P th \\<and> S th' = S th\n  ?m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n  S ?m' \\<in> set (ext_ids s)\n  ?x \\<in> set (ext_ids s) \\<Longrightarrow> \\<exists>i. idx s ?x = Inr i\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        idx s (S th) = Inr u' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  idx s (S th) = Inr u'\n\ngoal (1 subgoal):\n 1. \\<And>aa t.\n       \\<lbrakk>set t \\<subseteq> set s \\<Longrightarrow>\n                isOK (mapM (concurrent s l u) t) \\<and>\n                set (concat (projr (mapM (concurrent s l u) t))) =\n                InString `\n                I `\n                {x \\<in> set t.\n                 a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)};\n        set (aa # t) \\<subseteq> set s\\<rbrakk>\n       \\<Longrightarrow> isOK (mapM (concurrent s l u) (aa # t)) \\<and>\n                         set (concat\n                               (projr (mapM (concurrent s l u) (aa # t)))) =\n                         InString `\n                         I `\n                         {x \\<in> set (aa # t).\n                          a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "have \"{x. x = \\<lbrakk>I th\\<rbrakk> \\<and> l' \\<le> l \\<and> u \\<le> u'} = \n      InString ` I ` {x. x = th \\<and> a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x = \\<lbrakk>I th\\<rbrakk> \\<and> l' \\<le> l \\<and> u \\<le> u'} =\n    InString `\n    I ` {x. x = th \\<and> a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "using sorted_a l'_def u'_def assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>idx s ?x = Inr ?l; idx s ?y = Inr ?u\\<rbrakk>\n  \\<Longrightarrow> (?l \\<le> ?u) = (a ?x \\<le> a ?y)\n  idx s (P th) = Inr l'\n  idx s (S th) = Inr u'\n  idx s pm = Inr l\n  idx s sm = Inr u\n\ngoal (1 subgoal):\n 1. {x. x = \\<lbrakk>I th\\<rbrakk> \\<and> l' \\<le> l \\<and> u \\<le> u'} =\n    InString `\n    I ` {x. x = th \\<and> a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "by (rule_tac set_eqI, simp add:image_iff, blast)"], ["proof (state)\nthis:\n  {x. x = \\<lbrakk>I th\\<rbrakk> \\<and> l' \\<le> l \\<and> u \\<le> u'} =\n  InString `\n  I ` {x. x = th \\<and> a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n\ngoal (1 subgoal):\n 1. \\<And>aa t.\n       \\<lbrakk>set t \\<subseteq> set s \\<Longrightarrow>\n                isOK (mapM (concurrent s l u) t) \\<and>\n                set (concat (projr (mapM (concurrent s l u) t))) =\n                InString `\n                I `\n                {x \\<in> set t.\n                 a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)};\n        set (aa # t) \\<subseteq> set s\\<rbrakk>\n       \\<Longrightarrow> isOK (mapM (concurrent s l u) (aa # t)) \\<and>\n                         set (concat\n                               (projr (mapM (concurrent s l u) (aa # t)))) =\n                         InString `\n                         I `\n                         {x \\<in> set (aa # t).\n                          a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "then"], ["proof (chain)\npicking this:\n  {x. x = \\<lbrakk>I th\\<rbrakk> \\<and> l' \\<le> l \\<and> u \\<le> u'} =\n  InString `\n  I ` {x. x = th \\<and> a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "show ?case"], ["proof (prove)\nusing this:\n  {x. x = \\<lbrakk>I th\\<rbrakk> \\<and> l' \\<le> l \\<and> u \\<le> u'} =\n  InString `\n  I ` {x. x = th \\<and> a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n\ngoal (1 subgoal):\n 1. isOK (mapM (concurrent s l u) (th # tt)) \\<and>\n    set (concat (projr (mapM (concurrent s l u) (th # tt)))) =\n    InString `\n    I `\n    {x \\<in> set (th # tt). a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "using Cons"], ["proof (prove)\nusing this:\n  {x. x = \\<lbrakk>I th\\<rbrakk> \\<and> l' \\<le> l \\<and> u \\<le> u'} =\n  InString `\n  I ` {x. x = th \\<and> a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n  set tt \\<subseteq> set s \\<Longrightarrow>\n  isOK (mapM (concurrent s l u) tt) \\<and>\n  set (concat (projr (mapM (concurrent s l u) tt))) =\n  InString `\n  I ` {x \\<in> set tt. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n  set (th # tt) \\<subseteq> set s\n\ngoal (1 subgoal):\n 1. isOK (mapM (concurrent s l u) (th # tt)) \\<and>\n    set (concat (projr (mapM (concurrent s l u) (th # tt)))) =\n    InString `\n    I `\n    {x \\<in> set (th # tt). a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}", "by (simp add:bind_simp l'_def u'_def \n          concurrent.simps[where w=th] del:idx.simps, auto)"], ["proof (state)\nthis:\n  isOK (mapM (concurrent s l u) (th # tt)) \\<and>\n  set (concat (projr (mapM (concurrent s l u) (th # tt)))) =\n  InString `\n  I ` {x \\<in> set (th # tt). a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set t \\<subseteq> set s \\<Longrightarrow>\n  isOK (mapM (concurrent s l u) t) \\<and>\n  set (concat (projr (mapM (concurrent s l u) t))) =\n  InString `\n  I ` {x \\<in> set t. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        mapM (concurrent s l u) (substr s l u) = Inr d \\<and>\n        set (concat d) =\n        InString ` I ` {x. is_concurrent pm sm x} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  set t \\<subseteq> set s \\<Longrightarrow>\n  isOK (mapM (concurrent s l u) t) \\<and>\n  set (concat (projr (mapM (concurrent s l u) t))) =\n  InString `\n  I ` {x \\<in> set t. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        mapM (concurrent s l u) (substr s l u) = Inr d \\<and>\n        set (concat d) =\n        InString ` I ` {x. is_concurrent pm sm x} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \n    \"\\<And>x. (x \\<in> set (substr s l u)) = (x \\<in> set s \\<and> a pm < a \\<lbrakk>I x\\<rbrakk> \\<and> a \\<lbrakk>I x\\<rbrakk> < a sm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (substr s l u)) =\n       (x \\<in> set s \\<and>\n        a pm < a \\<lbrakk>I x\\<rbrakk> \\<and>\n        a \\<lbrakk>I x\\<rbrakk> < a sm)", "apply (simp add:set_nths in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>i.\n           x = s ! i \\<and>\n           i < length s \\<and> l < Suc i \\<and> Suc i < u) =\n       ((\\<exists>i<length s. s ! i = x) \\<and>\n        a pm < a \\<lbrakk>I x\\<rbrakk> \\<and>\n        a \\<lbrakk>I x\\<rbrakk> < a sm)", "using sorted_a_le idx_intro assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>idx s ?x = Inr ?l; idx s ?y = Inr ?u\\<rbrakk>\n  \\<Longrightarrow> (?l < ?u) = (a ?x < a ?y)\n  ?i < length s \\<Longrightarrow>\n  idx s \\<lbrakk>I (s ! ?i)\\<rbrakk> = Inr (Suc ?i)\n  idx s pm = Inr l\n  idx s sm = Inr u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>i.\n           x = s ! i \\<and>\n           i < length s \\<and> l < Suc i \\<and> Suc i < u) =\n       ((\\<exists>i<length s. s ! i = x) \\<and>\n        a pm < a \\<lbrakk>I x\\<rbrakk> \\<and>\n        a \\<lbrakk>I x\\<rbrakk> < a sm)", "by blast"], ["proof (state)\nthis:\n  (?x5 \\<in> set (substr s l u)) =\n  (?x5 \\<in> set s \\<and>\n   a pm < a \\<lbrakk>I ?x5\\<rbrakk> \\<and> a \\<lbrakk>I ?x5\\<rbrakk> < a sm)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        mapM (concurrent s l u) (substr s l u) = Inr d \\<and>\n        set (concat d) =\n        InString ` I ` {x. is_concurrent pm sm x} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  set t \\<subseteq> set s \\<Longrightarrow>\n  isOK (mapM (concurrent s l u) t) \\<and>\n  set (concat (projr (mapM (concurrent s l u) t))) =\n  InString `\n  I ` {x \\<in> set t. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n  (?x5 \\<in> set (substr s l u)) =\n  (?x5 \\<in> set s \\<and>\n   a pm < a \\<lbrakk>I ?x5\\<rbrakk> \\<and> a \\<lbrakk>I ?x5\\<rbrakk> < a sm)", "have \"\n    isOK (mapM (concurrent s l u) (substr s l u)) \\<and> \n    set (concat (projr (mapM (concurrent s l u) (substr s l u)))) = \n      InString ` I ` {x. is_concurrent pm sm x}\""], ["proof (prove)\nusing this:\n  set t \\<subseteq> set s \\<Longrightarrow>\n  isOK (mapM (concurrent s l u) t) \\<and>\n  set (concat (projr (mapM (concurrent s l u) t))) =\n  InString `\n  I ` {x \\<in> set t. a (P x) \\<le> a pm \\<and> a sm \\<le> a (S x)}\n  (?x5 \\<in> set (substr s l u)) =\n  (?x5 \\<in> set s \\<and>\n   a pm < a \\<lbrakk>I ?x5\\<rbrakk> \\<and> a \\<lbrakk>I ?x5\\<rbrakk> < a sm)\n\ngoal (1 subgoal):\n 1. isOK (mapM (concurrent s l u) (substr s l u)) \\<and>\n    set (concat (projr (mapM (concurrent s l u) (substr s l u)))) =\n    InString ` I ` {x. is_concurrent pm sm x}", "by (simp only:t_def, fastforce)"], ["proof (state)\nthis:\n  isOK (mapM (concurrent s l u) (substr s l u)) \\<and>\n  set (concat (projr (mapM (concurrent s l u) (substr s l u)))) =\n  InString ` I ` {x. is_concurrent pm sm x}\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        mapM (concurrent s l u) (substr s l u) = Inr d \\<and>\n        set (concat d) =\n        InString ` I ` {x. is_concurrent pm sm x} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  isOK (mapM (concurrent s l u) (substr s l u)) \\<and>\n  set (concat (projr (mapM (concurrent s l u) (substr s l u)))) =\n  InString ` I ` {x. is_concurrent pm sm x}\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  isOK (mapM (concurrent s l u) (substr s l u)) \\<and>\n  set (concat (projr (mapM (concurrent s l u) (substr s l u)))) =\n  InString ` I ` {x. is_concurrent pm sm x}\n  mapM (concurrent s l u) (substr s l u) = Inr ?d5 \\<and>\n  set (concat ?d5) =\n  InString ` I ` {x. is_concurrent pm sm x} \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma concurrent_eff_2:\n  assumes \"invariant pm sm\" \n  assumes \"is_concurrent pm sm x\"\n  shows \"preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk> (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n     (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n     (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)", "have \"x \\<in> to_woot_character M ` insert_messages M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> to_woot_character M ` insert_messages M", "using assms(2) associated_string_assm is_associated_string_def \n      is_concurrent.elims(2)"], ["proof (prove)\nusing this:\n  is_concurrent pm sm x\n  is_associated_string M s\n  is_associated_string ?M ?s \\<equiv>\n  consistent ?M \\<and>\n  set ?s = to_woot_character ?M ` insert_messages ?M \\<and>\n  (\\<forall>a.\n      a_conditions (insert_messages ?M) a \\<longrightarrow>\n      sorted_wrt (<) (map a (ext_ids ?s)))\n  \\<lbrakk>is_concurrent ?x ?xa ?xb;\n   \\<And>pm sm x.\n      \\<lbrakk>?x = pm; ?xa = sm; ?xb = x;\n       x \\<in> set s \\<and>\n       Psi.subset (a pm, a sm) (a (P x), a (S x)) \\<and>\n       elem (a \\<lbrakk>I x\\<rbrakk>) (a pm, a sm)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. x \\<in> to_woot_character M ` insert_messages M", "by blast"], ["proof (state)\nthis:\n  x \\<in> to_woot_character M ` insert_messages M\n\ngoal (1 subgoal):\n 1. preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n     (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)", "then"], ["proof (chain)\npicking this:\n  x \\<in> to_woot_character M ` insert_messages M", "obtain x' where x'_def: \"I x = I x' \\<and> P x = P x' \\<and> S x = S x' \\<and> x' \\<in> insert_messages M\""], ["proof (prove)\nusing this:\n  x \\<in> to_woot_character M ` insert_messages M\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        I x = I x' \\<and>\n        P x = P x' \\<and>\n        S x = S x' \\<and> x' \\<in> insert_messages M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using to_woot_character_keeps_P to_woot_character_keeps_S \n      to_woot_character_keeps_i"], ["proof (prove)\nusing this:\n  x \\<in> to_woot_character M ` insert_messages M\n  P (to_woot_character ?M ?m) = P ?m\n  S (to_woot_character ?M ?m) = S ?m\n  I (to_woot_character ?M ?m) = I ?m\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        I x = I x' \\<and>\n        P x = P x' \\<and>\n        S x = S x' \\<and> x' \\<in> insert_messages M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  I x = I x' \\<and>\n  P x = P x' \\<and> S x = S x' \\<and> x' \\<in> insert_messages M\n\ngoal (1 subgoal):\n 1. preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n     (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)", "have \"elem (a \\<lbrakk>I x\\<rbrakk>) (a (P m), a (S m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem (a \\<lbrakk>I x\\<rbrakk>) (a (P m), a (S m))", "using assms"], ["proof (prove)\nusing this:\n  invariant pm sm\n  is_concurrent pm sm x\n\ngoal (1 subgoal):\n 1. elem (a \\<lbrakk>I x\\<rbrakk>) (a (P m), a (S m))", "by (simp add: invariant_def, auto)"], ["proof (state)\nthis:\n  elem (a \\<lbrakk>I x\\<rbrakk>) (a (P m), a (S m))\n\ngoal (1 subgoal):\n 1. preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n     (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)", "moreover"], ["proof (state)\nthis:\n  elem (a \\<lbrakk>I x\\<rbrakk>) (a (P m), a (S m))\n\ngoal (1 subgoal):\n 1. preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n     (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)", "have \"elem (a \\<lbrakk>I m\\<rbrakk>) (a (P x), a (S x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem (a \\<lbrakk>I m\\<rbrakk>) (a (P x), a (S x))", "using assms"], ["proof (prove)\nusing this:\n  invariant pm sm\n  is_concurrent pm sm x\n\ngoal (1 subgoal):\n 1. elem (a \\<lbrakk>I m\\<rbrakk>) (a (P x), a (S x))", "by (simp add: invariant_def, auto)"], ["proof (state)\nthis:\n  elem (a \\<lbrakk>I m\\<rbrakk>) (a (P x), a (S x))\n\ngoal (1 subgoal):\n 1. preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n     (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)", "moreover"], ["proof (state)\nthis:\n  elem (a \\<lbrakk>I m\\<rbrakk>) (a (P x), a (S x))\n\ngoal (1 subgoal):\n 1. preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n     (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)", "have \"a_conditions (insert_messages M \\<union> {m}) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a_conditions (insert_messages M \\<union> {m}) a", "by (metis insert_insert_message a_conditions_assm_2)"], ["proof (state)\nthis:\n  a_conditions (insert_messages M \\<union> {m}) a\n\ngoal (1 subgoal):\n 1. preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n     (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)", "ultimately"], ["proof (chain)\npicking this:\n  elem (a \\<lbrakk>I x\\<rbrakk>) (a (P m), a (S m))\n  elem (a \\<lbrakk>I m\\<rbrakk>) (a (P x), a (S x))\n  a_conditions (insert_messages M \\<union> {m}) a", "have \"preserve_order (I x) (I m) (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)\""], ["proof (prove)\nusing this:\n  elem (a \\<lbrakk>I x\\<rbrakk>) (a (P m), a (S m))\n  elem (a \\<lbrakk>I m\\<rbrakk>) (a (P x), a (S x))\n  a_conditions (insert_messages M \\<union> {m}) a\n\ngoal (1 subgoal):\n 1. preserve_order (I x) (I m) (a \\<lbrakk>I x\\<rbrakk>)\n     (a \\<lbrakk>I m\\<rbrakk>)", "by (simp add: a_conditions_def psi_preserve_order x'_def)"], ["proof (state)\nthis:\n  preserve_order (I x) (I m) (a \\<lbrakk>I x\\<rbrakk>)\n   (a \\<lbrakk>I m\\<rbrakk>)\n\ngoal (1 subgoal):\n 1. preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n     (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  preserve_order (I x) (I m) (a \\<lbrakk>I x\\<rbrakk>)\n   (a \\<lbrakk>I m\\<rbrakk>)\n\ngoal (1 subgoal):\n 1. preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n     (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)", "by (simp add: preserve_order_def)"], ["proof (state)\nthis:\n  preserve_order \\<lbrakk>I x\\<rbrakk> \\<lbrakk>I m\\<rbrakk>\n   (a \\<lbrakk>I x\\<rbrakk>) (a \\<lbrakk>I m\\<rbrakk>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma concurrent_eff_3:\n  assumes \"idx s pm = Inr l\"\n  assumes \"idx s sm = Inr u\"\n  assumes \"Suc l < u\"\n  shows \"{x. is_concurrent pm sm x} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "define H where\n    \"H = {x. x \\<in> insert_messages M \\<and> a pm < a \\<lbrakk>I x\\<rbrakk> \\<and> a \\<lbrakk>I x\\<rbrakk> < a sm}\""], ["proof (state)\nthis:\n  H =\n  {x \\<in> insert_messages M.\n   a pm < a \\<lbrakk>I x\\<rbrakk> \\<and> a \\<lbrakk>I x\\<rbrakk> < a sm}\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "have \"wfP (depends_on (insert_messages M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (depends_on (insert_messages M))", "using associated_string_assm"], ["proof (prove)\nusing this:\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. wfP (depends_on (insert_messages M))", "by (simp add: consistent_def is_associated_string_def)"], ["proof (state)\nthis:\n  wfP (depends_on (insert_messages M))\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  wfP (depends_on (insert_messages M))\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "have f:\"H \\<subseteq> insert_messages M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<subseteq> insert_messages M", "using H_def"], ["proof (prove)\nusing this:\n  H =\n  {x \\<in> insert_messages M.\n   a pm < a \\<lbrakk>I x\\<rbrakk> \\<and> a \\<lbrakk>I x\\<rbrakk> < a sm}\n\ngoal (1 subgoal):\n 1. H \\<subseteq> insert_messages M", "by blast"], ["proof (state)\nthis:\n  H \\<subseteq> insert_messages M\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "hence \"depends_on H \\<le> depends_on (insert_messages M)\""], ["proof (prove)\nusing this:\n  H \\<subseteq> insert_messages M\n\ngoal (1 subgoal):\n 1. depends_on H \\<le> depends_on (insert_messages M)", "by auto"], ["proof (state)\nthis:\n  depends_on H \\<le> depends_on (insert_messages M)\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  wfP (depends_on (insert_messages M))\n  depends_on H \\<le> depends_on (insert_messages M)", "have \"wfP (depends_on H)\""], ["proof (prove)\nusing this:\n  wfP (depends_on (insert_messages M))\n  depends_on H \\<le> depends_on (insert_messages M)\n\ngoal (1 subgoal):\n 1. wfP (depends_on H)", "using wf_subset [to_pred]"], ["proof (prove)\nusing this:\n  wfP (depends_on (insert_messages M))\n  depends_on H \\<le> depends_on (insert_messages M)\n  \\<lbrakk>wfP ?r; ?p \\<le> ?r\\<rbrakk> \\<Longrightarrow> wfP ?p\n\ngoal (1 subgoal):\n 1. wfP (depends_on H)", "by blast"], ["proof (state)\nthis:\n  wfP (depends_on H)\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  wfP (depends_on H)\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "have u: \"l < length s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < length s", "using assms(2) assms(3)"], ["proof (prove)\nusing this:\n  idx s sm = Inr u\n  Suc l < u\n\ngoal (1 subgoal):\n 1. l < length s", "by (simp add:fromSingleton_simp filt_simp, simp add:ext_ids_def)"], ["proof (state)\nthis:\n  l < length s\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "hence v:\"a pm < a \\<lbrakk>I(s ! l)\\<rbrakk> \\<and> a \\<lbrakk>I(s ! l)\\<rbrakk> < a sm\""], ["proof (prove)\nusing this:\n  l < length s\n\ngoal (1 subgoal):\n 1. a pm < a \\<lbrakk>I (s ! l)\\<rbrakk> \\<and>\n    a \\<lbrakk>I (s ! l)\\<rbrakk> < a sm", "using sorted_a_le assms u idx_intro"], ["proof (prove)\nusing this:\n  l < length s\n  \\<lbrakk>idx s ?x = Inr ?l; idx s ?y = Inr ?u\\<rbrakk>\n  \\<Longrightarrow> (?l < ?u) = (a ?x < a ?y)\n  idx s pm = Inr l\n  idx s sm = Inr u\n  Suc l < u\n  l < length s\n  ?i < length s \\<Longrightarrow>\n  idx s \\<lbrakk>I (s ! ?i)\\<rbrakk> = Inr (Suc ?i)\n\ngoal (1 subgoal):\n 1. a pm < a \\<lbrakk>I (s ! l)\\<rbrakk> \\<and>\n    a \\<lbrakk>I (s ! l)\\<rbrakk> < a sm", "by blast"], ["proof (state)\nthis:\n  a pm < a \\<lbrakk>I (s ! l)\\<rbrakk> \\<and>\n  a \\<lbrakk>I (s ! l)\\<rbrakk> < a sm\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "have \"I (s ! l) \\<in> I ` insert_messages M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (s ! l) \\<in> I ` insert_messages M", "by (metis image_eqI associated_string_assm is_associated_string_def nth_mem \n        to_woot_character_keeps_i_lifted u)"], ["proof (state)\nthis:\n  I (s ! l) \\<in> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "hence \"\\<exists>x. x \\<in> H\""], ["proof (prove)\nusing this:\n  I (s ! l) \\<in> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> H", "using v H_def"], ["proof (prove)\nusing this:\n  I (s ! l) \\<in> I ` insert_messages M\n  a pm < a \\<lbrakk>I (s ! l)\\<rbrakk> \\<and>\n  a \\<lbrakk>I (s ! l)\\<rbrakk> < a sm\n  H =\n  {x \\<in> insert_messages M.\n   a pm < a \\<lbrakk>I x\\<rbrakk> \\<and> a \\<lbrakk>I x\\<rbrakk> < a sm}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> H", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> H\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  wfP (depends_on H)\n  \\<exists>x. x \\<in> H", "obtain z where z_def: \"z \\<in> H\" \"\\<And> y. depends_on H y z \\<Longrightarrow> y \\<notin> H\""], ["proof (prove)\nusing this:\n  wfP (depends_on H)\n  \\<exists>x. x \\<in> H\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> H;\n         \\<And>y. depends_on H y z \\<Longrightarrow> y \\<notin> H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis wfP_eq_minimal)"], ["proof (state)\nthis:\n  z \\<in> H\n  depends_on H ?y5 z \\<Longrightarrow> ?y5 \\<notin> H\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "have a:\"\\<And>x. x \\<in> deps (Insert z) \\<Longrightarrow> \\<not>(a pm < a \\<lbrakk>x\\<rbrakk> \\<and> a \\<lbrakk>x\\<rbrakk> < a sm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> deps (Insert z) \\<Longrightarrow>\n       \\<not> (a pm < a \\<lbrakk>x\\<rbrakk> \\<and>\n               a \\<lbrakk>x\\<rbrakk> < a sm)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> deps (Insert z) \\<Longrightarrow>\n       \\<not> (a pm < a \\<lbrakk>x\\<rbrakk> \\<and>\n               a \\<lbrakk>x\\<rbrakk> < a sm)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> deps (Insert z) \\<Longrightarrow>\n       \\<not> (a pm < a \\<lbrakk>x\\<rbrakk> \\<and>\n               a \\<lbrakk>x\\<rbrakk> < a sm)", "assume a:\"x \\<in> deps (Insert z)\""], ["proof (state)\nthis:\n  x \\<in> deps (Insert z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> deps (Insert z) \\<Longrightarrow>\n       \\<not> (a pm < a \\<lbrakk>x\\<rbrakk> \\<and>\n               a \\<lbrakk>x\\<rbrakk> < a sm)", "hence \"x \\<in> I ` insert_messages M\""], ["proof (prove)\nusing this:\n  x \\<in> deps (Insert z)\n\ngoal (1 subgoal):\n 1. x \\<in> I ` insert_messages M", "using insert_messages_def associated_string_assm"], ["proof (prove)\nusing this:\n  x \\<in> deps (Insert z)\n  insert_messages ?M = {x. Insert x \\<in> ?M}\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. x \\<in> I ` insert_messages M", "apply (simp add:consistent_def is_associated_string_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> deps (Insert z);\n     \\<And>M. insert_messages M = {x. Insert x \\<in> M};\n     inj_on I (insert_messages M) \\<and>\n     \\<Union> (deps ` M) \\<subseteq> I ` insert_messages M \\<and>\n     wfP (depends_on (insert_messages M)) \\<and>\n     Ex (a_conditions (insert_messages M)) \\<and>\n     set s = to_woot_character M ` insert_messages M \\<and>\n     (\\<forall>a.\n         a_conditions (insert_messages M) a \\<longrightarrow>\n         sorted_wrt (<) (map a (ext_ids s)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> I ` insert_messages M", "using H_def z_def(1)"], ["proof (prove)\nusing this:\n  H =\n  {x \\<in> insert_messages M.\n   a pm < a \\<lbrakk>I x\\<rbrakk> \\<and> a \\<lbrakk>I x\\<rbrakk> < a sm}\n  z \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> deps (Insert z);\n     \\<And>M. insert_messages M = {x. Insert x \\<in> M};\n     inj_on I (insert_messages M) \\<and>\n     \\<Union> (deps ` M) \\<subseteq> I ` insert_messages M \\<and>\n     wfP (depends_on (insert_messages M)) \\<and>\n     Ex (a_conditions (insert_messages M)) \\<and>\n     set s = to_woot_character M ` insert_messages M \\<and>\n     (\\<forall>a.\n         a_conditions (insert_messages M) a \\<longrightarrow>\n         sorted_wrt (<) (map a (ext_ids s)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> I ` insert_messages M", "by blast"], ["proof (state)\nthis:\n  x \\<in> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> deps (Insert z) \\<Longrightarrow>\n       \\<not> (a pm < a \\<lbrakk>x\\<rbrakk> \\<and>\n               a \\<lbrakk>x\\<rbrakk> < a sm)", "then"], ["proof (chain)\npicking this:\n  x \\<in> I ` insert_messages M", "obtain x' where x'_def: \"x' \\<in> insert_messages M \\<and> x = I x'\""], ["proof (prove)\nusing this:\n  x \\<in> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        x' \\<in> insert_messages M \\<and> x = I x' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x' \\<in> insert_messages M \\<and> x = I x'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> deps (Insert z) \\<Longrightarrow>\n       \\<not> (a pm < a \\<lbrakk>x\\<rbrakk> \\<and>\n               a \\<lbrakk>x\\<rbrakk> < a sm)", "hence \"x' \\<notin> H\""], ["proof (prove)\nusing this:\n  x' \\<in> insert_messages M \\<and> x = I x'\n\ngoal (1 subgoal):\n 1. x' \\<notin> H", "using z_def"], ["proof (prove)\nusing this:\n  x' \\<in> insert_messages M \\<and> x = I x'\n  z \\<in> H\n  depends_on H ?y5 z \\<Longrightarrow> ?y5 \\<notin> H\n\ngoal (1 subgoal):\n 1. x' \\<notin> H", "using a depends_on.simps"], ["proof (prove)\nusing this:\n  x' \\<in> insert_messages M \\<and> x = I x'\n  z \\<in> H\n  depends_on H ?y5 z \\<Longrightarrow> ?y5 \\<notin> H\n  x \\<in> deps (Insert z)\n  depends_on ?M ?x ?y =\n  (?x \\<in> ?M \\<and> ?y \\<in> ?M \\<and> I ?x \\<in> deps (Insert ?y))\n\ngoal (1 subgoal):\n 1. x' \\<notin> H", "by blast"], ["proof (state)\nthis:\n  x' \\<notin> H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> deps (Insert z) \\<Longrightarrow>\n       \\<not> (a pm < a \\<lbrakk>x\\<rbrakk> \\<and>\n               a \\<lbrakk>x\\<rbrakk> < a sm)", "thus \"\\<not>(a pm < a \\<lbrakk>x\\<rbrakk> \\<and> a \\<lbrakk>x\\<rbrakk> < a sm)\""], ["proof (prove)\nusing this:\n  x' \\<notin> H\n\ngoal (1 subgoal):\n 1. \\<not> (a pm < a \\<lbrakk>x\\<rbrakk> \\<and>\n            a \\<lbrakk>x\\<rbrakk> < a sm)", "using H_def x'_def"], ["proof (prove)\nusing this:\n  x' \\<notin> H\n  H =\n  {x \\<in> insert_messages M.\n   a pm < a \\<lbrakk>I x\\<rbrakk> \\<and> a \\<lbrakk>I x\\<rbrakk> < a sm}\n  x' \\<in> insert_messages M \\<and> x = I x'\n\ngoal (1 subgoal):\n 1. \\<not> (a pm < a \\<lbrakk>x\\<rbrakk> \\<and>\n            a \\<lbrakk>x\\<rbrakk> < a sm)", "by blast"], ["proof (state)\nthis:\n  \\<not> (a pm < a \\<lbrakk>x\\<rbrakk> \\<and> a \\<lbrakk>x\\<rbrakk> < a sm)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x5 \\<in> deps (Insert z) \\<Longrightarrow>\n  \\<not> (a pm < a \\<lbrakk>?x5\\<rbrakk> \\<and>\n          a \\<lbrakk>?x5\\<rbrakk> < a sm)\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "have \"ext_ids s ! 0 = \\<turnstile> \\<and> 0 < length (ext_ids s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ext_ids s ! 0 = \\<turnstile> \\<and> 0 < length (ext_ids s)", "by (simp add:ext_ids_def)"], ["proof (state)\nthis:\n  ext_ids s ! 0 = \\<turnstile> \\<and> 0 < length (ext_ids s)\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "hence b:\"\\<not>(a pm < a \\<turnstile>)\""], ["proof (prove)\nusing this:\n  ext_ids s ! 0 = \\<turnstile> \\<and> 0 < length (ext_ids s)\n\ngoal (1 subgoal):\n 1. \\<not> a pm < a \\<turnstile>", "by (metis not_less_zero  sorted_a_le assms(1) idx_intro_ext)"], ["proof (state)\nthis:\n  \\<not> a pm < a \\<turnstile>\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "have \"ext_ids s ! (Suc (length s)) = \\<stileturn> \\<and> Suc (length s) < length (ext_ids s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ext_ids s ! Suc (length s) = \\<stileturn> \\<and>\n    Suc (length s) < length (ext_ids s)", "by (simp add:nth_append ext_ids_def)"], ["proof (state)\nthis:\n  ext_ids s ! Suc (length s) = \\<stileturn> \\<and>\n  Suc (length s) < length (ext_ids s)\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  ext_ids s ! Suc (length s) = \\<stileturn> \\<and>\n  Suc (length s) < length (ext_ids s)\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "have \"\\<not>(Suc (length s) < u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Suc (length s) < u", "using assms(2)"], ["proof (prove)\nusing this:\n  idx s sm = Inr u\n\ngoal (1 subgoal):\n 1. \\<not> Suc (length s) < u", "by (simp add:fromSingleton_simp filt_simp, simp add:ext_ids_def)"], ["proof (state)\nthis:\n  \\<not> Suc (length s) < u\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  ext_ids s ! Suc (length s) = \\<stileturn> \\<and>\n  Suc (length s) < length (ext_ids s)\n  \\<not> Suc (length s) < u", "have c:\"\\<not>(a \\<stileturn> < a sm)\""], ["proof (prove)\nusing this:\n  ext_ids s ! Suc (length s) = \\<stileturn> \\<and>\n  Suc (length s) < length (ext_ids s)\n  \\<not> Suc (length s) < u\n\ngoal (1 subgoal):\n 1. \\<not> a \\<stileturn> < a sm", "by (metis sorted_a_le assms(2) idx_intro_ext)"], ["proof (state)\nthis:\n  \\<not> a \\<stileturn> < a sm\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "have d:\"a (P z) \\<le> a pm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (P z) \\<le> a pm", "using a b c pred_is_dep pred_succ_order H_def z_def(1)"], ["proof (prove)\nusing this:\n  ?x5 \\<in> deps (Insert z) \\<Longrightarrow>\n  \\<not> (a pm < a \\<lbrakk>?x5\\<rbrakk> \\<and>\n          a \\<lbrakk>?x5\\<rbrakk> < a sm)\n  \\<not> a pm < a \\<turnstile>\n  \\<not> a \\<stileturn> < a sm\n  P ?m = \\<lbrakk>?i\\<rbrakk> \\<longrightarrow> ?i \\<in> deps (Insert ?m)\n  ?m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n  a (P ?m') < a \\<lbrakk>I ?m'\\<rbrakk> \\<and>\n  a \\<lbrakk>I ?m'\\<rbrakk> < a (S ?m')\n  H =\n  {x \\<in> insert_messages M.\n   a pm < a \\<lbrakk>I x\\<rbrakk> \\<and> a \\<lbrakk>I x\\<rbrakk> < a sm}\n  z \\<in> H\n\ngoal (1 subgoal):\n 1. a (P z) \\<le> a pm", "by (cases \"P z\", fastforce+)"], ["proof (state)\nthis:\n  a (P z) \\<le> a pm\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "have e:\"a (S z) \\<ge> a sm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a sm \\<le> a (S z)", "using a b c succ_is_dep pred_succ_order H_def z_def(1)"], ["proof (prove)\nusing this:\n  ?x5 \\<in> deps (Insert z) \\<Longrightarrow>\n  \\<not> (a pm < a \\<lbrakk>?x5\\<rbrakk> \\<and>\n          a \\<lbrakk>?x5\\<rbrakk> < a sm)\n  \\<not> a pm < a \\<turnstile>\n  \\<not> a \\<stileturn> < a sm\n  S ?m = \\<lbrakk>?i\\<rbrakk> \\<longrightarrow> ?i \\<in> deps (Insert ?m)\n  ?m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n  a (P ?m') < a \\<lbrakk>I ?m'\\<rbrakk> \\<and>\n  a \\<lbrakk>I ?m'\\<rbrakk> < a (S ?m')\n  H =\n  {x \\<in> insert_messages M.\n   a pm < a \\<lbrakk>I x\\<rbrakk> \\<and> a \\<lbrakk>I x\\<rbrakk> < a sm}\n  z \\<in> H\n\ngoal (1 subgoal):\n 1. a sm \\<le> a (S z)", "by (cases \"S z\", fastforce+)"], ["proof (state)\nthis:\n  a sm \\<le> a (S z)\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "have \"to_woot_character M z \\<in> set s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_woot_character M z \\<in> set s", "using f associated_string_assm is_associated_string_def z_def(1)"], ["proof (prove)\nusing this:\n  H \\<subseteq> insert_messages M\n  is_associated_string M s\n  is_associated_string ?M ?s \\<equiv>\n  consistent ?M \\<and>\n  set ?s = to_woot_character ?M ` insert_messages ?M \\<and>\n  (\\<forall>a.\n      a_conditions (insert_messages ?M) a \\<longrightarrow>\n      sorted_wrt (<) (map a (ext_ids ?s)))\n  z \\<in> H\n\ngoal (1 subgoal):\n 1. to_woot_character M z \\<in> set s", "by fastforce"], ["proof (state)\nthis:\n  to_woot_character M z \\<in> set s\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "hence \"is_concurrent pm sm (to_woot_character M z)\""], ["proof (prove)\nusing this:\n  to_woot_character M z \\<in> set s\n\ngoal (1 subgoal):\n 1. is_concurrent pm sm (to_woot_character M z)", "using H_def z_def(1) d e"], ["proof (prove)\nusing this:\n  to_woot_character M z \\<in> set s\n  H =\n  {x \\<in> insert_messages M.\n   a pm < a \\<lbrakk>I x\\<rbrakk> \\<and> a \\<lbrakk>I x\\<rbrakk> < a sm}\n  z \\<in> H\n  a (P z) \\<le> a pm\n  a sm \\<le> a (S z)\n\ngoal (1 subgoal):\n 1. is_concurrent pm sm (to_woot_character M z)", "by simp"], ["proof (state)\nthis:\n  is_concurrent pm sm (to_woot_character M z)\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_concurrent pm sm (to_woot_character M z)\n\ngoal (1 subgoal):\n 1. {x. is_concurrent pm sm x} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  {x. is_concurrent pm sm x} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma integrate_insert_result_helper:\n  \"invariant pm sm \\<Longrightarrow> m' = m \\<Longrightarrow> s' = s \\<Longrightarrow> \n  is_certified_associated_string' (integrate_insert m' s' pm sm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant pm sm; m' = m; s' = s\\<rbrakk>\n    \\<Longrightarrow> is_certified_associated_string'\n                       (integrate_insert m' s' pm sm)", "proof (induction m' s' pm sm rule:integrate_insert.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ma w p sa.\n       \\<lbrakk>\\<And>y ya yb yba yc yd x ye.\n                   \\<lbrakk>idx w p = Inr y; idx w sa = Inr ya;\n                    assert (y < ya) = Inr yb; Suc y \\<noteq> ya;\n                    mapM (concurrent w y ya) (substr w y ya) = Inr yba;\n                    assert (concat yba \\<noteq> []) = Inr yc;\n                    fromSome\n                     (find\n                       ((\\<lambda>x.\n                            \\<lbrakk>I ma\\<rbrakk> < x \\<or> x = sa) \\<circ>\n                        snd)\n                       (zip (p # concat yba) (concat yba @ [sa]))) =\n                    Inr yd;\n                    (x, ye) = yd; invariant x ye; ma = m; w = s\\<rbrakk>\n                   \\<Longrightarrow> is_certified_associated_string'\n(integrate_insert ma w x ye);\n        invariant p sa; ma = m; w = s\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string'\n                          (integrate_insert ma w p sa)", "case (1 m' s' pm sm)"], ["proof (state)\nthis:\n  \\<lbrakk>idx s' pm = Inr ?y5; idx s' sm = Inr ?ya5;\n   assert (?y5 < ?ya5) = Inr ?yb5; Suc ?y5 \\<noteq> ?ya5;\n   mapM (concurrent s' ?y5 ?ya5) (substr s' ?y5 ?ya5) = Inr ?yba5;\n   assert (concat ?yba5 \\<noteq> []) = Inr ?yc5;\n   fromSome\n    (find\n      ((\\<lambda>x. \\<lbrakk>I m'\\<rbrakk> < x \\<or> x = sm) \\<circ> snd)\n      (zip (pm # concat ?yba5) (concat ?yba5 @ [sm]))) =\n   Inr ?yd5;\n   (?x5, ?ye5) = ?yd5; invariant ?x5 ?ye5; m' = m; s' = s\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string'\n                     (integrate_insert m' s' ?x5 ?ye5)\n  invariant pm sm\n  m' = m\n  s' = s\n\ngoal (1 subgoal):\n 1. \\<And>ma w p sa.\n       \\<lbrakk>\\<And>y ya yb yba yc yd x ye.\n                   \\<lbrakk>idx w p = Inr y; idx w sa = Inr ya;\n                    assert (y < ya) = Inr yb; Suc y \\<noteq> ya;\n                    mapM (concurrent w y ya) (substr w y ya) = Inr yba;\n                    assert (concat yba \\<noteq> []) = Inr yc;\n                    fromSome\n                     (find\n                       ((\\<lambda>x.\n                            \\<lbrakk>I ma\\<rbrakk> < x \\<or> x = sa) \\<circ>\n                        snd)\n                       (zip (p # concat yba) (concat yba @ [sa]))) =\n                    Inr yd;\n                    (x, ye) = yd; invariant x ye; ma = m; w = s\\<rbrakk>\n                   \\<Longrightarrow> is_certified_associated_string'\n(integrate_insert ma w x ye);\n        invariant p sa; ma = m; w = s\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string'\n                          (integrate_insert ma w p sa)", "obtain l where l_def: \"idx s pm = Inr l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. idx s pm = Inr l \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \"1\"(2) invariant_def obtain_idx"], ["proof (prove)\nusing this:\n  invariant pm sm\n  invariant ?pm ?sm =\n  (?pm \\<in> set (ext_ids s) \\<and>\n   ?sm \\<in> set (ext_ids s) \\<and>\n   Psi.subset (a ?pm, a ?sm) (a (P m), a (S m)) \\<and>\n   elem (a \\<lbrakk>I m\\<rbrakk>) (a ?pm, a ?sm))\n  ?x \\<in> set (ext_ids s) \\<Longrightarrow> \\<exists>i. idx s ?x = Inr i\n\ngoal (1 subgoal):\n 1. (\\<And>l. idx s pm = Inr l \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  idx s pm = Inr l\n\ngoal (1 subgoal):\n 1. \\<And>ma w p sa.\n       \\<lbrakk>\\<And>y ya yb yba yc yd x ye.\n                   \\<lbrakk>idx w p = Inr y; idx w sa = Inr ya;\n                    assert (y < ya) = Inr yb; Suc y \\<noteq> ya;\n                    mapM (concurrent w y ya) (substr w y ya) = Inr yba;\n                    assert (concat yba \\<noteq> []) = Inr yc;\n                    fromSome\n                     (find\n                       ((\\<lambda>x.\n                            \\<lbrakk>I ma\\<rbrakk> < x \\<or> x = sa) \\<circ>\n                        snd)\n                       (zip (p # concat yba) (concat yba @ [sa]))) =\n                    Inr yd;\n                    (x, ye) = yd; invariant x ye; ma = m; w = s\\<rbrakk>\n                   \\<Longrightarrow> is_certified_associated_string'\n(integrate_insert ma w x ye);\n        invariant p sa; ma = m; w = s\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string'\n                          (integrate_insert ma w p sa)", "obtain u where u_def: \"idx s sm = Inr u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u. idx s sm = Inr u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \"1\"(2) invariant_def obtain_idx"], ["proof (prove)\nusing this:\n  invariant pm sm\n  invariant ?pm ?sm =\n  (?pm \\<in> set (ext_ids s) \\<and>\n   ?sm \\<in> set (ext_ids s) \\<and>\n   Psi.subset (a ?pm, a ?sm) (a (P m), a (S m)) \\<and>\n   elem (a \\<lbrakk>I m\\<rbrakk>) (a ?pm, a ?sm))\n  ?x \\<in> set (ext_ids s) \\<Longrightarrow> \\<exists>i. idx s ?x = Inr i\n\ngoal (1 subgoal):\n 1. (\\<And>u. idx s sm = Inr u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  idx s sm = Inr u\n\ngoal (1 subgoal):\n 1. \\<And>ma w p sa.\n       \\<lbrakk>\\<And>y ya yb yba yc yd x ye.\n                   \\<lbrakk>idx w p = Inr y; idx w sa = Inr ya;\n                    assert (y < ya) = Inr yb; Suc y \\<noteq> ya;\n                    mapM (concurrent w y ya) (substr w y ya) = Inr yba;\n                    assert (concat yba \\<noteq> []) = Inr yc;\n                    fromSome\n                     (find\n                       ((\\<lambda>x.\n                            \\<lbrakk>I ma\\<rbrakk> < x \\<or> x = sa) \\<circ>\n                        snd)\n                       (zip (p # concat yba) (concat yba @ [sa]))) =\n                    Inr yd;\n                    (x, ye) = yd; invariant x ye; ma = m; w = s\\<rbrakk>\n                   \\<Longrightarrow> is_certified_associated_string'\n(integrate_insert ma w x ye);\n        invariant p sa; ma = m; w = s\\<rbrakk>\n       \\<Longrightarrow> is_certified_associated_string'\n                          (integrate_insert ma w p sa)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string' (integrate_insert m' s' pm sm)", "proof (cases \"Suc l = u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc l = u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)\n 2. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "case True"], ["proof (state)\nthis:\n  Suc l = u\n\ngoal (2 subgoals):\n 1. Suc l = u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)\n 2. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "then"], ["proof (chain)\npicking this:\n  Suc l = u", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc l = u\n\ngoal (1 subgoal):\n 1. is_certified_associated_string' (integrate_insert m' s' pm sm)", "apply (simp add:l_def u_def 1 del:idx.simps is_certified_associated_string'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc l = u \\<Longrightarrow>\n    is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "using \"1\"(2) l_def u_def integrate_insert_final_step"], ["proof (prove)\nusing this:\n  invariant pm sm\n  idx s pm = Inr l\n  idx s sm = Inr u\n  \\<lbrakk>invariant ?pm ?sm; idx s ?pm = Inr ?l;\n   idx s ?sm = Inr (Suc ?l)\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string'\n                     (Inr (take ?l s @ to_woot_char m # drop ?l s))\n\ngoal (1 subgoal):\n 1. Suc l = u \\<Longrightarrow>\n    is_certified_associated_string'\n     (Inr (take l s @ to_woot_char m # drop l s))", "by blast"], ["proof (state)\nthis:\n  is_certified_associated_string' (integrate_insert m' s' pm sm)\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "case False"], ["proof (state)\nthis:\n  Suc l \\<noteq> u\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "have \"a pm < a sm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a pm < a sm", "using invariant_def \"1\"(2)"], ["proof (prove)\nusing this:\n  invariant ?pm ?sm =\n  (?pm \\<in> set (ext_ids s) \\<and>\n   ?sm \\<in> set (ext_ids s) \\<and>\n   Psi.subset (a ?pm, a ?sm) (a (P m), a (S m)) \\<and>\n   elem (a \\<lbrakk>I m\\<rbrakk>) (a ?pm, a ?sm))\n  invariant pm sm\n\ngoal (1 subgoal):\n 1. a pm < a sm", "by auto"], ["proof (state)\nthis:\n  a pm < a sm\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "hence a:\"l < u\""], ["proof (prove)\nusing this:\n  a pm < a sm\n\ngoal (1 subgoal):\n 1. l < u", "using sorted_a_le  l_def u_def"], ["proof (prove)\nusing this:\n  a pm < a sm\n  \\<lbrakk>idx s ?x = Inr ?l; idx s ?y = Inr ?u\\<rbrakk>\n  \\<Longrightarrow> (?l < ?u) = (a ?x < a ?y)\n  idx s pm = Inr l\n  idx s sm = Inr u\n\ngoal (1 subgoal):\n 1. l < u", "by blast"], ["proof (state)\nthis:\n  l < u\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "obtain d where d_def: \"mapM (concurrent s l u) (substr s l u) = Inr d \\<and>  \n      set (concat d) = InString ` I ` {x. is_concurrent pm sm x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        mapM (concurrent s l u) (substr s l u) = Inr d \\<and>\n        set (concat d) =\n        InString ` I ` {x. is_concurrent pm sm x} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis concurrent_eff l_def u_def)"], ["proof (state)\nthis:\n  mapM (concurrent s l u) (substr s l u) = Inr d \\<and>\n  set (concat d) = InString ` I ` {x. is_concurrent pm sm x}\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "have b:\"concat d \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat d \\<noteq> []", "by (metis Suc_lessI concurrent_eff_3 False l_def u_def \n          a d_def empty_set image_is_empty)"], ["proof (state)\nthis:\n  concat d \\<noteq> []\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "have c:\"\\<And>x. x \\<in> set (concat d) \\<Longrightarrow> \n      preserve_order x \\<lbrakk>I m\\<rbrakk> (a x) (a \\<lbrakk>I m\\<rbrakk>) \\<and> x \\<in> set (ext_ids s) \\<and>\n       a pm < a x \\<and> a x < a sm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (concat d) \\<Longrightarrow>\n       preserve_order x \\<lbrakk>I m\\<rbrakk> (a x)\n        (a \\<lbrakk>I m\\<rbrakk>) \\<and>\n       x \\<in> set (ext_ids s) \\<and> a pm < a x \\<and> a x < a sm", "using 1(2) d_def concurrent_eff_2"], ["proof (prove)\nusing this:\n  invariant pm sm\n  mapM (concurrent s l u) (substr s l u) = Inr d \\<and>\n  set (concat d) = InString ` I ` {x. is_concurrent pm sm x}\n  \\<lbrakk>invariant ?pm ?sm; is_concurrent ?pm ?sm ?x\\<rbrakk>\n  \\<Longrightarrow> preserve_order \\<lbrakk>I ?x\\<rbrakk>\n                     \\<lbrakk>I m\\<rbrakk> (a \\<lbrakk>I ?x\\<rbrakk>)\n                     (a \\<lbrakk>I m\\<rbrakk>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (concat d) \\<Longrightarrow>\n       preserve_order x \\<lbrakk>I m\\<rbrakk> (a x)\n        (a \\<lbrakk>I m\\<rbrakk>) \\<and>\n       x \\<in> set (ext_ids s) \\<and> a pm < a x \\<and> a x < a sm", "by (simp del:set_concat add:ext_ids_def, blast)"], ["proof (state)\nthis:\n  ?x5 \\<in> set (concat d) \\<Longrightarrow>\n  preserve_order ?x5 \\<lbrakk>I m\\<rbrakk> (a ?x5)\n   (a \\<lbrakk>I m\\<rbrakk>) \\<and>\n  ?x5 \\<in> set (ext_ids s) \\<and> a pm < a ?x5 \\<and> a ?x5 < a sm\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "obtain pm' sm' where ps'_def: \"find ((\\<lambda>x.\\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ> snd)\n         (zip (pm # concat d) (concat d @ [sm])) = Some (pm',sm')\"\n      (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pm' sm'.\n        find\n         ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ> snd)\n         (zip (pm # concat d) (concat d @ [sm])) =\n        Some (pm', sm') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (cases \"?lhs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>pm' sm'.\n                find\n                 ((\\<lambda>x.\n                      \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ>\n                  snd)\n                 (zip (pm # concat d) (concat d @ [sm])) =\n                Some (pm', sm') \\<Longrightarrow>\n                thesis;\n     find ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ> snd)\n      (zip (pm # concat d) (concat d @ [sm])) =\n     None\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a.\n       \\<lbrakk>\\<And>pm' sm'.\n                   find\n                    ((\\<lambda>x.\n                         \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ>\n                     snd)\n                    (zip (pm # concat d) (concat d @ [sm])) =\n                   Some (pm', sm') \\<Longrightarrow>\n                   thesis;\n        find\n         ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ> snd)\n         (zip (pm # concat d) (concat d @ [sm])) =\n        Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (simp add:find_None_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>a b.\n       (a, b)\n       \\<in> set (zip (pm # concat d) (concat d @ [sm])) \\<longrightarrow>\n       \\<not> \\<lbrakk>I m\\<rbrakk> < b \\<and>\n       b \\<noteq> sm \\<Longrightarrow>\n    thesis\n 2. \\<And>a.\n       \\<lbrakk>\\<And>pm' sm'.\n                   find\n                    ((\\<lambda>x.\n                         \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ>\n                     snd)\n                    (zip (pm # concat d) (concat d @ [sm])) =\n                   Some (pm', sm') \\<Longrightarrow>\n                   thesis;\n        find\n         ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ> snd)\n         (zip (pm # concat d) (concat d @ [sm])) =\n        Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (metis in_set_conv_decomp in_set_impl_in_set_zip2 length_Cons \n              length_append_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>pm' sm'.\n                   find\n                    ((\\<lambda>x.\n                         \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ>\n                     snd)\n                    (zip (pm # concat d) (concat d @ [sm])) =\n                   Some (pm', sm') \\<Longrightarrow>\n                   thesis;\n        find\n         ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ> snd)\n         (zip (pm # concat d) (concat d @ [sm])) =\n        Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  find ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ> snd)\n   (zip (pm # concat d) (concat d @ [sm])) =\n  Some (pm', sm')\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "have d:\"pm' = pm \\<or> pm' \\<in> set (concat d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm' = pm \\<or> pm' \\<in> set (concat d)", "using ps'_def b"], ["proof (prove)\nusing this:\n  find ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ> snd)\n   (zip (pm # concat d) (concat d @ [sm])) =\n  Some (pm', sm')\n  concat d \\<noteq> []\n\ngoal (1 subgoal):\n 1. pm' = pm \\<or> pm' \\<in> set (concat d)", "by (metis (full_types) find_zip(3))"], ["proof (state)\nthis:\n  pm' = pm \\<or> pm' \\<in> set (concat d)\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "hence \"pm' \\<in> set (ext_ids s)\""], ["proof (prove)\nusing this:\n  pm' = pm \\<or> pm' \\<in> set (concat d)\n\ngoal (1 subgoal):\n 1. pm' \\<in> set (ext_ids s)", "using c 1(2) invariant_def"], ["proof (prove)\nusing this:\n  pm' = pm \\<or> pm' \\<in> set (concat d)\n  ?x5 \\<in> set (concat d) \\<Longrightarrow>\n  preserve_order ?x5 \\<lbrakk>I m\\<rbrakk> (a ?x5)\n   (a \\<lbrakk>I m\\<rbrakk>) \\<and>\n  ?x5 \\<in> set (ext_ids s) \\<and> a pm < a ?x5 \\<and> a ?x5 < a sm\n  invariant pm sm\n  invariant ?pm ?sm =\n  (?pm \\<in> set (ext_ids s) \\<and>\n   ?sm \\<in> set (ext_ids s) \\<and>\n   Psi.subset (a ?pm, a ?sm) (a (P m), a (S m)) \\<and>\n   elem (a \\<lbrakk>I m\\<rbrakk>) (a ?pm, a ?sm))\n\ngoal (1 subgoal):\n 1. pm' \\<in> set (ext_ids s)", "by auto"], ["proof (state)\nthis:\n  pm' \\<in> set (ext_ids s)\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "hence \"pm' \\<in> InString ` I ` insert_messages M \\<or> pm' = \\<turnstile> \\<or> pm' = \\<stileturn>\""], ["proof (prove)\nusing this:\n  pm' \\<in> set (ext_ids s)\n\ngoal (1 subgoal):\n 1. pm' \\<in> InString ` I ` insert_messages M \\<or>\n    pm' = \\<turnstile> \\<or> pm' = \\<stileturn>", "apply (simp add:ext_ids_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pm' = \\<turnstile> \\<or>\n    pm' = \\<stileturn> \\<or>\n    pm' \\<in> (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>) ` set s \\<Longrightarrow>\n    pm' \\<in> InString ` I ` insert_messages M \\<or>\n    pm' = \\<turnstile> \\<or> pm' = \\<stileturn>", "by (metis image_image associated_string_assm is_associated_string_def \n          to_woot_character_keeps_i_lifted)"], ["proof (state)\nthis:\n  pm' \\<in> InString ` I ` insert_messages M \\<or>\n  pm' = \\<turnstile> \\<or> pm' = \\<stileturn>\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "hence \"pm' \\<noteq> \\<lbrakk>I m\\<rbrakk>\""], ["proof (prove)\nusing this:\n  pm' \\<in> InString ` I ` insert_messages M \\<or>\n  pm' = \\<turnstile> \\<or> pm' = \\<stileturn>\n\ngoal (1 subgoal):\n 1. pm' \\<noteq> \\<lbrakk>I m\\<rbrakk>", "using no_id_collision"], ["proof (prove)\nusing this:\n  pm' \\<in> InString ` I ` insert_messages M \\<or>\n  pm' = \\<turnstile> \\<or> pm' = \\<stileturn>\n  I m \\<notin> I ` insert_messages M\n\ngoal (1 subgoal):\n 1. pm' \\<noteq> \\<lbrakk>I m\\<rbrakk>", "by blast"], ["proof (state)\nthis:\n  pm' \\<noteq> \\<lbrakk>I m\\<rbrakk>\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "hence \"(pm' = pm \\<or> pm' < \\<lbrakk>I m\\<rbrakk>) \\<and> (sm' = sm \\<or> sm' > \\<lbrakk>I m\\<rbrakk> \\<and> sm' \\<in> set (concat d))\""], ["proof (prove)\nusing this:\n  pm' \\<noteq> \\<lbrakk>I m\\<rbrakk>\n\ngoal (1 subgoal):\n 1. (pm' = pm \\<or> pm' < \\<lbrakk>I m\\<rbrakk>) \\<and>\n    (sm' = sm \\<or>\n     \\<lbrakk>I m\\<rbrakk> < sm' \\<and> sm' \\<in> set (concat d))", "by (metis (mono_tags, lifting) ps'_def b find_zip(1) find_zip(3) find_zip(4) less_linear)"], ["proof (state)\nthis:\n  (pm' = pm \\<or> pm' < \\<lbrakk>I m\\<rbrakk>) \\<and>\n  (sm' = sm \\<or>\n   \\<lbrakk>I m\\<rbrakk> < sm' \\<and> sm' \\<in> set (concat d))\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "hence e:\"invariant pm' sm'\""], ["proof (prove)\nusing this:\n  (pm' = pm \\<or> pm' < \\<lbrakk>I m\\<rbrakk>) \\<and>\n  (sm' = sm \\<or>\n   \\<lbrakk>I m\\<rbrakk> < sm' \\<and> sm' \\<in> set (concat d))\n\ngoal (1 subgoal):\n 1. invariant pm' sm'", "using 1(2) c d"], ["proof (prove)\nusing this:\n  (pm' = pm \\<or> pm' < \\<lbrakk>I m\\<rbrakk>) \\<and>\n  (sm' = sm \\<or>\n   \\<lbrakk>I m\\<rbrakk> < sm' \\<and> sm' \\<in> set (concat d))\n  invariant pm sm\n  ?x5 \\<in> set (concat d) \\<Longrightarrow>\n  preserve_order ?x5 \\<lbrakk>I m\\<rbrakk> (a ?x5)\n   (a \\<lbrakk>I m\\<rbrakk>) \\<and>\n  ?x5 \\<in> set (ext_ids s) \\<and> a pm < a ?x5 \\<and> a ?x5 < a sm\n  pm' = pm \\<or> pm' \\<in> set (concat d)\n\ngoal (1 subgoal):\n 1. invariant pm' sm'", "apply (simp add:invariant_def del:set_concat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(pm' = pm \\<or> pm' < \\<lbrakk>I m\\<rbrakk>) \\<and>\n             (sm' = sm \\<or>\n              \\<lbrakk>I m\\<rbrakk> < sm' \\<and> sm' \\<in> set (concat d));\n     pm \\<in> set (ext_ids s) \\<and>\n     sm \\<in> set (ext_ids s) \\<and>\n     a (P m) \\<le> a pm \\<and>\n     a sm \\<le> a (S m) \\<and>\n     a pm < a \\<lbrakk>I m\\<rbrakk> \\<and> a \\<lbrakk>I m\\<rbrakk> < a sm;\n     \\<And>x.\n        x \\<in> set (concat d) \\<Longrightarrow>\n        preserve_order x \\<lbrakk>I m\\<rbrakk> (a x)\n         (a \\<lbrakk>I m\\<rbrakk>) \\<and>\n        x \\<in> set (ext_ids s) \\<and> a pm < a x \\<and> a x < a sm;\n     pm' = pm \\<or> pm' \\<in> set (concat d)\\<rbrakk>\n    \\<Longrightarrow> pm' \\<in> set (ext_ids s) \\<and>\n                      sm' \\<in> set (ext_ids s) \\<and>\n                      a (P m) \\<le> a pm' \\<and>\n                      a sm' \\<le> a (S m) \\<and>\n                      a pm' < a \\<lbrakk>I m\\<rbrakk> \\<and>\n                      a \\<lbrakk>I m\\<rbrakk> < a sm'", "by (meson dual_order.strict_trans leD leI preserve_order_def)"], ["proof (state)\nthis:\n  invariant pm' sm'\n\ngoal (1 subgoal):\n 1. Suc l \\<noteq> u \\<Longrightarrow>\n    is_certified_associated_string' (integrate_insert m' s' pm sm)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string' (integrate_insert m' s' pm sm)", "apply (subst integrate_insert.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (idx s' pm \\<bind>\n      (\\<lambda>l.\n          idx s' sm \\<bind>\n          (\\<lambda>u.\n              assert (l < u) \\<bind>\n              (\\<lambda>_.\n                  if Suc l = u\n                  then Inr (take l s' @ [to_woot_char m'] @ drop l s')\n                  else mapM (concurrent s' l u) (substr s' l u) \\<bind>\n                       (\\<lambda>d.\n                           assert (concat d \\<noteq> []) \\<bind>\n                           (\\<lambda>_.\n                               fromSome\n                                (find\n                                  ((\\<lambda>x.\n \\<lbrakk>I m'\\<rbrakk> < x \\<or> x = sm) \\<circ>\n                                   snd)\n                                  (zip (pm # concat d)\n                                    (concat d @ [sm]))) \\<bind>\n                               (\\<lambda>(x, y).\n                                   integrate_insert m' s' x y)))))))", "using a b e ps'_def 1 d_def False l_def u_def"], ["proof (prove)\nusing this:\n  l < u\n  concat d \\<noteq> []\n  invariant pm' sm'\n  find ((\\<lambda>x. \\<lbrakk>I m\\<rbrakk> < x \\<or> x = sm) \\<circ> snd)\n   (zip (pm # concat d) (concat d @ [sm])) =\n  Some (pm', sm')\n  \\<lbrakk>idx s' pm = Inr ?y5; idx s' sm = Inr ?ya5;\n   assert (?y5 < ?ya5) = Inr ?yb5; Suc ?y5 \\<noteq> ?ya5;\n   mapM (concurrent s' ?y5 ?ya5) (substr s' ?y5 ?ya5) = Inr ?yba5;\n   assert (concat ?yba5 \\<noteq> []) = Inr ?yc5;\n   fromSome\n    (find\n      ((\\<lambda>x. \\<lbrakk>I m'\\<rbrakk> < x \\<or> x = sm) \\<circ> snd)\n      (zip (pm # concat ?yba5) (concat ?yba5 @ [sm]))) =\n   Inr ?yd5;\n   (?x5, ?ye5) = ?yd5; invariant ?x5 ?ye5; m' = m; s' = s\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string'\n                     (integrate_insert m' s' ?x5 ?ye5)\n  invariant pm sm\n  m' = m\n  s' = s\n  mapM (concurrent s l u) (substr s l u) = Inr d \\<and>\n  set (concat d) = InString ` I ` {x. is_concurrent pm sm x}\n  Suc l \\<noteq> u\n  idx s pm = Inr l\n  idx s sm = Inr u\n\ngoal (1 subgoal):\n 1. is_certified_associated_string'\n     (idx s' pm \\<bind>\n      (\\<lambda>l.\n          idx s' sm \\<bind>\n          (\\<lambda>u.\n              assert (l < u) \\<bind>\n              (\\<lambda>_.\n                  if Suc l = u\n                  then Inr (take l s' @ [to_woot_char m'] @ drop l s')\n                  else mapM (concurrent s' l u) (substr s' l u) \\<bind>\n                       (\\<lambda>d.\n                           assert (concat d \\<noteq> []) \\<bind>\n                           (\\<lambda>_.\n                               fromSome\n                                (find\n                                  ((\\<lambda>x.\n \\<lbrakk>I m'\\<rbrakk> < x \\<or> x = sm) \\<circ>\n                                   snd)\n                                  (zip (pm # concat d)\n                                    (concat d @ [sm]))) \\<bind>\n                               (\\<lambda>(x, y).\n                                   integrate_insert m' s' x y)))))))", "by (simp add:1 del:idx.simps integrate_insert.simps)"], ["proof (state)\nthis:\n  is_certified_associated_string' (integrate_insert m' s' pm sm)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_certified_associated_string' (integrate_insert m' s' pm sm)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma integrate_insert_result:\n  \"is_certified_associated_string' (integrate_insert m s (P m) (S m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string' (integrate_insert m s (P m) (S m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_certified_associated_string' (integrate_insert m s (P m) (S m))", "have \"invariant (P m) (S m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (P m) (S m)", "using find_pred find_succ pred_succ_order"], ["proof (prove)\nusing this:\n  ?m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n  P ?m' \\<in> set (ext_ids s)\n  ?m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n  S ?m' \\<in> set (ext_ids s)\n  ?m' \\<in> insert_messages M \\<union> {m} \\<Longrightarrow>\n  a (P ?m') < a \\<lbrakk>I ?m'\\<rbrakk> \\<and>\n  a \\<lbrakk>I ?m'\\<rbrakk> < a (S ?m')\n\ngoal (1 subgoal):\n 1. invariant (P m) (S m)", "by (simp add:invariant_def)"], ["proof (state)\nthis:\n  invariant (P m) (S m)\n\ngoal (1 subgoal):\n 1. is_certified_associated_string' (integrate_insert m s (P m) (S m))", "thus ?thesis"], ["proof (prove)\nusing this:\n  invariant (P m) (S m)\n\ngoal (1 subgoal):\n 1. is_certified_associated_string' (integrate_insert m s (P m) (S m))", "using integrate_insert_result_helper"], ["proof (prove)\nusing this:\n  invariant (P m) (S m)\n  \\<lbrakk>invariant ?pm ?sm; ?m' = m; ?s' = s\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string'\n                     (integrate_insert ?m' ?s' ?pm ?sm)\n\ngoal (1 subgoal):\n 1. is_certified_associated_string' (integrate_insert m s (P m) (S m))", "by blast"], ["proof (state)\nthis:\n  is_certified_associated_string' (integrate_insert m s (P m) (S m))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma integrate_insert_result:\n  assumes \"consistent (M \\<union> {Insert m})\"\n  assumes \"Insert m \\<notin> M\"\n  assumes \"is_associated_string M s\"\n  shows \"is_certified_associated_string (M \\<union> {Insert m}) (integrate_insert m s (P m) (S m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Insert m})\n     (integrate_insert m s (P m) (S m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Insert m})\n     (integrate_insert m s (P m) (S m))", "obtain t where t_def: \"(integrate_insert m s (P m) (S m)) = Inr t \\<and>\n    set t = to_woot_character (M \\<union> {Insert m}) ` (insert_messages (M \\<union> {Insert m}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        integrate_insert m s (P m) (S m) = Inr t \\<and>\n        set t =\n        to_woot_character (M \\<union> {Insert m}) `\n        insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        integrate_insert m s (P m) (S m) = Inr t \\<and>\n        set t =\n        to_woot_character (M \\<union> {Insert m}) `\n        insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "fix tt"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        integrate_insert m s (P m) (S m) = Inr t \\<and>\n        set t =\n        to_woot_character (M \\<union> {Insert m}) `\n        insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "assume a:\"(\\<And>t. (integrate_insert m s (P m) (S m)) = Inr t \\<and>\n          set t = to_woot_character (M \\<union> {Insert m}) ` insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n          tt)\""], ["proof (state)\nthis:\n  integrate_insert m s (P m) (S m) = Inr ?t \\<and>\n  set ?t =\n  to_woot_character (M \\<union> {Insert m}) `\n  insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n  tt\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        integrate_insert m s (P m) (S m) = Inr t \\<and>\n        set t =\n        to_woot_character (M \\<union> {Insert m}) `\n        insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain a where a_def: \"a_conditions (insert_messages (M \\<union> {Insert m})) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a_conditions (insert_messages (M \\<union> {Insert m}))\n         a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using consistent_def assms"], ["proof (prove)\nusing this:\n  consistent ?M \\<equiv>\n  inj_on I (insert_messages ?M) \\<and>\n  \\<Union> (deps ` ?M) \\<subseteq> I ` insert_messages ?M \\<and>\n  wfP (depends_on (insert_messages ?M)) \\<and>\n  (\\<exists>a. a_conditions (insert_messages ?M) a)\n  consistent (M \\<union> {Insert m})\n  Insert m \\<notin> M\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a_conditions (insert_messages (M \\<union> {Insert m}))\n         a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        integrate_insert m s (P m) (S m) = Inr t \\<and>\n        set t =\n        to_woot_character (M \\<union> {Insert m}) `\n        insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        integrate_insert m s (P m) (S m) = Inr t \\<and>\n        set t =\n        to_woot_character (M \\<union> {Insert m}) `\n        insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"a_conditions (insert_messages M) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a_conditions (insert_messages M) a", "using assms a_subset is_associated_string_def a_def"], ["proof (prove)\nusing this:\n  consistent (M \\<union> {Insert m})\n  Insert m \\<notin> M\n  is_associated_string M s\n  \\<lbrakk>?M \\<subseteq> ?N; a_conditions (insert_messages ?N) ?a\\<rbrakk>\n  \\<Longrightarrow> a_conditions (insert_messages ?M) ?a\n  is_associated_string ?M ?s \\<equiv>\n  consistent ?M \\<and>\n  set ?s = to_woot_character ?M ` insert_messages ?M \\<and>\n  (\\<forall>a.\n      a_conditions (insert_messages ?M) a \\<longrightarrow>\n      sorted_wrt (<) (map a (ext_ids ?s)))\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n\ngoal (1 subgoal):\n 1. a_conditions (insert_messages M) a", "by blast"], ["proof (state)\nthis:\n  a_conditions (insert_messages M) a\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        integrate_insert m s (P m) (S m) = Inr t \\<and>\n        set t =\n        to_woot_character (M \\<union> {Insert m}) `\n        insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n  a_conditions (insert_messages M) a", "interpret integrate_insert_commute_insert \"M\" \"a\" \"s\" \"m\""], ["proof (prove)\nusing this:\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n  a_conditions (insert_messages M) a\n\ngoal (1 subgoal):\n 1. integrate_insert_commute_insert M a s m", "using assms"], ["proof (prove)\nusing this:\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n  a_conditions (insert_messages M) a\n  consistent (M \\<union> {Insert m})\n  Insert m \\<notin> M\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. integrate_insert_commute_insert M a s m", "by (simp add: integrate_insert_commute_insert_def integrate_insert_commute_def (*\n                *) integrate_insert_commute_insert_axioms.intro)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        integrate_insert m s (P m) (S m) = Inr t \\<and>\n        set t =\n        to_woot_character (M \\<union> {Insert m}) `\n        insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "show tt"], ["proof (prove)\ngoal (1 subgoal):\n 1. tt", "using a integrate_insert_result"], ["proof (prove)\nusing this:\n  integrate_insert m s (P m) (S m) = Inr ?t \\<and>\n  set ?t =\n  to_woot_character (M \\<union> {Insert m}) `\n  insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n  tt\n  is_certified_associated_string' (integrate_insert m s (P m) (S m))\n\ngoal (1 subgoal):\n 1. tt", "apply (cases \"integrate_insert m s (P m) (S m)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   integrate_insert m s (P m) (S m) = Inr t \\<and>\n                   set t =\n                   to_woot_character (M \\<union> {Insert m}) `\n                   insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n                   tt;\n        is_certified_associated_string' (integrate_insert m s (P m) (S m));\n        integrate_insert m s (P m) (S m) = Inl a\\<rbrakk>\n       \\<Longrightarrow> tt\n 2. \\<And>b.\n       \\<lbrakk>\\<And>t.\n                   integrate_insert m s (P m) (S m) = Inr t \\<and>\n                   set t =\n                   to_woot_character (M \\<union> {Insert m}) `\n                   insert_messages (M \\<union> {Insert m}) \\<Longrightarrow>\n                   tt;\n        is_certified_associated_string' (integrate_insert m s (P m) (S m));\n        integrate_insert m s (P m) (S m) = Inr b\\<rbrakk>\n       \\<Longrightarrow> tt", "by auto"], ["proof (state)\nthis:\n  tt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  integrate_insert m s (P m) (S m) = Inr t \\<and>\n  set t =\n  to_woot_character (M \\<union> {Insert m}) `\n  insert_messages (M \\<union> {Insert m})\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Insert m})\n     (integrate_insert m s (P m) (S m))", "have b:\"\\<And>a. a_conditions (insert_messages (M \\<union> {Insert m})) a \\<Longrightarrow> \n    sorted_wrt (<) (map a (ext_ids t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a_conditions (insert_messages (M \\<union> {Insert m}))\n        a \\<Longrightarrow>\n       sorted_wrt (<) (map a (ext_ids t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a_conditions (insert_messages (M \\<union> {Insert m}))\n        a \\<Longrightarrow>\n       sorted_wrt (<) (map a (ext_ids t))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a_conditions (insert_messages (M \\<union> {Insert m}))\n        a \\<Longrightarrow>\n       sorted_wrt (<) (map a (ext_ids t))", "assume c:\"a_conditions (insert_messages (M \\<union> {Insert m})) a\""], ["proof (state)\nthis:\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a_conditions (insert_messages (M \\<union> {Insert m}))\n        a \\<Longrightarrow>\n       sorted_wrt (<) (map a (ext_ids t))", "moreover"], ["proof (state)\nthis:\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a_conditions (insert_messages (M \\<union> {Insert m}))\n        a \\<Longrightarrow>\n       sorted_wrt (<) (map a (ext_ids t))", "have \"a_conditions (insert_messages M) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a_conditions (insert_messages M) a", "using assms a_subset is_associated_string_def c"], ["proof (prove)\nusing this:\n  consistent (M \\<union> {Insert m})\n  Insert m \\<notin> M\n  is_associated_string M s\n  \\<lbrakk>?M \\<subseteq> ?N; a_conditions (insert_messages ?N) ?a\\<rbrakk>\n  \\<Longrightarrow> a_conditions (insert_messages ?M) ?a\n  is_associated_string ?M ?s \\<equiv>\n  consistent ?M \\<and>\n  set ?s = to_woot_character ?M ` insert_messages ?M \\<and>\n  (\\<forall>a.\n      a_conditions (insert_messages ?M) a \\<longrightarrow>\n      sorted_wrt (<) (map a (ext_ids ?s)))\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n\ngoal (1 subgoal):\n 1. a_conditions (insert_messages M) a", "by blast"], ["proof (state)\nthis:\n  a_conditions (insert_messages M) a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a_conditions (insert_messages (M \\<union> {Insert m}))\n        a \\<Longrightarrow>\n       sorted_wrt (<) (map a (ext_ids t))", "ultimately"], ["proof (chain)\npicking this:\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n  a_conditions (insert_messages M) a", "interpret integrate_insert_commute_insert \"M\" \"a\" \"s\" \"m\""], ["proof (prove)\nusing this:\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n  a_conditions (insert_messages M) a\n\ngoal (1 subgoal):\n 1. integrate_insert_commute_insert M a s m", "using assms"], ["proof (prove)\nusing this:\n  a_conditions (insert_messages (M \\<union> {Insert m})) a\n  a_conditions (insert_messages M) a\n  consistent (M \\<union> {Insert m})\n  Insert m \\<notin> M\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. integrate_insert_commute_insert M a s m", "by (simp add: integrate_insert_commute_insert_def integrate_insert_commute_def (*\n                *) integrate_insert_commute_insert_axioms.intro)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a_conditions (insert_messages (M \\<union> {Insert m}))\n        a \\<Longrightarrow>\n       sorted_wrt (<) (map a (ext_ids t))", "show \"sorted_wrt (<) (map a (ext_ids t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids t))", "using integrate_insert_result t_def"], ["proof (prove)\nusing this:\n  is_certified_associated_string' (integrate_insert m s (P m) (S m))\n  integrate_insert m s (P m) (S m) = Inr t \\<and>\n  set t =\n  to_woot_character (M \\<union> {Insert m}) `\n  insert_messages (M \\<union> {Insert m})\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (map a (ext_ids t))", "by simp"], ["proof (state)\nthis:\n  sorted_wrt (<) (map a (ext_ids t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a_conditions (insert_messages (M \\<union> {Insert m}))\n   ?a \\<Longrightarrow>\n  sorted_wrt (<) (map ?a (ext_ids t))\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Insert m})\n     (integrate_insert m s (P m) (S m))", "show \"?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Insert m})\n     (integrate_insert m s (P m) (S m))", "using b t_def assms(1)"], ["proof (prove)\nusing this:\n  a_conditions (insert_messages (M \\<union> {Insert m}))\n   ?a \\<Longrightarrow>\n  sorted_wrt (<) (map ?a (ext_ids t))\n  integrate_insert m s (P m) (S m) = Inr t \\<and>\n  set t =\n  to_woot_character (M \\<union> {Insert m}) `\n  insert_messages (M \\<union> {Insert m})\n  consistent (M \\<union> {Insert m})\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Insert m})\n     (integrate_insert m s (P m) (S m))", "by (simp add:is_associated_string_def)"], ["proof (state)\nthis:\n  is_certified_associated_string (M \\<union> {Insert m})\n   (integrate_insert m s (P m) (S m))\n\ngoal:\nNo subgoals!", "qed"], ["", "locale integrate_insert_commute_delete = integrate_insert_commute +\n  fixes m\n  assumes consistent_assm: \"consistent (M \\<union> {Delete m})\"\nbegin"], ["", "fun delete :: \"('a, 's) woot_character \\<Rightarrow> ('a, 's) woot_character\"\n  where \"delete (InsertMessage p i u _) = InsertMessage p i u None\""], ["", "definition delete_only_m :: \"('a, 's) woot_character \\<Rightarrow> ('a, 's) woot_character\"\n  where \"delete_only_m x = (if DeleteMessage (I x) = m then delete x else x)\""], ["", "lemma set_s: \"set s = to_woot_character M ` insert_messages M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set s = to_woot_character M ` insert_messages M", "using associated_string_assm"], ["proof (prove)\nusing this:\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. set s = to_woot_character M ` insert_messages M", "by (simp add:is_associated_string_def)"], ["", "lemma delete_only_m_effect:\n  \"delete_only_m (to_woot_character M x) = to_woot_character (M \\<union> {Delete m}) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_only_m (to_woot_character M x) =\n    to_woot_character (M \\<union> {Delete m}) x", "apply (cases x, simp add:to_woot_character_def delete_maybe_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       x = InsertMessage x1 x2 x3 x4 \\<Longrightarrow>\n       (Delete m \\<in> M \\<longrightarrow>\n        (DeleteMessage x2 = m \\<longrightarrow>\n         delete_only_m (InsertMessage x1 x2 x3 None) =\n         InsertMessage x1 x2 x3 None) \\<and>\n        (Delete (DeleteMessage x2) \\<in> M \\<longrightarrow>\n         delete_only_m (InsertMessage x1 x2 x3 None) =\n         InsertMessage x1 x2 x3 None) \\<and>\n        (DeleteMessage x2 \\<noteq> m \\<and>\n         Delete (DeleteMessage x2) \\<notin> M \\<longrightarrow>\n         delete_only_m (InsertMessage x1 x2 x3 (Some x4)) =\n         InsertMessage x1 x2 x3 (Some x4))) \\<and>\n       (Delete m \\<notin> M \\<longrightarrow>\n        (DeleteMessage x2 = m \\<longrightarrow>\n         delete_only_m (InsertMessage x1 x2 x3 (Some x4)) =\n         InsertMessage x1 x2 x3 None) \\<and>\n        (Delete (DeleteMessage x2) \\<in> M \\<longrightarrow>\n         delete_only_m (InsertMessage x1 x2 x3 None) =\n         InsertMessage x1 x2 x3 None) \\<and>\n        (DeleteMessage x2 \\<noteq> m \\<and>\n         Delete (DeleteMessage x2) \\<notin> M \\<longrightarrow>\n         delete_only_m (InsertMessage x1 x2 x3 (Some x4)) =\n         InsertMessage x1 x2 x3 (Some x4)))", "by (metis delete_only_m_def insert_message.sel(2) delete.simps)"], ["", "lemma integrate_delete_result:\n  \"is_certified_associated_string (M \\<union> {Delete m}) (integrate_delete m s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Delete m})\n     (integrate_delete m s)", "proof (cases m)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "case (DeleteMessage i)"], ["proof (state)\nthis:\n  m = DeleteMessage i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "have \"deps (Delete m) \\<subseteq> I ` insert_messages (M \\<union> {Delete m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deps (Delete m) \\<subseteq> I ` insert_messages (M \\<union> {Delete m})", "using consistent_assm"], ["proof (prove)\nusing this:\n  consistent (M \\<union> {Delete m})\n\ngoal (1 subgoal):\n 1. deps (Delete m) \\<subseteq> I ` insert_messages (M \\<union> {Delete m})", "by (simp add:consistent_def DeleteMessage)"], ["proof (state)\nthis:\n  deps (Delete m) \\<subseteq> I ` insert_messages (M \\<union> {Delete m})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "hence \"i \\<in> I ` insert_messages (M \\<union> {Delete m})\""], ["proof (prove)\nusing this:\n  deps (Delete m) \\<subseteq> I ` insert_messages (M \\<union> {Delete m})\n\ngoal (1 subgoal):\n 1. i \\<in> I ` insert_messages (M \\<union> {Delete m})", "using DeleteMessage"], ["proof (prove)\nusing this:\n  deps (Delete m) \\<subseteq> I ` insert_messages (M \\<union> {Delete m})\n  m = DeleteMessage i\n\ngoal (1 subgoal):\n 1. i \\<in> I ` insert_messages (M \\<union> {Delete m})", "by auto"], ["proof (state)\nthis:\n  i \\<in> I ` insert_messages (M \\<union> {Delete m})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "hence \"i \\<in> I ` set s\""], ["proof (prove)\nusing this:\n  i \\<in> I ` insert_messages (M \\<union> {Delete m})\n\ngoal (1 subgoal):\n 1. i \\<in> I ` set s", "using set_s"], ["proof (prove)\nusing this:\n  i \\<in> I ` insert_messages (M \\<union> {Delete m})\n  set s = to_woot_character M ` insert_messages M\n\ngoal (1 subgoal):\n 1. i \\<in> I ` set s", "by (simp add:insert_messages_def)"], ["proof (state)\nthis:\n  i \\<in> I ` set s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "then"], ["proof (chain)\npicking this:\n  i \\<in> I ` set s", "obtain k where k_def: \"I (s ! k) = i \\<and> k < length s\""], ["proof (prove)\nusing this:\n  i \\<in> I ` set s\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        I (s ! k) = i \\<and> k < length s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis imageE in_set_conv_nth)"], ["proof (state)\nthis:\n  I (s ! k) = i \\<and> k < length s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "hence \"ext_ids s ! (Suc k) = \\<lbrakk>i\\<rbrakk> \\<and> Suc k < length (ext_ids s)\""], ["proof (prove)\nusing this:\n  I (s ! k) = i \\<and> k < length s\n\ngoal (1 subgoal):\n 1. ext_ids s ! Suc k = \\<lbrakk>i\\<rbrakk> \\<and>\n    Suc k < length (ext_ids s)", "by (simp add:ext_ids_def nth_append)"], ["proof (state)\nthis:\n  ext_ids s ! Suc k = \\<lbrakk>i\\<rbrakk> \\<and> Suc k < length (ext_ids s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "hence g:\"idx s \\<lbrakk>i\\<rbrakk> = Inr (Suc k)\""], ["proof (prove)\nusing this:\n  ext_ids s ! Suc k = \\<lbrakk>i\\<rbrakk> \\<and> Suc k < length (ext_ids s)\n\ngoal (1 subgoal):\n 1. idx s \\<lbrakk>i\\<rbrakk> = Inr (Suc k)", "apply (simp add:fromSingleton_simp filt_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ext_ids s ! Suc k = \\<lbrakk>i\\<rbrakk> \\<and>\n    Suc k < length (ext_ids s) \\<Longrightarrow>\n    \\<forall>y<length (ext_ids s).\n       ext_ids s ! y = \\<lbrakk>i\\<rbrakk> \\<longrightarrow> Suc k = y", "using dist_ext_ids nth_eq_iff_index_eq"], ["proof (prove)\nusing this:\n  distinct (ext_ids s)\n  \\<lbrakk>distinct ?xs; ?i < length ?xs; ?j < length ?xs\\<rbrakk>\n  \\<Longrightarrow> (?xs ! ?i = ?xs ! ?j) = (?i = ?j)\n\ngoal (1 subgoal):\n 1. ext_ids s ! Suc k = \\<lbrakk>i\\<rbrakk> \\<and>\n    Suc k < length (ext_ids s) \\<Longrightarrow>\n    \\<forall>y<length (ext_ids s).\n       ext_ids s ! y = \\<lbrakk>i\\<rbrakk> \\<longrightarrow> Suc k = y", "by fastforce"], ["proof (state)\nthis:\n  idx s \\<lbrakk>i\\<rbrakk> = Inr (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "moreover"], ["proof (state)\nthis:\n  idx s \\<lbrakk>i\\<rbrakk> = Inr (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "define t where \"t = List.list_update s k (delete (s ! k))\""], ["proof (state)\nthis:\n  t = s[k := delete (s ! k)]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "ultimately"], ["proof (chain)\npicking this:\n  idx s \\<lbrakk>i\\<rbrakk> = Inr (Suc k)\n  t = s[k := delete (s ! k)]", "have a: \"integrate_delete m s = Inr t\""], ["proof (prove)\nusing this:\n  idx s \\<lbrakk>i\\<rbrakk> = Inr (Suc k)\n  t = s[k := delete (s ! k)]\n\ngoal (1 subgoal):\n 1. integrate_delete m s = Inr t", "using k_def DeleteMessage"], ["proof (prove)\nusing this:\n  idx s \\<lbrakk>i\\<rbrakk> = Inr (Suc k)\n  t = s[k := delete (s ! k)]\n  I (s ! k) = i \\<and> k < length s\n  m = DeleteMessage i\n\ngoal (1 subgoal):\n 1. integrate_delete m s = Inr t", "by (cases \"s ! k\", simp)"], ["proof (state)\nthis:\n  integrate_delete m s = Inr t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "have \"\\<And>j. j < length s \\<Longrightarrow> (DeleteMessage (I(s ! j)) = m) = (j = k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length s \\<Longrightarrow>\n       (DeleteMessage (I (s ! j)) = m) = (j = k)", "apply (simp add: DeleteMessage)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. j < length s \\<Longrightarrow> (I (s ! j) = i) = (j = k)", "using I_inj_on_S k_def"], ["proof (prove)\nusing this:\n  ?l < length s \\<and>\n  ?u < length s \\<and> I (s ! ?l) = I (s ! ?u) \\<Longrightarrow>\n  ?l = ?u\n  I (s ! k) = i \\<and> k < length s\n\ngoal (1 subgoal):\n 1. \\<And>j. j < length s \\<Longrightarrow> (I (s ! j) = i) = (j = k)", "by blast"], ["proof (state)\nthis:\n  ?j7 < length s \\<Longrightarrow>\n  (DeleteMessage (I (s ! ?j7)) = m) = (?j7 = k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "hence \"List.list_update s k (delete (s ! k)) = map delete_only_m s\""], ["proof (prove)\nusing this:\n  ?j7 < length s \\<Longrightarrow>\n  (DeleteMessage (I (s ! ?j7)) = m) = (?j7 = k)\n\ngoal (1 subgoal):\n 1. s[k := delete (s ! k)] = map delete_only_m s", "by (rule_tac nth_equalityI, (simp add:k_def delete_only_m_def)+)"], ["proof (state)\nthis:\n  s[k := delete (s ! k)] = map delete_only_m s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "hence \"set t = delete_only_m ` set s\""], ["proof (prove)\nusing this:\n  s[k := delete (s ! k)] = map delete_only_m s\n\ngoal (1 subgoal):\n 1. set t = delete_only_m ` set s", "using t_def"], ["proof (prove)\nusing this:\n  s[k := delete (s ! k)] = map delete_only_m s\n  t = s[k := delete (s ! k)]\n\ngoal (1 subgoal):\n 1. set t = delete_only_m ` set s", "by auto"], ["proof (state)\nthis:\n  set t = delete_only_m ` set s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "also"], ["proof (state)\nthis:\n  set t = delete_only_m ` set s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "have \"... = to_woot_character (M \\<union> {Delete m}) ` (insert_messages M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_only_m ` set s =\n    to_woot_character (M \\<union> {Delete m}) ` insert_messages M", "using set_s delete_only_m_effect image_cong"], ["proof (prove)\nusing this:\n  set s = to_woot_character M ` insert_messages M\n  delete_only_m (to_woot_character M ?x) =\n  to_woot_character (M \\<union> {Delete m}) ?x\n  \\<lbrakk>?M = ?N;\n   \\<And>x. x \\<in> ?N \\<Longrightarrow> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?M = ?g ` ?N\n\ngoal (1 subgoal):\n 1. delete_only_m ` set s =\n    to_woot_character (M \\<union> {Delete m}) ` insert_messages M", "by (metis (no_types, lifting) image_image)"], ["proof (state)\nthis:\n  delete_only_m ` set s =\n  to_woot_character (M \\<union> {Delete m}) ` insert_messages M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "finally"], ["proof (chain)\npicking this:\n  set t = to_woot_character (M \\<union> {Delete m}) ` insert_messages M", "have b:\n    \"set t = to_woot_character (M \\<union> {Delete m}) ` (insert_messages (M \\<union> {Delete m}))\""], ["proof (prove)\nusing this:\n  set t = to_woot_character (M \\<union> {Delete m}) ` insert_messages M\n\ngoal (1 subgoal):\n 1. set t =\n    to_woot_character (M \\<union> {Delete m}) `\n    insert_messages (M \\<union> {Delete m})", "by (simp add: insert_messages_def)"], ["proof (state)\nthis:\n  set t =\n  to_woot_character (M \\<union> {Delete m}) `\n  insert_messages (M \\<union> {Delete m})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "have \"ext_ids s = ext_ids t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ext_ids s = ext_ids t", "apply (cases \"s ! k\", simp add:t_def ext_ids_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       s ! k = InsertMessage x1 x2 x3 x4 \\<Longrightarrow>\n       map (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>) s =\n       map (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>)\n        (s[k := InsertMessage x1 x2 x3 None])", "by (metis (no_types, lifting) insert_message.sel(2) list_update_id map_update)"], ["proof (state)\nthis:\n  ext_ids s = ext_ids t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "moreover"], ["proof (state)\nthis:\n  ext_ids s = ext_ids t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "have \"\\<And>a. a_conditions (insert_messages M) a \\<Longrightarrow> sorted_wrt (<) (map a (ext_ids s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a_conditions (insert_messages M) a \\<Longrightarrow>\n       sorted_wrt (<) (map a (ext_ids s))", "using associated_string_assm is_associated_string_def"], ["proof (prove)\nusing this:\n  is_associated_string M s\n  is_associated_string ?M ?s \\<equiv>\n  consistent ?M \\<and>\n  set ?s = to_woot_character ?M ` insert_messages ?M \\<and>\n  (\\<forall>a.\n      a_conditions (insert_messages ?M) a \\<longrightarrow>\n      sorted_wrt (<) (map a (ext_ids ?s)))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a_conditions (insert_messages M) a \\<Longrightarrow>\n       sorted_wrt (<) (map a (ext_ids s))", "by blast"], ["proof (state)\nthis:\n  a_conditions (insert_messages M) ?a7 \\<Longrightarrow>\n  sorted_wrt (<) (map ?a7 (ext_ids s))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "ultimately"], ["proof (chain)\npicking this:\n  ext_ids s = ext_ids t\n  a_conditions (insert_messages M) ?a7 \\<Longrightarrow>\n  sorted_wrt (<) (map ?a7 (ext_ids s))", "have c: \"\\<And>a. a_conditions (insert_messages (M \\<union> {Delete m})) a\n                  \\<Longrightarrow> sorted_wrt (<) (map a (ext_ids t))\""], ["proof (prove)\nusing this:\n  ext_ids s = ext_ids t\n  a_conditions (insert_messages M) ?a7 \\<Longrightarrow>\n  sorted_wrt (<) (map ?a7 (ext_ids s))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a_conditions (insert_messages (M \\<union> {Delete m}))\n        a \\<Longrightarrow>\n       sorted_wrt (<) (map a (ext_ids t))", "by (simp add:insert_messages_def)"], ["proof (state)\nthis:\n  a_conditions (insert_messages (M \\<union> {Delete m}))\n   ?a7 \\<Longrightarrow>\n  sorted_wrt (<) (map ?a7 (ext_ids t))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = DeleteMessage x \\<Longrightarrow>\n       is_certified_associated_string (M \\<union> {Delete m})\n        (integrate_delete m s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Delete m})\n     (integrate_delete m s)", "apply (simp add:a is_associated_string_def b c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (insert (Delete m) M)", "using consistent_assm"], ["proof (prove)\nusing this:\n  consistent (M \\<union> {Delete m})\n\ngoal (1 subgoal):\n 1. consistent (insert (Delete m) M)", "by fastforce"], ["proof (state)\nthis:\n  is_certified_associated_string (M \\<union> {Delete m})\n   (integrate_delete m s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma integrate_delete_result:\n  assumes \"consistent (M \\<union> {Delete m})\"\n  assumes \"is_associated_string M s\"\n  shows \"is_certified_associated_string (M \\<union> {Delete m}) (integrate_delete m s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Delete m})\n     (integrate_delete m s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Delete m})\n     (integrate_delete m s)", "obtain a where a_def: \"a_conditions (insert_messages (M \\<union> {Delete m})) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a_conditions (insert_messages (M \\<union> {Delete m}))\n         a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using consistent_def assms"], ["proof (prove)\nusing this:\n  consistent ?M \\<equiv>\n  inj_on I (insert_messages ?M) \\<and>\n  \\<Union> (deps ` ?M) \\<subseteq> I ` insert_messages ?M \\<and>\n  wfP (depends_on (insert_messages ?M)) \\<and>\n  (\\<exists>a. a_conditions (insert_messages ?M) a)\n  consistent (M \\<union> {Delete m})\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a_conditions (insert_messages (M \\<union> {Delete m}))\n         a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a_conditions (insert_messages (M \\<union> {Delete m})) a\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Delete m})\n     (integrate_delete m s)", "moreover"], ["proof (state)\nthis:\n  a_conditions (insert_messages (M \\<union> {Delete m})) a\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Delete m})\n     (integrate_delete m s)", "have \"a_conditions (insert_messages M) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a_conditions (insert_messages M) a", "using assms a_subset is_associated_string_def a_def"], ["proof (prove)\nusing this:\n  consistent (M \\<union> {Delete m})\n  is_associated_string M s\n  \\<lbrakk>?M \\<subseteq> ?N; a_conditions (insert_messages ?N) ?a\\<rbrakk>\n  \\<Longrightarrow> a_conditions (insert_messages ?M) ?a\n  is_associated_string ?M ?s \\<equiv>\n  consistent ?M \\<and>\n  set ?s = to_woot_character ?M ` insert_messages ?M \\<and>\n  (\\<forall>a.\n      a_conditions (insert_messages ?M) a \\<longrightarrow>\n      sorted_wrt (<) (map a (ext_ids ?s)))\n  a_conditions (insert_messages (M \\<union> {Delete m})) a\n\ngoal (1 subgoal):\n 1. a_conditions (insert_messages M) a", "by blast"], ["proof (state)\nthis:\n  a_conditions (insert_messages M) a\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Delete m})\n     (integrate_delete m s)", "ultimately"], ["proof (chain)\npicking this:\n  a_conditions (insert_messages (M \\<union> {Delete m})) a\n  a_conditions (insert_messages M) a", "interpret integrate_insert_commute_delete \"M\" \"a\" \"s\" \"m\""], ["proof (prove)\nusing this:\n  a_conditions (insert_messages (M \\<union> {Delete m})) a\n  a_conditions (insert_messages M) a\n\ngoal (1 subgoal):\n 1. integrate_insert_commute_delete M a s m", "using assms"], ["proof (prove)\nusing this:\n  a_conditions (insert_messages (M \\<union> {Delete m})) a\n  a_conditions (insert_messages M) a\n  consistent (M \\<union> {Delete m})\n  is_associated_string M s\n\ngoal (1 subgoal):\n 1. integrate_insert_commute_delete M a s m", "by (simp add: integrate_insert_commute_def integrate_insert_commute_delete.intro\n            integrate_insert_commute_delete_axioms.intro)"], ["proof (state)\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Delete m})\n     (integrate_delete m s)", "show \"?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Delete m})\n     (integrate_delete m s)", "using integrate_delete_result"], ["proof (prove)\nusing this:\n  is_certified_associated_string (M \\<union> {Delete m})\n   (integrate_delete m s)\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {Delete m})\n     (integrate_delete m s)", "by blast"], ["proof (state)\nthis:\n  is_certified_associated_string (M \\<union> {Delete m})\n   (integrate_delete m s)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun is_delete :: \"(('a, 's) message) \\<Rightarrow> bool\" \n  where \n    \"is_delete (Insert m) = False\" |\n    \"is_delete (Delete m) = True\""], ["", "proposition integrate_insert_commute:\n  assumes \"consistent (M \\<union> {m})\"\n  assumes \"is_delete m \\<or> m \\<notin> M\"\n  assumes \"is_associated_string M s\"\n  shows \"is_certified_associated_string (M \\<union> {m}) (integrate s m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {m}) (integrate s m)", "using assms integrate_insert_result integrate_delete_result"], ["proof (prove)\nusing this:\n  consistent (M \\<union> {m})\n  is_delete m \\<or> m \\<notin> M\n  is_associated_string M s\n  \\<lbrakk>consistent (?M \\<union> {Insert ?m}); Insert ?m \\<notin> ?M;\n   is_associated_string ?M ?s\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string (?M \\<union> {Insert ?m})\n                     (integrate_insert ?m ?s (P ?m) (S ?m))\n  \\<lbrakk>consistent (?M \\<union> {Delete ?m});\n   is_associated_string ?M ?s\\<rbrakk>\n  \\<Longrightarrow> is_certified_associated_string (?M \\<union> {Delete ?m})\n                     (integrate_delete ?m ?s)\n\ngoal (1 subgoal):\n 1. is_certified_associated_string (M \\<union> {m}) (integrate s m)", "by (cases m, fastforce+)"], ["", "end"]]}