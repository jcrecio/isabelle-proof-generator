{"file_name": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency/SortKeys.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency", "problem_names": ["lemma sort_dir_less_def [simp]: \"(x < y) = (x = Left \\<and> y = Right)\"", "lemma embed_dir_inj [simp]: \"(embed_dir x = embed_dir y) = (x = y)\"", "lemma embed_dir_mono [simp]: \"(embed_dir x < embed_dir y) = (x < y)\"", "lemma sort_key_embedding_injective: \n  \"sort_key_embedding x = sort_key_embedding y \\<Longrightarrow> x = y\""], "translations": [["", "lemma sort_dir_less_def [simp]: \"(x < y) = (x = Left \\<and> y = Right)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x = sort_dir.Left \\<and> y = sort_dir.Right)", "by (cases x, case_tac [!] y, simp_all add:less_sort_dir_def)"], ["", "datatype 'a sort_key = \n  NonFinal \"('a \\<times> sort_dir)\" \"'a sort_key\" | \n  Final 'a"], ["", "type_synonym 'id position = \"'id sort_key extended\""], ["", "fun embed_dir where \"embed_dir (x,Left) = (x, 0)\" | \"embed_dir (x,Right) = (x, Suc (Suc 0))\""], ["", "lemma embed_dir_inj [simp]: \"(embed_dir x = embed_dir y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (embed_dir x = embed_dir y) = (x = y)", "by (cases x, cases y, case_tac [!] \"snd x\", case_tac [!] \"snd y\", simp+)"], ["", "lemma embed_dir_mono [simp]: \"(embed_dir x < embed_dir y) = (x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (embed_dir x < embed_dir y) = (x < y)", "by (cases x, cases y, case_tac [!] \"snd x\", case_tac [!] \"snd y\", (simp add:less_sort_dir_def)+)"], ["", "fun sort_key_embedding :: \"'a sort_key \\<Rightarrow> ('a \\<times> nat) list\"\n  where \n   \"sort_key_embedding (NonFinal x y) = embed_dir x#(sort_key_embedding y)\" |\n   \"sort_key_embedding (Final i) = [(i, Suc 0)]\""], ["", "lemma sort_key_embedding_injective: \n  \"sort_key_embedding x = sort_key_embedding y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_key_embedding x = sort_key_embedding y \\<Longrightarrow> x = y", "apply (induct x arbitrary: y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x y.\n       \\<lbrakk>\\<And>y.\n                   sort_key_embedding x =\n                   sort_key_embedding y \\<Longrightarrow>\n                   x = y;\n        sort_key_embedding (NonFinal x1 x) = sort_key_embedding y\\<rbrakk>\n       \\<Longrightarrow> NonFinal x1 x = y\n 2. \\<And>x y.\n       sort_key_embedding (Final x) = sort_key_embedding y \\<Longrightarrow>\n       Final x = y", "apply (metis embed_dir_inj list.distinct(1) list.inject sort_key.exhaust\n      sort_key_embedding.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       sort_key_embedding (Final x) = sort_key_embedding y \\<Longrightarrow>\n       Final x = y", "by (metis fst_conv list.distinct(1) list.inject sort_key.exhaust\n      sort_key_embedding.simps)"], ["", "instantiation sort_key :: (ord) ord\nbegin"], ["", "definition sort_key_less_eq_def [simp]: \n  \"(x :: ('a :: ord) sort_key) \\<le> y \\<longleftrightarrow> \n    (sort_key_embedding x \\<le> sort_key_embedding y)\""], ["", "definition sort_key_less_def [simp]: \n  \"(x :: ('a :: ord) sort_key) < y \\<longleftrightarrow> \n    (sort_key_embedding x < sort_key_embedding y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a sort_key, ord_class)", ".."], ["", "end"], ["", "instantiation sort_key :: (order) order\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a sort_key, order_class)", "by (intro_classes, simp_all add: less_le_not_le sort_key_embedding_injective)"], ["", "end"], ["", "instantiation sort_key :: (linorder) linorder\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a sort_key, linorder_class)", "by (intro_classes, meson less_imp_le not_le sort_key_less_eq_def)"], ["", "end"], ["", "end"]]}