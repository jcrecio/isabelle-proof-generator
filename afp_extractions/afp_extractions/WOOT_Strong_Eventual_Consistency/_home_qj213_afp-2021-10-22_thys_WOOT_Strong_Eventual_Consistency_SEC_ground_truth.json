{"file_name": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency/SEC.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency", "problem_names": ["theorem (in dist_execution) no_failure:\n  fixes i\n  assumes \"is_valid_state_id i\"\n  shows \"isOK (state i)\"", "theorem (in dist_execution) strong_convergence:\n  assumes \"is_valid_state_id i\"\n  assumes \"is_valid_state_id j\"\n  assumes \"set (received_messages i) = set (received_messages j)\"\n  shows \"state i = state j\""], "translations": [["", "theorem (in dist_execution) no_failure:\n  fixes i\n  assumes \"is_valid_state_id i\"\n  shows \"isOK (state i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (state i)", "apply (cases \"state i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. state i = Inl a \\<Longrightarrow> isOK (state i)\n 2. \\<And>b. state i = Inr b \\<Longrightarrow> isOK (state i)", "by (metis assms state_is_associated_string is_certified_associated_string.simps(2), simp)"], ["", "text \\<open>The following theorem establishes that any pair of peers having received the same\nset of updates, will be in the same state.\\<close>"], ["", "theorem (in dist_execution) strong_convergence:\n  assumes \"is_valid_state_id i\"\n  assumes \"is_valid_state_id j\"\n  assumes \"set (received_messages i) = set (received_messages j)\"\n  shows \"state i = state j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state i = state j", "using state_is_associated_string is_certified_associated_string_unique"], ["proof (prove)\nusing this:\n  is_valid_state_id ?i \\<Longrightarrow>\n  is_certified_associated_string (set (received_messages ?i)) (state ?i)\n  \\<lbrakk>is_certified_associated_string ?M ?s;\n   is_certified_associated_string ?M ?t\\<rbrakk>\n  \\<Longrightarrow> ?s = ?t\n\ngoal (1 subgoal):\n 1. state i = state j", "by (metis assms)"], ["", "text \\<open>As we noted in Section~\\ref{sec:networkModel}, we have not assumed eventual delivery, but\n  a corollary of this theorem with the eventual delivery assumption implies eventual consistency.\n  Since finally all peer would have received all messages, i.e., an equal set.\\<close>"], ["", "section \\<open>Code generation\\<close>"], ["", "export_code integrate create_insert create_delete in Haskell\n  module_name WOOT file_prefix \"code\""], ["", "section \\<open>Proof Outline\\label{sec:proof_outline}\\<close>"], ["", "text \\<open>\n  In this section we outline and motivate the approach we took to prove the strong eventual\n  consistency of WOOT.\n\n  While introducing operation-based CRDTs Shapiro et al. also establish\n  \\cite{shapiro2011conflict}[Theorem 2.2]. If the following two conditions are met:\n  \\begin{itemize}\n    \\item\n      Concurrent operations commute, i.e., if a pair of operations @{text \"m\\<^sub>1\"},\n      @{text \"m\\<^sub>2\"} is concurrent with respect to the order induced by the happened-before\n      relation, and they are both applicable to a state @{text \"s\"}, then the message\n      @{text \"m\\<^sub>1\"} (resp. @{text \"m\\<^sub>2\"}) is still applicable on the state reached by\n      applying  @{text \"m\\<^sub>2\"} (resp. @{text \"m\\<^sub>1\"}) on @{text \"s\"} and the resulting\n      states are equal.\n    \\item Assuming causal delivery, the messages are applicable.\n  \\end{itemize}\n  Then the CRDT has strong convergence.\n  The same authors extend the above result in \\cite[Proposition 2.2]{shapiro:inria-00555588}\n  to more general delivery orders $\\xrightarrow{d}$ (weaker than the one induced by the\n  happened-before relation), i.e., two messages may be causally dependent but concurrent with\n  respect to $\\xrightarrow{d}$. Assuming operations that are concurrent with respect to\n  $\\xrightarrow{d}$ commute, and messages are applicable, when the\n  delivery order respects $\\xrightarrow{d}$ then again the CRDT has strong convergence.\n\n  A key difficulty of the consistency proof of the WOOT framework is that the applicability\n  condition for the WOOT framework has three constraints:\n  \\begin{enumerate}\n    \\item \\label{en:proof:deps_are_met} Dependencies must be met.\n    \\item \\label{en:proof:id_distinct} Identifiers must be distinct.\n    \\item The order must be consistent, i.e. the predecessor W-character must appear before the\n      successor W-character in the state an insert message is being integrated.\n  \\end{enumerate}\n\n  The first constraint is a direct consequence of the semantic causal delivery order. The uniqueness\n  of identifiers can be directly established by analyzing the implementation of the message creation\n  algorithms. Alternatively, Gomes et al.~\\cite{gomes2017verifying} use an axiomatic approach, where\n  they require the underlying network protocol to deliver messages with unique identifiers. They\n  provide a formal framework in Isabelle/HOL that can be used to show consistency of arbitrary\n  CRDTs. Their results could be used to establish constraints \\ref{en:proof:deps_are_met} and\n  \\ref{en:proof:id_distinct}.\n\n  The last constraint is the most intricate one, and forces us to use a different method to\n  establish the strong eventual consistency. The fact that the order constraint is fulfilled is a\n  consequence of the consistency property. But the current fundamental lemmas require applicability\n  of the operations in the first place to establish consistency, which would result in a circular\n  argument.\n\n  Zeller et. al. actually predict the above circumstance in the context of state-based CRDTs\n  \\cite{DBLP:conf/forte/ZellerBP14}:\n  \\begin{displayquote}\n  In theory it could even be the case that there are two reachable states for which the merge\n  operation does not yield the correct result, but where the two states can never be reached in the\n  same execution.\n  \\end{displayquote}\n\n  Because of the above, we treat WOOT as a distributed message passing algorithm and show\n  convergence by establishing a global invariant, which is maintained during the execution of the\n  framework. The invariant captures that the W-characters appear in the same order on all peers.\n  It has strong convergence as a consequence, in the special case, when peers have received\n  the same set of updates. It also implies that the generated messages will be applicable.\n\n  \\begin{figure}\n    \\centering\n    \\begin{tikzpicture}[\n      statenode/.style={circle, draw=black, fill=black!20, thick, minimum size=5mm},\n      curstatenode/.style={circle, draw=black, fill=black!60, thick, minimum size=5mm},\n      peernode/.style={rectangle, draw=black, thick, minimum size=5mm},\n    ]\n    %Nodes\n    \\node[peernode] (peerA) at (1.5cm, 3cm) {Peer A};\n    \\node[peernode] (peerB) at (1.5cm, 2cm) {Peer B};\n    \\node[peernode] (peerC) at (1.5cm, 1cm) {Peer C};\n    \\node[statenode] (stateA2) at (4cm, 3cm) {};\n    \\node[curstatenode] (stateB2) at (5cm, 2cm) {};\n    \\node[statenode] (stateC2) at (3.5cm, 1cm) {};\n    \\node[statenode] (stateA3) at (5.5cm, 3cm) {};\n    \\node[statenode] (stateB3) at (7cm, 2cm) {};\n    \\node[statenode] (stateC3) at (6.5cm, 1cm) {};\n    \\node[statenode] (stateA4) at (7.5cm, 3cm) {};\n    \\draw[->] (peerA.east) -- (stateA2.west);\n    \\draw[->] (peerB.east) -- (stateB2.west);\n    \\draw[->] (peerC.east) -- (stateC2.west);\n    \\draw[->] (stateA2.east) -- (stateA3.west);\n    \\draw[->] (stateB2.east) -- (stateB3.west);\n    \\draw[->] (stateC2.east) -- (stateC3.west);\n    \\draw[->] (stateC2) -- (stateA2);\n    \\draw[->] (stateC2) -- (stateB2);\n    \\draw[->] (stateA3) -- (stateC3);\n    \\draw[->] (stateA3) -- (stateB3);\n    \\draw[->] (stateA3) -- (stateA4);\n    \\draw (5cm,3.5cm) to[bend right] (4.8cm,0.5cm);\n    \\end{tikzpicture}\n    \\caption{Example state graph, where the consistency is established left of the bend curve.}\n    \\label{fig:state_graph}\n  \\end{figure}\n\n  In Figure~\\ref{fig:state_graph}, we exemplify an induction step in a proof over the execution\n  of the framework. The invariant is established for all states left of the dashed lines, and we\n  show that it remains true if we include the state, drawn in dark gray. Note that induction\n  proceeds in an order consistent with the happened-before relation.\n\n  The technique we are using is to define a relation @{term is_associated_string} from a set of\n  messages to the final state their application leads to. Crucially, that relation can be defined\n  in a message-order independent way. We show that it correctly models the behaviour of Algorithm\n  @{term \"integrate\"} by establishing that applying the integration algorithm to the associated\n  string of a set @{term \"M\"} leads to the associated string of the set @{term \"M \\<union> {m}\"}\n  in Proposition @{thm [source] integrate_insert_commute}.\n\n  We also show that at most one @{text s} fulfills @{term \"is_associated_string M s\"},\n  which automatically implies commutativity (cf. Lemma @{thm [source] \"associated_string_unique\"}).\n\n  Note that the domain of the relation @{term \"is_associated_string\"} consists of the sets of\n  messages that we call @{term \"consistent\"}. We show that, in every state of a peer, the set of\n  received messages will be consistent.\n  The main ingredient required for the definition of a consistent set of messages as the relation\n  @{term \"is_associated_string\"} are \\emph{sort keys} associated to the W-characters, which we will\n  explain in the following Section.\n\\<close>"], ["", "subsection \\<open> Sort Keys \\<close>"], ["", "text \\<open>\n  There is an implicit sort key, which is deterministically computable, using the immutable data\n  associated to a W-character and the data of the W-characters it (transitively) depends on.\n\n  We show that Algorithm @{term \"integrate\"} effectively maintains the W-characters ordered with\n  respect to that sort key, which is the reason we can construct the mapping\n  @{term \"is_associated_string\"} in a message-order\n  independent way. An alternative viewpoint would be to see Algorithm @{term \"integrate_insert\"} as\n  an optimized version of a more mundane algorithm, that just inserts the W-characters using this\n  implicit sort key.\n\n  Since the sort key is deterministically computable using the immutable data associated to a\n  W-character and the data of the W-characters it (transitively) depends on, all peers could\n  perform this computation independently, which leads to the conclusion that the W-characters\n  will be ordered consistently across all peers.\n\n  The construction relies on a combinator @{term \"\\<Psi>\"} that computes the sort key for a\n  W-character, and which requires as input:\n  \\begin{itemize}\n    \\item The unique identifier associated to a W-character.\n    \\item The sort keys of the predecessor/successor W-characters.\n  \\end{itemize}\n  Its values are elements of a totally ordered space.\n\n  Note that the predecessor (resp. successor) W-character of a W-character is the W-character that\n  was immediately before (resp. after) it at the time it was inserted. Like its unique identifier,\n  it is immutable data associated with that W-character. Sometimes a W-character is inserted at the\n  beginning (resp. end) of the string. For those W-characters, we use the special smallest\n  (resp. largest) sort keys, denoted by @{term \"\\<turnstile>\"} (resp. @{term \"\\<stileturn>\"}) as predecessor\n  (resp. successor). These keys themselves are never associated to a W-character.\n\n  We will write @{term \"\\<Psi> (l,u) i\"} for the value computed by the combinator for a W-character\n  with identifier @{term \"i\"}, assuming the sort key of its predecessor (resp. successor) is\n  @{term \"l\"} (resp. @{term \"u\"}).\n\n  For example, the sort key for a W-character with identifier @{term \"i\"} inserted in an empty\n  string (hence its predecessor is @{term \"\\<turnstile>\"} and its successor is @{term \"\\<stileturn>\"}) \n  will be  @{term \"\\<Psi> (\\<turnstile>,\\<stileturn>) i\"}. A W-character\n  inserted between that character and the end of the string, with identifier j, would be assigned\n  the sort key @{term \"\\<Psi> (\\<lbrakk>\\<Psi> (\\<turnstile>,\\<stileturn>) i\\<rbrakk>,\\<stileturn>) j\"}.\n\n  The sort key needs to fulfill a couple of properties, to be useful:\n\n  There should never be a pair of W-characters with the same sort key. Note, if this happens, even\n  if those W-characters were equal or ordered consistently, we would not be able to insert a new\n  W-character between those W-characters.\n\n  Since the W-characters have themselves unique identifiers, a method to insure the above property\n  is to require that @{term \"\\<Psi>\"} be injective with respect to the identifier of the W-character\n  it computes a sort key for, i.e.,\n  @{term \"\\<Psi> (l,u) i = \\<Psi> (l',u') i' \\<Longrightarrow> i = i'\"}.\n\n  Another essential property is that the W-characters with predecessor having the sort key\n  @{term \"l\"} and successor having the sort key @{term \"u\"}  should have a sort key that is between\n  @{term \"l\"} and @{term \"u\"}, such that the W-character is inserted between the preceding and\n  succeeding W-character, i.e., @{text \"l < \\<Psi> (l,u) i < u\"}.\n\n  This latter property ensures intention preservation, i.e. the inserted W-character will be placed\n  at the place the user intended.\n\n  If we review function @{term \"concurrent\"}, then we see that the algorithm compares W-characters\n  by identifier, in the special case, when the inserted W-character is compared to a W-character\n  whose predecessor and successor are outside of the range it is to be inserted in. A careful\n  investigation, leads to the conclusion that:\n\n  If @{text \"l \\<le> l' < \\<Psi> (l,u) i < u' \\<le> u\"} then @{text \"\\<Psi>(l,u) i\"} can be compared\n  with @{text \"\\<Psi>(l',u') i'\"} by comparing @{text \"i\"} with @{text \"i'\"}, i.e.:\n  \\begin{itemize}\n    \\item @{text \"i < i' \\<Longrightarrow> \\<Psi> (l,u) i < \\<Psi>(l',u') i'\"}\n  \\end{itemize}\n\n  In Section \\ref{sec:psi} we show that a combinator @{term \"\\<Psi>\"} with the above properties can\n  be constructed (cf. Propositions @{thm [source] psi_narrow psi_mono psi_elem}).\n  Using the sort keys we can define the notion of a consistent set of messages as well as the\n  relation @{term \"is_associated_string\"} in a message-order independent way.\\<close>"], ["", "subsection \\<open> Induction \\<close>"], ["", "text \\<open>\n  We have a couple of criteria that define a consistent set of messages:\n\n  \\begin{itemize}\n    \\item Each insert message in the set has a unique identifier.\n    \\item If a message depends on another message identifier, a message with that identifier will\n      be present. Note that for insert messages, these are the predecessor/successor W-characters\n      if present. For delete messages it is the corresponding insert message.\n    \\item The dependencies form a well-order, i.e., there is no dependency cycle.\n    \\item It is possible to assign sort keys to each insert message, such that\n      the assigned sort key for each insert message is equal to the value returned by the\n      @{term \"\\<Psi>\"} for it, using the associated sort keys of its predecessor and successors,\n      i.e.,\n      @{term \"a (P m) < a (S m) \\<and>\n              a \\<lbrakk>I m\\<rbrakk> = \\<lbrakk>\\<Psi> (a (P m), a (S m)) (I m)\\<rbrakk>\"}.\n      Note that we also require that sort key of the predecessor is smaller than the sort key of the\n      successor.\n  \\end{itemize}\n\n  The relation @{term \"is_associated_string\"} is then defined by ordering the insert messages\n  according to the assigned sort keys above and marking W-characters, for which there are delete\n  messages as deleted.\n\n  The induction proof (Lemma @{thm [source] dist_execution.sent_messages_consistent}) over the\n  states of the framework is straight forward: Using Lemma @{thm [source] top_sort} we find a\n  possible order of the states consistent with the happened before relation. The induction invariant\n  is that the set of generated messages by all peers is\n  consistent (independent of whether they have been received by all peers (yet)). The latter also\n  implies that the subset a peer has received in any of those states is consistent, using the\n  additional fact that each messages dependencies will be delivered before the message itself\n  (see also Lemma @{thm [source] consistent_subset} and\n  Proposition @{thm [source] integrate_insert_commute'}).\n  For the induction step, we rely on the results from Section \\ref{sec:create_consistent} that any\n  additional created messages will keep the set of messages consistent and that the peers' states\n  will be consistent with the (consistent subset of) messages they received (Lemma @{thm [source]\n  dist_execution.state_is_associated_string'}).\\<close>"], ["", "end"]]}