{"file_name": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency/Sorting.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency", "problem_names": ["lemma insort:\n  assumes \"Suc l < length s\"\n  assumes \"s ! l < (v :: 'a :: linorder)\"\n  assumes \"s ! (l+1) > v\"\n  assumes \"sorted_wrt (<) s\"\n  shows \"sorted_wrt (<) ((take (Suc l) s)@v#(drop (Suc l) s))\"", "lemma sorted_wrt_irrefl_distinct:\n  assumes \"irreflp r\"\n  shows \"sorted_wrt r xs \\<longrightarrow> distinct xs\"", "lemma sort_set_unique_h:\n  assumes \"irreflp r \\<and> transp r\"\n  assumes \"set (x#xs) = set (y#ys)\" \n  assumes \"\\<forall>z \\<in> set xs. r x z\" \n  assumes \"\\<forall>z \\<in> set ys. r y z\" \n  shows \"x = y \\<and> set xs = set ys\"", "lemma sort_set_unique_rel:\n  assumes \"irreflp r \\<and> transp r\"\n  assumes \"set x = set y\"\n  assumes \"sorted_wrt r x\"\n  assumes \"sorted_wrt r y\"\n  shows \"x = y\"", "lemma sort_set_unique:\n  assumes \"set x = set y\"\n  assumes \"sorted_wrt (<) (map (f :: ('a \\<Rightarrow> ('b :: linorder)))  x)\"\n  assumes \"sorted_wrt (<) (map f y)\"\n  shows \"x = y\"", "lemma subseq_imp_sorted:\n  assumes \"subseq s t\"\n  assumes \"sorted_wrt p t\"\n  shows \"sorted_wrt p s\"", "lemma trancl_idemp: \"r\\<^sup>+\\<^sup>+\\<^sup>+\\<^sup>+ x y = r\\<^sup>+\\<^sup>+ x y\"", "lemma top_sort:\n  fixes rp\n  assumes \"acyclicP r\"\n  shows \"finite s \\<longrightarrow> (\\<exists>l. set l = s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)\"", "lemma top_sort_eff:\n  assumes \"irreflp p\\<^sup>+\\<^sup>+\"\n  assumes \"sorted_wrt (to_ord p) x\" \n  assumes \"i < length x\"\n  assumes \"j < length x\"\n  assumes \"(p\\<^sup>+\\<^sup>+ (x ! i) (x ! j))\"\n  shows \"i < j\""], "translations": [["", "lemma insort:\n  assumes \"Suc l < length s\"\n  assumes \"s ! l < (v :: 'a :: linorder)\"\n  assumes \"s ! (l+1) > v\"\n  assumes \"sorted_wrt (<) s\"\n  shows \"sorted_wrt (<) ((take (Suc l) s)@v#(drop (Suc l) s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ v # drop (Suc l) s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ v # drop (Suc l) s)", "have \"sorted_wrt (<) (take (Suc l) s@(drop (Suc l) s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ drop (Suc l) s)", "using assms(4)"], ["proof (prove)\nusing this:\n  sorted_wrt (<) s\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ drop (Suc l) s)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt (<) (take (Suc l) s @ drop (Suc l) s)\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ v # drop (Suc l) s)", "moreover"], ["proof (state)\nthis:\n  sorted_wrt (<) (take (Suc l) s @ drop (Suc l) s)\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ v # drop (Suc l) s)", "have\n    \"\\<And>x. x \\<in> set (take (Suc l) s) = (\\<exists>i. i < (Suc l) \\<and> i < length s \\<and> s ! i = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (take (Suc l) s)) =\n       (\\<exists>i<Suc l. i < length s \\<and> s ! i = x)", "by (metis in_set_conv_nth length_take min_less_iff_conj nth_take)"], ["proof (state)\nthis:\n  (?x \\<in> set (take (Suc l) s)) =\n  (\\<exists>i<Suc l. i < length s \\<and> s ! i = ?x)\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ v # drop (Suc l) s)", "hence \"\\<And>x. x \\<in> set (take (Suc l) s) \\<Longrightarrow> x < v\""], ["proof (prove)\nusing this:\n  (?x \\<in> set (take (Suc l) s)) =\n  (\\<exists>i<Suc l. i < length s \\<and> s ! i = ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (take (Suc l) s) \\<Longrightarrow> x < v", "using assms"], ["proof (prove)\nusing this:\n  (?x \\<in> set (take (Suc l) s)) =\n  (\\<exists>i<Suc l. i < length s \\<and> s ! i = ?x)\n  Suc l < length s\n  s ! l < v\n  v < s ! (l + 1)\n  sorted_wrt (<) s\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (take (Suc l) s) \\<Longrightarrow> x < v", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<exists>i<Suc l. i < length s \\<and> s ! i = x;\n        \\<And>x.\n           (x \\<in> set (take (Suc l) s)) =\n           (\\<exists>i<Suc l. i < length s \\<and> s ! i = x);\n        Suc l < length s; s ! l < v; v < s ! Suc l;\n        sorted_wrt (<) s\\<rbrakk>\n       \\<Longrightarrow> x < v", "using less_Suc_eq sorted_wrt_nth_less"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n  \\<lbrakk>sorted_wrt ?P ?xs; ?i < ?j; ?j < length ?xs\\<rbrakk>\n  \\<Longrightarrow> ?P (?xs ! ?i) (?xs ! ?j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<exists>i<Suc l. i < length s \\<and> s ! i = x;\n        \\<And>x.\n           (x \\<in> set (take (Suc l) s)) =\n           (\\<exists>i<Suc l. i < length s \\<and> s ! i = x);\n        Suc l < length s; s ! l < v; v < s ! Suc l;\n        sorted_wrt (<) s\\<rbrakk>\n       \\<Longrightarrow> x < v", "by fastforce"], ["proof (state)\nthis:\n  ?x \\<in> set (take (Suc l) s) \\<Longrightarrow> ?x < v\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ v # drop (Suc l) s)", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> set (take (Suc l) s) \\<Longrightarrow> ?x < v\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ v # drop (Suc l) s)", "have\n    \"\\<And>x. x \\<in> set (drop (Suc l) s) = (\\<exists>i. Suc l + i < length s \\<and> s ! (Suc l + i) = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (drop (Suc l) s)) =\n       (\\<exists>i. Suc l + i < length s \\<and> s ! (Suc l + i) = x)", "using assms(1)"], ["proof (prove)\nusing this:\n  Suc l < length s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (drop (Suc l) s)) =\n       (\\<exists>i. Suc l + i < length s \\<and> s ! (Suc l + i) = x)", "by (simp add:in_set_conv_nth add.commute less_diff_conv)"], ["proof (state)\nthis:\n  (?x \\<in> set (drop (Suc l) s)) =\n  (\\<exists>i. Suc l + i < length s \\<and> s ! (Suc l + i) = ?x)\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ v # drop (Suc l) s)", "hence \"\\<And>x. x \\<in> set (drop (Suc l) s) \\<Longrightarrow> x > v\""], ["proof (prove)\nusing this:\n  (?x \\<in> set (drop (Suc l) s)) =\n  (\\<exists>i. Suc l + i < length s \\<and> s ! (Suc l + i) = ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (drop (Suc l) s) \\<Longrightarrow> v < x", "using assms"], ["proof (prove)\nusing this:\n  (?x \\<in> set (drop (Suc l) s)) =\n  (\\<exists>i. Suc l + i < length s \\<and> s ! (Suc l + i) = ?x)\n  Suc l < length s\n  s ! l < v\n  v < s ! (l + 1)\n  sorted_wrt (<) s\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (drop (Suc l) s) \\<Longrightarrow> v < x", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<exists>i.\n                   Suc (l + i) < length s \\<and> s ! Suc (l + i) = x;\n        \\<And>x.\n           (x \\<in> set (drop (Suc l) s)) =\n           (\\<exists>i. Suc (l + i) < length s \\<and> s ! Suc (l + i) = x);\n        Suc l < length s; s ! l < v; v < s ! Suc l;\n        sorted_wrt (<) s\\<rbrakk>\n       \\<Longrightarrow> v < x", "by (metis add.right_neutral add_diff_cancel_left' diff_Suc_Suc diff_is_0_eq'\n        leI le_less_trans less_imp_le sorted_wrt_iff_nth_less)"], ["proof (state)\nthis:\n  ?x \\<in> set (drop (Suc l) s) \\<Longrightarrow> v < ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ v # drop (Suc l) s)", "ultimately"], ["proof (chain)\npicking this:\n  sorted_wrt (<) (take (Suc l) s @ drop (Suc l) s)\n  ?x \\<in> set (take (Suc l) s) \\<Longrightarrow> ?x < v\n  ?x \\<in> set (drop (Suc l) s) \\<Longrightarrow> v < ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt (<) (take (Suc l) s @ drop (Suc l) s)\n  ?x \\<in> set (take (Suc l) s) \\<Longrightarrow> ?x < v\n  ?x \\<in> set (drop (Suc l) s) \\<Longrightarrow> v < ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt (<) (take (Suc l) s @ v # drop (Suc l) s)", "by (simp add:sorted_wrt_append del:append_take_drop_id)"], ["proof (state)\nthis:\n  sorted_wrt (<) (take (Suc l) s @ v # drop (Suc l) s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_wrt_irrefl_distinct:\n  assumes \"irreflp r\"\n  shows \"sorted_wrt r xs \\<longrightarrow> distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt r xs \\<longrightarrow> distinct xs", "using assms"], ["proof (prove)\nusing this:\n  irreflp r\n\ngoal (1 subgoal):\n 1. sorted_wrt r xs \\<longrightarrow> distinct xs", "by (induction xs, simp, simp, meson irreflp_def)"], ["", "lemma sort_set_unique_h:\n  assumes \"irreflp r \\<and> transp r\"\n  assumes \"set (x#xs) = set (y#ys)\" \n  assumes \"\\<forall>z \\<in> set xs. r x z\" \n  assumes \"\\<forall>z \\<in> set ys. r y z\" \n  shows \"x = y \\<and> set xs = set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<and> set xs = set ys", "by (metis assms insert_eq_iff irreflp_def list.set_intros(1)\n      list.simps(15) set_ConsD transpD)"], ["", "lemma sort_set_unique_rel:\n  assumes \"irreflp r \\<and> transp r\"\n  assumes \"set x = set y\"\n  assumes \"sorted_wrt r x\"\n  assumes \"sorted_wrt r y\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have \"length x = length y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length x = length y", "using assms"], ["proof (prove)\nusing this:\n  irreflp r \\<and> transp r\n  set x = set y\n  sorted_wrt r x\n  sorted_wrt r y\n\ngoal (1 subgoal):\n 1. length x = length y", "by (metis sorted_wrt_irrefl_distinct distinct_card)"], ["proof (state)\nthis:\n  length x = length y\n\ngoal (1 subgoal):\n 1. x = y", "then"], ["proof (chain)\npicking this:\n  length x = length y", "show ?thesis"], ["proof (prove)\nusing this:\n  length x = length y\n\ngoal (1 subgoal):\n 1. x = y", "using assms"], ["proof (prove)\nusing this:\n  length x = length y\n  irreflp r \\<and> transp r\n  set x = set y\n  sorted_wrt r x\n  sorted_wrt r y\n\ngoal (1 subgoal):\n 1. x = y", "apply(induct rule:list_induct2, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys.\n       \\<lbrakk>length xs = length ys;\n        set xs = set ys \\<Longrightarrow> xs = ys;\n        insert xa (set xs) = insert ya (set ys);\n        (\\<forall>x\\<in>set xs. r xa x) \\<and> sorted_wrt r xs;\n        (\\<forall>x\\<in>set ys. r ya x) \\<and> sorted_wrt r ys;\n        length x = length y; irreflp r \\<and> transp r; set x = set y;\n        sorted_wrt r x; sorted_wrt r y\\<rbrakk>\n       \\<Longrightarrow> xa = ya \\<and> xs = ys", "by (metis assms(1) list.simps(15) sort_set_unique_h)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sort_set_unique:\n  assumes \"set x = set y\"\n  assumes \"sorted_wrt (<) (map (f :: ('a \\<Rightarrow> ('b :: linorder)))  x)\"\n  assumes \"sorted_wrt (<) (map f y)\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using assms"], ["proof (prove)\nusing this:\n  set x = set y\n  sorted_wrt (<) (map f x)\n  sorted_wrt (<) (map f y)\n\ngoal (1 subgoal):\n 1. x = y", "apply (simp add:sorted_wrt_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set x = set y; sorted_wrt (\\<lambda>x y. f x < f y) x;\n     sorted_wrt (\\<lambda>x y. f x < f y) y\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (metis (no_types, lifting) irreflp_def less_irrefl sort_set_unique_rel \n      transpD transpI transp_less)"], ["", "text \\<open>If two sequences contain the same element and strictly increasing with respect.\\<close>"], ["", "lemma subseq_imp_sorted:\n  assumes \"subseq s t\"\n  assumes \"sorted_wrt p t\"\n  shows \"sorted_wrt p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt p s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt p s", "have \"sorted_wrt p s \\<or> \\<not> sorted_wrt p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt p s \\<or> \\<not> sorted_wrt p t", "apply (rule list_emb.induct[where P=\"(=)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. subseq s t\n 2. \\<And>ys. sorted_wrt p [] \\<or> \\<not> sorted_wrt p ys\n 3. \\<And>xs ys y.\n       \\<lbrakk>subseq xs ys;\n        sorted_wrt p xs \\<or> \\<not> sorted_wrt p ys\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt p xs \\<or> \\<not> sorted_wrt p (y # ys)\n 4. \\<And>x y xs ys.\n       \\<lbrakk>x = y; subseq xs ys;\n        sorted_wrt p xs \\<or> \\<not> sorted_wrt p ys\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt p (x # xs) \\<or>\n                         \\<not> sorted_wrt p (y # ys)", "using list_emb_set assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>list_emb ?P ?xs ?ys; ?x \\<in> set ?xs;\n   \\<And>y.\n      \\<lbrakk>y \\<in> set ?ys; ?P ?x y\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  subseq s t\n  sorted_wrt p t\n\ngoal (4 subgoals):\n 1. subseq s t\n 2. \\<And>ys. sorted_wrt p [] \\<or> \\<not> sorted_wrt p ys\n 3. \\<And>xs ys y.\n       \\<lbrakk>subseq xs ys;\n        sorted_wrt p xs \\<or> \\<not> sorted_wrt p ys\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt p xs \\<or> \\<not> sorted_wrt p (y # ys)\n 4. \\<And>x y xs ys.\n       \\<lbrakk>x = y; subseq xs ys;\n        sorted_wrt p xs \\<or> \\<not> sorted_wrt p ys\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt p (x # xs) \\<or>\n                         \\<not> sorted_wrt p (y # ys)", "by fastforce+"], ["proof (state)\nthis:\n  sorted_wrt p s \\<or> \\<not> sorted_wrt p t\n\ngoal (1 subgoal):\n 1. sorted_wrt p s", "thus ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt p s \\<or> \\<not> sorted_wrt p t\n\ngoal (1 subgoal):\n 1. sorted_wrt p s", "using assms"], ["proof (prove)\nusing this:\n  sorted_wrt p s \\<or> \\<not> sorted_wrt p t\n  subseq s t\n  sorted_wrt p t\n\ngoal (1 subgoal):\n 1. sorted_wrt p s", "by blast"], ["proof (state)\nthis:\n  sorted_wrt p s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If a sequence @{text t} is sorted with respect to a relation @{text p} then a subsequence will \n  be as well.\\<close>"], ["", "fun to_ord where \"to_ord r x y = (\\<not>(r\\<^sup>*\\<^sup>* y x))\""], ["", "lemma trancl_idemp: \"r\\<^sup>+\\<^sup>+\\<^sup>+\\<^sup>+ x y = r\\<^sup>+\\<^sup>+ x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>+\\<^sup>+\\<^sup>+\\<^sup>+ x y = r\\<^sup>+\\<^sup>+ x y", "by (metis r_into_rtranclp reflclp_tranclp rtranclp_idemp rtranclp_reflclp \n      rtranclp_tranclp_tranclp tranclp.cases tranclp.r_into_trancl)"], ["", "lemma top_sort:\n  fixes rp\n  assumes \"acyclicP r\"\n  shows \"finite s \\<longrightarrow> (\\<exists>l. set l = s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite s \\<longrightarrow>\n    (\\<exists>l. set l = s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)", "proof (induction \"card s\" arbitrary:s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       0 = card s \\<Longrightarrow>\n       finite s \\<longrightarrow>\n       (\\<exists>l.\n           set l = s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)\n 2. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "case 0"], ["proof (state)\nthis:\n  0 = card s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       0 = card s \\<Longrightarrow>\n       finite s \\<longrightarrow>\n       (\\<exists>l.\n           set l = s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)\n 2. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "then"], ["proof (chain)\npicking this:\n  0 = card s", "show ?case"], ["proof (prove)\nusing this:\n  0 = card s\n\ngoal (1 subgoal):\n 1. finite s \\<longrightarrow>\n    (\\<exists>l. set l = s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)", "by auto"], ["proof (state)\nthis:\n  finite s \\<longrightarrow>\n  (\\<exists>l. set l = s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "case (Suc n)"], ["proof (state)\nthis:\n  n = card ?s \\<Longrightarrow>\n  finite ?s \\<longrightarrow>\n  (\\<exists>l. set l = ?s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)\n  Suc n = card s\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "hence \"s \\<noteq> {}\""], ["proof (prove)\nusing this:\n  n = card ?s \\<Longrightarrow>\n  finite ?s \\<longrightarrow>\n  (\\<exists>l. set l = ?s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)\n  Suc n = card s\n\ngoal (1 subgoal):\n 1. s \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "moreover"], ["proof (state)\nthis:\n  s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "have \"acyclicP (r\\<^sup>+\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclicP r\\<^sup>+\\<^sup>+", "using assms"], ["proof (prove)\nusing this:\n  acyclicP r\n\ngoal (1 subgoal):\n 1. acyclicP r\\<^sup>+\\<^sup>+", "by (simp add:acyclic_def trancl_def trancl_idemp)"], ["proof (state)\nthis:\n  acyclicP r\\<^sup>+\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "hence \"acyclic ({(x,y). r\\<^sup>+\\<^sup>+ x y} \\<inter> s \\<times> s)\""], ["proof (prove)\nusing this:\n  acyclicP r\\<^sup>+\\<^sup>+\n\ngoal (1 subgoal):\n 1. acyclic (Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s)", "by (meson acyclic_subset inf_le1)"], ["proof (state)\nthis:\n  acyclic (Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "hence \"wf ({(x,y). r\\<^sup>+\\<^sup>+ x y} \\<inter> s \\<times> s)\""], ["proof (prove)\nusing this:\n  acyclic (Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s)\n\ngoal (1 subgoal):\n 1. wf (Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s)", "using Suc"], ["proof (prove)\nusing this:\n  acyclic (Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s)\n  n = card ?s \\<Longrightarrow>\n  finite ?s \\<longrightarrow>\n  (\\<exists>l. set l = ?s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)\n  Suc n = card s\n\ngoal (1 subgoal):\n 1. wf (Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s)", "by (metis card.infinite finite_Int finite_SigmaI nat.distinct(1) \n        wf_iff_acyclic_if_finite)"], ["proof (state)\nthis:\n  wf (Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "ultimately"], ["proof (chain)\npicking this:\n  s \\<noteq> {}\n  wf (Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s)", "obtain z where \n    \"z \\<in> s \\<and> (\\<forall>y. (y, z) \\<in>  ({(x,y). r\\<^sup>+\\<^sup>+ x y} \\<inter> s \\<times> s) \\<longrightarrow> y \\<notin> s)\""], ["proof (prove)\nusing this:\n  s \\<noteq> {}\n  wf (Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        z \\<in> s \\<and>\n        (\\<forall>y.\n            (y, z)\n            \\<in> Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s \\<longrightarrow>\n            y \\<notin> s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis ex_in_conv wf_eq_minimal)"], ["proof (state)\nthis:\n  z \\<in> s \\<and>\n  (\\<forall>y.\n      (y, z) \\<in> Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s \\<longrightarrow>\n      y \\<notin> s)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "hence z_def: \"z \\<in> s \\<and> (\\<forall>y. r\\<^sup>+\\<^sup>+ y z \\<longrightarrow> y \\<notin> s)\""], ["proof (prove)\nusing this:\n  z \\<in> s \\<and>\n  (\\<forall>y.\n      (y, z) \\<in> Restr {(x, y). r\\<^sup>+\\<^sup>+ x y} s \\<longrightarrow>\n      y \\<notin> s)\n\ngoal (1 subgoal):\n 1. z \\<in> s \\<and>\n    (\\<forall>y. r\\<^sup>+\\<^sup>+ y z \\<longrightarrow> y \\<notin> s)", "by blast"], ["proof (state)\nthis:\n  z \\<in> s \\<and>\n  (\\<forall>y. r\\<^sup>+\\<^sup>+ y z \\<longrightarrow> y \\<notin> s)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "hence \"card (s - {z}) = n\""], ["proof (prove)\nusing this:\n  z \\<in> s \\<and>\n  (\\<forall>y. r\\<^sup>+\\<^sup>+ y z \\<longrightarrow> y \\<notin> s)\n\ngoal (1 subgoal):\n 1. card (s - {z}) = n", "by (metis One_nat_def Suc.hyps(2) card_Diff_singleton_if card.infinite \n        diff_Suc_Suc diff_zero nat.simps(3))"], ["proof (state)\nthis:\n  card (s - {z}) = n\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "then"], ["proof (chain)\npicking this:\n  card (s - {z}) = n", "obtain l where l_def: \n    \"set l = s - {z} \\<and> sorted_wrt (to_ord r) l \\<and> distinct l\""], ["proof (prove)\nusing this:\n  card (s - {z}) = n\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        set l = s - {z} \\<and>\n        sorted_wrt (to_ord r) l \\<and> distinct l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Zero_not_Suc card.infinite finite_Diff Suc)"], ["proof (state)\nthis:\n  set l = s - {z} \\<and> sorted_wrt (to_ord r) l \\<and> distinct l\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "hence \"set (z#l) = s\""], ["proof (prove)\nusing this:\n  set l = s - {z} \\<and> sorted_wrt (to_ord r) l \\<and> distinct l\n\ngoal (1 subgoal):\n 1. set (z # l) = s", "using z_def"], ["proof (prove)\nusing this:\n  set l = s - {z} \\<and> sorted_wrt (to_ord r) l \\<and> distinct l\n  z \\<in> s \\<and>\n  (\\<forall>y. r\\<^sup>+\\<^sup>+ y z \\<longrightarrow> y \\<notin> s)\n\ngoal (1 subgoal):\n 1. set (z # l) = s", "by auto"], ["proof (state)\nthis:\n  set (z # l) = s\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "moreover"], ["proof (state)\nthis:\n  set (z # l) = s\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "have \"\\<forall>y \\<in> set l. \\<not>(r\\<^sup>*\\<^sup>* y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set l. \\<not> r\\<^sup>*\\<^sup>* y z", "using z_def l_def rtranclpD"], ["proof (prove)\nusing this:\n  z \\<in> s \\<and>\n  (\\<forall>y. r\\<^sup>+\\<^sup>+ y z \\<longrightarrow> y \\<notin> s)\n  set l = s - {z} \\<and> sorted_wrt (to_ord r) l \\<and> distinct l\n  ?R\\<^sup>*\\<^sup>* ?a ?b \\<Longrightarrow>\n  ?a = ?b \\<or> ?a \\<noteq> ?b \\<and> ?R\\<^sup>+\\<^sup>+ ?a ?b\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set l. \\<not> r\\<^sup>*\\<^sup>* y z", "by force"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set l. \\<not> r\\<^sup>*\\<^sup>* y z\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>s.\n                   x = card s \\<Longrightarrow>\n                   finite s \\<longrightarrow>\n                   (\\<exists>l.\n                       set l = s \\<and>\n                       sorted_wrt (to_ord r) l \\<and> distinct l);\n        Suc x = card s\\<rbrakk>\n       \\<Longrightarrow> finite s \\<longrightarrow>\n                         (\\<exists>l.\n                             set l = s \\<and>\n                             sorted_wrt (to_ord r) l \\<and> distinct l)", "ultimately"], ["proof (chain)\npicking this:\n  set (z # l) = s\n  \\<forall>y\\<in>set l. \\<not> r\\<^sup>*\\<^sup>* y z", "show ?case"], ["proof (prove)\nusing this:\n  set (z # l) = s\n  \\<forall>y\\<in>set l. \\<not> r\\<^sup>*\\<^sup>* y z\n\ngoal (1 subgoal):\n 1. finite s \\<longrightarrow>\n    (\\<exists>l. set l = s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)", "by (metis distinct.simps(2) insert_absorb l_def list.simps(15) \n        sorted_wrt.simps(2) to_ord.elims(3))"], ["proof (state)\nthis:\n  finite s \\<longrightarrow>\n  (\\<exists>l. set l = s \\<and> sorted_wrt (to_ord r) l \\<and> distinct l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma top_sort_eff:\n  assumes \"irreflp p\\<^sup>+\\<^sup>+\"\n  assumes \"sorted_wrt (to_ord p) x\" \n  assumes \"i < length x\"\n  assumes \"j < length x\"\n  assumes \"(p\\<^sup>+\\<^sup>+ (x ! i) (x ! j))\"\n  shows \"i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j", "using assms"], ["proof (prove)\nusing this:\n  irreflp p\\<^sup>+\\<^sup>+\n  sorted_wrt (to_ord p) x\n  i < length x\n  j < length x\n  p\\<^sup>+\\<^sup>+ (x ! i) (x ! j)\n\ngoal (1 subgoal):\n 1. i < j", "apply (cases \"i > j\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>irreflp p\\<^sup>+\\<^sup>+; sorted_wrt (to_ord p) x;\n     i < length x; j < length x; p\\<^sup>+\\<^sup>+ (x ! i) (x ! j);\n     j < i\\<rbrakk>\n    \\<Longrightarrow> i < j\n 2. \\<lbrakk>irreflp p\\<^sup>+\\<^sup>+; sorted_wrt (to_ord p) x;\n     i < length x; j < length x; p\\<^sup>+\\<^sup>+ (x ! i) (x ! j);\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> i < j", "apply (metis sorted_wrt_nth_less r_into_rtranclp reflclp_tranclp\n          rtranclp_idemp rtranclp_reflclp to_ord.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>irreflp p\\<^sup>+\\<^sup>+; sorted_wrt (to_ord p) x;\n     i < length x; j < length x; p\\<^sup>+\\<^sup>+ (x ! i) (x ! j);\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> i < j", "by (metis irreflp_def nat_neq_iff)"], ["", "end"]]}