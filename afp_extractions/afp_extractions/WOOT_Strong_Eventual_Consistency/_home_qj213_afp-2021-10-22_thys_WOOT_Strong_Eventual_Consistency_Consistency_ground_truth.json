{"file_name": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency/Consistency.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WOOT_Strong_Eventual_Consistency", "problem_names": ["lemma insert_insert_message: \n  \"insert_messages (M \\<union> {Insert m}) = insert_messages M \\<union> {m}\"", "lemma consistent_subset:\n  assumes \"consistent N\"\n  assumes \"M \\<subseteq> N\"\n  assumes \"\\<Union> (deps ` M) \\<subseteq> (I ` insert_messages M)\"\n  shows \"consistent M\"", "lemma pred_is_dep: \"P m = \\<lbrakk> i \\<rbrakk> \\<longrightarrow> i \\<in> deps (Insert m)\"", "lemma succ_is_dep: \"S m = \\<lbrakk> i \\<rbrakk> \\<longrightarrow> i \\<in> deps (Insert m)\"", "lemma a_subset:\n  fixes M N a\n  assumes \"M \\<subseteq> N\"\n  assumes \"a_conditions (insert_messages N) a\"\n  shows \"a_conditions (insert_messages M) a\"", "lemma to_woot_character_keeps_i [simp]: \"I (to_woot_character M m) = I m\"", "lemma to_woot_character_keeps_i_lifted [simp]: \n  \"I ` to_woot_character M ` X = I ` X\"", "lemma to_woot_character_keeps_P [simp]: \"P (to_woot_character M m) = P m\"", "lemma to_woot_character_keeps_S [simp]: \"S (to_woot_character M m) = S m\"", "lemma to_woot_character_insert_no_eff:\n  \"to_woot_character (insert (Insert m) M) = to_woot_character M\"", "lemma associated_string_unique:\n  assumes \"is_associated_string M s\"\n  assumes \"is_associated_string M t\"\n  shows \"s = t\"", "lemma is_certified_associated_string_unique:\n  assumes \"is_certified_associated_string M s\"\n  assumes \"is_certified_associated_string M t\"\n  shows \"s = t\"", "lemma empty_consistent: \"consistent {}\"", "lemma empty_associated: \"is_associated_string {} []\""], "translations": [["", "lemma insert_insert_message: \n  \"insert_messages (M \\<union> {Insert m}) = insert_messages M \\<union> {m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_messages (M \\<union> {Insert m}) = insert_messages M \\<union> {m}", "by (simp add:insert_messages_def, simp add:set_eq_iff)"], ["", "definition delete_messages :: \"('a, 's) message set \\<Rightarrow> 'a delete_message set\"\n  where \"delete_messages M = {x. Delete x \\<in> M}\""], ["", "fun depends_on where \"depends_on M x y = (x \\<in> M \\<and> y \\<in> M \\<and> I x \\<in> deps (Insert y))\""], ["", "definition a_conditions ::\n  \"(('a :: linorder), 's) insert_message set \\<Rightarrow> ('a extended \\<Rightarrow> 'a position) \\<Rightarrow> bool\"\n  where \"a_conditions M a = (\n    a \\<turnstile> < a \\<stileturn> \\<and>\n    (\\<forall>m. m \\<in> M \\<longrightarrow> a (P m) < a (S m) \\<and>\n                   a \\<lbrakk>I m\\<rbrakk> = \\<lbrakk>\\<Psi> (a (P m), a (S m)) (I m)\\<rbrakk>))\""], ["", "definition consistent :: \"('a :: linorder, 's) message set \\<Rightarrow> bool\"\n  where \"consistent M \\<equiv>\n    inj_on I (insert_messages M) \\<and>\n    (\\<Union> (deps ` M) \\<subseteq> (I ` insert_messages M)) \\<and>\n    wfP (depends_on (insert_messages M)) \\<and>\n    (\\<exists>a. a_conditions (insert_messages M) a)\""], ["", "lemma consistent_subset:\n  assumes \"consistent N\"\n  assumes \"M \\<subseteq> N\"\n  assumes \"\\<Union> (deps ` M) \\<subseteq> (I ` insert_messages M)\"\n  shows \"consistent M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent M", "have a:\"insert_messages M \\<subseteq> insert_messages N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_messages M \\<subseteq> insert_messages N", "using assms(2) insert_messages_def"], ["proof (prove)\nusing this:\n  M \\<subseteq> N\n  insert_messages ?M = {x. Insert x \\<in> ?M}\n\ngoal (1 subgoal):\n 1. insert_messages M \\<subseteq> insert_messages N", "by blast"], ["proof (state)\nthis:\n  insert_messages M \\<subseteq> insert_messages N\n\ngoal (1 subgoal):\n 1. consistent M", "hence b:\"inj_on I (insert_messages M)\""], ["proof (prove)\nusing this:\n  insert_messages M \\<subseteq> insert_messages N\n\ngoal (1 subgoal):\n 1. inj_on I (insert_messages M)", "using assms(1) consistent_def inj_on_subset"], ["proof (prove)\nusing this:\n  insert_messages M \\<subseteq> insert_messages N\n  consistent N\n  consistent ?M \\<equiv>\n  inj_on I (insert_messages ?M) \\<and>\n  \\<Union> (deps ` ?M) \\<subseteq> I ` insert_messages ?M \\<and>\n  wfP (depends_on (insert_messages ?M)) \\<and>\n  (\\<exists>a. a_conditions (insert_messages ?M) a)\n  \\<lbrakk>inj_on ?f ?A; ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?B\n\ngoal (1 subgoal):\n 1. inj_on I (insert_messages M)", "by blast"], ["proof (state)\nthis:\n  inj_on I (insert_messages M)\n\ngoal (1 subgoal):\n 1. consistent M", "have \"wfP (depends_on (insert_messages N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (depends_on (insert_messages N))", "using assms(1) consistent_def"], ["proof (prove)\nusing this:\n  consistent N\n  consistent ?M \\<equiv>\n  inj_on I (insert_messages ?M) \\<and>\n  \\<Union> (deps ` ?M) \\<subseteq> I ` insert_messages ?M \\<and>\n  wfP (depends_on (insert_messages ?M)) \\<and>\n  (\\<exists>a. a_conditions (insert_messages ?M) a)\n\ngoal (1 subgoal):\n 1. wfP (depends_on (insert_messages N))", "by blast"], ["proof (state)\nthis:\n  wfP (depends_on (insert_messages N))\n\ngoal (1 subgoal):\n 1. consistent M", "moreover"], ["proof (state)\nthis:\n  wfP (depends_on (insert_messages N))\n\ngoal (1 subgoal):\n 1. consistent M", "have \n    \"depends_on (insert_messages M) \\<le> depends_on (insert_messages N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. depends_on (insert_messages M) \\<le> depends_on (insert_messages N)", "using a"], ["proof (prove)\nusing this:\n  insert_messages M \\<subseteq> insert_messages N\n\ngoal (1 subgoal):\n 1. depends_on (insert_messages M) \\<le> depends_on (insert_messages N)", "by auto"], ["proof (state)\nthis:\n  depends_on (insert_messages M) \\<le> depends_on (insert_messages N)\n\ngoal (1 subgoal):\n 1. consistent M", "ultimately"], ["proof (chain)\npicking this:\n  wfP (depends_on (insert_messages N))\n  depends_on (insert_messages M) \\<le> depends_on (insert_messages N)", "have c:\"wfP (depends_on (insert_messages M))\""], ["proof (prove)\nusing this:\n  wfP (depends_on (insert_messages N))\n  depends_on (insert_messages M) \\<le> depends_on (insert_messages N)\n\ngoal (1 subgoal):\n 1. wfP (depends_on (insert_messages M))", "using a wf_subset [to_pred]"], ["proof (prove)\nusing this:\n  wfP (depends_on (insert_messages N))\n  depends_on (insert_messages M) \\<le> depends_on (insert_messages N)\n  insert_messages M \\<subseteq> insert_messages N\n  \\<lbrakk>wfP ?r; ?p \\<le> ?r\\<rbrakk> \\<Longrightarrow> wfP ?p\n\ngoal (1 subgoal):\n 1. wfP (depends_on (insert_messages M))", "by blast"], ["proof (state)\nthis:\n  wfP (depends_on (insert_messages M))\n\ngoal (1 subgoal):\n 1. consistent M", "obtain a where \"a_conditions (insert_messages N) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a_conditions (insert_messages N) a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(1) consistent_def"], ["proof (prove)\nusing this:\n  consistent N\n  consistent ?M \\<equiv>\n  inj_on I (insert_messages ?M) \\<and>\n  \\<Union> (deps ` ?M) \\<subseteq> I ` insert_messages ?M \\<and>\n  wfP (depends_on (insert_messages ?M)) \\<and>\n  (\\<exists>a. a_conditions (insert_messages ?M) a)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a_conditions (insert_messages N) a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a_conditions (insert_messages N) a\n\ngoal (1 subgoal):\n 1. consistent M", "hence \"a_conditions (insert_messages M) a\""], ["proof (prove)\nusing this:\n  a_conditions (insert_messages N) a\n\ngoal (1 subgoal):\n 1. a_conditions (insert_messages M) a", "by (meson a a_conditions_def subset_iff)"], ["proof (state)\nthis:\n  a_conditions (insert_messages M) a\n\ngoal (1 subgoal):\n 1. consistent M", "thus ?thesis"], ["proof (prove)\nusing this:\n  a_conditions (insert_messages M) a\n\ngoal (1 subgoal):\n 1. consistent M", "using b c assms(3) consistent_def"], ["proof (prove)\nusing this:\n  a_conditions (insert_messages M) a\n  inj_on I (insert_messages M)\n  wfP (depends_on (insert_messages M))\n  \\<Union> (deps ` M) \\<subseteq> I ` insert_messages M\n  consistent ?M \\<equiv>\n  inj_on I (insert_messages ?M) \\<and>\n  \\<Union> (deps ` ?M) \\<subseteq> I ` insert_messages ?M \\<and>\n  wfP (depends_on (insert_messages ?M)) \\<and>\n  (\\<exists>a. a_conditions (insert_messages ?M) a)\n\ngoal (1 subgoal):\n 1. consistent M", "by blast"], ["proof (state)\nthis:\n  consistent M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pred_is_dep: \"P m = \\<lbrakk> i \\<rbrakk> \\<longrightarrow> i \\<in> deps (Insert m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P m = \\<lbrakk>i\\<rbrakk> \\<longrightarrow> i \\<in> deps (Insert m)", "by (metis Un_iff deps.simps(1) extended.set_intros extended.simps(27)\n      extended_to_set.simps(1) insert_message.exhaust_sel)"], ["", "lemma succ_is_dep: \"S m = \\<lbrakk> i \\<rbrakk> \\<longrightarrow> i \\<in> deps (Insert m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S m = \\<lbrakk>i\\<rbrakk> \\<longrightarrow> i \\<in> deps (Insert m)", "by (metis Un_insert_right deps.simps(1) extended_to_set.simps(1) insertI1\n      insert_message.exhaust_sel)"], ["", "lemma a_subset:\n  fixes M N a\n  assumes \"M \\<subseteq> N\"\n  assumes \"a_conditions (insert_messages N) a\"\n  shows \"a_conditions (insert_messages M) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a_conditions (insert_messages M) a", "using assms"], ["proof (prove)\nusing this:\n  M \\<subseteq> N\n  a_conditions (insert_messages N) a\n\ngoal (1 subgoal):\n 1. a_conditions (insert_messages M) a", "by (simp add:a_conditions_def insert_messages_def, blast)"], ["", "definition delete_maybe :: \"'\\<I>  \\<Rightarrow> ('\\<I>, '\\<Sigma>) message set \\<Rightarrow> '\\<Sigma>  \\<Rightarrow> '\\<Sigma> option\" where \n  \"delete_maybe i D s = (if Delete (DeleteMessage i) \\<in> D then None else Some s)\""], ["", "definition to_woot_character ::\n  \"('\\<I>, '\\<Sigma>) message set \\<Rightarrow> ('\\<I>, '\\<Sigma>) insert_message \\<Rightarrow> ('\\<I>, '\\<Sigma>) woot_character\"\n  where\n    \"to_woot_character D m = (\n       case m of\n         (InsertMessage l i u s) \\<Rightarrow> InsertMessage l i u (delete_maybe i D s))\""], ["", "lemma to_woot_character_keeps_i [simp]: \"I (to_woot_character M m) = I m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (to_woot_character M m) = I m", "by (cases m, simp add:to_woot_character_def)"], ["", "lemma to_woot_character_keeps_i_lifted [simp]: \n  \"I ` to_woot_character M ` X = I ` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I ` to_woot_character M ` X = I ` X", "by (metis (no_types, lifting) image_cong image_image to_woot_character_keeps_i)"], ["", "lemma to_woot_character_keeps_P [simp]: \"P (to_woot_character M m) = P m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (to_woot_character M m) = P m", "by (cases m, simp add:to_woot_character_def)"], ["", "lemma to_woot_character_keeps_S [simp]: \"S (to_woot_character M m) = S m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S (to_woot_character M m) = S m", "by (cases m, simp add:to_woot_character_def)"], ["", "lemma to_woot_character_insert_no_eff:\n  \"to_woot_character (insert (Insert m) M) = to_woot_character M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_woot_character (insert (Insert m) M) = to_woot_character M", "by (rule HOL.ext, simp add:delete_maybe_def to_woot_character_def insert_message.case_eq_if)"], ["", "definition is_associated_string ::\n  \"('a, 's) message set \\<Rightarrow> ('a :: linorder, 's) woot_character list \\<Rightarrow> bool\"\n  where \"is_associated_string M s \\<equiv> (\n    consistent M \\<and>\n    set s = to_woot_character M ` (insert_messages M) \\<and>\n    (\\<forall>a. a_conditions (insert_messages M) a \\<longrightarrow> \n         sorted_wrt (<) (map a (ext_ids s))))\""], ["", "fun is_certified_associated_string where\n  \"is_certified_associated_string M (Inr v) = is_associated_string M v\" |\n  \"is_certified_associated_string M (Inl _) = False\""], ["", "lemma associated_string_unique:\n  assumes \"is_associated_string M s\"\n  assumes \"is_associated_string M t\"\n  shows \"s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "using assms"], ["proof (prove)\nusing this:\n  is_associated_string M s\n  is_associated_string M t\n\ngoal (1 subgoal):\n 1. s = t", "apply (simp add:ext_ids_def is_associated_string_def consistent_def\n         sorted_wrt_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on I (insert_messages M) \\<and>\n             \\<Union> (deps ` M) \\<subseteq> I ` insert_messages M \\<and>\n             wfP (depends_on (insert_messages M)) \\<and>\n             Ex (a_conditions (insert_messages M)) \\<and>\n             set s = to_woot_character M ` insert_messages M \\<and>\n             (\\<forall>a.\n                 a_conditions (insert_messages M) a \\<longrightarrow>\n                 a \\<turnstile> < a \\<stileturn> \\<and>\n                 (\\<forall>x\\<in>set s.\n                     a \\<turnstile> < a \\<lbrakk>I x\\<rbrakk>) \\<and>\n                 sorted_wrt (<)\n                  (map (a \\<circ> (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>))\n                    s) \\<and>\n                 (\\<forall>x\\<in>set s.\n                     a \\<lbrakk>I x\\<rbrakk> < a \\<stileturn>));\n     set t = to_woot_character M ` insert_messages M \\<and>\n     (\\<forall>a.\n         a_conditions (insert_messages M) a \\<longrightarrow>\n         (\\<forall>x\\<in>set t.\n             a \\<turnstile> < a \\<lbrakk>I x\\<rbrakk>) \\<and>\n         sorted_wrt (<)\n          (map (a \\<circ> (\\<lambda>x. \\<lbrakk>I x\\<rbrakk>)) t) \\<and>\n         (\\<forall>x\\<in>set t.\n             a \\<lbrakk>I x\\<rbrakk> < a \\<stileturn>))\\<rbrakk>\n    \\<Longrightarrow> s = t", "by (metis sort_set_unique)"], ["", "lemma is_certified_associated_string_unique:\n  assumes \"is_certified_associated_string M s\"\n  assumes \"is_certified_associated_string M t\"\n  shows \"s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "using assms"], ["proof (prove)\nusing this:\n  is_certified_associated_string M s\n  is_certified_associated_string M t\n\ngoal (1 subgoal):\n 1. s = t", "by (case_tac s, case_tac [!] t, (simp add:associated_string_unique)+)"], ["", "lemma empty_consistent: \"consistent {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent {}", "have \"a_conditions {} (\\<lambda>x. (case x of \\<turnstile> \\<Rightarrow> \\<turnstile> | \\<stileturn> \\<Rightarrow> \\<stileturn>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a_conditions {}\n     (\\<lambda>x.\n         case x of \\<turnstile> \\<Rightarrow> \\<turnstile>\n         | \\<stileturn> \\<Rightarrow> \\<stileturn>)", "by (simp add: a_conditions_def)"], ["proof (state)\nthis:\n  a_conditions {}\n   (\\<lambda>x.\n       case x of \\<turnstile> \\<Rightarrow> \\<turnstile>\n       | \\<stileturn> \\<Rightarrow> \\<stileturn>)\n\ngoal (1 subgoal):\n 1. consistent {}", "hence \"\\<exists>f. a_conditions {} f\""], ["proof (prove)\nusing this:\n  a_conditions {}\n   (\\<lambda>x.\n       case x of \\<turnstile> \\<Rightarrow> \\<turnstile>\n       | \\<stileturn> \\<Rightarrow> \\<stileturn>)\n\ngoal (1 subgoal):\n 1. \\<exists>f. a_conditions {} f", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. a_conditions {} f\n\ngoal (1 subgoal):\n 1. consistent {}", "moreover"], ["proof (state)\nthis:\n  \\<exists>f. a_conditions {} f\n\ngoal (1 subgoal):\n 1. consistent {}", "have \"wfP (depends_on {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (depends_on {})", "by (simp add: wfP_eq_minimal)"], ["proof (state)\nthis:\n  wfP (depends_on {})\n\ngoal (1 subgoal):\n 1. consistent {}", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>f. a_conditions {} f\n  wfP (depends_on {})", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>f. a_conditions {} f\n  wfP (depends_on {})\n\ngoal (1 subgoal):\n 1. consistent {}", "by (simp add:consistent_def insert_messages_def)"], ["proof (state)\nthis:\n  consistent {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma empty_associated: \"is_associated_string {} []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_associated_string {} []", "by (simp add:is_associated_string_def insert_messages_def empty_consistent \n      ext_ids_def a_conditions_def)"], ["", "text \\<open>The empty set of messages is consistent and the associated string is the empty string.\\<close>"], ["", "end"]]}