{"file_name": "/home/qj213/afp-2021-10-22/thys/Knot_Theory/Preliminaries.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Knot_Theory", "problem_names": ["lemma empty_concatenate: \"xs \\<otimes> Nil = xs\"", "lemma leftright_associativity: \"(x\\<otimes>y)\\<otimes>z = x\\<otimes>(y\\<otimes>z)\"", "lemma left_associativity: \"(x\\<otimes>y)\\<otimes>z = x\\<otimes>y\\<otimes>z\"", "lemma right_associativity: \"x\\<otimes>(y\\<otimes>z) =x \\<otimes> y \\<otimes>z\"", "lemma compose_leftassociativity: \"(((x::wall) \\<circ> y) \\<circ> z) = (x\\<circ>y \\<circ>z)\"", "lemma compose_rightassociativity: \"(x::wall) \\<circ> (y \\<circ> z) = (x\\<circ>y \\<circ>z)\"", "lemma domain_non_negative:\"\\<forall>x.(domain x) \\<ge> 0\"", "lemma domain_block_non_negative:\"domain_block xs \\<ge> 0\"", "lemma domain_wall_compose: \"domain_wall (xs\\<circ>ys) = domain_wall xs\"", "lemma codomain_wall_compose: \"codomain_wall (xs\\<circ>ys) = codomain_wall ys\"", "lemma abs_zero: assumes \"abs x = 0\" shows \"x = 0\"", "lemma abs_zero_equality: assumes \"abs (x - y) = 0\" shows \"x = y\"", "lemma abs_non_negative: \" abs x \\<ge> 0\"", "lemma abs_non_negative_sum:  assumes \" abs x + abs y = 0\"\nshows \"abs x= 0\" and \"abs y = 0\"", "lemma domain_nonnegative: \"(domain x) \\<ge> 0\"", "lemma codomain_nonnegative: \"(codomain x) \\<ge> 0\"", "lemma domain_block_nonnegative: \"domain_block x \\<ge> 0\"", "lemma codomain_block_nonnegative: \"(codomain_block x) \\<ge> 0\"", "lemma domain_positive: \"((domain_block (x#Nil)) > 0) \\<or> ((domain_block y) > 0) \n\\<Longrightarrow> (domain_block (x#y) > 0)\"", "lemma domain_additive:  \"(domain_block (x\\<otimes>y))= (domain_block x) + (domain_block y)\"", "lemma codomain_additive:   \"(codomain_block (x\\<otimes>y))= (codomain_block x) + (codomain_block y)\"", "lemma domain_zero_sum: assumes \"(domain_block x) + (domain_block y) = 0\"\nshows \"domain_block x = 0\" and \"domain_block y = 0\"", "lemma domain_block_positive: assumes \"domain_block y>0\" or \"domain_block y>0\"\nshows \"(domain_block (x\\<otimes>y)) > 0\"", "lemma codomain_block_positive: assumes \"codomain_block y>0\" or \"codomain_block y>0\"\nshows \"(codomain_block (x\\<otimes>y)) > 0\"", "lemma brickcount_zero_implies_cup:\"(domain x= 0) \\<Longrightarrow> (x = cup)\"", "lemma brickcount_zero_implies_brick_is_cup:\"(domain x= 0) \\<Longrightarrow> (brick_is_cup x)\"", "lemma domain_zero_implies_is_cup:\"(domain_block x= 0) \\<Longrightarrow> (is_cup x)\""], "translations": [["", "lemma empty_concatenate: \"xs \\<otimes> Nil = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<otimes> [] = xs", "by (induction xs) (auto)"], ["", "text\\<open>Associativity properties of Conscatenation\\<close>"], ["", "lemma leftright_associativity: \"(x\\<otimes>y)\\<otimes>z = x\\<otimes>(y\\<otimes>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<otimes> y) \\<otimes> z = x \\<otimes> y \\<otimes> z", "by (induction x) (auto)"], ["", "lemma left_associativity: \"(x\\<otimes>y)\\<otimes>z = x\\<otimes>y\\<otimes>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<otimes> y) \\<otimes> z = x \\<otimes> y \\<otimes> z", "by (induction x) (auto)"], ["", "lemma right_associativity: \"x\\<otimes>(y\\<otimes>z) =x \\<otimes> y \\<otimes>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<otimes> y \\<otimes> z = x \\<otimes> y \\<otimes> z", "by auto"], ["", "text\\<open>Compose gives us the wall obtained by putting a wall above another, perhaps in an invalid way.\n\\<close>"], ["", "primrec compose :: \"wall => wall => wall\" (infixr \"\\<circ>\" 66) where\ncompose_Nil: \"(basic x) \\<circ>  ys = prod x ys\" |\ncompose_Cons: \"((prod x xs)\\<circ>ys) = prod x (xs\\<circ>ys)\""], ["", "text\\<open>Associativity properties of composition\\<close>"], ["", "lemma compose_leftassociativity: \"(((x::wall) \\<circ> y) \\<circ> z) = (x\\<circ>y \\<circ>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<circ> y) \\<circ> z = x \\<circ> y \\<circ> z", "by (induction x) (auto)"], ["", "lemma compose_rightassociativity: \"(x::wall) \\<circ> (y \\<circ> z) = (x\\<circ>y \\<circ>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<circ> y \\<circ> z = x \\<circ> y \\<circ> z", "by (induction x) (auto)"], ["", "text\\<open>block-length of a block is the number of bricks in a given block\\<close>"], ["", "primrec block_length::\"block \\<Rightarrow> nat\"\nwhere\n\"block_length [] = 0\"|\n\"block_length (Cons x y) = 1 + (block_length y)\""], ["", "(*domain tells us the number of incoming strands*)"], ["", "primrec domain::\"brick \\<Rightarrow> int\"\n where\n \"domain vert = 1\"|\n \"domain cup = 0\"|\n \"domain cap = 2\"|\n \"domain over = 2\"|\n \"domain under = 2\""], ["", "lemma domain_non_negative:\"\\<forall>x.(domain x) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. 0 \\<le> domain x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x. 0 \\<le> domain x", "have \"\\<forall>x.(x = vert)\\<or>(x = over)\\<or>(x=under)\\<or>(x=cap)\\<or>(x=cup)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x = vert \\<or>\n       x = over \\<or> x = brick.under \\<or> x = cap \\<or> x = cup", "by (metis brick.exhaust)"], ["proof (state)\nthis:\n  \\<forall>x.\n     x = vert \\<or>\n     x = over \\<or> x = brick.under \\<or> x = cap \\<or> x = cup\n\ngoal (1 subgoal):\n 1. \\<forall>x. 0 \\<le> domain x", "moreover"], ["proof (state)\nthis:\n  \\<forall>x.\n     x = vert \\<or>\n     x = over \\<or> x = brick.under \\<or> x = cap \\<or> x = cup\n\ngoal (1 subgoal):\n 1. \\<forall>x. 0 \\<le> domain x", "have \n      \"\\<forall>x.(((x = vert)\\<or>(x = over)\\<or>(x=under)\\<or>(x=cap)\\<or>(x=cup)) \\<longrightarrow> (domain x) \\<ge> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x = vert \\<or>\n       x = over \\<or>\n       x = brick.under \\<or> x = cap \\<or> x = cup \\<longrightarrow>\n       0 \\<le> domain x", "using domain.simps"], ["proof (prove)\nusing this:\n  domain vert = 1\n  domain cup = 0\n  domain cap = 2\n  domain over = 2\n  domain brick.under = 2\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x = vert \\<or>\n       x = over \\<or>\n       x = brick.under \\<or> x = cap \\<or> x = cup \\<longrightarrow>\n       0 \\<le> domain x", "by (metis order_refl zero_le_numeral zero_le_one)"], ["proof (state)\nthis:\n  \\<forall>x.\n     x = vert \\<or>\n     x = over \\<or>\n     x = brick.under \\<or> x = cap \\<or> x = cup \\<longrightarrow>\n     0 \\<le> domain x\n\ngoal (1 subgoal):\n 1. \\<forall>x. 0 \\<le> domain x", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x = vert \\<or>\n     x = over \\<or> x = brick.under \\<or> x = cap \\<or> x = cup\n  \\<forall>x.\n     x = vert \\<or>\n     x = over \\<or>\n     x = brick.under \\<or> x = cap \\<or> x = cup \\<longrightarrow>\n     0 \\<le> domain x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x = vert \\<or>\n     x = over \\<or> x = brick.under \\<or> x = cap \\<or> x = cup\n  \\<forall>x.\n     x = vert \\<or>\n     x = over \\<or>\n     x = brick.under \\<or> x = cap \\<or> x = cup \\<longrightarrow>\n     0 \\<le> domain x\n\ngoal (1 subgoal):\n 1. \\<forall>x. 0 \\<le> domain x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. 0 \\<le> domain x\n\ngoal:\nNo subgoals!", "qed"], ["", "(*co-domain tells us the number of outgoing strands*)"], ["", "primrec codomain::\"brick \\<Rightarrow> int\"\n where\n \"codomain vert = 1\"|\n \"codomain cup = 2\"|\n \"codomain cap = 0\"|\n \"codomain over = 2\"|\n \"codomain under = 2\""], ["", "(*domain-block tells us the number of incoming strands of a block*)"], ["", "primrec domain_block::\"block \\<Rightarrow> int \"\n where\n \"domain_block [] = 0\"\n |\"domain_block (Cons x y) = (domain x + (domain_block y))\""], ["", "lemma domain_block_non_negative:\"domain_block xs \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> domain_block xs", "by (induction xs) (auto simp add:domain_non_negative)"], ["", "(*codomain-block tells us the number of outgoing strands of a block*)"], ["", "primrec codomain_block::\"block \\<Rightarrow> int \"\n where\n \"codomain_block [] = 0\"\n |\"codomain_block (Cons x y) = (codomain x + (codomain_block y))\""], ["", "(*domain-wall tells us the number of incoming strands of a wall*)"], ["", "primrec domain_wall:: \"wall \\<Rightarrow> int\" where\n\"domain_wall (basic x) = domain_block x\"                                               \n|\"domain_wall (x*ys) = domain_block x\""], ["", "(*domain-wall tells us the number of incoming strands of a wall*)"], ["", "fun codomain_wall:: \"wall \\<Rightarrow> int\" where\n\"codomain_wall (basic x) = codomain_block x\"                      \n|\"codomain_wall (x*ys) = codomain_wall ys\""], ["", "lemma domain_wall_compose: \"domain_wall (xs\\<circ>ys) = domain_wall xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain_wall (xs \\<circ> ys) = domain_wall xs", "by (induction xs) (auto)"], ["", "lemma codomain_wall_compose: \"codomain_wall (xs\\<circ>ys) = codomain_wall ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain_wall (xs \\<circ> ys) = codomain_wall ys", "by (induction xs) (auto)"], ["", "text\\<open>this lemma tells us the number of incoming and outgoing strands\nof a composition of two wall\\<close>"], ["", "text\\<open>absolute value\\<close>"], ["", "definition abs::\"int \\<Rightarrow> int\" where\n\"abs x \\<equiv> if (x\\<ge>0) then x else (0-x)\""], ["", "text\\<open>theorems about abs\\<close>"], ["", "lemma abs_zero: assumes \"abs x = 0\" shows \"x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0", "using abs_def assms eq_iff_diff_eq_0"], ["proof (prove)\nusing this:\n  Preliminaries.abs ?x \\<equiv> if 0 \\<le> ?x then ?x else 0 - ?x\n  Preliminaries.abs x = 0\n  (?a = ?b) = (?a - ?b = (0::?'a))\n\ngoal (1 subgoal):\n 1. x = 0", "by metis"], ["", "lemma abs_zero_equality: assumes \"abs (x - y) = 0\" shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using assms abs_zero  eq_iff_diff_eq_0"], ["proof (prove)\nusing this:\n  Preliminaries.abs (x - y) = 0\n  Preliminaries.abs ?x = 0 \\<Longrightarrow> ?x = 0\n  (?a = ?b) = (?a - ?b = (0::?'a))\n\ngoal (1 subgoal):\n 1. x = y", "by blast"], ["", "lemma abs_non_negative: \" abs x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Preliminaries.abs x", "using abs_def diff_0 le_cases neg_0_le_iff_le"], ["proof (prove)\nusing this:\n  Preliminaries.abs ?x \\<equiv> if 0 \\<le> ?x then ?x else 0 - ?x\n  (0::?'a) - ?a = - ?a\n  \\<lbrakk>?x \\<le> ?y \\<Longrightarrow> ?P;\n   ?y \\<le> ?x \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  ((0::?'a) \\<le> - ?a) = (?a \\<le> (0::?'a))\n\ngoal (1 subgoal):\n 1. 0 \\<le> Preliminaries.abs x", "by auto"], ["", "lemma abs_non_negative_sum:  assumes \" abs x + abs y = 0\"\nshows \"abs x= 0\" and \"abs y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Preliminaries.abs x = 0 &&& Preliminaries.abs y = 0", "using abs_def diff_0 abs_non_negative  neg_0_le_iff_le \n add_nonneg_eq_0_iff assms"], ["proof (prove)\nusing this:\n  Preliminaries.abs ?x \\<equiv> if 0 \\<le> ?x then ?x else 0 - ?x\n  (0::?'a) - ?a = - ?a\n  0 \\<le> Preliminaries.abs ?x\n  ((0::?'a) \\<le> - ?a) = (?a \\<le> (0::?'a))\n  \\<lbrakk>(0::?'a) \\<le> ?x; (0::?'a) \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> (?x + ?y = (0::?'a)) =\n                    (?x = (0::?'a) \\<and> ?y = (0::?'a))\n  Preliminaries.abs x + Preliminaries.abs y = 0\n\ngoal (1 subgoal):\n 1. Preliminaries.abs x = 0 &&& Preliminaries.abs y = 0", "apply (metis)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Preliminaries.abs y = 0", "by (metis abs_non_negative add_nonneg_eq_0_iff assms)"], ["", "text\\<open>The following lemmas tell us that the number of incoming and outgoing strands of every brick \nis a non negative integer\\<close>"], ["", "lemma domain_nonnegative: \"(domain x) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> domain x", "using domain.simps  brick.exhaust le_cases not_numeral_le_zero zero_le_one"], ["proof (prove)\nusing this:\n  domain vert = 1\n  domain cup = 0\n  domain cap = 2\n  domain over = 2\n  domain brick.under = 2\n  \\<lbrakk>?y = vert \\<Longrightarrow> ?P; ?y = cup \\<Longrightarrow> ?P;\n   ?y = cap \\<Longrightarrow> ?P; ?y = over \\<Longrightarrow> ?P;\n   ?y = brick.under \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>?x \\<le> ?y \\<Longrightarrow> ?P;\n   ?y \\<le> ?x \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<not> numeral ?n \\<le> (0::?'a)\n  (0::?'a) \\<le> (1::?'a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> domain x", "by (metis)"], ["", "lemma codomain_nonnegative: \"(codomain x) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> codomain x", "by (cases x)(auto)"], ["", "text\\<open>The following lemmas tell us that the number of incoming and outgoing strands of every block \nis a non negative integer\\<close>"], ["", "lemma domain_block_nonnegative: \"domain_block x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> domain_block x", "by (induction x)(auto simp add: domain_nonnegative)"], ["", "lemma codomain_block_nonnegative: \"(codomain_block x) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> codomain_block x", "by (induction x)(auto simp add: codomain_nonnegative)"], ["", "text\\<open>The following lemmas tell us that if a block is appended to a block with incoming strands, then\nthe resultant block has incoming strands\\<close>"], ["", "lemma domain_positive: \"((domain_block (x#Nil)) > 0) \\<or> ((domain_block y) > 0) \n\\<Longrightarrow> (domain_block (x#y) > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < domain_block [x] \\<or> 0 < domain_block y \\<Longrightarrow>\n    0 < domain_block (x # y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < domain_block [x] \\<or> 0 < domain_block y \\<Longrightarrow>\n    0 < domain_block (x # y)", "have \"(domain_block (x#y)) =  (domain x) + (domain_block y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain_block (x # y) = domain x + domain_block y", "by auto"], ["proof (state)\nthis:\n  domain_block (x # y) = domain x + domain_block y\n\ngoal (1 subgoal):\n 1. 0 < domain_block [x] \\<or> 0 < domain_block y \\<Longrightarrow>\n    0 < domain_block (x # y)", "also"], ["proof (state)\nthis:\n  domain_block (x # y) = domain x + domain_block y\n\ngoal (1 subgoal):\n 1. 0 < domain_block [x] \\<or> 0 < domain_block y \\<Longrightarrow>\n    0 < domain_block (x # y)", "have \" (domain x) = (domain_block (x#Nil))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain x = domain_block [x]", "by auto"], ["proof (state)\nthis:\n  domain x = domain_block [x]\n\ngoal (1 subgoal):\n 1. 0 < domain_block [x] \\<or> 0 < domain_block y \\<Longrightarrow>\n    0 < domain_block (x # y)", "then"], ["proof (chain)\npicking this:\n  domain x = domain_block [x]", "have \"(domain_block (x#Nil) > 0) = (domain x > 0)\""], ["proof (prove)\nusing this:\n  domain x = domain_block [x]\n\ngoal (1 subgoal):\n 1. (0 < domain_block [x]) = (0 < domain x)", "by auto"], ["proof (state)\nthis:\n  (0 < domain_block [x]) = (0 < domain x)\n\ngoal (1 subgoal):\n 1. 0 < domain_block [x] \\<or> 0 < domain_block y \\<Longrightarrow>\n    0 < domain_block (x # y)", "then"], ["proof (chain)\npicking this:\n  (0 < domain_block [x]) = (0 < domain x)", "have \"((domain x > 0) \\<or> (domain_block y > 0)) \\<Longrightarrow> (domain x + domain_block y)>0\""], ["proof (prove)\nusing this:\n  (0 < domain_block [x]) = (0 < domain x)\n\ngoal (1 subgoal):\n 1. 0 < domain x \\<or> 0 < domain_block y \\<Longrightarrow>\n    0 < domain x + domain_block y", "using domain_nonnegative add_nonneg_pos add_pos_nonneg domain_block_nonnegative"], ["proof (prove)\nusing this:\n  (0 < domain_block [x]) = (0 < domain x)\n  0 \\<le> domain ?x\n  \\<lbrakk>(0::?'a) \\<le> ?a; (0::?'a) < ?b\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) < ?a + ?b\n  \\<lbrakk>(0::?'a) < ?a; (0::?'a) \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) < ?a + ?b\n  0 \\<le> domain_block ?x\n\ngoal (1 subgoal):\n 1. 0 < domain x \\<or> 0 < domain_block y \\<Longrightarrow>\n    0 < domain x + domain_block y", "by metis"], ["proof (state)\nthis:\n  0 < domain x \\<or> 0 < domain_block y \\<Longrightarrow>\n  0 < domain x + domain_block y\n\ngoal (1 subgoal):\n 1. 0 < domain_block [x] \\<or> 0 < domain_block y \\<Longrightarrow>\n    0 < domain_block (x # y)", "from this"], ["proof (chain)\npicking this:\n  0 < domain x \\<or> 0 < domain_block y \\<Longrightarrow>\n  0 < domain x + domain_block y", "show \"((domain_block(x#Nil)) > 0) \\<or> ((domain_block y) > 0) \n                                        \\<Longrightarrow> (domain_block (x#y) > 0)\""], ["proof (prove)\nusing this:\n  0 < domain x \\<or> 0 < domain_block y \\<Longrightarrow>\n  0 < domain x + domain_block y\n\ngoal (1 subgoal):\n 1. 0 < domain_block [x] \\<or> 0 < domain_block y \\<Longrightarrow>\n    0 < domain_block (x # y)", "by auto"], ["proof (state)\nthis:\n  0 < domain_block [x] \\<or> 0 < domain_block y \\<Longrightarrow>\n  0 < domain_block (x # y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma domain_additive:  \"(domain_block (x\\<otimes>y))= (domain_block x) + (domain_block y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain_block (x \\<otimes> y) = domain_block x + domain_block y", "by (induction x)(auto)"], ["", "lemma codomain_additive:   \"(codomain_block (x\\<otimes>y))= (codomain_block x) + (codomain_block y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain_block (x \\<otimes> y) = codomain_block x + codomain_block y", "by (induction x)(auto)"], ["", "lemma domain_zero_sum: assumes \"(domain_block x) + (domain_block y) = 0\"\nshows \"domain_block x = 0\" and \"domain_block y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain_block x = 0 &&& domain_block y = 0", "using domain_block_nonnegative add_nonneg_eq_0_iff assms"], ["proof (prove)\nusing this:\n  0 \\<le> domain_block ?x\n  \\<lbrakk>(0::?'a) \\<le> ?x; (0::?'a) \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> (?x + ?y = (0::?'a)) =\n                    (?x = (0::?'a) \\<and> ?y = (0::?'a))\n  domain_block x + domain_block y = 0\n\ngoal (1 subgoal):\n 1. domain_block x = 0 &&& domain_block y = 0", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. domain_block y = 0", "by (metis add_nonneg_eq_0_iff assms domain_block_nonnegative)"], ["", "lemma domain_block_positive: assumes \"domain_block y>0\" or \"domain_block y>0\"\nshows \"(domain_block (x\\<otimes>y)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < domain_block (x \\<otimes> y)", "apply (simp add: domain_additive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < domain_block x + domain_block y", "by (metis assms(1) domain_additive domain_block_nonnegative domain_zero_sum(2) less_le)"], ["", "lemma codomain_block_positive: assumes \"codomain_block y>0\" or \"codomain_block y>0\"\nshows \"(codomain_block (x\\<otimes>y)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < codomain_block (x \\<otimes> y)", "apply (simp add: codomain_additive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < codomain_block x + codomain_block y", "using  assms(1) codomain_additive codomain_block_nonnegative eq_neg_iff_add_eq_0 \n        le_less_trans less_le neg_less_0_iff_less"], ["proof (prove)\nusing this:\n  0 < codomain_block y\n  codomain_block (?x \\<otimes> ?y) = codomain_block ?x + codomain_block ?y\n  0 \\<le> codomain_block ?x\n  (?a = - ?b) = (?a + ?b = (0::?'a))\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  (?x < ?y) = (?x \\<le> ?y \\<and> ?x \\<noteq> ?y)\n  (- ?a < (0::?'a)) = ((0::?'a) < ?a)\n\ngoal (1 subgoal):\n 1. 0 < codomain_block x + codomain_block y", "by (metis)"], ["", "text\\<open>We prove that if the first count of a block is zero, then it is composed of cups and empty bricks. In\norder to do that we define the functions brick-is-cup and is-cup which check if a given block is \ncomposed of cups or if the blocks are composed of blocks\\<close>"], ["", "primrec brick_is_cup::\"brick \\<Rightarrow> bool\"\nwhere\n\"brick_is_cup vert = False\"|\n\"brick_is_cup cup = True\"|\n\"brick_is_cup cap = False\"|\n\"brick_is_cup over = False\"|\n\"brick_is_cup under = False\""], ["", "primrec is_cup::\"block \\<Rightarrow> bool\"\nwhere\n\"is_cup [] = True\"|\n\"is_cup (x#y) = (if (x= cup) then (is_cup y) else False)\""], ["", "lemma brickcount_zero_implies_cup:\"(domain x= 0) \\<Longrightarrow> (x = cup)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain x = 0 \\<Longrightarrow> x = cup", "by (cases x) (auto)"], ["", "lemma brickcount_zero_implies_brick_is_cup:\"(domain x= 0) \\<Longrightarrow> (brick_is_cup x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain x = 0 \\<Longrightarrow> brick_is_cup x", "by (cases x) (auto)"], ["", "lemma domain_zero_implies_is_cup:\"(domain_block x= 0) \\<Longrightarrow> (is_cup x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain_block x = 0 \\<Longrightarrow> is_cup x", "proof(induction x)"], ["proof (state)\ngoal (2 subgoals):\n 1. domain_block [] = 0 \\<Longrightarrow> is_cup []\n 2. \\<And>a x.\n       \\<lbrakk>domain_block x = 0 \\<Longrightarrow> is_cup x;\n        domain_block (a # x) = 0\\<rbrakk>\n       \\<Longrightarrow> is_cup (a # x)", "case Nil"], ["proof (state)\nthis:\n  domain_block [] = 0\n\ngoal (2 subgoals):\n 1. domain_block [] = 0 \\<Longrightarrow> is_cup []\n 2. \\<And>a x.\n       \\<lbrakk>domain_block x = 0 \\<Longrightarrow> is_cup x;\n        domain_block (a # x) = 0\\<rbrakk>\n       \\<Longrightarrow> is_cup (a # x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cup []", "by auto"], ["proof (state)\nthis:\n  is_cup []\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>domain_block x = 0 \\<Longrightarrow> is_cup x;\n        domain_block (a # x) = 0\\<rbrakk>\n       \\<Longrightarrow> is_cup (a # x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>domain_block x = 0 \\<Longrightarrow> is_cup x;\n        domain_block (a # x) = 0\\<rbrakk>\n       \\<Longrightarrow> is_cup (a # x)", "case (Cons a y)"], ["proof (state)\nthis:\n  domain_block y = 0 \\<Longrightarrow> is_cup y\n  domain_block (a # y) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>domain_block x = 0 \\<Longrightarrow> is_cup x;\n        domain_block (a # x) = 0\\<rbrakk>\n       \\<Longrightarrow> is_cup (a # x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cup (a # y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cup (a # y)", "have step1: \"domain_block (a # y) =  (domain a) + (domain_block y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain_block (a # y) = domain a + domain_block y", "by auto"], ["proof (state)\nthis:\n  domain_block (a # y) = domain a + domain_block y\n\ngoal (1 subgoal):\n 1. is_cup (a # y)", "with domain_zero_sum"], ["proof (chain)\npicking this:\n  domain_block ?x + domain_block ?y = 0 \\<Longrightarrow>\n  domain_block ?x = 0\n  domain_block ?x + domain_block ?y = 0 \\<Longrightarrow>\n  domain_block ?y = 0\n  domain_block (a # y) = domain a + domain_block y", "have\"domain_block y = 0\""], ["proof (prove)\nusing this:\n  domain_block ?x + domain_block ?y = 0 \\<Longrightarrow>\n  domain_block ?x = 0\n  domain_block ?x + domain_block ?y = 0 \\<Longrightarrow>\n  domain_block ?y = 0\n  domain_block (a # y) = domain a + domain_block y\n\ngoal (1 subgoal):\n 1. domain_block y = 0", "by (metis (full_types) Cons.prems domain_block_nonnegative domain_positive leD neq_iff)"], ["proof (state)\nthis:\n  domain_block y = 0\n\ngoal (1 subgoal):\n 1. is_cup (a # y)", "then"], ["proof (chain)\npicking this:\n  domain_block y = 0", "have step2: \"(is_cup y)\""], ["proof (prove)\nusing this:\n  domain_block y = 0\n\ngoal (1 subgoal):\n 1. is_cup y", "using Cons.IH"], ["proof (prove)\nusing this:\n  domain_block y = 0\n  domain_block y = 0 \\<Longrightarrow> is_cup y\n\ngoal (1 subgoal):\n 1. is_cup y", "by (auto)"], ["proof (state)\nthis:\n  is_cup y\n\ngoal (1 subgoal):\n 1. is_cup (a # y)", "with step1 and domain_zero_sum"], ["proof (chain)\npicking this:\n  domain_block (a # y) = domain a + domain_block y\n  domain_block ?x + domain_block ?y = 0 \\<Longrightarrow>\n  domain_block ?x = 0\n  domain_block ?x + domain_block ?y = 0 \\<Longrightarrow>\n  domain_block ?y = 0\n  is_cup y", "have \"domain a= 0\""], ["proof (prove)\nusing this:\n  domain_block (a # y) = domain a + domain_block y\n  domain_block ?x + domain_block ?y = 0 \\<Longrightarrow>\n  domain_block ?x = 0\n  domain_block ?x + domain_block ?y = 0 \\<Longrightarrow>\n  domain_block ?y = 0\n  is_cup y\n\ngoal (1 subgoal):\n 1. domain a = 0", "using Cons.prems \\<open>domain_block y = 0\\<close>"], ["proof (prove)\nusing this:\n  domain_block (a # y) = domain a + domain_block y\n  domain_block ?x + domain_block ?y = 0 \\<Longrightarrow>\n  domain_block ?x = 0\n  domain_block ?x + domain_block ?y = 0 \\<Longrightarrow>\n  domain_block ?y = 0\n  is_cup y\n  domain_block (a # y) = 0\n  domain_block y = 0\n\ngoal (1 subgoal):\n 1. domain a = 0", "by linarith"], ["proof (state)\nthis:\n  domain a = 0\n\ngoal (1 subgoal):\n 1. is_cup (a # y)", "then"], ["proof (chain)\npicking this:\n  domain a = 0", "have \"brick_is_cup a\""], ["proof (prove)\nusing this:\n  domain a = 0\n\ngoal (1 subgoal):\n 1. brick_is_cup a", "using brickcount_zero_implies_brick_is_cup"], ["proof (prove)\nusing this:\n  domain a = 0\n  domain ?x = 0 \\<Longrightarrow> brick_is_cup ?x\n\ngoal (1 subgoal):\n 1. brick_is_cup a", "by auto"], ["proof (state)\nthis:\n  brick_is_cup a\n\ngoal (1 subgoal):\n 1. is_cup (a # y)", "then"], ["proof (chain)\npicking this:\n  brick_is_cup a", "have \"a=cup\""], ["proof (prove)\nusing this:\n  brick_is_cup a\n\ngoal (1 subgoal):\n 1. a = cup", "using brick_is_cup_def"], ["proof (prove)\nusing this:\n  brick_is_cup a\n  brick_is_cup \\<equiv> rec_brick False True False False False\n\ngoal (1 subgoal):\n 1. a = cup", "by (metis \\<open>domain a = 0\\<close> brickcount_zero_implies_cup)"], ["proof (state)\nthis:\n  a = cup\n\ngoal (1 subgoal):\n 1. is_cup (a # y)", "with step2"], ["proof (chain)\npicking this:\n  is_cup y\n  a = cup", "have \"is_cup (a#y)\""], ["proof (prove)\nusing this:\n  is_cup y\n  a = cup\n\ngoal (1 subgoal):\n 1. is_cup (a # y)", "using is_cup_def"], ["proof (prove)\nusing this:\n  is_cup y\n  a = cup\n  is_cup \\<equiv>\n  rec_list True (\\<lambda>x y ya. if x = cup then ya else False)\n\ngoal (1 subgoal):\n 1. is_cup (a # y)", "by auto"], ["proof (state)\nthis:\n  is_cup (a # y)\n\ngoal (1 subgoal):\n 1. is_cup (a # y)", "then"], ["proof (chain)\npicking this:\n  is_cup (a # y)", "show ?case"], ["proof (prove)\nusing this:\n  is_cup (a # y)\n\ngoal (1 subgoal):\n 1. is_cup (a # y)", "by auto"], ["proof (state)\nthis:\n  is_cup (a # y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_cup (a # y)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We need a function that checks if a wall represents a knot diagram.\\<close>"], ["", "primrec is_tangle_diagram::\"wall \\<Rightarrow>  bool\"\nwhere\n\"is_tangle_diagram (basic x) = True\"\n|\"is_tangle_diagram (x*xs) = (if is_tangle_diagram xs\n                               then (codomain_block x = domain_wall xs) \n                               else False)\""], ["", "definition is_link_diagram::\"wall \\<Rightarrow>  bool\"\nwhere\n\"is_link_diagram x \\<equiv> (if (is_tangle_diagram x) \n                        then (abs (domain_wall x) + abs(codomain_wall x) = 0) \n                         else False)\""], ["", "end"]]}