{"file_name": "/home/qj213/afp-2021-10-22/thys/Knot_Theory/Kauffman_Matrix.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Knot_Theory", "problem_names": ["lemma eval_pCons: \"poly (pCons 0 1) x = x\"", "lemma pCons2:\" (pCons 0 1) \\<noteq> (1::int poly)\"", "lemma non_zero:\"x \\<noteq> 0\"", "lemma assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n      shows \"Fract a b = Fract c d \\<longleftrightarrow> a * d = c * b\"", "lemma A_non_zero:\"A \\<noteq> (0::rat_poly)\"", "lemma mult_inv_non_zero:\n assumes \"(p::rat_poly) \\<noteq> 0\" \n     and \"p*q = (1::rat_poly)\"\n shows \"q \\<noteq> 0\"", "lemma mat1_equiv:\"mat1 (1::nat) = [[(1::rat_poly)]]\"", "lemma  \"rat_poly.matrix_mult [[A,1],[0,A]] [[A,0],[0,A]] = [[A*A,A],[0,A*A]] \"", "lemma assumes \"(j::nat) div a = i div a\"\n          and \"j mod a = i mod a\"\n      shows \"j = i\"", "lemma \"[[1]] \\<otimes>  M = M\"", "lemma \" M \\<otimes> [[1]] = M\"", "lemma inverse1:\"rat_poly_times A B = 1\"", "lemma inverse2:\"rat_poly_times B A = 1\"", "lemma B_non_zero:\"B \\<noteq> 0\"", "lemma \"rat_poly_times p (q + r) \n                 = (rat_poly_times p q) + (rat_poly_times p r)\"", "lemma minus_left_distributivity:\n      \"rat_poly_times p (q - r) \n                  = (rat_poly_times p q) - (rat_poly_times p r)\"", "lemma minus_right_distributivity:\n    \"rat_poly_times (p - q) r = (rat_poly_times p r) - (rat_poly_times q r)\"", "lemma equation:\n   \"rat_poly_plus \n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) \n              = 0\"", "lemma  \"rat_poly.matrix_mult (brickmat over) (brickmat under) \n   = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]] \"", "lemma \"rat_poly_inv A = -A\"", "lemma vert_dim:\"rat_poly.row_length (brickmat vert) = 2 \\<and>length (brickmat vert) = 2\"", "lemma cup_dim:\"rat_poly.row_length (brickmat cup) = 1\" and \"length (brickmat cup) = 4\"", "lemma cap_dim:\"rat_poly.row_length (brickmat cap) = 4\" and \"length (brickmat cap) = 1\"", "lemma over_dim:\"rat_poly.row_length (brickmat over) = 4\" and \"length (brickmat over) = 4\"", "lemma under_dim:\"rat_poly.row_length (brickmat under) = 4\" and \"length (brickmat under) = 4\"", "lemma mat_vert:\"mat 2 2 (brickmat vert)\"", "lemma mat_cup:\"mat 1 4 (brickmat cup)\"", "lemma mat_cap:\"mat 4 1 (brickmat cap)\"", "lemma mat_over:\"mat 4 4 (brickmat over)\"", "lemma mat_under:\"mat 4 4 (brickmat under)\"", "lemma \"(rat_poly.row_length (brickmat d)) =  (2^(nat (domain d))) \"", "lemma \"rat_poly.row_length (brickmat cup) = 1\"", "lemma two:\"(Suc (Suc 0)) = 2\"", "lemma \"blockmat [a] = brickmat a\"", "lemma nat_sum:\n assumes \"a \\<ge> 0\" and \"b \\<ge> 0\"\n shows \"nat (a+b) = (nat a) + (nat b)\"", "lemma \"rat_poly.row_length (blockmat ls) = (2^ (nat ((domain_block ls))))\"", "lemma row_length_domain_block:\n \"rat_poly.row_length (blockmat ls) = (2^ (nat ((domain_block ls))))\"", "lemma length_codomain_block:\"length (blockmat ls) \n                                    = (2^ (nat ((codomain_block ls))))\"", "lemma matrix_blockmat:\n \"mat \n      (rat_poly.row_length (blockmat ls)) \n      (length (blockmat ls))  \n                    (blockmat ls)\"", "theorem matrix_kauff_mat:\n\"((is_tangle_diagram ws) \n \\<Longrightarrow> (rat_poly.row_length (kauff_mat ws)) = 2^(nat (domain_wall ws))\n \\<and> (length (kauff_mat ws)) = 2^(nat (codomain_wall ws))\n \\<and> (mat \n        (rat_poly.row_length (kauff_mat ws)) \n        (length (kauff_mat ws)) \n            (kauff_mat ws)))\"", "theorem effective_matrix_kauff_mat:\n assumes \"is_tangle_diagram ws\" \n shows \"(rat_poly.row_length (kauff_mat ws)) = 2^(nat (domain_wall ws))\"\n and \"length (kauff_mat ws) = 2^(nat (codomain_wall ws))\"\n and \"mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n                                           (kauff_mat ws) \"", "lemma mat_mult_equiv:\n \"rat_poly.matrix_mult m1 m2 = mat_mult (rat_poly.row_length m1) m1 m2\"", "theorem associative_rat_poly_mat:\n assumes \"mat (rat_poly.row_length m1) (rat_poly.row_length m2) m1\" \n     and \"mat (rat_poly.row_length m2) (rat_poly.row_length m3) m2\" \n     and \"mat (rat_poly.row_length m3) nc m3\"\n shows \"rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) \n                     = rat_poly.matrix_mult (rat_poly.matrix_mult m1  m2) m3\"", "theorem link_diagram_matrix:\n assumes \"is_link_diagram ws\"\n shows \"mat 1 1 (kauff_mat ws) \"", "theorem tangle_compose_matrix:\n\"((is_tangle_diagram ws1) \\<and> (is_tangle_diagram ws2) \n\\<and>(domain_wall ws2 = codomain_wall ws1)) \\<Longrightarrow>\nkauff_mat (ws1 \\<circ> ws2) = rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2)\"", "theorem left_mat_compose:\n assumes \"is_tangle_diagram ws\" \n     and \"codomain_wall ws = 0\"\n shows \"kauff_mat ws = (kauff_mat (ws  \\<circ> (basic [])))\"", "theorem right_mat_compose:\n assumes \"is_tangle_diagram ws\" and \"domain_wall ws = 0\"\n         shows \"kauff_mat ws = (kauff_mat ((basic []) \\<circ>ws))\"", "lemma left_id_blockmat:\"blockmat [] \\<otimes> blockmat b = blockmat b\"", "lemma tens_assoc:\n \"\\<forall>a xs ys.(brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) \n                   = (brickmat a \\<otimes> blockmat xs) \\<otimes> blockmat ys)\"", "lemma kauff_mat_tensor_distrib:\n\"\\<forall>xs.\\<forall>ys.(kauff_mat (basic xs \\<otimes> basic ys) \n = kauff_mat (basic xs) \\<otimes> kauff_mat (basic ys))\"", "lemma blockmat_tensor_distrib:\n \"(blockmat (a \\<otimes> b)) = (blockmat a) \\<otimes> (blockmat b)\"", "lemma blockmat_non_empty:\"\\<forall>bs.(blockmat bs \\<noteq> [])\"", "lemma  kauff_mat_non_empty:\n fixes ws\n assumes \"is_tangle_diagram ws\"\n shows \"kauff_mat ws \\<noteq> []\"", "lemma is_tangle_diagram_length_rowlength:\n assumes \"is_tangle_diagram (w*ws)\"\n shows \"length (blockmat w) = rat_poly.row_length (kauff_mat ws)\"", "lemma is_tangle_diagram_matrix_match:\n assumes \"is_tangle_diagram (w1*ws1)\"\n    and \"is_tangle_diagram (w2*ws2)\"\n shows \"rat_poly.matrix_match (blockmat w1) \n                      (kauff_mat ws1) (blockmat w2) (kauff_mat ws2)\"", "lemma mve1:\"make_vert_equiv 1 = (mat1 2)\"", "lemma\nassumes \"i<2\" and \"j<2\"\nshows \"(make_vert_equiv 1)!i!j  = (if i = j then 1 else 0)\"", "lemma mat1_vert_equiv:\"(mat1 2) = (brickmat vert)\" (is \"?l = ?r\")", "lemma blockmat_make_vert:\n \"blockmat (make_vert_block n) = (make_vert_equiv n)\"", "lemma prop_make_vert_equiv:\n shows \"rat_poly.row_length (make_vert_equiv n) = 2^n\"\n   and \"length (make_vert_equiv n) = 2^n\"\n   and \"mat \n         (rat_poly.row_length (make_vert_equiv n)) \n         (length (make_vert_equiv n)) \n                       (make_vert_equiv n)\"", "lemma equal_div_mod:assumes \"((j::nat) div a) = (i div a)\"\n            and \"(j mod a) = (i mod a)\"\n        shows \"j = i\"", "lemma equal_div_mod2:\"(((j::nat) div a)  = (i div a)\n                      \\<and> ((j mod a) = (i mod a))) = (j = i)\"", "lemma impl_rule:\n assumes \"(\\<forall>i < m.\\<forall>j < n. (P i) \\<and> (Q j))\" \n           and \"\\<forall> i j.(P i) \\<and> (Q j) \\<longrightarrow> R i j\"\n shows  \"(\\<forall>i < m.\\<forall>j < n. R i j)\"", "lemma implic:\n assumes \"\\<forall>i j.((P i j) \\<longrightarrow> (Q i j))\"\n        and \"\\<forall>i j.((Q i j) \\<longrightarrow> (R i j))\"  \n shows \"\\<forall>i j.((P i j) \\<longrightarrow> (R i j))\"", "lemma assumes \"a < (b*c)\"\n      shows \"((a::nat) div b) < c\"", "lemma mult_if_then:\"((v = (if P then 1 else 0)) \n                    \\<and> (w = (if Q then 1 else 0)))\n                       \\<Longrightarrow> (rat_poly_times v w = (if (P\\<and>Q) then 1 else 0))\"", "lemma rat_poly_unity:\"rat_poly_times 1 1 = 1\"", "lemma \"((P \\<and> Q) \\<longrightarrow> R) \\<Longrightarrow> (P \\<longrightarrow> Q  \\<longrightarrow> R)\"", "lemma \"length (mat1 2) = 2\"", "theorem make_vert_equiv_mat:\n\"make_vert_equiv n = (mat1 (2^n))\"", "theorem make_vert_block_map_blockmat:\n \"blockmat (make_vert_block n) = (mat1 (2^n))\"", "lemma  mat1_rt_mult:assumes \"mat nr nc m1\"\n       shows \"rat_poly.matrix_mult m1 (mat1 (nc)) = m1\"", "lemma mat1_vert_block: \n       \"rat_poly.matrix_mult \n                   (blockmat b) \n                   (blockmat (make_vert_block (nat (codomain_block b))))\n                           = (blockmat b)\"", "theorem weak_distributivity1:\n \"weak_matrix_match A1 A2 B1\n  \\<Longrightarrow> ((rat_poly.matrix_mult A1  A2)\\<otimes> B1) \n               = (rat_poly.matrix_mult (A1 \\<otimes> B1) (A2))\"", "theorem weak_distributivity2:\n\"weak_matrix_match2 A1 B1 B2\n     \\<Longrightarrow> (A1\\<otimes> (rat_poly.matrix_mult B1 B2)) \n                                  = (rat_poly.matrix_mult (A1 \\<otimes> B1) (B2))\"", "lemma is_tangle_diagram_weak_matrix_match:\n assumes \"is_tangle_diagram (w1*ws1)\"\n      and \"codomain_block w2 = 0\"\n shows \"weak_matrix_match (blockmat w1) (kauff_mat ws1) (blockmat w2)\"", "lemma is_tangle_diagram_weak_matrix_match2:\n assumes \"is_tangle_diagram (w2*ws2)\"\n      and \"codomain_block w1 = 0\"\n shows \"weak_matrix_match2 (blockmat w1) (blockmat w2) (kauff_mat ws2)\"", "lemma is_tangle_diagram_vert_block:\n  \"is_tangle_diagram (b*(basic (make_vert_block (nat (codomain_block b)))))\"", "theorem Tensor_Invariance:\n \"(is_tangle_diagram ws1) \\<and> (is_tangle_diagram ws2)\n \\<Longrightarrow> (kauff_mat (ws1 \\<otimes> ws2) = (kauff_mat ws1) \\<otimes> (kauff_mat ws2))\""], "translations": [["", "lemma eval_pCons: \"poly (pCons 0 1) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (pCons (0::'a) 1) x = x", "using poly_1 poly_pCons"], ["proof (prove)\nusing this:\n  poly 1 ?x = (1::?'a)\n  poly (pCons ?a ?p) ?x = ?a + ?x * poly ?p ?x\n\ngoal (1 subgoal):\n 1. poly (pCons (0::'a) 1) x = x", "by auto"], ["", "lemma pCons2:\" (pCons 0 1) \\<noteq> (1::int poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pCons 0 1 \\<noteq> 1", "using eval_pCons poly_1 zero_neq_one"], ["proof (prove)\nusing this:\n  poly (pCons (0::?'a) 1) ?x = ?x\n  poly 1 ?x = (1::?'a)\n  (0::?'a) \\<noteq> (1::?'a)\n\ngoal (1 subgoal):\n 1. pCons 0 1 \\<noteq> 1", "by metis"], ["", "definition var_def: \"x = (pCons 0 1)\""], ["", "lemma non_zero:\"x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "using var_def pCons_eq_0_iff zero_neq_one"], ["proof (prove)\nusing this:\n  x = pCons (0::?'a) 1\n  (pCons ?a ?p = 0) = (?a = (0::?'a) \\<and> ?p = 0)\n  (0::?'a) \\<noteq> (1::?'a)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by (metis)"], ["", "text\\<open>rat$\\_$poly is the fraction field of integer polynomials. In other\nwords, it is the type of rational functions\\<close>"], ["", "type_synonym rat_poly = \"intpoly fract\""], ["", "text\\<open>A is defined to be x/1, while B is defined to be 1/x\\<close>"], ["", "definition var_def1:\"A =  Fract x 1\""], ["", "definition var_def2: \"B = Fract 1 x\""], ["", "lemma assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n      shows \"Fract a b = Fract c d \\<longleftrightarrow> a * d = c * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Fraction_Field.Fract a b = Fraction_Field.Fract c d) = (a * d = c * b)", "using eq_fract assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<noteq> (0::?'a); ?d \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> (Fraction_Field.Fract ?a ?b =\n                     Fraction_Field.Fract ?c ?d) =\n                    (?a * ?d = ?c * ?b)\n  Fraction_Field.Fract ?a (0::?'b) = Fraction_Field.Fract (0::?'b) (1::?'b)\n  Fraction_Field.Fract (0::?'c) ?a = Fraction_Field.Fract (0::?'c) ?c\n  b \\<noteq> (0::'a)\n  d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (Fraction_Field.Fract a b = Fraction_Field.Fract c d) = (a * d = c * b)", "by auto"], ["", "lemma A_non_zero:\"A \\<noteq> (0::rat_poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> 0", "unfolding var_def1"], ["proof (prove)\ngoal (1 subgoal):\n 1. Fraction_Field.Fract x 1 \\<noteq> 0", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Fraction_Field.Fract x 1 \\<noteq> 0 \\<Longrightarrow> False", "assume 0:\" \\<not> (Fract x 1 \\<noteq> (0::rat_poly)) \""], ["proof (state)\nthis:\n  \\<not> Fraction_Field.Fract x 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> Fraction_Field.Fract x 1 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> Fraction_Field.Fract x 1 \\<noteq> 0", "have \"Fract x 1 = (0::rat_poly)\""], ["proof (prove)\nusing this:\n  \\<not> Fraction_Field.Fract x 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Fraction_Field.Fract x 1 = 0", "by auto"], ["proof (state)\nthis:\n  Fraction_Field.Fract x 1 = 0\n\ngoal (1 subgoal):\n 1. \\<not> Fraction_Field.Fract x 1 \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Fraction_Field.Fract x 1 = 0\n\ngoal (1 subgoal):\n 1. \\<not> Fraction_Field.Fract x 1 \\<noteq> 0 \\<Longrightarrow> False", "have \"(0::rat_poly) = Fract (0::intpoly) (1::intpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = Fraction_Field.Fract 0 1", "by (metis Zero_fract_def)"], ["proof (state)\nthis:\n  0 = Fraction_Field.Fract 0 1\n\ngoal (1 subgoal):\n 1. \\<not> Fraction_Field.Fract x 1 \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Fraction_Field.Fract x 1 = 0\n  0 = Fraction_Field.Fract 0 1", "have \"Fract x (1::intpoly) = Fract (0::intpoly) (1::intpoly)\""], ["proof (prove)\nusing this:\n  Fraction_Field.Fract x 1 = 0\n  0 = Fraction_Field.Fract 0 1\n\ngoal (1 subgoal):\n 1. Fraction_Field.Fract x 1 = Fraction_Field.Fract 0 1", "by auto"], ["proof (state)\nthis:\n  Fraction_Field.Fract x 1 = Fraction_Field.Fract 0 1\n\ngoal (1 subgoal):\n 1. \\<not> Fraction_Field.Fract x 1 \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Fraction_Field.Fract x 1 = Fraction_Field.Fract 0 1\n\ngoal (1 subgoal):\n 1. \\<not> Fraction_Field.Fract x 1 \\<noteq> 0 \\<Longrightarrow> False", "have \"(1::intpoly) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> Fraction_Field.Fract x 1 \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Fraction_Field.Fract x 1 = Fraction_Field.Fract 0 1\n  1 \\<noteq> 0", "have \"x*(1::intpoly) = (0::intpoly)*(1::intpoly)\""], ["proof (prove)\nusing this:\n  Fraction_Field.Fract x 1 = Fraction_Field.Fract 0 1\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x * 1 = 0 * 1", "using eq_fract"], ["proof (prove)\nusing this:\n  Fraction_Field.Fract x 1 = Fraction_Field.Fract 0 1\n  1 \\<noteq> 0\n  \\<lbrakk>?b \\<noteq> (0::?'a); ?d \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> (Fraction_Field.Fract ?a ?b =\n                     Fraction_Field.Fract ?c ?d) =\n                    (?a * ?d = ?c * ?b)\n  Fraction_Field.Fract ?a (0::?'b) = Fraction_Field.Fract (0::?'b) (1::?'b)\n  Fraction_Field.Fract (0::?'c) ?a = Fraction_Field.Fract (0::?'c) ?c\n\ngoal (1 subgoal):\n 1. x * 1 = 0 * 1", "by metis"], ["proof (state)\nthis:\n  x * 1 = 0 * 1\n\ngoal (1 subgoal):\n 1. \\<not> Fraction_Field.Fract x 1 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x * 1 = 0 * 1", "have \"x = (0::intpoly)\""], ["proof (prove)\nusing this:\n  x * 1 = 0 * 1\n\ngoal (1 subgoal):\n 1. x = 0", "by auto"], ["proof (state)\nthis:\n  x = 0\n\ngoal (1 subgoal):\n 1. \\<not> Fraction_Field.Fract x 1 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x = 0", "show False"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. False", "using non_zero"], ["proof (prove)\nusing this:\n  x = 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_inv_non_zero:\n assumes \"(p::rat_poly) \\<noteq> 0\" \n     and \"p*q = (1::rat_poly)\"\n shows \"q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p * q = 1\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["", "abbreviation rat_poly_times::\"rat_poly \\<Rightarrow> rat_poly \\<Rightarrow> rat_poly\"\nwhere\n\"rat_poly_times p q \\<equiv> p*q\""], ["", "abbreviation rat_poly_plus::\"rat_poly \\<Rightarrow> rat_poly \\<Rightarrow> rat_poly\"\nwhere\n\"rat_poly_plus p q \\<equiv> p+q\""], ["", "abbreviation rat_poly_inv::\"rat_poly \\<Rightarrow> rat_poly\"\nwhere\n\"rat_poly_inv p \\<equiv> (- p)\""], ["", "interpretation  rat_poly:semiring_0 \"rat_poly_plus\" 0 \"rat_poly_times\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_0 rat_poly_plus 0 rat_poly_times", "by (unfold_locales)"], ["", "interpretation  rat_poly:semiring_1 1 \"rat_poly_times\" \"rat_poly_plus\" 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_1 1 rat_poly_times rat_poly_plus 0", "by (unfold_locales)"], ["", "lemma mat1_equiv:\"mat1 (1::nat) = [[(1::rat_poly)]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat1 1 = [[1]]", "by (simp add:mat1I_def vec1I_def)"], ["", "text\\<open>rat$\\_$poly is an interpretation of the locale plus\\_mult\\<close>"], ["", "interpretation  rat_poly:plus_mult \"1\" \"rat_poly_times\"  0 \"rat_poly_plus\" \n                                  \"rat_poly_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plus_mult 1 rat_poly_times 0 rat_poly_plus rat_poly_inv", "apply(unfold_locales)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>a b. rat_poly_times a b = rat_poly_times b a\n 2. \\<And>a b c.\n       rat_poly_times (rat_poly_times a b) c =\n       rat_poly_times a (rat_poly_times b c)\n 3. \\<And>x. rat_poly_times 1 x = x\n 4. \\<And>x. rat_poly_times x 1 = x\n 5. \\<And>a b. rat_poly_plus a b = rat_poly_plus b a\n 6. \\<And>a b c.\n       rat_poly_plus (rat_poly_plus a b) c =\n       rat_poly_plus a (rat_poly_plus b c)\n 7. \\<And>x. rat_poly_plus 0 x = x\n 8. \\<And>x. rat_poly_plus x 0 = x\n 9. \\<And>a b c.\n       rat_poly_times a (rat_poly_plus b c) =\n       rat_poly_plus (rat_poly_times a b) (rat_poly_times a c)\n 10. \\<And>a b c.\n        rat_poly_times (rat_poly_plus a b) c =\n        rat_poly_plus (rat_poly_times a c) (rat_poly_times b c)\nA total of 12 subgoals...", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       rat_poly_times a (rat_poly_plus b c) =\n       rat_poly_plus (rat_poly_times a b) (rat_poly_times a c)\n 2. \\<And>a b c.\n       rat_poly_times (rat_poly_plus a b) c =\n       rat_poly_plus (rat_poly_times a c) (rat_poly_times b c)", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       rat_poly_times a (rat_poly_plus b c) =\n       rat_poly_plus (rat_poly_times a b) (rat_poly_times a c)\n 2. \\<And>a b c.\n       rat_poly_times (rat_poly_plus a b) c =\n       rat_poly_plus (rat_poly_times a c) (rat_poly_times b c)", "fix p q r"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       rat_poly_times a (rat_poly_plus b c) =\n       rat_poly_plus (rat_poly_times a b) (rat_poly_times a c)\n 2. \\<And>a b c.\n       rat_poly_times (rat_poly_plus a b) c =\n       rat_poly_plus (rat_poly_times a c) (rat_poly_times b c)", "show \"rat_poly_times p (rat_poly_plus q r) \n                    = rat_poly_plus (rat_poly_times p q) (rat_poly_times p r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times p (rat_poly_plus q r) =\n    rat_poly_plus (rat_poly_times p q) (rat_poly_times p r)", "by (simp add: distrib_left)"], ["proof (state)\nthis:\n  rat_poly_times p (rat_poly_plus q r) =\n  rat_poly_plus (rat_poly_times p q) (rat_poly_times p r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       rat_poly_times (rat_poly_plus a b) c =\n       rat_poly_plus (rat_poly_times a c) (rat_poly_times b c)", "show \"rat_poly_times (rat_poly_plus p q) r \n                    = rat_poly_plus (rat_poly_times p r) (rat_poly_times q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times (rat_poly_plus p q) r =\n    rat_poly_plus (rat_poly_times p r) (rat_poly_times q r)", "by (metis comm_semiring_class.distrib)"], ["proof (state)\nthis:\n  rat_poly_times (rat_poly_plus p q) r =\n  rat_poly_plus (rat_poly_times p r) (rat_poly_times q r)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*using matrix_multiplication *)"], ["", "lemma  \"rat_poly.matrix_mult [[A,1],[0,A]] [[A,0],[0,A]] = [[A*A,A],[0,A*A]] \""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult [[A, 1], [0, A]] [[A, 0], [0, A]] =\n    [[rat_poly_times A A, A], [0, rat_poly_times A A]]", "apply(simp add:mat_multI_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matT_vec_multI 0 rat_poly_plus rat_poly_times\n     (map2 (#) [A, 1]\n       (map2 (#) [0, A]\n         (replicate (rat_poly.row_length [[A, 1], [0, A]]) [])))\n     [A, 0] =\n    [rat_poly_times A A, A] \\<and>\n    matT_vec_multI 0 rat_poly_plus rat_poly_times\n     (map2 (#) [A, 1]\n       (map2 (#) [0, A]\n         (replicate (rat_poly.row_length [[A, 1], [0, A]]) [])))\n     [0, A] =\n    [0, rat_poly_times A A]", "apply(simp add:matT_vec_multI_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>w. scalar_prod w [A, 0]) \\<circ>\n         (\\<lambda>(x, y). x # y))\n     (zip [A, 1]\n       (map2 (#) [0, A]\n         (replicate (rat_poly.row_length [[A, 1], [0, A]]) []))) =\n    [rat_poly_times A A, A] \\<and>\n    map ((\\<lambda>w. scalar_prod w [0, A]) \\<circ>\n         (\\<lambda>(x, y). x # y))\n     (zip [A, 1]\n       (map2 (#) [0, A]\n         (replicate (rat_poly.row_length [[A, 1], [0, A]]) []))) =\n    [0, rat_poly_times A A]", "apply(auto simp add:replicate_def rat_poly.row_length_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. scalar_prod [A, 0] [A, 0] = rat_poly_times A A\n 2. scalar_prod [1, A] [A, 0] = A\n 3. scalar_prod [A, 0] [0, A] = 0\n 4. scalar_prod [1, A] [0, A] = rat_poly_times A A", "apply(auto simp add:scalar_prod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation \n   rat_polymat_tensor::\"rat_poly mat \\<Rightarrow> rat_poly mat \\<Rightarrow> rat_poly mat\" \n                                                          (infixl \"\\<otimes>\" 65) \nwhere\n\"rat_polymat_tensor p q \\<equiv> rat_poly.Tensor p q\""], ["", "lemma assumes \"(j::nat) div a = i div a\"\n          and \"j mod a = i mod a\"\n      shows \"j = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = i", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. j = i", "have \"a*(j div a) + (j mod a) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (j div a) + j mod a = j", "using mult_div_mod_eq"], ["proof (prove)\nusing this:\n  ?b * (?a div ?b) + ?a mod ?b = ?a\n\ngoal (1 subgoal):\n 1. a * (j div a) + j mod a = j", "by simp"], ["proof (state)\nthis:\n  a * (j div a) + j mod a = j\n\ngoal (1 subgoal):\n 1. j = i", "moreover"], ["proof (state)\nthis:\n  a * (j div a) + j mod a = j\n\ngoal (1 subgoal):\n 1. j = i", "have \"a*(i div a) + (i mod a) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (i div a) + i mod a = i", "using mult_div_mod_eq"], ["proof (prove)\nusing this:\n  ?b * (?a div ?b) + ?a mod ?b = ?a\n\ngoal (1 subgoal):\n 1. a * (i div a) + i mod a = i", "by auto"], ["proof (state)\nthis:\n  a * (i div a) + i mod a = i\n\ngoal (1 subgoal):\n 1. j = i", "ultimately"], ["proof (chain)\npicking this:\n  a * (j div a) + j mod a = j\n  a * (i div a) + i mod a = i", "show ?thesis"], ["proof (prove)\nusing this:\n  a * (j div a) + j mod a = j\n  a * (i div a) + i mod a = i\n\ngoal (1 subgoal):\n 1. j = i", "using assms"], ["proof (prove)\nusing this:\n  a * (j div a) + j mod a = j\n  a * (i div a) + i mod a = i\n  j div a = i div a\n  j mod a = i mod a\n\ngoal (1 subgoal):\n 1. j = i", "by metis"], ["proof (state)\nthis:\n  j = i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"[[1]] \\<otimes>  M = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[1]] \\<otimes> M = M", "by (metis rat_poly.Tensor_left_id)"], ["", "lemma \" M \\<otimes> [[1]] = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<otimes> [[1]] = M", "by (metis rat_poly.Tensor_right_id)"], ["", "section\\<open>Kauffman matrices\\<close>"], ["", "text\\<open>We assign every brick to a matrix of rational polynmials\\<close>"], ["", "primrec brickmat::\"brick \\<Rightarrow> rat_poly mat\"\nwhere\n\"brickmat vert = [[1,0],[0,1]]\"\n|\"brickmat cup  = [[0],[A],[-B],[0]]\"\n|\"brickmat cap  = [[0,-A,B,0]]\"\n|\"brickmat over = [[A,0,0,0],\n                   [0,0,B,0],\n                   [0,B,A-(B*B*B),0],\n                   [0,0,0,A]]\" \n|\"brickmat under  = [[B,0,0,0],\n                     [0,B-(A*A*A),A,0],\n                     [0,A,0,0],\n                     [0,0,0,B]]\""], ["", "lemma inverse1:\"rat_poly_times A B = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times A B = 1", "using non_zero  One_fract_def monoid_mult_class.mult.right_neutral \n       mult_fract mult_fract_cancel  var_def1 var_def2"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  1 = Fraction_Field.Fract (1::?'a) (1::?'a)\n  ?a * (1::?'a) = ?a\n  Fraction_Field.Fract ?a ?b * Fraction_Field.Fract ?c ?d =\n  Fraction_Field.Fract (?a * ?c) (?b * ?d)\n  ?c \\<noteq> (0::?'b) \\<Longrightarrow>\n  Fraction_Field.Fract (?c * ?a) (?c * ?b) = Fraction_Field.Fract ?a ?b\n  A = Fraction_Field.Fract x 1\n  B = Fraction_Field.Fract 1 x\n\ngoal (1 subgoal):\n 1. rat_poly_times A B = 1", "by (metis (hide_lams, no_types))"], ["", "lemma inverse2:\"rat_poly_times B A = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times B A = 1", "using  One_fract_def monoid_mult_class.mult.right_neutral mult_fract \n        mult_fract_cancel non_zero var_def1 var_def2"], ["proof (prove)\nusing this:\n  1 = Fraction_Field.Fract (1::?'a) (1::?'a)\n  ?a * (1::?'a) = ?a\n  Fraction_Field.Fract ?a ?b * Fraction_Field.Fract ?c ?d =\n  Fraction_Field.Fract (?a * ?c) (?b * ?d)\n  ?c \\<noteq> (0::?'b) \\<Longrightarrow>\n  Fraction_Field.Fract (?c * ?a) (?c * ?b) = Fraction_Field.Fract ?a ?b\n  x \\<noteq> 0\n  A = Fraction_Field.Fract x 1\n  B = Fraction_Field.Fract 1 x\n\ngoal (1 subgoal):\n 1. rat_poly_times B A = 1", "by (metis (hide_lams, no_types))"], ["", "lemma B_non_zero:\"B \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<noteq> 0", "using A_non_zero mult_inv_non_zero inverse1 \n       divide_fract div_0 fract_collapse(2) \n       monoid_mult_class.mult.left_neutral \n       mult_fract_cancel non_zero var_def2 zero_neq_one"], ["proof (prove)\nusing this:\n  A \\<noteq> 0\n  \\<lbrakk>?p \\<noteq> 0; rat_poly_times ?p ?q = 1\\<rbrakk>\n  \\<Longrightarrow> ?q \\<noteq> 0\n  rat_poly_times A B = 1\n  Fraction_Field.Fract ?a ?b / Fraction_Field.Fract ?c ?d =\n  Fraction_Field.Fract (?a * ?d) (?b * ?c)\n  (0::?'a) div ?a = (0::?'a)\n  Fraction_Field.Fract (1::?'b) (1::?'b) = 1\n  (1::?'a) * ?a = ?a\n  ?c \\<noteq> (0::?'b) \\<Longrightarrow>\n  Fraction_Field.Fract (?c * ?a) (?c * ?b) = Fraction_Field.Fract ?a ?b\n  x \\<noteq> 0\n  B = Fraction_Field.Fract 1 x\n  (0::?'a) \\<noteq> (1::?'a)\n\ngoal (1 subgoal):\n 1. B \\<noteq> 0", "by (metis (hide_lams, mono_tags))"], ["", "lemma \"rat_poly_times p (q + r) \n                 = (rat_poly_times p q) + (rat_poly_times p r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times p (rat_poly_plus q r) =\n    rat_poly_plus (rat_poly_times p q) (rat_poly_times p r)", "by (metis rat_poly.plus_left_distributivity)"], ["", "lemma minus_left_distributivity:\n      \"rat_poly_times p (q - r) \n                  = (rat_poly_times p q) - (rat_poly_times p r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times p (q - r) = rat_poly_times p q - rat_poly_times p r", "using minus_mult_right right_diff_distrib"], ["proof (prove)\nusing this:\n  - (?a * ?b) = ?a * - ?b\n  ?a * (?b - ?c) = ?a * ?b - ?a * ?c\n\ngoal (1 subgoal):\n 1. rat_poly_times p (q - r) = rat_poly_times p q - rat_poly_times p r", "by blast"], ["", "lemma minus_right_distributivity:\n    \"rat_poly_times (p - q) r = (rat_poly_times p r) - (rat_poly_times q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times (p - q) r = rat_poly_times p r - rat_poly_times q r", "using  minus_left_distributivity rat_poly.comm"], ["proof (prove)\nusing this:\n  rat_poly_times ?p (?q - ?r) = rat_poly_times ?p ?q - rat_poly_times ?p ?r\n  rat_poly_times ?a ?b = rat_poly_times ?b ?a\n\ngoal (1 subgoal):\n 1. rat_poly_times (p - q) r = rat_poly_times p r - rat_poly_times q r", "by metis"], ["", "lemma equation:\n   \"rat_poly_plus \n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) \n              = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "have \" rat_poly_times (rat_poly_times A A) A\n                       = ((A*A)*A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times (rat_poly_times A A) A =\n    rat_poly_times (rat_poly_times A A) A", "by auto"], ["proof (state)\nthis:\n  rat_poly_times (rat_poly_times A A) A =\n  rat_poly_times (rat_poly_times A A) A\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "then"], ["proof (chain)\npicking this:\n  rat_poly_times (rat_poly_times A A) A =\n  rat_poly_times (rat_poly_times A A) A", "have \"rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A)\n                     = B*B - B*((A*A)*A)\""], ["proof (prove)\nusing this:\n  rat_poly_times (rat_poly_times A A) A =\n  rat_poly_times (rat_poly_times A A) A\n\ngoal (1 subgoal):\n 1. rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A) =\n    rat_poly_times B B -\n    rat_poly_times B (rat_poly_times (rat_poly_times A A) A)", "using minus_left_distributivity"], ["proof (prove)\nusing this:\n  rat_poly_times (rat_poly_times A A) A =\n  rat_poly_times (rat_poly_times A A) A\n  rat_poly_times ?p (?q - ?r) = rat_poly_times ?p ?q - rat_poly_times ?p ?r\n\ngoal (1 subgoal):\n 1. rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A) =\n    rat_poly_times B B -\n    rat_poly_times B (rat_poly_times (rat_poly_times A A) A)", "by auto"], ["proof (state)\nthis:\n  rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A) =\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times (rat_poly_times A A) A)\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "moreover"], ["proof (state)\nthis:\n  rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A) =\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times (rat_poly_times A A) A)\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "have \"... = B*B - (B*(A*(A*A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times B B -\n    rat_poly_times B (rat_poly_times (rat_poly_times A A) A) =\n    rat_poly_times B B -\n    rat_poly_times B (rat_poly_times A (rat_poly_times A A))", "by auto"], ["proof (state)\nthis:\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times (rat_poly_times A A) A) =\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times A (rat_poly_times A A))\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "moreover"], ["proof (state)\nthis:\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times (rat_poly_times A A) A) =\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times A (rat_poly_times A A))\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "have \"... = B*B - ((B*A)*(A*A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times B B -\n    rat_poly_times B (rat_poly_times A (rat_poly_times A A)) =\n    rat_poly_times B B -\n    rat_poly_times (rat_poly_times B A) (rat_poly_times A A)", "by auto"], ["proof (state)\nthis:\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times A (rat_poly_times A A)) =\n  rat_poly_times B B -\n  rat_poly_times (rat_poly_times B A) (rat_poly_times A A)\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "moreover"], ["proof (state)\nthis:\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times A (rat_poly_times A A)) =\n  rat_poly_times B B -\n  rat_poly_times (rat_poly_times B A) (rat_poly_times A A)\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "have \"... = B*B - A*A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times B B -\n    rat_poly_times (rat_poly_times B A) (rat_poly_times A A) =\n    rat_poly_times B B - rat_poly_times A A", "using inverse2"], ["proof (prove)\nusing this:\n  rat_poly_times B A = 1\n\ngoal (1 subgoal):\n 1. rat_poly_times B B -\n    rat_poly_times (rat_poly_times B A) (rat_poly_times A A) =\n    rat_poly_times B B - rat_poly_times A A", "by auto"], ["proof (state)\nthis:\n  rat_poly_times B B -\n  rat_poly_times (rat_poly_times B A) (rat_poly_times A A) =\n  rat_poly_times B B - rat_poly_times A A\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A) =\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times (rat_poly_times A A) A)\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times (rat_poly_times A A) A) =\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times A (rat_poly_times A A))\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times A (rat_poly_times A A)) =\n  rat_poly_times B B -\n  rat_poly_times (rat_poly_times B A) (rat_poly_times A A)\n  rat_poly_times B B -\n  rat_poly_times (rat_poly_times B A) (rat_poly_times A A) =\n  rat_poly_times B B - rat_poly_times A A", "have 1:\n         \"rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A)\n                               =  B*B - A*A\""], ["proof (prove)\nusing this:\n  rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A) =\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times (rat_poly_times A A) A)\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times (rat_poly_times A A) A) =\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times A (rat_poly_times A A))\n  rat_poly_times B B -\n  rat_poly_times B (rat_poly_times A (rat_poly_times A A)) =\n  rat_poly_times B B -\n  rat_poly_times (rat_poly_times B A) (rat_poly_times A A)\n  rat_poly_times B B -\n  rat_poly_times (rat_poly_times B A) (rat_poly_times A A) =\n  rat_poly_times B B - rat_poly_times A A\n\ngoal (1 subgoal):\n 1. rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A) =\n    rat_poly_times B B - rat_poly_times A A", "by auto"], ["proof (state)\nthis:\n  rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A) =\n  rat_poly_times B B - rat_poly_times A A\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "have \"rat_poly_times (rat_poly_times B B) B = (B*B)*B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times (rat_poly_times B B) B =\n    rat_poly_times (rat_poly_times B B) B", "by auto"], ["proof (state)\nthis:\n  rat_poly_times (rat_poly_times B B) B =\n  rat_poly_times (rat_poly_times B B) B\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "then"], ["proof (chain)\npicking this:\n  rat_poly_times (rat_poly_times B B) B =\n  rat_poly_times (rat_poly_times B B) B", "have \n          \"(rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A)\n                  = (A*A) - ((B*B)*B)*A\""], ["proof (prove)\nusing this:\n  rat_poly_times (rat_poly_times B B) B =\n  rat_poly_times (rat_poly_times B B) B\n\ngoal (1 subgoal):\n 1. rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A =\n    rat_poly_times A A -\n    rat_poly_times (rat_poly_times (rat_poly_times B B) B) A", "using minus_right_distributivity"], ["proof (prove)\nusing this:\n  rat_poly_times (rat_poly_times B B) B =\n  rat_poly_times (rat_poly_times B B) B\n  rat_poly_times (?p - ?q) ?r = rat_poly_times ?p ?r - rat_poly_times ?q ?r\n\ngoal (1 subgoal):\n 1. rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A =\n    rat_poly_times A A -\n    rat_poly_times (rat_poly_times (rat_poly_times B B) B) A", "by auto"], ["proof (state)\nthis:\n  rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A =\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times (rat_poly_times B B) B) A\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "moreover"], ["proof (state)\nthis:\n  rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A =\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times (rat_poly_times B B) B) A\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "have \"... = (A*A) - ((B*B)*(B*A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times A A -\n    rat_poly_times (rat_poly_times (rat_poly_times B B) B) A =\n    rat_poly_times A A -\n    rat_poly_times (rat_poly_times B B) (rat_poly_times B A)", "by auto"], ["proof (state)\nthis:\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times (rat_poly_times B B) B) A =\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times B B) (rat_poly_times B A)\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "moreover"], ["proof (state)\nthis:\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times (rat_poly_times B B) B) A =\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times B B) (rat_poly_times B A)\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "have \"... = (A*A) - (B*B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times A A -\n    rat_poly_times (rat_poly_times B B) (rat_poly_times B A) =\n    rat_poly_times A A - rat_poly_times B B", "using inverse2"], ["proof (prove)\nusing this:\n  rat_poly_times B A = 1\n\ngoal (1 subgoal):\n 1. rat_poly_times A A -\n    rat_poly_times (rat_poly_times B B) (rat_poly_times B A) =\n    rat_poly_times A A - rat_poly_times B B", "by auto"], ["proof (state)\nthis:\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times B B) (rat_poly_times B A) =\n  rat_poly_times A A - rat_poly_times B B\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A =\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times (rat_poly_times B B) B) A\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times (rat_poly_times B B) B) A =\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times B B) (rat_poly_times B A)\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times B B) (rat_poly_times B A) =\n  rat_poly_times A A - rat_poly_times B B", "have 2:\n          \"(rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A)\n                  = (A*A) - (B*B)\""], ["proof (prove)\nusing this:\n  rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A =\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times (rat_poly_times B B) B) A\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times (rat_poly_times B B) B) A =\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times B B) (rat_poly_times B A)\n  rat_poly_times A A -\n  rat_poly_times (rat_poly_times B B) (rat_poly_times B A) =\n  rat_poly_times A A - rat_poly_times B B\n\ngoal (1 subgoal):\n 1. rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A =\n    rat_poly_times A A - rat_poly_times B B", "by auto"], ["proof (state)\nthis:\n  rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A =\n  rat_poly_times A A - rat_poly_times B B\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "have \"B*B - A*A + (A*A) - (B*B) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B * B - A * A + A * A - B * B = 0", "by auto"], ["proof (state)\nthis:\n  B * B - A * A + A * A - B * B = 0\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "with 1 2"], ["proof (chain)\npicking this:\n  rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A) =\n  rat_poly_times B B - rat_poly_times A A\n  rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A =\n  rat_poly_times A A - rat_poly_times B B\n  B * B - A * A + A * A - B * B = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A) =\n  rat_poly_times B B - rat_poly_times A A\n  rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A =\n  rat_poly_times A A - rat_poly_times B B\n  B * B - A * A + A * A - B * B = 0\n\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "by auto"], ["proof (state)\nthis:\n  rat_poly_plus\n   (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n   (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  \"rat_poly.matrix_mult (brickmat over) (brickmat under) \n   = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]] \""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (brickmat over) (brickmat brick.under) =\n    [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]", "apply(simp add:mat_multI_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matT_vec_multI 0 rat_poly_plus rat_poly_times\n     (map2 (#) [A, 0, 0, 0]\n       (map2 (#) [0, 0, B, 0]\n         (map2 (#) [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n           (map2 (#) [0, 0, 0, A]\n             (replicate\n               (rat_poly.row_length\n                 [[A, 0, 0, 0], [0, 0, B, 0],\n                  [0, B, A - rat_poly_times (rat_poly_times B B) B, 0],\n                  [0, 0, 0, A]])\n               [])))))\n     [B, 0, 0, 0] =\n    [1, 0, 0, 0] \\<and>\n    matT_vec_multI 0 rat_poly_plus rat_poly_times\n     (map2 (#) [A, 0, 0, 0]\n       (map2 (#) [0, 0, B, 0]\n         (map2 (#) [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n           (map2 (#) [0, 0, 0, A]\n             (replicate\n               (rat_poly.row_length\n                 [[A, 0, 0, 0], [0, 0, B, 0],\n                  [0, B, A - rat_poly_times (rat_poly_times B B) B, 0],\n                  [0, 0, 0, A]])\n               [])))))\n     [0, B - rat_poly_times (rat_poly_times A A) A, A, 0] =\n    [0, 1, 0, 0] \\<and>\n    matT_vec_multI 0 rat_poly_plus rat_poly_times\n     (map2 (#) [A, 0, 0, 0]\n       (map2 (#) [0, 0, B, 0]\n         (map2 (#) [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n           (map2 (#) [0, 0, 0, A]\n             (replicate\n               (rat_poly.row_length\n                 [[A, 0, 0, 0], [0, 0, B, 0],\n                  [0, B, A - rat_poly_times (rat_poly_times B B) B, 0],\n                  [0, 0, 0, A]])\n               [])))))\n     [0, A, 0, 0] =\n    [0, 0, 1, 0] \\<and>\n    matT_vec_multI 0 rat_poly_plus rat_poly_times\n     (map2 (#) [A, 0, 0, 0]\n       (map2 (#) [0, 0, B, 0]\n         (map2 (#) [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n           (map2 (#) [0, 0, 0, A]\n             (replicate\n               (rat_poly.row_length\n                 [[A, 0, 0, 0], [0, 0, B, 0],\n                  [0, B, A - rat_poly_times (rat_poly_times B B) B, 0],\n                  [0, 0, 0, A]])\n               [])))))\n     [0, 0, 0, B] =\n    [0, 0, 0, 1]", "apply(simp add:matT_vec_multI_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>w. scalar_prod w [B, 0, 0, 0]) \\<circ>\n         (\\<lambda>(x, y). x # y))\n     (zip [A, 0, 0, 0]\n       (map2 (#) [0, 0, B, 0]\n         (map2 (#) [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n           (map2 (#) [0, 0, 0, A]\n             (replicate\n               (rat_poly.row_length\n                 [[A, 0, 0, 0], [0, 0, B, 0],\n                  [0, B, A - rat_poly_times (rat_poly_times B B) B, 0],\n                  [0, 0, 0, A]])\n               []))))) =\n    [1, 0, 0, 0] \\<and>\n    map ((\\<lambda>w.\n             scalar_prod w\n              [0, B - rat_poly_times (rat_poly_times A A) A, A, 0]) \\<circ>\n         (\\<lambda>(x, y). x # y))\n     (zip [A, 0, 0, 0]\n       (map2 (#) [0, 0, B, 0]\n         (map2 (#) [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n           (map2 (#) [0, 0, 0, A]\n             (replicate\n               (rat_poly.row_length\n                 [[A, 0, 0, 0], [0, 0, B, 0],\n                  [0, B, A - rat_poly_times (rat_poly_times B B) B, 0],\n                  [0, 0, 0, A]])\n               []))))) =\n    [0, 1, 0, 0] \\<and>\n    map ((\\<lambda>w. scalar_prod w [0, A, 0, 0]) \\<circ>\n         (\\<lambda>(x, y). x # y))\n     (zip [A, 0, 0, 0]\n       (map2 (#) [0, 0, B, 0]\n         (map2 (#) [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n           (map2 (#) [0, 0, 0, A]\n             (replicate\n               (rat_poly.row_length\n                 [[A, 0, 0, 0], [0, 0, B, 0],\n                  [0, B, A - rat_poly_times (rat_poly_times B B) B, 0],\n                  [0, 0, 0, A]])\n               []))))) =\n    [0, 0, 1, 0] \\<and>\n    map ((\\<lambda>w. scalar_prod w [0, 0, 0, B]) \\<circ>\n         (\\<lambda>(x, y). x # y))\n     (zip [A, 0, 0, 0]\n       (map2 (#) [0, 0, B, 0]\n         (map2 (#) [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n           (map2 (#) [0, 0, 0, A]\n             (replicate\n               (rat_poly.row_length\n                 [[A, 0, 0, 0], [0, 0, B, 0],\n                  [0, B, A - rat_poly_times (rat_poly_times B B) B, 0],\n                  [0, 0, 0, A]])\n               []))))) =\n    [0, 0, 0, 1]", "apply(auto simp add:replicate_def rat_poly.row_length_def)"], ["proof (prove)\ngoal (16 subgoals):\n 1. scalar_prod [A, 0, 0, 0] [B, 0, 0, 0] = 1\n 2. scalar_prod [0, 0, B, 0] [B, 0, 0, 0] = 0\n 3. scalar_prod [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n     [B, 0, 0, 0] =\n    0\n 4. scalar_prod [0, 0, 0, A] [B, 0, 0, 0] = 0\n 5. scalar_prod [A, 0, 0, 0]\n     [0, B - rat_poly_times (rat_poly_times A A) A, A, 0] =\n    0\n 6. scalar_prod [0, 0, B, 0]\n     [0, B - rat_poly_times (rat_poly_times A A) A, A, 0] =\n    1\n 7. scalar_prod [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n     [0, B - rat_poly_times (rat_poly_times A A) A, A, 0] =\n    0\n 8. scalar_prod [0, 0, 0, A]\n     [0, B - rat_poly_times (rat_poly_times A A) A, A, 0] =\n    0\n 9. scalar_prod [A, 0, 0, 0] [0, A, 0, 0] = 0\n 10. scalar_prod [0, 0, B, 0] [0, A, 0, 0] = 0\nA total of 16 subgoals...", "apply(auto simp add:scalar_prod)"], ["proof (prove)\ngoal (5 subgoals):\n 1. rat_poly_times A B = 1\n 2. rat_poly_times B A = 1\n 3. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0\n 4. rat_poly_times B A = 1\n 5. rat_poly_times A B = 1", "apply(auto simp add:inverse1 inverse2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_plus\n     (rat_poly_times B (B - rat_poly_times (rat_poly_times A A) A))\n     (rat_poly_times (A - rat_poly_times (rat_poly_times B B) B) A) =\n    0", "apply(auto simp add:equation)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"rat_poly_inv A = -A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_inv A = rat_poly_inv A", "by auto"], ["", "lemma vert_dim:\"rat_poly.row_length (brickmat vert) = 2 \\<and>length (brickmat vert) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat vert) = 2 \\<and>\n    length (brickmat vert) = 2", "using rat_poly.row_length_def"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat vert) = 2 \\<and>\n    length (brickmat vert) = 2", "by auto"], ["", "lemma cup_dim:\"rat_poly.row_length (brickmat cup) = 1\" and \"length (brickmat cup) = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat cup) = 1 &&& length (brickmat cup) = 4", "using rat_poly.row_length_def"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat cup) = 1 &&& length (brickmat cup) = 4", "by auto"], ["", "lemma cap_dim:\"rat_poly.row_length (brickmat cap) = 4\" and \"length (brickmat cap) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat cap) = 4 &&& length (brickmat cap) = 1", "using rat_poly.row_length_def"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat cap) = 4 &&& length (brickmat cap) = 1", "by auto"], ["", "lemma over_dim:\"rat_poly.row_length (brickmat over) = 4\" and \"length (brickmat over) = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat over) = 4 &&& length (brickmat over) = 4", "using rat_poly.row_length_def"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat over) = 4 &&& length (brickmat over) = 4", "by auto"], ["", "lemma under_dim:\"rat_poly.row_length (brickmat under) = 4\" and \"length (brickmat under) = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat brick.under) = 4 &&&\n    length (brickmat brick.under) = 4", "using rat_poly.row_length_def"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat brick.under) = 4 &&&\n    length (brickmat brick.under) = 4", "by auto"], ["", "lemma mat_vert:\"mat 2 2 (brickmat vert)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 2 2 (brickmat vert)", "unfolding mat_def Ball_def vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (brickmat vert) = 2 \\<and>\n    (\\<forall>x. x \\<in> set (brickmat vert) \\<longrightarrow> length x = 2)", "by auto"], ["", "lemma mat_cup:\"mat 1 4 (brickmat cup)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 4 (brickmat cup)", "unfolding mat_def Ball_def vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (brickmat cup) = 4 \\<and>\n    (\\<forall>x. x \\<in> set (brickmat cup) \\<longrightarrow> length x = 1)", "by auto"], ["", "lemma mat_cap:\"mat 4 1 (brickmat cap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 4 1 (brickmat cap)", "unfolding mat_def Ball_def vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (brickmat cap) = 1 \\<and>\n    (\\<forall>x. x \\<in> set (brickmat cap) \\<longrightarrow> length x = 4)", "by auto"], ["", "lemma mat_over:\"mat 4 4 (brickmat over)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 4 4 (brickmat over)", "unfolding mat_def Ball_def vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (brickmat over) = 4 \\<and>\n    (\\<forall>x. x \\<in> set (brickmat over) \\<longrightarrow> length x = 4)", "by auto"], ["", "lemma mat_under:\"mat 4 4 (brickmat under)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 4 4 (brickmat brick.under)", "unfolding mat_def Ball_def vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (brickmat brick.under) = 4 \\<and>\n    (\\<forall>x.\n        x \\<in> set (brickmat brick.under) \\<longrightarrow> length x = 4)", "by auto"], ["", "primrec rowlength::\"nat \\<Rightarrow> nat\"\nwhere\n\"rowlength 0 = 1\"\n|\"rowlength (Suc k) = 2*(Suc k)\""], ["", "lemma \"(rat_poly.row_length (brickmat d)) =  (2^(nat (domain d))) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat d) = 2 ^ nat (Preliminaries.domain d)", "using vert_dim cup_dim cap_dim over_dim under_dim domain.simps"], ["proof (prove)\nusing this:\n  rat_poly.row_length (brickmat vert) = 2 \\<and> length (brickmat vert) = 2\n  rat_poly.row_length (brickmat cup) = 1\n  rat_poly.row_length (brickmat cap) = 4\n  rat_poly.row_length (brickmat over) = 4\n  rat_poly.row_length (brickmat brick.under) = 4\n  Preliminaries.domain vert = 1\n  Preliminaries.domain cup = 0\n  Preliminaries.domain cap = 2\n  Preliminaries.domain over = 2\n  Preliminaries.domain brick.under = 2\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat d) = 2 ^ nat (Preliminaries.domain d)", "by (cases d) (auto)"], ["", "lemma \"rat_poly.row_length (brickmat cup) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat cup) = 1", "unfolding rat_poly.row_length_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if brickmat cup = [] then 0 else length (hd (brickmat cup))) = 1", "by auto"], ["", "lemma two:\"(Suc (Suc 0)) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Suc 0) = 2", "by eval"], ["", "text\\<open>we assign every block to a matrix of rational function as follows\\<close>"], ["", "primrec blockmat::\"block \\<Rightarrow> rat_poly mat\"\nwhere\n\"blockmat [] = [[1]]\"\n|\"blockmat (l#ls) = (brickmat l) \\<otimes> (blockmat ls)\""], ["", "lemma \"blockmat [a] = brickmat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blockmat [a] = brickmat a", "unfolding blockmat.simps  rat_poly.Tensor_right_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. brickmat a = brickmat a", "by auto"], ["", "lemma nat_sum:\n assumes \"a \\<ge> 0\" and \"b \\<ge> 0\"\n shows \"nat (a+b) = (nat a) + (nat b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (a + b) = nat a + nat b", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> a\n  0 \\<le> b\n\ngoal (1 subgoal):\n 1. nat (a + b) = nat a + nat b", "by auto"], ["", "lemma \"rat_poly.row_length (blockmat ls) = (2^ (nat ((domain_block ls))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "proof(induct ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. rat_poly.row_length (blockmat []) = 2 ^ nat (domain_block [])\n 2. \\<And>a ls.\n       rat_poly.row_length (blockmat ls) =\n       2 ^ nat (domain_block ls) \\<Longrightarrow>\n       rat_poly.row_length (blockmat (a # ls)) =\n       2 ^ nat (domain_block (a # ls))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. rat_poly.row_length (blockmat []) = 2 ^ nat (domain_block [])\n 2. \\<And>a ls.\n       rat_poly.row_length (blockmat ls) =\n       2 ^ nat (domain_block ls) \\<Longrightarrow>\n       rat_poly.row_length (blockmat (a # ls)) =\n       2 ^ nat (domain_block (a # ls))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat []) = 2 ^ nat (domain_block [])", "unfolding blockmat.simps(1) rat_poly.row_length_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if [[1]] = [] then 0 else length (hd [[1]])) =\n    2 ^ nat (domain_block [])", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat []) = 2 ^ nat (domain_block [])\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       rat_poly.row_length (blockmat ls) =\n       2 ^ nat (domain_block ls) \\<Longrightarrow>\n       rat_poly.row_length (blockmat (a # ls)) =\n       2 ^ nat (domain_block (a # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       rat_poly.row_length (blockmat ls) =\n       2 ^ nat (domain_block ls) \\<Longrightarrow>\n       rat_poly.row_length (blockmat (a # ls)) =\n       2 ^ nat (domain_block (a # ls))", "case (Cons l ls)"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       rat_poly.row_length (blockmat ls) =\n       2 ^ nat (domain_block ls) \\<Longrightarrow>\n       rat_poly.row_length (blockmat (a # ls)) =\n       2 ^ nat (domain_block (a # ls))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "proof(cases l)"], ["proof (state)\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "case vert"], ["proof (state)\nthis:\n  l = vert\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "have \"rat_poly.row_length (blockmat (l#ls)) \n                        = (rat_poly.row_length (brickmat l))\n                            *(rat_poly.row_length (blockmat ls))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "using blockmat.simps  rat_poly.row_length_mat"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  rat_poly.row_length (?m1.0 \\<otimes> ?m2.0) =\n  rat_poly.row_length ?m1.0 * rat_poly.row_length ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2*(2 ^ nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    2 * 2 ^ nat (domain_block ls)", "using rat_poly.row_length_def Cons vert"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  l = vert\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    2 * 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  2 * 2 ^ nat (domain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  2 * 2 ^ nat (domain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(1 + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l) + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (1 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "using domain.simps vert"], ["proof (prove)\nusing this:\n  Preliminaries.domain vert = 1\n  Preliminaries.domain cup = 0\n  Preliminaries.domain cap = 2\n  Preliminaries.domain over = 2\n  Preliminaries.domain brick.under = 2\n  l = vert\n\ngoal (1 subgoal):\n 1. 2 ^ (1 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (1 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (1 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l + domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "using Suc_eq_plus1_left Suc_nat_eq_nat_zadd1 \n              calculation(4) domain.simps(1) domain_block_non_negative \n              vert"], ["proof (prove)\nusing this:\n  Suc ?n = 1 + ?n\n  0 \\<le> ?z \\<Longrightarrow> Suc (nat ?z) = nat (1 + ?z)\n  2 ^ (1 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  Preliminaries.domain vert = 1\n  0 \\<le> domain_block ?xs\n  l = vert\n\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "by (metis)"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  2 * 2 ^ nat (domain_block ls)\n  2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))\n  2 ^ (1 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  2 * 2 ^ nat (domain_block ls)\n  2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))\n  2 ^ (1 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "case over"], ["proof (state)\nthis:\n  l = over\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "have \"rat_poly.row_length (blockmat (l#ls)) \n                             = (rat_poly.row_length (brickmat l))\n                               *(rat_poly.row_length (blockmat ls))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "using blockmat.simps  rat_poly.row_length_mat"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  rat_poly.row_length (?m1.0 \\<otimes> ?m2.0) =\n  rat_poly.row_length ?m1.0 * rat_poly.row_length ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "also"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 4*(2 ^ nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "using rat_poly.row_length_def Cons over"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  l = over\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "also"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(2 + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "also"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l) + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "using domain.simps over"], ["proof (prove)\nusing this:\n  Preliminaries.domain vert = 1\n  Preliminaries.domain cup = 0\n  Preliminaries.domain cap = 2\n  Preliminaries.domain over = 2\n  Preliminaries.domain brick.under = 2\n  l = over\n\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "also"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l + domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "by (simp add: nat_add_distrib domain_block_nonnegative over)"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "also"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "by simp"], ["proof (state)\nthis:\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "finally"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "."], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "case under"], ["proof (state)\nthis:\n  l = brick.under\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "have \"rat_poly.row_length (blockmat (l#ls)) \n                              = (rat_poly.row_length (brickmat l))\n                                 *(rat_poly.row_length (blockmat ls))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "using blockmat.simps  rat_poly.row_length_mat"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  rat_poly.row_length (?m1.0 \\<otimes> ?m2.0) =\n  rat_poly.row_length ?m1.0 * rat_poly.row_length ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "also"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 4*(2 ^ nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "using rat_poly.row_length_def Cons under"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  l = brick.under\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "also"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(2 + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "also"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l) + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "using domain.simps under"], ["proof (prove)\nusing this:\n  Preliminaries.domain vert = 1\n  Preliminaries.domain cup = 0\n  Preliminaries.domain cap = 2\n  Preliminaries.domain over = 2\n  Preliminaries.domain brick.under = 2\n  l = brick.under\n\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "also"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l + domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "by (simp add: nat_add_distrib domain_block_nonnegative under)"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "also"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "finally"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "."], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "case cup"], ["proof (state)\nthis:\n  l = cup\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "have \"rat_poly.row_length (blockmat (l#ls)) \n                              = (rat_poly.row_length (brickmat l))\n                                *(rat_poly.row_length (blockmat ls))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "using blockmat.simps  rat_poly.row_length_mat"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  rat_poly.row_length (?m1.0 \\<otimes> ?m2.0) =\n  rat_poly.row_length ?m1.0 * rat_poly.row_length ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 1*(2 ^ nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    1 * 2 ^ nat (domain_block ls)", "using rat_poly.row_length_def Cons cup"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  l = cup\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    1 * 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  1 * 2 ^ nat (domain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  1 * 2 ^ nat (domain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(0 + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l) + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (0 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "using domain.simps cup"], ["proof (prove)\nusing this:\n  Preliminaries.domain vert = 1\n  Preliminaries.domain cup = 0\n  Preliminaries.domain cap = 2\n  Preliminaries.domain over = 2\n  Preliminaries.domain brick.under = 2\n  l = cup\n\ngoal (1 subgoal):\n 1. 2 ^ (0 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (0 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (0 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l + domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "using nat_sum cup  domain.simps(2) nat_0 plus_int_code(2) \n             plus_nat.add_0"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> nat (?a + ?b) = nat ?a + nat ?b\n  l = cup\n  Preliminaries.domain cup = 0\n  nat 0 = 0\n  0 + ?l = ?l\n  0 + ?n = ?n\n\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "by (metis)"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  1 * 2 ^ nat (domain_block ls)\n  1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))\n  2 ^ (0 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  1 * 2 ^ nat (domain_block ls)\n  1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))\n  2 ^ (0 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "case cap"], ["proof (state)\nthis:\n  l = cap\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "have \"rat_poly.row_length (blockmat (l#ls)) \n                             = (rat_poly.row_length (brickmat l))\n                                *(rat_poly.row_length (blockmat ls))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "using blockmat.simps  rat_poly.row_length_mat"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  rat_poly.row_length (?m1.0 \\<otimes> ?m2.0) =\n  rat_poly.row_length ?m1.0 * rat_poly.row_length ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 4*(2 ^ nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "using rat_poly.row_length_def Cons cap"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  l = cap\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(2 + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l) + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "using domain.simps cap"], ["proof (prove)\nusing this:\n  Preliminaries.domain vert = 1\n  Preliminaries.domain cup = 0\n  Preliminaries.domain cap = 2\n  Preliminaries.domain over = 2\n  Preliminaries.domain brick.under = 2\n  l = cap\n\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l + domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "by (simp add: cap domain_block_nonnegative nat_add_distrib)"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_length_domain_block:\n \"rat_poly.row_length (blockmat ls) = (2^ (nat ((domain_block ls))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "proof(induct ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. rat_poly.row_length (blockmat []) = 2 ^ nat (domain_block [])\n 2. \\<And>a ls.\n       rat_poly.row_length (blockmat ls) =\n       2 ^ nat (domain_block ls) \\<Longrightarrow>\n       rat_poly.row_length (blockmat (a # ls)) =\n       2 ^ nat (domain_block (a # ls))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. rat_poly.row_length (blockmat []) = 2 ^ nat (domain_block [])\n 2. \\<And>a ls.\n       rat_poly.row_length (blockmat ls) =\n       2 ^ nat (domain_block ls) \\<Longrightarrow>\n       rat_poly.row_length (blockmat (a # ls)) =\n       2 ^ nat (domain_block (a # ls))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat []) = 2 ^ nat (domain_block [])", "unfolding blockmat.simps(1) rat_poly.row_length_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if [[1]] = [] then 0 else length (hd [[1]])) =\n    2 ^ nat (domain_block [])", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat []) = 2 ^ nat (domain_block [])\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       rat_poly.row_length (blockmat ls) =\n       2 ^ nat (domain_block ls) \\<Longrightarrow>\n       rat_poly.row_length (blockmat (a # ls)) =\n       2 ^ nat (domain_block (a # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       rat_poly.row_length (blockmat ls) =\n       2 ^ nat (domain_block ls) \\<Longrightarrow>\n       rat_poly.row_length (blockmat (a # ls)) =\n       2 ^ nat (domain_block (a # ls))", "case (Cons l ls)"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       rat_poly.row_length (blockmat ls) =\n       2 ^ nat (domain_block ls) \\<Longrightarrow>\n       rat_poly.row_length (blockmat (a # ls)) =\n       2 ^ nat (domain_block (a # ls))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "proof(cases l)"], ["proof (state)\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "case vert"], ["proof (state)\nthis:\n  l = vert\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "have \"rat_poly.row_length (blockmat (l#ls)) \n                              = (rat_poly.row_length (brickmat l))\n                                 *(rat_poly.row_length (blockmat ls))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "using blockmat.simps  rat_poly.row_length_mat"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  rat_poly.row_length (?m1.0 \\<otimes> ?m2.0) =\n  rat_poly.row_length ?m1.0 * rat_poly.row_length ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2*(2 ^ nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    2 * 2 ^ nat (domain_block ls)", "using rat_poly.row_length_def Cons vert"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  l = vert\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    2 * 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  2 * 2 ^ nat (domain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  2 * 2 ^ nat (domain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(1 + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l) + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (1 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "using domain.simps vert"], ["proof (prove)\nusing this:\n  Preliminaries.domain vert = 1\n  Preliminaries.domain cup = 0\n  Preliminaries.domain cap = 2\n  Preliminaries.domain over = 2\n  Preliminaries.domain brick.under = 2\n  l = vert\n\ngoal (1 subgoal):\n 1. 2 ^ (1 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (1 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (1 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l + domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "using Suc_eq_plus1_left Suc_nat_eq_nat_zadd1 calculation(4) domain.simps(1) \n                domain_block_non_negative vert"], ["proof (prove)\nusing this:\n  Suc ?n = 1 + ?n\n  0 \\<le> ?z \\<Longrightarrow> Suc (nat ?z) = nat (1 + ?z)\n  2 ^ (1 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  Preliminaries.domain vert = 1\n  0 \\<le> domain_block ?xs\n  l = vert\n\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "by metis"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  2 * 2 ^ nat (domain_block ls)\n  2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))\n  2 ^ (1 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  2 * 2 ^ nat (domain_block ls)\n  2 * 2 ^ nat (domain_block ls) = 2 ^ (1 + nat (domain_block ls))\n  2 ^ (1 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "case over"], ["proof (state)\nthis:\n  l = over\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "have \"rat_poly.row_length (blockmat (l#ls)) \n                      = (rat_poly.row_length (brickmat l))\n                         *(rat_poly.row_length (blockmat ls))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "using blockmat.simps  rat_poly.row_length_mat"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  rat_poly.row_length (?m1.0 \\<otimes> ?m2.0) =\n  rat_poly.row_length ?m1.0 * rat_poly.row_length ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 4*(2 ^ nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "using rat_poly.row_length_def Cons over"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  l = over\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(2 + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l) + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "using domain.simps over"], ["proof (prove)\nusing this:\n  Preliminaries.domain vert = 1\n  Preliminaries.domain cup = 0\n  Preliminaries.domain cap = 2\n  Preliminaries.domain over = 2\n  Preliminaries.domain brick.under = 2\n  l = over\n\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l + domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "by (simp add: over domain_block_nonnegative nat_add_distrib)"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "case under"], ["proof (state)\nthis:\n  l = brick.under\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "have \"rat_poly.row_length (blockmat (l#ls)) \n                        = (rat_poly.row_length (brickmat l))\n                                *(rat_poly.row_length (blockmat ls))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "using blockmat.simps  rat_poly.row_length_mat"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  rat_poly.row_length (?m1.0 \\<otimes> ?m2.0) =\n  rat_poly.row_length ?m1.0 * rat_poly.row_length ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 4*(2 ^ nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "using rat_poly.row_length_def Cons under"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  l = brick.under\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(2 + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l) + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "using domain.simps under"], ["proof (prove)\nusing this:\n  Preliminaries.domain vert = 1\n  Preliminaries.domain cup = 0\n  Preliminaries.domain cap = 2\n  Preliminaries.domain over = 2\n  Preliminaries.domain brick.under = 2\n  l = brick.under\n\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l + domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "by (simp add: under domain_block_nonnegative nat_add_distrib)"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "case cup"], ["proof (state)\nthis:\n  l = cup\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "have \"rat_poly.row_length (blockmat (l#ls)) \n                              = (rat_poly.row_length (brickmat l))\n                                   *(rat_poly.row_length (blockmat ls))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "using blockmat.simps  rat_poly.row_length_mat"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  rat_poly.row_length (?m1.0 \\<otimes> ?m2.0) =\n  rat_poly.row_length ?m1.0 * rat_poly.row_length ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 1*(2 ^ nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    1 * 2 ^ nat (domain_block ls)", "using rat_poly.row_length_def Cons cup"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  l = cup\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    1 * 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  1 * 2 ^ nat (domain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  1 * 2 ^ nat (domain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(0 + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l) + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (0 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "using domain.simps cup"], ["proof (prove)\nusing this:\n  Preliminaries.domain vert = 1\n  Preliminaries.domain cup = 0\n  Preliminaries.domain cap = 2\n  Preliminaries.domain over = 2\n  Preliminaries.domain brick.under = 2\n  l = cup\n\ngoal (1 subgoal):\n 1. 2 ^ (0 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (0 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (0 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l + domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "using nat_sum cup  domain.simps(2) \n                nat_0 plus_int_code(2) plus_nat.add_0"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> nat (?a + ?b) = nat ?a + nat ?b\n  l = cup\n  Preliminaries.domain cup = 0\n  nat 0 = 0\n  0 + ?l = ?l\n  0 + ?n = ?n\n\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "by (metis)"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  1 * 2 ^ nat (domain_block ls)\n  1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))\n  2 ^ (0 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  1 * 2 ^ nat (domain_block ls)\n  1 * 2 ^ nat (domain_block ls) = 2 ^ (0 + nat (domain_block ls))\n  2 ^ (0 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "case cap"], ["proof (state)\nthis:\n  l = cap\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)", "have \"rat_poly.row_length (blockmat (l#ls)) \n                              = (rat_poly.row_length (brickmat l))\n                                 *(rat_poly.row_length (blockmat ls))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "using blockmat.simps  rat_poly.row_length_mat"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  rat_poly.row_length (?m1.0 \\<otimes> ?m2.0) =\n  rat_poly.row_length ?m1.0 * rat_poly.row_length ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 4*(2 ^ nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "using rat_poly.row_length_def Cons cap"], ["proof (prove)\nusing this:\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  rat_poly.row_length (blockmat ls) = 2 ^ nat (domain_block ls)\n  l = cap\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n    4 * 2 ^ nat (domain_block ls)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(2 + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l) + nat (domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "using domain.simps cap"], ["proof (prove)\nusing this:\n  Preliminaries.domain vert = 1\n  Preliminaries.domain cup = 0\n  Preliminaries.domain cap = 2\n  Preliminaries.domain over = 2\n  Preliminaries.domain brick.under = 2\n  l = cap\n\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (domain_block ls)) =\n    2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain l + domain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n    2 ^ nat (Preliminaries.domain l + domain_block ls)", "by (simp add: cap domain_block_nonnegative nat_add_distrib)"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "have \"... = 2^(nat (domain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "using domain_block.simps"], ["proof (prove)\nusing this:\n  domain_block [] = 0\n  domain_block (?x # ?y) = Preliminaries.domain ?x + domain_block ?y\n\ngoal (1 subgoal):\n 1. 2 ^ nat (Preliminaries.domain l + domain_block ls) =\n    2 ^ nat (domain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat (l # ls)) =\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls)\n  rat_poly.row_length (brickmat l) * rat_poly.row_length (blockmat ls) =\n  4 * 2 ^ nat (domain_block ls)\n  4 * 2 ^ nat (domain_block ls) = 2 ^ (2 + nat (domain_block ls))\n  2 ^ (2 + nat (domain_block ls)) =\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls))\n  2 ^ (nat (Preliminaries.domain l) + nat (domain_block ls)) =\n  2 ^ nat (Preliminaries.domain l + domain_block ls)\n  2 ^ nat (Preliminaries.domain l + domain_block ls) =\n  2 ^ nat (domain_block (l # ls))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (l # ls)) =\n    2 ^ nat (domain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (l # ls)) = 2 ^ nat (domain_block (l # ls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_codomain_block:\"length (blockmat ls) \n                                    = (2^ (nat ((codomain_block ls))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat ls) = 2 ^ nat (codomain_block ls)", "proof(induct ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (blockmat []) = 2 ^ nat (codomain_block [])\n 2. \\<And>a ls.\n       length (blockmat ls) = 2 ^ nat (codomain_block ls) \\<Longrightarrow>\n       length (blockmat (a # ls)) = 2 ^ nat (codomain_block (a # ls))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. length (blockmat []) = 2 ^ nat (codomain_block [])\n 2. \\<And>a ls.\n       length (blockmat ls) = 2 ^ nat (codomain_block ls) \\<Longrightarrow>\n       length (blockmat (a # ls)) = 2 ^ nat (codomain_block (a # ls))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat []) = 2 ^ nat (codomain_block [])", "unfolding blockmat.simps(1) rat_poly.row_length_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [[1]] = 2 ^ nat (codomain_block [])", "by auto"], ["proof (state)\nthis:\n  length (blockmat []) = 2 ^ nat (codomain_block [])\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       length (blockmat ls) = 2 ^ nat (codomain_block ls) \\<Longrightarrow>\n       length (blockmat (a # ls)) = 2 ^ nat (codomain_block (a # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       length (blockmat ls) = 2 ^ nat (codomain_block ls) \\<Longrightarrow>\n       length (blockmat (a # ls)) = 2 ^ nat (codomain_block (a # ls))", "case (Cons l ls)"], ["proof (state)\nthis:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       length (blockmat ls) = 2 ^ nat (codomain_block ls) \\<Longrightarrow>\n       length (blockmat (a # ls)) = 2 ^ nat (codomain_block (a # ls))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "proof(cases l)"], ["proof (state)\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "case vert"], ["proof (state)\nthis:\n  l = vert\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"length (blockmat ls) = 2 ^ nat (codomain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat ls) = 2 ^ nat (codomain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. length (blockmat ls) = 2 ^ nat (codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)", "have \"length (blockmat (l#ls)) \n                              = (length (brickmat l))*(length (blockmat ls))\""], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)", "using blockmat.simps rat_poly.length_Tensor"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  length (?M1.0 \\<otimes> ?M2.0) = length ?M1.0 * length ?M2.0\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2*(2 ^ nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (brickmat l) * length (blockmat ls) =\n    2 * 2 ^ nat (codomain_block ls)", "using  Cons vert"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n  l = vert\n\ngoal (1 subgoal):\n 1. length (brickmat l) * length (blockmat ls) =\n    2 * 2 ^ nat (codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  length (brickmat l) * length (blockmat ls) =\n  2 * 2 ^ nat (codomain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  length (brickmat l) * length (blockmat ls) =\n  2 * 2 ^ nat (codomain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(1 + nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * 2 ^ nat (codomain_block ls) = 2 ^ (1 + nat (codomain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 * 2 ^ nat (codomain_block ls) = 2 ^ (1 + nat (codomain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 * 2 ^ nat (codomain_block ls) = 2 ^ (1 + nat (codomain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain l) + nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (1 + nat (codomain_block ls)) =\n    2 ^ (nat (codomain l) + nat (codomain_block ls))", "using codomain.simps vert"], ["proof (prove)\nusing this:\n  codomain vert = 1\n  codomain cup = 2\n  codomain cap = 0\n  codomain over = 2\n  codomain brick.under = 2\n  l = vert\n\ngoal (1 subgoal):\n 1. 2 ^ (1 + nat (codomain_block ls)) =\n    2 ^ (nat (codomain l) + nat (codomain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (1 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (1 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain l + codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n    2 ^ nat (codomain l + codomain_block ls)", "using nat_sum  Suc_eq_plus1_left Suc_nat_eq_nat_zadd1 \n               codomain.simps(1)  codomain_block_nonnegative nat_numeral \n               numeral_One vert"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> nat (?a + ?b) = nat ?a + nat ?b\n  Suc ?n = 1 + ?n\n  0 \\<le> ?z \\<Longrightarrow> Suc (nat ?z) = nat (1 + ?z)\n  codomain vert = 1\n  0 \\<le> codomain_block ?x\n  nat (numeral ?k) = numeral ?k\n  Numeral1 = (1::?'a)\n  l = vert\n\ngoal (1 subgoal):\n 1. 2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n    2 ^ nat (codomain l + codomain_block ls)", "by (metis)"], ["proof (state)\nthis:\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (codomain l + codomain_block ls) =\n    2 ^ nat (codomain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))\n\ngoal (5 subgoals):\n 1. l = vert \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 5. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n  length (brickmat l) * length (blockmat ls) =\n  2 * 2 ^ nat (codomain_block ls)\n  2 * 2 ^ nat (codomain_block ls) = 2 ^ (1 + nat (codomain_block ls))\n  2 ^ (1 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n  length (brickmat l) * length (blockmat ls) =\n  2 * 2 ^ nat (codomain_block ls)\n  2 * 2 ^ nat (codomain_block ls) = 2 ^ (1 + nat (codomain_block ls))\n  2 ^ (1 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "case over"], ["proof (state)\nthis:\n  l = over\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"length (blockmat ls) = 2 ^ nat (codomain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat ls) = 2 ^ nat (codomain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. length (blockmat ls) = 2 ^ nat (codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)", "have \"length (blockmat (l#ls)) \n                              = (length (brickmat l))*(length (blockmat ls))\""], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)", "using blockmat.simps rat_poly.length_Tensor"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  length (?M1.0 \\<otimes> ?M2.0) = length ?M1.0 * length ?M2.0\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 4*(2 ^ nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (brickmat l) * length (blockmat ls) =\n    4 * 2 ^ nat (codomain_block ls)", "using  Cons over"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n  l = over\n\ngoal (1 subgoal):\n 1. length (brickmat l) * length (blockmat ls) =\n    4 * 2 ^ nat (codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(2 + nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))", "by auto"], ["proof (state)\nthis:\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain l) + nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (codomain_block ls)) =\n    2 ^ (nat (codomain l) + nat (codomain_block ls))", "using codomain.simps over"], ["proof (prove)\nusing this:\n  codomain vert = 1\n  codomain cup = 2\n  codomain cap = 0\n  codomain over = 2\n  codomain brick.under = 2\n  l = over\n\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (codomain_block ls)) =\n    2 ^ (nat (codomain l) + nat (codomain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain l + codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n    2 ^ nat (codomain l + codomain_block ls)", "using nat_sum  over codomain.simps codomain_block_nonnegative"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> nat (?a + ?b) = nat ?a + nat ?b\n  l = over\n  codomain vert = 1\n  codomain cup = 2\n  codomain cap = 0\n  codomain over = 2\n  codomain brick.under = 2\n  0 \\<le> codomain_block ?x\n\ngoal (1 subgoal):\n 1. 2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n    2 ^ nat (codomain l + codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (codomain l + codomain_block ls) =\n    2 ^ nat (codomain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))\n\ngoal (4 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = over \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 4. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "case under"], ["proof (state)\nthis:\n  l = brick.under\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"length (blockmat ls) = 2 ^ nat (codomain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat ls) = 2 ^ nat (codomain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. length (blockmat ls) = 2 ^ nat (codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)", "have \"length (blockmat (l#ls)) \n                              = (length (brickmat l))*(length (blockmat ls))\""], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)", "using blockmat.simps rat_poly.length_Tensor"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  length (?M1.0 \\<otimes> ?M2.0) = length ?M1.0 * length ?M2.0\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 4*(2 ^ nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (brickmat l) * length (blockmat ls) =\n    4 * 2 ^ nat (codomain_block ls)", "using  Cons under"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n  l = brick.under\n\ngoal (1 subgoal):\n 1. length (brickmat l) * length (blockmat ls) =\n    4 * 2 ^ nat (codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(2 + nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))", "by auto"], ["proof (state)\nthis:\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain l) + nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (codomain_block ls)) =\n    2 ^ (nat (codomain l) + nat (codomain_block ls))", "using codomain.simps under"], ["proof (prove)\nusing this:\n  codomain vert = 1\n  codomain cup = 2\n  codomain cap = 0\n  codomain over = 2\n  codomain brick.under = 2\n  l = brick.under\n\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (codomain_block ls)) =\n    2 ^ (nat (codomain l) + nat (codomain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain l + codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n    2 ^ nat (codomain l + codomain_block ls)", "using nat_sum  under codomain.simps codomain_block_nonnegative"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> nat (?a + ?b) = nat ?a + nat ?b\n  l = brick.under\n  codomain vert = 1\n  codomain cup = 2\n  codomain cap = 0\n  codomain over = 2\n  codomain brick.under = 2\n  0 \\<le> codomain_block ?x\n\ngoal (1 subgoal):\n 1. 2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n    2 ^ nat (codomain l + codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (codomain l + codomain_block ls) =\n    2 ^ nat (codomain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))\n\ngoal (3 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 3. l = brick.under \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "case cup"], ["proof (state)\nthis:\n  l = cup\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"length (blockmat ls) = 2 ^ nat (codomain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat ls) = 2 ^ nat (codomain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. length (blockmat ls) = 2 ^ nat (codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)", "have \"length (blockmat (l#ls)) \n                              = (length (brickmat l))*(length (blockmat ls))\""], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)", "using blockmat.simps rat_poly.length_Tensor"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  length (?M1.0 \\<otimes> ?M2.0) = length ?M1.0 * length ?M2.0\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 4*(2 ^ nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (brickmat l) * length (blockmat ls) =\n    4 * 2 ^ nat (codomain_block ls)", "using  Cons cup"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n  l = cup\n\ngoal (1 subgoal):\n 1. length (brickmat l) * length (blockmat ls) =\n    4 * 2 ^ nat (codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(2 + nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))", "by auto"], ["proof (state)\nthis:\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain l) + nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (codomain_block ls)) =\n    2 ^ (nat (codomain l) + nat (codomain_block ls))", "using codomain.simps cup"], ["proof (prove)\nusing this:\n  codomain vert = 1\n  codomain cup = 2\n  codomain cap = 0\n  codomain over = 2\n  codomain brick.under = 2\n  l = cup\n\ngoal (1 subgoal):\n 1. 2 ^ (2 + nat (codomain_block ls)) =\n    2 ^ (nat (codomain l) + nat (codomain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain l + codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n    2 ^ nat (codomain l + codomain_block ls)", "using nat_sum  cup codomain.simps \n                 codomain_block_nonnegative"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> nat (?a + ?b) = nat ?a + nat ?b\n  l = cup\n  codomain vert = 1\n  codomain cup = 2\n  codomain cap = 0\n  codomain over = 2\n  codomain brick.under = 2\n  0 \\<le> codomain_block ?x\n\ngoal (1 subgoal):\n 1. 2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n    2 ^ nat (codomain l + codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (codomain l + codomain_block ls) =\n    2 ^ nat (codomain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))\n\ngoal (2 subgoals):\n 1. l = cup \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n 2. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n  length (brickmat l) * length (blockmat ls) =\n  4 * 2 ^ nat (codomain_block ls)\n  4 * 2 ^ nat (codomain_block ls) = 2 ^ (2 + nat (codomain_block ls))\n  2 ^ (2 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "case cap"], ["proof (state)\nthis:\n  l = cap\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"length (blockmat ls) = 2 ^ nat (codomain_block ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat ls) = 2 ^ nat (codomain_block ls)", "using Cons"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. length (blockmat ls) = 2 ^ nat (codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "then"], ["proof (chain)\npicking this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)", "have \"length (blockmat (l#ls)) \n                              = (length (brickmat l))*(length (blockmat ls))\""], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)", "using blockmat.simps rat_poly.length_Tensor"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  length (?M1.0 \\<otimes> ?M2.0) = length ?M1.0 * length ?M2.0\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 1*(2 ^ nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (brickmat l) * length (blockmat ls) =\n    1 * 2 ^ nat (codomain_block ls)", "using  Cons cap"], ["proof (prove)\nusing this:\n  length (blockmat ls) = 2 ^ nat (codomain_block ls)\n  l = cap\n\ngoal (1 subgoal):\n 1. length (brickmat l) * length (blockmat ls) =\n    1 * 2 ^ nat (codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  length (brickmat l) * length (blockmat ls) =\n  1 * 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  length (brickmat l) * length (blockmat ls) =\n  1 * 2 ^ nat (codomain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(0 + nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 2 ^ nat (codomain_block ls) = 2 ^ (0 + nat (codomain_block ls))", "by auto"], ["proof (state)\nthis:\n  1 * 2 ^ nat (codomain_block ls) = 2 ^ (0 + nat (codomain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  1 * 2 ^ nat (codomain_block ls) = 2 ^ (0 + nat (codomain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain l) + nat (codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (0 + nat (codomain_block ls)) =\n    2 ^ (nat (codomain l) + nat (codomain_block ls))", "using codomain.simps cap"], ["proof (prove)\nusing this:\n  codomain vert = 1\n  codomain cup = 2\n  codomain cap = 0\n  codomain over = 2\n  codomain brick.under = 2\n  l = cap\n\ngoal (1 subgoal):\n 1. 2 ^ (0 + nat (codomain_block ls)) =\n    2 ^ (nat (codomain l) + nat (codomain_block ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ (0 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (0 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain l + codomain_block ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n    2 ^ nat (codomain l + codomain_block ls)", "using nat_sum cap codomain.simps codomain_block_nonnegative"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> nat (?a + ?b) = nat ?a + nat ?b\n  l = cap\n  codomain vert = 1\n  codomain cup = 2\n  codomain cap = 0\n  codomain over = 2\n  codomain brick.under = 2\n  0 \\<le> codomain_block ?x\n\ngoal (1 subgoal):\n 1. 2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n    2 ^ nat (codomain l + codomain_block ls)", "by auto"], ["proof (state)\nthis:\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "moreover"], ["proof (state)\nthis:\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "have \"... = 2^(nat (codomain_block (l#ls)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (codomain l + codomain_block ls) =\n    2 ^ nat (codomain_block (l # ls))", "by auto"], ["proof (state)\nthis:\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))\n\ngoal (1 subgoal):\n 1. l = cap \\<Longrightarrow>\n    length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "ultimately"], ["proof (chain)\npicking this:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n  length (brickmat l) * length (blockmat ls) =\n  1 * 2 ^ nat (codomain_block ls)\n  1 * 2 ^ nat (codomain_block ls) = 2 ^ (0 + nat (codomain_block ls))\n  2 ^ (0 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (blockmat (l # ls)) = length (brickmat l) * length (blockmat ls)\n  length (brickmat l) * length (blockmat ls) =\n  1 * 2 ^ nat (codomain_block ls)\n  1 * 2 ^ nat (codomain_block ls) = 2 ^ (0 + nat (codomain_block ls))\n  2 ^ (0 + nat (codomain_block ls)) =\n  2 ^ (nat (codomain l) + nat (codomain_block ls))\n  2 ^ (nat (codomain l) + nat (codomain_block ls)) =\n  2 ^ nat (codomain l + codomain_block ls)\n  2 ^ nat (codomain l + codomain_block ls) =\n  2 ^ nat (codomain_block (l # ls))\n\ngoal (1 subgoal):\n 1. length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))", "by metis"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (blockmat (l # ls)) = 2 ^ nat (codomain_block (l # ls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_blockmat:\n \"mat \n      (rat_poly.row_length (blockmat ls)) \n      (length (blockmat ls))  \n                    (blockmat ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n     (blockmat ls)", "proof(induct ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. mat (rat_poly.row_length (blockmat [])) (length (blockmat []))\n     (blockmat [])\n 2. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. mat (rat_poly.row_length (blockmat [])) (length (blockmat []))\n     (blockmat [])\n 2. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat [])) (length (blockmat []))\n     (blockmat [])", "using Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat [])) (length (blockmat []))\n     (blockmat [])", "unfolding blockmat.simps(1) rat_poly.row_length_def mat_def \n        vec_def Ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [[1]] = length [[1]] \\<and>\n    (\\<forall>x.\n        x \\<in> set [[1]] \\<longrightarrow>\n        length x = (if [[1]] = [] then 0 else length (hd [[1]])))", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat [])) (length (blockmat []))\n   (blockmat [])\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "case (Cons a ls)"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n   (blockmat ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "have Cons_1:\"mat \n                 (rat_poly.row_length (blockmat ls)) \n                 (length (blockmat ls)) \n                                   (blockmat ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n     (blockmat ls)", "using Cons"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n   (blockmat ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n     (blockmat ls)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n   (blockmat ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "have Cons_2:\"(blockmat (a#ls)) = (brickmat a)\\<otimes>(blockmat ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blockmat (a # ls) = brickmat a \\<otimes> blockmat ls", "using blockmat.simps"], ["proof (prove)\nusing this:\n  blockmat [] = [[1]]\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n\ngoal (1 subgoal):\n 1. blockmat (a # ls) = brickmat a \\<otimes> blockmat ls", "by auto"], ["proof (state)\nthis:\n  blockmat (a # ls) = brickmat a \\<otimes> blockmat ls\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "moreover"], ["proof (state)\nthis:\n  blockmat (a # ls) = brickmat a \\<otimes> blockmat ls\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "have \"rat_poly.row_length (blockmat (a#ls)) \n                        = (rat_poly.row_length (brickmat a))\n                                 *(rat_poly.row_length (blockmat ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (a # ls)) =\n    rat_poly.row_length (brickmat a) * rat_poly.row_length (blockmat ls)", "using calculation rat_poly.row_length_mat"], ["proof (prove)\nusing this:\n  blockmat (a # ls) = brickmat a \\<otimes> blockmat ls\n  rat_poly.row_length (?m1.0 \\<otimes> ?m2.0) =\n  rat_poly.row_length ?m1.0 * rat_poly.row_length ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat (a # ls)) =\n    rat_poly.row_length (brickmat a) * rat_poly.row_length (blockmat ls)", "by (metis)"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (a # ls)) =\n  rat_poly.row_length (brickmat a) * rat_poly.row_length (blockmat ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat (a # ls)) =\n  rat_poly.row_length (brickmat a) * rat_poly.row_length (blockmat ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "have \"length (blockmat (a#ls)) \n                             = (length (brickmat a))\n                                      *(length (blockmat ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat (a # ls)) = length (brickmat a) * length (blockmat ls)", "using  blockmat.simps(2) rat_poly.length_Tensor"], ["proof (prove)\nusing this:\n  blockmat (?l # ?ls) = brickmat ?l \\<otimes> blockmat ?ls\n  length (?M1.0 \\<otimes> ?M2.0) = length ?M1.0 * length ?M2.0\n\ngoal (1 subgoal):\n 1. length (blockmat (a # ls)) = length (brickmat a) * length (blockmat ls)", "by (metis)"], ["proof (state)\nthis:\n  length (blockmat (a # ls)) = length (brickmat a) * length (blockmat ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "ultimately"], ["proof (chain)\npicking this:\n  blockmat (a # ls) = brickmat a \\<otimes> blockmat ls\n  rat_poly.row_length (blockmat (a # ls)) =\n  rat_poly.row_length (brickmat a) * rat_poly.row_length (blockmat ls)\n  length (blockmat (a # ls)) = length (brickmat a) * length (blockmat ls)", "have Cons_3:\"mat \n                            (rat_poly.row_length (brickmat a)) \n                            (length (brickmat a)) \n                                         (brickmat a)\n                      \\<Longrightarrow> ?case\""], ["proof (prove)\nusing this:\n  blockmat (a # ls) = brickmat a \\<otimes> blockmat ls\n  rat_poly.row_length (blockmat (a # ls)) =\n  rat_poly.row_length (brickmat a) * rat_poly.row_length (blockmat ls)\n  length (blockmat (a # ls)) = length (brickmat a) * length (blockmat ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a) \\<Longrightarrow>\n    mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "using rat_poly.well_defined_Tensor Cons"], ["proof (prove)\nusing this:\n  blockmat (a # ls) = brickmat a \\<otimes> blockmat ls\n  rat_poly.row_length (blockmat (a # ls)) =\n  rat_poly.row_length (brickmat a) * rat_poly.row_length (blockmat ls)\n  length (blockmat (a # ls)) = length (brickmat a) * length (blockmat ls)\n  mat (rat_poly.row_length ?M1.0) (length ?M1.0) ?M1.0 \\<and>\n  mat (rat_poly.row_length ?M2.0) (length ?M2.0) ?M2.0 \\<Longrightarrow>\n  mat (rat_poly.row_length ?M1.0 * rat_poly.row_length ?M2.0)\n   (length ?M1.0 * length ?M2.0) (?M1.0 \\<otimes> ?M2.0)\n  mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n   (blockmat ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a) \\<Longrightarrow>\n    mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n   (brickmat a) \\<Longrightarrow>\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       mat (rat_poly.row_length (blockmat ls)) (length (blockmat ls))\n        (blockmat ls) \\<Longrightarrow>\n       mat (rat_poly.row_length (blockmat (a # ls)))\n        (length (blockmat (a # ls))) (blockmat (a # ls))", "then"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n   (brickmat a) \\<Longrightarrow>\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))", "show ?case"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n   (brickmat a) \\<Longrightarrow>\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "proof(cases a)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = vert\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 3. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 4. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = over\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 5. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = brick.under\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "case vert"], ["proof (state)\nthis:\n  a = vert\n\ngoal (5 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = vert\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 3. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 4. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = over\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 5. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = brick.under\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "have \"mat \n                (rat_poly.row_length (brickmat a)) \n                (length (brickmat a)) \n                    (brickmat a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a)", "using vert_dim mat_vert rat_poly.matrix_row_length vert"], ["proof (prove)\nusing this:\n  rat_poly.row_length (brickmat vert) = 2 \\<and> length (brickmat vert) = 2\n  mat 2 2 (brickmat vert)\n  mat ?nr ?nc ?M \\<Longrightarrow>\n  mat (rat_poly.row_length ?M) (length ?M) ?M\n  a = vert\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a)", "by metis"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = vert\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 3. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 4. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = over\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 5. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = brick.under\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "using Cons_3"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n   (brickmat a) \\<Longrightarrow>\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 3. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = over\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 4. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = brick.under\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 3. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = over\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 4. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = brick.under\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "case over"], ["proof (state)\nthis:\n  a = over\n\ngoal (4 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 3. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = over\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 4. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = brick.under\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "have \"mat \n              (rat_poly.row_length (brickmat a)) \n              (length (brickmat a)) \n                         (brickmat a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a)", "using mat_over rat_poly.matrix_row_length over"], ["proof (prove)\nusing this:\n  mat 4 4 (brickmat over)\n  mat ?nr ?nc ?M \\<Longrightarrow>\n  mat (rat_poly.row_length ?M) (length ?M) ?M\n  a = over\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a)", "by metis"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 3. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = over\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 4. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = brick.under\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "using Cons_3"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n   (brickmat a) \\<Longrightarrow>\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 3. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = brick.under\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 3. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = brick.under\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "case under"], ["proof (state)\nthis:\n  a = brick.under\n\ngoal (3 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 3. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = brick.under\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "have \"mat \n              (rat_poly.row_length (brickmat a)) \n              (length (brickmat a)) \n                         (brickmat a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a)", "using  mat_under rat_poly.matrix_row_length under"], ["proof (prove)\nusing this:\n  mat 4 4 (brickmat brick.under)\n  mat ?nr ?nc ?M \\<Longrightarrow>\n  mat (rat_poly.row_length ?M) (length ?M) ?M\n  a = brick.under\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a)", "by metis"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 3. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = brick.under\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "using Cons_3"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n   (brickmat a) \\<Longrightarrow>\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "case cap"], ["proof (state)\nthis:\n  a = cap\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "have \"mat \n              (rat_poly.row_length (brickmat a)) \n              (length (brickmat a)) \n                            (brickmat a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a)", "using  mat_cap rat_poly.matrix_row_length cap"], ["proof (prove)\nusing this:\n  mat 4 1 (brickmat cap)\n  mat ?nr ?nc ?M \\<Longrightarrow>\n  mat (rat_poly.row_length ?M) (length ?M) ?M\n  a = cap\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a)", "by metis"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))\n 2. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cap\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "using Cons_3"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n   (brickmat a) \\<Longrightarrow>\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "case cup"], ["proof (state)\nthis:\n  a = cup\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "have \"mat \n             (rat_poly.row_length (brickmat a)) \n             (length (brickmat a)) \n                            (brickmat a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a)", "using mat_cup rat_poly.matrix_row_length cup"], ["proof (prove)\nusing this:\n  mat 1 4 (brickmat cup)\n  mat ?nr ?nc ?M \\<Longrightarrow>\n  mat (rat_poly.row_length ?M) (length ?M) ?M\n  a = cup\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n     (brickmat a)", "by metis"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n              (brickmat a) \\<Longrightarrow>\n             mat (rat_poly.row_length (blockmat (a # ls)))\n              (length (blockmat (a # ls))) (blockmat (a # ls));\n     a = cup\\<rbrakk>\n    \\<Longrightarrow> mat (rat_poly.row_length (blockmat (a # ls)))\n                       (length (blockmat (a # ls))) (blockmat (a # ls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "using Cons_3"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a)) (brickmat a)\n  mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n   (brickmat a) \\<Longrightarrow>\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat (a # ls)))\n     (length (blockmat (a # ls))) (blockmat (a # ls))", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat (a # ls))) (length (blockmat (a # ls)))\n   (blockmat (a # ls))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The function kauff$\\_$mat below associates every wall to a matrix. \n We call this the kauffman matrix. When the wall represents a well defined\n tangle diagram, the Kauffman matrix is a 1 $\\times$  1 matrix whose entry is the\n Kauffman bracket.\\<close>"], ["", "primrec kauff_mat::\"wall \\<Rightarrow> rat_poly mat\"\nwhere \n\"kauff_mat (basic w) = (blockmat w)\"\n|\"kauff_mat (w*ws) = rat_poly.matrix_mult (blockmat w) (kauff_mat ws)\""], ["", "text\\<open>The following theorem tells us  that if a wall\nrepresents a tangle diagram, then its Kauffman matrix is a `valid' matrix.\\<close>"], ["", "theorem matrix_kauff_mat:\n\"((is_tangle_diagram ws) \n \\<Longrightarrow> (rat_poly.row_length (kauff_mat ws)) = 2^(nat (domain_wall ws))\n \\<and> (length (kauff_mat ws)) = 2^(nat (codomain_wall ws))\n \\<and> (mat \n        (rat_poly.row_length (kauff_mat ws)) \n        (length (kauff_mat ws)) \n            (kauff_mat ws)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws \\<Longrightarrow>\n    rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws) \\<and>\n    length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n    mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n     (kauff_mat ws)", "proof(induct ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_tangle_diagram (basic x) \\<Longrightarrow>\n       rat_poly.row_length (kauff_mat (basic x)) =\n       2 ^ nat (domain_wall (basic x)) \\<and>\n       length (kauff_mat (basic x)) =\n       2 ^ nat (codomain_wall (basic x)) \\<and>\n       mat (rat_poly.row_length (kauff_mat (basic x)))\n        (length (kauff_mat (basic x))) (kauff_mat (basic x))\n 2. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "case (basic w)"], ["proof (state)\nthis:\n  is_tangle_diagram (basic w)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_tangle_diagram (basic x) \\<Longrightarrow>\n       rat_poly.row_length (kauff_mat (basic x)) =\n       2 ^ nat (domain_wall (basic x)) \\<and>\n       length (kauff_mat (basic x)) =\n       2 ^ nat (codomain_wall (basic x)) \\<and>\n       mat (rat_poly.row_length (kauff_mat (basic x)))\n        (length (kauff_mat (basic x))) (kauff_mat (basic x))\n 2. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat (basic w)) =\n    2 ^ nat (domain_wall (basic w)) \\<and>\n    length (kauff_mat (basic w)) = 2 ^ nat (codomain_wall (basic w)) \\<and>\n    mat (rat_poly.row_length (kauff_mat (basic w)))\n     (length (kauff_mat (basic w))) (kauff_mat (basic w))", "using kauff_mat.simps(1) domain_wall.simps(1) \n             row_length_domain_block matrix_blockmat\n             length_codomain_block basic"], ["proof (prove)\nusing this:\n  kauff_mat (basic ?w) = blockmat ?w\n  domain_wall (basic ?x) = domain_block ?x\n  rat_poly.row_length (blockmat ?ls) = 2 ^ nat (domain_block ?ls)\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n  length (blockmat ?ls) = 2 ^ nat (codomain_block ?ls)\n  is_tangle_diagram (basic w)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat (basic w)) =\n    2 ^ nat (domain_wall (basic w)) \\<and>\n    length (kauff_mat (basic w)) = 2 ^ nat (codomain_wall (basic w)) \\<and>\n    mat (rat_poly.row_length (kauff_mat (basic w)))\n     (length (kauff_mat (basic w))) (kauff_mat (basic w))", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (kauff_mat (basic w)) =\n  2 ^ nat (domain_wall (basic w)) \\<and>\n  length (kauff_mat (basic w)) = 2 ^ nat (codomain_wall (basic w)) \\<and>\n  mat (rat_poly.row_length (kauff_mat (basic w)))\n   (length (kauff_mat (basic w))) (kauff_mat (basic w))\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "case (prod w ws)"], ["proof (state)\nthis:\n  is_tangle_diagram ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws) \\<and>\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n  mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n   (kauff_mat ws)\n  is_tangle_diagram (w * ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "have \"is_tangle_diagram (w*ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram (w * ws)", "using prod"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws) \\<and>\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n  mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n   (kauff_mat ws)\n  is_tangle_diagram (w * ws)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram (w * ws)", "by auto"], ["proof (state)\nthis:\n  is_tangle_diagram (w * ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "moreover"], ["proof (state)\nthis:\n  is_tangle_diagram (w * ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "have prod_1:\"is_tangle_diagram ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws", "using is_tangle_diagram.simps  prod.prems"], ["proof (prove)\nusing this:\n  is_tangle_diagram (basic ?x) = True\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n  is_tangle_diagram (w * ws)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram ws", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram ws\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "ultimately"], ["proof (chain)\npicking this:\n  is_tangle_diagram (w * ws)\n  is_tangle_diagram ws", "have prod_2:\"(codomain_block w) = domain_wall ws\""], ["proof (prove)\nusing this:\n  is_tangle_diagram (w * ws)\n  is_tangle_diagram ws\n\ngoal (1 subgoal):\n 1. codomain_block w = domain_wall ws", "using is_tangle_diagram.simps"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w * ws)\n  is_tangle_diagram ws\n  is_tangle_diagram (basic ?x) = True\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. codomain_block w = domain_wall ws", "by auto"], ["proof (state)\nthis:\n  codomain_block w = domain_wall ws\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "from prod_1"], ["proof (chain)\npicking this:\n  is_tangle_diagram ws", "have prod_3:\n         \"mat \n              (rat_poly.row_length (kauff_mat ws)) \n              (length (kauff_mat ws)) \n                           (kauff_mat ws)\""], ["proof (prove)\nusing this:\n  is_tangle_diagram ws\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n     (kauff_mat ws)", "using prod.hyps"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws\n  is_tangle_diagram ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws) \\<and>\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n  mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n   (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n     (kauff_mat ws)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n   (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "moreover"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n   (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "have \"(rat_poly.row_length (kauff_mat ws)) \n                                =  2^(nat (domain_wall ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)", "using prod.hyps prod_1"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws) \\<and>\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n  mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n   (kauff_mat ws)\n  is_tangle_diagram ws\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "have prod_4:\"length (kauff_mat ws) \n                                = 2^(nat (codomain_wall ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)", "using prod.hyps prod_1"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws) \\<and>\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n  mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n   (kauff_mat ws)\n  is_tangle_diagram ws\n\ngoal (1 subgoal):\n 1. length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)", "by auto"], ["proof (state)\nthis:\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "moreover"], ["proof (state)\nthis:\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "have prod_5:\n           \"mat \n               (rat_poly.row_length (blockmat w)) \n               (length (blockmat w)) \n                            (blockmat w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w)) (length (blockmat w))\n     (blockmat w)", "using matrix_blockmat"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w)) (length (blockmat w))\n     (blockmat w)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w)) (length (blockmat w)) (blockmat w)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "moreover"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w)) (length (blockmat w)) (blockmat w)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "have prod_6:\n           \"rat_poly.row_length (blockmat w) \n                             = 2^(nat (domain_block w))\"\n              and \"length (blockmat w) = 2^(nat (codomain_block w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat w) = 2 ^ nat (domain_block w) &&&\n    length (blockmat w) = 2 ^ nat (codomain_block w)", "using row_length_domain_block length_codomain_block"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat ?ls) = 2 ^ nat (domain_block ?ls)\n  length (blockmat ?ls) = 2 ^ nat (codomain_block ?ls)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat w) = 2 ^ nat (domain_block w) &&&\n    length (blockmat w) = 2 ^ nat (codomain_block w)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat w) = 2 ^ nat (domain_block w)\n  length (blockmat w) = 2 ^ nat (codomain_block w)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "ultimately"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n   (kauff_mat ws)\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)\n  mat (rat_poly.row_length (blockmat w)) (length (blockmat w)) (blockmat w)\n  rat_poly.row_length (blockmat w) = 2 ^ nat (domain_block w)\n  length (blockmat w) = 2 ^ nat (codomain_block w)", "have ad1:\"length (blockmat w) \n                             = rat_poly.row_length (kauff_mat ws)\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n   (kauff_mat ws)\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)\n  mat (rat_poly.row_length (blockmat w)) (length (blockmat w)) (blockmat w)\n  rat_poly.row_length (blockmat w) = 2 ^ nat (domain_block w)\n  length (blockmat w) = 2 ^ nat (codomain_block w)\n\ngoal (1 subgoal):\n 1. length (blockmat w) = rat_poly.row_length (kauff_mat ws)", "using prod_2"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n   (kauff_mat ws)\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)\n  mat (rat_poly.row_length (blockmat w)) (length (blockmat w)) (blockmat w)\n  rat_poly.row_length (blockmat w) = 2 ^ nat (domain_block w)\n  length (blockmat w) = 2 ^ nat (codomain_block w)\n  codomain_block w = domain_wall ws\n\ngoal (1 subgoal):\n 1. length (blockmat w) = rat_poly.row_length (kauff_mat ws)", "by auto"], ["proof (state)\nthis:\n  length (blockmat w) = rat_poly.row_length (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "then"], ["proof (chain)\npicking this:\n  length (blockmat w) = rat_poly.row_length (kauff_mat ws)", "have \"mat \n                 (rat_poly.row_length (blockmat w)) \n                 (length (kauff_mat ws)) \n                      (rat_poly.matrix_mult (blockmat w) (kauff_mat ws))\""], ["proof (prove)\nusing this:\n  length (blockmat w) = rat_poly.row_length (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n     (rat_poly.matrix_mult (blockmat w) (kauff_mat ws))", "using prod_3 prod_5 mat_mult"], ["proof (prove)\nusing this:\n  length (blockmat w) = rat_poly.row_length (kauff_mat ws)\n  mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n   (kauff_mat ws)\n  mat (rat_poly.row_length (blockmat w)) (length (blockmat w)) (blockmat w)\n  \\<lbrakk>mat ?nr ?n ?m1.0; mat ?n ?nc ?m2.0\\<rbrakk>\n  \\<Longrightarrow> mat ?nr ?nc (mat_multI ?ze ?pl ?ti ?nr ?m1.0 ?m2.0)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n     (rat_poly.matrix_mult (blockmat w) (kauff_mat ws))", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (rat_poly.matrix_mult (blockmat w) (kauff_mat ws))\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "then"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (rat_poly.matrix_mult (blockmat w) (kauff_mat ws))", "have res1:\"mat \n                     (rat_poly.row_length (blockmat w)) \n                     (length (kauff_mat ws)) \n                               (kauff_mat (w*ws))\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (rat_poly.matrix_mult (blockmat w) (kauff_mat ws))\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n     (kauff_mat (w * ws))", "using kauff_mat.simps(2)"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (rat_poly.matrix_mult (blockmat w) (kauff_mat ws))\n  kauff_mat (?w * ?ws) = rat_poly.matrix_mult (blockmat ?w) (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n     (kauff_mat (w * ws))", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (kauff_mat (w * ws))\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "then"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (kauff_mat (w * ws))", "have \"rat_poly.row_length (kauff_mat (w*ws)) \n                               = (rat_poly.row_length (blockmat w))\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (kauff_mat (w * ws))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat (w * ws)) =\n    rat_poly.row_length (blockmat w)", "using ad1 length_0_conv rat_poly.mat_empty_column_length \n             rat_poly.matrix_row_length rat_poly.row_length_def \n             rat_poly.unique_row_col(1)"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (kauff_mat (w * ws))\n  length (blockmat w) = rat_poly.row_length (kauff_mat ws)\n  (length ?xs = 0) = (?xs = [])\n  \\<lbrakk>mat ?nr ?nc ?M; ?M = []\\<rbrakk> \\<Longrightarrow> ?nc = 0\n  mat ?nr ?nc ?M \\<Longrightarrow>\n  mat (rat_poly.row_length ?M) (length ?M) ?M\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  \\<lbrakk>mat ?nr1.0 ?nc1.0 ?M; mat ?nr2.0 ?nc2.0 ?M;\n   ?M \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?nr1.0 = ?nr2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat (w * ws)) =\n    rat_poly.row_length (blockmat w)", "by (metis)"], ["proof (state)\nthis:\n  rat_poly.row_length (kauff_mat (w * ws)) =\n  rat_poly.row_length (blockmat w)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (kauff_mat (w * ws)) =\n  rat_poly.row_length (blockmat w)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "have \"...  = 2^(nat (domain_wall (w*ws)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat w) = 2 ^ nat (domain_wall (w * ws))", "using prod_6 domain_wall.simps"], ["proof (prove)\nusing this:\n  rat_poly.row_length (blockmat w) = 2 ^ nat (domain_block w)\n  domain_wall (basic ?x) = domain_block ?x\n  domain_wall (?x * ?ys) = domain_block ?x\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (blockmat w) = 2 ^ nat (domain_wall (w * ws))", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (blockmat w) = 2 ^ nat (domain_wall (w * ws))\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.row_length (kauff_mat (w * ws)) =\n  rat_poly.row_length (blockmat w)\n  rat_poly.row_length (blockmat w) = 2 ^ nat (domain_wall (w * ws))", "have res2:\n                 \"rat_poly.row_length (kauff_mat (w*ws)) \n                       = 2^(nat (domain_wall (w*ws)))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (kauff_mat (w * ws)) =\n  rat_poly.row_length (blockmat w)\n  rat_poly.row_length (blockmat w) = 2 ^ nat (domain_wall (w * ws))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat (w * ws)) =\n    2 ^ nat (domain_wall (w * ws))", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (kauff_mat (w * ws)) = 2 ^ nat (domain_wall (w * ws))\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "have \"length (kauff_mat (w*ws)) = length (kauff_mat ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (kauff_mat (w * ws)) = length (kauff_mat ws)", "using res1  rat_poly.mat_empty_column_length \n           rat_poly.matrix_row_length rat_poly.unique_row_col(2)"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (kauff_mat (w * ws))\n  \\<lbrakk>mat ?nr ?nc ?M; ?M = []\\<rbrakk> \\<Longrightarrow> ?nc = 0\n  mat ?nr ?nc ?M \\<Longrightarrow>\n  mat (rat_poly.row_length ?M) (length ?M) ?M\n  \\<lbrakk>mat ?nr1.0 ?nc1.0 ?M; mat ?nr2.0 ?nc2.0 ?M;\n   ?M \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?nc1.0 = ?nc2.0\n\ngoal (1 subgoal):\n 1. length (kauff_mat (w * ws)) = length (kauff_mat ws)", "by metis"], ["proof (state)\nthis:\n  length (kauff_mat (w * ws)) = length (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "moreover"], ["proof (state)\nthis:\n  length (kauff_mat (w * ws)) = length (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "have \"... = 2^(nat (codomain_wall (w*ws)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (kauff_mat ws) = 2 ^ nat (codomain_wall (w * ws))", "using prod_4 codomain_wall.simps(2)"], ["proof (prove)\nusing this:\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)\n  codomain_wall (?x * ?ys) = codomain_wall ?ys\n\ngoal (1 subgoal):\n 1. length (kauff_mat ws) = 2 ^ nat (codomain_wall (w * ws))", "by auto"], ["proof (state)\nthis:\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall (w * ws))\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "ultimately"], ["proof (chain)\npicking this:\n  length (kauff_mat (w * ws)) = length (kauff_mat ws)\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall (w * ws))", "have res3:\"length (kauff_mat (w*ws))  \n                               =  2^(nat (codomain_wall (w*ws)))\""], ["proof (prove)\nusing this:\n  length (kauff_mat (w * ws)) = length (kauff_mat ws)\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall (w * ws))\n\ngoal (1 subgoal):\n 1. length (kauff_mat (w * ws)) = 2 ^ nat (codomain_wall (w * ws))", "by auto"], ["proof (state)\nthis:\n  length (kauff_mat (w * ws)) = 2 ^ nat (codomain_wall (w * ws))\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws.\n       \\<lbrakk>is_tangle_diagram ws \\<Longrightarrow>\n                rat_poly.row_length (kauff_mat ws) =\n                2 ^ nat (domain_wall ws) \\<and>\n                length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) \\<and>\n                mat (rat_poly.row_length (kauff_mat ws))\n                 (length (kauff_mat ws)) (kauff_mat ws);\n        is_tangle_diagram (x1a * ws)\\<rbrakk>\n       \\<Longrightarrow> rat_poly.row_length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (domain_wall (x1a * ws)) \\<and>\n                         length (kauff_mat (x1a * ws)) =\n                         2 ^ nat (codomain_wall (x1a * ws)) \\<and>\n                         mat (rat_poly.row_length (kauff_mat (x1a * ws)))\n                          (length (kauff_mat (x1a * ws)))\n                          (kauff_mat (x1a * ws))", "with res1 res2"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (kauff_mat (w * ws))\n  rat_poly.row_length (kauff_mat (w * ws)) = 2 ^ nat (domain_wall (w * ws))\n  length (kauff_mat (w * ws)) = 2 ^ nat (codomain_wall (w * ws))", "show ?case"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (kauff_mat (w * ws))\n  rat_poly.row_length (kauff_mat (w * ws)) = 2 ^ nat (domain_wall (w * ws))\n  length (kauff_mat (w * ws)) = 2 ^ nat (codomain_wall (w * ws))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat (w * ws)) =\n    2 ^ nat (domain_wall (w * ws)) \\<and>\n    length (kauff_mat (w * ws)) = 2 ^ nat (codomain_wall (w * ws)) \\<and>\n    mat (rat_poly.row_length (kauff_mat (w * ws)))\n     (length (kauff_mat (w * ws))) (kauff_mat (w * ws))", "using  \\<open>length (kauff_mat ws) = 2 ^ nat (codomain_wall (w * ws))\\<close> \n           \\<open>rat_poly.row_length (blockmat w) = 2 ^ nat (domain_wall (w * ws))\\<close>"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w)) (length (kauff_mat ws))\n   (kauff_mat (w * ws))\n  rat_poly.row_length (kauff_mat (w * ws)) = 2 ^ nat (domain_wall (w * ws))\n  length (kauff_mat (w * ws)) = 2 ^ nat (codomain_wall (w * ws))\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall (w * ws))\n  rat_poly.row_length (blockmat w) = 2 ^ nat (domain_wall (w * ws))\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat (w * ws)) =\n    2 ^ nat (domain_wall (w * ws)) \\<and>\n    length (kauff_mat (w * ws)) = 2 ^ nat (codomain_wall (w * ws)) \\<and>\n    mat (rat_poly.row_length (kauff_mat (w * ws)))\n     (length (kauff_mat (w * ws))) (kauff_mat (w * ws))", "by (metis)"], ["proof (state)\nthis:\n  rat_poly.row_length (kauff_mat (w * ws)) =\n  2 ^ nat (domain_wall (w * ws)) \\<and>\n  length (kauff_mat (w * ws)) = 2 ^ nat (codomain_wall (w * ws)) \\<and>\n  mat (rat_poly.row_length (kauff_mat (w * ws)))\n   (length (kauff_mat (w * ws))) (kauff_mat (w * ws))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem effective_matrix_kauff_mat:\n assumes \"is_tangle_diagram ws\" \n shows \"(rat_poly.row_length (kauff_mat ws)) = 2^(nat (domain_wall ws))\"\n and \"length (kauff_mat ws) = 2^(nat (codomain_wall ws))\"\n and \"mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n                                           (kauff_mat ws) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws) &&&\n    length (kauff_mat ws) = 2 ^ nat (codomain_wall ws) &&&\n    mat (rat_poly.row_length (kauff_mat ws)) (length (kauff_mat ws))\n     (kauff_mat ws)", "apply (auto simp add:matrix_kauff_mat assms )"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (2 ^ nat (domain_wall ws)) (2 ^ nat (codomain_wall ws))\n     (kauff_mat ws)", "using assms matrix_kauff_mat"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws) \\<and>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws) \\<and>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. mat (2 ^ nat (domain_wall ws)) (2 ^ nat (codomain_wall ws))\n     (kauff_mat ws)", "by metis"], ["", "lemma mat_mult_equiv:\n \"rat_poly.matrix_mult m1 m2 = mat_mult (rat_poly.row_length m1) m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 m2 = rat_poly.matrix_mult m1 m2", "by auto"], ["", "theorem associative_rat_poly_mat:\n assumes \"mat (rat_poly.row_length m1) (rat_poly.row_length m2) m1\" \n     and \"mat (rat_poly.row_length m2) (rat_poly.row_length m3) m2\" \n     and \"mat (rat_poly.row_length m3) nc m3\"\n shows \"rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) \n                     = rat_poly.matrix_mult (rat_poly.matrix_mult m1  m2) m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "have \"(rat_poly.matrix_mult m2 m3) \n                   = mat_mult (rat_poly.row_length m2) m2 m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m2 m3 = rat_poly.matrix_mult m2 m3", "using mat_mult_equiv"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult ?m1.0 ?m2.0 = rat_poly.matrix_mult ?m1.0 ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m2 m3 = rat_poly.matrix_mult m2 m3", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult m2 m3 = rat_poly.matrix_mult m2 m3\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult m2 m3 = rat_poly.matrix_mult m2 m3", "have \"rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3)\n                   = mat_mult (rat_poly.row_length m1)  m1 \n                                 (mat_mult (rat_poly.row_length m2) m2 m3)\""], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult m2 m3 = rat_poly.matrix_mult m2 m3\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3)", "using mat_mult_equiv"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult m2 m3 = rat_poly.matrix_mult m2 m3\n  rat_poly.matrix_mult ?m1.0 ?m2.0 = rat_poly.matrix_mult ?m1.0 ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "have \"...  =    mat_mult (rat_poly.row_length m1) \n                           (mat_mult (rat_poly.row_length m1) m1 m2) m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3", "using assms mat_mult_assoc"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length m1) (rat_poly.row_length m2) m1\n  mat (rat_poly.row_length m2) (rat_poly.row_length m3) m2\n  mat (rat_poly.row_length m3) nc m3\n  \\<lbrakk>mat ?nr ?n1.0 ?m1.0; mat ?n1.0 ?n2.0 ?m2.0;\n   mat ?n2.0 ?nc ?m3.0\\<rbrakk>\n  \\<Longrightarrow> mat_mult ?nr (mat_mult ?nr ?m1.0 ?m2.0) ?m3.0 =\n                    mat_mult ?nr ?m1.0 (mat_mult ?n1.0 ?m2.0 ?m3.0)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3", "by metis"], ["proof (state)\nthis:\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n  mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n  mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "have \"... = rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "have \"mat \n           (rat_poly.row_length m1) \n           (rat_poly.row_length m3) \n                     (rat_poly.matrix_mult m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length m1) (rat_poly.row_length m3)\n     (rat_poly.matrix_mult m1 m2)", "using assms(1) assms(2) mat_mult"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length m1) (rat_poly.row_length m2) m1\n  mat (rat_poly.row_length m2) (rat_poly.row_length m3) m2\n  \\<lbrakk>mat ?nr ?n ?m1.0; mat ?n ?nc ?m2.0\\<rbrakk>\n  \\<Longrightarrow> mat ?nr ?nc (mat_multI ?ze ?pl ?ti ?nr ?m1.0 ?m2.0)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length m1) (rat_poly.row_length m3)\n     (rat_poly.matrix_mult m1 m2)", "by (metis)"], ["proof (state)\nthis:\n  mat (rat_poly.row_length m1) (rat_poly.row_length m3)\n   (rat_poly.matrix_mult m1 m2)\n\ngoal (1 subgoal):\n 1. mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "then"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length m1) (rat_poly.row_length m3)\n   (rat_poly.matrix_mult m1 m2)", "have \"rat_poly.row_length (rat_poly.matrix_mult m1 m2) = \n                     (rat_poly.row_length m1)\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length m1) (rat_poly.row_length m3)\n   (rat_poly.matrix_mult m1 m2)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (rat_poly.matrix_mult m1 m2) =\n    rat_poly.row_length m1", "using assms(1) assms(2) length_0_conv rat_poly.mat_empty_column_length \n            rat_poly.matrix_row_length rat_poly.row_length_Nil \n            rat_poly.unique_row_col(1) rat_poly.unique_row_col(2)"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length m1) (rat_poly.row_length m3)\n   (rat_poly.matrix_mult m1 m2)\n  mat (rat_poly.row_length m1) (rat_poly.row_length m2) m1\n  mat (rat_poly.row_length m2) (rat_poly.row_length m3) m2\n  (length ?xs = 0) = (?xs = [])\n  \\<lbrakk>mat ?nr ?nc ?M; ?M = []\\<rbrakk> \\<Longrightarrow> ?nc = 0\n  mat ?nr ?nc ?M \\<Longrightarrow>\n  mat (rat_poly.row_length ?M) (length ?M) ?M\n  rat_poly.row_length [] = 0\n  \\<lbrakk>mat ?nr1.0 ?nc1.0 ?M; mat ?nr2.0 ?nc2.0 ?M;\n   ?M \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?nr1.0 = ?nr2.0\n  \\<lbrakk>mat ?nr1.0 ?nc1.0 ?M; mat ?nr2.0 ?nc2.0 ?M;\n   ?M \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?nc1.0 = ?nc2.0\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (rat_poly.matrix_mult m1 m2) =\n    rat_poly.row_length m1", "by (metis)"], ["proof (state)\nthis:\n  rat_poly.row_length (rat_poly.matrix_mult m1 m2) = rat_poly.row_length m1\n\ngoal (1 subgoal):\n 1. mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (rat_poly.matrix_mult m1 m2) = rat_poly.row_length m1\n\ngoal (1 subgoal):\n 1. mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "have \"rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3\n                       = mat_mult (rat_poly.row_length \n                                      (rat_poly.matrix_mult m1 m2))\n                                   (rat_poly.matrix_mult m1 m2) m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3 =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "using mat_mult_equiv"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult ?m1.0 ?m2.0 = rat_poly.matrix_mult ?m1.0 ?m2.0\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3 =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3 =\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3\n\ngoal (1 subgoal):\n 1. mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3 =\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3 =\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3\n\ngoal (1 subgoal):\n 1. mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "using mat_mult_equiv"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3 =\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3\n  rat_poly.matrix_mult ?m1.0 ?m2.0 = rat_poly.matrix_mult ?m1.0 ?m2.0\n\ngoal (1 subgoal):\n 1. mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "by (metis calculation)"], ["proof (state)\nthis:\n  mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3)\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n  mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3\n  mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3)\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n  mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3\n  mat_mult (rat_poly.row_length m1) (rat_poly.matrix_mult m1 m2) m3 =\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n    rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult m1 (rat_poly.matrix_mult m2 m3) =\n  rat_poly.matrix_mult (rat_poly.matrix_mult m1 m2) m3\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>It follows from this result that the Kauffman Matrix of a wall representing a link\ndiagram, is a 1 $\\times$ 1 matrix. \n Thus it establishes a correspondence between links and\nrational functions.\\<close>"], ["", "theorem link_diagram_matrix:\n assumes \"is_link_diagram ws\"\n shows \"mat 1 1 (kauff_mat ws) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 1 (kauff_mat ws)", "using assms effective_matrix_kauff_mat"], ["proof (prove)\nusing this:\n  is_link_diagram ws\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. mat 1 1 (kauff_mat ws)", "unfolding is_link_diagram_def"], ["proof (prove)\nusing this:\n  if is_tangle_diagram ws\n  then Preliminaries.abs (domain_wall ws) +\n       Preliminaries.abs (codomain_wall ws) =\n       0\n  else False\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. mat 1 1 (kauff_mat ws)", "by (metis Preliminaries.abs_zero abs_non_negative_sum(1) comm_monoid_add_class.add_0 nat_0 power_0)"], ["", "theorem tangle_compose_matrix:\n\"((is_tangle_diagram ws1) \\<and> (is_tangle_diagram ws2) \n\\<and>(domain_wall ws2 = codomain_wall ws1)) \\<Longrightarrow>\nkauff_mat (ws1 \\<circ> ws2) = rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1 \\<and>\n    is_tangle_diagram ws2 \\<and>\n    domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n    kauff_mat (ws1 \\<circ> ws2) =\n    rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2)", "proof(induct ws1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_tangle_diagram (basic x) \\<and>\n       is_tangle_diagram ws2 \\<and>\n       domain_wall ws2 = codomain_wall (basic x) \\<Longrightarrow>\n       kauff_mat (basic x \\<circ> ws2) =\n       rat_poly.matrix_mult (kauff_mat (basic x)) (kauff_mat ws2)\n 2. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "case (basic w1)"], ["proof (state)\nthis:\n  is_tangle_diagram (basic w1) \\<and>\n  is_tangle_diagram ws2 \\<and> domain_wall ws2 = codomain_wall (basic w1)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_tangle_diagram (basic x) \\<and>\n       is_tangle_diagram ws2 \\<and>\n       domain_wall ws2 = codomain_wall (basic x) \\<Longrightarrow>\n       kauff_mat (basic x \\<circ> ws2) =\n       rat_poly.matrix_mult (kauff_mat (basic x)) (kauff_mat ws2)\n 2. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "have \"(basic w1) \\<circ> (ws2) = (w1)*(ws2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basic w1 \\<circ> ws2 = w1 * ws2", "using compose.simps"], ["proof (prove)\nusing this:\n  basic ?x \\<circ> ?ys = ?x * ?ys\n  (?x * ?xs) \\<circ> ?ys = ?x * ?xs \\<circ> ?ys\n\ngoal (1 subgoal):\n 1. basic w1 \\<circ> ws2 = w1 * ws2", "by auto"], ["proof (state)\nthis:\n  basic w1 \\<circ> ws2 = w1 * ws2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_tangle_diagram (basic x) \\<and>\n       is_tangle_diagram ws2 \\<and>\n       domain_wall ws2 = codomain_wall (basic x) \\<Longrightarrow>\n       kauff_mat (basic x \\<circ> ws2) =\n       rat_poly.matrix_mult (kauff_mat (basic x)) (kauff_mat ws2)\n 2. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "moreover"], ["proof (state)\nthis:\n  basic w1 \\<circ> ws2 = w1 * ws2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_tangle_diagram (basic x) \\<and>\n       is_tangle_diagram ws2 \\<and>\n       domain_wall ws2 = codomain_wall (basic x) \\<Longrightarrow>\n       kauff_mat (basic x \\<circ> ws2) =\n       rat_poly.matrix_mult (kauff_mat (basic x)) (kauff_mat ws2)\n 2. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "have \"kauff_mat ((basic w1) \\<circ> ws2) =rat_poly.matrix_mult (blockmat w1) (kauff_mat ws2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat (basic w1 \\<circ> ws2) =\n    rat_poly.matrix_mult (blockmat w1) (kauff_mat ws2)", "using kauff_mat.simps(2)"], ["proof (prove)\nusing this:\n  kauff_mat (?w * ?ws) = rat_poly.matrix_mult (blockmat ?w) (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. kauff_mat (basic w1 \\<circ> ws2) =\n    rat_poly.matrix_mult (blockmat w1) (kauff_mat ws2)", "by auto"], ["proof (state)\nthis:\n  kauff_mat (basic w1 \\<circ> ws2) =\n  rat_poly.matrix_mult (blockmat w1) (kauff_mat ws2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_tangle_diagram (basic x) \\<and>\n       is_tangle_diagram ws2 \\<and>\n       domain_wall ws2 = codomain_wall (basic x) \\<Longrightarrow>\n       kauff_mat (basic x \\<circ> ws2) =\n       rat_poly.matrix_mult (kauff_mat (basic x)) (kauff_mat ws2)\n 2. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "then"], ["proof (chain)\npicking this:\n  kauff_mat (basic w1 \\<circ> ws2) =\n  rat_poly.matrix_mult (blockmat w1) (kauff_mat ws2)", "show ?case"], ["proof (prove)\nusing this:\n  kauff_mat (basic w1 \\<circ> ws2) =\n  rat_poly.matrix_mult (blockmat w1) (kauff_mat ws2)\n\ngoal (1 subgoal):\n 1. kauff_mat (basic w1 \\<circ> ws2) =\n    rat_poly.matrix_mult (kauff_mat (basic w1)) (kauff_mat ws2)", "using kauff_mat.simps(1)"], ["proof (prove)\nusing this:\n  kauff_mat (basic w1 \\<circ> ws2) =\n  rat_poly.matrix_mult (blockmat w1) (kauff_mat ws2)\n  kauff_mat (basic ?w) = blockmat ?w\n\ngoal (1 subgoal):\n 1. kauff_mat (basic w1 \\<circ> ws2) =\n    rat_poly.matrix_mult (kauff_mat (basic w1)) (kauff_mat ws2)", "by auto"], ["proof (state)\nthis:\n  kauff_mat (basic w1 \\<circ> ws2) =\n  rat_poly.matrix_mult (kauff_mat (basic w1)) (kauff_mat ws2)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "case (prod w1 ws1)"], ["proof (state)\nthis:\n  is_tangle_diagram ws1 \\<and>\n  is_tangle_diagram ws2 \\<and>\n  domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n  kauff_mat (ws1 \\<circ> ws2) =\n  rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2)\n  is_tangle_diagram (w1 * ws1) \\<and>\n  is_tangle_diagram ws2 \\<and> domain_wall ws2 = codomain_wall (w1 * ws1)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "have 1:\"is_tangle_diagram (w1*ws1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram (w1 * ws1)", "using prod.prems"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w1 * ws1) \\<and>\n  is_tangle_diagram ws2 \\<and> domain_wall ws2 = codomain_wall (w1 * ws1)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram (w1 * ws1)", "by (rule conjE)"], ["proof (state)\nthis:\n  is_tangle_diagram (w1 * ws1)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram (w1 * ws1)", "have 2:\"(is_tangle_diagram ws1) \n                 \\<and> (codomain_block w1 = domain_wall ws1)\""], ["proof (prove)\nusing this:\n  is_tangle_diagram (w1 * ws1)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1 \\<and> codomain_block w1 = domain_wall ws1", "using is_tangle_diagram.simps(2)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w1 * ws1)\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1 \\<and> codomain_block w1 = domain_wall ws1", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram ws1 \\<and> codomain_block w1 = domain_wall ws1\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram ws1 \\<and> codomain_block w1 = domain_wall ws1", "have \n       \"mat (2^(nat (domain_wall ws1))) (2^(nat (codomain_wall ws1))) (kauff_mat ws1)\"\n            and \"mat (2^(nat (domain_block w1))) (2^(nat (codomain_block w1))) (blockmat w1)\""], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1 \\<and> codomain_block w1 = domain_wall ws1\n\ngoal (1 subgoal):\n 1. mat (2 ^ nat (domain_wall ws1)) (2 ^ nat (codomain_wall ws1))\n     (kauff_mat ws1) &&&\n    mat (2 ^ nat (domain_block w1)) (2 ^ nat (codomain_block w1))\n     (blockmat w1)", "using  effective_matrix_kauff_mat   matrix_blockmat  length_codomain_block \n               row_length_domain_block"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1 \\<and> codomain_block w1 = domain_wall ws1\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n  length (blockmat ?ls) = 2 ^ nat (codomain_block ?ls)\n  rat_poly.row_length (blockmat ?ls) = 2 ^ nat (domain_block ?ls)\n\ngoal (1 subgoal):\n 1. mat (2 ^ nat (domain_wall ws1)) (2 ^ nat (codomain_wall ws1))\n     (kauff_mat ws1) &&&\n    mat (2 ^ nat (domain_block w1)) (2 ^ nat (codomain_block w1))\n     (blockmat w1)", "by (auto) (metis)"], ["proof (state)\nthis:\n  mat (2 ^ nat (domain_wall ws1)) (2 ^ nat (codomain_wall ws1))\n   (kauff_mat ws1)\n  mat (2 ^ nat (domain_block w1)) (2 ^ nat (codomain_block w1))\n   (blockmat w1)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "with 2"], ["proof (chain)\npicking this:\n  is_tangle_diagram ws1 \\<and> codomain_block w1 = domain_wall ws1\n  mat (2 ^ nat (domain_wall ws1)) (2 ^ nat (codomain_wall ws1))\n   (kauff_mat ws1)\n  mat (2 ^ nat (domain_block w1)) (2 ^ nat (codomain_block w1))\n   (blockmat w1)", "have 3:\"mat \n                     (rat_poly.row_length (blockmat w1)) \n                     (2^(nat (domain_wall ws1)))\n                               (blockmat w1)\"\n         and   \"mat \n                   (2^(nat (domain_wall ws1))) \n                   (2^(nat (domain_wall ws2))) \n                               (kauff_mat ws1)\"\n         and \"(2^(nat (domain_wall ws1))) \n                           = (rat_poly.row_length (kauff_mat ws1))\""], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1 \\<and> codomain_block w1 = domain_wall ws1\n  mat (2 ^ nat (domain_wall ws1)) (2 ^ nat (codomain_wall ws1))\n   (kauff_mat ws1)\n  mat (2 ^ nat (domain_block w1)) (2 ^ nat (codomain_block w1))\n   (blockmat w1)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) (2 ^ nat (domain_wall ws1))\n     (blockmat w1) &&&\n    mat (2 ^ nat (domain_wall ws1)) (2 ^ nat (domain_wall ws2))\n     (kauff_mat ws1) &&&\n    2 ^ nat (domain_wall ws1) = rat_poly.row_length (kauff_mat ws1)", "using  effective_matrix_kauff_mat prod.prems matrix_blockmat \n                row_length_domain_block"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1 \\<and> codomain_block w1 = domain_wall ws1\n  mat (2 ^ nat (domain_wall ws1)) (2 ^ nat (codomain_wall ws1))\n   (kauff_mat ws1)\n  mat (2 ^ nat (domain_block w1)) (2 ^ nat (codomain_block w1))\n   (blockmat w1)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n  is_tangle_diagram (w1 * ws1) \\<and>\n  is_tangle_diagram ws2 \\<and> domain_wall ws2 = codomain_wall (w1 * ws1)\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n  rat_poly.row_length (blockmat ?ls) = 2 ^ nat (domain_block ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) (2 ^ nat (domain_wall ws1))\n     (blockmat w1) &&&\n    mat (2 ^ nat (domain_wall ws1)) (2 ^ nat (domain_wall ws2))\n     (kauff_mat ws1) &&&\n    2 ^ nat (domain_wall ws1) = rat_poly.row_length (kauff_mat ws1)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w1)) (2 ^ nat (domain_wall ws1))\n   (blockmat w1)\n  mat (2 ^ nat (domain_wall ws1)) (2 ^ nat (domain_wall ws2))\n   (kauff_mat ws1)\n  2 ^ nat (domain_wall ws1) = rat_poly.row_length (kauff_mat ws1)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "then"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (blockmat w1)) (2 ^ nat (domain_wall ws1))\n   (blockmat w1)\n  mat (2 ^ nat (domain_wall ws1)) (2 ^ nat (domain_wall ws2))\n   (kauff_mat ws1)\n  2 ^ nat (domain_wall ws1) = rat_poly.row_length (kauff_mat ws1)", "have \"mat \n                  (rat_poly.row_length (blockmat w1)) \n                  (rat_poly.row_length (kauff_mat ws1)) \n                       (blockmat w1)\"\n         and   \"mat \n                 (rat_poly.row_length (kauff_mat ws1)) \n                 (2^(nat (domain_wall ws2))) \n                       (kauff_mat ws1)\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w1)) (2 ^ nat (domain_wall ws1))\n   (blockmat w1)\n  mat (2 ^ nat (domain_wall ws1)) (2 ^ nat (domain_wall ws2))\n   (kauff_mat ws1)\n  2 ^ nat (domain_wall ws1) = rat_poly.row_length (kauff_mat ws1)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1))\n     (rat_poly.row_length (kauff_mat ws1)) (blockmat w1) &&&\n    mat (rat_poly.row_length (kauff_mat ws1)) (2 ^ nat (domain_wall ws2))\n     (kauff_mat ws1)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w1))\n   (rat_poly.row_length (kauff_mat ws1)) (blockmat w1)\n  mat (rat_poly.row_length (kauff_mat ws1)) (2 ^ nat (domain_wall ws2))\n   (kauff_mat ws1)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "moreover"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w1))\n   (rat_poly.row_length (kauff_mat ws1)) (blockmat w1)\n  mat (rat_poly.row_length (kauff_mat ws1)) (2 ^ nat (domain_wall ws2))\n   (kauff_mat ws1)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "have \"mat \n                     (2^(nat (domain_wall ws2))) \n                      (2^(nat (codomain_wall ws2))) \n                            (kauff_mat ws2)\"\n           and \"(2^(nat (domain_wall ws2))) \n                    = rat_poly.row_length (kauff_mat ws2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (2 ^ nat (domain_wall ws2)) (2 ^ nat (codomain_wall ws2))\n     (kauff_mat ws2) &&&\n    2 ^ nat (domain_wall ws2) = rat_poly.row_length (kauff_mat ws2)", "using prod.prems  effective_matrix_kauff_mat \n              effective_matrix_kauff_mat"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w1 * ws1) \\<and>\n  is_tangle_diagram ws2 \\<and> domain_wall ws2 = codomain_wall (w1 * ws1)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. mat (2 ^ nat (domain_wall ws2)) (2 ^ nat (codomain_wall ws2))\n     (kauff_mat ws2) &&&\n    2 ^ nat (domain_wall ws2) = rat_poly.row_length (kauff_mat ws2)", "by (auto) (metis prod.prems)"], ["proof (state)\nthis:\n  mat (2 ^ nat (domain_wall ws2)) (2 ^ nat (codomain_wall ws2))\n   (kauff_mat ws2)\n  2 ^ nat (domain_wall ws2) = rat_poly.row_length (kauff_mat ws2)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "ultimately"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (blockmat w1))\n   (rat_poly.row_length (kauff_mat ws1)) (blockmat w1)\n  mat (rat_poly.row_length (kauff_mat ws1)) (2 ^ nat (domain_wall ws2))\n   (kauff_mat ws1)\n  mat (2 ^ nat (domain_wall ws2)) (2 ^ nat (codomain_wall ws2))\n   (kauff_mat ws2)\n  2 ^ nat (domain_wall ws2) = rat_poly.row_length (kauff_mat ws2)", "have \"mat \n                     (rat_poly.row_length (blockmat w1))\n                     (rat_poly.row_length (kauff_mat ws1)) \n                               (blockmat w1)\" \n             and  \"mat \n                     (rat_poly.row_length (kauff_mat ws1)) \n                     (rat_poly.row_length (kauff_mat ws2))\n                               (kauff_mat ws1)\"\n              and \"mat \n                      (rat_poly.row_length (kauff_mat ws2)) \n                      (2^(nat (codomain_wall ws2))) \n                               (kauff_mat ws2)\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w1))\n   (rat_poly.row_length (kauff_mat ws1)) (blockmat w1)\n  mat (rat_poly.row_length (kauff_mat ws1)) (2 ^ nat (domain_wall ws2))\n   (kauff_mat ws1)\n  mat (2 ^ nat (domain_wall ws2)) (2 ^ nat (codomain_wall ws2))\n   (kauff_mat ws2)\n  2 ^ nat (domain_wall ws2) = rat_poly.row_length (kauff_mat ws2)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1))\n     (rat_poly.row_length (kauff_mat ws1)) (blockmat w1) &&&\n    mat (rat_poly.row_length (kauff_mat ws1))\n     (rat_poly.row_length (kauff_mat ws2)) (kauff_mat ws1) &&&\n    mat (rat_poly.row_length (kauff_mat ws2)) (2 ^ nat (codomain_wall ws2))\n     (kauff_mat ws2)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w1))\n   (rat_poly.row_length (kauff_mat ws1)) (blockmat w1)\n  mat (rat_poly.row_length (kauff_mat ws1))\n   (rat_poly.row_length (kauff_mat ws2)) (kauff_mat ws1)\n  mat (rat_poly.row_length (kauff_mat ws2)) (2 ^ nat (codomain_wall ws2))\n   (kauff_mat ws2)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "with 3"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (blockmat w1)) (2 ^ nat (domain_wall ws1))\n   (blockmat w1)\n  mat (rat_poly.row_length (blockmat w1))\n   (rat_poly.row_length (kauff_mat ws1)) (blockmat w1)\n  mat (rat_poly.row_length (kauff_mat ws1))\n   (rat_poly.row_length (kauff_mat ws2)) (kauff_mat ws1)\n  mat (rat_poly.row_length (kauff_mat ws2)) (2 ^ nat (codomain_wall ws2))\n   (kauff_mat ws2)", "have \"rat_poly.matrix_mult \n                         (blockmat w1) \n                          (rat_poly.matrix_mult (kauff_mat ws1) \n                                      (kauff_mat ws2))\n                      = rat_poly.matrix_mult \n                             (rat_poly.matrix_mult \n                                     (blockmat w1)  \n                                     (kauff_mat ws1)) \n                                           (kauff_mat ws2)\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w1)) (2 ^ nat (domain_wall ws1))\n   (blockmat w1)\n  mat (rat_poly.row_length (blockmat w1))\n   (rat_poly.row_length (kauff_mat ws1)) (blockmat w1)\n  mat (rat_poly.row_length (kauff_mat ws1))\n   (rat_poly.row_length (kauff_mat ws2)) (kauff_mat ws1)\n  mat (rat_poly.row_length (kauff_mat ws2)) (2 ^ nat (codomain_wall ws2))\n   (kauff_mat ws2)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat w1)\n     (rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2)) =\n    rat_poly.matrix_mult\n     (rat_poly.matrix_mult (blockmat w1) (kauff_mat ws1)) (kauff_mat ws2)", "using associative_rat_poly_mat"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w1)) (2 ^ nat (domain_wall ws1))\n   (blockmat w1)\n  mat (rat_poly.row_length (blockmat w1))\n   (rat_poly.row_length (kauff_mat ws1)) (blockmat w1)\n  mat (rat_poly.row_length (kauff_mat ws1))\n   (rat_poly.row_length (kauff_mat ws2)) (kauff_mat ws1)\n  mat (rat_poly.row_length (kauff_mat ws2)) (2 ^ nat (codomain_wall ws2))\n   (kauff_mat ws2)\n  \\<lbrakk>mat (rat_poly.row_length ?m1.0) (rat_poly.row_length ?m2.0)\n            ?m1.0;\n   mat (rat_poly.row_length ?m2.0) (rat_poly.row_length ?m3.0) ?m2.0;\n   mat (rat_poly.row_length ?m3.0) ?nc ?m3.0\\<rbrakk>\n  \\<Longrightarrow> rat_poly.matrix_mult ?m1.0\n                     (rat_poly.matrix_mult ?m2.0 ?m3.0) =\n                    rat_poly.matrix_mult (rat_poly.matrix_mult ?m1.0 ?m2.0)\n                     ?m3.0\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat w1)\n     (rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2)) =\n    rat_poly.matrix_mult\n     (rat_poly.matrix_mult (blockmat w1) (kauff_mat ws1)) (kauff_mat ws2)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat w1)\n   (rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2)) =\n  rat_poly.matrix_mult (rat_poly.matrix_mult (blockmat w1) (kauff_mat ws1))\n   (kauff_mat ws2)\n\ngoal (1 subgoal):\n 1. \\<And>x1a ws1.\n       \\<lbrakk>is_tangle_diagram ws1 \\<and>\n                is_tangle_diagram ws2 \\<and>\n                domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n                kauff_mat (ws1 \\<circ> ws2) =\n                rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2);\n        is_tangle_diagram (x1a * ws1) \\<and>\n        is_tangle_diagram ws2 \\<and>\n        domain_wall ws2 = codomain_wall (x1a * ws1)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat ((x1a * ws1) \\<circ> ws2) =\n                         rat_poly.matrix_mult (kauff_mat (x1a * ws1))\n                          (kauff_mat ws2)", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (blockmat w1)\n   (rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2)) =\n  rat_poly.matrix_mult (rat_poly.matrix_mult (blockmat w1) (kauff_mat ws1))\n   (kauff_mat ws2)", "show ?case"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat w1)\n   (rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2)) =\n  rat_poly.matrix_mult (rat_poly.matrix_mult (blockmat w1) (kauff_mat ws1))\n   (kauff_mat ws2)\n\ngoal (1 subgoal):\n 1. kauff_mat ((w1 * ws1) \\<circ> ws2) =\n    rat_poly.matrix_mult (kauff_mat (w1 * ws1)) (kauff_mat ws2)", "using  \"2\" codomain_wall.simps(2) compose_Cons \n         prod.hyps prod.prems kauff_mat.simps(2)"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat w1)\n   (rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2)) =\n  rat_poly.matrix_mult (rat_poly.matrix_mult (blockmat w1) (kauff_mat ws1))\n   (kauff_mat ws2)\n  is_tangle_diagram ws1 \\<and> codomain_block w1 = domain_wall ws1\n  codomain_wall (?x * ?ys) = codomain_wall ?ys\n  (?x * ?xs) \\<circ> ?ys = ?x * ?xs \\<circ> ?ys\n  is_tangle_diagram ws1 \\<and>\n  is_tangle_diagram ws2 \\<and>\n  domain_wall ws2 = codomain_wall ws1 \\<Longrightarrow>\n  kauff_mat (ws1 \\<circ> ws2) =\n  rat_poly.matrix_mult (kauff_mat ws1) (kauff_mat ws2)\n  is_tangle_diagram (w1 * ws1) \\<and>\n  is_tangle_diagram ws2 \\<and> domain_wall ws2 = codomain_wall (w1 * ws1)\n  kauff_mat (?w * ?ws) = rat_poly.matrix_mult (blockmat ?w) (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. kauff_mat ((w1 * ws1) \\<circ> ws2) =\n    rat_poly.matrix_mult (kauff_mat (w1 * ws1)) (kauff_mat ws2)", "by (metis)"], ["proof (state)\nthis:\n  kauff_mat ((w1 * ws1) \\<circ> ws2) =\n  rat_poly.matrix_mult (kauff_mat (w1 * ws1)) (kauff_mat ws2)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem left_mat_compose:\n assumes \"is_tangle_diagram ws\" \n     and \"codomain_wall ws = 0\"\n shows \"kauff_mat ws = (kauff_mat (ws  \\<circ> (basic [])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (ws \\<circ> basic [])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (ws \\<circ> basic [])", "have \"mat (rat_poly.row_length (kauff_mat ws)) 1 (kauff_mat ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws)) 1 (kauff_mat ws)", "using effective_matrix_kauff_mat assms  nat_0 power_0"], ["proof (prove)\nusing this:\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n  is_tangle_diagram ws\n  codomain_wall ws = 0\n  nat 0 = 0\n  ?a ^ 0 = (1::?'a)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws)) 1 (kauff_mat ws)", "by metis"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (kauff_mat ws)) 1 (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (ws \\<circ> basic [])", "moreover"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (kauff_mat ws)) 1 (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (ws \\<circ> basic [])", "have \"(kauff_mat (basic [])) = mat1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat (basic []) = mat1 1", "using kauff_mat.simps(1) blockmat.simps(1) mat1_equiv"], ["proof (prove)\nusing this:\n  kauff_mat (basic ?w) = blockmat ?w\n  blockmat [] = [[1]]\n  mat1 1 = [[1]]\n\ngoal (1 subgoal):\n 1. kauff_mat (basic []) = mat1 1", "by auto"], ["proof (state)\nthis:\n  kauff_mat (basic []) = mat1 1\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (ws \\<circ> basic [])", "moreover"], ["proof (state)\nthis:\n  kauff_mat (basic []) = mat1 1\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (ws \\<circ> basic [])", "then"], ["proof (chain)\npicking this:\n  kauff_mat (basic []) = mat1 1", "have 1:\"(kauff_mat (ws  \\<circ> (basic []))) \n                              = rat_poly.matrix_mult \n                                          (kauff_mat ws) \n                                          (kauff_mat (basic []))\""], ["proof (prove)\nusing this:\n  kauff_mat (basic []) = mat1 1\n\ngoal (1 subgoal):\n 1. kauff_mat (ws \\<circ> basic []) =\n    rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic []))", "using tangle_compose_matrix assms is_tangle_diagram.simps"], ["proof (prove)\nusing this:\n  kauff_mat (basic []) = mat1 1\n  is_tangle_diagram ?ws1.0 \\<and>\n  is_tangle_diagram ?ws2.0 \\<and>\n  domain_wall ?ws2.0 = codomain_wall ?ws1.0 \\<Longrightarrow>\n  kauff_mat (?ws1.0 \\<circ> ?ws2.0) =\n  rat_poly.matrix_mult (kauff_mat ?ws1.0) (kauff_mat ?ws2.0)\n  is_tangle_diagram ws\n  codomain_wall ws = 0\n  is_tangle_diagram (basic ?x) = True\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. kauff_mat (ws \\<circ> basic []) =\n    rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic []))", "by auto"], ["proof (state)\nthis:\n  kauff_mat (ws \\<circ> basic []) =\n  rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic []))\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (ws \\<circ> basic [])", "ultimately"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (kauff_mat ws)) 1 (kauff_mat ws)\n  kauff_mat (basic []) = mat1 1\n  kauff_mat (ws \\<circ> basic []) =\n  rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic []))", "have \"rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic []))\n                             = (kauff_mat ws)\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (kauff_mat ws)) 1 (kauff_mat ws)\n  kauff_mat (basic []) = mat1 1\n  kauff_mat (ws \\<circ> basic []) =\n  rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic []))\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic [])) =\n    kauff_mat ws", "using mat_mult_equiv mat1_mult_right"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (kauff_mat ws)) 1 (kauff_mat ws)\n  kauff_mat (basic []) = mat1 1\n  kauff_mat (ws \\<circ> basic []) =\n  rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic []))\n  rat_poly.matrix_mult ?m1.0 ?m2.0 = rat_poly.matrix_mult ?m1.0 ?m2.0\n  mat ?nr ?nc ?m \\<Longrightarrow> mat_mult ?nr ?m (mat1 ?nc) = ?m\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic [])) =\n    kauff_mat ws", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic [])) = kauff_mat ws\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (ws \\<circ> basic [])", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic [])) = kauff_mat ws", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic [])) = kauff_mat ws\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (ws \\<circ> basic [])", "using 1"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic [])) = kauff_mat ws\n  kauff_mat (ws \\<circ> basic []) =\n  rat_poly.matrix_mult (kauff_mat ws) (kauff_mat (basic []))\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (ws \\<circ> basic [])", "by auto"], ["proof (state)\nthis:\n  kauff_mat ws = kauff_mat (ws \\<circ> basic [])\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem right_mat_compose:\n assumes \"is_tangle_diagram ws\" and \"domain_wall ws = 0\"\n         shows \"kauff_mat ws = (kauff_mat ((basic []) \\<circ>ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (basic [] \\<circ> ws)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (basic [] \\<circ> ws)", "have \"mat 1 (length (kauff_mat ws)) (kauff_mat ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 (length (kauff_mat ws)) (kauff_mat ws)", "using effective_matrix_kauff_mat assms  nat_0 power_0"], ["proof (prove)\nusing this:\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n  is_tangle_diagram ws\n  domain_wall ws = 0\n  nat 0 = 0\n  ?a ^ 0 = (1::?'a)\n\ngoal (1 subgoal):\n 1. mat 1 (length (kauff_mat ws)) (kauff_mat ws)", "by metis"], ["proof (state)\nthis:\n  mat 1 (length (kauff_mat ws)) (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (basic [] \\<circ> ws)", "moreover"], ["proof (state)\nthis:\n  mat 1 (length (kauff_mat ws)) (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (basic [] \\<circ> ws)", "have \"(kauff_mat (basic [])) = mat1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat (basic []) = mat1 1", "using kauff_mat.simps(1) blockmat.simps(1) mat1_equiv"], ["proof (prove)\nusing this:\n  kauff_mat (basic ?w) = blockmat ?w\n  blockmat [] = [[1]]\n  mat1 1 = [[1]]\n\ngoal (1 subgoal):\n 1. kauff_mat (basic []) = mat1 1", "by auto"], ["proof (state)\nthis:\n  kauff_mat (basic []) = mat1 1\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (basic [] \\<circ> ws)", "moreover"], ["proof (state)\nthis:\n  kauff_mat (basic []) = mat1 1\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (basic [] \\<circ> ws)", "then"], ["proof (chain)\npicking this:\n  kauff_mat (basic []) = mat1 1", "have 1:\"(kauff_mat ((basic []) \\<circ>ws))\n                              = rat_poly.matrix_mult \n                                           (kauff_mat (basic [])) \n                                           (kauff_mat ws) \""], ["proof (prove)\nusing this:\n  kauff_mat (basic []) = mat1 1\n\ngoal (1 subgoal):\n 1. kauff_mat (basic [] \\<circ> ws) =\n    rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws)", "using tangle_compose_matrix assms is_tangle_diagram.simps"], ["proof (prove)\nusing this:\n  kauff_mat (basic []) = mat1 1\n  is_tangle_diagram ?ws1.0 \\<and>\n  is_tangle_diagram ?ws2.0 \\<and>\n  domain_wall ?ws2.0 = codomain_wall ?ws1.0 \\<Longrightarrow>\n  kauff_mat (?ws1.0 \\<circ> ?ws2.0) =\n  rat_poly.matrix_mult (kauff_mat ?ws1.0) (kauff_mat ?ws2.0)\n  is_tangle_diagram ws\n  domain_wall ws = 0\n  is_tangle_diagram (basic ?x) = True\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. kauff_mat (basic [] \\<circ> ws) =\n    rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws)", "by auto"], ["proof (state)\nthis:\n  kauff_mat (basic [] \\<circ> ws) =\n  rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (basic [] \\<circ> ws)", "ultimately"], ["proof (chain)\npicking this:\n  mat 1 (length (kauff_mat ws)) (kauff_mat ws)\n  kauff_mat (basic []) = mat1 1\n  kauff_mat (basic [] \\<circ> ws) =\n  rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws)", "have \"rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws) \n                             = (kauff_mat ws)\""], ["proof (prove)\nusing this:\n  mat 1 (length (kauff_mat ws)) (kauff_mat ws)\n  kauff_mat (basic []) = mat1 1\n  kauff_mat (basic [] \\<circ> ws) =\n  rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws) =\n    kauff_mat ws", "using effective_matrix_kauff_mat(3) is_tangle_diagram.simps(1) \n              mat1 mat1_mult_left one_neq_zero rat_poly.mat_empty_column_length \n              rat_poly.unique_row_col(1)"], ["proof (prove)\nusing this:\n  mat 1 (length (kauff_mat ws)) (kauff_mat ws)\n  kauff_mat (basic []) = mat1 1\n  kauff_mat (basic [] \\<circ> ws) =\n  rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n  is_tangle_diagram (basic ?x) = True\n  mat ?nr ?nr (mat1I ?ze ?on ?nr)\n  mat ?nr ?nc ?m \\<Longrightarrow> mat_mult ?nr (mat1 ?nr) ?m = ?m\n  (1::?'a) \\<noteq> (0::?'a)\n  \\<lbrakk>mat ?nr ?nc ?M; ?M = []\\<rbrakk> \\<Longrightarrow> ?nc = 0\n  \\<lbrakk>mat ?nr1.0 ?nc1.0 ?M; mat ?nr2.0 ?nc2.0 ?M;\n   ?M \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?nr1.0 = ?nr2.0\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws) =\n    kauff_mat ws", "by metis"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws) = kauff_mat ws\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (basic [] \\<circ> ws)", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws) = kauff_mat ws", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws) = kauff_mat ws\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (basic [] \\<circ> ws)", "using 1"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws) = kauff_mat ws\n  kauff_mat (basic [] \\<circ> ws) =\n  rat_poly.matrix_mult (kauff_mat (basic [])) (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. kauff_mat ws = kauff_mat (basic [] \\<circ> ws)", "by auto"], ["proof (state)\nthis:\n  kauff_mat ws = kauff_mat (basic [] \\<circ> ws)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_id_blockmat:\"blockmat [] \\<otimes> blockmat b = blockmat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blockmat [] \\<otimes> blockmat b = blockmat b", "unfolding blockmat.simps(1) rat_poly.Tensor_left_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. blockmat b = blockmat b", "by auto"], ["", "lemma tens_assoc:\n \"\\<forall>a xs ys.(brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) \n                   = (brickmat a \\<otimes> blockmat xs) \\<otimes> blockmat ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a xs ys.\n       brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) =\n       brickmat a \\<otimes> blockmat xs \\<otimes> blockmat ys", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a xs ys.\n       brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) =\n       brickmat a \\<otimes> blockmat xs \\<otimes> blockmat ys", "have \"\\<forall>a.(mat \n               (rat_poly.row_length (brickmat a)) \n               (length (brickmat a)) \n                         (brickmat a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n        (brickmat a)", "using brickmat.simps"], ["proof (prove)\nusing this:\n  brickmat vert = [[1, 0], [0, 1]]\n  brickmat cup = [[0], [A], [rat_poly_inv B], [0]]\n  brickmat cap = [[0, rat_poly_inv A, B, 0]]\n  brickmat over =\n  [[A, 0, 0, 0], [0, 0, B, 0],\n   [0, B, A - rat_poly_times (rat_poly_times B B) B, 0], [0, 0, 0, A]]\n  brickmat brick.under =\n  [[B, 0, 0, 0], [0, B - rat_poly_times (rat_poly_times A A) A, A, 0],\n   [0, A, 0, 0], [0, 0, 0, B]]\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n        (brickmat a)", "unfolding mat_def rat_poly.row_length_def Ball_def vec_def"], ["proof (prove)\nusing this:\n  brickmat vert = [[1, 0], [0, 1]]\n  brickmat cup = [[0], [A], [rat_poly_inv B], [0]]\n  brickmat cap = [[0, rat_poly_inv A, B, 0]]\n  brickmat over =\n  [[A, 0, 0, 0], [0, 0, B, 0],\n   [0, B, A - rat_poly_times (rat_poly_times B B) B, 0], [0, 0, 0, A]]\n  brickmat brick.under =\n  [[B, 0, 0, 0], [0, B - rat_poly_times (rat_poly_times A A) A, A, 0],\n   [0, A, 0, 0], [0, 0, 0, B]]\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       length (brickmat a) = length (brickmat a) \\<and>\n       (\\<forall>x.\n           x \\<in> set (brickmat a) \\<longrightarrow>\n           length x =\n           (if brickmat a = [] then 0 else length (hd (brickmat a))))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>brickmat a \\<noteq> []; x \\<in> set (brickmat a)\\<rbrakk>\n       \\<Longrightarrow> length x = length (hd (brickmat a))", "by (case_tac a) (auto)"], ["proof (state)\nthis:\n  \\<forall>a.\n     mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n      (brickmat a)\n\ngoal (1 subgoal):\n 1. \\<forall>a xs ys.\n       brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) =\n       brickmat a \\<otimes> blockmat xs \\<otimes> blockmat ys", "moreover"], ["proof (state)\nthis:\n  \\<forall>a.\n     mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n      (brickmat a)\n\ngoal (1 subgoal):\n 1. \\<forall>a xs ys.\n       brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) =\n       brickmat a \\<otimes> blockmat xs \\<otimes> blockmat ys", "have \"\\<forall>xs. (mat \n                           (rat_poly.row_length (blockmat xs)) \n                           (length (blockmat xs)) \n                                       (blockmat xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       mat (rat_poly.row_length (blockmat xs)) (length (blockmat xs))\n        (blockmat xs)", "using matrix_blockmat"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       mat (rat_poly.row_length (blockmat xs)) (length (blockmat xs))\n        (blockmat xs)", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs.\n     mat (rat_poly.row_length (blockmat xs)) (length (blockmat xs))\n      (blockmat xs)\n\ngoal (1 subgoal):\n 1. \\<forall>a xs ys.\n       brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) =\n       brickmat a \\<otimes> blockmat xs \\<otimes> blockmat ys", "moreover"], ["proof (state)\nthis:\n  \\<forall>xs.\n     mat (rat_poly.row_length (blockmat xs)) (length (blockmat xs))\n      (blockmat xs)\n\ngoal (1 subgoal):\n 1. \\<forall>a xs ys.\n       brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) =\n       brickmat a \\<otimes> blockmat xs \\<otimes> blockmat ys", "have \"\\<forall>ys. mat \n                          (rat_poly.row_length (blockmat ys)) \n                          (length (blockmat ys)) \n                                        (blockmat ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys.\n       mat (rat_poly.row_length (blockmat ys)) (length (blockmat ys))\n        (blockmat ys)", "using matrix_blockmat"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n\ngoal (1 subgoal):\n 1. \\<forall>ys.\n       mat (rat_poly.row_length (blockmat ys)) (length (blockmat ys))\n        (blockmat ys)", "by auto"], ["proof (state)\nthis:\n  \\<forall>ys.\n     mat (rat_poly.row_length (blockmat ys)) (length (blockmat ys))\n      (blockmat ys)\n\ngoal (1 subgoal):\n 1. \\<forall>a xs ys.\n       brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) =\n       brickmat a \\<otimes> blockmat xs \\<otimes> blockmat ys", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>a.\n     mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n      (brickmat a)\n  \\<forall>xs.\n     mat (rat_poly.row_length (blockmat xs)) (length (blockmat xs))\n      (blockmat xs)\n  \\<forall>ys.\n     mat (rat_poly.row_length (blockmat ys)) (length (blockmat ys))\n      (blockmat ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n      (brickmat a)\n  \\<forall>xs.\n     mat (rat_poly.row_length (blockmat xs)) (length (blockmat xs))\n      (blockmat xs)\n  \\<forall>ys.\n     mat (rat_poly.row_length (blockmat ys)) (length (blockmat ys))\n      (blockmat ys)\n\ngoal (1 subgoal):\n 1. \\<forall>a xs ys.\n       brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) =\n       brickmat a \\<otimes> blockmat xs \\<otimes> blockmat ys", "using rat_poly.associativity"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     mat (rat_poly.row_length (brickmat a)) (length (brickmat a))\n      (brickmat a)\n  \\<forall>xs.\n     mat (rat_poly.row_length (blockmat xs)) (length (blockmat xs))\n      (blockmat xs)\n  \\<forall>ys.\n     mat (rat_poly.row_length (blockmat ys)) (length (blockmat ys))\n      (blockmat ys)\n  mat (rat_poly.row_length ?M1.0) (length ?M1.0) ?M1.0 \\<and>\n  mat (rat_poly.row_length ?M2.0) (length ?M2.0) ?M2.0 \\<and>\n  mat (rat_poly.row_length ?M3.0) (length ?M3.0) ?M3.0 \\<Longrightarrow>\n  ?M1.0 \\<otimes> (?M2.0 \\<otimes> ?M3.0) =\n  ?M1.0 \\<otimes> ?M2.0 \\<otimes> ?M3.0\n\ngoal (1 subgoal):\n 1. \\<forall>a xs ys.\n       brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) =\n       brickmat a \\<otimes> blockmat xs \\<otimes> blockmat ys", "by auto"], ["proof (state)\nthis:\n  \\<forall>a xs ys.\n     brickmat a \\<otimes> (blockmat xs \\<otimes> blockmat ys) =\n     brickmat a \\<otimes> blockmat xs \\<otimes> blockmat ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kauff_mat_tensor_distrib:\n\"\\<forall>xs.\\<forall>ys.(kauff_mat (basic xs \\<otimes> basic ys) \n = kauff_mat (basic xs) \\<otimes> kauff_mat (basic ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       kauff_mat (basic xs \\<otimes> basic ys) =\n       kauff_mat (basic xs) \\<otimes> kauff_mat (basic ys)", "apply(rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          kauff_mat (basic xs \\<otimes> basic ys) =\n          kauff_mat (basic xs) \\<otimes> kauff_mat (basic ys)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       kauff_mat (basic xs \\<otimes> basic ys) =\n       kauff_mat (basic xs) \\<otimes> kauff_mat (basic ys)", "apply (induct_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       kauff_mat (basic [] \\<otimes> basic ys) =\n       kauff_mat (basic []) \\<otimes> kauff_mat (basic ys)\n 2. \\<And>xs ys a list.\n       kauff_mat (basic list \\<otimes> basic ys) =\n       kauff_mat (basic list) \\<otimes>\n       kauff_mat (basic ys) \\<Longrightarrow>\n       kauff_mat (basic (a # list) \\<otimes> basic ys) =\n       kauff_mat (basic (a # list)) \\<otimes> kauff_mat (basic ys)", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys. blockmat ys = rat_poly.vec_mat_Tensor [1] (blockmat ys)\n 2. \\<And>ys a list.\n       blockmat (list \\<otimes> ys) =\n       blockmat list \\<otimes> blockmat ys \\<Longrightarrow>\n       brickmat a \\<otimes> (blockmat list \\<otimes> blockmat ys) =\n       brickmat a \\<otimes> blockmat list \\<otimes> blockmat ys", "apply (metis rat_poly.vec_mat_Tensor_vector_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys a list.\n       blockmat (list \\<otimes> ys) =\n       blockmat list \\<otimes> blockmat ys \\<Longrightarrow>\n       brickmat a \\<otimes> (blockmat list \\<otimes> blockmat ys) =\n       brickmat a \\<otimes> blockmat list \\<otimes> blockmat ys", "apply (simp add:tens_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma blockmat_tensor_distrib:\n \"(blockmat (a \\<otimes> b)) = (blockmat a) \\<otimes> (blockmat b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blockmat (a \\<otimes> b) = blockmat a \\<otimes> blockmat b", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. blockmat (a \\<otimes> b) = blockmat a \\<otimes> blockmat b", "have \"blockmat (a \\<otimes> b) = kauff_mat (basic (a \\<otimes> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blockmat (a \\<otimes> b) = kauff_mat (basic (a \\<otimes> b))", "using kauff_mat.simps(1)"], ["proof (prove)\nusing this:\n  kauff_mat (basic ?w) = blockmat ?w\n\ngoal (1 subgoal):\n 1. blockmat (a \\<otimes> b) = kauff_mat (basic (a \\<otimes> b))", "by auto"], ["proof (state)\nthis:\n  blockmat (a \\<otimes> b) = kauff_mat (basic (a \\<otimes> b))\n\ngoal (1 subgoal):\n 1. blockmat (a \\<otimes> b) = blockmat a \\<otimes> blockmat b", "moreover"], ["proof (state)\nthis:\n  blockmat (a \\<otimes> b) = kauff_mat (basic (a \\<otimes> b))\n\ngoal (1 subgoal):\n 1. blockmat (a \\<otimes> b) = blockmat a \\<otimes> blockmat b", "have \"... = kauff_mat (basic a) \\<otimes> kauff_mat (basic b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat (basic (a \\<otimes> b)) =\n    kauff_mat (basic a) \\<otimes> kauff_mat (basic b)", "using kauff_mat_tensor_distrib"], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     kauff_mat (basic xs \\<otimes> basic ys) =\n     kauff_mat (basic xs) \\<otimes> kauff_mat (basic ys)\n\ngoal (1 subgoal):\n 1. kauff_mat (basic (a \\<otimes> b)) =\n    kauff_mat (basic a) \\<otimes> kauff_mat (basic b)", "by auto"], ["proof (state)\nthis:\n  kauff_mat (basic (a \\<otimes> b)) =\n  kauff_mat (basic a) \\<otimes> kauff_mat (basic b)\n\ngoal (1 subgoal):\n 1. blockmat (a \\<otimes> b) = blockmat a \\<otimes> blockmat b", "moreover"], ["proof (state)\nthis:\n  kauff_mat (basic (a \\<otimes> b)) =\n  kauff_mat (basic a) \\<otimes> kauff_mat (basic b)\n\ngoal (1 subgoal):\n 1. blockmat (a \\<otimes> b) = blockmat a \\<otimes> blockmat b", "have \"... = (blockmat a) \\<otimes> (blockmat b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat (basic a) \\<otimes> kauff_mat (basic b) =\n    blockmat a \\<otimes> blockmat b", "using kauff_mat.simps(1)"], ["proof (prove)\nusing this:\n  kauff_mat (basic ?w) = blockmat ?w\n\ngoal (1 subgoal):\n 1. kauff_mat (basic a) \\<otimes> kauff_mat (basic b) =\n    blockmat a \\<otimes> blockmat b", "by auto"], ["proof (state)\nthis:\n  kauff_mat (basic a) \\<otimes> kauff_mat (basic b) =\n  blockmat a \\<otimes> blockmat b\n\ngoal (1 subgoal):\n 1. blockmat (a \\<otimes> b) = blockmat a \\<otimes> blockmat b", "ultimately"], ["proof (chain)\npicking this:\n  blockmat (a \\<otimes> b) = kauff_mat (basic (a \\<otimes> b))\n  kauff_mat (basic (a \\<otimes> b)) =\n  kauff_mat (basic a) \\<otimes> kauff_mat (basic b)\n  kauff_mat (basic a) \\<otimes> kauff_mat (basic b) =\n  blockmat a \\<otimes> blockmat b", "show ?thesis"], ["proof (prove)\nusing this:\n  blockmat (a \\<otimes> b) = kauff_mat (basic (a \\<otimes> b))\n  kauff_mat (basic (a \\<otimes> b)) =\n  kauff_mat (basic a) \\<otimes> kauff_mat (basic b)\n  kauff_mat (basic a) \\<otimes> kauff_mat (basic b) =\n  blockmat a \\<otimes> blockmat b\n\ngoal (1 subgoal):\n 1. blockmat (a \\<otimes> b) = blockmat a \\<otimes> blockmat b", "by auto"], ["proof (state)\nthis:\n  blockmat (a \\<otimes> b) = blockmat a \\<otimes> blockmat b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma blockmat_non_empty:\"\\<forall>bs.(blockmat bs \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>bs. blockmat bs \\<noteq> []", "apply(rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bs. blockmat bs \\<noteq> []", "apply(induct_tac bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs. blockmat [] \\<noteq> []\n 2. \\<And>bs a list.\n       blockmat list \\<noteq> [] \\<Longrightarrow>\n       blockmat (a # list) \\<noteq> []", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        brickmat a \\<otimes> blockmat list = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        brickmat a \\<otimes> blockmat list = []; a = vert\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        brickmat a \\<otimes> blockmat list = []; a = cup\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        brickmat a \\<otimes> blockmat list = []; a = cap\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        brickmat a \\<otimes> blockmat list = []; a = over\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        brickmat a \\<otimes> blockmat list = []; a = brick.under\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [1, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0, 1] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [A] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [rat_poly_inv B] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [0, rat_poly_inv A, B, 0] (blockmat list) =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [A, 0, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0, 0, B, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor\n         [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n         (blockmat list) =\n        [];\n        rat_poly.vec_mat_Tensor [0, 0, 0, A] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [B, 0, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor\n         [0, B - rat_poly_times (rat_poly_times A A) A, A, 0]\n         (blockmat list) =\n        [];\n        rat_poly.vec_mat_Tensor [0, A, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0, 0, 0, B] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis length_0_conv rat_poly.vec_mat_Tensor_length)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [A] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [rat_poly_inv B] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [0, rat_poly_inv A, B, 0] (blockmat list) =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [A, 0, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0, 0, B, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor\n         [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n         (blockmat list) =\n        [];\n        rat_poly.vec_mat_Tensor [0, 0, 0, A] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [B, 0, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor\n         [0, B - rat_poly_times (rat_poly_times A A) A, A, 0]\n         (blockmat list) =\n        [];\n        rat_poly.vec_mat_Tensor [0, A, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0, 0, 0, B] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis length_0_conv rat_poly.vec_mat_Tensor_length)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [0, rat_poly_inv A, B, 0] (blockmat list) =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [A, 0, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0, 0, B, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor\n         [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n         (blockmat list) =\n        [];\n        rat_poly.vec_mat_Tensor [0, 0, 0, A] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [B, 0, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor\n         [0, B - rat_poly_times (rat_poly_times A A) A, A, 0]\n         (blockmat list) =\n        [];\n        rat_poly.vec_mat_Tensor [0, A, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0, 0, 0, B] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis length_0_conv rat_poly.vec_mat_Tensor_length)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [A, 0, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0, 0, B, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor\n         [0, B, A - rat_poly_times (rat_poly_times B B) B, 0]\n         (blockmat list) =\n        [];\n        rat_poly.vec_mat_Tensor [0, 0, 0, A] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [B, 0, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor\n         [0, B - rat_poly_times (rat_poly_times A A) A, A, 0]\n         (blockmat list) =\n        [];\n        rat_poly.vec_mat_Tensor [0, A, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0, 0, 0, B] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis length_0_conv rat_poly.vec_mat_Tensor_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       \\<lbrakk>blockmat list \\<noteq> [];\n        rat_poly.vec_mat_Tensor [B, 0, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor\n         [0, B - rat_poly_times (rat_poly_times A A) A, A, 0]\n         (blockmat list) =\n        [];\n        rat_poly.vec_mat_Tensor [0, A, 0, 0] (blockmat list) = [];\n        rat_poly.vec_mat_Tensor [0, 0, 0, B] (blockmat list) = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis length_0_conv rat_poly.vec_mat_Tensor_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>The kauffman matrix of a wall representing a tangle diagram is \n         non empty\\<close>"], ["", "lemma  kauff_mat_non_empty:\n fixes ws\n assumes \"is_tangle_diagram ws\"\n shows \"kauff_mat ws \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat ws \\<noteq> []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. kauff_mat ws \\<noteq> []", "have \"(length (kauff_mat ws) =  2^(nat (codomain_wall ws)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)", "using effective_matrix_kauff_mat assms"], ["proof (prove)\nusing this:\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n  is_tangle_diagram ws\n\ngoal (1 subgoal):\n 1. length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)", "by auto"], ["proof (state)\nthis:\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)\n\ngoal (1 subgoal):\n 1. kauff_mat ws \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)", "have \"(length (kauff_mat ws)) \\<ge> 1\""], ["proof (prove)\nusing this:\n  length (kauff_mat ws) = 2 ^ nat (codomain_wall ws)\n\ngoal (1 subgoal):\n 1. 1 \\<le> length (kauff_mat ws)", "by auto"], ["proof (state)\nthis:\n  1 \\<le> length (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. kauff_mat ws \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  1 \\<le> length (kauff_mat ws)", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> length (kauff_mat ws)\n\ngoal (1 subgoal):\n 1. kauff_mat ws \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  kauff_mat ws \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_tangle_diagram_length_rowlength:\n assumes \"is_tangle_diagram (w*ws)\"\n shows \"length (blockmat w) = rat_poly.row_length (kauff_mat ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat w) = rat_poly.row_length (kauff_mat ws)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. length (blockmat w) = rat_poly.row_length (kauff_mat ws)", "have \"(codomain_block w = domain_wall ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain_block w = domain_wall ws", "using assms is_tangle_diagram.simps"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w * ws)\n  is_tangle_diagram (basic ?x) = True\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. codomain_block w = domain_wall ws", "by metis"], ["proof (state)\nthis:\n  codomain_block w = domain_wall ws\n\ngoal (1 subgoal):\n 1. length (blockmat w) = rat_poly.row_length (kauff_mat ws)", "moreover"], ["proof (state)\nthis:\n  codomain_block w = domain_wall ws\n\ngoal (1 subgoal):\n 1. length (blockmat w) = rat_poly.row_length (kauff_mat ws)", "have \"rat_poly.row_length (kauff_mat ws) \n                                = 2^(nat (domain_wall ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)", "using effective_matrix_kauff_mat"], ["proof (prove)\nusing this:\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws)\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)", "by (metis assms is_tangle_diagram.simps(2))"], ["proof (state)\nthis:\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)\n\ngoal (1 subgoal):\n 1. length (blockmat w) = rat_poly.row_length (kauff_mat ws)", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)\n\ngoal (1 subgoal):\n 1. length (blockmat w) = rat_poly.row_length (kauff_mat ws)", "have \"length (blockmat w) \n                                = 2^(nat (codomain_block w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat w) = 2 ^ nat (codomain_block w)", "using matrix_blockmat length_codomain_block"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n  length (blockmat ?ls) = 2 ^ nat (codomain_block ?ls)\n\ngoal (1 subgoal):\n 1. length (blockmat w) = 2 ^ nat (codomain_block w)", "by auto"], ["proof (state)\nthis:\n  length (blockmat w) = 2 ^ nat (codomain_block w)\n\ngoal (1 subgoal):\n 1. length (blockmat w) = rat_poly.row_length (kauff_mat ws)", "ultimately"], ["proof (chain)\npicking this:\n  codomain_block w = domain_wall ws\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)\n  length (blockmat w) = 2 ^ nat (codomain_block w)", "show ?thesis"], ["proof (prove)\nusing this:\n  codomain_block w = domain_wall ws\n  rat_poly.row_length (kauff_mat ws) = 2 ^ nat (domain_wall ws)\n  length (blockmat w) = 2 ^ nat (codomain_block w)\n\ngoal (1 subgoal):\n 1. length (blockmat w) = rat_poly.row_length (kauff_mat ws)", "by auto"], ["proof (state)\nthis:\n  length (blockmat w) = rat_poly.row_length (kauff_mat ws)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_tangle_diagram_matrix_match:\n assumes \"is_tangle_diagram (w1*ws1)\"\n    and \"is_tangle_diagram (w2*ws2)\"\n shows \"rat_poly.matrix_match (blockmat w1) \n                      (kauff_mat ws1) (blockmat w2) (kauff_mat ws2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_match (blockmat w1) (kauff_mat ws1) (blockmat w2)\n     (kauff_mat ws2)", "unfolding rat_poly.matrix_match_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1) \\<and>\n    mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1) \\<and>\n    mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2) \\<and>\n    mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2) \\<and>\n    length (blockmat w1) = rat_poly.row_length (kauff_mat ws1) \\<and>\n    length (blockmat w2) = rat_poly.row_length (kauff_mat ws2) \\<and>\n    blockmat w1 \\<noteq> [] \\<and>\n    kauff_mat ws1 \\<noteq> [] \\<and>\n    blockmat w2 \\<noteq> [] \\<and> kauff_mat ws2 \\<noteq> []", "apply(auto)"], ["proof (prove)\ngoal (10 subgoals):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1)\n 2. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)\n 3. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 4. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 5. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 6. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 7. blockmat w1 = [] \\<Longrightarrow> False\n 8. kauff_mat ws1 = [] \\<Longrightarrow> False\n 9. blockmat w2 = [] \\<Longrightarrow> False\n 10. kauff_mat ws2 = [] \\<Longrightarrow> False", "proof-"], ["proof (state)\ngoal (10 subgoals):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1)\n 2. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)\n 3. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 4. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 5. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 6. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 7. blockmat w1 = [] \\<Longrightarrow> False\n 8. kauff_mat ws1 = [] \\<Longrightarrow> False\n 9. blockmat w2 = [] \\<Longrightarrow> False\n 10. kauff_mat ws2 = [] \\<Longrightarrow> False", "show \"mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1)) (blockmat w1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1)", "using matrix_blockmat"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n   (blockmat w1)\n\ngoal (9 subgoals):\n 1. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)\n 2. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 3. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 4. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 5. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 6. blockmat w1 = [] \\<Longrightarrow> False\n 7. kauff_mat ws1 = [] \\<Longrightarrow> False\n 8. blockmat w2 = [] \\<Longrightarrow> False\n 9. kauff_mat ws2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)\n 2. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 3. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 4. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 5. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 6. blockmat w1 = [] \\<Longrightarrow> False\n 7. kauff_mat ws1 = [] \\<Longrightarrow> False\n 8. blockmat w2 = [] \\<Longrightarrow> False\n 9. kauff_mat ws2 = [] \\<Longrightarrow> False", "have \"is_tangle_diagram ws1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1", "using assms(1) is_tangle_diagram.simps(2)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w1 * ws1)\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram ws1\n\ngoal (9 subgoals):\n 1. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)\n 2. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 3. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 4. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 5. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 6. blockmat w1 = [] \\<Longrightarrow> False\n 7. kauff_mat ws1 = [] \\<Longrightarrow> False\n 8. blockmat w2 = [] \\<Longrightarrow> False\n 9. kauff_mat ws2 = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram ws1", "show \"mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1)) (kauff_mat ws1)\""], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)", "using matrix_kauff_mat"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws) \\<and>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws) \\<and>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)", "by metis"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n   (kauff_mat ws1)\n\ngoal (8 subgoals):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 2. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 3. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 4. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 5. blockmat w1 = [] \\<Longrightarrow> False\n 6. kauff_mat ws1 = [] \\<Longrightarrow> False\n 7. blockmat w2 = [] \\<Longrightarrow> False\n 8. kauff_mat ws2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 2. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 3. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 4. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 5. blockmat w1 = [] \\<Longrightarrow> False\n 6. kauff_mat ws1 = [] \\<Longrightarrow> False\n 7. blockmat w2 = [] \\<Longrightarrow> False\n 8. kauff_mat ws2 = [] \\<Longrightarrow> False", "show \"mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2)) (blockmat w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)", "using matrix_blockmat"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n   (blockmat w2)\n\ngoal (7 subgoals):\n 1. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 2. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 3. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 4. blockmat w1 = [] \\<Longrightarrow> False\n 5. kauff_mat ws1 = [] \\<Longrightarrow> False\n 6. blockmat w2 = [] \\<Longrightarrow> False\n 7. kauff_mat ws2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 2. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 3. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 4. blockmat w1 = [] \\<Longrightarrow> False\n 5. kauff_mat ws1 = [] \\<Longrightarrow> False\n 6. blockmat w2 = [] \\<Longrightarrow> False\n 7. kauff_mat ws2 = [] \\<Longrightarrow> False", "have \"is_tangle_diagram ws2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws2", "using assms(2) is_tangle_diagram.simps(2)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w2 * ws2)\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram ws2", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram ws2\n\ngoal (7 subgoals):\n 1. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 2. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 3. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 4. blockmat w1 = [] \\<Longrightarrow> False\n 5. kauff_mat ws1 = [] \\<Longrightarrow> False\n 6. blockmat w2 = [] \\<Longrightarrow> False\n 7. kauff_mat ws2 = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram ws2", "show \"mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2)) (kauff_mat ws2)\""], ["proof (prove)\nusing this:\n  is_tangle_diagram ws2\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)", "using matrix_kauff_mat"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws2\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws) \\<and>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws) \\<and>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)", "by metis"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n   (kauff_mat ws2)\n\ngoal (6 subgoals):\n 1. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 2. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 3. blockmat w1 = [] \\<Longrightarrow> False\n 4. kauff_mat ws1 = [] \\<Longrightarrow> False\n 5. blockmat w2 = [] \\<Longrightarrow> False\n 6. kauff_mat ws2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n 2. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 3. blockmat w1 = [] \\<Longrightarrow> False\n 4. kauff_mat ws1 = [] \\<Longrightarrow> False\n 5. blockmat w2 = [] \\<Longrightarrow> False\n 6. kauff_mat ws2 = [] \\<Longrightarrow> False", "show \"length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "using is_tangle_diagram_length_rowlength assms(1)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (?w * ?ws) \\<Longrightarrow>\n  length (blockmat ?w) = rat_poly.row_length (kauff_mat ?ws)\n  is_tangle_diagram (w1 * ws1)\n\ngoal (1 subgoal):\n 1. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "by auto"], ["proof (state)\nthis:\n  length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n\ngoal (5 subgoals):\n 1. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 2. blockmat w1 = [] \\<Longrightarrow> False\n 3. kauff_mat ws1 = [] \\<Longrightarrow> False\n 4. blockmat w2 = [] \\<Longrightarrow> False\n 5. kauff_mat ws2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n 2. blockmat w1 = [] \\<Longrightarrow> False\n 3. kauff_mat ws1 = [] \\<Longrightarrow> False\n 4. blockmat w2 = [] \\<Longrightarrow> False\n 5. kauff_mat ws2 = [] \\<Longrightarrow> False", "show  \"length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "using is_tangle_diagram_length_rowlength assms(2)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (?w * ?ws) \\<Longrightarrow>\n  length (blockmat ?w) = rat_poly.row_length (kauff_mat ?ws)\n  is_tangle_diagram (w2 * ws2)\n\ngoal (1 subgoal):\n 1. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "by auto"], ["proof (state)\nthis:\n  length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n\ngoal (4 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. kauff_mat ws1 = [] \\<Longrightarrow> False\n 3. blockmat w2 = [] \\<Longrightarrow> False\n 4. kauff_mat ws2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. kauff_mat ws1 = [] \\<Longrightarrow> False\n 3. blockmat w2 = [] \\<Longrightarrow> False\n 4. kauff_mat ws2 = [] \\<Longrightarrow> False", "assume 0:\"blockmat w1 = [] \""], ["proof (state)\nthis:\n  blockmat w1 = []\n\ngoal (4 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. kauff_mat ws1 = [] \\<Longrightarrow> False\n 3. blockmat w2 = [] \\<Longrightarrow> False\n 4. kauff_mat ws2 = [] \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using 0"], ["proof (prove)\nusing this:\n  blockmat w1 = []\n\ngoal (1 subgoal):\n 1. False", "by (metis blockmat_non_empty)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. kauff_mat ws1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False\n 3. kauff_mat ws2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. kauff_mat ws1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False\n 3. kauff_mat ws2 = [] \\<Longrightarrow> False", "assume 1:\"kauff_mat ws1 = [] \""], ["proof (state)\nthis:\n  kauff_mat ws1 = []\n\ngoal (3 subgoals):\n 1. kauff_mat ws1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False\n 3. kauff_mat ws2 = [] \\<Longrightarrow> False", "have \"is_tangle_diagram ws1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1", "using assms(1) is_tangle_diagram.simps(2)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w1 * ws1)\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram ws1\n\ngoal (3 subgoals):\n 1. kauff_mat ws1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False\n 3. kauff_mat ws2 = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram ws1", "show False"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1\n\ngoal (1 subgoal):\n 1. False", "using 1 kauff_mat_non_empty"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1\n  kauff_mat ws1 = []\n  is_tangle_diagram ?ws \\<Longrightarrow> kauff_mat ?ws \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. blockmat w2 = [] \\<Longrightarrow> False\n 2. kauff_mat ws2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. blockmat w2 = [] \\<Longrightarrow> False\n 2. kauff_mat ws2 = [] \\<Longrightarrow> False", "assume 0:\"blockmat w2 = [] \""], ["proof (state)\nthis:\n  blockmat w2 = []\n\ngoal (2 subgoals):\n 1. blockmat w2 = [] \\<Longrightarrow> False\n 2. kauff_mat ws2 = [] \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using 0"], ["proof (prove)\nusing this:\n  blockmat w2 = []\n\ngoal (1 subgoal):\n 1. False", "by (metis blockmat_non_empty)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. kauff_mat ws2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. kauff_mat ws2 = [] \\<Longrightarrow> False", "assume 1:\"kauff_mat ws2 = [] \""], ["proof (state)\nthis:\n  kauff_mat ws2 = []\n\ngoal (1 subgoal):\n 1. kauff_mat ws2 = [] \\<Longrightarrow> False", "have \"is_tangle_diagram ws2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws2", "using assms(2) is_tangle_diagram.simps(2)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w2 * ws2)\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram ws2", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram ws2\n\ngoal (1 subgoal):\n 1. kauff_mat ws2 = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram ws2", "show False"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws2\n\ngoal (1 subgoal):\n 1. False", "using 1 kauff_mat_non_empty"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws2\n  kauff_mat ws2 = []\n  is_tangle_diagram ?ws \\<Longrightarrow> kauff_mat ?ws \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The following function constructs a $2^n \\times 2^n$ identity matrix\n for a given $n$\\<close>"], ["", "primrec make_vert_equiv::\"nat \\<Rightarrow> rat_poly mat\"\nwhere\n\"make_vert_equiv 0 = [[1]]\"\n|\"make_vert_equiv (Suc k) = ((mat1 2)\\<otimes>(make_vert_equiv k))\""], ["", "lemma mve1:\"make_vert_equiv 1 = (mat1 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_vert_equiv 1 = mat1 2", "using make_vert_equiv.simps brickmat.simps(1) \n       One_nat_def rat_poly.Tensor_right_id"], ["proof (prove)\nusing this:\n  make_vert_equiv 0 = [[1]]\n  make_vert_equiv (Suc ?k) = mat1 2 \\<otimes> make_vert_equiv ?k\n  brickmat vert = [[1, 0], [0, 1]]\n  1 = Suc 0\n  ?xs \\<otimes> [[1]] = ?xs\n\ngoal (1 subgoal):\n 1. make_vert_equiv 1 = mat1 2", "by (metis)"], ["", "lemma\nassumes \"i<2\" and \"j<2\"\nshows \"(make_vert_equiv 1)!i!j  = (if i = j then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_vert_equiv 1 ! i ! j = (if i = j then 1 else 0)", "apply(simp add:mve1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> (mat1 2 \\<otimes> [[1]]) ! j ! j = 1) \\<and>\n    (i \\<noteq> j \\<longrightarrow> (mat1 2 \\<otimes> [[1]]) ! i ! j = 0)", "apply(simp add:rat_poly.Tensor_right_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> mat1 2 ! j ! j = 1) \\<and>\n    (i \\<noteq> j \\<longrightarrow> mat1 2 ! i ! j = 0)", "using make_vert_equiv.simps mat1_index assms"], ["proof (prove)\nusing this:\n  make_vert_equiv 0 = [[1]]\n  make_vert_equiv (Suc ?k) = mat1 2 \\<otimes> make_vert_equiv ?k\n  \\<lbrakk>?i < ?n; ?j < ?n\\<rbrakk>\n  \\<Longrightarrow> mat1I ?ze ?on ?n ! ?i ! ?j =\n                    (if ?i = ?j then ?on else ?ze)\n  i < 2\n  j < 2\n\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> mat1 2 ! j ! j = 1) \\<and>\n    (i \\<noteq> j \\<longrightarrow> mat1 2 ! i ! j = 0)", "by (metis)"], ["", "lemma mat1_vert_equiv:\"(mat1 2) = (brickmat vert)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "have \"?r = [[1,0],[0,1]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. brickmat vert = [[1, 0], [0, 1]]", "using brickmat.simps"], ["proof (prove)\nusing this:\n  brickmat vert = [[1, 0], [0, 1]]\n  brickmat cup = [[0], [A], [rat_poly_inv B], [0]]\n  brickmat cap = [[0, rat_poly_inv A, B, 0]]\n  brickmat over =\n  [[A, 0, 0, 0], [0, 0, B, 0],\n   [0, B, A - rat_poly_times (rat_poly_times B B) B, 0], [0, 0, 0, A]]\n  brickmat brick.under =\n  [[B, 0, 0, 0], [0, B - rat_poly_times (rat_poly_times A A) A, A, 0],\n   [0, A, 0, 0], [0, 0, 0, B]]\n\ngoal (1 subgoal):\n 1. brickmat vert = [[1, 0], [0, 1]]", "by auto"], ["proof (state)\nthis:\n  brickmat vert = [[1, 0], [0, 1]]\n\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "then"], ["proof (chain)\npicking this:\n  brickmat vert = [[1, 0], [0, 1]]", "have \"rat_poly.row_length ?r = 2\" and \"length ?r = 2\""], ["proof (prove)\nusing this:\n  brickmat vert = [[1, 0], [0, 1]]\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat vert) = 2 &&& length (brickmat vert) = 2", "using rat_poly.row_length_def"], ["proof (prove)\nusing this:\n  brickmat vert = [[1, 0], [0, 1]]\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (brickmat vert) = 2 &&& length (brickmat vert) = 2", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat vert) = 2\n  length (brickmat vert) = 2\n\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (brickmat vert) = 2\n  length (brickmat vert) = 2\n\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (brickmat vert) = 2\n  length (brickmat vert) = 2", "have 1:\"mat 2 2 ?r\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (brickmat vert) = 2\n  length (brickmat vert) = 2\n\ngoal (1 subgoal):\n 1. mat 2 2 (brickmat vert)", "using mat_vert"], ["proof (prove)\nusing this:\n  rat_poly.row_length (brickmat vert) = 2\n  length (brickmat vert) = 2\n  mat 2 2 (brickmat vert)\n\ngoal (1 subgoal):\n 1. mat 2 2 (brickmat vert)", "by metis"], ["proof (state)\nthis:\n  mat 2 2 (brickmat vert)\n\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.row_length (brickmat vert) = 2\n  length (brickmat vert) = 2\n  mat 2 2 (brickmat vert)", "have 2:\"(\\<forall> i < 2. \\<forall> j < 2.  \n                               ((?r) ! i ! j = (if i = j then 1 else 0)))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (brickmat vert) = 2\n  length (brickmat vert) = 2\n  mat 2 2 (brickmat vert)\n\ngoal (1 subgoal):\n 1. \\<forall>i<2.\n       \\<forall>j<2. brickmat vert ! i ! j = (if i = j then 1 else 0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_poly.row_length (brickmat vert) = 2;\n     length (brickmat vert) = 2; mat 2 2 (brickmat vert)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<2.\n                         \\<forall>j<2.\n                            brickmat vert ! i ! j = (if i = j then 1 else 0)", "have 1:\"(?r ! 0! 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. brickmat vert ! 0 ! 0 = 1", "by auto"], ["proof (state)\nthis:\n  brickmat vert ! 0 ! 0 = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_poly.row_length (brickmat vert) = 2;\n     length (brickmat vert) = 2; mat 2 2 (brickmat vert)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<2.\n                         \\<forall>j<2.\n                            brickmat vert ! i ! j = (if i = j then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  brickmat vert ! 0 ! 0 = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_poly.row_length (brickmat vert) = 2;\n     length (brickmat vert) = 2; mat 2 2 (brickmat vert)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<2.\n                         \\<forall>j<2.\n                            brickmat vert ! i ! j = (if i = j then 1 else 0)", "have 2:\"(?r ! 0! 1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. brickmat vert ! 0 ! 1 = 0", "by auto"], ["proof (state)\nthis:\n  brickmat vert ! 0 ! 1 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_poly.row_length (brickmat vert) = 2;\n     length (brickmat vert) = 2; mat 2 2 (brickmat vert)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<2.\n                         \\<forall>j<2.\n                            brickmat vert ! i ! j = (if i = j then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  brickmat vert ! 0 ! 1 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_poly.row_length (brickmat vert) = 2;\n     length (brickmat vert) = 2; mat 2 2 (brickmat vert)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<2.\n                         \\<forall>j<2.\n                            brickmat vert ! i ! j = (if i = j then 1 else 0)", "have 3:\"(?r ! 1! 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. brickmat vert ! 1 ! 0 = 0", "by auto"], ["proof (state)\nthis:\n  brickmat vert ! 1 ! 0 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_poly.row_length (brickmat vert) = 2;\n     length (brickmat vert) = 2; mat 2 2 (brickmat vert)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<2.\n                         \\<forall>j<2.\n                            brickmat vert ! i ! j = (if i = j then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  brickmat vert ! 1 ! 0 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_poly.row_length (brickmat vert) = 2;\n     length (brickmat vert) = 2; mat 2 2 (brickmat vert)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<2.\n                         \\<forall>j<2.\n                            brickmat vert ! i ! j = (if i = j then 1 else 0)", "have 5:\"(?r ! 1! 1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. brickmat vert ! 1 ! 1 = 1", "by auto"], ["proof (state)\nthis:\n  brickmat vert ! 1 ! 1 = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_poly.row_length (brickmat vert) = 2;\n     length (brickmat vert) = 2; mat 2 2 (brickmat vert)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<2.\n                         \\<forall>j<2.\n                            brickmat vert ! i ! j = (if i = j then 1 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  brickmat vert ! 0 ! 0 = 1\n  brickmat vert ! 0 ! 1 = 0\n  brickmat vert ! 1 ! 0 = 0\n  brickmat vert ! 1 ! 1 = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  brickmat vert ! 0 ! 0 = 1\n  brickmat vert ! 0 ! 1 = 0\n  brickmat vert ! 1 ! 0 = 0\n  brickmat vert ! 1 ! 1 = 1\n\ngoal (1 subgoal):\n 1. \\<forall>i<2.\n       \\<forall>j<2. brickmat vert ! i ! j = (if i = j then 1 else 0)", "by (auto dest!: less_2_cases)"], ["proof (state)\nthis:\n  \\<forall>i<2.\n     \\<forall>j<2. brickmat vert ! i ! j = (if i = j then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<2.\n     \\<forall>j<2. brickmat vert ! i ! j = (if i = j then 1 else 0)\n\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "have 3:\"mat 2 2 (mat1 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 2 2 (mat1 2)", "by (metis mat1)"], ["proof (state)\nthis:\n  mat 2 2 (mat1 2)\n\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "have 4:\"(\\<forall> i < 2. \\<forall> j < 2.  ((?l) ! i ! j = (if i = j then 1 else 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<2. \\<forall>j<2. mat1 2 ! i ! j = (if i = j then 1 else 0)", "by (metis mat1_index)"], ["proof (state)\nthis:\n  \\<forall>i<2. \\<forall>j<2. mat1 2 ! i ! j = (if i = j then 1 else 0)\n\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<2. \\<forall>j<2. mat1 2 ! i ! j = (if i = j then 1 else 0)", "have \"(\\<forall> i < 2. \\<forall> j < 2.  ((?l) ! i ! j = (?r !i !j)))\""], ["proof (prove)\nusing this:\n  \\<forall>i<2. \\<forall>j<2. mat1 2 ! i ! j = (if i = j then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>i<2. \\<forall>j<2. mat1 2 ! i ! j = brickmat vert ! i ! j", "using 2"], ["proof (prove)\nusing this:\n  \\<forall>i<2. \\<forall>j<2. mat1 2 ! i ! j = (if i = j then 1 else 0)\n  \\<forall>i<2.\n     \\<forall>j<2. brickmat vert ! i ! j = (if i = j then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>i<2. \\<forall>j<2. mat1 2 ! i ! j = brickmat vert ! i ! j", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<2. \\<forall>j<2. mat1 2 ! i ! j = brickmat vert ! i ! j\n\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "with 1  3"], ["proof (chain)\npicking this:\n  mat 2 2 (brickmat vert)\n  mat 2 2 (mat1 2)\n  \\<forall>i<2. \\<forall>j<2. mat1 2 ! i ! j = brickmat vert ! i ! j", "have \"?l = ?r\""], ["proof (prove)\nusing this:\n  mat 2 2 (brickmat vert)\n  mat 2 2 (mat1 2)\n  \\<forall>i<2. \\<forall>j<2. mat1 2 ! i ! j = brickmat vert ! i ! j\n\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "by (metis mat_eqI)"], ["proof (state)\nthis:\n  mat1 2 = brickmat vert\n\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "then"], ["proof (chain)\npicking this:\n  mat1 2 = brickmat vert", "show ?thesis"], ["proof (prove)\nusing this:\n  mat1 2 = brickmat vert\n\ngoal (1 subgoal):\n 1. mat1 2 = brickmat vert", "by auto"], ["proof (state)\nthis:\n  mat1 2 = brickmat vert\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma blockmat_make_vert:\n \"blockmat (make_vert_block n) = (make_vert_equiv n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blockmat (make_vert_block n) = make_vert_equiv n", "apply(induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. blockmat (make_vert_block 0) = make_vert_equiv 0\n 2. \\<And>n.\n       blockmat (make_vert_block n) = make_vert_equiv n \\<Longrightarrow>\n       blockmat (make_vert_block (Suc n)) = make_vert_equiv (Suc n)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       blockmat (make_vert_block n) = make_vert_equiv n \\<Longrightarrow>\n       blockmat (make_vert_block (Suc n)) = make_vert_equiv (Suc n)", "unfolding make_vert_block.simps blockmat.simps make_vert_equiv.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       blockmat (make_vert_block n) = make_vert_equiv n \\<Longrightarrow>\n       brickmat vert \\<otimes> blockmat (make_vert_block n) =\n       mat1 2 \\<otimes> make_vert_equiv n", "using mat1_vert_equiv"], ["proof (prove)\nusing this:\n  mat1 2 = brickmat vert\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       blockmat (make_vert_block n) = make_vert_equiv n \\<Longrightarrow>\n       brickmat vert \\<otimes> blockmat (make_vert_block n) =\n       mat1 2 \\<otimes> make_vert_equiv n", "by auto"], ["", "lemma prop_make_vert_equiv:\n shows \"rat_poly.row_length (make_vert_equiv n) = 2^n\"\n   and \"length (make_vert_equiv n) = 2^n\"\n   and \"mat \n         (rat_poly.row_length (make_vert_equiv n)) \n         (length (make_vert_equiv n)) \n                       (make_vert_equiv n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (make_vert_equiv n) = 2 ^ n &&&\n    length (make_vert_equiv n) = 2 ^ n &&&\n    mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "proof-"], ["proof (state)\ngoal (3 subgoals):\n 1. rat_poly.row_length (make_vert_equiv n) = 2 ^ n\n 2. length (make_vert_equiv n) = 2 ^ n\n 3. mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "have 1:\"make_vert_equiv n = (blockmat (make_vert_block n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_vert_equiv n = blockmat (make_vert_block n)", "using blockmat_make_vert"], ["proof (prove)\nusing this:\n  blockmat (make_vert_block ?n) = make_vert_equiv ?n\n\ngoal (1 subgoal):\n 1. make_vert_equiv n = blockmat (make_vert_block n)", "by auto"], ["proof (state)\nthis:\n  make_vert_equiv n = blockmat (make_vert_block n)\n\ngoal (3 subgoals):\n 1. rat_poly.row_length (make_vert_equiv n) = 2 ^ n\n 2. length (make_vert_equiv n) = 2 ^ n\n 3. mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "moreover"], ["proof (state)\nthis:\n  make_vert_equiv n = blockmat (make_vert_block n)\n\ngoal (3 subgoals):\n 1. rat_poly.row_length (make_vert_equiv n) = 2 ^ n\n 2. length (make_vert_equiv n) = 2 ^ n\n 3. mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "have 2:\"domain_block (make_vert_block n) = int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain_block (make_vert_block n) = int n", "using domain_make_vert"], ["proof (prove)\nusing this:\n  domain_block (make_vert_block ?n) = int ?n\n\ngoal (1 subgoal):\n 1. domain_block (make_vert_block n) = int n", "by auto"], ["proof (state)\nthis:\n  domain_block (make_vert_block n) = int n\n\ngoal (3 subgoals):\n 1. rat_poly.row_length (make_vert_equiv n) = 2 ^ n\n 2. length (make_vert_equiv n) = 2 ^ n\n 3. mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "moreover"], ["proof (state)\nthis:\n  domain_block (make_vert_block n) = int n\n\ngoal (3 subgoals):\n 1. rat_poly.row_length (make_vert_equiv n) = 2 ^ n\n 2. length (make_vert_equiv n) = 2 ^ n\n 3. mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "have 3:\"codomain_block (make_vert_block n) = int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain_block (make_vert_block n) = int n", "using codomain_make_vert"], ["proof (prove)\nusing this:\n  codomain_block (make_vert_block ?n) = int ?n\n\ngoal (1 subgoal):\n 1. codomain_block (make_vert_block n) = int n", "by auto"], ["proof (state)\nthis:\n  codomain_block (make_vert_block n) = int n\n\ngoal (3 subgoals):\n 1. rat_poly.row_length (make_vert_equiv n) = 2 ^ n\n 2. length (make_vert_equiv n) = 2 ^ n\n 3. mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "ultimately"], ["proof (chain)\npicking this:\n  make_vert_equiv n = blockmat (make_vert_block n)\n  domain_block (make_vert_block n) = int n\n  codomain_block (make_vert_block n) = int n", "show \"rat_poly.row_length (make_vert_equiv n) = 2^n\" \n             and \"length (make_vert_equiv n) = 2^n\"\n             and \"mat \n                     (rat_poly.row_length (make_vert_equiv n)) \n                     (length (make_vert_equiv n)) \n                               (make_vert_equiv n)\""], ["proof (prove)\nusing this:\n  make_vert_equiv n = blockmat (make_vert_block n)\n  domain_block (make_vert_block n) = int n\n  codomain_block (make_vert_block n) = int n\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (make_vert_equiv n) = 2 ^ n &&&\n    length (make_vert_equiv n) = 2 ^ n &&&\n    mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "apply (metis nat_int row_length_domain_block)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (make_vert_equiv n) = 2 ^ n\n 2. mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "using 1 2 3"], ["proof (prove)\nusing this:\n  make_vert_equiv n = blockmat (make_vert_block n)\n  domain_block (make_vert_block n) = int n\n  codomain_block (make_vert_block n) = int n\n\ngoal (2 subgoals):\n 1. length (make_vert_equiv n) = 2 ^ n\n 2. mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "apply (metis length_codomain_block nat_int)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "using 1 2 3"], ["proof (prove)\nusing this:\n  make_vert_equiv n = blockmat (make_vert_block n)\n  domain_block (make_vert_block n) = int n\n  codomain_block (make_vert_block n) = int n\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (make_vert_equiv n))\n     (length (make_vert_equiv n)) (make_vert_equiv n)", "by (metis matrix_blockmat)"], ["proof (state)\nthis:\n  rat_poly.row_length (make_vert_equiv n) = 2 ^ n\n  length (make_vert_equiv n) = 2 ^ n\n  mat (rat_poly.row_length (make_vert_equiv n)) (length (make_vert_equiv n))\n   (make_vert_equiv n)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation nat_mult::\"nat \\<Rightarrow> nat \\<Rightarrow> nat\"   (infixl \"*n\" 65)\nwhere\n\"nat_mult a b \\<equiv> ((a::nat)*b)\""], ["", "lemma equal_div_mod:assumes \"((j::nat) div a) = (i div a)\"\n            and \"(j mod a) = (i mod a)\"\n        shows \"j = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = i", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. j = i", "have \"j = a*(j div a) + (j mod a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = a *n j div a + j mod a", "by auto"], ["proof (state)\nthis:\n  j = a *n j div a + j mod a\n\ngoal (1 subgoal):\n 1. j = i", "then"], ["proof (chain)\npicking this:\n  j = a *n j div a + j mod a", "have \"j = a*(i div a) + (i mod a)\""], ["proof (prove)\nusing this:\n  j = a *n j div a + j mod a\n\ngoal (1 subgoal):\n 1. j = a *n i div a + i mod a", "using assms"], ["proof (prove)\nusing this:\n  j = a *n j div a + j mod a\n  j div a = i div a\n  j mod a = i mod a\n\ngoal (1 subgoal):\n 1. j = a *n i div a + i mod a", "by auto"], ["proof (state)\nthis:\n  j = a *n i div a + i mod a\n\ngoal (1 subgoal):\n 1. j = i", "then"], ["proof (chain)\npicking this:\n  j = a *n i div a + i mod a", "show ?thesis"], ["proof (prove)\nusing this:\n  j = a *n i div a + i mod a\n\ngoal (1 subgoal):\n 1. j = i", "by auto"], ["proof (state)\nthis:\n  j = i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma equal_div_mod2:\"(((j::nat) div a)  = (i div a)\n                      \\<and> ((j mod a) = (i mod a))) = (j = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (j div a = i div a \\<and> j mod a = i mod a) = (j = i)", "using equal_div_mod"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j div ?a = ?i div ?a; ?j mod ?a = ?i mod ?a\\<rbrakk>\n  \\<Longrightarrow> ?j = ?i\n\ngoal (1 subgoal):\n 1. (j div a = i div a \\<and> j mod a = i mod a) = (j = i)", "by metis"], ["", "lemma impl_rule:\n assumes \"(\\<forall>i < m.\\<forall>j < n. (P i) \\<and> (Q j))\" \n           and \"\\<forall> i j.(P i) \\<and> (Q j) \\<longrightarrow> R i j\"\n shows  \"(\\<forall>i < m.\\<forall>j < n. R i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<m. \\<forall>j<n. R i j", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<m. \\<forall>j<n. P i \\<and> Q j\n  \\<forall>i j. P i \\<and> Q j \\<longrightarrow> R i j\n\ngoal (1 subgoal):\n 1. \\<forall>i<m. \\<forall>j<n. R i j", "by metis"], ["", "lemma implic:\n assumes \"\\<forall>i j.((P i j) \\<longrightarrow> (Q i j))\"\n        and \"\\<forall>i j.((Q i j) \\<longrightarrow> (R i j))\"  \n shows \"\\<forall>i j.((P i j) \\<longrightarrow> (R i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j. P i j \\<longrightarrow> R i j", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i j. P i j \\<longrightarrow> Q i j\n  \\<forall>i j. Q i j \\<longrightarrow> R i j\n\ngoal (1 subgoal):\n 1. \\<forall>i j. P i j \\<longrightarrow> R i j", "by auto"], ["", "lemma assumes \"a < (b*c)\"\n      shows \"((a::nat) div b) < c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div b < c", "using assms"], ["proof (prove)\nusing this:\n  a < b *n c\n\ngoal (1 subgoal):\n 1. a div b < c", "by (metis rat_poly.div_right_ineq)"], ["", "lemma mult_if_then:\"((v = (if P then 1 else 0)) \n                    \\<and> (w = (if Q then 1 else 0)))\n                       \\<Longrightarrow> (rat_poly_times v w = (if (P\\<and>Q) then 1 else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = (if P then 1 else 0) \\<and>\n    w = (if Q then 1 else 0) \\<Longrightarrow>\n    rat_poly_times v w = (if P \\<and> Q then 1 else 0)", "by auto"], ["", "lemma rat_poly_unity:\"rat_poly_times 1 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times 1 1 = 1", "by auto"], ["", "lemma \"((P \\<and> Q) \\<longrightarrow> R) \\<Longrightarrow> (P \\<longrightarrow> Q  \\<longrightarrow> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<and> Q \\<longrightarrow> R \\<Longrightarrow>\n    P \\<longrightarrow> Q \\<longrightarrow> R", "by auto"], ["", "lemma \"length (mat1 2) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mat1 2) = 2", "apply(simp add:mat1I_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem make_vert_equiv_mat:\n\"make_vert_equiv n = (mat1 (2^n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_vert_equiv n = mat1 (2 ^ n)", "proof(induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. make_vert_equiv 0 = mat1 (2 ^ 0)\n 2. \\<And>n.\n       make_vert_equiv n = mat1 (2 ^ n) \\<Longrightarrow>\n       make_vert_equiv (Suc n) = mat1 (2 ^ Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. make_vert_equiv 0 = mat1 (2 ^ 0)\n 2. \\<And>n.\n       make_vert_equiv n = mat1 (2 ^ n) \\<Longrightarrow>\n       make_vert_equiv (Suc n) = mat1 (2 ^ Suc n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. make_vert_equiv 0 = mat1 (2 ^ 0)", "using 0 mat1_equiv"], ["proof (prove)\nusing this:\n  mat1 1 = [[1]]\n\ngoal (1 subgoal):\n 1. make_vert_equiv 0 = mat1 (2 ^ 0)", "by auto"], ["proof (state)\nthis:\n  make_vert_equiv 0 = mat1 (2 ^ 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       make_vert_equiv n = mat1 (2 ^ n) \\<Longrightarrow>\n       make_vert_equiv (Suc n) = mat1 (2 ^ Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       make_vert_equiv n = mat1 (2 ^ n) \\<Longrightarrow>\n       make_vert_equiv (Suc n) = mat1 (2 ^ Suc n)", "case (Suc k)"], ["proof (state)\nthis:\n  make_vert_equiv k = mat1 (2 ^ k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       make_vert_equiv n = mat1 (2 ^ n) \\<Longrightarrow>\n       make_vert_equiv (Suc n) = mat1 (2 ^ Suc n)", "have 1:\"make_vert_equiv k = mat1 (2 ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_vert_equiv k = mat1 (2 ^ k)", "using Suc"], ["proof (prove)\nusing this:\n  make_vert_equiv k = mat1 (2 ^ k)\n\ngoal (1 subgoal):\n 1. make_vert_equiv k = mat1 (2 ^ k)", "by auto"], ["proof (state)\nthis:\n  make_vert_equiv k = mat1 (2 ^ k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       make_vert_equiv n = mat1 (2 ^ n) \\<Longrightarrow>\n       make_vert_equiv (Suc n) = mat1 (2 ^ Suc n)", "moreover"], ["proof (state)\nthis:\n  make_vert_equiv k = mat1 (2 ^ k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       make_vert_equiv n = mat1 (2 ^ n) \\<Longrightarrow>\n       make_vert_equiv (Suc n) = mat1 (2 ^ Suc n)", "then"], ["proof (chain)\npicking this:\n  make_vert_equiv k = mat1 (2 ^ k)", "have \"make_vert_equiv (k+1) = (mat1 2)\\<otimes>(mat1 (2^k))\""], ["proof (prove)\nusing this:\n  make_vert_equiv k = mat1 (2 ^ k)\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) = mat1 2 \\<otimes> mat1 (2 ^ k)", "using make_vert_equiv.simps(2)"], ["proof (prove)\nusing this:\n  make_vert_equiv k = mat1 (2 ^ k)\n  make_vert_equiv (Suc ?k) = mat1 2 \\<otimes> make_vert_equiv ?k\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) = mat1 2 \\<otimes> mat1 (2 ^ k)", "by auto"], ["proof (state)\nthis:\n  make_vert_equiv (k + 1) = mat1 2 \\<otimes> mat1 (2 ^ k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       make_vert_equiv n = mat1 (2 ^ n) \\<Longrightarrow>\n       make_vert_equiv (Suc n) = mat1 (2 ^ Suc n)", "then"], ["proof (chain)\npicking this:\n  make_vert_equiv (k + 1) = mat1 2 \\<otimes> mat1 (2 ^ k)", "have \"(mat1 2) \\<otimes> (mat1 (2^k)) = mat1 (2^(k+1))\""], ["proof (prove)\nusing this:\n  make_vert_equiv (k + 1) = mat1 2 \\<otimes> mat1 (2 ^ k)\n\ngoal (1 subgoal):\n 1. mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 1:\"mat (2^(k+1)) (2^(k+1)) (mat1 (2^(k+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (2 ^ (k + 1)) (2 ^ (k + 1)) (mat1 (2 ^ (k + 1)))", "using mat1"], ["proof (prove)\nusing this:\n  mat ?nr ?nr (mat1I ?ze ?on ?nr)\n\ngoal (1 subgoal):\n 1. mat (2 ^ (k + 1)) (2 ^ (k + 1)) (mat1 (2 ^ (k + 1)))", "by auto"], ["proof (state)\nthis:\n  mat (2 ^ (k + 1)) (2 ^ (k + 1)) (mat1 (2 ^ (k + 1)))\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 2:\"(\\<forall> i < 2^(k+1). \\<forall> j <2^(k+1). \n                  (mat1 (2^(k+1)) ! i ! j = (if i = j then 1 else 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1).\n       \\<forall>j<2 ^ (k + 1).\n          mat1 (2 ^ (k + 1)) ! i ! j = (if i = j then 1::'a else (0::'a))", "by (metis mat1_index)"], ["proof (state)\nthis:\n  \\<forall>i<2 ^ (k + 1).\n     \\<forall>j<2 ^ (k + 1).\n        mat1 (2 ^ (k + 1)) ! i ! j = (if i = j then 1::?'a2 else (0::?'a2))\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 3:\"rat_poly.row_length (mat1 2) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (mat1 2) = 2", "by (metis mat1_vert_equiv vert_dim)"], ["proof (state)\nthis:\n  rat_poly.row_length (mat1 2) = 2\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 4:\"length (mat1 2) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mat1 2) = 2", "by (simp add:mat1I_def)"], ["proof (state)\nthis:\n  length (mat1 2) = 2\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "then"], ["proof (chain)\npicking this:\n  length (mat1 2) = 2", "have 5:\"mat \n                      (rat_poly.row_length (mat1 2)) \n                      (length (mat1 2)) \n                                (mat1 2)\""], ["proof (prove)\nusing this:\n  length (mat1 2) = 2\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (mat1 2)) (length (mat1 2)) (mat1 2)", "by (metis \"4\" mat1 mat1_vert_equiv vert_dim)"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (mat1 2)) (length (mat1 2)) (mat1 2)\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "moreover"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (mat1 2)) (length (mat1 2)) (mat1 2)\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 6:\"rat_poly.row_length (mat1 (2^k)) = 2^k\"\n           and 7:\"length ((mat1 (2^k))) = 2^k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (mat1 (2 ^ k)) = 2 ^ k &&&\n    length (mat1 (2 ^ k)) = 2 ^ k", "using Suc"], ["proof (prove)\nusing this:\n  make_vert_equiv k = mat1 (2 ^ k)\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (mat1 (2 ^ k)) = 2 ^ k &&&\n    length (mat1 (2 ^ k)) = 2 ^ k", "by (metis prop_make_vert_equiv(1)) (simp add:mat1I_def)"], ["proof (state)\nthis:\n  rat_poly.row_length (mat1 (2 ^ k)) = 2 ^ k\n  length (mat1 (2 ^ k)) = 2 ^ k\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "then"], ["proof (chain)\npicking this:\n  rat_poly.row_length (mat1 (2 ^ k)) = 2 ^ k\n  length (mat1 (2 ^ k)) = 2 ^ k", "have 8:\"mat \n                         (rat_poly.row_length (mat1 (2^k))) \n                         (length (mat1 (2^k))) \n                              (mat1 (2^k))\""], ["proof (prove)\nusing this:\n  rat_poly.row_length (mat1 (2 ^ k)) = 2 ^ k\n  length (mat1 (2 ^ k)) = 2 ^ k\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n     (mat1 (2 ^ k))", "using Suc  mat1"], ["proof (prove)\nusing this:\n  rat_poly.row_length (mat1 (2 ^ k)) = 2 ^ k\n  length (mat1 (2 ^ k)) = 2 ^ k\n  make_vert_equiv k = mat1 (2 ^ k)\n  mat ?nr ?nr (mat1I ?ze ?on ?nr)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n     (mat1 (2 ^ k))", "by (metis)"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n   (mat1 (2 ^ k))\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "then"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n   (mat1 (2 ^ k))", "have 9:\n           \"(\\<forall>i <(2^(k+1)). \\<forall>j < (2^(k+1)).\n               ((rat_poly.Tensor (mat1 2)  (mat1 (2^k))!j!i) \n                 =  rat_poly_times\n                       ((mat1 2)!(j div (length (mat1 (2^k))))\n                                !(i div (rat_poly.row_length (mat1 (2^k))))) \n                     ((mat1 (2^k))!(j mod length (mat1 (2^k)))\n                              !(i mod (rat_poly.row_length (mat1 (2^k)))))))\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n   (mat1 (2 ^ k))\n\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1).\n       \\<forall>j<2 ^ (k + 1).\n          (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n          rat_poly_times\n           (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n            (i div rat_poly.row_length (mat1 (2 ^ k))))\n           (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n            (i mod rat_poly.row_length (mat1 (2 ^ k))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n     (mat1 (2 ^ k)) \\<Longrightarrow>\n    \\<forall>i<2 ^ (k + 1).\n       \\<forall>j<2 ^ (k + 1).\n          (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n          rat_poly_times\n           (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n            (i div rat_poly.row_length (mat1 (2 ^ k))))\n           (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n            (i mod rat_poly.row_length (mat1 (2 ^ k))))", "have \"(\\<forall>i <((rat_poly.row_length (mat1 2))\n                                 *n (rat_poly.row_length (mat1 (2^k)))).\n               \\<forall>j < ((length (mat1 2))\n                       *n (length (mat1 (2^k)))).\n                   ((rat_poly.Tensor (mat1 2)  (mat1 (2^k))!j!i) \n            =  rat_poly_times\n                ((mat1 2)!(j div (length (mat1 (2^k))))\n                         !(i div (rat_poly.row_length (mat1 (2^k))))) \n                ((mat1 (2^k))!(j mod length (mat1 (2^k)))\n                         !(i mod (rat_poly.row_length (mat1 (2^k)))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<rat_poly.row_length (mat1 2) *n\n               rat_poly.row_length (mat1 (2 ^ k)).\n       \\<forall>j<length (mat1 2) *n length (mat1 (2 ^ k)).\n          (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n          rat_poly_times\n           (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n            (i div rat_poly.row_length (mat1 (2 ^ k))))\n           (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n            (i mod rat_poly.row_length (mat1 (2 ^ k))))", "using 5 8 rat_poly.effective_matrix_Tensor_elements2"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (mat1 2)) (length (mat1 2)) (mat1 2)\n  mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n   (mat1 (2 ^ k))\n  \\<lbrakk>mat (rat_poly.row_length ?M1.0) (length ?M1.0) ?M1.0;\n   mat (rat_poly.row_length ?M2.0) (length ?M2.0) ?M2.0\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i<rat_poly.row_length ?M1.0 *n\n                               rat_poly.row_length ?M2.0.\n                       \\<forall>j<length ?M1.0 *n length ?M2.0.\n                          (?M1.0 \\<otimes> ?M2.0) ! j ! i =\n                          rat_poly_times\n                           (?M1.0 ! (j div length ?M2.0) !\n                            (i div rat_poly.row_length ?M2.0))\n                           (?M2.0 ! (j mod length ?M2.0) !\n                            (i mod rat_poly.row_length ?M2.0))\n\ngoal (1 subgoal):\n 1. \\<forall>i<rat_poly.row_length (mat1 2) *n\n               rat_poly.row_length (mat1 (2 ^ k)).\n       \\<forall>j<length (mat1 2) *n length (mat1 (2 ^ k)).\n          (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n          rat_poly_times\n           (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n            (i div rat_poly.row_length (mat1 (2 ^ k))))\n           (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n            (i mod rat_poly.row_length (mat1 (2 ^ k))))", "by (metis \"3\" \"4\" \"6\" \"7\" rat_poly.comm)"], ["proof (state)\nthis:\n  \\<forall>i<rat_poly.row_length (mat1 2) *n\n             rat_poly.row_length (mat1 (2 ^ k)).\n     \\<forall>j<length (mat1 2) *n length (mat1 (2 ^ k)).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n        rat_poly_times\n         (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n          (i div rat_poly.row_length (mat1 (2 ^ k))))\n         (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n          (i mod rat_poly.row_length (mat1 (2 ^ k))))\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n     (mat1 (2 ^ k)) \\<Longrightarrow>\n    \\<forall>i<2 ^ (k + 1).\n       \\<forall>j<2 ^ (k + 1).\n          (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n          rat_poly_times\n           (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n            (i div rat_poly.row_length (mat1 (2 ^ k))))\n           (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n            (i mod rat_poly.row_length (mat1 (2 ^ k))))", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<rat_poly.row_length (mat1 2) *n\n             rat_poly.row_length (mat1 (2 ^ k)).\n     \\<forall>j<length (mat1 2) *n length (mat1 (2 ^ k)).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n        rat_poly_times\n         (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n          (i div rat_poly.row_length (mat1 (2 ^ k))))\n         (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n          (i mod rat_poly.row_length (mat1 (2 ^ k))))\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n     (mat1 (2 ^ k)) \\<Longrightarrow>\n    \\<forall>i<2 ^ (k + 1).\n       \\<forall>j<2 ^ (k + 1).\n          (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n          rat_poly_times\n           (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n            (i div rat_poly.row_length (mat1 (2 ^ k))))\n           (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n            (i mod rat_poly.row_length (mat1 (2 ^ k))))", "have \"(rat_poly.row_length (mat1 2))\n                           *n(rat_poly.row_length (mat1 (2^k))) \n                                       = 2^(k+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length (mat1 2) *n rat_poly.row_length (mat1 (2 ^ k)) =\n    2 ^ (k + 1)", "using 3 6"], ["proof (prove)\nusing this:\n  rat_poly.row_length (mat1 2) = 2\n  rat_poly.row_length (mat1 (2 ^ k)) = 2 ^ k\n\ngoal (1 subgoal):\n 1. rat_poly.row_length (mat1 2) *n rat_poly.row_length (mat1 (2 ^ k)) =\n    2 ^ (k + 1)", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length (mat1 2) *n rat_poly.row_length (mat1 (2 ^ k)) =\n  2 ^ (k + 1)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n     (mat1 (2 ^ k)) \\<Longrightarrow>\n    \\<forall>i<2 ^ (k + 1).\n       \\<forall>j<2 ^ (k + 1).\n          (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n          rat_poly_times\n           (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n            (i div rat_poly.row_length (mat1 (2 ^ k))))\n           (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n            (i mod rat_poly.row_length (mat1 (2 ^ k))))", "moreover"], ["proof (state)\nthis:\n  rat_poly.row_length (mat1 2) *n rat_poly.row_length (mat1 (2 ^ k)) =\n  2 ^ (k + 1)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n     (mat1 (2 ^ k)) \\<Longrightarrow>\n    \\<forall>i<2 ^ (k + 1).\n       \\<forall>j<2 ^ (k + 1).\n          (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n          rat_poly_times\n           (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n            (i div rat_poly.row_length (mat1 (2 ^ k))))\n           (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n            (i mod rat_poly.row_length (mat1 (2 ^ k))))", "have \"(length (mat1 2))\n                           *n(length (mat1 (2^k))) \n                                       = 2^(k+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mat1 2) *n length (mat1 (2 ^ k)) = 2 ^ (k + 1)", "using 4 7"], ["proof (prove)\nusing this:\n  length (mat1 2) = 2\n  length (mat1 (2 ^ k)) = 2 ^ k\n\ngoal (1 subgoal):\n 1. length (mat1 2) *n length (mat1 (2 ^ k)) = 2 ^ (k + 1)", "by (metis \"3\" \"6\" calculation(2))"], ["proof (state)\nthis:\n  length (mat1 2) *n length (mat1 (2 ^ k)) = 2 ^ (k + 1)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (mat1 (2 ^ k))) (length (mat1 (2 ^ k)))\n     (mat1 (2 ^ k)) \\<Longrightarrow>\n    \\<forall>i<2 ^ (k + 1).\n       \\<forall>j<2 ^ (k + 1).\n          (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n          rat_poly_times\n           (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n            (i div rat_poly.row_length (mat1 (2 ^ k))))\n           (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n            (i mod rat_poly.row_length (mat1 (2 ^ k))))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i<rat_poly.row_length (mat1 2) *n\n             rat_poly.row_length (mat1 (2 ^ k)).\n     \\<forall>j<length (mat1 2) *n length (mat1 (2 ^ k)).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n        rat_poly_times\n         (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n          (i div rat_poly.row_length (mat1 (2 ^ k))))\n         (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n          (i mod rat_poly.row_length (mat1 (2 ^ k))))\n  rat_poly.row_length (mat1 2) *n rat_poly.row_length (mat1 (2 ^ k)) =\n  2 ^ (k + 1)\n  length (mat1 2) *n length (mat1 (2 ^ k)) = 2 ^ (k + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<rat_poly.row_length (mat1 2) *n\n             rat_poly.row_length (mat1 (2 ^ k)).\n     \\<forall>j<length (mat1 2) *n length (mat1 (2 ^ k)).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n        rat_poly_times\n         (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n          (i div rat_poly.row_length (mat1 (2 ^ k))))\n         (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n          (i mod rat_poly.row_length (mat1 (2 ^ k))))\n  rat_poly.row_length (mat1 2) *n rat_poly.row_length (mat1 (2 ^ k)) =\n  2 ^ (k + 1)\n  length (mat1 2) *n length (mat1 (2 ^ k)) = 2 ^ (k + 1)\n\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1).\n       \\<forall>j<2 ^ (k + 1).\n          (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n          rat_poly_times\n           (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n            (i div rat_poly.row_length (mat1 (2 ^ k))))\n           (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n            (i mod rat_poly.row_length (mat1 (2 ^ k))))", "by metis"], ["proof (state)\nthis:\n  \\<forall>i<2 ^ (k + 1).\n     \\<forall>j<2 ^ (k + 1).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n        rat_poly_times\n         (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n          (i div rat_poly.row_length (mat1 (2 ^ k))))\n         (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n          (i mod rat_poly.row_length (mat1 (2 ^ k))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<2 ^ (k + 1).\n     \\<forall>j<2 ^ (k + 1).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n        rat_poly_times\n         (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n          (i div rat_poly.row_length (mat1 (2 ^ k))))\n         (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n          (i mod rat_poly.row_length (mat1 (2 ^ k))))\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 10:\"\\<forall>i j.((i div (rat_poly.row_length (mat1 (2^k))) < 2)\n                    \\<and>(j div length (mat1 (2^k)) < 2)\n                  \\<longrightarrow> (((mat1 2)!(j div (length (mat1 (2^k))))\n                                !(i div (rat_poly.row_length (mat1 (2^k))))) \n                      = (if \n                          ((j div (length (mat1 (2^k)))) \n                              = (i div (rat_poly.row_length (mat1 (2^k)))))\n                         then 1 \n                     else 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n       j div length (mat1 (2 ^ k)) < 2 \\<longrightarrow>\n       mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'b else (0::'b))", "using mat1_index"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?n; ?j < ?n\\<rbrakk>\n  \\<Longrightarrow> mat1I ?ze ?on ?n ! ?i ! ?j =\n                    (if ?i = ?j then ?on else ?ze)\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n       j div length (mat1 (2 ^ k)) < 2 \\<longrightarrow>\n       mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'b else (0::'b))", "by (metis \"6\" \"7\")"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n     j div length (mat1 (2 ^ k)) < 2 \\<longrightarrow>\n     mat1 2 ! (j div length (mat1 (2 ^ k))) !\n     (i div rat_poly.row_length (mat1 (2 ^ k))) =\n     (if j div length (mat1 (2 ^ k)) =\n         i div rat_poly.row_length (mat1 (2 ^ k))\n      then 1::?'b8 else (0::?'b8))\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 11:\"\\<forall>j.(j < (2^(k+1)) \\<longrightarrow> j div (length (mat1 (2^k))) < 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<2 ^ (k + 1). j div length (mat1 (2 ^ k)) < 2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>j<2 ^ (k + 1). j div length (mat1 (2 ^ k)) < 2", "have \"2^(k+1) = (2 *n (2^k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (k + 1) = 2 *n 2 ^ k", "by auto"], ["proof (state)\nthis:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<forall>j<2 ^ (k + 1). j div length (mat1 (2 ^ k)) < 2", "then"], ["proof (chain)\npicking this:\n  2 ^ (k + 1) = 2 *n 2 ^ k", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<forall>j<2 ^ (k + 1). j div length (mat1 (2 ^ k)) < 2", "using 7 allI  Suc.IH prop_make_vert_equiv(1) \n                    rat_poly.div_left_ineq"], ["proof (prove)\nusing this:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n  length (mat1 (2 ^ k)) = 2 ^ k\n  (\\<And>x. ?P x) \\<Longrightarrow> \\<forall>x. ?P x\n  make_vert_equiv k = mat1 (2 ^ k)\n  rat_poly.row_length (make_vert_equiv ?n) = 2 ^ ?n\n  ?x < ?y *n ?z \\<Longrightarrow> ?x div ?z < ?y\n\ngoal (1 subgoal):\n 1. \\<forall>j<2 ^ (k + 1). j div length (mat1 (2 ^ k)) < 2", "by (metis)"], ["proof (state)\nthis:\n  \\<forall>j<2 ^ (k + 1). j div length (mat1 (2 ^ k)) < 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j<2 ^ (k + 1). j div length (mat1 (2 ^ k)) < 2\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "moreover"], ["proof (state)\nthis:\n  \\<forall>j<2 ^ (k + 1). j div length (mat1 (2 ^ k)) < 2\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 12:\n                \"\\<forall>i.(i < (2^(k+1)) \n                      \\<longrightarrow> (i div (rat_poly.row_length (mat1 (2^k)))) < 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1). i div rat_poly.row_length (mat1 (2 ^ k)) < 2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1). i div rat_poly.row_length (mat1 (2 ^ k)) < 2", "have \"2^(k+1) = (2 *n (2^k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (k + 1) = 2 *n 2 ^ k", "by auto"], ["proof (state)\nthis:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1). i div rat_poly.row_length (mat1 (2 ^ k)) < 2", "then"], ["proof (chain)\npicking this:\n  2 ^ (k + 1) = 2 *n 2 ^ k", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1). i div rat_poly.row_length (mat1 (2 ^ k)) < 2", "using 7 allI"], ["proof (prove)\nusing this:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n  length (mat1 (2 ^ k)) = 2 ^ k\n  (\\<And>x. ?P x) \\<Longrightarrow> \\<forall>x. ?P x\n\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1). i div rat_poly.row_length (mat1 (2 ^ k)) < 2", "by (metis Suc.IH prop_make_vert_equiv(1) rat_poly.div_left_ineq)"], ["proof (state)\nthis:\n  \\<forall>i<2 ^ (k + 1). i div rat_poly.row_length (mat1 (2 ^ k)) < 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<2 ^ (k + 1). i div rat_poly.row_length (mat1 (2 ^ k)) < 2\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "ultimately"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (mat1 2)) (length (mat1 2)) (mat1 2)\n  \\<forall>j<2 ^ (k + 1). j div length (mat1 (2 ^ k)) < 2\n  \\<forall>i<2 ^ (k + 1). i div rat_poly.row_length (mat1 (2 ^ k)) < 2", "have 13:\n                \"\\<forall>i j.((i < (2^(k+1)))\\<and> j < (2^(k+1)) \\<longrightarrow>\n                         ((i div (rat_poly.row_length (mat1 (2^k)))) < 2)\n                          \\<and>((j div (length (mat1 (2^k)))) < 2))\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (mat1 2)) (length (mat1 2)) (mat1 2)\n  \\<forall>j<2 ^ (k + 1). j div length (mat1 (2 ^ k)) < 2\n  \\<forall>i<2 ^ (k + 1). i div rat_poly.row_length (mat1 (2 ^ k)) < 2\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n       j div length (mat1 (2 ^ k)) < 2", "by auto"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n     j div length (mat1 (2 ^ k)) < 2\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 14:\"\\<forall>i j.(i < (2^(k+1)))\\<and> (j < (2^(k+1))) \\<longrightarrow>\n                  (((mat1 2)\n                     !(j div (length (mat1 (2^k))))\n                     !(i div (rat_poly.row_length (mat1 (2^k))))) \n                      = (if \n                         ((j div (length (mat1 (2^k)))) \n                              = (i div (rat_poly.row_length (mat1 (2^k)))))\n                         then 1 \n                         else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "apply(rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<forall>j.\n          i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n          mat1 2 ! (j div length (mat1 (2 ^ k))) !\n          (i div rat_poly.row_length (mat1 (2 ^ k))) =\n          (if j div length (mat1 (2 ^ k)) =\n              i div rat_poly.row_length (mat1 (2 ^ k))\n           then 1::'a else (0::'a))", "apply(rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "assume 0:\"(i::nat) < 2 ^ (k + 1) \\<and> (j::nat) < 2 ^ (k + 1)\""], ["proof (state)\nthis:\n  i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "have \"((i div (rat_poly.row_length (mat1 (2^k)))) < 2)\n                     \\<and>((j div (length (mat1 (2^k)))) < 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n    j div length (mat1 (2 ^ k)) < 2", "using 0 13"], ["proof (prove)\nusing this:\n  i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1)\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n     j div length (mat1 (2 ^ k)) < 2\n\ngoal (1 subgoal):\n 1. i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n    j div length (mat1 (2 ^ k)) < 2", "by auto"], ["proof (state)\nthis:\n  i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n  j div length (mat1 (2 ^ k)) < 2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "then"], ["proof (chain)\npicking this:\n  i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n  j div length (mat1 (2 ^ k)) < 2", "show \"(((mat1 2)\n                               !(j div (length (mat1 (2^k))))\n                               !(i div (rat_poly.row_length (mat1 (2^k))))) \n                      = (if \n                        ((j div (length (mat1 (2^k)))) \n                              = (i div (rat_poly.row_length (mat1 (2^k)))))\n                         then 1 \n                         else 0))\""], ["proof (prove)\nusing this:\n  i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n  j div length (mat1 (2 ^ k)) < 2\n\ngoal (1 subgoal):\n 1. mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (if j div length (mat1 (2 ^ k)) =\n        i div rat_poly.row_length (mat1 (2 ^ k))\n     then 1::'d else (0::'d))", "using 10"], ["proof (prove)\nusing this:\n  i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n  j div length (mat1 (2 ^ k)) < 2\n  \\<forall>i j.\n     i div rat_poly.row_length (mat1 (2 ^ k)) < 2 \\<and>\n     j div length (mat1 (2 ^ k)) < 2 \\<longrightarrow>\n     mat1 2 ! (j div length (mat1 (2 ^ k))) !\n     (i div rat_poly.row_length (mat1 (2 ^ k))) =\n     (if j div length (mat1 (2 ^ k)) =\n         i div rat_poly.row_length (mat1 (2 ^ k))\n      then 1::?'b8 else (0::?'b8))\n\ngoal (1 subgoal):\n 1. mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (if j div length (mat1 (2 ^ k)) =\n        i div rat_poly.row_length (mat1 (2 ^ k))\n     then 1::'d else (0::'d))", "by (metis \"6\")"], ["proof (state)\nthis:\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (if j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k))\n   then 1::?'d12 else (0::?'d12))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     mat1 2 ! (j div length (mat1 (2 ^ k))) !\n     (i div rat_poly.row_length (mat1 (2 ^ k))) =\n     (if j div length (mat1 (2 ^ k)) =\n         i div rat_poly.row_length (mat1 (2 ^ k))\n      then 1::?'a11 else (0::?'a11))\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 15:\"\\<forall>i j.((i mod (rat_poly.row_length (mat1 (2^k))) < 2^k)\n                       \\<and>  (j mod length (mat1 (2^k)) < 2^k)\n                  \\<longrightarrow> (((mat1 (2^k))\n                             !(j mod (length (mat1 (2^k))))\n                             !(i mod (rat_poly.row_length (mat1 (2^k))))) \n                      = (if \n                           ((j mod (length (mat1 (2^k)))) \n                                 = (i mod (rat_poly.row_length (mat1 (2^k)))))\n                         then 1 \n                         else 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n       j mod length (mat1 (2 ^ k)) < 2 ^ k \\<longrightarrow>\n       mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'b else (0::'b))", "using mat1_index"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?n; ?j < ?n\\<rbrakk>\n  \\<Longrightarrow> mat1I ?ze ?on ?n ! ?i ! ?j =\n                    (if ?i = ?j then ?on else ?ze)\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n       j mod length (mat1 (2 ^ k)) < 2 ^ k \\<longrightarrow>\n       mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'b else (0::'b))", "by (metis \"6\" \"7\")"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n     j mod length (mat1 (2 ^ k)) < 2 ^ k \\<longrightarrow>\n     mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n     (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n     (if j mod length (mat1 (2 ^ k)) =\n         i mod rat_poly.row_length (mat1 (2 ^ k))\n      then 1::?'b12 else (0::?'b12))\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 16:\"\\<forall>j.(j < (2^(k+1)) \\<longrightarrow> j mod (length (mat1 (2^k))) < 2^k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<2 ^ (k + 1). j mod length (mat1 (2 ^ k)) < 2 ^ k", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>j<2 ^ (k + 1). j mod length (mat1 (2 ^ k)) < 2 ^ k", "have \"2^(k+1) = (2 *n (2^k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (k + 1) = 2 *n 2 ^ k", "by auto"], ["proof (state)\nthis:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<forall>j<2 ^ (k + 1). j mod length (mat1 (2 ^ k)) < 2 ^ k", "then"], ["proof (chain)\npicking this:\n  2 ^ (k + 1) = 2 *n 2 ^ k", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<forall>j<2 ^ (k + 1). j mod length (mat1 (2 ^ k)) < 2 ^ k", "using 7 allI  mod_less_divisor \n               nat_zero_less_power_iff zero_less_numeral"], ["proof (prove)\nusing this:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n  length (mat1 (2 ^ k)) = 2 ^ k\n  (\\<And>x. ?P x) \\<Longrightarrow> \\<forall>x. ?P x\n  0 < ?n \\<Longrightarrow> ?m mod ?n < ?n\n  (0 < ?x ^ ?n) = (0 < ?x \\<or> ?n = 0)\n  (0::?'a) < numeral ?n\n\ngoal (1 subgoal):\n 1. \\<forall>j<2 ^ (k + 1). j mod length (mat1 (2 ^ k)) < 2 ^ k", "by (metis)"], ["proof (state)\nthis:\n  \\<forall>j<2 ^ (k + 1). j mod length (mat1 (2 ^ k)) < 2 ^ k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j<2 ^ (k + 1). j mod length (mat1 (2 ^ k)) < 2 ^ k\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "moreover"], ["proof (state)\nthis:\n  \\<forall>j<2 ^ (k + 1). j mod length (mat1 (2 ^ k)) < 2 ^ k\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 17:\"\\<forall>i.(i < (2^(k+1)) \n                         \\<longrightarrow> (i mod (rat_poly.row_length (mat1 (2^k)))) < 2^k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1). i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1). i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k", "have \"2^(k+1) = (2 *n (2^k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (k + 1) = 2 *n 2 ^ k", "by auto"], ["proof (state)\nthis:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1). i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k", "then"], ["proof (chain)\npicking this:\n  2 ^ (k + 1) = 2 *n 2 ^ k", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1). i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k", "using 7 allI"], ["proof (prove)\nusing this:\n  2 ^ (k + 1) = 2 *n 2 ^ k\n  length (mat1 (2 ^ k)) = 2 ^ k\n  (\\<And>x. ?P x) \\<Longrightarrow> \\<forall>x. ?P x\n\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1). i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k", "by (metis \"6\" calculation)"], ["proof (state)\nthis:\n  \\<forall>i<2 ^ (k + 1). i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<2 ^ (k + 1). i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>j<2 ^ (k + 1). j mod length (mat1 (2 ^ k)) < 2 ^ k\n  \\<forall>i<2 ^ (k + 1). i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k", "have 18:\n             \"\\<forall>i j.((i < (2^(k+1)))\\<and> j < (2^(k+1)) \\<longrightarrow>\n                         ((i mod (rat_poly.row_length (mat1 (2^k)))) < 2^k)\n                          \\<and>((j mod (length (mat1 (2^k)))) < 2^k))\""], ["proof (prove)\nusing this:\n  \\<forall>j<2 ^ (k + 1). j mod length (mat1 (2 ^ k)) < 2 ^ k\n  \\<forall>i<2 ^ (k + 1). i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n       j mod length (mat1 (2 ^ k)) < 2 ^ k", "by (metis \"7\")"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n     j mod length (mat1 (2 ^ k)) < 2 ^ k\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have 19:\"\\<forall>i j.(i < (2^(k+1)))\\<and> (j < (2^(k+1))) \\<longrightarrow>\n                  (((mat1 (2^k))\n                        !(j mod (length (mat1 (2^k))))\n                        !(i mod (rat_poly.row_length (mat1 (2^k))))) \n                          = (if \n                              ((j mod (length (mat1 (2^k)))) \n                                 = (i mod (rat_poly.row_length (mat1 (2^k)))))\n                         then 1 \n                         else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "apply(rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<forall>j.\n          i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n          mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n          (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n          (if j mod length (mat1 (2 ^ k)) =\n              i mod rat_poly.row_length (mat1 (2 ^ k))\n           then 1::'a else (0::'a))", "apply(rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "assume 0:\"(i::nat) < 2 ^ (k + 1) \\<and> (j::nat) < 2 ^ (k + 1)\""], ["proof (state)\nthis:\n  i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "have \"((i mod (rat_poly.row_length (mat1 (2^k)))) < 2^k)\n                          \\<and>((j mod (length (mat1 (2^k)))) < 2^k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n    j mod length (mat1 (2 ^ k)) < 2 ^ k", "using 0 18"], ["proof (prove)\nusing this:\n  i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1)\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n     j mod length (mat1 (2 ^ k)) < 2 ^ k\n\ngoal (1 subgoal):\n 1. i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n    j mod length (mat1 (2 ^ k)) < 2 ^ k", "by auto"], ["proof (state)\nthis:\n  i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n  j mod length (mat1 (2 ^ k)) < 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n       (if j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1::'a else (0::'a))", "then"], ["proof (chain)\npicking this:\n  i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n  j mod length (mat1 (2 ^ k)) < 2 ^ k", "show \"(((mat1 (2^k))\n                               !(j mod (length (mat1 (2^k))))\n                               !(i mod(rat_poly.row_length (mat1 (2^k))))) \n                      = (if \n                          ((j mod (length (mat1 (2^k)))) \n                                = (i mod (rat_poly.row_length (mat1 (2^k)))))\n                            then 1 \n                            else 0))\""], ["proof (prove)\nusing this:\n  i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n  j mod length (mat1 (2 ^ k)) < 2 ^ k\n\ngoal (1 subgoal):\n 1. mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (if j mod length (mat1 (2 ^ k)) =\n        i mod rat_poly.row_length (mat1 (2 ^ k))\n     then 1::'d else (0::'d))", "using 15"], ["proof (prove)\nusing this:\n  i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n  j mod length (mat1 (2 ^ k)) < 2 ^ k\n  \\<forall>i j.\n     i mod rat_poly.row_length (mat1 (2 ^ k)) < 2 ^ k \\<and>\n     j mod length (mat1 (2 ^ k)) < 2 ^ k \\<longrightarrow>\n     mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n     (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n     (if j mod length (mat1 (2 ^ k)) =\n         i mod rat_poly.row_length (mat1 (2 ^ k))\n      then 1::?'b12 else (0::?'b12))\n\ngoal (1 subgoal):\n 1. mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (if j mod length (mat1 (2 ^ k)) =\n        i mod rat_poly.row_length (mat1 (2 ^ k))\n     then 1::'d else (0::'d))", "by (metis \"6\")"], ["proof (state)\nthis:\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (if j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k))\n   then 1::?'d16 else (0::?'d16))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n     (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n     (if j mod length (mat1 (2 ^ k)) =\n         i mod rat_poly.row_length (mat1 (2 ^ k))\n      then 1::?'a15 else (0::?'a15))\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have \"(\\<forall>i. \\<forall>j. \n              (i <(2^(k+1))) \\<and> (j < (2^(k+1))) \n                \\<longrightarrow> rat_poly_times\n                              ((mat1 2)\n                                  !(j div (length (mat1 (2^k))))\n                                  !(i div (rat_poly.row_length (mat1 (2^k))))) \n                              ((mat1 (2^k))\n                                  !(j mod length (mat1 (2^k)))\n                                  !(i mod (rat_poly.row_length (mat1 (2^k)))))\n                   =\n                    (if \n                        (((j div (length (mat1 (2^k)))) \n                              = (i div (rat_poly.row_length (mat1 (2^k)))))\n                        \\<and>((j mod (length (mat1 (2^k)))) \n                              = (i mod (rat_poly.row_length (mat1 (2^k))))))                        \n                         then 1 \n                         else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       rat_poly_times\n        (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n         (i div rat_poly.row_length (mat1 (2 ^ k))))\n        (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n         (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n           j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1 else 0)", "apply(rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<forall>j.\n          i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n          rat_poly_times\n           (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n            (i div rat_poly.row_length (mat1 (2 ^ k))))\n           (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n            (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n          (if j div length (mat1 (2 ^ k)) =\n              i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n              j mod length (mat1 (2 ^ k)) =\n              i mod rat_poly.row_length (mat1 (2 ^ k))\n           then 1 else 0)", "apply(rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       rat_poly_times\n        (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n         (i div rat_poly.row_length (mat1 (2 ^ k))))\n        (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n         (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n           j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1 else 0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       rat_poly_times\n        (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n         (i div rat_poly.row_length (mat1 (2 ^ k))))\n        (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n         (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n           j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1 else 0)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       rat_poly_times\n        (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n         (i div rat_poly.row_length (mat1 (2 ^ k))))\n        (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n         (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n           j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1 else 0)", "assume 0: \"((i::nat) <(2^(k+1))) \\<and> ((j::nat) < (2^(k+1)))\""], ["proof (state)\nthis:\n  i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       rat_poly_times\n        (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n         (i div rat_poly.row_length (mat1 (2 ^ k))))\n        (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n         (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n           j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1 else 0)", "have s1: \"((mat1 2)\n                      !(j div (length (mat1 (2^k))))\n                      !(i div (rat_poly.row_length (mat1 (2^k))))) \n                      =    (if \n                          ((j div (length (mat1 (2^k)))) \n                             = (i div (rat_poly.row_length (mat1 (2^k)))))\n                          then 1 \n                               else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (if j div length (mat1 (2 ^ k)) =\n        i div rat_poly.row_length (mat1 (2 ^ k))\n     then 1::'e else (0::'e))", "using 0 14"], ["proof (prove)\nusing this:\n  i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1)\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     mat1 2 ! (j div length (mat1 (2 ^ k))) !\n     (i div rat_poly.row_length (mat1 (2 ^ k))) =\n     (if j div length (mat1 (2 ^ k)) =\n         i div rat_poly.row_length (mat1 (2 ^ k))\n      then 1::?'a11 else (0::?'a11))\n\ngoal (1 subgoal):\n 1. mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (if j div length (mat1 (2 ^ k)) =\n        i div rat_poly.row_length (mat1 (2 ^ k))\n     then 1::'e else (0::'e))", "by metis"], ["proof (state)\nthis:\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (if j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k))\n   then 1::?'e16 else (0::?'e16))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       rat_poly_times\n        (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n         (i div rat_poly.row_length (mat1 (2 ^ k))))\n        (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n         (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n           j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (if j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k))\n   then 1::?'e16 else (0::?'e16))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       rat_poly_times\n        (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n         (i div rat_poly.row_length (mat1 (2 ^ k))))\n        (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n         (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n           j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1 else 0)", "have s2:\"((mat1 (2^k))\n                              !(j mod (length (mat1 (2^k))))\n                              !(i mod (rat_poly.row_length (mat1 (2^k))))) \n                         =  (if \n                          ((j mod (length (mat1 (2^k)))) \n                                = (i mod (rat_poly.row_length (mat1 (2^k)))))\n                               then 1 \n                               else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (if j mod length (mat1 (2 ^ k)) =\n        i mod rat_poly.row_length (mat1 (2 ^ k))\n     then 1::'e else (0::'e))", "using 0 19"], ["proof (prove)\nusing this:\n  i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1)\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n     (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n     (if j mod length (mat1 (2 ^ k)) =\n         i mod rat_poly.row_length (mat1 (2 ^ k))\n      then 1::?'a15 else (0::?'a15))\n\ngoal (1 subgoal):\n 1. mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (if j mod length (mat1 (2 ^ k)) =\n        i mod rat_poly.row_length (mat1 (2 ^ k))\n     then 1::'e else (0::'e))", "by metis"], ["proof (state)\nthis:\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (if j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k))\n   then 1::?'e17 else (0::?'e17))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<Longrightarrow>\n       rat_poly_times\n        (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n         (i div rat_poly.row_length (mat1 (2 ^ k))))\n        (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n         (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n           j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1 else 0)", "show \"rat_poly_times\n                     ((mat1 2)\n                             !(j div (length (mat1 (2^k))))\n                             !(i div (rat_poly.row_length (mat1 (2^k))))) \n                             ((mat1 (2^k))\n                                 !(j mod length (mat1 (2^k)))\n                                 !(i mod (rat_poly.row_length (mat1 (2^k)))))\n                             =\n                           (if \n                             (((j div (length (mat1 (2^k)))) \n                                = (i div (rat_poly.row_length (mat1 (2^k)))))\n                             \\<and>((j mod (length (mat1 (2^k)))) \n                                = (i mod (rat_poly.row_length (mat1 (2^k))))))\n                                  then 1 \n                                  else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    (if j div length (mat1 (2 ^ k)) =\n        i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n        j mod length (mat1 (2 ^ k)) =\n        i mod rat_poly.row_length (mat1 (2 ^ k))\n     then 1 else 0)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n     j mod length (mat1 (2 ^ k)) =\n     i mod rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     rat_poly_times\n      (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))))\n      (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n     1) \\<and>\n    ((j div length (mat1 (2 ^ k)) =\n      i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n      j mod length (mat1 (2 ^ k)) \\<noteq>\n      i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n     mat1 2 ! (j div length (mat1 (2 ^ k))) !\n     (i div rat_poly.row_length (mat1 (2 ^ k))) =\n     0 \\<or>\n     mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n     (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n     0)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1\n 2. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq>\n     i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    0 \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    0", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1\n 2. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq>\n     i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    0 \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    0", "show \"j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k)) \n           \\<and> (j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k)))\n                        \\<longrightarrow> rat_poly_times \n                              (mat1 2 \n                                 !(j div length (mat1 (2 ^ k))) \n                                 !(i div rat_poly.row_length (mat1 (2 ^ k))))\n                               (mat1 (2 ^ k) \n                                 !(j mod length (mat1 (2 ^ k))) \n                                 !(i mod rat_poly.row_length (mat1 (2 ^ k)))) \n                                         = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1", "have \n        \"j div length (mat1 (2 ^ k)) \n                                  = i div rat_poly.row_length (mat1 (2 ^ k)) \n          \\<and> j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k))  \n         \\<Longrightarrow> rat_poly_times \n              (mat1 2 ! (j div length (mat1 (2 ^ k))) ! (i div rat_poly.row_length (mat1 (2 ^ k))))\n              (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) \n                            ! (i mod rat_poly.row_length (mat1 (2 ^ k)))) =   1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1", "assume local_assms:\n            \"j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k)) \n           \\<and> j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k)) \""], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k))\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1", "have \"(mat1 2 ! (j div length (mat1 (2 ^ k))) ! (i div rat_poly.row_length (mat1 (2 ^ k))))\n                               = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (1::'s)", "using s1 local_assms"], ["proof (prove)\nusing this:\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (if j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k))\n   then 1::?'e16 else (0::?'e16))\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k))\n\ngoal (1 subgoal):\n 1. mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (1::'s)", "by metis"], ["proof (state)\nthis:\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (1::?'s19)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1", "moreover"], ["proof (state)\nthis:\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (1::?'s19)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1", "have \"(mat1 (2 ^ k) \n                 ! (j mod length (mat1 (2 ^ k))) ! (i mod rat_poly.row_length (mat1 (2 ^ k)))) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (1::'s)", "using s2 local_assms"], ["proof (prove)\nusing this:\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (if j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k))\n   then 1::?'e17 else (0::?'e17))\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k))\n\ngoal (1 subgoal):\n 1. mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (1::'s)", "by metis"], ["proof (state)\nthis:\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (1::?'s20)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1", "ultimately"], ["proof (chain)\npicking this:\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (1::?'s19)\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (1::?'s20)", "show ?thesis"], ["proof (prove)\nusing this:\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (1::?'s19)\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (1::?'s20)\n\ngoal (1 subgoal):\n 1. rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1", "by (metis \"3\" \"6\" \"7\" Suc.IH local_assms mve1 prop_make_vert_equiv(1) \n                          prop_make_vert_equiv(2) rat_poly.right_id)"], ["proof (state)\nthis:\n  rat_poly_times\n   (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))))\n   (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) =\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  rat_poly_times\n   (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))))\n   (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n  1\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1", "then"], ["proof (chain)\npicking this:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) =\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  rat_poly_times\n   (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))))\n   (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n  1", "show ?thesis"], ["proof (prove)\nusing this:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) =\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  rat_poly_times\n   (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))))\n   (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n  1\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) =\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    rat_poly_times\n     (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n      (i div rat_poly.row_length (mat1 (2 ^ k))))\n     (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n      (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n    1", "by auto"], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) =\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n  rat_poly_times\n   (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))))\n   (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) =\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n  rat_poly_times\n   (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))))\n   (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n  1\n\ngoal (1 subgoal):\n 1. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq>\n     i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    0 \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    0", "show \n       \"(j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n              j mod length (mat1 (2 ^ k)) \\<noteq> i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n          mat1 2 ! (j div length (mat1 (2 ^ k))) ! (i div rat_poly.row_length (mat1 (2 ^ k))) = 0 \\<or>\n      mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) ! (i mod rat_poly.row_length (mat1 (2 ^ k))) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq>\n     i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'k) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'m)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq>\n     i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'k) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'m)", "have \"(j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k))\n            \\<and>  j mod length (mat1 (2 ^ k)) \\<noteq> i mod rat_poly.row_length (mat1 (2 ^ k))) \\<Longrightarrow>\n           mat1 2 ! (j div length (mat1 (2 ^ k))) ! (i div rat_poly.row_length (mat1 (2 ^ k))) = 0 \n   \\<or> mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) ! (i mod rat_poly.row_length (mat1 (2 ^ k))) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'q) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'s)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'q) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'s)", "assume local_assms:\n                \"(j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k))\n                 \\<and> j mod length (mat1 (2 ^ k)) \\<noteq> i mod rat_poly.row_length (mat1 (2 ^ k)))\""], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) \\<noteq>\n  i mod rat_poly.row_length (mat1 (2 ^ k))\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'q) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'s)", "have \"mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) ! (i mod rat_poly.row_length (mat1 (2 ^ k))) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w)", "using s2 local_assms"], ["proof (prove)\nusing this:\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (if j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k))\n   then 1::?'e17 else (0::?'e17))\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) \\<noteq>\n  i mod rat_poly.row_length (mat1 (2 ^ k))\n\ngoal (1 subgoal):\n 1. mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w)", "by metis"], ["proof (state)\nthis:\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'w20)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'q) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'s)", "then"], ["proof (chain)\npicking this:\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'w20)", "show ?thesis"], ["proof (prove)\nusing this:\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'w20)\n\ngoal (1 subgoal):\n 1. mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'q) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'s)", "by auto"], ["proof (state)\nthis:\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'q) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) \\<noteq>\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'q19) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'s19)\n\ngoal (1 subgoal):\n 1. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq>\n     i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'k) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'m)", "then"], ["proof (chain)\npicking this:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) \\<noteq>\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'q19) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'s19)", "have l:\n     \"(j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k))\n       \\<and> j mod length (mat1 (2 ^ k)) \\<noteq> i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n        mat1 2 ! (j div length (mat1 (2 ^ k))) ! (i div rat_poly.row_length (mat1 (2 ^ k))) = 0 \n    \\<or>mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) ! (i mod rat_poly.row_length (mat1 (2 ^ k))) = 0\""], ["proof (prove)\nusing this:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) \\<noteq>\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'q19) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'s19)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'q) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'s)", "by auto"], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n  j mod length (mat1 (2 ^ k)) \\<noteq>\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'q20) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'s20)\n\ngoal (1 subgoal):\n 1. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq>\n     i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'k) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'m)", "show \"(j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq> i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) ! (i div rat_poly.row_length (mat1 (2 ^ k))) = 0 \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) ! (i mod rat_poly.row_length (mat1 (2 ^ k))) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq>\n     i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'q) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'s)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq>\n     i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'q) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'s)", "have \n         \"(j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n          j mod length (mat1 (2 ^ k)) \\<noteq> i mod rat_poly.row_length (mat1 (2 ^ k))) \\<Longrightarrow>\n      mat1 2 ! (j div length (mat1 (2 ^ k))) ! (i div rat_poly.row_length (mat1 (2 ^ k))) = 0 \\<or>\n      mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) ! (i mod rat_poly.row_length (mat1 (2 ^ k))) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "assume local_assm1:\n           \"(j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n                    j mod length (mat1 (2 ^ k)) \\<noteq> i mod rat_poly.row_length (mat1 (2 ^ k)))\""], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n  j mod length (mat1 (2 ^ k)) \\<noteq>\n  i mod rat_poly.row_length (mat1 (2 ^ k))\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "have \"(j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k)))\n               \\<Longrightarrow> \n                mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) \n                             ! (i mod rat_poly.row_length (mat1 (2 ^ k))) \n                           = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'ad)", "using s2 local_assm1"], ["proof (prove)\nusing this:\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (if j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k))\n   then 1::?'e17 else (0::?'e17))\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n  j mod length (mat1 (2 ^ k)) \\<noteq>\n  i mod rat_poly.row_length (mat1 (2 ^ k))\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'ad)", "by (metis \"7\")"], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'ad22)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "then"], ["proof (chain)\npicking this:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'ad22)", "have l1:\" (j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k)))\n                     \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'ad22)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "by auto"], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'w) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'y)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "moreover"], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'w) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'y)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "have \"\\<not>(j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k)))\n                         \\<Longrightarrow>  mat1 2 ! (j div length (mat1 (2^k))) \n                                     ! (i div rat_poly.row_length (mat1 (2^k))) \n                                                = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) \\<noteq>\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'ad)", "using s1"], ["proof (prove)\nusing this:\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (if j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k))\n   then 1::?'e16 else (0::?'e16))\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) \\<noteq>\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'ad)", "by metis"], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) \\<noteq>\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'ad24)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "then"], ["proof (chain)\npicking this:\n  j div length (mat1 (2 ^ k)) \\<noteq>\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'ad24)", "have \"\\<not>(j div length (mat1 (2 ^ k)) = i div rat_poly.row_length (mat1 (2 ^ k)))\n                        \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  j div length (mat1 (2 ^ k)) \\<noteq>\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'ad24)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) \\<noteq>\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "by auto"], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) \\<noteq>\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'w) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'y)\n\ngoal (1 subgoal):\n 1. j div length (mat1 (2 ^ k)) =\n    i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n    j mod length (mat1 (2 ^ k)) \\<noteq>\n    i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "then"], ["proof (chain)\npicking this:\n  j div length (mat1 (2 ^ k)) \\<noteq>\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'w) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'y)", "show ?thesis"], ["proof (prove)\nusing this:\n  j div length (mat1 (2 ^ k)) \\<noteq>\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'w) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'y)\n\ngoal (1 subgoal):\n 1. mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "using l1"], ["proof (prove)\nusing this:\n  j div length (mat1 (2 ^ k)) \\<noteq>\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'w) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'y)\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'w) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'y)\n\ngoal (1 subgoal):\n 1. mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'w) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'y)", "by auto"], ["proof (state)\nthis:\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'w) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n  j mod length (mat1 (2 ^ k)) \\<noteq>\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'w21) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'y21)\n\ngoal (1 subgoal):\n 1. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq>\n     i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'q) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'s)", "then"], ["proof (chain)\npicking this:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n  j mod length (mat1 (2 ^ k)) \\<noteq>\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'w21) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'y21)", "show ?thesis"], ["proof (prove)\nusing this:\n  j div length (mat1 (2 ^ k)) =\n  i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n  j mod length (mat1 (2 ^ k)) \\<noteq>\n  i mod rat_poly.row_length (mat1 (2 ^ k)) \\<Longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'w21) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'y21)\n\ngoal (1 subgoal):\n 1. (j div length (mat1 (2 ^ k)) =\n     i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n     j mod length (mat1 (2 ^ k)) \\<noteq>\n     i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n    mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'q) \\<or>\n    mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n    (0::'s)", "by auto"], ["proof (state)\nthis:\n  (j div length (mat1 (2 ^ k)) =\n   i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n   j mod length (mat1 (2 ^ k)) \\<noteq>\n   i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'q) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::'s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (j div length (mat1 (2 ^ k)) =\n   i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n   j mod length (mat1 (2 ^ k)) \\<noteq>\n   i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'q21) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'s21)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (j div length (mat1 (2 ^ k)) =\n   i div rat_poly.row_length (mat1 (2 ^ k)) \\<longrightarrow>\n   j mod length (mat1 (2 ^ k)) \\<noteq>\n   i mod rat_poly.row_length (mat1 (2 ^ k))) \\<longrightarrow>\n  mat1 2 ! (j div length (mat1 (2 ^ k))) !\n  (i div rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'k19) \\<or>\n  mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n  (i mod rat_poly.row_length (mat1 (2 ^ k))) =\n  (0::?'m19)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rat_poly_times\n   (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n    (i div rat_poly.row_length (mat1 (2 ^ k))))\n   (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n    (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n  (if j div length (mat1 (2 ^ k)) =\n      i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n      j mod length (mat1 (2 ^ k)) = i mod rat_poly.row_length (mat1 (2 ^ k))\n   then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     rat_poly_times\n      (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))))\n      (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n     (if j div length (mat1 (2 ^ k)) =\n         i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n         j mod length (mat1 (2 ^ k)) =\n         i mod rat_poly.row_length (mat1 (2 ^ k))\n      then 1 else 0)\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "then"], ["proof (chain)\npicking this:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     rat_poly_times\n      (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))))\n      (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n     (if j div length (mat1 (2 ^ k)) =\n         i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n         j mod length (mat1 (2 ^ k)) =\n         i mod rat_poly.row_length (mat1 (2 ^ k))\n      then 1 else 0)", "have \"(\\<forall>i. \\<forall>j. (i <(2^(k+1))) \\<and> (j < (2^(k+1))) \\<longrightarrow>\n         ((rat_poly.Tensor (mat1 2)  (mat1 (2^k))!j!i)  = (if \n                      (((j div (length (mat1 (2^k)))) = (i div (rat_poly.row_length (mat1 (2^k)))))\n                     \\<and>((j mod (length (mat1 (2^k)))) = (i mod (rat_poly.row_length (mat1 (2^k))))))\n                        then 1 \n                         else 0)))\""], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     rat_poly_times\n      (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))))\n      (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n     (if j div length (mat1 (2 ^ k)) =\n         i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n         j mod length (mat1 (2 ^ k)) =\n         i mod rat_poly.row_length (mat1 (2 ^ k))\n      then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n           j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1 else 0)", "using 9"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     rat_poly_times\n      (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n       (i div rat_poly.row_length (mat1 (2 ^ k))))\n      (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n       (i mod rat_poly.row_length (mat1 (2 ^ k)))) =\n     (if j div length (mat1 (2 ^ k)) =\n         i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n         j mod length (mat1 (2 ^ k)) =\n         i mod rat_poly.row_length (mat1 (2 ^ k))\n      then 1 else 0)\n  \\<forall>i<2 ^ (k + 1).\n     \\<forall>j<2 ^ (k + 1).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n        rat_poly_times\n         (mat1 2 ! (j div length (mat1 (2 ^ k))) !\n          (i div rat_poly.row_length (mat1 (2 ^ k))))\n         (mat1 (2 ^ k) ! (j mod length (mat1 (2 ^ k))) !\n          (i mod rat_poly.row_length (mat1 (2 ^ k))))\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n       (if j div length (mat1 (2 ^ k)) =\n           i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n           j mod length (mat1 (2 ^ k)) =\n           i mod rat_poly.row_length (mat1 (2 ^ k))\n        then 1 else 0)", "by metis"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n     (if j div length (mat1 (2 ^ k)) =\n         i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n         j mod length (mat1 (2 ^ k)) =\n         i mod rat_poly.row_length (mat1 (2 ^ k))\n      then 1 else 0)\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "then"], ["proof (chain)\npicking this:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n     (if j div length (mat1 (2 ^ k)) =\n         i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n         j mod length (mat1 (2 ^ k)) =\n         i mod rat_poly.row_length (mat1 (2 ^ k))\n      then 1 else 0)", "have \"(\\<forall>i. \\<forall>j. (i <(2^(k+1))) \\<and> (j < (2^(k+1))) \\<longrightarrow>\n                ((rat_poly.Tensor (mat1 2)  (mat1 (2^k))!j!i)  = (if \n                         (((j div (2^k))) = (i div (2^k))\n                       \\<and>((j mod (2^k)) = (i mod (2^k))))\n                        then 1 \n                         else 0)))\""], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n     (if j div length (mat1 (2 ^ k)) =\n         i div rat_poly.row_length (mat1 (2 ^ k)) \\<and>\n         j mod length (mat1 (2 ^ k)) =\n         i mod rat_poly.row_length (mat1 (2 ^ k))\n      then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n       (if j div 2 ^ k = i div 2 ^ k \\<and> j mod 2 ^ k = i mod 2 ^ k then 1\n        else 0)", "by (metis (hide_lams, no_types) \"6\" \"7\")"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n     (if j div 2 ^ k = i div 2 ^ k \\<and> j mod 2 ^ k = i mod 2 ^ k then 1\n      else 0)\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "then"], ["proof (chain)\npicking this:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n     (if j div 2 ^ k = i div 2 ^ k \\<and> j mod 2 ^ k = i mod 2 ^ k then 1\n      else 0)", "have 20:\"(\\<forall>i. \\<forall>j. (i <(2^(k+1))) \\<and> (j < (2^(k+1))) \\<longrightarrow>\n                         ((rat_poly.Tensor (mat1 2)  (mat1 (2^k))!j!i)  = (if  (j = i)\n                                                                                then 1 \n                                                                                 else 0)))\""], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n     (if j div 2 ^ k = i div 2 ^ k \\<and> j mod 2 ^ k = i mod 2 ^ k then 1\n      else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = (if j = i then 1 else 0)", "using equal_div_mod2"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n     (if j div 2 ^ k = i div 2 ^ k \\<and> j mod 2 ^ k = i mod 2 ^ k then 1\n      else 0)\n  (?j div ?a = ?i div ?a \\<and> ?j mod ?a = ?i mod ?a) = (?j = ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = (if j = i then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = (if j = i then 1 else 0)\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "with 2"], ["proof (chain)\npicking this:\n  \\<forall>i<2 ^ (k + 1).\n     \\<forall>j<2 ^ (k + 1).\n        mat1 (2 ^ (k + 1)) ! i ! j = (if i = j then 1::?'a2 else (0::?'a2))\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = (if j = i then 1 else 0)", "have \"(\\<forall>i. \\<forall>j. (i <(2^(k+1))) \\<and> (j < (2^(k+1))) \\<longrightarrow>\n                      ((rat_poly.Tensor (mat1 2)  (mat1 (2^k))!j!i)  = (mat1 (2^(k+1)))!j!i))\""], ["proof (prove)\nusing this:\n  \\<forall>i<2 ^ (k + 1).\n     \\<forall>j<2 ^ (k + 1).\n        mat1 (2 ^ (k + 1)) ! i ! j = (if i = j then 1::?'a2 else (0::?'a2))\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = (if j = i then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n       (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = mat1 (2 ^ (k + 1)) ! j ! i", "by metis"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = mat1 (2 ^ (k + 1)) ! j ! i\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "then"], ["proof (chain)\npicking this:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = mat1 (2 ^ (k + 1)) ! j ! i", "have \"(\\<forall>i <(2^(k+1)).\\<forall>j < (2^(k+1)). \n         ((rat_poly.Tensor (mat1 2)  (mat1 (2^k))!j!i)  = (mat1 (2^(k+1)))!j!i))\""], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i < 2 ^ (k + 1) \\<and> j < 2 ^ (k + 1) \\<longrightarrow>\n     (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = mat1 (2 ^ (k + 1)) ! j ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<2 ^ (k + 1).\n       \\<forall>j<2 ^ (k + 1).\n          (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i =\n          mat1 (2 ^ (k + 1)) ! j ! i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<2 ^ (k + 1).\n     \\<forall>j<2 ^ (k + 1).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = mat1 (2 ^ (k + 1)) ! j ! i\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<2 ^ (k + 1).\n     \\<forall>j<2 ^ (k + 1).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = mat1 (2 ^ (k + 1)) ! j ! i\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "have \"mat (2^(k+1)) (2^(k+1)) (rat_poly.Tensor (mat1 2)  (mat1 (2^k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (2 ^ (k + 1)) (2 ^ (k + 1)) (mat1 2 \\<otimes> mat1 (2 ^ k))", "using  \\<open>make_vert_equiv (k + 1) = mat1 2 \\<otimes> mat1 (2 ^ k)\\<close>"], ["proof (prove)\nusing this:\n  make_vert_equiv (k + 1) = mat1 2 \\<otimes> mat1 (2 ^ k)\n\ngoal (1 subgoal):\n 1. mat (2 ^ (k + 1)) (2 ^ (k + 1)) (mat1 2 \\<otimes> mat1 (2 ^ k))", "by (metis prop_make_vert_equiv(1) prop_make_vert_equiv(2) \n                  prop_make_vert_equiv(3))"], ["proof (state)\nthis:\n  mat (2 ^ (k + 1)) (2 ^ (k + 1)) (mat1 2 \\<otimes> mat1 (2 ^ k))\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i<2 ^ (k + 1).\n     \\<forall>j<2 ^ (k + 1).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = mat1 (2 ^ (k + 1)) ! j ! i\n  mat (2 ^ (k + 1)) (2 ^ (k + 1)) (mat1 2 \\<otimes> mat1 (2 ^ k))", "have \"(rat_poly.Tensor (mat1 2)  (mat1 (2^k))) = (mat1 (2^(k+1)))\""], ["proof (prove)\nusing this:\n  \\<forall>i<2 ^ (k + 1).\n     \\<forall>j<2 ^ (k + 1).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = mat1 (2 ^ (k + 1)) ! j ! i\n  mat (2 ^ (k + 1)) (2 ^ (k + 1)) (mat1 2 \\<otimes> mat1 (2 ^ k))\n\ngoal (1 subgoal):\n 1. mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "using 1 mat_eqI"], ["proof (prove)\nusing this:\n  \\<forall>i<2 ^ (k + 1).\n     \\<forall>j<2 ^ (k + 1).\n        (mat1 2 \\<otimes> mat1 (2 ^ k)) ! j ! i = mat1 (2 ^ (k + 1)) ! j ! i\n  mat (2 ^ (k + 1)) (2 ^ (k + 1)) (mat1 2 \\<otimes> mat1 (2 ^ k))\n  mat (2 ^ (k + 1)) (2 ^ (k + 1)) (mat1 (2 ^ (k + 1)))\n  \\<lbrakk>mat ?nr ?nc ?m1.0; mat ?nr ?nc ?m2.0;\n   \\<And>i j.\n      \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n      \\<Longrightarrow> ?m1.0 ! i ! j = ?m2.0 ! i ! j\\<rbrakk>\n  \\<Longrightarrow> ?m1.0 = ?m2.0\n\ngoal (1 subgoal):\n 1. mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "by metis"], ["proof (state)\nthis:\n  mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))\n\ngoal (1 subgoal):\n 1. make_vert_equiv (k + 1) =\n    mat1 2 \\<otimes> mat1 (2 ^ k) \\<Longrightarrow>\n    mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "then"], ["proof (chain)\npicking this:\n  mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))\n\ngoal (1 subgoal):\n 1. mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "by auto"], ["proof (state)\nthis:\n  mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       make_vert_equiv n = mat1 (2 ^ n) \\<Longrightarrow>\n       make_vert_equiv (Suc n) = mat1 (2 ^ Suc n)", "then"], ["proof (chain)\npicking this:\n  mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))", "show ?case"], ["proof (prove)\nusing this:\n  mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))\n\ngoal (1 subgoal):\n 1. make_vert_equiv (Suc k) = mat1 (2 ^ Suc k)", "using make_vert_equiv.simps"], ["proof (prove)\nusing this:\n  mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))\n  make_vert_equiv 0 = [[1]]\n  make_vert_equiv (Suc ?k) = mat1 2 \\<otimes> make_vert_equiv ?k\n\ngoal (1 subgoal):\n 1. make_vert_equiv (Suc k) = mat1 (2 ^ Suc k)", "using  \\<open>make_vert_equiv (k + 1) = mat1 2 \\<otimes> mat1 (2 ^ k)\\<close>"], ["proof (prove)\nusing this:\n  mat1 2 \\<otimes> mat1 (2 ^ k) = mat1 (2 ^ (k + 1))\n  make_vert_equiv 0 = [[1]]\n  make_vert_equiv (Suc ?k) = mat1 2 \\<otimes> make_vert_equiv ?k\n  make_vert_equiv (k + 1) = mat1 2 \\<otimes> mat1 (2 ^ k)\n\ngoal (1 subgoal):\n 1. make_vert_equiv (Suc k) = mat1 (2 ^ Suc k)", "by (metis Suc_eq_plus1)"], ["proof (state)\nthis:\n  make_vert_equiv (Suc k) = mat1 (2 ^ Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem make_vert_block_map_blockmat:\n \"blockmat (make_vert_block n) = (mat1 (2^n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blockmat (make_vert_block n) = mat1 (2 ^ n)", "by (metis blockmat_make_vert make_vert_equiv_mat)"], ["", "lemma  mat1_rt_mult:assumes \"mat nr nc m1\"\n       shows \"rat_poly.matrix_mult m1 (mat1 (nc)) = m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (mat1 nc) = m1", "using assms  mat1_mult_right rat_poly.mat_empty_row_length \n        rat_poly.matrix_row_length \n        rat_poly.row_length_def rat_poly.unique_row_col(1)"], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat ?nr ?nc ?m \\<Longrightarrow> mat_mult ?nr ?m (mat1 ?nc) = ?m\n  \\<lbrakk>mat ?nr ?nc ?M; ?M = []\\<rbrakk> \\<Longrightarrow> mat 0 ?nc ?M\n  mat ?nr ?nc ?M \\<Longrightarrow>\n  mat (rat_poly.row_length ?M) (length ?M) ?M\n  rat_poly.row_length ?xs \\<equiv> if ?xs = [] then 0 else length (hd ?xs)\n  \\<lbrakk>mat ?nr1.0 ?nc1.0 ?M; mat ?nr2.0 ?nc2.0 ?M;\n   ?M \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?nr1.0 = ?nr2.0\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult m1 (mat1 nc) = m1", "by (metis)"], ["", "lemma mat1_vert_block: \n       \"rat_poly.matrix_mult \n                   (blockmat b) \n                   (blockmat (make_vert_block (nat (codomain_block b))))\n                           = (blockmat b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b)\n     (blockmat (make_vert_block (nat (codomain_block b)))) =\n    blockmat b", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b)\n     (blockmat (make_vert_block (nat (codomain_block b)))) =\n    blockmat b", "have \"mat \n          (rat_poly.row_length (blockmat b)) \n          (2^(nat (codomain_block b))) \n                            (blockmat b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat b)) (2 ^ nat (codomain_block b))\n     (blockmat b)", "using  length_codomain_block matrix_blockmat"], ["proof (prove)\nusing this:\n  length (blockmat ?ls) = 2 ^ nat (codomain_block ?ls)\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat b)) (2 ^ nat (codomain_block b))\n     (blockmat b)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat b)) (2 ^ nat (codomain_block b))\n   (blockmat b)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b)\n     (blockmat (make_vert_block (nat (codomain_block b)))) =\n    blockmat b", "moreover"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat b)) (2 ^ nat (codomain_block b))\n   (blockmat b)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b)\n     (blockmat (make_vert_block (nat (codomain_block b)))) =\n    blockmat b", "have \"(blockmat (make_vert_block (nat (codomain_block b))))\n                       = mat1 (2^(nat (codomain_block b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blockmat (make_vert_block (nat (codomain_block b))) =\n    mat1 (2 ^ nat (codomain_block b))", "using make_vert_block_map_blockmat"], ["proof (prove)\nusing this:\n  blockmat (make_vert_block ?n) = mat1 (2 ^ ?n)\n\ngoal (1 subgoal):\n 1. blockmat (make_vert_block (nat (codomain_block b))) =\n    mat1 (2 ^ nat (codomain_block b))", "by auto"], ["proof (state)\nthis:\n  blockmat (make_vert_block (nat (codomain_block b))) =\n  mat1 (2 ^ nat (codomain_block b))\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b)\n     (blockmat (make_vert_block (nat (codomain_block b)))) =\n    blockmat b", "ultimately"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (blockmat b)) (2 ^ nat (codomain_block b))\n   (blockmat b)\n  blockmat (make_vert_block (nat (codomain_block b))) =\n  mat1 (2 ^ nat (codomain_block b))", "show ?thesis"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat b)) (2 ^ nat (codomain_block b))\n   (blockmat b)\n  blockmat (make_vert_block (nat (codomain_block b))) =\n  mat1 (2 ^ nat (codomain_block b))\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b)\n     (blockmat (make_vert_block (nat (codomain_block b)))) =\n    blockmat b", "using mat1_rt_mult"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat b)) (2 ^ nat (codomain_block b))\n   (blockmat b)\n  blockmat (make_vert_block (nat (codomain_block b))) =\n  mat1 (2 ^ nat (codomain_block b))\n  mat ?nr ?nc ?m1.0 \\<Longrightarrow>\n  rat_poly.matrix_mult ?m1.0 (mat1 ?nc) = ?m1.0\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b)\n     (blockmat (make_vert_block (nat (codomain_block b)))) =\n    blockmat b", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat b)\n   (blockmat (make_vert_block (nat (codomain_block b)))) =\n  blockmat b\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The following list of theorems deal with distributivity properties\nof tensor product of matrices (with entries as rational functions) \n      and composition\\<close>"], ["", "definition weak_matrix_match::\n              \"rat_poly mat \\<Rightarrow> rat_poly mat \\<Rightarrow> rat_poly mat \\<Rightarrow> bool\"\nwhere\n\"weak_matrix_match A1 A2 B1 \\<equiv> (mat (rat_poly.row_length A1) (length A1) A1)\n   \\<and>(mat (rat_poly.row_length A2) (length A2) A2)\n   \\<and>(mat (rat_poly.row_length B1) 1 B1)\n\\<and>(A1 \\<noteq> [])\\<and>(A2 \\<noteq> [])\\<and>(B1 \\<noteq> [])\n  \\<and> (length A1 = rat_poly.row_length A2)\""], ["", "theorem weak_distributivity1:\n \"weak_matrix_match A1 A2 B1\n  \\<Longrightarrow> ((rat_poly.matrix_mult A1  A2)\\<otimes> B1) \n               = (rat_poly.matrix_mult (A1 \\<otimes> B1) (A2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "assume assms:\"weak_matrix_match A1 A2 B1\""], ["proof (state)\nthis:\n  weak_matrix_match A1 A2 B1\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "have 1:\"length B1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length B1 = 1", "using assms weak_matrix_match_def"], ["proof (prove)\nusing this:\n  weak_matrix_match A1 A2 B1\n  weak_matrix_match ?A1.0 ?A2.0 ?B1.0 \\<equiv>\n  mat (rat_poly.row_length ?A1.0) (length ?A1.0) ?A1.0 \\<and>\n  mat (rat_poly.row_length ?A2.0) (length ?A2.0) ?A2.0 \\<and>\n  mat (rat_poly.row_length ?B1.0) 1 ?B1.0 \\<and>\n  ?A1.0 \\<noteq> [] \\<and>\n  ?A2.0 \\<noteq> [] \\<and>\n  ?B1.0 \\<noteq> [] \\<and> length ?A1.0 = rat_poly.row_length ?A2.0\n\ngoal (1 subgoal):\n 1. length B1 = 1", "by (metis rat_poly.matrix_row_length rat_poly.unique_row_col(2))"], ["proof (state)\nthis:\n  length B1 = 1\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "have \"[[1]] \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[1::'a]] \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  [[1::?'a1]] \\<noteq> []\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "moreover"], ["proof (state)\nthis:\n  [[1::?'a1]] \\<noteq> []\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "have \"mat 1 1 [[1]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 1 [[1::'a]]", "unfolding mat_def Ball_def vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [[1::'a]] = 1 \\<and>\n    (\\<forall>x. x \\<in> set [[1::'a]] \\<longrightarrow> length x = 1)", "by auto"], ["proof (state)\nthis:\n  mat 1 1 [[1::?'a2]]\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "moreover"], ["proof (state)\nthis:\n  mat 1 1 [[1::?'a2]]\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "have \"rat_poly.row_length [[1]] = length B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length [[1]] = length B1", "unfolding rat_poly.row_length_def 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if [[1]] = [] then 0 else length (hd [[1]])) = 1", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length [[1]] = length B1\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "ultimately"], ["proof (chain)\npicking this:\n  [[1::?'a1]] \\<noteq> []\n  mat 1 1 [[1::?'a2]]\n  rat_poly.row_length [[1]] = length B1", "have \"rat_poly.matrix_match A1 A2 B1 [[1]]\""], ["proof (prove)\nusing this:\n  [[1::?'a1]] \\<noteq> []\n  mat 1 1 [[1::?'a2]]\n  rat_poly.row_length [[1]] = length B1\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_match A1 A2 B1 [[1]]", "unfolding rat_poly.matrix_match_def"], ["proof (prove)\nusing this:\n  [[1::?'a1]] \\<noteq> []\n  mat 1 1 [[1::?'a2]]\n  rat_poly.row_length [[1]] = length B1\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length A1) (length A1) A1 \\<and>\n    mat (rat_poly.row_length A2) (length A2) A2 \\<and>\n    mat (rat_poly.row_length B1) (length B1) B1 \\<and>\n    mat (rat_poly.row_length [[1]]) (length [[1]]) [[1]] \\<and>\n    length A1 = rat_poly.row_length A2 \\<and>\n    length B1 = rat_poly.row_length [[1]] \\<and>\n    A1 \\<noteq> [] \\<and>\n    A2 \\<noteq> [] \\<and> B1 \\<noteq> [] \\<and> [[1]] \\<noteq> []", "using assms weak_matrix_match_def \"1\" blockmat.simps(1)\n              matrix_blockmat"], ["proof (prove)\nusing this:\n  [[1::?'a1]] \\<noteq> []\n  mat 1 1 [[1::?'a2]]\n  rat_poly.row_length [[1]] = length B1\n  weak_matrix_match A1 A2 B1\n  weak_matrix_match ?A1.0 ?A2.0 ?B1.0 \\<equiv>\n  mat (rat_poly.row_length ?A1.0) (length ?A1.0) ?A1.0 \\<and>\n  mat (rat_poly.row_length ?A2.0) (length ?A2.0) ?A2.0 \\<and>\n  mat (rat_poly.row_length ?B1.0) 1 ?B1.0 \\<and>\n  ?A1.0 \\<noteq> [] \\<and>\n  ?A2.0 \\<noteq> [] \\<and>\n  ?B1.0 \\<noteq> [] \\<and> length ?A1.0 = rat_poly.row_length ?A2.0\n  length B1 = 1\n  blockmat [] = [[1]]\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length A1) (length A1) A1 \\<and>\n    mat (rat_poly.row_length A2) (length A2) A2 \\<and>\n    mat (rat_poly.row_length B1) (length B1) B1 \\<and>\n    mat (rat_poly.row_length [[1]]) (length [[1]]) [[1]] \\<and>\n    length A1 = rat_poly.row_length A2 \\<and>\n    length B1 = rat_poly.row_length [[1]] \\<and>\n    A1 \\<noteq> [] \\<and>\n    A2 \\<noteq> [] \\<and> B1 \\<noteq> [] \\<and> [[1]] \\<noteq> []", "by (metis (hide_lams, no_types))"], ["proof (state)\nthis:\n  rat_poly.matrix_match A1 A2 B1 [[1]]\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_match A1 A2 B1 [[1]]", "have \"((rat_poly.matrix_mult A1  A2)\\<otimes>(rat_poly.matrix_mult B1  [[1]])) \n               = (rat_poly.matrix_mult (A1 \\<otimes> B1) (A2 \\<otimes> [[1]]))\""], ["proof (prove)\nusing this:\n  rat_poly.matrix_match A1 A2 B1 [[1]]\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult A1 A2 \\<otimes> rat_poly.matrix_mult B1 [[1]] =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) (A2 \\<otimes> [[1]])", "using rat_poly.distributivity"], ["proof (prove)\nusing this:\n  rat_poly.matrix_match A1 A2 B1 [[1]]\n  rat_poly.matrix_match ?A1.0 ?A2.0 ?B1.0 ?B2.0 \\<Longrightarrow>\n  rat_poly.matrix_mult ?A1.0 ?A2.0 \\<otimes>\n  rat_poly.matrix_mult ?B1.0 ?B2.0 =\n  rat_poly.matrix_mult (?A1.0 \\<otimes> ?B1.0) (?A2.0 \\<otimes> ?B2.0)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult A1 A2 \\<otimes> rat_poly.matrix_mult B1 [[1]] =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) (A2 \\<otimes> [[1]])", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult A1 A2 \\<otimes> rat_poly.matrix_mult B1 [[1]] =\n  rat_poly.matrix_mult (A1 \\<otimes> B1) (A2 \\<otimes> [[1]])\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult A1 A2 \\<otimes> rat_poly.matrix_mult B1 [[1]] =\n  rat_poly.matrix_mult (A1 \\<otimes> B1) (A2 \\<otimes> [[1]])\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "have \"(rat_poly.matrix_mult B1  [[1]]) = B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult B1 [[1]] = B1", "using weak_matrix_match_def  assms mat1_equiv mat1_mult_right"], ["proof (prove)\nusing this:\n  weak_matrix_match ?A1.0 ?A2.0 ?B1.0 \\<equiv>\n  mat (rat_poly.row_length ?A1.0) (length ?A1.0) ?A1.0 \\<and>\n  mat (rat_poly.row_length ?A2.0) (length ?A2.0) ?A2.0 \\<and>\n  mat (rat_poly.row_length ?B1.0) 1 ?B1.0 \\<and>\n  ?A1.0 \\<noteq> [] \\<and>\n  ?A2.0 \\<noteq> [] \\<and>\n  ?B1.0 \\<noteq> [] \\<and> length ?A1.0 = rat_poly.row_length ?A2.0\n  weak_matrix_match A1 A2 B1\n  mat1 1 = [[1]]\n  mat ?nr ?nc ?m \\<Longrightarrow> mat_mult ?nr ?m (mat1 ?nc) = ?m\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult B1 [[1]] = B1", "by (metis)"], ["proof (state)\nthis:\n  rat_poly.matrix_mult B1 [[1]] = B1\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult B1 [[1]] = B1\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "have \"(A2 \\<otimes> [[1]]) = A2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A2 \\<otimes> [[1]] = A2", "using  rat_poly.Tensor_right_id"], ["proof (prove)\nusing this:\n  ?xs \\<otimes> [[1]] = ?xs\n\ngoal (1 subgoal):\n 1. A2 \\<otimes> [[1]] = A2", "by (metis)"], ["proof (state)\nthis:\n  A2 \\<otimes> [[1]] = A2\n\ngoal (1 subgoal):\n 1. weak_matrix_match A1 A2 B1 \\<Longrightarrow>\n    rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult A1 A2 \\<otimes> rat_poly.matrix_mult B1 [[1]] =\n  rat_poly.matrix_mult (A1 \\<otimes> B1) (A2 \\<otimes> [[1]])\n  rat_poly.matrix_mult B1 [[1]] = B1\n  A2 \\<otimes> [[1]] = A2", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult A1 A2 \\<otimes> rat_poly.matrix_mult B1 [[1]] =\n  rat_poly.matrix_mult (A1 \\<otimes> B1) (A2 \\<otimes> [[1]])\n  rat_poly.matrix_mult B1 [[1]] = B1\n  A2 \\<otimes> [[1]] = A2\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) A2", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult A1 A2 \\<otimes> B1 =\n  rat_poly.matrix_mult (A1 \\<otimes> B1) A2\n\ngoal:\nNo subgoals!", "qed"], ["", "definition weak_matrix_match2::\n     \"rat_poly mat \\<Rightarrow> rat_poly mat \\<Rightarrow> rat_poly mat \\<Rightarrow> bool\"\nwhere\n\"weak_matrix_match2 A1 B1 B2 \\<equiv> (mat (rat_poly.row_length A1) 1 A1)\n   \\<and>(mat (rat_poly.row_length B1) (length B1) B1)\n   \\<and>(mat (rat_poly.row_length B2) (length B2) B2)\n\\<and>(A1 \\<noteq> [])\\<and>(B1 \\<noteq> [])\\<and>(B2 \\<noteq> [])\n  \\<and> (length B1 = rat_poly.row_length B2)\""], ["", "theorem weak_distributivity2:\n\"weak_matrix_match2 A1 B1 B2\n     \\<Longrightarrow> (A1\\<otimes> (rat_poly.matrix_mult B1 B2)) \n                                  = (rat_poly.matrix_mult (A1 \\<otimes> B1) (B2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "assume assms:\"weak_matrix_match2 A1 B1 B2\""], ["proof (state)\nthis:\n  weak_matrix_match2 A1 B1 B2\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "have 1:\"length A1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length A1 = 1", "using assms weak_matrix_match2_def"], ["proof (prove)\nusing this:\n  weak_matrix_match2 A1 B1 B2\n  weak_matrix_match2 ?A1.0 ?B1.0 ?B2.0 \\<equiv>\n  mat (rat_poly.row_length ?A1.0) 1 ?A1.0 \\<and>\n  mat (rat_poly.row_length ?B1.0) (length ?B1.0) ?B1.0 \\<and>\n  mat (rat_poly.row_length ?B2.0) (length ?B2.0) ?B2.0 \\<and>\n  ?A1.0 \\<noteq> [] \\<and>\n  ?B1.0 \\<noteq> [] \\<and>\n  ?B2.0 \\<noteq> [] \\<and> length ?B1.0 = rat_poly.row_length ?B2.0\n\ngoal (1 subgoal):\n 1. length A1 = 1", "by (metis rat_poly.matrix_row_length rat_poly.unique_row_col(2))"], ["proof (state)\nthis:\n  length A1 = 1\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "have \"[[1]] \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[1::'a]] \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  [[1::?'a1]] \\<noteq> []\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "moreover"], ["proof (state)\nthis:\n  [[1::?'a1]] \\<noteq> []\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "have \"mat 1 1 [[1]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 1 [[1::'a]]", "unfolding mat_def Ball_def vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [[1::'a]] = 1 \\<and>\n    (\\<forall>x. x \\<in> set [[1::'a]] \\<longrightarrow> length x = 1)", "by auto"], ["proof (state)\nthis:\n  mat 1 1 [[1::?'a2]]\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "moreover"], ["proof (state)\nthis:\n  mat 1 1 [[1::?'a2]]\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "have \"rat_poly.row_length [[1]] = length A1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.row_length [[1]] = length A1", "unfolding rat_poly.row_length_def 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if [[1]] = [] then 0 else length (hd [[1]])) = 1", "by auto"], ["proof (state)\nthis:\n  rat_poly.row_length [[1]] = length A1\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "ultimately"], ["proof (chain)\npicking this:\n  [[1::?'a1]] \\<noteq> []\n  mat 1 1 [[1::?'a2]]\n  rat_poly.row_length [[1]] = length A1", "have \"rat_poly.matrix_match A1 [[1]] B1 B2\""], ["proof (prove)\nusing this:\n  [[1::?'a1]] \\<noteq> []\n  mat 1 1 [[1::?'a2]]\n  rat_poly.row_length [[1]] = length A1\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_match A1 [[1]] B1 B2", "unfolding rat_poly.matrix_match_def"], ["proof (prove)\nusing this:\n  [[1::?'a1]] \\<noteq> []\n  mat 1 1 [[1::?'a2]]\n  rat_poly.row_length [[1]] = length A1\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length A1) (length A1) A1 \\<and>\n    mat (rat_poly.row_length [[1]]) (length [[1]]) [[1]] \\<and>\n    mat (rat_poly.row_length B1) (length B1) B1 \\<and>\n    mat (rat_poly.row_length B2) (length B2) B2 \\<and>\n    length A1 = rat_poly.row_length [[1]] \\<and>\n    length B1 = rat_poly.row_length B2 \\<and>\n    A1 \\<noteq> [] \\<and>\n    [[1]] \\<noteq> [] \\<and> B1 \\<noteq> [] \\<and> B2 \\<noteq> []", "using assms weak_matrix_match2_def  \n             \"1\" blockmat.simps(1) matrix_blockmat"], ["proof (prove)\nusing this:\n  [[1::?'a1]] \\<noteq> []\n  mat 1 1 [[1::?'a2]]\n  rat_poly.row_length [[1]] = length A1\n  weak_matrix_match2 A1 B1 B2\n  weak_matrix_match2 ?A1.0 ?B1.0 ?B2.0 \\<equiv>\n  mat (rat_poly.row_length ?A1.0) 1 ?A1.0 \\<and>\n  mat (rat_poly.row_length ?B1.0) (length ?B1.0) ?B1.0 \\<and>\n  mat (rat_poly.row_length ?B2.0) (length ?B2.0) ?B2.0 \\<and>\n  ?A1.0 \\<noteq> [] \\<and>\n  ?B1.0 \\<noteq> [] \\<and>\n  ?B2.0 \\<noteq> [] \\<and> length ?B1.0 = rat_poly.row_length ?B2.0\n  length A1 = 1\n  blockmat [] = [[1]]\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length A1) (length A1) A1 \\<and>\n    mat (rat_poly.row_length [[1]]) (length [[1]]) [[1]] \\<and>\n    mat (rat_poly.row_length B1) (length B1) B1 \\<and>\n    mat (rat_poly.row_length B2) (length B2) B2 \\<and>\n    length A1 = rat_poly.row_length [[1]] \\<and>\n    length B1 = rat_poly.row_length B2 \\<and>\n    A1 \\<noteq> [] \\<and>\n    [[1]] \\<noteq> [] \\<and> B1 \\<noteq> [] \\<and> B2 \\<noteq> []", "by (metis (hide_lams, no_types))"], ["proof (state)\nthis:\n  rat_poly.matrix_match A1 [[1]] B1 B2\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_match A1 [[1]] B1 B2", "have \"((rat_poly.matrix_mult A1  [[1]])\\<otimes>(rat_poly.matrix_mult B1 B2)) \n               = (rat_poly.matrix_mult (A1 \\<otimes> B1) ([[1]] \\<otimes> B2))\""], ["proof (prove)\nusing this:\n  rat_poly.matrix_match A1 [[1]] B1 B2\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult A1 [[1]] \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) ([[1]] \\<otimes> B2)", "using rat_poly.distributivity"], ["proof (prove)\nusing this:\n  rat_poly.matrix_match A1 [[1]] B1 B2\n  rat_poly.matrix_match ?A1.0 ?A2.0 ?B1.0 ?B2.0 \\<Longrightarrow>\n  rat_poly.matrix_mult ?A1.0 ?A2.0 \\<otimes>\n  rat_poly.matrix_mult ?B1.0 ?B2.0 =\n  rat_poly.matrix_mult (?A1.0 \\<otimes> ?B1.0) (?A2.0 \\<otimes> ?B2.0)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult A1 [[1]] \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) ([[1]] \\<otimes> B2)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult A1 [[1]] \\<otimes> rat_poly.matrix_mult B1 B2 =\n  rat_poly.matrix_mult (A1 \\<otimes> B1) ([[1]] \\<otimes> B2)\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult A1 [[1]] \\<otimes> rat_poly.matrix_mult B1 B2 =\n  rat_poly.matrix_mult (A1 \\<otimes> B1) ([[1]] \\<otimes> B2)\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "have \"(rat_poly.matrix_mult A1  [[1]]) = A1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult A1 [[1]] = A1", "using weak_matrix_match2_def\n              assms mat1_equiv mat1_mult_right"], ["proof (prove)\nusing this:\n  weak_matrix_match2 ?A1.0 ?B1.0 ?B2.0 \\<equiv>\n  mat (rat_poly.row_length ?A1.0) 1 ?A1.0 \\<and>\n  mat (rat_poly.row_length ?B1.0) (length ?B1.0) ?B1.0 \\<and>\n  mat (rat_poly.row_length ?B2.0) (length ?B2.0) ?B2.0 \\<and>\n  ?A1.0 \\<noteq> [] \\<and>\n  ?B1.0 \\<noteq> [] \\<and>\n  ?B2.0 \\<noteq> [] \\<and> length ?B1.0 = rat_poly.row_length ?B2.0\n  weak_matrix_match2 A1 B1 B2\n  mat1 1 = [[1]]\n  mat ?nr ?nc ?m \\<Longrightarrow> mat_mult ?nr ?m (mat1 ?nc) = ?m\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult A1 [[1]] = A1", "by (metis)"], ["proof (state)\nthis:\n  rat_poly.matrix_mult A1 [[1]] = A1\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult A1 [[1]] = A1\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "have \"([[1]] \\<otimes> B2) = B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[1]] \\<otimes> B2 = B2", "by (metis rat_poly.Tensor_left_id)"], ["proof (state)\nthis:\n  [[1]] \\<otimes> B2 = B2\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 A1 B1 B2 \\<Longrightarrow>\n    A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult A1 [[1]] \\<otimes> rat_poly.matrix_mult B1 B2 =\n  rat_poly.matrix_mult (A1 \\<otimes> B1) ([[1]] \\<otimes> B2)\n  rat_poly.matrix_mult A1 [[1]] = A1\n  [[1]] \\<otimes> B2 = B2", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult A1 [[1]] \\<otimes> rat_poly.matrix_mult B1 B2 =\n  rat_poly.matrix_mult (A1 \\<otimes> B1) ([[1]] \\<otimes> B2)\n  rat_poly.matrix_mult A1 [[1]] = A1\n  [[1]] \\<otimes> B2 = B2\n\ngoal (1 subgoal):\n 1. A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n    rat_poly.matrix_mult (A1 \\<otimes> B1) B2", "by auto"], ["proof (state)\nthis:\n  A1 \\<otimes> rat_poly.matrix_mult B1 B2 =\n  rat_poly.matrix_mult (A1 \\<otimes> B1) B2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_tangle_diagram_weak_matrix_match:\n assumes \"is_tangle_diagram (w1*ws1)\"\n      and \"codomain_block w2 = 0\"\n shows \"weak_matrix_match (blockmat w1) (kauff_mat ws1) (blockmat w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_matrix_match (blockmat w1) (kauff_mat ws1) (blockmat w2)", "unfolding weak_matrix_match_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1) \\<and>\n    mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1) \\<and>\n    mat (rat_poly.row_length (blockmat w2)) 1 (blockmat w2) \\<and>\n    blockmat w1 \\<noteq> [] \\<and>\n    kauff_mat ws1 \\<noteq> [] \\<and>\n    blockmat w2 \\<noteq> [] \\<and>\n    length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "apply(auto)"], ["proof (prove)\ngoal (7 subgoals):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1)\n 2. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)\n 3. mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)\n 4. blockmat w1 = [] \\<Longrightarrow> False\n 5. kauff_mat ws1 = [] \\<Longrightarrow> False\n 6. blockmat w2 = [] \\<Longrightarrow> False\n 7. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "proof-"], ["proof (state)\ngoal (7 subgoals):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1)\n 2. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)\n 3. mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)\n 4. blockmat w1 = [] \\<Longrightarrow> False\n 5. kauff_mat ws1 = [] \\<Longrightarrow> False\n 6. blockmat w2 = [] \\<Longrightarrow> False\n 7. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "show \"mat \n          (rat_poly.row_length (blockmat w1)) \n          (length (blockmat w1)) \n                         (blockmat w1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1)", "using matrix_blockmat"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n   (blockmat w1)\n\ngoal (6 subgoals):\n 1. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)\n 2. mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)\n 3. blockmat w1 = [] \\<Longrightarrow> False\n 4. kauff_mat ws1 = [] \\<Longrightarrow> False\n 5. blockmat w2 = [] \\<Longrightarrow> False\n 6. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)\n 2. mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)\n 3. blockmat w1 = [] \\<Longrightarrow> False\n 4. kauff_mat ws1 = [] \\<Longrightarrow> False\n 5. blockmat w2 = [] \\<Longrightarrow> False\n 6. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "have \"is_tangle_diagram ws1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1", "using assms(1) is_tangle_diagram.simps(2)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w1 * ws1)\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram ws1\n\ngoal (6 subgoals):\n 1. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)\n 2. mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)\n 3. blockmat w1 = [] \\<Longrightarrow> False\n 4. kauff_mat ws1 = [] \\<Longrightarrow> False\n 5. blockmat w2 = [] \\<Longrightarrow> False\n 6. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram ws1", "show \"mat \n                (rat_poly.row_length (kauff_mat ws1)) \n                (length (kauff_mat ws1)) \n                           (kauff_mat ws1)\""], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)", "using matrix_kauff_mat"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws) \\<and>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws) \\<and>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n     (kauff_mat ws1)", "by metis"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (kauff_mat ws1)) (length (kauff_mat ws1))\n   (kauff_mat ws1)\n\ngoal (5 subgoals):\n 1. mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)\n 2. blockmat w1 = [] \\<Longrightarrow> False\n 3. kauff_mat ws1 = [] \\<Longrightarrow> False\n 4. blockmat w2 = [] \\<Longrightarrow> False\n 5. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)\n 2. blockmat w1 = [] \\<Longrightarrow> False\n 3. kauff_mat ws1 = [] \\<Longrightarrow> False\n 4. blockmat w2 = [] \\<Longrightarrow> False\n 5. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "have \"mat \n           (rat_poly.row_length (blockmat w2)) \n           (length (blockmat w2)) \n                          (blockmat w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)", "using matrix_blockmat"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n   (blockmat w2)\n\ngoal (5 subgoals):\n 1. mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)\n 2. blockmat w1 = [] \\<Longrightarrow> False\n 3. kauff_mat ws1 = [] \\<Longrightarrow> False\n 4. blockmat w2 = [] \\<Longrightarrow> False\n 5. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "then"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n   (blockmat w2)", "have \"mat \n                (rat_poly.row_length (blockmat w2)) 1 (blockmat w2)\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n   (blockmat w2)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w2)) 1 (blockmat w2)", "using assms(2) length_codomain_block"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n   (blockmat w2)\n  codomain_block w2 = 0\n  length (blockmat ?ls) = 2 ^ nat (codomain_block ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w2)) 1 (blockmat w2)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w2)) 1 (blockmat w2)\n\ngoal (5 subgoals):\n 1. mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)\n 2. blockmat w1 = [] \\<Longrightarrow> False\n 3. kauff_mat ws1 = [] \\<Longrightarrow> False\n 4. blockmat w2 = [] \\<Longrightarrow> False\n 5. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "then"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (blockmat w2)) 1 (blockmat w2)", "show \"mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w2)) 1 (blockmat w2)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w2)) (Suc 0) (blockmat w2)\n\ngoal (4 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. kauff_mat ws1 = [] \\<Longrightarrow> False\n 3. blockmat w2 = [] \\<Longrightarrow> False\n 4. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. kauff_mat ws1 = [] \\<Longrightarrow> False\n 3. blockmat w2 = [] \\<Longrightarrow> False\n 4. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "show \"length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "using is_tangle_diagram_length_rowlength assms(1)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (?w * ?ws) \\<Longrightarrow>\n  length (blockmat ?w) = rat_poly.row_length (kauff_mat ?ws)\n  is_tangle_diagram (w1 * ws1)\n\ngoal (1 subgoal):\n 1. length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)", "by auto"], ["proof (state)\nthis:\n  length (blockmat w1) = rat_poly.row_length (kauff_mat ws1)\n\ngoal (3 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. kauff_mat ws1 = [] \\<Longrightarrow> False\n 3. blockmat w2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. kauff_mat ws1 = [] \\<Longrightarrow> False\n 3. blockmat w2 = [] \\<Longrightarrow> False", "assume 0:\"blockmat w1 = [] \""], ["proof (state)\nthis:\n  blockmat w1 = []\n\ngoal (3 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. kauff_mat ws1 = [] \\<Longrightarrow> False\n 3. blockmat w2 = [] \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using 0"], ["proof (prove)\nusing this:\n  blockmat w1 = []\n\ngoal (1 subgoal):\n 1. False", "by (metis blockmat_non_empty)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. kauff_mat ws1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. kauff_mat ws1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False", "assume 1:\"kauff_mat ws1 = [] \""], ["proof (state)\nthis:\n  kauff_mat ws1 = []\n\ngoal (2 subgoals):\n 1. kauff_mat ws1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False", "have \"is_tangle_diagram ws1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1", "using assms(1) is_tangle_diagram.simps(2)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w1 * ws1)\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram ws1\n\ngoal (2 subgoals):\n 1. kauff_mat ws1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram ws1", "show False"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1\n\ngoal (1 subgoal):\n 1. False", "using 1 kauff_mat_non_empty"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws1\n  kauff_mat ws1 = []\n  is_tangle_diagram ?ws \\<Longrightarrow> kauff_mat ?ws \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. blockmat w2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. blockmat w2 = [] \\<Longrightarrow> False", "assume 0:\"blockmat w2 = [] \""], ["proof (state)\nthis:\n  blockmat w2 = []\n\ngoal (1 subgoal):\n 1. blockmat w2 = [] \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using 0"], ["proof (prove)\nusing this:\n  blockmat w2 = []\n\ngoal (1 subgoal):\n 1. False", "by (metis blockmat_non_empty)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_tangle_diagram_weak_matrix_match2:\n assumes \"is_tangle_diagram (w2*ws2)\"\n      and \"codomain_block w1 = 0\"\n shows \"weak_matrix_match2 (blockmat w1) (blockmat w2) (kauff_mat ws2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_matrix_match2 (blockmat w1) (blockmat w2) (kauff_mat ws2)", "unfolding weak_matrix_match2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) 1 (blockmat w1) \\<and>\n    mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2) \\<and>\n    mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2) \\<and>\n    blockmat w1 \\<noteq> [] \\<and>\n    blockmat w2 \\<noteq> [] \\<and>\n    kauff_mat ws2 \\<noteq> [] \\<and>\n    length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "apply(auto)"], ["proof (prove)\ngoal (7 subgoals):\n 1. mat (rat_poly.row_length (blockmat w1)) (Suc 0) (blockmat w1)\n 2. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 3. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 4. blockmat w1 = [] \\<Longrightarrow> False\n 5. blockmat w2 = [] \\<Longrightarrow> False\n 6. kauff_mat ws2 = [] \\<Longrightarrow> False\n 7. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "proof-"], ["proof (state)\ngoal (7 subgoals):\n 1. mat (rat_poly.row_length (blockmat w1)) (Suc 0) (blockmat w1)\n 2. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 3. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 4. blockmat w1 = [] \\<Longrightarrow> False\n 5. blockmat w2 = [] \\<Longrightarrow> False\n 6. kauff_mat ws2 = [] \\<Longrightarrow> False\n 7. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "have \"mat \n            (rat_poly.row_length (blockmat w1)) \n            (length (blockmat w1)) \n                           (blockmat w1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1)", "using matrix_blockmat"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat ?ls)) (length (blockmat ?ls))\n   (blockmat ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n     (blockmat w1)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n   (blockmat w1)\n\ngoal (7 subgoals):\n 1. mat (rat_poly.row_length (blockmat w1)) (Suc 0) (blockmat w1)\n 2. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 3. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 4. blockmat w1 = [] \\<Longrightarrow> False\n 5. blockmat w2 = [] \\<Longrightarrow> False\n 6. kauff_mat ws2 = [] \\<Longrightarrow> False\n 7. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "then"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n   (blockmat w1)", "have \"mat \n                 (rat_poly.row_length (blockmat w1)) 1 (blockmat w1)\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n   (blockmat w1)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) 1 (blockmat w1)", "using assms(2) length_codomain_block"], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w1)) (length (blockmat w1))\n   (blockmat w1)\n  codomain_block w1 = 0\n  length (blockmat ?ls) = 2 ^ nat (codomain_block ?ls)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) 1 (blockmat w1)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w1)) 1 (blockmat w1)\n\ngoal (7 subgoals):\n 1. mat (rat_poly.row_length (blockmat w1)) (Suc 0) (blockmat w1)\n 2. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 3. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 4. blockmat w1 = [] \\<Longrightarrow> False\n 5. blockmat w2 = [] \\<Longrightarrow> False\n 6. kauff_mat ws2 = [] \\<Longrightarrow> False\n 7. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "then"], ["proof (chain)\npicking this:\n  mat (rat_poly.row_length (blockmat w1)) 1 (blockmat w1)", "show \"mat (rat_poly.row_length (blockmat w1)) (Suc 0) (blockmat w1)\""], ["proof (prove)\nusing this:\n  mat (rat_poly.row_length (blockmat w1)) 1 (blockmat w1)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w1)) (Suc 0) (blockmat w1)", "by auto"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w1)) (Suc 0) (blockmat w1)\n\ngoal (6 subgoals):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 2. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 3. blockmat w1 = [] \\<Longrightarrow> False\n 4. blockmat w2 = [] \\<Longrightarrow> False\n 5. kauff_mat ws2 = [] \\<Longrightarrow> False\n 6. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 2. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 3. blockmat w1 = [] \\<Longrightarrow> False\n 4. blockmat w2 = [] \\<Longrightarrow> False\n 5. kauff_mat ws2 = [] \\<Longrightarrow> False\n 6. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "have \"is_tangle_diagram ws2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws2", "using assms(1) is_tangle_diagram.simps(2)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w2 * ws2)\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram ws2", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram ws2\n\ngoal (6 subgoals):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 2. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)\n 3. blockmat w1 = [] \\<Longrightarrow> False\n 4. blockmat w2 = [] \\<Longrightarrow> False\n 5. kauff_mat ws2 = [] \\<Longrightarrow> False\n 6. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram ws2", "show \"mat \n                (rat_poly.row_length (kauff_mat ws2)) \n                (length (kauff_mat ws2)) \n                               (kauff_mat ws2)\""], ["proof (prove)\nusing this:\n  is_tangle_diagram ws2\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)", "using matrix_kauff_mat"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws2\n  is_tangle_diagram ?ws \\<Longrightarrow>\n  rat_poly.row_length (kauff_mat ?ws) = 2 ^ nat (domain_wall ?ws) \\<and>\n  length (kauff_mat ?ws) = 2 ^ nat (codomain_wall ?ws) \\<and>\n  mat (rat_poly.row_length (kauff_mat ?ws)) (length (kauff_mat ?ws))\n   (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n     (kauff_mat ws2)", "by metis"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (kauff_mat ws2)) (length (kauff_mat ws2))\n   (kauff_mat ws2)\n\ngoal (5 subgoals):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 2. blockmat w1 = [] \\<Longrightarrow> False\n 3. blockmat w2 = [] \\<Longrightarrow> False\n 4. kauff_mat ws2 = [] \\<Longrightarrow> False\n 5. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)\n 2. blockmat w1 = [] \\<Longrightarrow> False\n 3. blockmat w2 = [] \\<Longrightarrow> False\n 4. kauff_mat ws2 = [] \\<Longrightarrow> False\n 5. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "show \"mat \n           (rat_poly.row_length (blockmat w2)) \n           (length (blockmat w2)) \n                           (blockmat w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n     (blockmat w2)", "by (metis matrix_blockmat)"], ["proof (state)\nthis:\n  mat (rat_poly.row_length (blockmat w2)) (length (blockmat w2))\n   (blockmat w2)\n\ngoal (4 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False\n 3. kauff_mat ws2 = [] \\<Longrightarrow> False\n 4. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False\n 3. kauff_mat ws2 = [] \\<Longrightarrow> False\n 4. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "show \"length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "using is_tangle_diagram_length_rowlength assms(1)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (?w * ?ws) \\<Longrightarrow>\n  length (blockmat ?w) = rat_poly.row_length (kauff_mat ?ws)\n  is_tangle_diagram (w2 * ws2)\n\ngoal (1 subgoal):\n 1. length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)", "by auto"], ["proof (state)\nthis:\n  length (blockmat w2) = rat_poly.row_length (kauff_mat ws2)\n\ngoal (3 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False\n 3. kauff_mat ws2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False\n 3. kauff_mat ws2 = [] \\<Longrightarrow> False", "assume 0:\"blockmat w1 = [] \""], ["proof (state)\nthis:\n  blockmat w1 = []\n\ngoal (3 subgoals):\n 1. blockmat w1 = [] \\<Longrightarrow> False\n 2. blockmat w2 = [] \\<Longrightarrow> False\n 3. kauff_mat ws2 = [] \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using 0"], ["proof (prove)\nusing this:\n  blockmat w1 = []\n\ngoal (1 subgoal):\n 1. False", "by (metis blockmat_non_empty)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. blockmat w2 = [] \\<Longrightarrow> False\n 2. kauff_mat ws2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. blockmat w2 = [] \\<Longrightarrow> False\n 2. kauff_mat ws2 = [] \\<Longrightarrow> False", "assume 1:\"kauff_mat ws2 = [] \""], ["proof (state)\nthis:\n  kauff_mat ws2 = []\n\ngoal (2 subgoals):\n 1. blockmat w2 = [] \\<Longrightarrow> False\n 2. kauff_mat ws2 = [] \\<Longrightarrow> False", "have \"is_tangle_diagram ws2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws2", "using assms(1) is_tangle_diagram.simps(2)"], ["proof (prove)\nusing this:\n  is_tangle_diagram (w2 * ws2)\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram ws2", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram ws2\n\ngoal (2 subgoals):\n 1. blockmat w2 = [] \\<Longrightarrow> False\n 2. kauff_mat ws2 = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram ws2", "show False"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws2\n\ngoal (1 subgoal):\n 1. False", "using 1 kauff_mat_non_empty"], ["proof (prove)\nusing this:\n  is_tangle_diagram ws2\n  kauff_mat ws2 = []\n  is_tangle_diagram ?ws \\<Longrightarrow> kauff_mat ?ws \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. blockmat w2 = [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. blockmat w2 = [] \\<Longrightarrow> False", "assume 0:\"blockmat w2 = [] \""], ["proof (state)\nthis:\n  blockmat w2 = []\n\ngoal (1 subgoal):\n 1. blockmat w2 = [] \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using 0"], ["proof (prove)\nusing this:\n  blockmat w2 = []\n\ngoal (1 subgoal):\n 1. False", "by (metis blockmat_non_empty)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_tangle_diagram_vert_block:\n  \"is_tangle_diagram (b*(basic (make_vert_block (nat (codomain_block b)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram (b * basic (make_vert_block (nat (codomain_block b))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_tangle_diagram (b * basic (make_vert_block (nat (codomain_block b))))", "have \"domain_wall (basic (make_vert_block (nat (codomain_block b))))\n                = (codomain_block b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain_wall (basic (make_vert_block (nat (codomain_block b)))) =\n    codomain_block b", "using domain_wall.simps make_vert_block.simps"], ["proof (prove)\nusing this:\n  domain_wall (basic ?x) = domain_block ?x\n  domain_wall (?x * ?ys) = domain_block ?x\n  make_vert_block 0 = []\n  make_vert_block (Suc ?n) = vert # make_vert_block ?n\n\ngoal (1 subgoal):\n 1. domain_wall (basic (make_vert_block (nat (codomain_block b)))) =\n    codomain_block b", "by (metis codomain_block_nonnegative domain_make_vert int_nat_eq)"], ["proof (state)\nthis:\n  domain_wall (basic (make_vert_block (nat (codomain_block b)))) =\n  codomain_block b\n\ngoal (1 subgoal):\n 1. is_tangle_diagram (b * basic (make_vert_block (nat (codomain_block b))))", "then"], ["proof (chain)\npicking this:\n  domain_wall (basic (make_vert_block (nat (codomain_block b)))) =\n  codomain_block b", "show ?thesis"], ["proof (prove)\nusing this:\n  domain_wall (basic (make_vert_block (nat (codomain_block b)))) =\n  codomain_block b\n\ngoal (1 subgoal):\n 1. is_tangle_diagram (b * basic (make_vert_block (nat (codomain_block b))))", "using is_tangle_diagram.simps"], ["proof (prove)\nusing this:\n  domain_wall (basic (make_vert_block (nat (codomain_block b)))) =\n  codomain_block b\n  is_tangle_diagram (basic ?x) = True\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram (b * basic (make_vert_block (nat (codomain_block b))))", "by auto"], ["proof (state)\nthis:\n  is_tangle_diagram (b * basic (make_vert_block (nat (codomain_block b))))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The following theorem tells us that the the map kauff$\\_$mat when \n restricted to walls representing tangles preserves the tensor product\\<close>"], ["", "theorem Tensor_Invariance:\n \"(is_tangle_diagram ws1) \\<and> (is_tangle_diagram ws2)\n \\<Longrightarrow> (kauff_mat (ws1 \\<otimes> ws2) = (kauff_mat ws1) \\<otimes> (kauff_mat ws2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram ws1 \\<and> is_tangle_diagram ws2 \\<Longrightarrow>\n    kauff_mat (ws1 \\<otimes> ws2) = kauff_mat ws1 \\<otimes> kauff_mat ws2", "proof(induction rule:tensor.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       is_tangle_diagram (basic x) \\<and>\n       is_tangle_diagram (basic y) \\<Longrightarrow>\n       kauff_mat (basic x \\<otimes> basic y) =\n       kauff_mat (basic x) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 4. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "case 1"], ["proof (state)\nthis:\n  is_tangle_diagram (basic x_) \\<and> is_tangle_diagram (basic y_)\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       is_tangle_diagram (basic x) \\<and>\n       is_tangle_diagram (basic y) \\<Longrightarrow>\n       kauff_mat (basic x \\<otimes> basic y) =\n       kauff_mat (basic x) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 3. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 4. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat (basic x_ \\<otimes> basic y_) =\n    kauff_mat (basic x_) \\<otimes> kauff_mat (basic y_)", "using kauff_mat_tensor_distrib"], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     kauff_mat (basic xs \\<otimes> basic ys) =\n     kauff_mat (basic xs) \\<otimes> kauff_mat (basic ys)\n\ngoal (1 subgoal):\n 1. kauff_mat (basic x_ \\<otimes> basic y_) =\n    kauff_mat (basic x_) \\<otimes> kauff_mat (basic y_)", "by auto"], ["proof (state)\nthis:\n  kauff_mat (basic x_ \\<otimes> basic y_) =\n  kauff_mat (basic x_) \\<otimes> kauff_mat (basic y_)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "fix a b as bs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "assume hyps:\"  is_tangle_diagram as \\<and> is_tangle_diagram bs \n                \\<Longrightarrow> (kauff_mat (as \\<otimes> bs) = kauff_mat as \\<otimes> kauff_mat bs)\""], ["proof (state)\nthis:\n  is_tangle_diagram as \\<and> is_tangle_diagram bs \\<Longrightarrow>\n  kauff_mat (as \\<otimes> bs) = kauff_mat as \\<otimes> kauff_mat bs\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "assume prems:\" is_tangle_diagram (a*as) \\<and> is_tangle_diagram (b*bs) \""], ["proof (state)\nthis:\n  is_tangle_diagram (a * as) \\<and> is_tangle_diagram (b * bs)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "let ?case =  \"kauff_mat (a * as \\<otimes> b * bs) \n                         = kauff_mat (a * as) \\<otimes> kauff_mat (b * bs)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "have 0:\"rat_poly.matrix_match \n                         (blockmat a) \n                         (kauff_mat as) \n                         (blockmat b) \n                         (kauff_mat bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_match (blockmat a) (kauff_mat as) (blockmat b)\n     (kauff_mat bs)", "using prems is_tangle_diagram_matrix_match"], ["proof (prove)\nusing this:\n  is_tangle_diagram (a * as) \\<and> is_tangle_diagram (b * bs)\n  \\<lbrakk>is_tangle_diagram (?w1.0 * ?ws1.0);\n   is_tangle_diagram (?w2.0 * ?ws2.0)\\<rbrakk>\n  \\<Longrightarrow> rat_poly.matrix_match (blockmat ?w1.0)\n                     (kauff_mat ?ws1.0) (blockmat ?w2.0) (kauff_mat ?ws2.0)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_match (blockmat a) (kauff_mat as) (blockmat b)\n     (kauff_mat bs)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_match (blockmat a) (kauff_mat as) (blockmat b)\n   (kauff_mat bs)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "have 1:\"is_tangle_diagram as \\<and> is_tangle_diagram bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram as \\<and> is_tangle_diagram bs", "using prems is_tangle_diagram.simps"], ["proof (prove)\nusing this:\n  is_tangle_diagram (a * as) \\<and> is_tangle_diagram (b * bs)\n  is_tangle_diagram (basic ?x) = True\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram as \\<and> is_tangle_diagram bs", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram as \\<and> is_tangle_diagram bs\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "have \"kauff_mat ((a * as) \\<otimes> (b * bs)) \n                          = kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat (a * as \\<otimes> b * bs) =\n    kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs))", "using tensor.simps"], ["proof (prove)\nusing this:\n  basic ?x \\<otimes> basic ?y = basic (?x \\<otimes> ?y)\n  ?x * ?xs \\<otimes> basic ?y =\n  (if codomain_block ?y = 0 then (?x \\<otimes> ?y) * ?xs\n   else (?x \\<otimes> ?y) *\n        (?xs \\<otimes> basic (make_vert_block (nat (codomain_block ?y)))))\n  basic ?x \\<otimes> ?y * ?ys =\n  (if codomain_block ?x = 0 then (?x \\<otimes> ?y) * ?ys\n   else (?x \\<otimes> ?y) *\n        (basic (make_vert_block (nat (codomain_block ?x))) \\<otimes> ?ys))\n  ?x * ?xs \\<otimes> ?y * ?ys = (?x \\<otimes> ?y) * (?xs \\<otimes> ?ys)\n\ngoal (1 subgoal):\n 1. kauff_mat (a * as \\<otimes> b * bs) =\n    kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs))", "by auto"], ["proof (state)\nthis:\n  kauff_mat (a * as \\<otimes> b * bs) =\n  kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs))\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "moreover"], ["proof (state)\nthis:\n  kauff_mat (a * as \\<otimes> b * bs) =\n  kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs))\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "have \"... = rat_poly.matrix_mult \n                                   (blockmat (a \\<otimes> b)) \n                                   (kauff_mat (as \\<otimes> bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs)) =\n    rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n     (kauff_mat (as \\<otimes> bs))", "using kauff_mat.simps(2)"], ["proof (prove)\nusing this:\n  kauff_mat (?w * ?ws) = rat_poly.matrix_mult (blockmat ?w) (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs)) =\n    rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n     (kauff_mat (as \\<otimes> bs))", "by auto"], ["proof (state)\nthis:\n  kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs)) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat (as \\<otimes> bs))\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "moreover"], ["proof (state)\nthis:\n  kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs)) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat (as \\<otimes> bs))\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "have \"... = rat_poly.matrix_mult \n                             ((blockmat a) \\<otimes> (blockmat b)) \n                             ((kauff_mat as) \\<otimes> (kauff_mat bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n     (kauff_mat (as \\<otimes> bs)) =\n    rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n     (kauff_mat as \\<otimes> kauff_mat bs)", "using hyps 1  kauff_mat_tensor_distrib"], ["proof (prove)\nusing this:\n  is_tangle_diagram as \\<and> is_tangle_diagram bs \\<Longrightarrow>\n  kauff_mat (as \\<otimes> bs) = kauff_mat as \\<otimes> kauff_mat bs\n  is_tangle_diagram as \\<and> is_tangle_diagram bs\n  \\<forall>xs ys.\n     kauff_mat (basic xs \\<otimes> basic ys) =\n     kauff_mat (basic xs) \\<otimes> kauff_mat (basic ys)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n     (kauff_mat (as \\<otimes> bs)) =\n    rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n     (kauff_mat as \\<otimes> kauff_mat bs)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat (as \\<otimes> bs)) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes> kauff_mat bs)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat (as \\<otimes> bs)) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes> kauff_mat bs)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "have \"... =(rat_poly.matrix_mult (blockmat a) (kauff_mat as))\n                         \\<otimes> (rat_poly.matrix_mult (blockmat b) (kauff_mat bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n     (kauff_mat as \\<otimes> kauff_mat bs) =\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n    rat_poly.matrix_mult (blockmat b) (kauff_mat bs)", "using 0 rat_poly.distributivity"], ["proof (prove)\nusing this:\n  rat_poly.matrix_match (blockmat a) (kauff_mat as) (blockmat b)\n   (kauff_mat bs)\n  rat_poly.matrix_match ?A1.0 ?A2.0 ?B1.0 ?B2.0 \\<Longrightarrow>\n  rat_poly.matrix_mult ?A1.0 ?A2.0 \\<otimes>\n  rat_poly.matrix_mult ?B1.0 ?B2.0 =\n  rat_poly.matrix_mult (?A1.0 \\<otimes> ?B1.0) (?A2.0 \\<otimes> ?B2.0)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n     (kauff_mat as \\<otimes> kauff_mat bs) =\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n    rat_poly.matrix_mult (blockmat b) (kauff_mat bs)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes> kauff_mat bs) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b) (kauff_mat bs)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes> kauff_mat bs) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b) (kauff_mat bs)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "have \"... = kauff_mat (a*as) \\<otimes> kauff_mat (b*bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n    rat_poly.matrix_mult (blockmat b) (kauff_mat bs) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (b * bs)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b) (kauff_mat bs) =\n  kauff_mat (a * as) \\<otimes> kauff_mat (b * bs)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)\n 3. \\<And>x xs y ys.\n       \\<lbrakk>is_tangle_diagram xs \\<and>\n                is_tangle_diagram ys \\<Longrightarrow>\n                kauff_mat (xs \\<otimes> ys) =\n                kauff_mat xs \\<otimes> kauff_mat ys;\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> y * ys) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (y * ys)", "ultimately"], ["proof (chain)\npicking this:\n  kauff_mat (a * as \\<otimes> b * bs) =\n  kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs))\n  kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs)) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat (as \\<otimes> bs))\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat (as \\<otimes> bs)) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes> kauff_mat bs)\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes> kauff_mat bs) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b) (kauff_mat bs)\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b) (kauff_mat bs) =\n  kauff_mat (a * as) \\<otimes> kauff_mat (b * bs)", "show ?case"], ["proof (prove)\nusing this:\n  kauff_mat (a * as \\<otimes> b * bs) =\n  kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs))\n  kauff_mat ((a \\<otimes> b) * (as \\<otimes> bs)) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat (as \\<otimes> bs))\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat (as \\<otimes> bs)) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes> kauff_mat bs)\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes> kauff_mat bs) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b) (kauff_mat bs)\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b) (kauff_mat bs) =\n  kauff_mat (a * as) \\<otimes> kauff_mat (b * bs)\n\ngoal (1 subgoal):\n 1. kauff_mat (a * as \\<otimes> b * bs) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (b * bs)", "by metis"], ["proof (state)\nthis:\n  kauff_mat (a * as \\<otimes> b * bs) =\n  kauff_mat (a * as) \\<otimes> kauff_mat (b * bs)\n\ngoal (2 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "fix a b as bs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "assume hyps:\"codomain_block b \\<noteq> 0  \n            \\<Longrightarrow> is_tangle_diagram as \n               \\<and> is_tangle_diagram \n                      (basic (make_vert_block (nat (codomain_block b)))) \n            \\<Longrightarrow> kauff_mat \n                  (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))\n                   = kauff_mat as \n                      \\<otimes> kauff_mat \n                         (basic (make_vert_block (nat (codomain_block b))))\""], ["proof (state)\nthis:\n  \\<lbrakk>codomain_block b \\<noteq> 0;\n   is_tangle_diagram as \\<and>\n   is_tangle_diagram\n    (basic (make_vert_block (nat (codomain_block b))))\\<rbrakk>\n  \\<Longrightarrow> kauff_mat\n                     (as \\<otimes>\n                      basic (make_vert_block (nat (codomain_block b)))) =\n                    kauff_mat as \\<otimes>\n                    kauff_mat\n                     (basic (make_vert_block (nat (codomain_block b))))\n\ngoal (2 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "assume prems:\"is_tangle_diagram (a * as) \\<and> is_tangle_diagram (basic b)\""], ["proof (state)\nthis:\n  is_tangle_diagram (a * as) \\<and> is_tangle_diagram (basic b)\n\ngoal (2 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "let ?case = \" kauff_mat (a * as \\<otimes> basic b) \n                  = kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs y.\n       \\<lbrakk>\\<lbrakk>codomain_block y \\<noteq> 0;\n                 is_tangle_diagram xs \\<and>\n                 is_tangle_diagram\n                  (basic\n                    (make_vert_block (nat (codomain_block y))))\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (xs \\<otimes>\n                                    basic\n                                     (make_vert_block\n (nat (codomain_block y)))) =\n                                  kauff_mat xs \\<otimes>\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block y))));\n        is_tangle_diagram (x * xs) \\<and>\n        is_tangle_diagram (basic y)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (x * xs \\<otimes> basic y) =\n                         kauff_mat (x * xs) \\<otimes> kauff_mat (basic y)\n 2. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "proof(cases \"codomain_block b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "case True"], ["proof (state)\nthis:\n  codomain_block b = 0\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "have \"((a * as) \\<otimes> (basic b)) =  ((a \\<otimes>b) *  as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * as \\<otimes> basic b = (a \\<otimes> b) * as", "using tensor.simps True"], ["proof (prove)\nusing this:\n  basic ?x \\<otimes> basic ?y = basic (?x \\<otimes> ?y)\n  ?x * ?xs \\<otimes> basic ?y =\n  (if codomain_block ?y = 0 then (?x \\<otimes> ?y) * ?xs\n   else (?x \\<otimes> ?y) *\n        (?xs \\<otimes> basic (make_vert_block (nat (codomain_block ?y)))))\n  basic ?x \\<otimes> ?y * ?ys =\n  (if codomain_block ?x = 0 then (?x \\<otimes> ?y) * ?ys\n   else (?x \\<otimes> ?y) *\n        (basic (make_vert_block (nat (codomain_block ?x))) \\<otimes> ?ys))\n  ?x * ?xs \\<otimes> ?y * ?ys = (?x \\<otimes> ?y) * (?xs \\<otimes> ?ys)\n  codomain_block b = 0\n\ngoal (1 subgoal):\n 1. a * as \\<otimes> basic b = (a \\<otimes> b) * as", "by auto"], ["proof (state)\nthis:\n  a * as \\<otimes> basic b = (a \\<otimes> b) * as\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "then"], ["proof (chain)\npicking this:\n  a * as \\<otimes> basic b = (a \\<otimes> b) * as", "have \"kauff_mat ((a * as) \\<otimes> (basic b))\n                           = kauff_mat ((a \\<otimes>b) *  as)\""], ["proof (prove)\nusing this:\n  a * as \\<otimes> basic b = (a \\<otimes> b) * as\n\ngoal (1 subgoal):\n 1. kauff_mat (a * as \\<otimes> basic b) = kauff_mat ((a \\<otimes> b) * as)", "by auto"], ["proof (state)\nthis:\n  kauff_mat (a * as \\<otimes> basic b) = kauff_mat ((a \\<otimes> b) * as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "moreover"], ["proof (state)\nthis:\n  kauff_mat (a * as \\<otimes> basic b) = kauff_mat ((a \\<otimes> b) * as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "have \"... = \n                              rat_poly.matrix_mult \n                                   (blockmat (a \\<otimes> b))  \n                                   (kauff_mat as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat ((a \\<otimes> b) * as) =\n    rat_poly.matrix_mult (blockmat (a \\<otimes> b)) (kauff_mat as)", "by auto"], ["proof (state)\nthis:\n  kauff_mat ((a \\<otimes> b) * as) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b)) (kauff_mat as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "moreover"], ["proof (state)\nthis:\n  kauff_mat ((a \\<otimes> b) * as) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b)) (kauff_mat as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "have \"... = \n                           rat_poly.matrix_mult \n                                     ((blockmat a) \\<otimes> (blockmat b)) \n                                     (kauff_mat as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat (a \\<otimes> b)) (kauff_mat as) =\n    rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as)", "using  blockmat_tensor_distrib"], ["proof (prove)\nusing this:\n  blockmat (?a \\<otimes> ?b) = blockmat ?a \\<otimes> blockmat ?b\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat (a \\<otimes> b)) (kauff_mat as) =\n    rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as)", "by (metis)"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b)) (kauff_mat as) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "ultimately"], ["proof (chain)\npicking this:\n  kauff_mat (a * as \\<otimes> basic b) = kauff_mat ((a \\<otimes> b) * as)\n  kauff_mat ((a \\<otimes> b) * as) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b)) (kauff_mat as)\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b)) (kauff_mat as) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as)", "have T1:\n                     \"kauff_mat ((a * as) \\<otimes> (basic b))\n                             = rat_poly.matrix_mult \n                                     ((blockmat a) \\<otimes> (blockmat b)) \n                               (kauff_mat as)\""], ["proof (prove)\nusing this:\n  kauff_mat (a * as \\<otimes> basic b) = kauff_mat ((a \\<otimes> b) * as)\n  kauff_mat ((a \\<otimes> b) * as) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b)) (kauff_mat as)\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b)) (kauff_mat as) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. kauff_mat (a * as \\<otimes> basic b) =\n    rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as)", "by auto"], ["proof (state)\nthis:\n  kauff_mat (a * as \\<otimes> basic b) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "then"], ["proof (chain)\npicking this:\n  kauff_mat (a * as \\<otimes> basic b) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as)", "have \"weak_matrix_match \n                            (blockmat a) \n                            (kauff_mat as) \n                            (blockmat b)\""], ["proof (prove)\nusing this:\n  kauff_mat (a * as \\<otimes> basic b) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. weak_matrix_match (blockmat a) (kauff_mat as) (blockmat b)", "using is_tangle_diagram_weak_matrix_match True prems"], ["proof (prove)\nusing this:\n  kauff_mat (a * as \\<otimes> basic b) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as)\n  \\<lbrakk>is_tangle_diagram (?w1.0 * ?ws1.0);\n   codomain_block ?w2.0 = 0\\<rbrakk>\n  \\<Longrightarrow> weak_matrix_match (blockmat ?w1.0) (kauff_mat ?ws1.0)\n                     (blockmat ?w2.0)\n  codomain_block b = 0\n  is_tangle_diagram (a * as) \\<and> is_tangle_diagram (basic b)\n\ngoal (1 subgoal):\n 1. weak_matrix_match (blockmat a) (kauff_mat as) (blockmat b)", "by auto"], ["proof (state)\nthis:\n  weak_matrix_match (blockmat a) (kauff_mat as) (blockmat b)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "then"], ["proof (chain)\npicking this:\n  weak_matrix_match (blockmat a) (kauff_mat as) (blockmat b)", "have \"rat_poly.matrix_mult \n                        ((blockmat a) \\<otimes> (blockmat b)) \n                        (kauff_mat as)\n                              = ((rat_poly.matrix_mult \n                                           (blockmat a) \n                                            (kauff_mat as))\n                                  \\<otimes> (blockmat b))\""], ["proof (prove)\nusing this:\n  weak_matrix_match (blockmat a) (kauff_mat as) (blockmat b)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as) =\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b", "using weak_distributivity1"], ["proof (prove)\nusing this:\n  weak_matrix_match (blockmat a) (kauff_mat as) (blockmat b)\n  weak_matrix_match ?A1.0 ?A2.0 ?B1.0 \\<Longrightarrow>\n  rat_poly.matrix_mult ?A1.0 ?A2.0 \\<otimes> ?B1.0 =\n  rat_poly.matrix_mult (?A1.0 \\<otimes> ?B1.0) ?A2.0\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as) =\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "have \"... = (kauff_mat (a*as)) \\<otimes> (kauff_mat (basic b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b =\n  kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b =\n  kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b =\n  kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n\ngoal (1 subgoal):\n 1. kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "using T1"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b =\n  kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n  kauff_mat (a * as \\<otimes> basic b) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "by metis"], ["proof (state)\nthis:\n  kauff_mat (a * as \\<otimes> basic b) =\n  kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "case False"], ["proof (state)\nthis:\n  codomain_block b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "let ?bs = \"(basic (make_vert_block (nat (codomain_block b))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "have F0:\"rat_poly.matrix_match \n                                 (blockmat a) \n                                 (kauff_mat as) \n                                  (blockmat b)\n                                   (kauff_mat ?bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_match (blockmat a) (kauff_mat as) (blockmat b)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))", "using prems is_tangle_diagram_vert_block \n                 is_tangle_diagram_matrix_match"], ["proof (prove)\nusing this:\n  is_tangle_diagram (a * as) \\<and> is_tangle_diagram (basic b)\n  is_tangle_diagram (?b * basic (make_vert_block (nat (codomain_block ?b))))\n  \\<lbrakk>is_tangle_diagram (?w1.0 * ?ws1.0);\n   is_tangle_diagram (?w2.0 * ?ws2.0)\\<rbrakk>\n  \\<Longrightarrow> rat_poly.matrix_match (blockmat ?w1.0)\n                     (kauff_mat ?ws1.0) (blockmat ?w2.0) (kauff_mat ?ws2.0)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_match (blockmat a) (kauff_mat as) (blockmat b)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))", "by metis"], ["proof (state)\nthis:\n  rat_poly.matrix_match (blockmat a) (kauff_mat as) (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "have F1:\"codomain_block b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0", "using False"], ["proof (prove)\nusing this:\n  codomain_block b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  codomain_block b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "have F2:\" is_tangle_diagram as \n                     \\<and> is_tangle_diagram ?bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram as \\<and>\n    is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))", "using is_tangle_diagram.simps prems"], ["proof (prove)\nusing this:\n  is_tangle_diagram (basic ?x) = True\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n  is_tangle_diagram (a * as) \\<and> is_tangle_diagram (basic b)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram as \\<and>\n    is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram as \\<and>\n  is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram as \\<and>\n  is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))", "have F3:\"kauff_mat \n                         (as\\<otimes>basic (make_vert_block (nat (codomain_block b)))) =\n                                     kauff_mat as \\<otimes> kauff_mat ?bs\""], ["proof (prove)\nusing this:\n  is_tangle_diagram as \\<and>\n  is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))\n\ngoal (1 subgoal):\n 1. kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))) =\n    kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b))))", "using F1 hyps"], ["proof (prove)\nusing this:\n  is_tangle_diagram as \\<and>\n  is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))\n  codomain_block b \\<noteq> 0\n  \\<lbrakk>codomain_block b \\<noteq> 0;\n   is_tangle_diagram as \\<and>\n   is_tangle_diagram\n    (basic (make_vert_block (nat (codomain_block b))))\\<rbrakk>\n  \\<Longrightarrow> kauff_mat\n                     (as \\<otimes>\n                      basic (make_vert_block (nat (codomain_block b)))) =\n                    kauff_mat as \\<otimes>\n                    kauff_mat\n                     (basic (make_vert_block (nat (codomain_block b))))\n\ngoal (1 subgoal):\n 1. kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))) =\n    kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b))))", "by auto"], ["proof (state)\nthis:\n  kauff_mat\n   (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))) =\n  kauff_mat as \\<otimes>\n  kauff_mat (basic (make_vert_block (nat (codomain_block b))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "moreover"], ["proof (state)\nthis:\n  kauff_mat\n   (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))) =\n  kauff_mat as \\<otimes>\n  kauff_mat (basic (make_vert_block (nat (codomain_block b))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "have \"((a*as) \\<otimes> (basic b)) = (a \\<otimes> b) * (as \\<otimes> ?bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * as \\<otimes> basic b =\n    (a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))", "using False tensor.simps"], ["proof (prove)\nusing this:\n  codomain_block b \\<noteq> 0\n  basic ?x \\<otimes> basic ?y = basic (?x \\<otimes> ?y)\n  ?x * ?xs \\<otimes> basic ?y =\n  (if codomain_block ?y = 0 then (?x \\<otimes> ?y) * ?xs\n   else (?x \\<otimes> ?y) *\n        (?xs \\<otimes> basic (make_vert_block (nat (codomain_block ?y)))))\n  basic ?x \\<otimes> ?y * ?ys =\n  (if codomain_block ?x = 0 then (?x \\<otimes> ?y) * ?ys\n   else (?x \\<otimes> ?y) *\n        (basic (make_vert_block (nat (codomain_block ?x))) \\<otimes> ?ys))\n  ?x * ?xs \\<otimes> ?y * ?ys = (?x \\<otimes> ?y) * (?xs \\<otimes> ?ys)\n\ngoal (1 subgoal):\n 1. a * as \\<otimes> basic b =\n    (a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))", "by auto"], ["proof (state)\nthis:\n  a * as \\<otimes> basic b =\n  (a \\<otimes> b) *\n  (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "moreover"], ["proof (state)\nthis:\n  a * as \\<otimes> basic b =\n  (a \\<otimes> b) *\n  (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "then"], ["proof (chain)\npicking this:\n  a * as \\<otimes> basic b =\n  (a \\<otimes> b) *\n  (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))", "have \"kauff_mat ((a*as) \\<otimes> (basic b)) \n                                     = kauff_mat((a \\<otimes> b) * (as \\<otimes> ?bs))\""], ["proof (prove)\nusing this:\n  a * as \\<otimes> basic b =\n  (a \\<otimes> b) *\n  (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))\n\ngoal (1 subgoal):\n 1. kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat\n     ((a \\<otimes> b) *\n      (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))", "by auto"], ["proof (state)\nthis:\n  kauff_mat (a * as \\<otimes> basic b) =\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "moreover"], ["proof (state)\nthis:\n  kauff_mat (a * as \\<otimes> basic b) =\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "then"], ["proof (chain)\npicking this:\n  kauff_mat (a * as \\<otimes> basic b) =\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))", "have \"... = rat_poly.matrix_mult \n                                             (blockmat (a \\<otimes> b)) \n                                             (kauff_mat (as \\<otimes> ?bs))\""], ["proof (prove)\nusing this:\n  kauff_mat (a * as \\<otimes> basic b) =\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. kauff_mat\n     ((a \\<otimes> b) *\n      (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n    rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n     (kauff_mat\n       (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))", "using kauff_mat.simps"], ["proof (prove)\nusing this:\n  kauff_mat (a * as \\<otimes> basic b) =\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n  kauff_mat (basic ?w) = blockmat ?w\n  kauff_mat (?w * ?ws) = rat_poly.matrix_mult (blockmat ?w) (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. kauff_mat\n     ((a \\<otimes> b) *\n      (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n    rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n     (kauff_mat\n       (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))", "by auto"], ["proof (state)\nthis:\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "moreover"], ["proof (state)\nthis:\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "then"], ["proof (chain)\npicking this:\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))", "have \"... = rat_poly.matrix_mult \n                                            ((blockmat a)\\<otimes>(blockmat b))\n                                            ((kauff_mat as)\\<otimes>(kauff_mat ?bs))\""], ["proof (prove)\nusing this:\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n     (kauff_mat\n       (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n    rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n     (kauff_mat as \\<otimes>\n      kauff_mat (basic (make_vert_block (nat (codomain_block b)))))", "using F3  blockmat_tensor_distrib"], ["proof (prove)\nusing this:\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n  kauff_mat\n   (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))) =\n  kauff_mat as \\<otimes>\n  kauff_mat (basic (make_vert_block (nat (codomain_block b))))\n  blockmat (?a \\<otimes> ?b) = blockmat ?a \\<otimes> blockmat ?b\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n     (kauff_mat\n       (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n    rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n     (kauff_mat as \\<otimes>\n      kauff_mat (basic (make_vert_block (nat (codomain_block b)))))", "by (metis)"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b)))))", "have \n               \"...  \n                    = (rat_poly.matrix_mult (blockmat a) (kauff_mat as))\n                       \\<otimes> (rat_poly.matrix_mult (blockmat b) (kauff_mat ?bs))\""], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n     (kauff_mat as \\<otimes>\n      kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n    rat_poly.matrix_mult (blockmat b)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))", "using rat_poly.distributivity F0"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n  rat_poly.matrix_match ?A1.0 ?A2.0 ?B1.0 ?B2.0 \\<Longrightarrow>\n  rat_poly.matrix_mult ?A1.0 ?A2.0 \\<otimes>\n  rat_poly.matrix_mult ?B1.0 ?B2.0 =\n  rat_poly.matrix_mult (?A1.0 \\<otimes> ?B1.0) (?A2.0 \\<otimes> ?B2.0)\n  rat_poly.matrix_match (blockmat a) (kauff_mat as) (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n     (kauff_mat as \\<otimes>\n      kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n    rat_poly.matrix_mult (blockmat b)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))", "have \"... \n                                  =  (rat_poly.matrix_mult \n                                             (blockmat a) \n                                             (kauff_mat as))\n                                       \\<otimes> (blockmat b)\""], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n    rat_poly.matrix_mult (blockmat b)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b", "using mat1_vert_block"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n  rat_poly.matrix_mult (blockmat ?b)\n   (blockmat (make_vert_block (nat (codomain_block ?b)))) =\n  blockmat ?b\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n    rat_poly.matrix_mult (blockmat b)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b", "have \"... = (kauff_mat (a*as)) \n                                           \\<otimes> (kauff_mat (basic b))\""], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "using kauff_mat.simps"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b\n  kauff_mat (basic ?w) = blockmat ?w\n  kauff_mat (?w * ?ws) = rat_poly.matrix_mult (blockmat ?w) (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b =\n  kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "ultimately"], ["proof (chain)\npicking this:\n  kauff_mat\n   (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))) =\n  kauff_mat as \\<otimes>\n  kauff_mat (basic (make_vert_block (nat (codomain_block b))))\n  a * as \\<otimes> basic b =\n  (a \\<otimes> b) *\n  (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))\n  kauff_mat (a * as \\<otimes> basic b) =\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b =\n  kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "show ?thesis"], ["proof (prove)\nusing this:\n  kauff_mat\n   (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))) =\n  kauff_mat as \\<otimes>\n  kauff_mat (basic (make_vert_block (nat (codomain_block b))))\n  a * as \\<otimes> basic b =\n  (a \\<otimes> b) *\n  (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))\n  kauff_mat (a * as \\<otimes> basic b) =\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n  kauff_mat\n   ((a \\<otimes> b) *\n    (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b)))))\n  rat_poly.matrix_mult (blockmat (a \\<otimes> b))\n   (kauff_mat\n     (as \\<otimes> basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n  rat_poly.matrix_mult (blockmat a \\<otimes> blockmat b)\n   (kauff_mat as \\<otimes>\n    kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes>\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) =\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) \\<otimes> blockmat b =\n  kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n\ngoal (1 subgoal):\n 1. kauff_mat (a * as \\<otimes> basic b) =\n    kauff_mat (a * as) \\<otimes> kauff_mat (basic b)", "by metis"], ["proof (state)\nthis:\n  kauff_mat (a * as \\<otimes> basic b) =\n  kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  kauff_mat (a * as \\<otimes> basic b) =\n  kauff_mat (a * as) \\<otimes> kauff_mat (basic b)\n\ngoal (1 subgoal):\n 1. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "fix a b as bs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "assume hyps:\n       \"codomain_block b \\<noteq> 0  \n          \\<Longrightarrow>  is_tangle_diagram \n                       (basic (make_vert_block (nat (codomain_block b)))) \n                 \\<and>(is_tangle_diagram as) \n          \\<Longrightarrow> kauff_mat (basic (make_vert_block (nat (codomain_block b)))\\<otimes> as) \n            =  kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \n         \\<otimes> kauff_mat as \""], ["proof (state)\nthis:\n  \\<lbrakk>codomain_block b \\<noteq> 0;\n   is_tangle_diagram\n    (basic (make_vert_block (nat (codomain_block b)))) \\<and>\n   is_tangle_diagram as\\<rbrakk>\n  \\<Longrightarrow> kauff_mat\n                     (basic\n                       (make_vert_block (nat (codomain_block b))) \\<otimes>\n                      as) =\n                    kauff_mat\n                     (basic\n                       (make_vert_block (nat (codomain_block b)))) \\<otimes>\n                    kauff_mat as\n\ngoal (1 subgoal):\n 1. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "assume prems:\"is_tangle_diagram (basic b) \\<and> is_tangle_diagram (a * as) \""], ["proof (state)\nthis:\n  is_tangle_diagram (basic b) \\<and> is_tangle_diagram (a * as)\n\ngoal (1 subgoal):\n 1. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "let ?case = \" kauff_mat ( (basic b) \\<otimes>  (a * as)) \n                       = kauff_mat (basic b) \\<otimes>  kauff_mat (a * as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y ys.\n       \\<lbrakk>\\<lbrakk>codomain_block x \\<noteq> 0;\n                 is_tangle_diagram\n                  (basic (make_vert_block (nat (codomain_block x)))) \\<and>\n                 is_tangle_diagram ys\\<rbrakk>\n                \\<Longrightarrow> kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x))) \\<otimes>\n                                    ys) =\n                                  kauff_mat\n                                   (basic\n                                     (make_vert_block\n (nat (codomain_block x)))) \\<otimes>\n                                  kauff_mat ys;\n        is_tangle_diagram (basic x) \\<and>\n        is_tangle_diagram (y * ys)\\<rbrakk>\n       \\<Longrightarrow> kauff_mat (basic x \\<otimes> y * ys) =\n                         kauff_mat (basic x) \\<otimes> kauff_mat (y * ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "proof(cases \"codomain_block b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "case True"], ["proof (state)\nthis:\n  codomain_block b = 0\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "have \"((basic b) \\<otimes> (a * as)) =  ((b \\<otimes> a) *  as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basic b \\<otimes> a * as = (b \\<otimes> a) * as", "using tensor.simps True"], ["proof (prove)\nusing this:\n  basic ?x \\<otimes> basic ?y = basic (?x \\<otimes> ?y)\n  ?x * ?xs \\<otimes> basic ?y =\n  (if codomain_block ?y = 0 then (?x \\<otimes> ?y) * ?xs\n   else (?x \\<otimes> ?y) *\n        (?xs \\<otimes> basic (make_vert_block (nat (codomain_block ?y)))))\n  basic ?x \\<otimes> ?y * ?ys =\n  (if codomain_block ?x = 0 then (?x \\<otimes> ?y) * ?ys\n   else (?x \\<otimes> ?y) *\n        (basic (make_vert_block (nat (codomain_block ?x))) \\<otimes> ?ys))\n  ?x * ?xs \\<otimes> ?y * ?ys = (?x \\<otimes> ?y) * (?xs \\<otimes> ?ys)\n  codomain_block b = 0\n\ngoal (1 subgoal):\n 1. basic b \\<otimes> a * as = (b \\<otimes> a) * as", "by auto"], ["proof (state)\nthis:\n  basic b \\<otimes> a * as = (b \\<otimes> a) * as\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "then"], ["proof (chain)\npicking this:\n  basic b \\<otimes> a * as = (b \\<otimes> a) * as", "have \"kauff_mat ((basic b) \\<otimes> (a * as))\n                           = kauff_mat ((b \\<otimes>a ) *  as)\""], ["proof (prove)\nusing this:\n  basic b \\<otimes> a * as = (b \\<otimes> a) * as\n\ngoal (1 subgoal):\n 1. kauff_mat (basic b \\<otimes> a * as) = kauff_mat ((b \\<otimes> a) * as)", "by auto"], ["proof (state)\nthis:\n  kauff_mat (basic b \\<otimes> a * as) = kauff_mat ((b \\<otimes> a) * as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "moreover"], ["proof (state)\nthis:\n  kauff_mat (basic b \\<otimes> a * as) = kauff_mat ((b \\<otimes> a) * as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "have \"... = rat_poly.matrix_mult \n                                      (blockmat (b \\<otimes> a))  \n                                      (kauff_mat as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kauff_mat ((b \\<otimes> a) * as) =\n    rat_poly.matrix_mult (blockmat (b \\<otimes> a)) (kauff_mat as)", "by auto"], ["proof (state)\nthis:\n  kauff_mat ((b \\<otimes> a) * as) =\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a)) (kauff_mat as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "moreover"], ["proof (state)\nthis:\n  kauff_mat ((b \\<otimes> a) * as) =\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a)) (kauff_mat as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "have \"... = rat_poly.matrix_mult \n                                         ((blockmat b) \\<otimes> (blockmat a)) \n                                         (kauff_mat as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat (b \\<otimes> a)) (kauff_mat as) =\n    rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as)", "using  blockmat_tensor_distrib"], ["proof (prove)\nusing this:\n  blockmat (?a \\<otimes> ?b) = blockmat ?a \\<otimes> blockmat ?b\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat (b \\<otimes> a)) (kauff_mat as) =\n    rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as)", "by (metis)"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a)) (kauff_mat as) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "ultimately"], ["proof (chain)\npicking this:\n  kauff_mat (basic b \\<otimes> a * as) = kauff_mat ((b \\<otimes> a) * as)\n  kauff_mat ((b \\<otimes> a) * as) =\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a)) (kauff_mat as)\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a)) (kauff_mat as) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as)", "have T1:\"kauff_mat ((basic b) \\<otimes> (a*as))\n                                     = rat_poly.matrix_mult \n                                          ((blockmat b) \\<otimes> (blockmat a)) \n                                          (kauff_mat as)\""], ["proof (prove)\nusing this:\n  kauff_mat (basic b \\<otimes> a * as) = kauff_mat ((b \\<otimes> a) * as)\n  kauff_mat ((b \\<otimes> a) * as) =\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a)) (kauff_mat as)\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a)) (kauff_mat as) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. kauff_mat (basic b \\<otimes> a * as) =\n    rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as)", "by auto"], ["proof (state)\nthis:\n  kauff_mat (basic b \\<otimes> a * as) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "then"], ["proof (chain)\npicking this:\n  kauff_mat (basic b \\<otimes> a * as) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as)", "have \"weak_matrix_match2 \n                              (blockmat b) \n                               (blockmat a) \n                               (kauff_mat as)\""], ["proof (prove)\nusing this:\n  kauff_mat (basic b \\<otimes> a * as) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 (blockmat b) (blockmat a) (kauff_mat as)", "using is_tangle_diagram_weak_matrix_match2 \n               True prems"], ["proof (prove)\nusing this:\n  kauff_mat (basic b \\<otimes> a * as) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as)\n  \\<lbrakk>is_tangle_diagram (?w2.0 * ?ws2.0);\n   codomain_block ?w1.0 = 0\\<rbrakk>\n  \\<Longrightarrow> weak_matrix_match2 (blockmat ?w1.0) (blockmat ?w2.0)\n                     (kauff_mat ?ws2.0)\n  codomain_block b = 0\n  is_tangle_diagram (basic b) \\<and> is_tangle_diagram (a * as)\n\ngoal (1 subgoal):\n 1. weak_matrix_match2 (blockmat b) (blockmat a) (kauff_mat as)", "by auto"], ["proof (state)\nthis:\n  weak_matrix_match2 (blockmat b) (blockmat a) (kauff_mat as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "then"], ["proof (chain)\npicking this:\n  weak_matrix_match2 (blockmat b) (blockmat a) (kauff_mat as)", "have \"rat_poly.matrix_mult \n                                ((blockmat b) \\<otimes> (blockmat a)) \n                                (kauff_mat as)\n                     = (blockmat b)  \n                        \\<otimes> (rat_poly.matrix_mult (blockmat a)(kauff_mat as))\""], ["proof (prove)\nusing this:\n  weak_matrix_match2 (blockmat b) (blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as) =\n    blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)", "using weak_distributivity2"], ["proof (prove)\nusing this:\n  weak_matrix_match2 (blockmat b) (blockmat a) (kauff_mat as)\n  weak_matrix_match2 ?A1.0 ?B1.0 ?B2.0 \\<Longrightarrow>\n  ?A1.0 \\<otimes> rat_poly.matrix_mult ?B1.0 ?B2.0 =\n  rat_poly.matrix_mult (?A1.0 \\<otimes> ?B1.0) ?B2.0\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as) =\n    blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "have \"... = (kauff_mat (basic b)) \\<otimes> (kauff_mat (a*as)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "by auto"], ["proof (state)\nthis:\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n\ngoal (2 subgoals):\n 1. codomain_block b = 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n 2. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "ultimately"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n\ngoal (1 subgoal):\n 1. kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "using T1"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n  kauff_mat (basic b \\<otimes> a * as) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "by metis"], ["proof (state)\nthis:\n  kauff_mat (basic b \\<otimes> a * as) =\n  kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "case False"], ["proof (state)\nthis:\n  codomain_block b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "let ?bs = \"(basic (make_vert_block (nat (codomain_block b))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "have F0:\"rat_poly.matrix_match  \n                                   (blockmat b)\n                                   (kauff_mat ?bs) \n                                   (blockmat a) \n                                   (kauff_mat as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_poly.matrix_match (blockmat b)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n     (blockmat a) (kauff_mat as)", "using prems is_tangle_diagram_vert_block \n              is_tangle_diagram_matrix_match"], ["proof (prove)\nusing this:\n  is_tangle_diagram (basic b) \\<and> is_tangle_diagram (a * as)\n  is_tangle_diagram (?b * basic (make_vert_block (nat (codomain_block ?b))))\n  \\<lbrakk>is_tangle_diagram (?w1.0 * ?ws1.0);\n   is_tangle_diagram (?w2.0 * ?ws2.0)\\<rbrakk>\n  \\<Longrightarrow> rat_poly.matrix_match (blockmat ?w1.0)\n                     (kauff_mat ?ws1.0) (blockmat ?w2.0) (kauff_mat ?ws2.0)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_match (blockmat b)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n     (blockmat a) (kauff_mat as)", "by metis"], ["proof (state)\nthis:\n  rat_poly.matrix_match (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n   (blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "have F1:\"codomain_block b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0", "using False"], ["proof (prove)\nusing this:\n  codomain_block b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  codomain_block b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "have F2:\" is_tangle_diagram as \n                     \\<and> is_tangle_diagram ?bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tangle_diagram as \\<and>\n    is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))", "using is_tangle_diagram.simps prems"], ["proof (prove)\nusing this:\n  is_tangle_diagram (basic ?x) = True\n  is_tangle_diagram (?x * ?xs) =\n  (if is_tangle_diagram ?xs then codomain_block ?x = domain_wall ?xs\n   else False)\n  is_tangle_diagram (basic b) \\<and> is_tangle_diagram (a * as)\n\ngoal (1 subgoal):\n 1. is_tangle_diagram as \\<and>\n    is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))", "by metis"], ["proof (state)\nthis:\n  is_tangle_diagram as \\<and>\n  is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "then"], ["proof (chain)\npicking this:\n  is_tangle_diagram as \\<and>\n  is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))", "have F3:\"kauff_mat (?bs \\<otimes> as) = kauff_mat ?bs \\<otimes> kauff_mat as\""], ["proof (prove)\nusing this:\n  is_tangle_diagram as \\<and>\n  is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))\n\ngoal (1 subgoal):\n 1. kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as) =\n    kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as", "using F1 hyps"], ["proof (prove)\nusing this:\n  is_tangle_diagram as \\<and>\n  is_tangle_diagram (basic (make_vert_block (nat (codomain_block b))))\n  codomain_block b \\<noteq> 0\n  \\<lbrakk>codomain_block b \\<noteq> 0;\n   is_tangle_diagram\n    (basic (make_vert_block (nat (codomain_block b)))) \\<and>\n   is_tangle_diagram as\\<rbrakk>\n  \\<Longrightarrow> kauff_mat\n                     (basic\n                       (make_vert_block (nat (codomain_block b))) \\<otimes>\n                      as) =\n                    kauff_mat\n                     (basic\n                       (make_vert_block (nat (codomain_block b)))) \\<otimes>\n                    kauff_mat as\n\ngoal (1 subgoal):\n 1. kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as) =\n    kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as", "by auto"], ["proof (state)\nthis:\n  kauff_mat\n   (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as) =\n  kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n  kauff_mat as\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "moreover"], ["proof (state)\nthis:\n  kauff_mat\n   (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as) =\n  kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n  kauff_mat as\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "have \"((basic b) \\<otimes> (a*as)) = (b \\<otimes> a) * (?bs \\<otimes> as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basic b \\<otimes> a * as =\n    (b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)", "using False tensor.simps"], ["proof (prove)\nusing this:\n  codomain_block b \\<noteq> 0\n  basic ?x \\<otimes> basic ?y = basic (?x \\<otimes> ?y)\n  ?x * ?xs \\<otimes> basic ?y =\n  (if codomain_block ?y = 0 then (?x \\<otimes> ?y) * ?xs\n   else (?x \\<otimes> ?y) *\n        (?xs \\<otimes> basic (make_vert_block (nat (codomain_block ?y)))))\n  basic ?x \\<otimes> ?y * ?ys =\n  (if codomain_block ?x = 0 then (?x \\<otimes> ?y) * ?ys\n   else (?x \\<otimes> ?y) *\n        (basic (make_vert_block (nat (codomain_block ?x))) \\<otimes> ?ys))\n  ?x * ?xs \\<otimes> ?y * ?ys = (?x \\<otimes> ?y) * (?xs \\<otimes> ?ys)\n\ngoal (1 subgoal):\n 1. basic b \\<otimes> a * as =\n    (b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)", "by auto"], ["proof (state)\nthis:\n  basic b \\<otimes> a * as =\n  (b \\<otimes> a) *\n  (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "moreover"], ["proof (state)\nthis:\n  basic b \\<otimes> a * as =\n  (b \\<otimes> a) *\n  (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "then"], ["proof (chain)\npicking this:\n  basic b \\<otimes> a * as =\n  (b \\<otimes> a) *\n  (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)", "have \n                    \"kauff_mat ((basic b) \\<otimes> (a*as)) \n                                    = kauff_mat((b \\<otimes> a) * (?bs \\<otimes> as))\""], ["proof (prove)\nusing this:\n  basic b \\<otimes> a * as =\n  (b \\<otimes> a) *\n  (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)\n\ngoal (1 subgoal):\n 1. kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat\n     ((b \\<otimes> a) *\n      (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))", "by auto"], ["proof (state)\nthis:\n  kauff_mat (basic b \\<otimes> a * as) =\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "moreover"], ["proof (state)\nthis:\n  kauff_mat (basic b \\<otimes> a * as) =\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "then"], ["proof (chain)\npicking this:\n  kauff_mat (basic b \\<otimes> a * as) =\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))", "have \"... \n                                 = rat_poly.matrix_mult \n                                               (blockmat (b \\<otimes> a)) \n                                               (kauff_mat (?bs \\<otimes> as))\""], ["proof (prove)\nusing this:\n  kauff_mat (basic b \\<otimes> a * as) =\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n\ngoal (1 subgoal):\n 1. kauff_mat\n     ((b \\<otimes> a) *\n      (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n    rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n     (kauff_mat\n       (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))", "using kauff_mat.simps"], ["proof (prove)\nusing this:\n  kauff_mat (basic b \\<otimes> a * as) =\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n  kauff_mat (basic ?w) = blockmat ?w\n  kauff_mat (?w * ?ws) = rat_poly.matrix_mult (blockmat ?w) (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. kauff_mat\n     ((b \\<otimes> a) *\n      (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n    rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n     (kauff_mat\n       (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))", "by auto"], ["proof (state)\nthis:\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "moreover"], ["proof (state)\nthis:\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "then"], ["proof (chain)\npicking this:\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))", "have \"... \n                          = rat_poly.matrix_mult \n                                    ((blockmat b)\\<otimes>(blockmat a))\n                                    ((kauff_mat ?bs)\\<otimes>(kauff_mat as))\""], ["proof (prove)\nusing this:\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n     (kauff_mat\n       (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n    rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n      kauff_mat as)", "using F3"], ["proof (prove)\nusing this:\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n  kauff_mat\n   (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as) =\n  kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n  kauff_mat as\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n     (kauff_mat\n       (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n    rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n      kauff_mat as)", "by (metis blockmat_tensor_distrib)"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as)", "have \"...  \n                                 = (rat_poly.matrix_mult \n                                          (blockmat b) \n                                          (kauff_mat ?bs))\n                          \\<otimes> (rat_poly.matrix_mult  \n                                              (blockmat a) \n                                              (kauff_mat as))\""], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n      kauff_mat as) =\n    rat_poly.matrix_mult (blockmat b)\n     (kauff_mat\n       (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as)", "using rat_poly.distributivity F0"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as)\n  rat_poly.matrix_match ?A1.0 ?A2.0 ?B1.0 ?B2.0 \\<Longrightarrow>\n  rat_poly.matrix_mult ?A1.0 ?A2.0 \\<otimes>\n  rat_poly.matrix_mult ?B1.0 ?B2.0 =\n  rat_poly.matrix_mult (?A1.0 \\<otimes> ?B1.0) (?A2.0 \\<otimes> ?B2.0)\n  rat_poly.matrix_match (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))))\n   (blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n     (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n      kauff_mat as) =\n    rat_poly.matrix_mult (blockmat b)\n     (kauff_mat\n       (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as) =\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as) =\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as) =\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as)", "have \"... = (blockmat b) \n                                      \\<otimes> (rat_poly.matrix_mult \n                                                   (blockmat a) \n                                                   (kauff_mat as))\""], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as) =\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b)\n     (kauff_mat\n       (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n    blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)", "using mat1_vert_block"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as) =\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n  rat_poly.matrix_mult (blockmat ?b)\n   (blockmat (make_vert_block (nat (codomain_block ?b)))) =\n  blockmat ?b\n\ngoal (1 subgoal):\n 1. rat_poly.matrix_mult (blockmat b)\n     (kauff_mat\n       (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n    rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n    blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)", "by auto"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "moreover"], ["proof (state)\nthis:\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "then"], ["proof (chain)\npicking this:\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)", "have \"... = (kauff_mat (basic b)) \n                                           \\<otimes> (kauff_mat (a*as))\""], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n\ngoal (1 subgoal):\n 1. blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "using kauff_mat.simps"], ["proof (prove)\nusing this:\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n  kauff_mat (basic ?w) = blockmat ?w\n  kauff_mat (?w * ?ws) = rat_poly.matrix_mult (blockmat ?w) (kauff_mat ?ws)\n\ngoal (1 subgoal):\n 1. blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "by auto"], ["proof (state)\nthis:\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n\ngoal (1 subgoal):\n 1. codomain_block b \\<noteq> 0 \\<Longrightarrow>\n    kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "ultimately"], ["proof (chain)\npicking this:\n  kauff_mat\n   (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as) =\n  kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n  kauff_mat as\n  basic b \\<otimes> a * as =\n  (b \\<otimes> a) *\n  (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)\n  kauff_mat (basic b \\<otimes> a * as) =\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as)\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as) =\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "show ?thesis"], ["proof (prove)\nusing this:\n  kauff_mat\n   (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as) =\n  kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n  kauff_mat as\n  basic b \\<otimes> a * as =\n  (b \\<otimes> a) *\n  (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)\n  kauff_mat (basic b \\<otimes> a * as) =\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n  kauff_mat\n   ((b \\<otimes> a) *\n    (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as))\n  rat_poly.matrix_mult (blockmat (b \\<otimes> a))\n   (kauff_mat\n     (basic (make_vert_block (nat (codomain_block b))) \\<otimes> as)) =\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as)\n  rat_poly.matrix_mult (blockmat b \\<otimes> blockmat a)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b)))) \\<otimes>\n    kauff_mat as) =\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n  rat_poly.matrix_mult (blockmat b)\n   (kauff_mat (basic (make_vert_block (nat (codomain_block b))))) \\<otimes>\n  rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as)\n  blockmat b \\<otimes> rat_poly.matrix_mult (blockmat a) (kauff_mat as) =\n  kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n\ngoal (1 subgoal):\n 1. kauff_mat (basic b \\<otimes> a * as) =\n    kauff_mat (basic b) \\<otimes> kauff_mat (a * as)", "by metis"], ["proof (state)\nthis:\n  kauff_mat (basic b \\<otimes> a * as) =\n  kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  kauff_mat (basic b \\<otimes> a * as) =\n  kauff_mat (basic b) \\<otimes> kauff_mat (a * as)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}