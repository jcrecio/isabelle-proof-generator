{"file_name": "/home/qj213/afp-2021-10-22/thys/Echelon_Form/Cayley_Hamilton_Compatible.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Echelon_Form", "problem_names": ["lemma det_sq_matrix_eq: \"Square_Matrix.det (from_vec A) = det A\"", "lemma to_vec_matrix_scalar_mult: \"to_vec (x *\\<^sub>S A) = x *k to_vec A\"", "lemma to_vec_matrix_matrix_mult: \"to_vec (A * B) = to_vec A ** to_vec B\"", "lemma to_vec_diag: \"to_vec (diag x) = mat x\"", "lemma to_vec_one: \"to_vec 1 = mat 1\"", "lemma to_vec_eq_iff: \"to_vec M = to_vec N \\<longleftrightarrow> M = N\"", "lemma invertible_iff_is_unit:\n  fixes A::\"'a::{comm_ring_1}^'n^'n\"\n  shows \"invertible A \\<longleftrightarrow> (det A) dvd 1\"", "lemma minorM_eq: \"minorM M i j = to_vec (minor (from_vec M) i j)\"", "lemma cofactorM_eq: \"cofactorM = to_vec \\<circ> Square_Matrix.cofactor \\<circ> from_vec\"", "lemma charpoly_eq: \"charpoly A = Cayley_Hamilton.charpoly (from_vec A)\"", "lemma adjugate_eq: \"adjugate = to_vec \\<circ> Square_Matrix.adjugate \\<circ> from_vec\""], "translations": [["", "lemma det_sq_matrix_eq: \"Square_Matrix.det (from_vec A) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (from_vec A) = det A", "unfolding Square_Matrix.det.rep_eq Determinants.det_def from_vec.rep_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A $ i $ p i)) =\n    (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A $ i $ p i))", ".."], ["", "lemma to_vec_matrix_scalar_mult: \"to_vec (x *\\<^sub>S A) = x *k to_vec A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_vec (x *\\<^sub>S A) = x *k to_vec A", "by transfer (simp add: matrix_scalar_mult_def)"], ["", "lemma to_vec_matrix_matrix_mult: \"to_vec (A * B) = to_vec A ** to_vec B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_vec (A * B) = to_vec A ** to_vec B", "by transfer (simp add: matrix_matrix_mult_def)"], ["", "lemma to_vec_diag: \"to_vec (diag x) = mat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_vec (diag x) = mat x", "by transfer (simp add: mat_def)"], ["", "lemma to_vec_one: \"to_vec 1 = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_vec 1 = mat (1::'a)", "by transfer (simp add: mat_def)"], ["", "lemma to_vec_eq_iff: \"to_vec M = to_vec N \\<longleftrightarrow> M = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_vec M = to_vec N) = (M = N)", "by transfer (auto simp: vec_eq_iff)"], ["", "subsection\\<open>Some preliminary lemmas and results\\<close>"], ["", "lemma invertible_iff_is_unit:\n  fixes A::\"'a::{comm_ring_1}^'n^'n\"\n  shows \"invertible A \\<longleftrightarrow> (det A) dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible A = (det A dvd (1::'a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. invertible A \\<Longrightarrow> det A dvd (1::'a)\n 2. det A dvd (1::'a) \\<Longrightarrow> invertible A", "assume inv_A: \"invertible A\""], ["proof (state)\nthis:\n  invertible A\n\ngoal (2 subgoals):\n 1. invertible A \\<Longrightarrow> det A dvd (1::'a)\n 2. det A dvd (1::'a) \\<Longrightarrow> invertible A", "obtain B where AB_mat: \"A ** B = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B.\n        A ** B = mat (1::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inv_A"], ["proof (prove)\nusing this:\n  invertible A\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        A ** B = mat (1::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding invertible_def"], ["proof (prove)\nusing this:\n  \\<exists>A'. A ** A' = mat (1::'a) \\<and> A' ** A = mat (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        A ** B = mat (1::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A ** B = mat (1::'a)\n\ngoal (2 subgoals):\n 1. invertible A \\<Longrightarrow> det A dvd (1::'a)\n 2. det A dvd (1::'a) \\<Longrightarrow> invertible A", "have \"1 = det (mat 1::'a^'n^'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) = det (mat (1::'a))", "unfolding det_I"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) = (1::'a)", ".."], ["proof (state)\nthis:\n  (1::'a) = det (mat (1::'a))\n\ngoal (2 subgoals):\n 1. invertible A \\<Longrightarrow> det A dvd (1::'a)\n 2. det A dvd (1::'a) \\<Longrightarrow> invertible A", "also"], ["proof (state)\nthis:\n  (1::'a) = det (mat (1::'a))\n\ngoal (2 subgoals):\n 1. invertible A \\<Longrightarrow> det A dvd (1::'a)\n 2. det A dvd (1::'a) \\<Longrightarrow> invertible A", "have \"... = det (A ** B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat (1::'a)) = det (A ** B)", "unfolding AB_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat (1::'a)) = det (mat (1::'a))", ".."], ["proof (state)\nthis:\n  det (mat (1::'a)) = det (A ** B)\n\ngoal (2 subgoals):\n 1. invertible A \\<Longrightarrow> det A dvd (1::'a)\n 2. det A dvd (1::'a) \\<Longrightarrow> invertible A", "also"], ["proof (state)\nthis:\n  det (mat (1::'a)) = det (A ** B)\n\ngoal (2 subgoals):\n 1. invertible A \\<Longrightarrow> det A dvd (1::'a)\n 2. det A dvd (1::'a) \\<Longrightarrow> invertible A", "have \"... = det A * det B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (A ** B) = det A * det B", "unfolding det_mul"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A * det B = det A * det B", ".."], ["proof (state)\nthis:\n  det (A ** B) = det A * det B\n\ngoal (2 subgoals):\n 1. invertible A \\<Longrightarrow> det A dvd (1::'a)\n 2. det A dvd (1::'a) \\<Longrightarrow> invertible A", "finally"], ["proof (chain)\npicking this:\n  (1::'a) = det A * det B", "have \"1 = det A * det B\""], ["proof (prove)\nusing this:\n  (1::'a) = det A * det B\n\ngoal (1 subgoal):\n 1. (1::'a) = det A * det B", "by simp"], ["proof (state)\nthis:\n  (1::'a) = det A * det B\n\ngoal (2 subgoals):\n 1. invertible A \\<Longrightarrow> det A dvd (1::'a)\n 2. det A dvd (1::'a) \\<Longrightarrow> invertible A", "thus \"(det A) dvd 1\""], ["proof (prove)\nusing this:\n  (1::'a) = det A * det B\n\ngoal (1 subgoal):\n 1. det A dvd (1::'a)", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  (1::'a) = det A * det B\n\ngoal (1 subgoal):\n 1. \\<exists>k. (1::'a) = det A * k", "by auto"], ["proof (state)\nthis:\n  det A dvd (1::'a)\n\ngoal (1 subgoal):\n 1. det A dvd (1::'a) \\<Longrightarrow> invertible A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. det A dvd (1::'a) \\<Longrightarrow> invertible A", "assume det_unit: \"(det A) dvd 1\""], ["proof (state)\nthis:\n  det A dvd (1::'a)\n\ngoal (1 subgoal):\n 1. det A dvd (1::'a) \\<Longrightarrow> invertible A", "from this"], ["proof (chain)\npicking this:\n  det A dvd (1::'a)", "obtain a where a: \"(det A) * a = 1\""], ["proof (prove)\nusing this:\n  det A dvd (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        det A * a = (1::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. (1::'a) = det A * k\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        det A * a = (1::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  det A * a = (1::'a)\n\ngoal (1 subgoal):\n 1. det A dvd (1::'a) \\<Longrightarrow> invertible A", "let ?A = \"to_vec (Square_Matrix.adjugate (from_vec A))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A dvd (1::'a) \\<Longrightarrow> invertible A", "show \"invertible A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible A", "proof (unfold invertible_def, rule exI[of _ \"a *k ?A\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. A ** (a *k to_vec (Square_Matrix.adjugate (from_vec A))) =\n    mat (1::'a) \\<and>\n    a *k to_vec (Square_Matrix.adjugate (from_vec A)) ** A = mat (1::'a)", "have \"from_vec A * (a *\\<^sub>S Square_Matrix.adjugate (from_vec A)) = 1\"\n      \"(a *\\<^sub>S Square_Matrix.adjugate (from_vec A)) * from_vec A = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_vec A * a *\\<^sub>S Square_Matrix.adjugate (from_vec A) = 1 &&&\n    a *\\<^sub>S Square_Matrix.adjugate (from_vec A) * from_vec A = 1", "using a"], ["proof (prove)\nusing this:\n  det A * a = (1::'a)\n\ngoal (1 subgoal):\n 1. from_vec A * a *\\<^sub>S Square_Matrix.adjugate (from_vec A) = 1 &&&\n    a *\\<^sub>S Square_Matrix.adjugate (from_vec A) * from_vec A = 1", "unfolding smult_mult2[symmetric] mult_adjugate_det[of \"from_vec A\"] smult_diag det_sq_matrix_eq\n         smult_mult1[symmetric] adjugate_mult_det[of \"from_vec A\"]"], ["proof (prove)\nusing this:\n  det A * a = (1::'a)\n\ngoal (1 subgoal):\n 1. diag (a * det A) = 1 &&& diag (a * det A) = 1", "by (simp_all add: ac_simps diag_1)"], ["proof (state)\nthis:\n  from_vec A * a *\\<^sub>S Square_Matrix.adjugate (from_vec A) = 1\n  a *\\<^sub>S Square_Matrix.adjugate (from_vec A) * from_vec A = 1\n\ngoal (1 subgoal):\n 1. A ** (a *k to_vec (Square_Matrix.adjugate (from_vec A))) =\n    mat (1::'a) \\<and>\n    a *k to_vec (Square_Matrix.adjugate (from_vec A)) ** A = mat (1::'a)", "then"], ["proof (chain)\npicking this:\n  from_vec A * a *\\<^sub>S Square_Matrix.adjugate (from_vec A) = 1\n  a *\\<^sub>S Square_Matrix.adjugate (from_vec A) * from_vec A = 1", "show \"A ** (a *k ?A) = mat 1 \\<and> a *k ?A ** A = mat 1\""], ["proof (prove)\nusing this:\n  from_vec A * a *\\<^sub>S Square_Matrix.adjugate (from_vec A) = 1\n  a *\\<^sub>S Square_Matrix.adjugate (from_vec A) * from_vec A = 1\n\ngoal (1 subgoal):\n 1. A ** (a *k to_vec (Square_Matrix.adjugate (from_vec A))) =\n    mat (1::'a) \\<and>\n    a *k to_vec (Square_Matrix.adjugate (from_vec A)) ** A = mat (1::'a)", "unfolding to_vec_eq_iff[symmetric] to_vec_matrix_matrix_mult to_vec_matrix_scalar_mult\n        to_vec_from_vec to_vec_one"], ["proof (prove)\nusing this:\n  A ** (a *k to_vec (Square_Matrix.adjugate (from_vec A))) = mat (1::'a)\n  a *k to_vec (Square_Matrix.adjugate (from_vec A)) ** A = mat (1::'a)\n\ngoal (1 subgoal):\n 1. A ** (a *k to_vec (Square_Matrix.adjugate (from_vec A))) =\n    mat (1::'a) \\<and>\n    a *k to_vec (Square_Matrix.adjugate (from_vec A)) ** A = mat (1::'a)", "by simp"], ["proof (state)\nthis:\n  A ** (a *k to_vec (Square_Matrix.adjugate (from_vec A))) =\n  mat (1::'a) \\<and>\n  a *k to_vec (Square_Matrix.adjugate (from_vec A)) ** A = mat (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invertible A\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"minorM M i j = (\\<chi> k l. if k = i \\<and> l = j then 1 else if k = i \\<or> l = j then 0 else M $ k $ l)\""], ["", "lemma minorM_eq: \"minorM M i j = to_vec (minor (from_vec M) i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minorM M i j = to_vec (minor (from_vec M) i j)", "unfolding minorM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>k l.\n        if k = i \\<and> l = j then 1::'a\n        else if k = i \\<or> l = j then 0::'a else M $ k $ l) =\n    to_vec (minor (from_vec M) i j)", "by transfer standard"], ["", "definition cofactor where \"cofactor A i j = det (minorM A i j)\""], ["", "definition cofactorM where \"cofactorM A = (\\<chi> i j. cofactor A i j)\""], ["", "lemma cofactorM_eq: \"cofactorM = to_vec \\<circ> Square_Matrix.cofactor \\<circ> from_vec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cofactorM = to_vec \\<circ> Square_Matrix.cofactor \\<circ> from_vec", "unfolding cofactorM_def cofactor_def[abs_def] det_sq_matrix_eq[symmetric] minorM_eq fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<chi>i j.\n           Square_Matrix.det (from_vec (to_vec (minor (from_vec x) i j)))) =\n       (to_vec \\<circ> Square_Matrix.cofactor \\<circ> from_vec) x", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<chi>i j.\n           Square_Matrix.det (from_vec (to_vec (minor (from_vec x) i j)))) =\n       (to_vec \\<circ> Square_Matrix.cofactor \\<circ> from_vec) x", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<chi>i j.\n           \\<Sum>p | p permutes UNIV.\n             of_int (sign p) *\n             (\\<Prod>ia\\<in>UNIV.\n                (\\<chi>ia ja.\n                    if ia = i \\<and> ja = j then 1::'a\n                    else if ia = i \\<or> ja = j then 0::'a\n                         else x $ ia $ ja) $\n                ia $\n                p ia)) =\n       ((\\<lambda>M. \\<chi>i. vec_lambda (M i)) \\<circ>\n        (\\<lambda>A i j. Square_Matrix.det (minor A i j)) \\<circ>\n        from_vec)\n        x", "apply (simp add: fun_eq_iff vec_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i ia.\n          (\\<Sum>p | p permutes UNIV.\n             of_int (sign p) *\n             (\\<Prod>ib\\<in>UNIV.\n                if ib = i \\<and> p ib = ia then 1::'a\n                else if ib = i \\<or> p ib = ia then 0::'a\n                     else x $ ib $ p ib)) =\n          Square_Matrix.det (minor (from_vec x) i ia)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i ia.\n          (\\<Sum>p | p permutes UNIV.\n             of_int (sign p) *\n             (\\<Prod>ib\\<in>UNIV.\n                if ib = i \\<and> p ib = ia then 1::'a\n                else if ib = i \\<or> p ib = ia then 0::'a\n                     else x $ ib $ p ib)) =\n          (\\<Sum>p | p permutes UNIV.\n             of_int (sign p) *\n             (\\<Prod>ib\\<in>UNIV.\n                if ib = i \\<and> p ib = ia then 1::'a\n                else if ib = i \\<or> p ib = ia then 0::'a\n                     else x $ ib $ p ib))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition mat2matofpoly where \"mat2matofpoly A = (\\<chi> i j. [: A $ i $ j :])\""], ["", "definition charpoly where charpoly_def: \"charpoly A = det (mat (monom 1 (Suc 0)) - mat2matofpoly A)\""], ["", "lemma charpoly_eq: \"charpoly A = Cayley_Hamilton.charpoly (from_vec A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cayley_Hamilton_Compatible.charpoly A =\n    Cayley_Hamilton.charpoly (from_vec A)", "unfolding charpoly_def Cayley_Hamilton.charpoly_def det_sq_matrix_eq[symmetric] X_def C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det\n     (from_vec (mat (monom (1::'a) (Suc 0)) - mat2matofpoly A)) =\n    Square_Matrix.det\n     (diag [:0::'a, 1::'a:] -\n      map_sq_matrix (\\<lambda>c. [:c:]) (from_vec A))", "apply (intro arg_cong[where f=Square_Matrix.det])"], ["proof (prove)\ngoal (1 subgoal):\n 1. from_vec (mat (monom (1::'a) (Suc 0)) - mat2matofpoly A) =\n    diag [:0::'a, 1::'a:] - map_sq_matrix (\\<lambda>c. [:c:]) (from_vec A)", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<lambda>i.\n           ($) ((mat (monom (1::'a) (Suc 0)) - mat2matofpoly A) $ i)) =\n       (\\<lambda>i j.\n           (if i = j then [:0::'a, 1::'a:] else 0) - [:A $ i $ j:])", "apply (simp add: fun_eq_iff mat_def mat2matofpoly_def C_def monom_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition adjugate where \"adjugate A = transpose (cofactorM A)\""], ["", "lemma adjugate_eq: \"adjugate = to_vec \\<circ> Square_Matrix.adjugate \\<circ> from_vec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjugate = to_vec \\<circ> Square_Matrix.adjugate \\<circ> from_vec", "apply (simp add: adjugate_def Square_Matrix.adjugate_def fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       Finite_Cartesian_Product.transpose (cofactorM x) =\n       to_vec\n        (Square_Matrix.transpose (Square_Matrix.cofactor (from_vec x)))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Finite_Cartesian_Product.transpose (cofactorM x) =\n       to_vec\n        (Square_Matrix.transpose (Square_Matrix.cofactor (from_vec x)))", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Finite_Cartesian_Product.transpose (cofactorM x) =\n       (\\<chi>i j. Square_Matrix.det (minor (from_vec x) j i))", "apply (simp add: transpose_def cofactorM_eq to_vec.rep_eq\n    Square_Matrix.cofactor.rep_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}