{"file_name": "/home/qj213/afp-2021-10-22/thys/Echelon_Form/Echelon_Form_IArrays.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Echelon_Form", "problem_names": ["lemma matrix_to_iarray_bezout_matrix:\n  shows \"matrix_to_iarray (bezout_matrix A a b j bezout) \n  = bezout_matrix_iarrays (matrix_to_iarray A) (to_nat a) (to_nat b) (to_nat j) bezout\"\n  (is \"?lhs = ?rhs\")", "lemma matrix_to_iarray_bezout_iterate:\n  assumes n: \"n<nrows A\"\n  shows \"matrix_to_iarray (bezout_iterate A n i j bezout) \n  = bezout_iterate_iarrays (matrix_to_iarray A) n (to_nat i) (to_nat j) bezout\"", "lemma matrix_vector_all_zero_from_index2:\n  fixes A::\"'a::{zero}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"(\\<forall>m>i. A $ m $ k = 0) = vector_all_zero_from_index ((to_nat i)+1, vec_to_iarray (column k A))\"", "lemma matrix_to_iarray_echelon_form_of_column_k:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  and i: \"i\\<le>nrows A\"\n  shows \"matrix_to_iarray (fst ((echelon_form_of_column_k bezout) (A,i) k)) \n  = fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)\"", "lemma snd_matrix_to_iarray_echelon_form_of_column_k:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  and i: \"i\\<le>nrows A\"\n  shows \"snd ((echelon_form_of_column_k bezout) (A,i) k) \n  = fst (snd (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k))\"", "lemma snd_snd_foldl_echelon_form_of_column_k_iarrays:\n  \"snd (snd (foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A, 0, bezout) [0..<k])) \n  = bezout\"", "lemma foldl_echelon_form_column_k_eq:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  shows matrix_to_iarray_echelon_form_of_upt_k[code_unfold]: \n  \"matrix_to_iarray (echelon_form_of_upt_k A k bezout)\n  = echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout\"\n  and fst_foldl_ef_k_eq: \"fst (snd (foldl echelon_form_of_column_k_iarrays \n  (matrix_to_iarray A,0,bezout) [0..<Suc k])) \n  = snd (foldl (echelon_form_of_column_k bezout) (A,0) [0..<Suc k])\"\n  and fst_foldl_ef_k_less:\n  \"snd (foldl (echelon_form_of_column_k bezout) (A,0) [0..<Suc k]) \\<le> nrows A\"", "lemma matrix_to_iarray_echelon_form_of[code_unfold]:\n  \"matrix_to_iarray (echelon_form_of A bezout) \n    = echelon_form_of_iarrays (matrix_to_iarray A) bezout\""], "translations": [["", "lemma matrix_to_iarray_bezout_matrix:\n  shows \"matrix_to_iarray (bezout_matrix A a b j bezout) \n  = bezout_matrix_iarrays (matrix_to_iarray A) (to_nat a) (to_nat b) (to_nat j) bezout\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_matrix A a b j bezout) =\n    bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat a)\n     (mod_type_class.to_nat b) (mod_type_class.to_nat j) bezout", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_matrix A a b j bezout) =\n    bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat a)\n     (mod_type_class.to_nat b) (mod_type_class.to_nat j) bezout", "have n: \"nrows_iarray (IArray (map (vec_to_iarray \\<circ> ($) A \\<circ> from_nat) [0..<CARD('b)])) \n    = CARD('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows_iarray\n     (IArray\n       (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat)\n         [0..<CARD('b)])) =\n    CARD('b)", "unfolding nrows_iarray_def vec_to_iarray_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                IArray.of_fun\n                 (\\<lambda>i.\n                     A $ mod_type_class.from_nat x $\n                     mod_type_class.from_nat i)\n                 CARD('c))\n         [0..<CARD('b)])) =\n    CARD('b)", "by auto"], ["proof (state)\nthis:\n  nrows_iarray\n   (IArray\n     (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat)\n       [0..<CARD('b)])) =\n  CARD('b)\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_matrix A a b j bezout) =\n    bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat a)\n     (mod_type_class.to_nat b) (mod_type_class.to_nat j) bezout", "have rw1:\"(map (\\<lambda>x. IArray.of_fun \n    (\\<lambda>i. A $ from_nat x $ from_nat i) CARD('c)) [0..<CARD('b)] ! to_nat a !! to_nat j) = A $ a $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x.\n            IArray.of_fun\n             (\\<lambda>i.\n                 A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n             CARD('c))\n     [0..<CARD('b)] !\n    mod_type_class.to_nat a !!\n    mod_type_class.to_nat j =\n    A $ a $ j", "by (metis (erased, lifting) from_nat_to_nat_id length_upt minus_nat.diff_0 nth_map \n      nth_upt of_fun_nth plus_nat.add_0 to_nat_less_card)"], ["proof (state)\nthis:\n  map (\\<lambda>x.\n          IArray.of_fun\n           (\\<lambda>i.\n               A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n           CARD('c))\n   [0..<CARD('b)] !\n  mod_type_class.to_nat a !!\n  mod_type_class.to_nat j =\n  A $ a $ j\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_matrix A a b j bezout) =\n    bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat a)\n     (mod_type_class.to_nat b) (mod_type_class.to_nat j) bezout", "have rw2: \"(map (\\<lambda>x. IArray.of_fun \n    (\\<lambda>i. A $ from_nat x $ from_nat i) CARD('c)) [0..<CARD('b)] ! to_nat b !! to_nat j) = (A $ b $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x.\n            IArray.of_fun\n             (\\<lambda>i.\n                 A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n             CARD('c))\n     [0..<CARD('b)] !\n    mod_type_class.to_nat b !!\n    mod_type_class.to_nat j =\n    A $ b $ j", "by (metis (erased, lifting) from_nat_to_nat_id length_upt minus_nat.diff_0 nth_map \n      nth_upt of_fun_nth plus_nat.add_0 to_nat_less_card)"], ["proof (state)\nthis:\n  map (\\<lambda>x.\n          IArray.of_fun\n           (\\<lambda>i.\n               A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n           CARD('c))\n   [0..<CARD('b)] !\n  mod_type_class.to_nat b !!\n  mod_type_class.to_nat j =\n  A $ b $ j\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_matrix A a b j bezout) =\n    bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat a)\n     (mod_type_class.to_nat b) (mod_type_class.to_nat j) bezout", "have rw3: \"IArray (map (\\<lambda>x. IArray.of_fun \n    (\\<lambda>i. A $ from_nat x $ from_nat i) CARD('c)) [0..<CARD('b)]) !! to_nat a !! to_nat j = A $ a $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>i.\n                   A $ mod_type_class.from_nat x $\n                   mod_type_class.from_nat i)\n               CARD('c))\n       [0..<CARD('b)]) !!\n    mod_type_class.to_nat a !!\n    mod_type_class.to_nat j =\n    A $ a $ j", "by (metis IArray.sub_def list_of.simps rw1)"], ["proof (state)\nthis:\n  IArray\n   (map (\\<lambda>x.\n            IArray.of_fun\n             (\\<lambda>i.\n                 A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n             CARD('c))\n     [0..<CARD('b)]) !!\n  mod_type_class.to_nat a !!\n  mod_type_class.to_nat j =\n  A $ a $ j\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_matrix A a b j bezout) =\n    bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat a)\n     (mod_type_class.to_nat b) (mod_type_class.to_nat j) bezout", "have rw4: \"IArray (map (\\<lambda>x. IArray.of_fun\n    (\\<lambda>i. A $ from_nat x $ from_nat i) CARD('c)) [0..<CARD('b)]) !! to_nat b !! to_nat j = A $ b $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>i.\n                   A $ mod_type_class.from_nat x $\n                   mod_type_class.from_nat i)\n               CARD('c))\n       [0..<CARD('b)]) !!\n    mod_type_class.to_nat b !!\n    mod_type_class.to_nat j =\n    A $ b $ j", "by (metis IArray.sub_def list_of.simps rw2)"], ["proof (state)\nthis:\n  IArray\n   (map (\\<lambda>x.\n            IArray.of_fun\n             (\\<lambda>i.\n                 A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n             CARD('c))\n     [0..<CARD('b)]) !!\n  mod_type_class.to_nat b !!\n  mod_type_class.to_nat j =\n  A $ b $ j\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_matrix A a b j bezout) =\n    bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat a)\n     (mod_type_class.to_nat b) (mod_type_class.to_nat j) bezout", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_matrix A a b j bezout) =\n    bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat a)\n     (mod_type_class.to_nat b) (mod_type_class.to_nat j) bezout", "unfolding matrix_to_iarray_def bezout_matrix_iarrays_def tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (vec_to_iarray \\<circ> ($) (bezout_matrix A a b j bezout) \\<circ>\n           mod_type_class.from_nat)\n       [0..<CARD('b)]) =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          ((let (p, q, u, v, d) =\n                  bezout\n                   (IArray\n                     (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                           mod_type_class.from_nat)\n                       [0..<CARD('b)]) !!\n                    mod_type_class.to_nat a !!\n                    mod_type_class.to_nat j)\n                   (IArray\n                     (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                           mod_type_class.from_nat)\n                       [0..<CARD('b)]) !!\n                    mod_type_class.to_nat b !!\n                    mod_type_class.to_nat j)\n            in (\\<lambda>x y.\n                   if x = mod_type_class.to_nat a \\<and>\n                      y = mod_type_class.to_nat a\n                   then p\n                   else if x = mod_type_class.to_nat a \\<and>\n                           y = mod_type_class.to_nat b\n                        then q\n                        else if x = mod_type_class.to_nat b \\<and>\n                                y = mod_type_class.to_nat a\n                             then u\n                             else if x = mod_type_class.to_nat b \\<and>\n                                     y = mod_type_class.to_nat b\n                                  then v\n                                  else if x = y then 1::'a else (0::'a)))\n            i)\n          (nrows_iarray\n            (IArray\n              (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                    mod_type_class.from_nat)\n                [0..<CARD('b)]))))\n     (nrows_iarray\n       (IArray\n         (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat)\n           [0..<CARD('b)])))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (vec_to_iarray \\<circ> ($) (bezout_matrix A a b j bezout) \\<circ>\n         mod_type_class.from_nat)\n     [0..<CARD('b)] =\n    map (\\<lambda>i.\n            IArray\n             (map ((case bezout\n                          (IArray.list_of\n                            (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                                  mod_type_class.from_nat)\n                              [0..<CARD('b)] !\n                             mod_type_class.to_nat a) !\n                           mod_type_class.to_nat j)\n                          (IArray.list_of\n                            (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                                  mod_type_class.from_nat)\n                              [0..<CARD('b)] !\n                             mod_type_class.to_nat b) !\n                           mod_type_class.to_nat j) of\n                    (p, q, u, v, d) \\<Rightarrow>\n                      \\<lambda>x y.\n                         if x = mod_type_class.to_nat a \\<and>\n                            y = mod_type_class.to_nat a\n                         then p\n                         else if x = mod_type_class.to_nat a \\<and>\n                                 y = mod_type_class.to_nat b\n                              then q\n                              else if x = mod_type_class.to_nat b \\<and>\ny = mod_type_class.to_nat a\n                                   then u\n                                   else if x =\n     mod_type_class.to_nat b \\<and>\n     y = mod_type_class.to_nat b\n  then v else if x = y then 1::'a else (0::'a))\n                    i)\n               [0..<\n                nrows_iarray\n                 (IArray\n                   (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                         mod_type_class.from_nat)\n                     [0..<CARD('b)]))]))\n     [0..<\n      nrows_iarray\n       (IArray\n         (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat)\n           [0..<CARD('b)]))]", "unfolding n"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (vec_to_iarray \\<circ> ($) (bezout_matrix A a b j bezout) \\<circ>\n         mod_type_class.from_nat)\n     [0..<CARD('b)] =\n    map (\\<lambda>i.\n            IArray\n             (map ((case bezout\n                          (IArray.list_of\n                            (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                                  mod_type_class.from_nat)\n                              [0..<CARD('b)] !\n                             mod_type_class.to_nat a) !\n                           mod_type_class.to_nat j)\n                          (IArray.list_of\n                            (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                                  mod_type_class.from_nat)\n                              [0..<CARD('b)] !\n                             mod_type_class.to_nat b) !\n                           mod_type_class.to_nat j) of\n                    (p, q, u, v, d) \\<Rightarrow>\n                      \\<lambda>x y.\n                         if x = mod_type_class.to_nat a \\<and>\n                            y = mod_type_class.to_nat a\n                         then p\n                         else if x = mod_type_class.to_nat a \\<and>\n                                 y = mod_type_class.to_nat b\n                              then q\n                              else if x = mod_type_class.to_nat b \\<and>\ny = mod_type_class.to_nat a\n                                   then u\n                                   else if x =\n     mod_type_class.to_nat b \\<and>\n     y = mod_type_class.to_nat b\n  then v else if x = y then 1::'a else (0::'a))\n                    i)\n               [0..<CARD('b)]))\n     [0..<CARD('b)]", "apply (rule map_ext, auto simp add: bezout_matrix_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < CARD('b) \\<Longrightarrow>\n       vec_to_iarray\n        (\\<chi>y.\n            case bezout (A $ a $ j) (A $ b $ j) of\n            (p, q, u, v, d) \\<Rightarrow>\n              if mod_type_class.from_nat x = a \\<and> y = a then p\n              else if mod_type_class.from_nat x = a \\<and> y = b then q\n                   else if mod_type_class.from_nat x = b \\<and> y = a then u\n                        else if mod_type_class.from_nat x = b \\<and> y = b\n                             then v\n                             else if mod_type_class.from_nat x = y\n                                  then 1::'a else (0::'a)) =\n       IArray\n        (map ((case bezout\n                     (IArray.list_of\n                       (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                             mod_type_class.from_nat)\n                         [0..<CARD('b)] !\n                        mod_type_class.to_nat a) !\n                      mod_type_class.to_nat j)\n                     (IArray.list_of\n                       (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                             mod_type_class.from_nat)\n                         [0..<CARD('b)] !\n                        mod_type_class.to_nat b) !\n                      mod_type_class.to_nat j) of\n               (p, q, u, v, d) \\<Rightarrow>\n                 \\<lambda>x y.\n                    if x = mod_type_class.to_nat a \\<and>\n                       y = mod_type_class.to_nat a\n                    then p\n                    else if x = mod_type_class.to_nat a \\<and>\n                            y = mod_type_class.to_nat b\n                         then q\n                         else if x = mod_type_class.to_nat b \\<and>\n                                 y = mod_type_class.to_nat a\n                              then u\n                              else if x = mod_type_class.to_nat b \\<and>\ny = mod_type_class.to_nat b\n                                   then v\n                                   else if x = y then 1::'a else (0::'a))\n               x)\n          [0..<CARD('b)])", "unfolding o_def vec_to_iarray_def  Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < CARD('b) \\<Longrightarrow>\n       IArray.of_fun\n        (\\<lambda>i.\n            (\\<chi>y.\n                case bezout (A $ a $ j) (A $ b $ j) of\n                (p, q, u, v, d) \\<Rightarrow>\n                  if mod_type_class.from_nat x = a \\<and> y = a then p\n                  else if mod_type_class.from_nat x = a \\<and> y = b then q\n                       else if mod_type_class.from_nat x = b \\<and> y = a\n                            then u\n                            else if mod_type_class.from_nat x = b \\<and>\n                                    y = b\n                                 then v\n                                 else if mod_type_class.from_nat x = y\nthen 1::'a else (0::'a)) $\n            mod_type_class.from_nat i)\n        CARD('b) =\n       IArray\n        (map ((case bezout\n                     (IArray.list_of\n                       (map (\\<lambda>x.\n                                IArray.of_fun\n                                 (\\<lambda>i.\n                                     A $ mod_type_class.from_nat x $\n                                     mod_type_class.from_nat i)\n                                 CARD('c))\n                         [0..<CARD('b)] !\n                        mod_type_class.to_nat a) !\n                      mod_type_class.to_nat j)\n                     (IArray.list_of\n                       (map (\\<lambda>x.\n                                IArray.of_fun\n                                 (\\<lambda>i.\n                                     A $ mod_type_class.from_nat x $\n                                     mod_type_class.from_nat i)\n                                 CARD('c))\n                         [0..<CARD('b)] !\n                        mod_type_class.to_nat b) !\n                      mod_type_class.to_nat j) of\n               (p, q, u, v, d) \\<Rightarrow>\n                 \\<lambda>x y.\n                    if x = mod_type_class.to_nat a \\<and>\n                       y = mod_type_class.to_nat a\n                    then p\n                    else if x = mod_type_class.to_nat a \\<and>\n                            y = mod_type_class.to_nat b\n                         then q\n                         else if x = mod_type_class.to_nat b \\<and>\n                                 y = mod_type_class.to_nat a\n                              then u\n                              else if x = mod_type_class.to_nat b \\<and>\ny = mod_type_class.to_nat b\n                                   then v\n                                   else if x = y then 1::'a else (0::'a))\n               x)\n          [0..<CARD('b)])", "unfolding IArray.sub_def[symmetric] rw1 rw2 rw3 rw4"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < CARD('b) \\<Longrightarrow>\n       IArray.of_fun\n        (\\<lambda>i.\n            (\\<chi>y.\n                case bezout (A $ a $ j) (A $ b $ j) of\n                (p, q, u, v, d) \\<Rightarrow>\n                  if mod_type_class.from_nat x = a \\<and> y = a then p\n                  else if mod_type_class.from_nat x = a \\<and> y = b then q\n                       else if mod_type_class.from_nat x = b \\<and> y = a\n                            then u\n                            else if mod_type_class.from_nat x = b \\<and>\n                                    y = b\n                                 then v\n                                 else if mod_type_class.from_nat x = y\nthen 1::'a else (0::'a)) $\n            mod_type_class.from_nat i)\n        CARD('b) =\n       IArray\n        (map ((case bezout (A $ a $ j) (A $ b $ j) of\n               (p, q, u, v, d) \\<Rightarrow>\n                 \\<lambda>x y.\n                    if x = mod_type_class.to_nat a \\<and>\n                       y = mod_type_class.to_nat a\n                    then p\n                    else if x = mod_type_class.to_nat a \\<and>\n                            y = mod_type_class.to_nat b\n                         then q\n                         else if x = mod_type_class.to_nat b \\<and>\n                                 y = mod_type_class.to_nat a\n                              then u\n                              else if x = mod_type_class.to_nat b \\<and>\ny = mod_type_class.to_nat b\n                                   then v\n                                   else if x = y then 1::'a else (0::'a))\n               x)\n          [0..<CARD('b)])", "unfolding IArray.of_fun_def iarray.inject"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < CARD('b) \\<Longrightarrow>\n       map (\\<lambda>i.\n               (\\<chi>y.\n                   case bezout (A $ a $ j) (A $ b $ j) of\n                   (p, q, u, v, d) \\<Rightarrow>\n                     if mod_type_class.from_nat x = a \\<and> y = a then p\n                     else if mod_type_class.from_nat x = a \\<and> y = b\n                          then q\n                          else if mod_type_class.from_nat x = b \\<and> y = a\n                               then u\n                               else if mod_type_class.from_nat x = b \\<and>\n y = b\n                                    then v\n                                    else if mod_type_class.from_nat x = y\n   then 1::'a else (0::'a)) $\n               mod_type_class.from_nat i)\n        [0..<CARD('b)] =\n       map ((case bezout (A $ a $ j) (A $ b $ j) of\n             (p, q, u, v, d) \\<Rightarrow>\n               \\<lambda>x y.\n                  if x = mod_type_class.to_nat a \\<and>\n                     y = mod_type_class.to_nat a\n                  then p\n                  else if x = mod_type_class.to_nat a \\<and>\n                          y = mod_type_class.to_nat b\n                       then q\n                       else if x = mod_type_class.to_nat b \\<and>\n                               y = mod_type_class.to_nat a\n                            then u\n                            else if x = mod_type_class.to_nat b \\<and>\n                                    y = mod_type_class.to_nat b\n                                 then v\n                                 else if x = y then 1::'a else (0::'a))\n             x)\n        [0..<CARD('b)]", "apply (rule map_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       x < CARD('b) \\<Longrightarrow>\n       xa \\<in> set [0..<CARD('b)] \\<longrightarrow>\n       (\\<chi>y.\n           case bezout (A $ a $ j) (A $ b $ j) of\n           (p, q, u, v, d) \\<Rightarrow>\n             if mod_type_class.from_nat x = a \\<and> y = a then p\n             else if mod_type_class.from_nat x = a \\<and> y = b then q\n                  else if mod_type_class.from_nat x = b \\<and> y = a then u\n                       else if mod_type_class.from_nat x = b \\<and> y = b\n                            then v\n                            else if mod_type_class.from_nat x = y then 1::'a\n                                 else (0::'a)) $\n       mod_type_class.from_nat xa =\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          \\<lambda>x y.\n             if x = mod_type_class.to_nat a \\<and>\n                y = mod_type_class.to_nat a\n             then p\n             else if x = mod_type_class.to_nat a \\<and>\n                     y = mod_type_class.to_nat b\n                  then q\n                  else if x = mod_type_class.to_nat b \\<and>\n                          y = mod_type_class.to_nat a\n                       then u\n                       else if x = mod_type_class.to_nat b \\<and>\n                               y = mod_type_class.to_nat b\n                            then v else if x = y then 1::'a else (0::'a))\n        x xa", "unfolding vec_lambda_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       x < CARD('b) \\<Longrightarrow>\n       xa \\<in> set [0..<CARD('b)] \\<longrightarrow>\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if mod_type_class.from_nat x = a \\<and>\n             mod_type_class.from_nat xa = a\n          then p\n          else if mod_type_class.from_nat x = a \\<and>\n                  mod_type_class.from_nat xa = b\n               then q\n               else if mod_type_class.from_nat x = b \\<and>\n                       mod_type_class.from_nat xa = a\n                    then u\n                    else if mod_type_class.from_nat x = b \\<and>\n                            mod_type_class.from_nat xa = b\n                         then v\n                         else if mod_type_class.from_nat x =\n                                 mod_type_class.from_nat xa\n                              then 1::'a else (0::'a)) =\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          \\<lambda>x y.\n             if x = mod_type_class.to_nat a \\<and>\n                y = mod_type_class.to_nat a\n             then p\n             else if x = mod_type_class.to_nat a \\<and>\n                     y = mod_type_class.to_nat b\n                  then q\n                  else if x = mod_type_class.to_nat b \\<and>\n                          y = mod_type_class.to_nat a\n                       then u\n                       else if x = mod_type_class.to_nat b \\<and>\n                               y = mod_type_class.to_nat b\n                            then v else if x = y then 1::'a else (0::'a))\n        x xa", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "fix x xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "assume x: \"x < CARD('b)\""], ["proof (state)\nthis:\n  x < CARD('b)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "assume \"xa \\<in> set [0..<CARD('b)]\""], ["proof (state)\nthis:\n  xa \\<in> set [0..<CARD('b)]\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "hence xa: \"xa < CARD('b)\""], ["proof (prove)\nusing this:\n  xa \\<in> set [0..<CARD('b)]\n\ngoal (1 subgoal):\n 1. xa < CARD('b)", "using atLeast_upt"], ["proof (prove)\nusing this:\n  xa \\<in> set [0..<CARD('b)]\n  {..<?n} = set [0..<?n]\n\ngoal (1 subgoal):\n 1. xa < CARD('b)", "by blast"], ["proof (state)\nthis:\n  xa < CARD('b)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "have rw5: \"(from_nat x = a) = (x = to_nat a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_type_class.from_nat x = a) = (x = mod_type_class.to_nat a)", "using x from_nat_not_eq from_nat_to_nat_id"], ["proof (prove)\nusing this:\n  x < CARD('b)\n  \\<lbrakk>?a \\<noteq> mod_type_class.to_nat ?b; ?a < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat ?a \\<noteq> ?b\n  mod_type_class.from_nat (mod_type_class.to_nat ?x) = ?x\n\ngoal (1 subgoal):\n 1. (mod_type_class.from_nat x = a) = (x = mod_type_class.to_nat a)", "by blast"], ["proof (state)\nthis:\n  (mod_type_class.from_nat x = a) = (x = mod_type_class.to_nat a)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "have rw6: \"(from_nat x = b) = (x = to_nat b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_type_class.from_nat x = b) = (x = mod_type_class.to_nat b)", "by (metis x from_nat_to_nat_id to_nat_from_nat_id)"], ["proof (state)\nthis:\n  (mod_type_class.from_nat x = b) = (x = mod_type_class.to_nat b)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "have rw7: \"(from_nat xa = b) = (xa = to_nat b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_type_class.from_nat xa = b) = (xa = mod_type_class.to_nat b)", "by (metis xa from_nat_to_nat_id to_nat_from_nat_id)"], ["proof (state)\nthis:\n  (mod_type_class.from_nat xa = b) = (xa = mod_type_class.to_nat b)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "have rw8: \"((from_nat x::'b) = (from_nat xa::'b)) = (x = xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_type_class.from_nat x = mod_type_class.from_nat xa) = (x = xa)", "by (metis from_nat_not_eq x xa)"], ["proof (state)\nthis:\n  (mod_type_class.from_nat x = mod_type_class.from_nat xa) = (x = xa)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "have rw9: \"(from_nat xa = a) = (xa = to_nat a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_type_class.from_nat xa = a) = (xa = mod_type_class.to_nat a)", "by (metis from_nat_to_nat_id to_nat_from_nat_id xa)"], ["proof (state)\nthis:\n  (mod_type_class.from_nat xa = a) = (xa = mod_type_class.to_nat a)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "have cond01: \"(from_nat x = a \\<and> from_nat xa = a) == (x = to_nat a \\<and> xa = to_nat a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat x = a \\<and>\n    mod_type_class.from_nat xa = a \\<equiv>\n    x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a", "using rw5 rw9"], ["proof (prove)\nusing this:\n  (mod_type_class.from_nat x = a) = (x = mod_type_class.to_nat a)\n  (mod_type_class.from_nat xa = a) = (xa = mod_type_class.to_nat a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat x = a \\<and>\n    mod_type_class.from_nat xa = a \\<equiv>\n    x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat x = a \\<and>\n  mod_type_class.from_nat xa = a \\<equiv>\n  x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "have cond02: \"(from_nat x = a \\<and> from_nat xa = b) == (x = to_nat a \\<and> xa = to_nat b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat x = a \\<and>\n    mod_type_class.from_nat xa = b \\<equiv>\n    x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b", "using rw5 rw7"], ["proof (prove)\nusing this:\n  (mod_type_class.from_nat x = a) = (x = mod_type_class.to_nat a)\n  (mod_type_class.from_nat xa = b) = (xa = mod_type_class.to_nat b)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat x = a \\<and>\n    mod_type_class.from_nat xa = b \\<equiv>\n    x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat x = a \\<and>\n  mod_type_class.from_nat xa = b \\<equiv>\n  x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "have cond03: \"(from_nat x = b \\<and> from_nat xa = a) == (x = to_nat b \\<and> xa = to_nat a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat x = b \\<and>\n    mod_type_class.from_nat xa = a \\<equiv>\n    x = mod_type_class.to_nat b \\<and> xa = mod_type_class.to_nat a", "using rw6 rw9"], ["proof (prove)\nusing this:\n  (mod_type_class.from_nat x = b) = (x = mod_type_class.to_nat b)\n  (mod_type_class.from_nat xa = a) = (xa = mod_type_class.to_nat a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat x = b \\<and>\n    mod_type_class.from_nat xa = a \\<equiv>\n    x = mod_type_class.to_nat b \\<and> xa = mod_type_class.to_nat a", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat x = b \\<and>\n  mod_type_class.from_nat xa = a \\<equiv>\n  x = mod_type_class.to_nat b \\<and> xa = mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "have cond04: \"(from_nat x = b \\<and> from_nat xa = b) == (x = to_nat b \\<and> xa = to_nat b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat x = b \\<and>\n    mod_type_class.from_nat xa = b \\<equiv>\n    x = mod_type_class.to_nat b \\<and> xa = mod_type_class.to_nat b", "using rw6 rw7"], ["proof (prove)\nusing this:\n  (mod_type_class.from_nat x = b) = (x = mod_type_class.to_nat b)\n  (mod_type_class.from_nat xa = b) = (xa = mod_type_class.to_nat b)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat x = b \\<and>\n    mod_type_class.from_nat xa = b \\<equiv>\n    x = mod_type_class.to_nat b \\<and> xa = mod_type_class.to_nat b", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat x = b \\<and>\n  mod_type_class.from_nat xa = b \\<equiv>\n  x = mod_type_class.to_nat b \\<and> xa = mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "have cond05: \"((from_nat x::'b) = (from_nat xa::'b)) == (x = xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat x = mod_type_class.from_nat xa \\<equiv> x = xa", "using rw8"], ["proof (prove)\nusing this:\n  (mod_type_class.from_nat x = mod_type_class.from_nat xa) = (x = xa)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat x = mod_type_class.from_nat xa \\<equiv> x = xa", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat x = mod_type_class.from_nat xa \\<equiv> x = xa\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('b); xa \\<in> set [0..<CARD('b)]\\<rbrakk>\n       \\<Longrightarrow> (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            if mod_type_class.from_nat x = a \\<and>\n                               mod_type_class.from_nat xa = a\n                            then p\n                            else if mod_type_class.from_nat x = a \\<and>\n                                    mod_type_class.from_nat xa = b\n                                 then q\n                                 else if mod_type_class.from_nat x =\n   b \\<and>\n   mod_type_class.from_nat xa = a\nthen u\nelse if mod_type_class.from_nat x = b \\<and> mod_type_class.from_nat xa = b\n     then v\n     else if mod_type_class.from_nat x = mod_type_class.from_nat xa\n          then 1::'a else (0::'a)) =\n                         (case bezout (A $ a $ j) (A $ b $ j) of\n                          (p, q, u, v, d) \\<Rightarrow>\n                            \\<lambda>x y.\n                               if x = mod_type_class.to_nat a \\<and>\n                                  y = mod_type_class.to_nat a\n                               then p\n                               else if x = mod_type_class.to_nat a \\<and>\n y = mod_type_class.to_nat b\n                                    then q\n                                    else if x =\n      mod_type_class.to_nat b \\<and>\n      y = mod_type_class.to_nat a\n   then u\n   else if x = mod_type_class.to_nat b \\<and> y = mod_type_class.to_nat b\n        then v else if x = y then 1::'a else (0::'a))\n                          x xa", "show \"(case bezout (A $ a $ j) (A $ b $ j) of\n             (p, q, u, v, d) \\<Rightarrow>\n               if from_nat x = a \\<and> from_nat xa = a then p\n               else if from_nat x = a \\<and> from_nat xa = b then q\n                    else if from_nat x = b \\<and> from_nat xa = a then u\n                         else if from_nat x = b \\<and> from_nat xa = b then v\n                              else if (from_nat x::'b) = from_nat xa then 1 else 0) =\n            (case bezout (A $ a $ j) (A $ b $ j) of\n             (p, q, u, v, d) \\<Rightarrow>\n               \\<lambda>x y. if x = to_nat a \\<and> y = to_nat a then p\n                     else if x = to_nat a \\<and> y = to_nat b then q\n                          else if x = to_nat b \\<and> y = to_nat a then u\n                               else if x = to_nat b \\<and> y = to_nat b then v\n                                    else if x = y then 1 else 0)\n             x xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case bezout (A $ a $ j) (A $ b $ j) of\n     (p, q, u, v, d) \\<Rightarrow>\n       if mod_type_class.from_nat x = a \\<and>\n          mod_type_class.from_nat xa = a\n       then p\n       else if mod_type_class.from_nat x = a \\<and>\n               mod_type_class.from_nat xa = b\n            then q\n            else if mod_type_class.from_nat x = b \\<and>\n                    mod_type_class.from_nat xa = a\n                 then u\n                 else if mod_type_class.from_nat x = b \\<and>\n                         mod_type_class.from_nat xa = b\n                      then v\n                      else if mod_type_class.from_nat x =\n                              mod_type_class.from_nat xa\n                           then 1::'a else (0::'a)) =\n    (case bezout (A $ a $ j) (A $ b $ j) of\n     (p, q, u, v, d) \\<Rightarrow>\n       \\<lambda>x y.\n          if x = mod_type_class.to_nat a \\<and> y = mod_type_class.to_nat a\n          then p\n          else if x = mod_type_class.to_nat a \\<and>\n                  y = mod_type_class.to_nat b\n               then q\n               else if x = mod_type_class.to_nat b \\<and>\n                       y = mod_type_class.to_nat a\n                    then u\n                    else if x = mod_type_class.to_nat b \\<and>\n                            y = mod_type_class.to_nat b\n                         then v else if x = y then 1::'a else (0::'a))\n     x xa", "proof (cases \"bezout (A $ a $ j) (A $ b $ j)\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ba c d e.\n       bezout (A $ a $ j) (A $ b $ j) = (aa, ba, c, d, e) \\<Longrightarrow>\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if mod_type_class.from_nat x = a \\<and>\n             mod_type_class.from_nat xa = a\n          then p\n          else if mod_type_class.from_nat x = a \\<and>\n                  mod_type_class.from_nat xa = b\n               then q\n               else if mod_type_class.from_nat x = b \\<and>\n                       mod_type_class.from_nat xa = a\n                    then u\n                    else if mod_type_class.from_nat x = b \\<and>\n                            mod_type_class.from_nat xa = b\n                         then v\n                         else if mod_type_class.from_nat x =\n                                 mod_type_class.from_nat xa\n                              then 1::'a else (0::'a)) =\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          \\<lambda>x y.\n             if x = mod_type_class.to_nat a \\<and>\n                y = mod_type_class.to_nat a\n             then p\n             else if x = mod_type_class.to_nat a \\<and>\n                     y = mod_type_class.to_nat b\n                  then q\n                  else if x = mod_type_class.to_nat b \\<and>\n                          y = mod_type_class.to_nat a\n                       then u\n                       else if x = mod_type_class.to_nat b \\<and>\n                               y = mod_type_class.to_nat b\n                            then v else if x = y then 1::'a else (0::'a))\n        x xa", "fix p q u v d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ba c d e.\n       bezout (A $ a $ j) (A $ b $ j) = (aa, ba, c, d, e) \\<Longrightarrow>\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if mod_type_class.from_nat x = a \\<and>\n             mod_type_class.from_nat xa = a\n          then p\n          else if mod_type_class.from_nat x = a \\<and>\n                  mod_type_class.from_nat xa = b\n               then q\n               else if mod_type_class.from_nat x = b \\<and>\n                       mod_type_class.from_nat xa = a\n                    then u\n                    else if mod_type_class.from_nat x = b \\<and>\n                            mod_type_class.from_nat xa = b\n                         then v\n                         else if mod_type_class.from_nat x =\n                                 mod_type_class.from_nat xa\n                              then 1::'a else (0::'a)) =\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          \\<lambda>x y.\n             if x = mod_type_class.to_nat a \\<and>\n                y = mod_type_class.to_nat a\n             then p\n             else if x = mod_type_class.to_nat a \\<and>\n                     y = mod_type_class.to_nat b\n                  then q\n                  else if x = mod_type_class.to_nat b \\<and>\n                          y = mod_type_class.to_nat a\n                       then u\n                       else if x = mod_type_class.to_nat b \\<and>\n                               y = mod_type_class.to_nat b\n                            then v else if x = y then 1::'a else (0::'a))\n        x xa", "assume b: \"bezout (A $ a $ j) (A $ b $ j) = (p, q, u, v, d)\""], ["proof (state)\nthis:\n  bezout (A $ a $ j) (A $ b $ j) = (p, q, u, v, d)\n\ngoal (1 subgoal):\n 1. \\<And>aa ba c d e.\n       bezout (A $ a $ j) (A $ b $ j) = (aa, ba, c, d, e) \\<Longrightarrow>\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if mod_type_class.from_nat x = a \\<and>\n             mod_type_class.from_nat xa = a\n          then p\n          else if mod_type_class.from_nat x = a \\<and>\n                  mod_type_class.from_nat xa = b\n               then q\n               else if mod_type_class.from_nat x = b \\<and>\n                       mod_type_class.from_nat xa = a\n                    then u\n                    else if mod_type_class.from_nat x = b \\<and>\n                            mod_type_class.from_nat xa = b\n                         then v\n                         else if mod_type_class.from_nat x =\n                                 mod_type_class.from_nat xa\n                              then 1::'a else (0::'a)) =\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          \\<lambda>x y.\n             if x = mod_type_class.to_nat a \\<and>\n                y = mod_type_class.to_nat a\n             then p\n             else if x = mod_type_class.to_nat a \\<and>\n                     y = mod_type_class.to_nat b\n                  then q\n                  else if x = mod_type_class.to_nat b \\<and>\n                          y = mod_type_class.to_nat a\n                       then u\n                       else if x = mod_type_class.to_nat b \\<and>\n                               y = mod_type_class.to_nat b\n                            then v else if x = y then 1::'a else (0::'a))\n        x xa", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case bezout (A $ a $ j) (A $ b $ j) of\n     (p, q, u, v, d) \\<Rightarrow>\n       if mod_type_class.from_nat x = a \\<and>\n          mod_type_class.from_nat xa = a\n       then p\n       else if mod_type_class.from_nat x = a \\<and>\n               mod_type_class.from_nat xa = b\n            then q\n            else if mod_type_class.from_nat x = b \\<and>\n                    mod_type_class.from_nat xa = a\n                 then u\n                 else if mod_type_class.from_nat x = b \\<and>\n                         mod_type_class.from_nat xa = b\n                      then v\n                      else if mod_type_class.from_nat x =\n                              mod_type_class.from_nat xa\n                           then 1::'a else (0::'a)) =\n    (case bezout (A $ a $ j) (A $ b $ j) of\n     (p, q, u, v, d) \\<Rightarrow>\n       \\<lambda>x y.\n          if x = mod_type_class.to_nat a \\<and> y = mod_type_class.to_nat a\n          then p\n          else if x = mod_type_class.to_nat a \\<and>\n                  y = mod_type_class.to_nat b\n               then q\n               else if x = mod_type_class.to_nat b \\<and>\n                       y = mod_type_class.to_nat a\n                    then u\n                    else if x = mod_type_class.to_nat b \\<and>\n                            y = mod_type_class.to_nat b\n                         then v else if x = y then 1::'a else (0::'a))\n     x xa", "unfolding b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (p, q, u, v, d) of\n     (p, q, u, v, d) \\<Rightarrow>\n       if mod_type_class.from_nat x = a \\<and>\n          mod_type_class.from_nat xa = a\n       then p\n       else if mod_type_class.from_nat x = a \\<and>\n               mod_type_class.from_nat xa = b\n            then q\n            else if mod_type_class.from_nat x = b \\<and>\n                    mod_type_class.from_nat xa = a\n                 then u\n                 else if mod_type_class.from_nat x = b \\<and>\n                         mod_type_class.from_nat xa = b\n                      then v\n                      else if mod_type_class.from_nat x =\n                              mod_type_class.from_nat xa\n                           then 1::'a else (0::'a)) =\n    (case (p, q, u, v, d) of\n     (p, q, u, v, d) \\<Rightarrow>\n       \\<lambda>x y.\n          if x = mod_type_class.to_nat a \\<and> y = mod_type_class.to_nat a\n          then p\n          else if x = mod_type_class.to_nat a \\<and>\n                  y = mod_type_class.to_nat b\n               then q\n               else if x = mod_type_class.to_nat b \\<and>\n                       y = mod_type_class.to_nat a\n                    then u\n                    else if x = mod_type_class.to_nat b \\<and>\n                            y = mod_type_class.to_nat b\n                         then v else if x = y then 1::'a else (0::'a))\n     x xa", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if mod_type_class.from_nat x = a \\<and> mod_type_class.from_nat xa = a\n     then p\n     else if mod_type_class.from_nat x = a \\<and>\n             mod_type_class.from_nat xa = b\n          then q\n          else if mod_type_class.from_nat x = b \\<and>\n                  mod_type_class.from_nat xa = a\n               then u\n               else if mod_type_class.from_nat x = b \\<and>\n                       mod_type_class.from_nat xa = b\n                    then v\n                    else if mod_type_class.from_nat x =\n                            mod_type_class.from_nat xa\n                         then 1::'a else (0::'a)) =\n    (if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n     then p\n     else if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b\n          then q\n          else if x = mod_type_class.to_nat b \\<and>\n                  xa = mod_type_class.to_nat a\n               then u\n               else if x = mod_type_class.to_nat b \\<and>\n                       xa = mod_type_class.to_nat b\n                    then v else if x = xa then 1::'a else (0::'a))", "unfolding cond01"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n     then p\n     else if mod_type_class.from_nat x = a \\<and>\n             mod_type_class.from_nat xa = b\n          then q\n          else if mod_type_class.from_nat x = b \\<and>\n                  mod_type_class.from_nat xa = a\n               then u\n               else if mod_type_class.from_nat x = b \\<and>\n                       mod_type_class.from_nat xa = b\n                    then v\n                    else if mod_type_class.from_nat x =\n                            mod_type_class.from_nat xa\n                         then 1::'a else (0::'a)) =\n    (if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n     then p\n     else if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b\n          then q\n          else if x = mod_type_class.to_nat b \\<and>\n                  xa = mod_type_class.to_nat a\n               then u\n               else if x = mod_type_class.to_nat b \\<and>\n                       xa = mod_type_class.to_nat b\n                    then v else if x = xa then 1::'a else (0::'a))", "unfolding cond02"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n     then p\n     else if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b\n          then q\n          else if mod_type_class.from_nat x = b \\<and>\n                  mod_type_class.from_nat xa = a\n               then u\n               else if mod_type_class.from_nat x = b \\<and>\n                       mod_type_class.from_nat xa = b\n                    then v\n                    else if mod_type_class.from_nat x =\n                            mod_type_class.from_nat xa\n                         then 1::'a else (0::'a)) =\n    (if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n     then p\n     else if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b\n          then q\n          else if x = mod_type_class.to_nat b \\<and>\n                  xa = mod_type_class.to_nat a\n               then u\n               else if x = mod_type_class.to_nat b \\<and>\n                       xa = mod_type_class.to_nat b\n                    then v else if x = xa then 1::'a else (0::'a))", "unfolding cond03"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n     then p\n     else if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b\n          then q\n          else if x = mod_type_class.to_nat b \\<and>\n                  xa = mod_type_class.to_nat a\n               then u\n               else if mod_type_class.from_nat x = b \\<and>\n                       mod_type_class.from_nat xa = b\n                    then v\n                    else if mod_type_class.from_nat x =\n                            mod_type_class.from_nat xa\n                         then 1::'a else (0::'a)) =\n    (if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n     then p\n     else if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b\n          then q\n          else if x = mod_type_class.to_nat b \\<and>\n                  xa = mod_type_class.to_nat a\n               then u\n               else if x = mod_type_class.to_nat b \\<and>\n                       xa = mod_type_class.to_nat b\n                    then v else if x = xa then 1::'a else (0::'a))", "unfolding cond04"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n     then p\n     else if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b\n          then q\n          else if x = mod_type_class.to_nat b \\<and>\n                  xa = mod_type_class.to_nat a\n               then u\n               else if x = mod_type_class.to_nat b \\<and>\n                       xa = mod_type_class.to_nat b\n                    then v\n                    else if mod_type_class.from_nat x =\n                            mod_type_class.from_nat xa\n                         then 1::'a else (0::'a)) =\n    (if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n     then p\n     else if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b\n          then q\n          else if x = mod_type_class.to_nat b \\<and>\n                  xa = mod_type_class.to_nat a\n               then u\n               else if x = mod_type_class.to_nat b \\<and>\n                       xa = mod_type_class.to_nat b\n                    then v else if x = xa then 1::'a else (0::'a))", "unfolding cond05"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n     then p\n     else if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b\n          then q\n          else if x = mod_type_class.to_nat b \\<and>\n                  xa = mod_type_class.to_nat a\n               then u\n               else if x = mod_type_class.to_nat b \\<and>\n                       xa = mod_type_class.to_nat b\n                    then v else if x = xa then 1::'a else (0::'a)) =\n    (if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat a\n     then p\n     else if x = mod_type_class.to_nat a \\<and> xa = mod_type_class.to_nat b\n          then q\n          else if x = mod_type_class.to_nat b \\<and>\n                  xa = mod_type_class.to_nat a\n               then u\n               else if x = mod_type_class.to_nat b \\<and>\n                       xa = mod_type_class.to_nat b\n                    then v else if x = xa then 1::'a else (0::'a))", "by (rule refl)"], ["proof (state)\nthis:\n  (case bezout (A $ a $ j) (A $ b $ j) of\n   (p, q, u, v, d) \\<Rightarrow>\n     if mod_type_class.from_nat x = a \\<and> mod_type_class.from_nat xa = a\n     then p\n     else if mod_type_class.from_nat x = a \\<and>\n             mod_type_class.from_nat xa = b\n          then q\n          else if mod_type_class.from_nat x = b \\<and>\n                  mod_type_class.from_nat xa = a\n               then u\n               else if mod_type_class.from_nat x = b \\<and>\n                       mod_type_class.from_nat xa = b\n                    then v\n                    else if mod_type_class.from_nat x =\n                            mod_type_class.from_nat xa\n                         then 1::'a else (0::'a)) =\n  (case bezout (A $ a $ j) (A $ b $ j) of\n   (p, q, u, v, d) \\<Rightarrow>\n     \\<lambda>x y.\n        if x = mod_type_class.to_nat a \\<and> y = mod_type_class.to_nat a\n        then p\n        else if x = mod_type_class.to_nat a \\<and>\n                y = mod_type_class.to_nat b\n             then q\n             else if x = mod_type_class.to_nat b \\<and>\n                     y = mod_type_class.to_nat a\n                  then u\n                  else if x = mod_type_class.to_nat b \\<and>\n                          y = mod_type_class.to_nat b\n                       then v else if x = y then 1::'a else (0::'a))\n   x xa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case bezout (A $ a $ j) (A $ b $ j) of\n   (p, q, u, v, d) \\<Rightarrow>\n     if mod_type_class.from_nat x = a \\<and> mod_type_class.from_nat xa = a\n     then p\n     else if mod_type_class.from_nat x = a \\<and>\n             mod_type_class.from_nat xa = b\n          then q\n          else if mod_type_class.from_nat x = b \\<and>\n                  mod_type_class.from_nat xa = a\n               then u\n               else if mod_type_class.from_nat x = b \\<and>\n                       mod_type_class.from_nat xa = b\n                    then v\n                    else if mod_type_class.from_nat x =\n                            mod_type_class.from_nat xa\n                         then 1::'a else (0::'a)) =\n  (case bezout (A $ a $ j) (A $ b $ j) of\n   (p, q, u, v, d) \\<Rightarrow>\n     \\<lambda>x y.\n        if x = mod_type_class.to_nat a \\<and> y = mod_type_class.to_nat a\n        then p\n        else if x = mod_type_class.to_nat a \\<and>\n                y = mod_type_class.to_nat b\n             then q\n             else if x = mod_type_class.to_nat b \\<and>\n                     y = mod_type_class.to_nat a\n                  then u\n                  else if x = mod_type_class.to_nat b \\<and>\n                          y = mod_type_class.to_nat b\n                       then v else if x = y then 1::'a else (0::'a))\n   x xa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_to_iarray (bezout_matrix A a b j bezout) =\n  bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat a)\n   (mod_type_class.to_nat b) (mod_type_class.to_nat j) bezout\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Bezout Iterate for immutable arrays\\<close>"], ["", "lemma matrix_to_iarray_bezout_iterate:\n  assumes n: \"n<nrows A\"\n  shows \"matrix_to_iarray (bezout_iterate A n i j bezout) \n  = bezout_iterate_iarrays (matrix_to_iarray A) n (to_nat i) (to_nat j) bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_iterate A n i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) n (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j) bezout", "using n"], ["proof (prove)\nusing this:\n  n < nrows A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_iterate A n i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) n (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j) bezout", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 < nrows A \\<Longrightarrow>\n       matrix_to_iarray (bezout_iterate A 0 i j bezout) =\n       bezout_iterate_iarrays (matrix_to_iarray A) 0\n        (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   matrix_to_iarray (bezout_iterate A n i j bezout) =\n                   bezout_iterate_iarrays (matrix_to_iarray A) n\n                    (mod_type_class.to_nat i) (mod_type_class.to_nat j)\n                    bezout;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (bezout_iterate A (Suc n) i j bezout) =\n                         bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n                          (mod_type_class.to_nat i)\n                          (mod_type_class.to_nat j) bezout", "case 0"], ["proof (state)\nthis:\n  0 < nrows A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 < nrows A \\<Longrightarrow>\n       matrix_to_iarray (bezout_iterate A 0 i j bezout) =\n       bezout_iterate_iarrays (matrix_to_iarray A) 0\n        (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   matrix_to_iarray (bezout_iterate A n i j bezout) =\n                   bezout_iterate_iarrays (matrix_to_iarray A) n\n                    (mod_type_class.to_nat i) (mod_type_class.to_nat j)\n                    bezout;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (bezout_iterate A (Suc n) i j bezout) =\n                         bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n                          (mod_type_class.to_nat i)\n                          (mod_type_class.to_nat j) bezout", "thus ?case"], ["proof (prove)\nusing this:\n  0 < nrows A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_iterate A 0 i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) 0 (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j) bezout", "unfolding bezout_iterate_iarrays.simps bezout_iterate.simps"], ["proof (prove)\nusing this:\n  0 < nrows A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray A = matrix_to_iarray A", "by simp"], ["proof (state)\nthis:\n  matrix_to_iarray (bezout_iterate A 0 i j bezout) =\n  bezout_iterate_iarrays (matrix_to_iarray A) 0 (mod_type_class.to_nat i)\n   (mod_type_class.to_nat j) bezout\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   matrix_to_iarray (bezout_iterate A n i j bezout) =\n                   bezout_iterate_iarrays (matrix_to_iarray A) n\n                    (mod_type_class.to_nat i) (mod_type_class.to_nat j)\n                    bezout;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (bezout_iterate A (Suc n) i j bezout) =\n                         bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n                          (mod_type_class.to_nat i)\n                          (mod_type_class.to_nat j) bezout", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   matrix_to_iarray (bezout_iterate A n i j bezout) =\n                   bezout_iterate_iarrays (matrix_to_iarray A) n\n                    (mod_type_class.to_nat i) (mod_type_class.to_nat j)\n                    bezout;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (bezout_iterate A (Suc n) i j bezout) =\n                         bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n                          (mod_type_class.to_nat i)\n                          (mod_type_class.to_nat j) bezout", "case (Suc n)"], ["proof (state)\nthis:\n  n < nrows ?A \\<Longrightarrow>\n  matrix_to_iarray (bezout_iterate ?A n i j bezout) =\n  bezout_iterate_iarrays (matrix_to_iarray ?A) n (mod_type_class.to_nat i)\n   (mod_type_class.to_nat j) bezout\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   matrix_to_iarray (bezout_iterate A n i j bezout) =\n                   bezout_iterate_iarrays (matrix_to_iarray A) n\n                    (mod_type_class.to_nat i) (mod_type_class.to_nat j)\n                    bezout;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (bezout_iterate A (Suc n) i j bezout) =\n                         bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n                          (mod_type_class.to_nat i)\n                          (mod_type_class.to_nat j) bezout", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "proof (cases \"Suc n \\<le> to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n 2. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "case True"], ["proof (state)\nthis:\n  Suc n \\<le> mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n 2. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "unfolding bezout_iterate.simps bezout_iterate_iarrays.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (if Suc n \\<le> mod_type_class.to_nat i then A\n      else bezout_iterate\n            (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout **\n             A)\n            n i j bezout) =\n    (if Suc n \\<le> mod_type_class.to_nat i then matrix_to_iarray A\n     else bezout_iterate_iarrays\n           (bezout_matrix_iarrays (matrix_to_iarray A)\n             (mod_type_class.to_nat i) (Suc n) (mod_type_class.to_nat j)\n             bezout **i\n            matrix_to_iarray A)\n           n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout)", "using True"], ["proof (prove)\nusing this:\n  Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (if Suc n \\<le> mod_type_class.to_nat i then A\n      else bezout_iterate\n            (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout **\n             A)\n            n i j bezout) =\n    (if Suc n \\<le> mod_type_class.to_nat i then matrix_to_iarray A\n     else bezout_iterate_iarrays\n           (bezout_matrix_iarrays (matrix_to_iarray A)\n             (mod_type_class.to_nat i) (Suc n) (mod_type_class.to_nat j)\n             bezout **i\n            matrix_to_iarray A)\n           n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout)", "by auto"], ["proof (state)\nthis:\n  matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n  bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n   (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "case False"], ["proof (state)\nthis:\n  \\<not> Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "let ?B=\"(bezout_matrix_iarrays (matrix_to_iarray A) (to_nat i) (Suc n) (to_nat j) bezout \n      **i matrix_to_iarray A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "let ?B2=\"matrix_to_iarray (bezout_matrix A i (from_nat (Suc n)) j bezout ** A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "have \"matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) \n      = matrix_to_iarray (bezout_iterate (bezout_matrix A i (from_nat (Suc n)) j bezout ** A) n i j bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    matrix_to_iarray\n     (bezout_iterate\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n\n       i j bezout)", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (if Suc n \\<le> mod_type_class.to_nat i then A\n      else bezout_iterate\n            (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout **\n             A)\n            n i j bezout) =\n    matrix_to_iarray\n     (bezout_iterate\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n\n       i j bezout)", "using False"], ["proof (prove)\nusing this:\n  \\<not> Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (if Suc n \\<le> mod_type_class.to_nat i then A\n      else bezout_iterate\n            (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout **\n             A)\n            n i j bezout) =\n    matrix_to_iarray\n     (bezout_iterate\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n\n       i j bezout)", "by auto"], ["proof (state)\nthis:\n  matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n  matrix_to_iarray\n   (bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i\n     j bezout)\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "also"], ["proof (state)\nthis:\n  matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n  matrix_to_iarray\n   (bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i\n     j bezout)\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "have \"... = bezout_iterate_iarrays ?B2 n (to_nat i) (to_nat j) bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (bezout_iterate\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n\n       i j bezout) =\n    bezout_iterate_iarrays\n     (matrix_to_iarray\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A))\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "proof (rule Suc.hyps)"], ["proof (state)\ngoal (1 subgoal):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A)", "show \"n < nrows (bezout_matrix A i (from_nat (Suc n)) j bezout ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A)", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  Suc n < CARD('c)\n\ngoal (1 subgoal):\n 1. n < CARD('c)", "by simp"], ["proof (state)\nthis:\n  n < nrows\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_to_iarray\n   (bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i\n     j bezout) =\n  bezout_iterate_iarrays\n   (matrix_to_iarray\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A))\n   n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "also"], ["proof (state)\nthis:\n  matrix_to_iarray\n   (bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i\n     j bezout) =\n  bezout_iterate_iarrays\n   (matrix_to_iarray\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A))\n   n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "have \"... = bezout_iterate_iarrays ?B n (to_nat i) (to_nat j) bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate_iarrays\n     (matrix_to_iarray\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A))\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout =\n    bezout_iterate_iarrays\n     (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (Suc n) (mod_type_class.to_nat j) bezout **i\n      matrix_to_iarray A)\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "unfolding matrix_to_iarray_matrix_matrix_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate_iarrays\n     (matrix_to_iarray\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout) **i\n      matrix_to_iarray A)\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout =\n    bezout_iterate_iarrays\n     (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (Suc n) (mod_type_class.to_nat j) bezout **i\n      matrix_to_iarray A)\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "unfolding matrix_to_iarray_bezout_matrix[of A i \"from_nat (Suc n)\" j bezout]"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate_iarrays\n     (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (mod_type_class.to_nat (mod_type_class.from_nat (Suc n)))\n       (mod_type_class.to_nat j) bezout **i\n      matrix_to_iarray A)\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout =\n    bezout_iterate_iarrays\n     (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (Suc n) (mod_type_class.to_nat j) bezout **i\n      matrix_to_iarray A)\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "unfolding to_nat_from_nat_id[OF Suc.prems[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate_iarrays\n     (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (Suc n) (mod_type_class.to_nat j) bezout **i\n      matrix_to_iarray A)\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout =\n    bezout_iterate_iarrays\n     (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (Suc n) (mod_type_class.to_nat j) bezout **i\n      matrix_to_iarray A)\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", ".."], ["proof (state)\nthis:\n  bezout_iterate_iarrays\n   (matrix_to_iarray\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A))\n   n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout =\n  bezout_iterate_iarrays\n   (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (Suc n) (mod_type_class.to_nat j) bezout **i\n    matrix_to_iarray A)\n   n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "also"], ["proof (state)\nthis:\n  bezout_iterate_iarrays\n   (matrix_to_iarray\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A))\n   n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout =\n  bezout_iterate_iarrays\n   (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (Suc n) (mod_type_class.to_nat j) bezout **i\n    matrix_to_iarray A)\n   n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "have \"... = bezout_iterate_iarrays (matrix_to_iarray A) (Suc n) (to_nat i) (to_nat j) bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate_iarrays\n     (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (Suc n) (mod_type_class.to_nat j) bezout **i\n      matrix_to_iarray A)\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "unfolding bezout_iterate_iarrays.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate_iarrays\n     (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (Suc n) (mod_type_class.to_nat j) bezout **i\n      matrix_to_iarray A)\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout =\n    (if Suc n \\<le> mod_type_class.to_nat i then matrix_to_iarray A\n     else bezout_iterate_iarrays\n           (bezout_matrix_iarrays (matrix_to_iarray A)\n             (mod_type_class.to_nat i) (Suc n) (mod_type_class.to_nat j)\n             bezout **i\n            matrix_to_iarray A)\n           n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout)", "using False"], ["proof (prove)\nusing this:\n  \\<not> Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. bezout_iterate_iarrays\n     (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (Suc n) (mod_type_class.to_nat j) bezout **i\n      matrix_to_iarray A)\n     n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout =\n    (if Suc n \\<le> mod_type_class.to_nat i then matrix_to_iarray A\n     else bezout_iterate_iarrays\n           (bezout_matrix_iarrays (matrix_to_iarray A)\n             (mod_type_class.to_nat i) (Suc n) (mod_type_class.to_nat j)\n             bezout **i\n            matrix_to_iarray A)\n           n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout)", "by auto"], ["proof (state)\nthis:\n  bezout_iterate_iarrays\n   (bezout_matrix_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (Suc n) (mod_type_class.to_nat j) bezout **i\n    matrix_to_iarray A)\n   n (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout =\n  bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n   (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "finally"], ["proof (chain)\npicking this:\n  matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n  bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n   (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "show ?thesis"], ["proof (prove)\nusing this:\n  matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n  bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n   (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n    bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout", "."], ["proof (state)\nthis:\n  matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n  bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n   (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_to_iarray (bezout_iterate A (Suc n) i j bezout) =\n  bezout_iterate_iarrays (matrix_to_iarray A) (Suc n)\n   (mod_type_class.to_nat i) (mod_type_class.to_nat j) bezout\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_vector_all_zero_from_index2:\n  fixes A::\"'a::{zero}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"(\\<forall>m>i. A $ m $ k = 0) = vector_all_zero_from_index ((to_nat i)+1, vec_to_iarray (column k A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "proof (cases \"to_nat i = nrows A - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))\n 2. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat i = nrows A - 1\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))\n 2. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "have \"(\\<forall>m>i. A $ m $ k = 0) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m>i. A $ m $ k = (0::'a)) = True", "by (metis One_nat_def Suc_pred True not_less_eq nrows_def to_nat_0 to_nat_less_card to_nat_mono)"], ["proof (state)\nthis:\n  (\\<forall>m>i. A $ m $ k = (0::'a)) = True\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))\n 2. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "also"], ["proof (state)\nthis:\n  (\\<forall>m>i. A $ m $ k = (0::'a)) = True\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))\n 2. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "have \"... = vector_all_zero_from_index ((to_nat i)+1, vec_to_iarray (column k A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "unfolding vector_all_zero_from_index_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. True =\n    IArray.all\n     (\\<lambda>x.\n         snd (mod_type_class.to_nat i + 1, vec_to_iarray (column k A)) !!\n         x =\n         (0::'a))\n     (IArray\n       [fst (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))..<\n        IArray.length\n         (snd (mod_type_class.to_nat i + 1, vec_to_iarray (column k A)))])", "unfolding vec_to_iarray_def column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. True =\n    IArray.all\n     (\\<lambda>x.\n         snd (mod_type_class.to_nat i + 1,\n              IArray.of_fun\n               (\\<lambda>i.\n                   (\\<chi>i. A $ i $ k) $ mod_type_class.from_nat i)\n               CARD('rows)) !!\n         x =\n         (0::'a))\n     (IArray\n       [fst (mod_type_class.to_nat i + 1,\n             IArray.of_fun\n              (\\<lambda>i. (\\<chi>i. A $ i $ k) $ mod_type_class.from_nat i)\n              CARD('rows))..<\n        IArray.length\n         (snd (mod_type_class.to_nat i + 1,\n               IArray.of_fun\n                (\\<lambda>i.\n                    (\\<chi>i. A $ i $ k) $ mod_type_class.from_nat i)\n                CARD('rows)))])", "by (auto, metis True nrows_def One_nat_def Suc_pred not_le zero_less_card_finite)"], ["proof (state)\nthis:\n  True =\n  vector_all_zero_from_index\n   (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))\n 2. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "finally"], ["proof (chain)\npicking this:\n  (\\<forall>m>i. A $ m $ k = (0::'a)) =\n  vector_all_zero_from_index\n   (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>m>i. A $ m $ k = (0::'a)) =\n  vector_all_zero_from_index\n   (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))\n\ngoal (1 subgoal):\n 1. (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "."], ["proof (state)\nthis:\n  (\\<forall>m>i. A $ m $ k = (0::'a)) =\n  vector_all_zero_from_index\n   (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "case False"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<noteq> nrows A - 1\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "have i_le: \"i<i+1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < i + (1::'rows)", "by (metis False Suc_le' add_diff_cancel_right' nrows_def suc_not_zero)"], ["proof (state)\nthis:\n  i < i + (1::'rows)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "hence \"(\\<forall>m>i. A $ m $ k = 0) = (\\<forall>m\\<ge>i+1. A $ m $ k = 0)\""], ["proof (prove)\nusing this:\n  i < i + (1::'rows)\n\ngoal (1 subgoal):\n 1. (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    (\\<forall>m\\<ge>i + (1::'rows). A $ m $ k = (0::'a))", "using i_le le_Suc"], ["proof (prove)\nusing this:\n  i < i + (1::'rows)\n  i < i + (1::'rows)\n  ?a < ?b \\<Longrightarrow> ?a + (1::?'a) \\<le> ?b\n\ngoal (1 subgoal):\n 1. (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    (\\<forall>m\\<ge>i + (1::'rows). A $ m $ k = (0::'a))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>m>i. A $ m $ k = (0::'a)) =\n  (\\<forall>m\\<ge>i + (1::'rows). A $ m $ k = (0::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "also"], ["proof (state)\nthis:\n  (\\<forall>m>i. A $ m $ k = (0::'a)) =\n  (\\<forall>m\\<ge>i + (1::'rows). A $ m $ k = (0::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "have \"... = vector_all_zero_from_index ((to_nat i)+1, vec_to_iarray (column k A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m\\<ge>i + (1::'rows). A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "unfolding matrix_vector_all_zero_from_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (mod_type_class.to_nat (i + (1::'rows)), vec_to_iarray (column k A)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "by (metis (mono_tags, hide_lams) from_nat_suc from_nat_to_nat_id i_le not_less0 \n      to_nat_0 to_nat_from_nat_id to_nat_mono to_nat_plus_one_less_card)"], ["proof (state)\nthis:\n  (\\<forall>m\\<ge>i + (1::'rows). A $ m $ k = (0::'a)) =\n  vector_all_zero_from_index\n   (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> nrows A - 1 \\<Longrightarrow>\n    (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "finally"], ["proof (chain)\npicking this:\n  (\\<forall>m>i. A $ m $ k = (0::'a)) =\n  vector_all_zero_from_index\n   (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>m>i. A $ m $ k = (0::'a)) =\n  vector_all_zero_from_index\n   (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))\n\ngoal (1 subgoal):\n 1. (\\<forall>m>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))", "."], ["proof (state)\nthis:\n  (\\<forall>m>i. A $ m $ k = (0::'a)) =\n  vector_all_zero_from_index\n   (mod_type_class.to_nat i + 1, vec_to_iarray (column k A))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Echelon form of column k for immutable arrays\\<close>"], ["", "lemma matrix_to_iarray_echelon_form_of_column_k:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  and i: \"i\\<le>nrows A\"\n  shows \"matrix_to_iarray (fst ((echelon_form_of_column_k bezout) (A,i) k)) \n  = fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "proof (cases \"i<nrows A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)\n 2. \\<not> i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "case False"], ["proof (state)\nthis:\n  \\<not> i < nrows A\n\ngoal (2 subgoals):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)\n 2. \\<not> i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "have i_eq: \"i=nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = nrows A", "by (metis False le_imp_less_or_eq i)"], ["proof (state)\nthis:\n  i = nrows A\n\ngoal (2 subgoals):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)\n 2. \\<not> i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "show \"matrix_to_iarray (fst ((echelon_form_of_column_k bezout) (A,i) k)) \n    = fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "unfolding echelon_form_of_column_k_efficient echelon_form_of_column_k_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (case (A, i) of\n           (A, i) \\<Rightarrow>\n             if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n                i = nrows A\n             then (A, i)\n             else if \\<forall>m>mod_type_class.from_nat i.\n                        A $ m $ mod_type_class.from_nat k = (0::'a)\n                  then (A, i + 1)\n                  else (bezout_iterate\n                         (interchange_rows A (mod_type_class.from_nat i)\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n))\n                         (nrows A - 1) (mod_type_class.from_nat i)\n                         (mod_type_class.from_nat k) bezout,\n                        i + 1))) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "unfolding echelon_form_of_column_k_iarrays_def Let_def snd_conv fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (case (A, i) of\n           (A, i) \\<Rightarrow>\n             if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n                i = nrows A\n             then (A, i)\n             else if \\<forall>m>mod_type_class.from_nat i.\n                        A $ m $ mod_type_class.from_nat k = (0::'a)\n                  then (A, i + 1)\n                  else (bezout_iterate\n                         (interchange_rows A (mod_type_class.from_nat i)\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n))\n                         (nrows A - 1) (mod_type_class.from_nat i)\n                         (mod_type_class.from_nat k) bezout,\n                        i + 1))) =\n    fst (case (matrix_to_iarray A, i, bezout) of\n         (A, i, bezout) \\<Rightarrow>\n           if i = nrows_iarray A \\<or>\n              A !! i !! k = (0::'a) \\<and>\n              vector_all_zero_from_index (i + 1, column_iarray k A)\n           then (A, i, bezout)\n           else if vector_all_zero_from_index (i + 1, column_iarray k A)\n                then (A, i + 1, bezout)\n                else (bezout_iterate_iarrays\n                       (interchange_rows_iarray A i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k A) i))\n                       (nrows_iarray A - 1) i k bezout,\n                      i + 1, bezout))", "unfolding matrix_to_iarray_nrows"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (case (A, i) of\n           (A, i) \\<Rightarrow>\n             if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n                i = nrows_iarray (matrix_to_iarray A)\n             then (A, i)\n             else if \\<forall>m>mod_type_class.from_nat i.\n                        A $ m $ mod_type_class.from_nat k = (0::'a)\n                  then (A, i + 1)\n                  else (bezout_iterate\n                         (interchange_rows A (mod_type_class.from_nat i)\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n))\n                         (nrows_iarray (matrix_to_iarray A) - 1)\n                         (mod_type_class.from_nat i)\n                         (mod_type_class.from_nat k) bezout,\n                        i + 1))) =\n    fst (case (matrix_to_iarray A, i, bezout) of\n         (A, i, bezout) \\<Rightarrow>\n           if i = nrows_iarray A \\<or>\n              A !! i !! k = (0::'a) \\<and>\n              vector_all_zero_from_index (i + 1, column_iarray k A)\n           then (A, i, bezout)\n           else if vector_all_zero_from_index (i + 1, column_iarray k A)\n                then (A, i + 1, bezout)\n                else (bezout_iterate_iarrays\n                       (interchange_rows_iarray A i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k A) i))\n                       (nrows_iarray A - 1) i k bezout,\n                      i + 1, bezout))", "unfolding i_eq matrix_to_iarray_nrows"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (case (A, nrows_iarray (matrix_to_iarray A)) of\n           (A, i) \\<Rightarrow>\n             if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n                i = nrows_iarray (matrix_to_iarray A)\n             then (A, i)\n             else if \\<forall>m>mod_type_class.from_nat i.\n                        A $ m $ mod_type_class.from_nat k = (0::'a)\n                  then (A, i + 1)\n                  else (bezout_iterate\n                         (interchange_rows A (mod_type_class.from_nat i)\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n))\n                         (nrows_iarray (matrix_to_iarray A) - 1)\n                         (mod_type_class.from_nat i)\n                         (mod_type_class.from_nat k) bezout,\n                        i + 1))) =\n    fst (case (matrix_to_iarray A, nrows_iarray (matrix_to_iarray A),\n               bezout) of\n         (A, i, bezout) \\<Rightarrow>\n           if i = nrows_iarray A \\<or>\n              A !! i !! k = (0::'a) \\<and>\n              vector_all_zero_from_index (i + 1, column_iarray k A)\n           then (A, i, bezout)\n           else if vector_all_zero_from_index (i + 1, column_iarray k A)\n                then (A, i + 1, bezout)\n                else (bezout_iterate_iarrays\n                       (interchange_rows_iarray A i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k A) i))\n                       (nrows_iarray A - 1) i k bezout,\n                      i + 1, bezout))", "by auto"], ["proof (state)\nthis:\n  matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n  fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)\n\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "case True"], ["proof (state)\nthis:\n  i < nrows A\n\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "let ?interchange=\"(interchange_rows A (from_nat i) \n    (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "have all_zero: \"(\\<forall>m\\<ge>mod_type_class.from_nat i. A $ m $ mod_type_class.from_nat k = 0) \n    = vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m\\<ge>mod_type_class.from_nat i.\n        A $ m $ mod_type_class.from_nat k = (0::'a)) =\n    vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))", "unfolding matrix_vector_all_zero_from_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (mod_type_class.to_nat (mod_type_class.from_nat i),\n      vec_to_iarray (column (mod_type_class.from_nat k) A)) =\n    vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))", "unfolding to_nat_from_nat_id[OF True[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) =\n    vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))", "unfolding vec_to_iarray_column'[OF k]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A)) =\n    vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))", ".."], ["proof (state)\nthis:\n  (\\<forall>m\\<ge>mod_type_class.from_nat i.\n      A $ m $ mod_type_class.from_nat k = (0::'a)) =\n  vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "have all_zero2: \" (\\<forall>m>from_nat i. A $ m $ mod_type_class.from_nat k = 0) \n    = (vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m>mod_type_class.from_nat i.\n        A $ m $ mod_type_class.from_nat k = (0::'a)) =\n    vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A))", "unfolding matrix_vector_all_zero_from_index2"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (mod_type_class.to_nat (mod_type_class.from_nat i) + 1,\n      vec_to_iarray (column (mod_type_class.from_nat k) A)) =\n    vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A))", "unfolding to_nat_from_nat_id[OF True[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (i + 1, vec_to_iarray (column (mod_type_class.from_nat k) A)) =\n    vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A))", "unfolding vec_to_iarray_column'[OF k]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (i + 1, column_iarray k (matrix_to_iarray A)) =\n    vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A))", ".."], ["proof (state)\nthis:\n  (\\<forall>m>mod_type_class.from_nat i.\n      A $ m $ mod_type_class.from_nat k = (0::'a)) =\n  vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "have n: \"(nrows_iarray (matrix_to_iarray A) - Suc 0) < nrows ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows_iarray (matrix_to_iarray A) - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "unfolding matrix_to_iarray_nrows[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows_iarray (matrix_to_iarray A) - Suc 0\n  < nrows\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "using True"], ["proof (prove)\nusing this:\n  i < nrows A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "unfolding echelon_form_of_column_k_efficient echelon_form_of_column_k_def Let_def split_beta"], ["proof (prove)\nusing this:\n  i < nrows A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat (snd (A, i)).\n                  fst (A, i) $ m $ mod_type_class.from_nat k =\n                  (0::'a)) \\<or>\n              snd (A, i) = nrows (fst (A, i))\n           then (fst (A, i), snd (A, i))\n           else if \\<forall>m>mod_type_class.from_nat (snd (A, i)).\n                      fst (A, i) $ m $ mod_type_class.from_nat k = (0::'a)\n                then (fst (A, i), snd (A, i) + 1)\n                else (bezout_iterate\n                       (interchange_rows (fst (A, i))\n                         (mod_type_class.from_nat (snd (A, i)))\n                         (LEAST n.\n                             fst (A, i) $ n $\n                             mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat (snd (A, i)) \\<le> n))\n                       (nrows (fst (A, i)) - 1)\n                       (mod_type_class.from_nat (snd (A, i)))\n                       (mod_type_class.from_nat k) bezout,\n                      snd (A, i) + 1))) =\n    fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)", "unfolding echelon_form_of_column_k_iarrays_def Let_def snd_conv fst_conv"], ["proof (prove)\nusing this:\n  i < nrows A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1))) =\n    fst (case (matrix_to_iarray A, i, bezout) of\n         (A, i, bezout) \\<Rightarrow>\n           if i = nrows_iarray A \\<or>\n              A !! i !! k = (0::'a) \\<and>\n              vector_all_zero_from_index (i + 1, column_iarray k A)\n           then (A, i, bezout)\n           else if vector_all_zero_from_index (i + 1, column_iarray k A)\n                then (A, i + 1, bezout)\n                else (bezout_iterate_iarrays\n                       (interchange_rows_iarray A i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k A) i))\n                       (nrows_iarray A - 1) i k bezout,\n                      i + 1, bezout))", "unfolding matrix_to_iarray_nrows"], ["proof (prove)\nusing this:\n  i < nrows_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows_iarray (matrix_to_iarray A)\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows_iarray (matrix_to_iarray A) - 1)\n                       (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1))) =\n    fst (case (matrix_to_iarray A, i, bezout) of\n         (A, i, bezout) \\<Rightarrow>\n           if i = nrows_iarray A \\<or>\n              A !! i !! k = (0::'a) \\<and>\n              vector_all_zero_from_index (i + 1, column_iarray k A)\n           then (A, i, bezout)\n           else if vector_all_zero_from_index (i + 1, column_iarray k A)\n                then (A, i + 1, bezout)\n                else (bezout_iterate_iarrays\n                       (interchange_rows_iarray A i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k A) i))\n                       (nrows_iarray A - 1) i k bezout,\n                      i + 1, bezout))", "unfolding all_zero all_zero2"], ["proof (prove)\nusing this:\n  i < nrows_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (if vector_all_zero_from_index\n               (i, column_iarray k (matrix_to_iarray A)) \\<or>\n              i = nrows_iarray (matrix_to_iarray A)\n           then (A, i)\n           else if vector_all_zero_from_index\n                    (i + 1, column_iarray k (matrix_to_iarray A))\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows_iarray (matrix_to_iarray A) - 1)\n                       (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1))) =\n    fst (case (matrix_to_iarray A, i, bezout) of\n         (A, i, bezout) \\<Rightarrow>\n           if i = nrows_iarray A \\<or>\n              A !! i !! k = (0::'a) \\<and>\n              vector_all_zero_from_index (i + 1, column_iarray k A)\n           then (A, i, bezout)\n           else if vector_all_zero_from_index (i + 1, column_iarray k A)\n                then (A, i + 1, bezout)\n                else (bezout_iterate_iarrays\n                       (interchange_rows_iarray A i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k A) i))\n                       (nrows_iarray A - 1) i k bezout,\n                      i + 1, bezout))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> matrix_to_iarray A =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout\n 2. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     \\<not> vector_all_zero_from_index\n             (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> matrix_to_iarray\n                       (bezout_iterate\n                         (interchange_rows A (mod_type_class.from_nat i)\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n))\n                         (nrows_iarray (matrix_to_iarray A) - Suc 0)\n                         (mod_type_class.from_nat i)\n                         (mod_type_class.from_nat k) bezout) =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout", "unfolding matrix_to_iarray_bezout_iterate[OF n]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> matrix_to_iarray A =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout\n 2. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     \\<not> vector_all_zero_from_index\n             (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> bezout_iterate_iarrays\n                       (matrix_to_iarray\n                         (interchange_rows A (mod_type_class.from_nat i)\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n)))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0)\n                       (mod_type_class.to_nat (mod_type_class.from_nat i))\n                       (mod_type_class.to_nat (mod_type_class.from_nat k))\n                       bezout =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout", "unfolding matrix_to_iarray_interchange_rows"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> matrix_to_iarray A =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout\n 2. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     \\<not> vector_all_zero_from_index\n             (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A)\n                         (mod_type_class.to_nat (mod_type_class.from_nat i))\n                         (mod_type_class.to_nat\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n)))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0)\n                       (mod_type_class.to_nat (mod_type_class.from_nat i))\n                       (mod_type_class.to_nat (mod_type_class.from_nat k))\n                       bezout =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout", "using vec_to_iarray_least_non_zero_position_of_vector_from_index'[of \"from_nat i\" \"from_nat k\" A]"], ["proof (prove)\nusing this:\n  \\<not> vector_all_zero_from_index\n          (mod_type_class.to_nat (mod_type_class.from_nat i),\n           vec_to_iarray\n            (column (mod_type_class.from_nat k) A)) \\<Longrightarrow>\n  least_non_zero_position_of_vector_from_index\n   (vec_to_iarray (column (mod_type_class.from_nat k) A))\n   (mod_type_class.to_nat (mod_type_class.from_nat i)) =\n  mod_type_class.to_nat\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> matrix_to_iarray A =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout\n 2. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     \\<not> vector_all_zero_from_index\n             (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A)\n                         (mod_type_class.to_nat (mod_type_class.from_nat i))\n                         (mod_type_class.to_nat\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n)))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0)\n                       (mod_type_class.to_nat (mod_type_class.from_nat i))\n                       (mod_type_class.to_nat (mod_type_class.from_nat k))\n                       bezout =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout", "unfolding to_nat_from_nat_id[OF True[unfolded nrows_def]]"], ["proof (prove)\nusing this:\n  \\<not> vector_all_zero_from_index\n          (i, vec_to_iarray\n               (column (mod_type_class.from_nat k) A)) \\<Longrightarrow>\n  least_non_zero_position_of_vector_from_index\n   (vec_to_iarray (column (mod_type_class.from_nat k) A)) i =\n  mod_type_class.to_nat\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> matrix_to_iarray A =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout\n 2. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     \\<not> vector_all_zero_from_index\n             (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (mod_type_class.to_nat\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n)))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i\n                       (mod_type_class.to_nat (mod_type_class.from_nat k))\n                       bezout =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout", "unfolding to_nat_from_nat_id[OF k[unfolded ncols_def]]"], ["proof (prove)\nusing this:\n  \\<not> vector_all_zero_from_index\n          (i, vec_to_iarray\n               (column (mod_type_class.from_nat k) A)) \\<Longrightarrow>\n  least_non_zero_position_of_vector_from_index\n   (vec_to_iarray (column (mod_type_class.from_nat k) A)) i =\n  mod_type_class.to_nat\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> matrix_to_iarray A =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout\n 2. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     \\<not> vector_all_zero_from_index\n             (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (mod_type_class.to_nat\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n)))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout", "unfolding vec_to_iarray_column'[OF k]"], ["proof (prove)\nusing this:\n  \\<not> vector_all_zero_from_index\n          (i, column_iarray k (matrix_to_iarray A)) \\<Longrightarrow>\n  least_non_zero_position_of_vector_from_index\n   (column_iarray k (matrix_to_iarray A)) i =\n  mod_type_class.to_nat\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> matrix_to_iarray A =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout\n 2. \\<lbrakk>i < nrows_iarray (matrix_to_iarray A);\n     \\<not> vector_all_zero_from_index\n             (i, column_iarray k (matrix_to_iarray A));\n     \\<not> vector_all_zero_from_index\n             (Suc i, column_iarray k (matrix_to_iarray A))\\<rbrakk>\n    \\<Longrightarrow> bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (mod_type_class.to_nat\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n)))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout =\n                      bezout_iterate_iarrays\n                       (interchange_rows_iarray (matrix_to_iarray A) i\n                         (least_non_zero_position_of_vector_from_index\n                           (column_iarray k (matrix_to_iarray A)) i))\n                       (nrows_iarray (matrix_to_iarray A) - Suc 0) i k\n                       bezout", "by (auto, metis Suc_eq_plus1 all_zero all_zero2 less_le)"], ["proof (state)\nthis:\n  matrix_to_iarray (fst (echelon_form_of_column_k bezout (A, i) k)) =\n  fst (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snd_matrix_to_iarray_echelon_form_of_column_k:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  and i: \"i\\<le>nrows A\"\n  shows \"snd ((echelon_form_of_column_k bezout) (A,i) k) \n  = fst (snd (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "proof (cases \"i<nrows A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))\n 2. \\<not> i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "case False"], ["proof (state)\nthis:\n  \\<not> i < nrows A\n\ngoal (2 subgoals):\n 1. i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))\n 2. \\<not> i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "have i_eq: \"i=nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = nrows A", "by (metis False le_imp_less_or_eq i)"], ["proof (state)\nthis:\n  i = nrows A\n\ngoal (2 subgoals):\n 1. i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))\n 2. \\<not> i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "show \"snd ((echelon_form_of_column_k bezout) (A,i) k) \n    = fst (snd (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "unfolding echelon_form_of_column_k_efficient echelon_form_of_column_k_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "unfolding echelon_form_of_column_k_iarrays_def Let_def snd_conv fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    fst (snd (case (matrix_to_iarray A, i, bezout) of\n              (A, i, bezout) \\<Rightarrow>\n                if i = nrows_iarray A \\<or>\n                   A !! i !! k = (0::'a) \\<and>\n                   vector_all_zero_from_index (i + 1, column_iarray k A)\n                then (A, i, bezout)\n                else if vector_all_zero_from_index\n                         (i + 1, column_iarray k A)\n                     then (A, i + 1, bezout)\n                     else (bezout_iterate_iarrays\n                            (interchange_rows_iarray A i\n                              (least_non_zero_position_of_vector_from_index\n                                (column_iarray k A) i))\n                            (nrows_iarray A - 1) i k bezout,\n                           i + 1, bezout)))", "unfolding i_eq matrix_to_iarray_nrows"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (case (A, nrows_iarray (matrix_to_iarray A)) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows_iarray (matrix_to_iarray A)\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows_iarray (matrix_to_iarray A) - 1)\n                       (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    fst (snd (case (matrix_to_iarray A, nrows_iarray (matrix_to_iarray A),\n                    bezout) of\n              (A, i, bezout) \\<Rightarrow>\n                if i = nrows_iarray A \\<or>\n                   A !! i !! k = (0::'a) \\<and>\n                   vector_all_zero_from_index (i + 1, column_iarray k A)\n                then (A, i, bezout)\n                else if vector_all_zero_from_index\n                         (i + 1, column_iarray k A)\n                     then (A, i + 1, bezout)\n                     else (bezout_iterate_iarrays\n                            (interchange_rows_iarray A i\n                              (least_non_zero_position_of_vector_from_index\n                                (column_iarray k A) i))\n                            (nrows_iarray A - 1) i k bezout,\n                           i + 1, bezout)))", "by auto"], ["proof (state)\nthis:\n  snd (echelon_form_of_column_k bezout (A, i) k) =\n  fst (snd (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout)\n             k))\n\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "case True"], ["proof (state)\nthis:\n  i < nrows A\n\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "let ?interchange=\"(interchange_rows A (from_nat i) \n    (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "have all_zero: \"(\\<forall>m\\<ge>mod_type_class.from_nat i. A $ m $ mod_type_class.from_nat k = 0) \n    = vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m\\<ge>mod_type_class.from_nat i.\n        A $ m $ mod_type_class.from_nat k = (0::'a)) =\n    vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))", "unfolding matrix_vector_all_zero_from_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (mod_type_class.to_nat (mod_type_class.from_nat i),\n      vec_to_iarray (column (mod_type_class.from_nat k) A)) =\n    vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))", "unfolding to_nat_from_nat_id[OF True[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) =\n    vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))", "unfolding vec_to_iarray_column'[OF k]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A)) =\n    vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))", ".."], ["proof (state)\nthis:\n  (\\<forall>m\\<ge>mod_type_class.from_nat i.\n      A $ m $ mod_type_class.from_nat k = (0::'a)) =\n  vector_all_zero_from_index (i, column_iarray k (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "have all_zero2: \" (\\<forall>m>from_nat i. A $ m $ mod_type_class.from_nat k = 0) \n    = (vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m>mod_type_class.from_nat i.\n        A $ m $ mod_type_class.from_nat k = (0::'a)) =\n    vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A))", "unfolding matrix_vector_all_zero_from_index2"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (mod_type_class.to_nat (mod_type_class.from_nat i) + 1,\n      vec_to_iarray (column (mod_type_class.from_nat k) A)) =\n    vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A))", "unfolding to_nat_from_nat_id[OF True[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (i + 1, vec_to_iarray (column (mod_type_class.from_nat k) A)) =\n    vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A))", "unfolding vec_to_iarray_column'[OF k]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (i + 1, column_iarray k (matrix_to_iarray A)) =\n    vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A))", ".."], ["proof (state)\nthis:\n  (\\<forall>m>mod_type_class.from_nat i.\n      A $ m $ mod_type_class.from_nat k = (0::'a)) =\n  vector_all_zero_from_index (i + 1, column_iarray k (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "have Aik: \"A $ from_nat i $ from_nat k = matrix_to_iarray A !! i !! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n    matrix_to_iarray A !! i !! k", "by (metis True k matrix_to_iarray_nth ncols_def nrows_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n  matrix_to_iarray A !! i !! k\n\ngoal (1 subgoal):\n 1. i < nrows A \\<Longrightarrow>\n    snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "using True Aik"], ["proof (prove)\nusing this:\n  i < nrows A\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n  matrix_to_iarray A !! i !! k\n\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "unfolding echelon_form_of_column_k_efficient"], ["proof (prove)\nusing this:\n  i < nrows A\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n  matrix_to_iarray A !! i !! k\n\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k_efficient bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "unfolding echelon_form_of_column_k_efficient_def Let_def split_beta"], ["proof (prove)\nusing this:\n  i < nrows A\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n  matrix_to_iarray A !! i !! k\n\ngoal (1 subgoal):\n 1. snd (if snd (A, i) = nrows (fst (A, i)) \\<or>\n            fst (A, i) $ mod_type_class.from_nat (snd (A, i)) $\n            mod_type_class.from_nat k =\n            (0::'a) \\<and>\n            (\\<forall>m>mod_type_class.from_nat (snd (A, i)).\n                fst (A, i) $ m $ mod_type_class.from_nat k = (0::'a))\n         then (fst (A, i), snd (A, i))\n         else if \\<forall>m>mod_type_class.from_nat (snd (A, i)).\n                    fst (A, i) $ m $ mod_type_class.from_nat k = (0::'a)\n              then (fst (A, i), snd (A, i) + 1)\n              else (bezout_iterate\n                     (interchange_rows (fst (A, i))\n                       (mod_type_class.from_nat (snd (A, i)))\n                       (LEAST n.\n                           fst (A, i) $ n $\n                           mod_type_class.from_nat k \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat (snd (A, i)) \\<le> n))\n                     (nrows (fst (A, i)) - 1)\n                     (mod_type_class.from_nat (snd (A, i)))\n                     (mod_type_class.from_nat k) bezout,\n                    snd (A, i) + 1)) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "unfolding echelon_form_of_column_k_iarrays_def Let_def snd_conv fst_conv"], ["proof (prove)\nusing this:\n  i < nrows A\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n  matrix_to_iarray A !! i !! k\n\ngoal (1 subgoal):\n 1. snd (if i = nrows A \\<or>\n            A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n            (0::'a) \\<and>\n            (\\<forall>m>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a))\n         then (A, i)\n         else if \\<forall>m>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat k = (0::'a)\n              then (A, i + 1)\n              else (bezout_iterate\n                     (interchange_rows A (mod_type_class.from_nat i)\n                       (LEAST n.\n                           A $ n $ mod_type_class.from_nat k \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat i \\<le> n))\n                     (nrows A - 1) (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k) bezout,\n                    i + 1)) =\n    fst (snd (case (matrix_to_iarray A, i, bezout) of\n              (A, i, bezout) \\<Rightarrow>\n                if i = nrows_iarray A \\<or>\n                   A !! i !! k = (0::'a) \\<and>\n                   vector_all_zero_from_index (i + 1, column_iarray k A)\n                then (A, i, bezout)\n                else if vector_all_zero_from_index\n                         (i + 1, column_iarray k A)\n                     then (A, i + 1, bezout)\n                     else (bezout_iterate_iarrays\n                            (interchange_rows_iarray A i\n                              (least_non_zero_position_of_vector_from_index\n                                (column_iarray k A) i))\n                            (nrows_iarray A - 1) i k bezout,\n                           i + 1, bezout)))", "unfolding all_zero all_zero2"], ["proof (prove)\nusing this:\n  i < nrows A\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n  matrix_to_iarray A !! i !! k\n\ngoal (1 subgoal):\n 1. snd (if i = nrows A \\<or>\n            A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n            (0::'a) \\<and>\n            vector_all_zero_from_index\n             (i + 1, column_iarray k (matrix_to_iarray A))\n         then (A, i)\n         else if vector_all_zero_from_index\n                  (i + 1, column_iarray k (matrix_to_iarray A))\n              then (A, i + 1)\n              else (bezout_iterate\n                     (interchange_rows A (mod_type_class.from_nat i)\n                       (LEAST n.\n                           A $ n $ mod_type_class.from_nat k \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat i \\<le> n))\n                     (nrows A - 1) (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k) bezout,\n                    i + 1)) =\n    fst (snd (case (matrix_to_iarray A, i, bezout) of\n              (A, i, bezout) \\<Rightarrow>\n                if i = nrows_iarray A \\<or>\n                   A !! i !! k = (0::'a) \\<and>\n                   vector_all_zero_from_index (i + 1, column_iarray k A)\n                then (A, i, bezout)\n                else if vector_all_zero_from_index\n                         (i + 1, column_iarray k A)\n                     then (A, i + 1, bezout)\n                     else (bezout_iterate_iarrays\n                            (interchange_rows_iarray A i\n                              (least_non_zero_position_of_vector_from_index\n                                (column_iarray k A) i))\n                            (nrows_iarray A - 1) i k bezout,\n                           i + 1, bezout)))", "unfolding matrix_to_iarray_nrows"], ["proof (prove)\nusing this:\n  i < nrows_iarray (matrix_to_iarray A)\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n  matrix_to_iarray A !! i !! k\n\ngoal (1 subgoal):\n 1. snd (if i = nrows_iarray (matrix_to_iarray A) \\<or>\n            A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n            (0::'a) \\<and>\n            vector_all_zero_from_index\n             (i + 1, column_iarray k (matrix_to_iarray A))\n         then (A, i)\n         else if vector_all_zero_from_index\n                  (i + 1, column_iarray k (matrix_to_iarray A))\n              then (A, i + 1)\n              else (bezout_iterate\n                     (interchange_rows A (mod_type_class.from_nat i)\n                       (LEAST n.\n                           A $ n $ mod_type_class.from_nat k \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat i \\<le> n))\n                     (nrows_iarray (matrix_to_iarray A) - 1)\n                     (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n                     bezout,\n                    i + 1)) =\n    fst (snd (case (matrix_to_iarray A, i, bezout) of\n              (A, i, bezout) \\<Rightarrow>\n                if i = nrows_iarray A \\<or>\n                   A !! i !! k = (0::'a) \\<and>\n                   vector_all_zero_from_index (i + 1, column_iarray k A)\n                then (A, i, bezout)\n                else if vector_all_zero_from_index\n                         (i + 1, column_iarray k A)\n                     then (A, i + 1, bezout)\n                     else (bezout_iterate_iarrays\n                            (interchange_rows_iarray A i\n                              (least_non_zero_position_of_vector_from_index\n                                (column_iarray k A) i))\n                            (nrows_iarray A - 1) i k bezout,\n                           i + 1, bezout)))", "by auto"], ["proof (state)\nthis:\n  snd (echelon_form_of_column_k bezout (A, i) k) =\n  fst (snd (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout)\n             k))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary fst_snd_matrix_to_iarray_echelon_form_of_column_k:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  and i: \"i\\<le>nrows A\"\n  shows \"snd ((echelon_form_of_column_k bezout) (A,i) k)\n  = fst (snd (echelon_form_of_column_k_iarrays (matrix_to_iarray A, i, bezout) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "using snd_matrix_to_iarray_echelon_form_of_column_k[OF assms]"], ["proof (prove)\nusing this:\n  snd (echelon_form_of_column_k ?bezout (A, i) k) =\n  fst (snd (echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, i, ?bezout) k))\n\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k bezout (A, i) k) =\n    fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, i, bezout) k))", "by simp"], ["", "subsubsection\\<open>Echelon form up to column k for immutable arrays\\<close>"], ["", "lemma snd_snd_foldl_echelon_form_of_column_k_iarrays:\n  \"snd (snd (foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A, 0, bezout) [0..<k])) \n  = bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<k])) =\n    bezout", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. snd (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<0])) =\n    bezout\n 2. \\<And>k.\n       snd (snd (foldl echelon_form_of_column_k_iarrays\n                  (matrix_to_iarray A, 0, bezout) [0..<k])) =\n       bezout \\<Longrightarrow>\n       snd (snd (foldl echelon_form_of_column_k_iarrays\n                  (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n       bezout", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. snd (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<0])) =\n    bezout\n 2. \\<And>k.\n       snd (snd (foldl echelon_form_of_column_k_iarrays\n                  (matrix_to_iarray A, 0, bezout) [0..<k])) =\n       bezout \\<Longrightarrow>\n       snd (snd (foldl echelon_form_of_column_k_iarrays\n                  (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n       bezout", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<0])) =\n    bezout", "by auto"], ["proof (state)\nthis:\n  snd (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<0])) =\n  bezout\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       snd (snd (foldl echelon_form_of_column_k_iarrays\n                  (matrix_to_iarray A, 0, bezout) [0..<k])) =\n       bezout \\<Longrightarrow>\n       snd (snd (foldl echelon_form_of_column_k_iarrays\n                  (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n       bezout", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       snd (snd (foldl echelon_form_of_column_k_iarrays\n                  (matrix_to_iarray A, 0, bezout) [0..<k])) =\n       bezout \\<Longrightarrow>\n       snd (snd (foldl echelon_form_of_column_k_iarrays\n                  (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n       bezout", "case (Suc k)"], ["proof (state)\nthis:\n  snd (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<k])) =\n  bezout\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       snd (snd (foldl echelon_form_of_column_k_iarrays\n                  (matrix_to_iarray A, 0, bezout) [0..<k])) =\n       bezout \\<Longrightarrow>\n       snd (snd (foldl echelon_form_of_column_k_iarrays\n                  (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n       bezout", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n    bezout", "using Suc.hyps"], ["proof (prove)\nusing this:\n  snd (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<k])) =\n  bezout\n\ngoal (1 subgoal):\n 1. snd (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n    bezout", "unfolding echelon_form_of_column_k_iarrays_def"], ["proof (prove)\nusing this:\n  snd (snd (foldl\n             (\\<lambda>a b.\n                 let (A, i, bezout) = a; nrows_A = nrows_iarray A;\n                     column_Ak = column_iarray b A;\n                     all_zero_below_i =\n                       vector_all_zero_from_index (i + 1, column_Ak)\n                 in if i = nrows_A \\<or>\n                       A !! i !! b = (0::'a) \\<and> all_zero_below_i\n                    then (A, i, bezout)\n                    else if all_zero_below_i then (A, i + 1, bezout)\n                         else let n = least_non_zero_position_of_vector_from_index\n column_Ak i;\n                                  interchange_A =\n                                    interchange_rows_iarray A i n\n                              in (bezout_iterate_iarrays interchange_A\n                                   (nrows_A - 1) i b bezout,\n                                  i + 1, bezout))\n             (matrix_to_iarray A, 0, bezout) [0..<k])) =\n  bezout\n\ngoal (1 subgoal):\n 1. snd (snd (foldl\n               (\\<lambda>a b.\n                   let (A, i, bezout) = a; nrows_A = nrows_iarray A;\n                       column_Ak = column_iarray b A;\n                       all_zero_below_i =\n                         vector_all_zero_from_index (i + 1, column_Ak)\n                   in if i = nrows_A \\<or>\n                         A !! i !! b = (0::'a) \\<and> all_zero_below_i\n                      then (A, i, bezout)\n                      else if all_zero_below_i then (A, i + 1, bezout)\n                           else let n =\nleast_non_zero_position_of_vector_from_index column_Ak i;\n                                    interchange_A =\ninterchange_rows_iarray A i n\n                                in (bezout_iterate_iarrays interchange_A\n                                     (nrows_A - 1) i b bezout,\n                                    i + 1, bezout))\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n    bezout", "unfolding Let_def"], ["proof (prove)\nusing this:\n  snd (snd (foldl\n             (\\<lambda>a aa.\n                 case a of\n                 (A, i, bezout) \\<Rightarrow>\n                   if i = nrows_iarray A \\<or>\n                      A !! i !! aa = (0::'a) \\<and>\n                      vector_all_zero_from_index (i + 1, column_iarray aa A)\n                   then (A, i, bezout)\n                   else if vector_all_zero_from_index\n                            (i + 1, column_iarray aa A)\n                        then (A, i + 1, bezout)\n                        else (bezout_iterate_iarrays\n                               (interchange_rows_iarray A i\n                                 (least_non_zero_position_of_vector_from_index\n                                   (column_iarray aa A) i))\n                               (nrows_iarray A - 1) i aa bezout,\n                              i + 1, bezout))\n             (matrix_to_iarray A, 0, bezout) [0..<k])) =\n  bezout\n\ngoal (1 subgoal):\n 1. snd (snd (foldl\n               (\\<lambda>a aa.\n                   case a of\n                   (A, i, bezout) \\<Rightarrow>\n                     if i = nrows_iarray A \\<or>\n                        A !! i !! aa = (0::'a) \\<and>\n                        vector_all_zero_from_index\n                         (i + 1, column_iarray aa A)\n                     then (A, i, bezout)\n                     else if vector_all_zero_from_index\n                              (i + 1, column_iarray aa A)\n                          then (A, i + 1, bezout)\n                          else (bezout_iterate_iarrays\n                                 (interchange_rows_iarray A i\n                                   (least_non_zero_position_of_vector_from_index\n                                     (column_iarray aa A) i))\n                                 (nrows_iarray A - 1) i aa bezout,\n                                i + 1, bezout))\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n    bezout", "unfolding split_beta"], ["proof (prove)\nusing this:\n  snd (snd (foldl\n             (\\<lambda>a b.\n                 if fst (snd a) = nrows_iarray (fst a) \\<or>\n                    fst a !! fst (snd a) !! b = (0::'a) \\<and>\n                    vector_all_zero_from_index\n                     (fst (snd a) + 1, column_iarray b (fst a))\n                 then (fst a, fst (snd a), snd (snd a))\n                 else if vector_all_zero_from_index\n                          (fst (snd a) + 1, column_iarray b (fst a))\n                      then (fst a, fst (snd a) + 1, snd (snd a))\n                      else (bezout_iterate_iarrays\n                             (interchange_rows_iarray (fst a) (fst (snd a))\n                               (least_non_zero_position_of_vector_from_index\n                                 (column_iarray b (fst a)) (fst (snd a))))\n                             (nrows_iarray (fst a) - 1) (fst (snd a)) b\n                             (snd (snd a)),\n                            fst (snd a) + 1, snd (snd a)))\n             (matrix_to_iarray A, 0, bezout) [0..<k])) =\n  bezout\n\ngoal (1 subgoal):\n 1. snd (snd (foldl\n               (\\<lambda>a b.\n                   if fst (snd a) = nrows_iarray (fst a) \\<or>\n                      fst a !! fst (snd a) !! b = (0::'a) \\<and>\n                      vector_all_zero_from_index\n                       (fst (snd a) + 1, column_iarray b (fst a))\n                   then (fst a, fst (snd a), snd (snd a))\n                   else if vector_all_zero_from_index\n                            (fst (snd a) + 1, column_iarray b (fst a))\n                        then (fst a, fst (snd a) + 1, snd (snd a))\n                        else (bezout_iterate_iarrays\n                               (interchange_rows_iarray (fst a)\n                                 (fst (snd a))\n                                 (least_non_zero_position_of_vector_from_index\n                                   (column_iarray b (fst a)) (fst (snd a))))\n                               (nrows_iarray (fst a) - 1) (fst (snd a)) b\n                               (snd (snd a)),\n                              fst (snd a) + 1, snd (snd a)))\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n    bezout", "by auto"], ["proof (state)\nthis:\n  snd (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n  bezout\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foldl_echelon_form_column_k_eq:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  shows matrix_to_iarray_echelon_form_of_upt_k[code_unfold]: \n  \"matrix_to_iarray (echelon_form_of_upt_k A k bezout)\n  = echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout\"\n  and fst_foldl_ef_k_eq: \"fst (snd (foldl echelon_form_of_column_k_iarrays \n  (matrix_to_iarray A,0,bezout) [0..<Suc k])) \n  = snd (foldl (echelon_form_of_column_k bezout) (A,0) [0..<Suc k])\"\n  and fst_foldl_ef_k_less:\n  \"snd (foldl (echelon_form_of_column_k bezout) (A,0) [0..<Suc k]) \\<le> nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n    echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout &&&\n    fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) &&&\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n    \\<le> nrows A", "using assms"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n    echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout &&&\n    fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) &&&\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n    \\<le> nrows A", "proof (induct k)"], ["proof (state)\ngoal (6 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    matrix_to_iarray (echelon_form_of_upt_k A 0 bezout) =\n    echelon_form_of_upt_k_iarrays (matrix_to_iarray A) 0 bezout\n 2. 0 < ncols A \\<Longrightarrow>\n    fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc 0])) =\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])\n 3. 0 < ncols A \\<Longrightarrow>\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])\n    \\<le> nrows A\n 4. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 5. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 6. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"matrix_to_iarray (echelon_form_of_upt_k A 0 bezout) \n    = echelon_form_of_upt_k_iarrays (matrix_to_iarray A) 0 bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (echelon_form_of_upt_k A 0 bezout) =\n    echelon_form_of_upt_k_iarrays (matrix_to_iarray A) 0 bezout", "unfolding echelon_form_of_upt_k_def echelon_form_of_upt_k_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])) =\n    fst (foldl echelon_form_of_column_k_iarrays\n          (matrix_to_iarray A, 0, bezout) [0..<Suc 0])", "by (simp, metis le0 matrix_to_iarray_echelon_form_of_column_k ncols_not_0 neq0_conv)"], ["proof (state)\nthis:\n  matrix_to_iarray (echelon_form_of_upt_k A 0 bezout) =\n  echelon_form_of_upt_k_iarrays (matrix_to_iarray A) 0 bezout\n\ngoal (5 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc 0])) =\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])\n 2. 0 < ncols A \\<Longrightarrow>\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])\n    \\<le> nrows A\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 4. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 5. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"fst (snd (foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A, 0, bezout) [0..<Suc 0]))\n    = snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc 0])) =\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])", "by (simp, metis le0 ncols_not_0 not_gr0 snd_matrix_to_iarray_echelon_form_of_column_k)"], ["proof (state)\nthis:\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc 0])) =\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])\n\ngoal (4 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])\n    \\<le> nrows A\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 4. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]) \\<le> nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])\n    \\<le> nrows A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k bezout (A, 0) 0) \\<le> nrows A", "unfolding echelon_form_of_column_k_def Let_def snd_conv fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (case (A, 0) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat 0 = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat 0 = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat 0 \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat 0) bezout,\n                      i + 1))\n    \\<le> nrows A", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (case (A, 0) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat 0 = (0::'a)) \\<or>\n              i = CARD('rows)\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat 0 = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat 0 \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (CARD('rows) - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat 0) bezout,\n                      i + 1))\n    \\<le> CARD('rows)", "by auto"], ["proof (state)\nthis:\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])\n  \\<le> nrows A\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "fix k"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "assume \"(k < ncols A \\<Longrightarrow> matrix_to_iarray (echelon_form_of_upt_k A k bezout) \n    = echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout)\"\n    and  \"(k < ncols A \\<Longrightarrow>\n    fst (snd (foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\"\n    and hyp3: \"(k < ncols A \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) \\<le> nrows A)\"\n    and Suc_k_less_card: \"Suc k < ncols A\""], ["proof (state)\nthis:\n  k < ncols A \\<Longrightarrow>\n  matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n  echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout\n  k < ncols A \\<Longrightarrow>\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  k < ncols A \\<Longrightarrow>\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  \\<le> nrows A\n  Suc k < ncols A\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "hence hyp1: \"matrix_to_iarray (echelon_form_of_upt_k A k bezout) \n    = echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout\"\n    and hyp2: \"fst (snd (foldl echelon_form_of_column_k_iarrays \n    (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n    = snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\"\n    and hyp3: \"snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) \\<le> nrows A\""], ["proof (prove)\nusing this:\n  k < ncols A \\<Longrightarrow>\n  matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n  echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout\n  k < ncols A \\<Longrightarrow>\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  k < ncols A \\<Longrightarrow>\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  \\<le> nrows A\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n    echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout &&&\n    fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) &&&\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n    \\<le> nrows A", "by auto"], ["proof (state)\nthis:\n  matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n  echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  \\<le> nrows A\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "hence hyp1_unfolded: \"matrix_to_iarray (fst (foldl (echelon_form_of_column_k bezout) (A,0) [0..<Suc k])) \n    = fst (foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A,0,bezout) [0..<Suc k])\""], ["proof (prove)\nusing this:\n  matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n  echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  \\<le> nrows A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])) =\n    fst (foldl echelon_form_of_column_k_iarrays\n          (matrix_to_iarray A, 0, bezout) [0..<Suc k])", "using hyp1"], ["proof (prove)\nusing this:\n  matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n  echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  \\<le> nrows A\n  matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n  echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])) =\n    fst (foldl echelon_form_of_column_k_iarrays\n          (matrix_to_iarray A, 0, bezout) [0..<Suc k])", "unfolding echelon_form_of_upt_k_def echelon_form_of_upt_k_iarrays_def"], ["proof (prove)\nusing this:\n  matrix_to_iarray\n   (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])) =\n  fst (foldl echelon_form_of_column_k_iarrays\n        (matrix_to_iarray A, 0, bezout) [0..<Suc k])\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  \\<le> nrows A\n  matrix_to_iarray\n   (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])) =\n  fst (foldl echelon_form_of_column_k_iarrays\n        (matrix_to_iarray A, 0, bezout) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])) =\n    fst (foldl echelon_form_of_column_k_iarrays\n          (matrix_to_iarray A, 0, bezout) [0..<Suc k])", "by simp"], ["proof (state)\nthis:\n  matrix_to_iarray\n   (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])) =\n  fst (foldl echelon_form_of_column_k_iarrays\n        (matrix_to_iarray A, 0, bezout) [0..<Suc k])\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "have upt_rw: \"[0..<Suc (Suc k)] = [0..<Suc k] @ [(Suc k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by auto"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "let ?f = \"foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A, 0, bezout) [0..<Suc k]\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "let ?f2 = \"foldl (echelon_form_of_column_k bezout) (A,0) [0..<(Suc k)]\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "have fold_rw: \"?f = (fst ?f, fst (snd ?f), snd (snd ?f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A, 0, bezout)\n     [0..<Suc k] =\n    (fst (foldl echelon_form_of_column_k_iarrays\n           (matrix_to_iarray A, 0, bezout) [0..<Suc k]),\n     fst (snd (foldl echelon_form_of_column_k_iarrays\n                (matrix_to_iarray A, 0, bezout) [0..<Suc k])),\n     snd (snd (foldl echelon_form_of_column_k_iarrays\n                (matrix_to_iarray A, 0, bezout) [0..<Suc k])))", "by simp"], ["proof (state)\nthis:\n  foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A, 0, bezout)\n   [0..<Suc k] =\n  (fst (foldl echelon_form_of_column_k_iarrays\n         (matrix_to_iarray A, 0, bezout) [0..<Suc k]),\n   fst (snd (foldl echelon_form_of_column_k_iarrays\n              (matrix_to_iarray A, 0, bezout) [0..<Suc k])),\n   snd (snd (foldl echelon_form_of_column_k_iarrays\n              (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "have fold_rw': \"?f2 = (fst ?f2, snd ?f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n     snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))", "by simp"], ["proof (state)\nthis:\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n   snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "have rw: \"snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n    = fst (snd (foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) =\n    fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k]))", "using hyp2"], ["proof (prove)\nusing this:\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) =\n    fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k]))", "by auto"], ["proof (state)\nthis:\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) =\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl echelon_form_of_column_k_iarrays\n                                    (matrix_to_iarray A, 0, bezout)\n                                    [0..<Suc (Suc k)])) =\n                         snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"fst (snd (foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A, 0, bezout) \n    [0..<Suc (Suc k)])) = snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc (Suc k)])) =\n    snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)])", "unfolding upt_rw foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl echelon_form_of_column_k_iarrays\n               (foldl echelon_form_of_column_k_iarrays\n                 (matrix_to_iarray A, 0, bezout) [0..<Suc k])\n               [Suc k])) =\n    snd (foldl (echelon_form_of_column_k bezout)\n          (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n          [Suc k])", "unfolding List.foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (echelon_form_of_column_k_iarrays\n               (foldl echelon_form_of_column_k_iarrays\n                 (matrix_to_iarray A, 0, bezout) [0..<Suc k])\n               (Suc k))) =\n    snd (echelon_form_of_column_k bezout\n          (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n          (Suc k))", "apply (subst fold_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (echelon_form_of_column_k_iarrays\n               (fst (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k]),\n                fst (snd (foldl echelon_form_of_column_k_iarrays\n                           (matrix_to_iarray A, 0, bezout) [0..<Suc k])),\n                snd (snd (foldl echelon_form_of_column_k_iarrays\n                           (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n               (Suc k))) =\n    snd (echelon_form_of_column_k bezout\n          (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n          (Suc k))", "apply (subst fold_rw')"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (echelon_form_of_column_k_iarrays\n               (fst (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k]),\n                fst (snd (foldl echelon_form_of_column_k_iarrays\n                           (matrix_to_iarray A, 0, bezout) [0..<Suc k])),\n                snd (snd (foldl echelon_form_of_column_k_iarrays\n                           (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n               (Suc k))) =\n    snd (echelon_form_of_column_k bezout\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n           snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n          (Suc k))", "unfolding hyp2"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (echelon_form_of_column_k_iarrays\n               (fst (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k]),\n                snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                      [0..<Suc k]),\n                snd (snd (foldl echelon_form_of_column_k_iarrays\n                           (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n               (Suc k))) =\n    snd (echelon_form_of_column_k bezout\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n           snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n          (Suc k))", "unfolding hyp1_unfolded[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray\n                 (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                        [0..<Suc k])),\n                snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                      [0..<Suc k]),\n                snd (snd (foldl echelon_form_of_column_k_iarrays\n                           (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n               (Suc k))) =\n    snd (echelon_form_of_column_k bezout\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n           snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n          (Suc k))", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray\n                 (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                        [0..<Suc k])),\n                fst (snd (foldl echelon_form_of_column_k_iarrays\n                           (matrix_to_iarray A, 0, bezout) [0..<Suc k])),\n                snd (snd (foldl echelon_form_of_column_k_iarrays\n                           (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n               (Suc k))) =\n    snd (echelon_form_of_column_k bezout\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n           fst (snd (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n          (Suc k))", "unfolding snd_snd_foldl_echelon_form_of_column_k_iarrays"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (echelon_form_of_column_k_iarrays\n               (matrix_to_iarray\n                 (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                        [0..<Suc k])),\n                fst (snd (foldl echelon_form_of_column_k_iarrays\n                           (matrix_to_iarray A, 0, bezout) [0..<Suc k])),\n                bezout)\n               (Suc k))) =\n    snd (echelon_form_of_column_k bezout\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n           fst (snd (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n          (Suc k))", "proof (rule fst_snd_matrix_to_iarray_echelon_form_of_column_k [symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc k\n    < ncols\n       (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n 2. fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n    \\<le> nrows\n           (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                  [0..<Suc k]))", "show \"Suc k < ncols (fst ?f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k\n    < ncols\n       (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))", "using Suc_k_less_card"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. Suc k\n    < ncols\n       (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('cols)\n\ngoal (1 subgoal):\n 1. Suc k < CARD('cols)", "."], ["proof (state)\nthis:\n  Suc k\n  < ncols (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n\ngoal (1 subgoal):\n 1. fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n    \\<le> nrows\n           (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                  [0..<Suc k]))", "show \"fst (snd (foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n    \\<le> nrows (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n    \\<le> nrows\n           (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                  [0..<Suc k]))", "by (metis hyp2 hyp3 nrows_def)"], ["proof (state)\nthis:\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n  \\<le> nrows\n         (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc (Suc k)])) =\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)])\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (echelon_form_of_upt_k A (Suc k) bezout) =\n                         echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k) bezout\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"matrix_to_iarray (echelon_form_of_upt_k A (Suc k) bezout) \n    = echelon_form_of_upt_k_iarrays (matrix_to_iarray A) (Suc k) bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (echelon_form_of_upt_k A (Suc k) bezout) =\n    echelon_form_of_upt_k_iarrays (matrix_to_iarray A) (Suc k) bezout", "unfolding echelon_form_of_upt_k_def echelon_form_of_upt_k_iarrays_def\n      upt_rw foldl_append List.foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (echelon_form_of_column_k bezout\n            (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n            (Suc k))) =\n    fst (echelon_form_of_column_k_iarrays\n          (foldl echelon_form_of_column_k_iarrays\n            (matrix_to_iarray A, 0, bezout) [0..<Suc k])\n          (Suc k))", "apply (subst fold_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (echelon_form_of_column_k bezout\n            (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n            (Suc k))) =\n    fst (echelon_form_of_column_k_iarrays\n          (fst (foldl echelon_form_of_column_k_iarrays\n                 (matrix_to_iarray A, 0, bezout) [0..<Suc k]),\n           fst (snd (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k])),\n           snd (snd (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n          (Suc k))", "apply (subst fold_rw')"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (echelon_form_of_column_k bezout\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]),\n             snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]))\n            (Suc k))) =\n    fst (echelon_form_of_column_k_iarrays\n          (fst (foldl echelon_form_of_column_k_iarrays\n                 (matrix_to_iarray A, 0, bezout) [0..<Suc k]),\n           fst (snd (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k])),\n           snd (snd (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n          (Suc k))", "unfolding hyp2 hyp1_unfolded[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (echelon_form_of_column_k bezout\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]),\n             snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]))\n            (Suc k))) =\n    fst (echelon_form_of_column_k_iarrays\n          (matrix_to_iarray\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k])),\n           snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n           snd (snd (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n          (Suc k))", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (echelon_form_of_column_k bezout\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]),\n             fst (snd (foldl echelon_form_of_column_k_iarrays\n                        (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n            (Suc k))) =\n    fst (echelon_form_of_column_k_iarrays\n          (matrix_to_iarray\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k])),\n           fst (snd (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k])),\n           snd (snd (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n          (Suc k))", "unfolding snd_snd_foldl_echelon_form_of_column_k_iarrays"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (fst (echelon_form_of_column_k bezout\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]),\n             fst (snd (foldl echelon_form_of_column_k_iarrays\n                        (matrix_to_iarray A, 0, bezout) [0..<Suc k])))\n            (Suc k))) =\n    fst (echelon_form_of_column_k_iarrays\n          (matrix_to_iarray\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k])),\n           fst (snd (foldl echelon_form_of_column_k_iarrays\n                      (matrix_to_iarray A, 0, bezout) [0..<Suc k])),\n           bezout)\n          (Suc k))", "proof (rule matrix_to_iarray_echelon_form_of_column_k)"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc k\n    < ncols\n       (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n 2. fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n    \\<le> nrows\n           (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                  [0..<Suc k]))", "show \"Suc k < ncols (fst ?f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k\n    < ncols\n       (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))", "using Suc_k_less_card"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. Suc k\n    < ncols\n       (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('cols)\n\ngoal (1 subgoal):\n 1. Suc k < CARD('cols)", "."], ["proof (state)\nthis:\n  Suc k\n  < ncols (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n\ngoal (1 subgoal):\n 1. fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n    \\<le> nrows\n           (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                  [0..<Suc k]))", "show \"fst (snd (foldl echelon_form_of_column_k_iarrays (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n    \\<le> nrows (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl echelon_form_of_column_k_iarrays\n               (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n    \\<le> nrows\n           (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                  [0..<Suc k]))", "by (metis hyp2 hyp3 nrows_def)"], ["proof (state)\nthis:\n  fst (snd (foldl echelon_form_of_column_k_iarrays\n             (matrix_to_iarray A, 0, bezout) [0..<Suc k]))\n  \\<le> nrows\n         (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_to_iarray (echelon_form_of_upt_k A (Suc k) bezout) =\n  echelon_form_of_upt_k_iarrays (matrix_to_iarray A) (Suc k) bezout\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (echelon_form_of_upt_k A k bezout) =\n                echelon_form_of_upt_k_iarrays (matrix_to_iarray A) k bezout;\n        k < ncols A \\<Longrightarrow>\n        fst (snd (foldl echelon_form_of_column_k_iarrays\n                   (matrix_to_iarray A, 0, bezout) [0..<Suc k])) =\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n        \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) \\<le> nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)])\n    \\<le> nrows A", "using [[unfold_abs_def = false]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)])\n    \\<le> nrows A", "unfolding upt_rw foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout)\n          (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n          [Suc k])\n    \\<le> nrows A", "unfolding List.foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k bezout\n          (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n          (Suc k))\n    \\<le> nrows A", "apply (subst fold_rw')"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k bezout\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n           snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n          (Suc k))\n    \\<le> nrows A", "unfolding echelon_form_of_column_k_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (case (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k]),\n               snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k])) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat (Suc k) = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $\n                             mod_type_class.from_nat (Suc k) \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat (Suc k)) bezout,\n                      i + 1))\n    \\<le> nrows A", "using hyp3 le_antisym not_less_eq_eq"], ["proof (prove)\nusing this:\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  \\<le> nrows A\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n\ngoal (1 subgoal):\n 1. snd (case (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k]),\n               snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k])) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat (Suc k) = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $\n                             mod_type_class.from_nat (Suc k) \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat (Suc k)) bezout,\n                      i + 1))\n    \\<le> nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n  \\<le> CARD('rows)\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n\ngoal (1 subgoal):\n 1. snd (case (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k]),\n               snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k])) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat (Suc k) = (0::'a)) \\<or>\n              i = CARD('rows)\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $\n                             mod_type_class.from_nat (Suc k) \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (CARD('rows) - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat (Suc k)) bezout,\n                      i + 1))\n    \\<le> CARD('rows)", "by fastforce"], ["proof (state)\nthis:\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)])\n  \\<le> nrows A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Echelon form up to column k for immutable arrays\\<close>"], ["", "lemma matrix_to_iarray_echelon_form_of[code_unfold]:\n  \"matrix_to_iarray (echelon_form_of A bezout) \n    = echelon_form_of_iarrays (matrix_to_iarray A) bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (echelon_form_of A bezout) =\n    echelon_form_of_iarrays (matrix_to_iarray A) bezout", "unfolding echelon_form_of_def echelon_form_of_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (echelon_form_of_upt_k A (ncols A - 1) bezout) =\n    echelon_form_of_upt_k_iarrays (matrix_to_iarray A)\n     (ncols_iarray (matrix_to_iarray A) - 1) bezout", "by (metis (poly_guards_query) One_nat_def diff_less lessI matrix_to_iarray_echelon_form_of_upt_k \n    ncols_def ncols_eq_card_columns zero_less_card_finite)"], ["", "end"]]}