{"file_name": "/home/qj213/afp-2021-10-22/thys/Echelon_Form/Echelon_Form_Inverse.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Echelon_Form", "problem_names": ["lemma scalar_mult_mat: \n  fixes x :: \"'a::comm_semiring_0\"\n  shows \"x *k mat y = mat (x * y)\"", "lemma matrix_mul_mat:\n  fixes A :: \"'a::comm_semiring_1 ^ 'm ^ 'n\"\n  shows \"A ** mat x = x *k A\"", "lemma mult_adjugate_det: \"A ** adjugate A = mat (det A)\"", "lemma invertible_imp_matrix_inv:\n  assumes i: \"invertible (A :: ('a :: {comm_ring_1,euclidean_semiring}) ^ 'b ^ 'b)\"\n  shows \"matrix_inv A = (1 div (det A)) *k adjugate A\"", "lemma inverse_matrix_code_rings[code_unfold]: \n  fixes A::\"'a::{euclidean_ring}^'n::{mod_type}^'n::{mod_type}\"\n  shows \"inverse_matrix A = (let d=det A in if is_unit d then Some ((1 div d) *k adjugate A) else None)\""], "translations": [["", "lemma scalar_mult_mat: \n  fixes x :: \"'a::comm_semiring_0\"\n  shows \"x *k mat y = mat (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x *k mat y = mat (x * y)", "by (simp add: matrix_scalar_mult_def mat_def vec_eq_iff)"], ["", "lemma matrix_mul_mat:\n  fixes A :: \"'a::comm_semiring_1 ^ 'm ^ 'n\"\n  shows \"A ** mat x = x *k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** mat x = x *k A", "by (simp add: matrix_matrix_mult_def mat_def if_distrib sum.If_cases matrix_scalar_mult_def vec_eq_iff ac_simps)"], ["", "lemma mult_adjugate_det: \"A ** adjugate A = mat (det A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** adjugate A = mat (det A)", "using mult_adjugate_det[of \"from_vec A\"]"], ["proof (prove)\nusing this:\n  from_vec A * Square_Matrix.adjugate (from_vec A) =\n  diag (Square_Matrix.det (from_vec A))\n\ngoal (1 subgoal):\n 1. A ** adjugate A = mat (det A)", "unfolding det_sq_matrix_eq adjugate_eq to_vec_eq_iff[symmetric] to_vec_matrix_matrix_mult to_vec_from_vec"], ["proof (prove)\nusing this:\n  A ** to_vec (Square_Matrix.adjugate (from_vec A)) = to_vec (diag (det A))\n\ngoal (1 subgoal):\n 1. A ** (to_vec \\<circ> Square_Matrix.adjugate \\<circ> from_vec) A =\n    mat (det A)", "by (simp add: to_vec_diag)"], ["", "lemma invertible_imp_matrix_inv:\n  assumes i: \"invertible (A :: ('a :: {comm_ring_1,euclidean_semiring}) ^ 'b ^ 'b)\"\n  shows \"matrix_inv A = (1 div (det A)) *k adjugate A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv A = (1::'a) div det A *k adjugate A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_inv A = (1::'a) div det A *k adjugate A", "let ?A = \"adjugate A\""], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_inv A = (1::'a) div det A *k adjugate A", "have \"A ** ?A = det A *k mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** adjugate A = det A *k mat (1::'a)", "unfolding mult_adjugate_det"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (det A) = det A *k mat (1::'a)", "by (simp add: scalar_mult_mat)"], ["proof (state)\nthis:\n  A ** adjugate A = det A *k mat (1::'a)\n\ngoal (1 subgoal):\n 1. matrix_inv A = (1::'a) div det A *k adjugate A", "hence \"matrix_inv A ** (A ** ?A) = matrix_inv A ** (det A *k mat 1)\""], ["proof (prove)\nusing this:\n  A ** adjugate A = det A *k mat (1::'a)\n\ngoal (1 subgoal):\n 1. matrix_inv A ** (A ** adjugate A) =\n    matrix_inv A ** (det A *k mat (1::'a))", "by auto"], ["proof (state)\nthis:\n  matrix_inv A ** (A ** adjugate A) = matrix_inv A ** (det A *k mat (1::'a))\n\ngoal (1 subgoal):\n 1. matrix_inv A = (1::'a) div det A *k adjugate A", "hence \"?A = det A *k matrix_inv A\""], ["proof (prove)\nusing this:\n  matrix_inv A ** (A ** adjugate A) = matrix_inv A ** (det A *k mat (1::'a))\n\ngoal (1 subgoal):\n 1. adjugate A = det A *k matrix_inv A", "unfolding matrix_mul_assoc matrix_inv_left[OF i] matrix_mul_lid scalar_mult_mat matrix_mul_mat"], ["proof (prove)\nusing this:\n  adjugate A = det A * (1::'a) *k matrix_inv A\n\ngoal (1 subgoal):\n 1. adjugate A = det A *k matrix_inv A", "by simp"], ["proof (state)\nthis:\n  adjugate A = det A *k matrix_inv A\n\ngoal (1 subgoal):\n 1. matrix_inv A = (1::'a) div det A *k adjugate A", "with i"], ["proof (chain)\npicking this:\n  invertible A\n  adjugate A = det A *k matrix_inv A", "show ?thesis"], ["proof (prove)\nusing this:\n  invertible A\n  adjugate A = det A *k matrix_inv A\n\ngoal (1 subgoal):\n 1. matrix_inv A = (1::'a) div det A *k adjugate A", "by (metis (no_types, lifting) dvd_mult_div_cancel invertible_iff_is_unit\n                 matrix_mul_assoc matrix_mul_mat matrix_mul_rid scalar_mult_mat mult.commute)"], ["proof (state)\nthis:\n  matrix_inv A = (1::'a) div det A *k adjugate A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_matrix_code_rings[code_unfold]: \n  fixes A::\"'a::{euclidean_ring}^'n::{mod_type}^'n::{mod_type}\"\n  shows \"inverse_matrix A = (let d=det A in if is_unit d then Some ((1 div d) *k adjugate A) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_matrix A =\n    (let d = det A\n     in if is_unit d then Some ((1::'a) div d *k adjugate A) else None)", "using invertible_imp_matrix_inv[of A]"], ["proof (prove)\nusing this:\n  invertible A \\<Longrightarrow>\n  matrix_inv A = (1::'a) div det A *k adjugate A\n\ngoal (1 subgoal):\n 1. inverse_matrix A =\n    (let d = det A\n     in if is_unit d then Some ((1::'a) div d *k adjugate A) else None)", "unfolding inverse_matrix_def invertible_iff_is_unit"], ["proof (prove)\nusing this:\n  is_unit (det A) \\<Longrightarrow>\n  matrix_inv A = (1::'a) div det A *k adjugate A\n\ngoal (1 subgoal):\n 1. (if is_unit (det A) then Some (matrix_inv A) else None) =\n    (let d = det A\n     in if is_unit d then Some ((1::'a) div d *k adjugate A) else None)", "by auto"], ["", "end"]]}