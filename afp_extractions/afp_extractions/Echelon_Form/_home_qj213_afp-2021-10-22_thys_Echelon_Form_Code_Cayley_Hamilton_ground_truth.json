{"file_name": "/home/qj213/afp-2021-10-22/thys/Echelon_Form/Code_Cayley_Hamilton.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Echelon_Form", "problem_names": ["lemma scalar_matrix_mult_row_code [code abstract]:\n  \"vec_nth (scalar_matrix_mult_row c A i) =(% j. c * (A $ i $ j))\"", "lemma scalar_matrix_mult_code [code abstract]: \"vec_nth (c *k A)  = scalar_matrix_mult_row c A\"", "lemma minorM_row_code [code abstract]:\n  \"vec_nth (minorM_row A i j k) =(%l. if k = i \\<and> l = j then 1 else\n  if k = i \\<or> l = j then 0 else A$k$l)\"", "lemma minorM_code [code abstract]: \"vec_nth (minorM A i j) = minorM_row A i j\"", "lemma cofactorM_row_code [code abstract]: \"vec_nth (cofactorM_row A i) = cofactor A i\"", "lemma cofactorM_code [code abstract]: \"vec_nth (cofactorM A) = cofactorM_row A\"", "lemmas cofactor_def[code_unfold]", "lemma mat2matofpoly_row_code [code abstract]:\n  \"vec_nth (mat2matofpoly_row A i) = (%j. [: A $ i $ j :])\"", "lemma [code abstract]: \"vec_nth (mat2matofpoly k) = mat2matofpoly_row k\"", "lemma evalmat_unfold:\n  \"evalmat P A = (\\<Sum>i = 0..degree P. coeff P i *k matpow A i)\"", "lemma evalmat_code[code]:\n  \"evalmat P A = (\\<Sum>i\\<leftarrow>[0..int (degree P)]. coeff P (nat i) *k matpow A (nat i))\" (is \"_ = ?rhs\")", "lemma coeffM_zero_row_code [code abstract]:\n  \"vec_nth (coeffM_zero_row A i) = (% j. (coeff (A $ i $ j) 0))\"", "lemma coeffM_zero_code [code abstract]: \"vec_nth (coeffM_zero A) = coeffM_zero_row A\"", "lemma coeffM_row_code [code abstract]:\n  \"vec_nth (coeffM_row A n i) = (% j. coeff (A $ i $ j) n)\"", "lemma coeffM_code [code abstract]: \"vec_nth (coeffM A n) = coeffM_row A n\""], "translations": [["", "lemma scalar_matrix_mult_row_code [code abstract]:\n  \"vec_nth (scalar_matrix_mult_row c A i) =(% j. c * (A $ i $ j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (scalar_matrix_mult_row c A i) = (\\<lambda>j. c * A $ i $ j)", "by(simp add: scalar_matrix_mult_row_def fun_eq_iff)"], ["", "lemma scalar_matrix_mult_code [code abstract]: \"vec_nth (c *k A)  = scalar_matrix_mult_row c A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (c *k A) = scalar_matrix_mult_row c A", "unfolding matrix_scalar_mult_def scalar_matrix_mult_row_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>i j. c * A $ i $ j) = (\\<lambda>i. \\<chi>j. c * A $ i $ j)", "using vec_lambda_beta"], ["proof (prove)\nusing this:\n  vec_lambda ?g $ ?i = ?g ?i\n\ngoal (1 subgoal):\n 1. ($) (\\<chi>i j. c * A $ i $ j) = (\\<lambda>i. \\<chi>j. c * A $ i $ j)", "by auto"], ["", "definition \"minorM_row A i j k=  vec_lambda (%l. if k = i \\<and> l = j then 1 else\n  if k = i \\<or> l = j then 0 else A$k$l)\""], ["", "lemma minorM_row_code [code abstract]:\n  \"vec_nth (minorM_row A i j k) =(%l. if k = i \\<and> l = j then 1 else\n  if k = i \\<or> l = j then 0 else A$k$l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (minorM_row A i j k) =\n    (\\<lambda>l.\n        if k = i \\<and> l = j then 1::'b\n        else if k = i \\<or> l = j then 0::'b else A $ k $ l)", "by(simp add: minorM_row_def fun_eq_iff)"], ["", "lemma minorM_code [code abstract]: \"vec_nth (minorM A i j) = minorM_row A i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (minorM A i j) = minorM_row A i j", "unfolding minorM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>k l.\n            if k = i \\<and> l = j then 1::'b\n            else if k = i \\<or> l = j then 0::'b else A $ k $ l) =\n    minorM_row A i j", "by transfer (auto simp: vec_eq_iff fun_eq_iff minorM_row_def)"], ["", "definition \"cofactorM_row A i = vec_lambda (\\<lambda>j. cofactorM A $ i $ j)\""], ["", "lemma cofactorM_row_code [code abstract]: \"vec_nth (cofactorM_row A i) = cofactor A i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (cofactorM_row A i) = cofactor A i", "by (simp add: fun_eq_iff cofactorM_row_def cofactor_def cofactorM_def)"], ["", "lemma cofactorM_code [code abstract]: \"vec_nth (cofactorM A) = cofactorM_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (cofactorM A) = cofactorM_row A", "by (simp add: fun_eq_iff cofactorM_row_def vec_eq_iff)"], ["", "lemmas cofactor_def[code_unfold]"], ["", "definition mat2matofpoly_row\n  where \"mat2matofpoly_row A i = vec_lambda (\\<lambda>j. [: A $ i $ j :])\""], ["", "lemma mat2matofpoly_row_code [code abstract]:\n  \"vec_nth (mat2matofpoly_row A i) = (%j. [: A $ i $ j :])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (mat2matofpoly_row A i) = (\\<lambda>j. [:A $ i $ j:])", "unfolding mat2matofpoly_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>j. [:A $ i $ j:]) = (\\<lambda>j. [:A $ i $ j:])", "by auto"], ["", "lemma [code abstract]: \"vec_nth (mat2matofpoly k) = mat2matofpoly_row k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (mat2matofpoly k) = mat2matofpoly_row k", "unfolding mat2matofpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>i j. [:k $ i $ j:]) = mat2matofpoly_row k", "unfolding mat2matofpoly_row_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>i j. [:k $ i $ j:]) = (\\<lambda>i. \\<chi>j. [:k $ i $ j:])", "by auto"], ["", "primrec matpow :: \"'a::semiring_1^'n^'n \\<Rightarrow> nat \\<Rightarrow> 'a^'n^'n\" where\n  matpow_0:   \"matpow A 0 = mat 1\" |\n  matpow_Suc: \"matpow A (Suc n) = A ** (matpow A n)\""], ["", "definition evalmat :: \"'a::comm_ring_1 poly \\<Rightarrow> 'a^'n^'n \\<Rightarrow> 'a^'n^'n\" where\n  \"evalmat P A = (\\<Sum> i \\<in> { n::nat . n \\<le> ( degree P ) } . (coeff P i) *k (matpow A i) )\""], ["", "lemma evalmat_unfold:\n  \"evalmat P A = (\\<Sum>i = 0..degree P. coeff P i *k matpow A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalmat P A = (\\<Sum>i = 0..degree P. coeff P i *k matpow A i)", "by (simp add: evalmat_def atMost_def [symmetric] atMost_atLeast0)"], ["", "lemma evalmat_code[code]:\n  \"evalmat P A = (\\<Sum>i\\<leftarrow>[0..int (degree P)]. coeff P (nat i) *k matpow A (nat i))\" (is \"_ = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalmat P A =\n    (\\<Sum>i\\<leftarrow>[0..int (degree\n                                  P)]. coeff P (nat i) *k matpow A (nat i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. evalmat P A =\n    (\\<Sum>i\\<leftarrow>[0..int (degree\n                                  P)]. coeff P (nat i) *k matpow A (nat i))", "let ?t = \"\\<lambda>n. coeff P n *k matpow A n\""], ["proof (state)\ngoal (1 subgoal):\n 1. evalmat P A =\n    (\\<Sum>i\\<leftarrow>[0..int (degree\n                                  P)]. coeff P (nat i) *k matpow A (nat i))", "have \"(\\<Sum>i = 0..degree P. coeff P i *k matpow A i) = (\\<Sum>i\\<in>{0..int (degree P)}. coeff P (nat i) *k matpow A (nat i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..degree P. coeff P i *k matpow A i) =\n    (\\<Sum>i = 0..int (degree P). coeff P (nat i) *k matpow A (nat i))", "by (rule sum.reindex_cong [of nat])\n      (auto simp add: eq_nat_nat_iff image_iff intro: inj_onI, presburger)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..degree P. coeff P i *k matpow A i) =\n  (\\<Sum>i = 0..int (degree P). coeff P (nat i) *k matpow A (nat i))\n\ngoal (1 subgoal):\n 1. evalmat P A =\n    (\\<Sum>i\\<leftarrow>[0..int (degree\n                                  P)]. coeff P (nat i) *k matpow A (nat i))", "(* TODO: why does the proof step above need all of Analysis?? *)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..degree P. coeff P i *k matpow A i) =\n  (\\<Sum>i = 0..int (degree P). coeff P (nat i) *k matpow A (nat i))\n\ngoal (1 subgoal):\n 1. evalmat P A =\n    (\\<Sum>i\\<leftarrow>[0..int (degree\n                                  P)]. coeff P (nat i) *k matpow A (nat i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..degree P. coeff P i *k matpow A i) =\n  (\\<Sum>i = 0..int (degree P). coeff P (nat i) *k matpow A (nat i))\n\ngoal (1 subgoal):\n 1. evalmat P A =\n    (\\<Sum>i\\<leftarrow>[0..int (degree\n                                  P)]. coeff P (nat i) *k matpow A (nat i))", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..int (degree P). coeff P (nat i) *k matpow A (nat i)) =\n    (\\<Sum>i\\<leftarrow>[0..int (degree\n                                  P)]. coeff P (nat i) *k matpow A (nat i))", "by (simp add: sum_set_upto_conv_sum_list_int [symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..int (degree P). coeff P (nat i) *k matpow A (nat i)) =\n  (\\<Sum>i\\<leftarrow>[0..int (degree\n                                P)]. coeff P (nat i) *k matpow A (nat i))\n\ngoal (1 subgoal):\n 1. evalmat P A =\n    (\\<Sum>i\\<leftarrow>[0..int (degree\n                                  P)]. coeff P (nat i) *k matpow A (nat i))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..degree P. coeff P i *k matpow A i) =\n  (\\<Sum>i\\<leftarrow>[0..int (degree\n                                P)]. coeff P (nat i) *k matpow A (nat i))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..degree P. coeff P i *k matpow A i) =\n  (\\<Sum>i\\<leftarrow>[0..int (degree\n                                P)]. coeff P (nat i) *k matpow A (nat i))\n\ngoal (1 subgoal):\n 1. evalmat P A =\n    (\\<Sum>i\\<leftarrow>[0..int (degree\n                                  P)]. coeff P (nat i) *k matpow A (nat i))", "by (simp add: evalmat_unfold)"], ["proof (state)\nthis:\n  evalmat P A =\n  (\\<Sum>i\\<leftarrow>[0..int (degree\n                                P)]. coeff P (nat i) *k matpow A (nat i))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition coeffM_zero :: \"'a poly^'n^'n \\<Rightarrow> 'a::zero^'n^'n\" where\n  \"coeffM_zero A = (\\<chi> i j. (coeff (A $ i $ j) 0))\""], ["", "definition \"coeffM_zero_row A i = (\\<chi> j. (coeff (A $ i $ j) 0))\""], ["", "definition coeffM :: \"'a poly^'n^'n \\<Rightarrow> nat \\<Rightarrow> 'a::zero^'n^'n\" where\n  \"coeffM A n = (\\<chi> i j. coeff (A $ i $ j) n)\""], ["", "lemma coeffM_zero_row_code [code abstract]:\n  \"vec_nth (coeffM_zero_row A i) = (% j. (coeff (A $ i $ j) 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (coeffM_zero_row A i) = (\\<lambda>j. coeff (A $ i $ j) 0)", "by(simp add: coeffM_zero_row_def fun_eq_iff)"], ["", "lemma coeffM_zero_code [code abstract]: \"vec_nth (coeffM_zero A) = coeffM_zero_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (coeffM_zero A) = coeffM_zero_row A", "unfolding coeffM_zero_def coeffM_zero_row_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>i j. coeff (A $ i $ j) 0) =\n    (\\<lambda>i. \\<chi>j. coeff (A $ i $ j) 0)", "using vec_lambda_beta"], ["proof (prove)\nusing this:\n  vec_lambda ?g $ ?i = ?g ?i\n\ngoal (1 subgoal):\n 1. ($) (\\<chi>i j. coeff (A $ i $ j) 0) =\n    (\\<lambda>i. \\<chi>j. coeff (A $ i $ j) 0)", "by auto"], ["", "definition\n  \"coeffM_row A n i = (\\<chi> j. coeff (A $ i $ j) n)\""], ["", "lemma coeffM_row_code [code abstract]:\n  \"vec_nth (coeffM_row A n i) = (% j. coeff (A $ i $ j) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (coeffM_row A n i) = (\\<lambda>j. coeff (A $ i $ j) n)", "by(simp add: coeffM_row_def coeffM_def fun_eq_iff)"], ["", "lemma coeffM_code [code abstract]: \"vec_nth (coeffM A n) = coeffM_row A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (coeffM A n) = coeffM_row A n", "unfolding coeffM_def coeffM_row_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>i j. coeff (A $ i $ j) n) =\n    (\\<lambda>i. \\<chi>j. coeff (A $ i $ j) n)", "using vec_lambda_beta"], ["proof (prove)\nusing this:\n  vec_lambda ?g $ ?i = ?g ?i\n\ngoal (1 subgoal):\n 1. ($) (\\<chi>i j. coeff (A $ i $ j) n) =\n    (\\<lambda>i. \\<chi>j. coeff (A $ i $ j) n)", "by auto"], ["", "end"]]}