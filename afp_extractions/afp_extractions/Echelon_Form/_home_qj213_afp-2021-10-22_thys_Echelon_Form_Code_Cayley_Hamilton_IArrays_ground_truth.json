{"file_name": "/home/qj213/afp-2021-10-22/thys/Echelon_Form/Code_Cayley_Hamilton_IArrays.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Echelon_Form", "problem_names": ["lemma matrix_to_iarray_scalar_matrix_mult[code_unfold]: \n  \"matrix_to_iarray (k *k A) = k *ssi (matrix_to_iarray A)\"", "lemma matrix_to_iarray_minorM[code_unfold]: \n  \"matrix_to_iarray (minorM A i j) = minorM_iarrays (matrix_to_iarray A) (to_nat i) (to_nat j)\"", "lemma matrix_to_iarray_cofactor[code_unfold]: \n  \"(cofactor A i j) = cofactor_iarrays (matrix_to_iarray A) (to_nat i) (to_nat j)\"", "lemma matrix_to_iarray_cofactorM[code_unfold]: \n  \"matrix_to_iarray (cofactorM A) = cofactorM_iarrays (matrix_to_iarray A)\"", "lemma matrix_to_iarray_adjugate[code_unfold]: \n  \"matrix_to_iarray (adjugate A) = adjugate_iarrays (matrix_to_iarray A)\""], "translations": [["", "lemma matrix_to_iarray_scalar_matrix_mult[code_unfold]: \n  \"matrix_to_iarray (k *k A) = k *ssi (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (k *k A) = k *ssi matrix_to_iarray A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_to_iarray (k *k A) = k *ssi matrix_to_iarray A", "have n_rw: \"nrows_iarray (IArray (map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<CARD('c)])) \n    = CARD('c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows_iarray\n     (IArray\n       (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n         [0..<CARD('c)])) =\n    CARD('c)", "unfolding nrows_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n         [0..<CARD('c)])) =\n    CARD('c)", "by auto"], ["proof (state)\nthis:\n  nrows_iarray\n   (IArray\n     (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n       [0..<CARD('c)])) =\n  CARD('c)\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (k *k A) = k *ssi matrix_to_iarray A", "have n_rw2: \"nrows_iarray (IArray (map (\\<lambda>x. IArray (map (\\<lambda>i. A $ from_nat x $ from_nat i) \n    [0..<CARD('b)])) [0..<CARD('c)])) = CARD('c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows_iarray\n     (IArray\n       (map (\\<lambda>x.\n                IArray\n                 (map (\\<lambda>i.\n                          A $ mod_type_class.from_nat x $\n                          mod_type_class.from_nat i)\n                   [0..<CARD('b)]))\n         [0..<CARD('c)])) =\n    CARD('c)", "unfolding nrows_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                IArray\n                 (map (\\<lambda>i.\n                          A $ mod_type_class.from_nat x $\n                          mod_type_class.from_nat i)\n                   [0..<CARD('b)]))\n         [0..<CARD('c)])) =\n    CARD('c)", "by auto"], ["proof (state)\nthis:\n  nrows_iarray\n   (IArray\n     (map (\\<lambda>x.\n              IArray\n               (map (\\<lambda>i.\n                        A $ mod_type_class.from_nat x $\n                        mod_type_class.from_nat i)\n                 [0..<CARD('b)]))\n       [0..<CARD('c)])) =\n  CARD('c)\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (k *k A) = k *ssi matrix_to_iarray A", "have n_rw3: \"ncols_iarray (IArray (map (\\<lambda>x. IArray (map (\\<lambda>i. A $ from_nat x $ from_nat i) \n    [0..<CARD('b)])) [0..<CARD('c)])) = CARD('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols_iarray\n     (IArray\n       (map (\\<lambda>x.\n                IArray\n                 (map (\\<lambda>i.\n                          A $ mod_type_class.from_nat x $\n                          mod_type_class.from_nat i)\n                   [0..<CARD('b)]))\n         [0..<CARD('c)])) =\n    CARD('b)", "unfolding ncols_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                IArray\n                 (map (\\<lambda>i.\n                          A $ mod_type_class.from_nat x $\n                          mod_type_class.from_nat i)\n                   [0..<CARD('b)]))\n         [0..<CARD('c)]) !!\n      0) =\n    CARD('b)", "by auto"], ["proof (state)\nthis:\n  ncols_iarray\n   (IArray\n     (map (\\<lambda>x.\n              IArray\n               (map (\\<lambda>i.\n                        A $ mod_type_class.from_nat x $\n                        mod_type_class.from_nat i)\n                 [0..<CARD('b)]))\n       [0..<CARD('c)])) =\n  CARD('b)\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (k *k A) = k *ssi matrix_to_iarray A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (k *k A) = k *ssi matrix_to_iarray A", "unfolding matrix_to_iarray_def o_def matrix_scalar_mult_def scalar_matrix_mult_iarrays_def\n      tabulate2_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>i.\n                   (\\<chi>i j. k * A $ i $ j) $ mod_type_class.from_nat x $\n                   mod_type_class.from_nat i)\n               CARD('b))\n       [0..<CARD('c)]) =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>j.\n              k *\n              IArray\n               (map (\\<lambda>x.\n                        IArray.of_fun\n                         (\\<lambda>i.\n                             A $ mod_type_class.from_nat x $\n                             mod_type_class.from_nat i)\n                         CARD('b))\n                 [0..<CARD('c)]) !!\n              i !!\n              j)\n          (ncols_iarray\n            (IArray\n              (map (\\<lambda>x.\n                       IArray.of_fun\n                        (\\<lambda>i.\n                            A $ mod_type_class.from_nat x $\n                            mod_type_class.from_nat i)\n                        CARD('b))\n                [0..<CARD('c)]))))\n     (nrows_iarray\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('b))\n           [0..<CARD('c)])))", "by (simp add: n_rw n_rw2 n_rw3)"], ["proof (state)\nthis:\n  matrix_to_iarray (k *k A) = k *ssi matrix_to_iarray A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_minorM[code_unfold]: \n  \"matrix_to_iarray (minorM A i j) = minorM_iarrays (matrix_to_iarray A) (to_nat i) (to_nat j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (minorM A i j) =\n    minorM_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_to_iarray (minorM A i j) =\n    minorM_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j)", "have n_rw: \"nrows_iarray (IArray (map (\\<lambda>x. IArray (map (\\<lambda>i. A $ from_nat x $ from_nat i) \n    [0..<CARD('b)])) [0..<CARD('c)])) = CARD('c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows_iarray\n     (IArray\n       (map (\\<lambda>x.\n                IArray\n                 (map (\\<lambda>i.\n                          A $ mod_type_class.from_nat x $\n                          mod_type_class.from_nat i)\n                   [0..<CARD('b)]))\n         [0..<CARD('c)])) =\n    CARD('c)", "unfolding nrows_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                IArray\n                 (map (\\<lambda>i.\n                          A $ mod_type_class.from_nat x $\n                          mod_type_class.from_nat i)\n                   [0..<CARD('b)]))\n         [0..<CARD('c)])) =\n    CARD('c)", "by auto"], ["proof (state)\nthis:\n  nrows_iarray\n   (IArray\n     (map (\\<lambda>x.\n              IArray\n               (map (\\<lambda>i.\n                        A $ mod_type_class.from_nat x $\n                        mod_type_class.from_nat i)\n                 [0..<CARD('b)]))\n       [0..<CARD('c)])) =\n  CARD('c)\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (minorM A i j) =\n    minorM_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j)", "have n_rw2: \"ncols_iarray (IArray (map (\\<lambda>x. IArray (map (\\<lambda>i. A $ from_nat x $ from_nat i) \n    [0..<CARD('b)])) [0..<CARD('c)])) = CARD('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols_iarray\n     (IArray\n       (map (\\<lambda>x.\n                IArray\n                 (map (\\<lambda>i.\n                          A $ mod_type_class.from_nat x $\n                          mod_type_class.from_nat i)\n                   [0..<CARD('b)]))\n         [0..<CARD('c)])) =\n    CARD('b)", "unfolding ncols_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                IArray\n                 (map (\\<lambda>i.\n                          A $ mod_type_class.from_nat x $\n                          mod_type_class.from_nat i)\n                   [0..<CARD('b)]))\n         [0..<CARD('c)]) !!\n      0) =\n    CARD('b)", "by simp"], ["proof (state)\nthis:\n  ncols_iarray\n   (IArray\n     (map (\\<lambda>x.\n              IArray\n               (map (\\<lambda>i.\n                        A $ mod_type_class.from_nat x $\n                        mod_type_class.from_nat i)\n                 [0..<CARD('b)]))\n       [0..<CARD('c)])) =\n  CARD('b)\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (minorM A i j) =\n    minorM_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (minorM A i j) =\n    minorM_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j)", "unfolding matrix_to_iarray_def o_def\n    minorM_def minorM_iarrays_def\n    tabulate2_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>ia.\n                   (\\<chi>k l.\n                       if k = i \\<and> l = j then 1::'a\n                       else if k = i \\<or> l = j then 0::'a\n                            else A $ k $ l) $\n                   mod_type_class.from_nat x $\n                   mod_type_class.from_nat ia)\n               CARD('b))\n       [0..<CARD('c)]) =\n    IArray.of_fun\n     (\\<lambda>ia.\n         IArray.of_fun\n          (\\<lambda>l.\n              if ia = mod_type_class.to_nat i \\<and>\n                 l = mod_type_class.to_nat j\n              then 1::'a\n              else if ia = mod_type_class.to_nat i \\<or>\n                      l = mod_type_class.to_nat j\n                   then 0::'a\n                   else IArray\n                         (map (\\<lambda>x.\n                                  IArray.of_fun\n                                   (\\<lambda>i.\n A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n                                   CARD('b))\n                           [0..<CARD('c)]) !!\n                        ia !!\n                        l)\n          (ncols_iarray\n            (IArray\n              (map (\\<lambda>x.\n                       IArray.of_fun\n                        (\\<lambda>i.\n                            A $ mod_type_class.from_nat x $\n                            mod_type_class.from_nat i)\n                        CARD('b))\n                [0..<CARD('c)]))))\n     (nrows_iarray\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('b))\n           [0..<CARD('c)])))", "by (auto simp add: n_rw n_rw2 to_nat_from_nat_id)"], ["proof (state)\nthis:\n  matrix_to_iarray (minorM A i j) =\n  minorM_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n   (mod_type_class.to_nat j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_cofactor[code_unfold]: \n  \"(cofactor A i j) = cofactor_iarrays (matrix_to_iarray A) (to_nat i) (to_nat j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cofactor A i j =\n    cofactor_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j)", "unfolding o_def cofactor_iarrays_def cofactor_def cofactorM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (minorM A i j) =\n    det_iarrays_rings\n     (minorM_iarrays (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (mod_type_class.to_nat j))", "unfolding matrix_to_iarray_minorM[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (minorM A i j) = det_iarrays_rings (matrix_to_iarray (minorM A i j))", "unfolding matrix_to_iarray_det_euclidean_ring[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (minorM A i j) = det (minorM A i j)", "by simp"], ["", "lemma matrix_to_iarray_cofactorM[code_unfold]: \n  \"matrix_to_iarray (cofactorM A) = cofactorM_iarrays (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (cofactorM A) = cofactorM_iarrays (matrix_to_iarray A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_to_iarray (cofactorM A) = cofactorM_iarrays (matrix_to_iarray A)", "have n_rw: \"nrows_iarray (IArray (map (\\<lambda>x. IArray (map (\\<lambda>i. A $ from_nat x $ from_nat i) \n    [0..<CARD('b)])) [0..<CARD('b)])) = CARD('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows_iarray\n     (IArray\n       (map (\\<lambda>x.\n                IArray\n                 (map (\\<lambda>i.\n                          A $ mod_type_class.from_nat x $\n                          mod_type_class.from_nat i)\n                   [0..<CARD('b)]))\n         [0..<CARD('b)])) =\n    CARD('b)", "unfolding nrows_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                IArray\n                 (map (\\<lambda>i.\n                          A $ mod_type_class.from_nat x $\n                          mod_type_class.from_nat i)\n                   [0..<CARD('b)]))\n         [0..<CARD('b)])) =\n    CARD('b)", "by simp"], ["proof (state)\nthis:\n  nrows_iarray\n   (IArray\n     (map (\\<lambda>x.\n              IArray\n               (map (\\<lambda>i.\n                        A $ mod_type_class.from_nat x $\n                        mod_type_class.from_nat i)\n                 [0..<CARD('b)]))\n       [0..<CARD('b)])) =\n  CARD('b)\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (cofactorM A) = cofactorM_iarrays (matrix_to_iarray A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (cofactorM A) = cofactorM_iarrays (matrix_to_iarray A)", "unfolding cofactorM_iarrays_def tabulate2_def cofactorM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (\\<chi>i. vec_lambda (cofactor A i)) =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun (cofactor_iarrays (matrix_to_iarray A) i)\n          (nrows_iarray (matrix_to_iarray A)))\n     (nrows_iarray (matrix_to_iarray A))", "by (auto simp add: n_rw matrix_to_iarray_cofactor\n        matrix_to_iarray_def o_def vec_to_iarray_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  matrix_to_iarray (cofactorM A) = cofactorM_iarrays (matrix_to_iarray A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_adjugate[code_unfold]: \n  \"matrix_to_iarray (adjugate A) = adjugate_iarrays (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (adjugate A) = adjugate_iarrays (matrix_to_iarray A)", "unfolding adjugate_def adjugate_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Finite_Cartesian_Product.transpose (cofactorM A)) =\n    transpose_iarray (cofactorM_iarrays (matrix_to_iarray A))", "unfolding matrix_to_iarray_cofactorM[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Finite_Cartesian_Product.transpose (cofactorM A)) =\n    transpose_iarray (matrix_to_iarray (cofactorM A))", "unfolding matrix_to_iarray_transpose[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Finite_Cartesian_Product.transpose (cofactorM A)) =\n    matrix_to_iarray (Finite_Cartesian_Product.transpose (cofactorM A))", ".."], ["", "end"]]}