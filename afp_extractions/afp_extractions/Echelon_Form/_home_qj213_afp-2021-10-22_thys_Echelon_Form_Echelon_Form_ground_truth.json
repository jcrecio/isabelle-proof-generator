{"file_name": "/home/qj213/afp-2021-10-22/thys/Echelon_Form/Echelon_Form.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Echelon_Form", "problem_names": ["lemma echelon_form_upt_k_intro:\n  assumes \"(\\<forall>i. is_zero_row_upt_k i k A \\<longrightarrow> \\<not> (\\<exists>j. j>i \\<and> \\<not> is_zero_row_upt_k j k A))\"\n  and \"(\\<forall>i j. i<j \\<and> \\<not> (is_zero_row_upt_k i k A) \\<and> \\<not> (is_zero_row_upt_k j k A) \n  \\<longrightarrow> ((LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)))\"\n  shows \"echelon_form_upt_k A k\"", "lemma echelon_form_upt_k_condition1:\n  assumes \"echelon_form_upt_k A k\" \"is_zero_row_upt_k i k A\"\n  shows \"\\<not> (\\<exists>j. j>i \\<and> \\<not> is_zero_row_upt_k j k A)\"", "lemma echelon_form_upt_k_condition1':\n  assumes \"echelon_form_upt_k A k\" \"is_zero_row_upt_k i k A\" and \"i<j\"\n  shows \"is_zero_row_upt_k j k A\"", "lemma echelon_form_upt_k_condition2:\n  assumes \"echelon_form_upt_k A k\" \"i<j\"\n  and  \"\\<not> (is_zero_row_upt_k i k A)\" \"\\<not> (is_zero_row_upt_k j k A)\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\"", "lemma echelon_form_upt_k_if_equal:\n  assumes e: \"echelon_form_upt_k A k\"\n  and eq: \"\\<forall>a. \\<forall>b<from_nat k. A $ a $ b = B $ a $ b\"\n  and k: \"k < ncols A\"\n  shows \"echelon_form_upt_k B k\"", "lemma echelon_form_upt_k_0: \"echelon_form_upt_k A 0\"", "lemma echelon_form_condition1:\n  assumes r: \"echelon_form A\"\n  shows \"(\\<forall>i. is_zero_row i A \\<longrightarrow> \\<not> (\\<exists>j. j>i \\<and> \\<not> is_zero_row j A))\"", "lemma echelon_form_condition2:\n  assumes r: \"echelon_form A\"\n  shows \"(\\<forall>i. i<j \\<and> \\<not> (is_zero_row i A) \\<and> \\<not> (is_zero_row j A) \n  \\<longrightarrow> ((LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)))\"", "lemma echelon_form_condition2_explicit:\n  assumes rref_A: \"echelon_form A\"\n  and i_le: \"i < j\"\n  and \"\\<not> is_zero_row i A\" and \"\\<not> is_zero_row j A\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\"", "lemma echelon_form_intro:\n  assumes 1: \"(\\<forall>i. is_zero_row i A \\<longrightarrow> \\<not> (\\<exists>j. j>i \\<and> \\<not> is_zero_row j A))\"\n  and 2: \"(\\<forall>i j. i<j \\<and> \\<not> (is_zero_row i A) \\<and> \\<not> (is_zero_row j A) \n  \\<longrightarrow> ((LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)))\"\n  shows \"echelon_form A\"", "lemma echelon_form_implies_echelon_form_upt:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes rref: \"echelon_form A\"\n  shows \"echelon_form_upt_k A k\"", "lemma upper_triangular_upt_k_def':\n  assumes \"\\<forall>i j. to_nat j \\<le> k \\<and> A $ i $ j \\<noteq> 0 \\<longrightarrow> j\\<ge>i\"\n  shows \"upper_triangular_upt_k A k\"", "lemma echelon_form_imp_upper_triagular_upt:\n  fixes A::\"'a::{bezout_ring}^'n::{mod_type}^'n::{mod_type}\"\n  assumes \"echelon_form A\"\n  shows \"upper_triangular_upt_k A k\"", "lemma echelon_form_imp_upper_triagular:\n  fixes A::\"'a::{bezout_ring}^'n::{mod_type}^'n::{mod_type}\"\n  assumes \"echelon_form A\"\n  shows \"upper_triangular A\"", "lemma echelon_form_upt_k_interchange:\n  fixes A::\"'a::{bezout_ring}^'c::{mod_type}^'b::{mod_type}\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and zero_ikA: \"is_zero_row_upt_k (from_nat i) k A\"\n  and Amk_not_0: \"A $ m $ from_nat k \\<noteq> 0\"\n  and i_le_m: \"(from_nat i)\\<le>m\"\n  and k: \"k<ncols A\"\n  shows \"echelon_form_upt_k (interchange_rows A (from_nat i) \n  (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (from_nat i) \\<le> n)) k\"", "lemma greatest_less_zero_row:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{finite, wellorder}\"\n  assumes r: \"echelon_form_upt_k A k\"\n  and zero_i: \"is_zero_row_upt_k i k A\"\n  and not_all_zero: \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\"\n  shows \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\"", "lemma greatest_ge_nonzero_row':\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"echelon_form_upt_k A k\"\n  and i: \"i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\"\n  and not_all_zero: \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\"\n  shows \"\\<not> is_zero_row_upt_k i k A\"", "lemma rref_imp_ef: \n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes rref: \"reduced_row_echelon_form A\"\n  shows \"echelon_form A\"", "lemma bezout_matrix_works1:\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_not_b: \"a \\<noteq> b\"\n  shows \"(bezout_matrix A a b j bezout ** A) $ a $ j = snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))\"", "lemma bezout_matrix_not_zero:\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_not_b: \"a \\<noteq> b\"\n  and Aaj: \"A $ a $ j \\<noteq> 0\"\n  shows \"(bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> 0\"", "lemma ua_vb_0:\n  fixes a::\"'a::bezout_domain\"\n  assumes ib: \"is_bezout_ext bezout\" and nz: \"snd (snd (snd (snd (bezout a b)))) \\<noteq> 0\"\n  shows \"fst (snd (snd (bezout a b))) * a + fst (snd (snd (snd (bezout a b)))) * b = 0\"", "lemma bezout_matrix_works2:\n  fixes A::\"'a::bezout_domain^'cols^'rows\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_not_b: \"a \\<noteq> b\"\n  and not_0: \"A $ a $ j \\<noteq> 0 \\<or> A $ b $ j \\<noteq> 0\"\n  shows \"(bezout_matrix A a b j bezout ** A) $ b $ j = 0\"", "lemma bezout_matrix_preserves_previous_columns:\n  assumes ib: \"is_bezout_ext bezout\"\n  and i_not_j: \"i \\<noteq> j\"\n  and Aik: \"A $ i $ k \\<noteq> 0\"\n  and b_k: \"b<k\"\n  and i: \"is_zero_row_upt_k i (to_nat k) A\" and j: \"is_zero_row_upt_k j (to_nat k) A\"\n  shows \"(bezout_matrix A i j k bezout ** A) $ a $ b = A $ a $ b\"", "lemma det_bezout_matrix:\n  fixes A::\"'a::{bezout_domain}^'cols^'rows::{finite,wellorder}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_less_b: \"a < b\"\n  and aj: \"A $ a $ j \\<noteq> 0\"\n  shows \"det (bezout_matrix A a b j bezout) = 1\"", "lemma invertible_bezout_matrix:\n  fixes A::\"'a::{bezout_ring_div}^'cols^'rows::{finite,wellorder}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_less_b: \"a < b\"\n  and aj: \"A $ a $ j \\<noteq> 0\"\n  shows \"invertible (bezout_matrix A a b j bezout)\"", "lemma echelon_form_upt_k_bezout_matrix:\n  fixes A k and i::\"'b::mod_type\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and ib: \"is_bezout_ext bezout\"\n  and Aik_0: \"A $ i $ from_nat k \\<noteq> 0\"\n  and zero_i: \"is_zero_row_upt_k i k A\" \n  and i_less_n: \"i<n\"\n  and k: \"k<ncols A\"\n  shows \"echelon_form_upt_k (bezout_matrix A i n (from_nat k) bezout ** A) k\"", "lemma bezout_matrix_preserves_rest:\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_not_n: \"a\\<noteq>n\"\n  and i_not_n: \"i\\<noteq>n\"\n  and a_not_i: \"a\\<noteq>i\"\n  and Aik_0: \"A $ i $ k \\<noteq> 0\"\n  and zero_ikA: \"is_zero_row_upt_k i (to_nat k) A\"\n  shows \"(bezout_matrix A i n k bezout ** A) $ a $ b = A $ a $ b\"", "lemma bezout_matrix_row_code [code abstract]:\n  \"vec_nth (bezout_matrix_row A a b j bezout x) = \n      (let (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n        in\n          (\\<lambda>y. if x = a \\<and> y = a then p else\n               if x = a \\<and> y = b then q else\n               if x = b \\<and> y = a then u else\n               if x = b \\<and> y = b then v else\n               if x = y then 1 else 0))\"", "lemma [code abstract]: \"vec_nth (bezout_matrix A a b j bezout) = bezout_matrix_row A a b j bezout\"", "lemma bezout_iterate_not_zero:\n  assumes Aik_0: \"A $ i $ from_nat k \\<noteq> 0\"\n  and n: \"n<nrows A\"\n  and a: \"to_nat i \\<le> n\"\n  and ib: \"is_bezout_ext bezout\"\n  shows \"bezout_iterate A n i (from_nat k) bezout $ i $ from_nat k \\<noteq> 0\"", "lemma bezout_iterate_preserves:\n  fixes A k and i::\"'b::mod_type\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and ib: \"is_bezout_ext bezout\"\n  and Aik_0: \"A $ i $ from_nat k \\<noteq> 0\"\n  and n: \"n<nrows A\"\n  and \"b < from_nat k\"\n  and i_le_n: \"to_nat i \\<le> n\"\n  and k: \"k<ncols A\"\n  and zero_upt_k_i: \"is_zero_row_upt_k i k A\" \n  shows \"bezout_iterate A n i (from_nat k) bezout $ a $ b = A $ a $ b\"", "lemma bezout_iterate_preserves_below_n:\n  assumes e: \"echelon_form_upt_k A k\"\n  and ib: \"is_bezout_ext bezout\"\n  and Aik_0: \"A $ i $ from_nat k \\<noteq> 0\"\n  and n: \"n<nrows A\"\n  and n_less_a: \"n < to_nat a\"\n  and k: \"k<ncols A\"\n  and i_le_n: \"to_nat i \\<le> n\"\n  and zero_upt_k_i: \"is_zero_row_upt_k i k A\"\n  shows \"bezout_iterate A n i (from_nat k) bezout $ a $ b = A $ a $ b\"", "lemma bezout_iterate_zero_column_k:\n  fixes A::\"'a::bezout_domain^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and ib: \"is_bezout_ext bezout\"\n  and Aik_0: \"A $ i $ from_nat k \\<noteq> 0\"\n  and n: \"n<nrows A\"\n  and i_le_a: \"i<a\"\n  and k: \"k<ncols A\"\n  and a_n: \"to_nat a\\<le>n\"\n  and zero_upt_k_i: \"is_zero_row_upt_k i k A\"\n  shows \"bezout_iterate A n i (from_nat k) bezout $ a $ from_nat k = 0\"", "lemma condition1_index_le_zero_row: \n  fixes A k\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and \"is_zero_row_upt_k a (Suc k) A\"\n  shows \"from_nat i\\<le>a\"", "lemma condition1_part1: \n  fixes A k\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n    else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and a: \"is_zero_row_upt_k a (Suc k) A\"\n  and ab: \"a < b\"\n  and all_zero: \"\\<forall>m\\<ge>from_nat i. A $ m $ from_nat k = 0\"\n  shows \"is_zero_row_upt_k b (Suc k) A\"", "lemma condition1_part2: \n  fixes A k\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and a: \"is_zero_row_upt_k a (Suc k) A\"\n  and ab: \"a < b\"\n  and i_last: \"i = nrows A\"\n  and all_zero: \"\\<forall>m>from_nat (nrows A). A $ m $ from_nat k = 0\"\n  shows \"is_zero_row_upt_k b (Suc k) A\"", "lemma condition1_part3:\n  fixes A k bezout\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B: \"B \\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes e: \"echelon_form_upt_k A k\" and ib: \"is_bezout_ext bezout\"\n  and a: \"is_zero_row_upt_k a (Suc k) B\"\n  and \"a < b\"\n  and all_zero: \"\\<forall>m>from_nat i. A $ m $ from_nat k = 0\"\n  and i_not_last: \"i \\<noteq> nrows A\"\n  and i_le_m: \"from_nat i \\<le> m\"\n  and Amk_not_0: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"is_zero_row_upt_k b (Suc k) A\"", "lemma condition1_part4:\n  fixes A k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B: \"B\\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  assumes a: \"is_zero_row_upt_k a (Suc k) A\"\n  and i_nrows: \"i = nrows A\"\n  shows \"is_zero_row_upt_k b (Suc k) A\"", "lemma condition1_part5:\n  fixes A::\"'a::bezout_domain^'cols::{mod_type}^'rows::{mod_type}\"\n  and k bezout\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n    else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B: \"B \\<equiv> fst((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes ib: \"is_bezout_ext bezout\" and e: \"echelon_form_upt_k A k\"\n  assumes zero_a_B: \"is_zero_row_upt_k a (Suc k) B\"\n  and ab: \"a < b\"\n  and im: \"from_nat i < m\"\n  and Amk_not_0: \"A $ m $ from_nat k \\<noteq> 0\"\n  and not_last_row: \"i \\<noteq> nrows A\"\n  and k: \"k<ncols A\"\n  shows \"is_zero_row_upt_k b (Suc k) (bezout_iterate \n  (interchange_rows A (from_nat i) (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (from_nat i) \\<le> n)) \n  (nrows A - Suc 0) (from_nat i) (from_nat k) bezout)\"", "lemma condition2_part1:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n    else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B:\"B \\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and ab: \"a < b\" and not_zero_aB: \"\\<not> is_zero_row_upt_k a (Suc k) B\" \n  and not_zero_bB: \"\\<not> is_zero_row_upt_k b (Suc k) B\"\n  and all_zero: \"\\<forall>m\\<ge>from_nat i. A $ m $ from_nat k = 0\" \n  shows \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\"", "lemma condition2_part2: \n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else \n  to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and ab: \"a < b\"\n  and all_zero: \"\\<forall>m>from_nat (nrows A). A $ m $ from_nat k = 0\" \n  and i_nrows: \"i = nrows A\"\n  shows \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\"", "lemma condition2_part3:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n    else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B:\"B \\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes e: \"echelon_form_upt_k A k\" and k: \"k<ncols A\"\n  and ab: \"a < b\" and not_zero_aB: \"\\<not> is_zero_row_upt_k a (Suc k) B\" \n  and not_zero_bB: \"\\<not> is_zero_row_upt_k b (Suc k) B\"\n  and all_zero: \"\\<forall>m>from_nat i. A $ m $ from_nat k = 0\"\n  and i_ma: \"from_nat i \\<le> ma\" and A_ma_k: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\"", "lemma condition2_part4:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  assumes  e: \"echelon_form_upt_k A k\"\n  and ab: \"a < b\" \n  and i_nrows: \"i = nrows A\"\n  shows \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\"", "lemma condition2_part5:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B:\"B \\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes ib: \"is_bezout_ext bezout\" and e: \"echelon_form_upt_k A k\" and k: \"k<ncols A\"\n  and ab: \"a < b\" and not_zero_aB: \"\\<not> is_zero_row_upt_k a (Suc k) B\" \n  and not_zero_bB: \"\\<not> is_zero_row_upt_k b (Suc k) B\"\n  and i_m:\"from_nat i < m\"\n  and A_mk: \"A $ m $ from_nat k \\<noteq> 0\"\n  and i_not_nrows: \"i \\<noteq> nrows A\"\n  shows \"(LEAST n. B $ a $ n \\<noteq> 0) < (LEAST n. B $ b $ n \\<noteq> 0)\"", "lemma echelon_echelon_form_column_k:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout\n  defines i:\"i \\<equiv> (if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B: \"B \\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes ib: \"is_bezout_ext bezout\" and e: \"echelon_form_upt_k A k\" and k: \"k<ncols A\"\n  shows \"echelon_form_upt_k B (Suc k)\"", "lemma echelon_foldl_condition1:\n  assumes ib: \"is_bezout_ext bezout\"\n  and \"A $ ma $ from_nat (Suc k) \\<noteq> 0\"\n  and k: \"k<ncols A\"\n  shows \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k))\n  (bezout_iterate (interchange_rows A 0 (LEAST n. A $ n $ from_nat (Suc k) \\<noteq> 0)) \n  (nrows A - Suc 0) 0 (from_nat (Suc k)) bezout)\"", "lemma echelon_foldl_condition2:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes n: \"\\<not> is_zero_row_upt_k ma k A\"\n  and all_zero: \"\\<forall>m\\<ge> (GREATEST n. \\<not> is_zero_row_upt_k n k A)+1. A $ m $ from_nat k = 0\"\n  shows \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) = (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\"", "lemma echelon_foldl_condition3:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and Am0: \"A $ m $ from_nat k \\<noteq> 0\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and e: \"echelon_form_upt_k A k\"\n  and k: \"k < ncols A\"\n  shows \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k)\n  (bezout_iterate (interchange_rows A 0 (LEAST n. A $ n $ from_nat k \\<noteq> 0)) \n  (nrows A - (Suc 0)) 0 (from_nat k) bezout)) = 0\"", "lemma echelon_foldl_condition4:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes all_zero: \"\\<forall>m>(GREATEST n. \\<not> is_zero_row_upt_k n k A)+1.\n  A $ m $ from_nat k = 0\"\n  and greatest_nrows: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and le_mb: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A)+1 \\<le> mb\"\n  and A_mb_k: \"A $ mb $ from_nat k \\<noteq> 0\"\n  shows \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\"", "lemma echelon_foldl_condition5:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"        \n  assumes mb: \"\\<not> is_zero_row_upt_k mb k A\"\n  and nrows: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"nrows A = Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))\"", "lemma echelon_foldl_condition6:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and g_mc: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> mc\"\n  and A_mc_k: \"A $ mc $ from_nat k \\<noteq> 0\"\n  shows \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc k)\n  (bezout_iterate (interchange_rows A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\n  (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> n))\n  (nrows A - Suc 0) ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) bezout)\"", "lemma echelon_foldl_condition7:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and e: \"echelon_form_upt_k A k\"\n  and k: \"k<ncols A\"\n  and mb: \"\\<not> is_zero_row_upt_k mb k A\"\n  and not_nrows: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and g_mc: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> mc\"\n  and A_mc_k: \"A $ mc $ from_nat k \\<noteq> 0\"\n  shows \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (bezout_iterate\n  (interchange_rows A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\n  (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> n))\n  (nrows A - Suc 0) ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) bezout))\"", "lemma\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\" and ib: \"is_bezout_ext bezout\"\n  shows echelon_echelon_form_of_upt_k:\n  \"echelon_form_upt_k (echelon_form_of_upt_k A k bezout) (Suc k)\"\n  and \"foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]), \n  if \\<forall>m. is_zero_row_upt_k m (Suc k) \n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])) then 0\n  else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) \n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))) + 1)\"", "lemma bezout_iterate_invertible:\n  fixes A::\"'a::{bezout_domain}^'cols^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  assumes \"n<nrows A\"\n  and \"to_nat i\\<le>n\"\n  and \"A $ i $ j \\<noteq> 0\"\n  shows \"\\<exists>P. invertible P \\<and> P**A = bezout_iterate A n i j bezout\"", "lemma echelon_form_of_column_k_invertible:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"\\<exists>P. invertible P \\<and> P ** A = fst ((echelon_form_of_column_k bezout) (A,i) k)\"", "lemma echelon_form_of_upt_k_invertible:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"\\<exists>P. invertible P \\<and> P**A = (echelon_form_of_upt_k A k bezout)\"", "lemma echelon_form_echelon_form_of:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"echelon_form (echelon_form_of A bezout)\"", "lemma echelon_form_of_invertible:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext (bezout)\"\n  shows \"\\<exists>P. invertible P \n            \\<and> P ** A = (echelon_form_of A bezout) \n            \\<and> echelon_form (echelon_form_of A bezout)\"", "lemma echelon_form_of_column_k_efficient[code]: \n  \"(echelon_form_of_column_k bezout) (A,i) k\n    = (echelon_form_of_column_k_efficient bezout) (A,i) k\""], "translations": [["", "lemma echelon_form_upt_k_intro:\n  assumes \"(\\<forall>i. is_zero_row_upt_k i k A \\<longrightarrow> \\<not> (\\<exists>j. j>i \\<and> \\<not> is_zero_row_upt_k j k A))\"\n  and \"(\\<forall>i j. i<j \\<and> \\<not> (is_zero_row_upt_k i k A) \\<and> \\<not> (is_zero_row_upt_k j k A) \n  \\<longrightarrow> ((LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)))\"\n  shows \"echelon_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k A k", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     is_zero_row_upt_k i k A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n  \\<forall>i j.\n     i < j \\<and>\n     \\<not> is_zero_row_upt_k i k A \\<and>\n     \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'b))\n     < (LEAST n. A $ j $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. echelon_form_upt_k A k", "unfolding echelon_form_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     is_zero_row_upt_k i k A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n  \\<forall>i j.\n     i < j \\<and>\n     \\<not> is_zero_row_upt_k i k A \\<and>\n     \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'b))\n     < (LEAST n. A $ j $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        is_zero_row_upt_k i k A \\<longrightarrow>\n        \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)) \\<and>\n    (\\<forall>i j.\n        i < j \\<and>\n        \\<not> is_zero_row_upt_k i k A \\<and>\n        \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n        (LEAST n. A $ i $ n \\<noteq> (0::'b))\n        < (LEAST n. A $ j $ n \\<noteq> (0::'b)))", "by fast"], ["", "lemma echelon_form_upt_k_condition1:\n  assumes \"echelon_form_upt_k A k\" \"is_zero_row_upt_k i k A\"\n  shows \"\\<not> (\\<exists>j. j>i \\<and> \\<not> is_zero_row_upt_k j k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)", "using assms"], ["proof (prove)\nusing this:\n  echelon_form_upt_k A k\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)", "unfolding echelon_form_upt_k_def"], ["proof (prove)\nusing this:\n  (\\<forall>i.\n      is_zero_row_upt_k i k A \\<longrightarrow>\n      \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)) \\<and>\n  (\\<forall>i j.\n      i < j \\<and>\n      \\<not> is_zero_row_upt_k i k A \\<and>\n      \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n      (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      < (LEAST n. A $ j $ n \\<noteq> (0::'a)))\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)", "by auto"], ["", "lemma echelon_form_upt_k_condition1':\n  assumes \"echelon_form_upt_k A k\" \"is_zero_row_upt_k i k A\" and \"i<j\"\n  shows \"is_zero_row_upt_k j k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k A", "using assms"], ["proof (prove)\nusing this:\n  echelon_form_upt_k A k\n  is_zero_row_upt_k i k A\n  i < j\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k A", "unfolding echelon_form_upt_k_def"], ["proof (prove)\nusing this:\n  (\\<forall>i.\n      is_zero_row_upt_k i k A \\<longrightarrow>\n      \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)) \\<and>\n  (\\<forall>i j.\n      i < j \\<and>\n      \\<not> is_zero_row_upt_k i k A \\<and>\n      \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n      (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      < (LEAST n. A $ j $ n \\<noteq> (0::'a)))\n  is_zero_row_upt_k i k A\n  i < j\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k A", "by auto"], ["", "lemma echelon_form_upt_k_condition2:\n  assumes \"echelon_form_upt_k A k\" \"i<j\"\n  and  \"\\<not> (is_zero_row_upt_k i k A)\" \"\\<not> (is_zero_row_upt_k j k A)\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "using assms"], ["proof (prove)\nusing this:\n  echelon_form_upt_k A k\n  i < j\n  \\<not> is_zero_row_upt_k i k A\n  \\<not> is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "unfolding echelon_form_upt_k_def"], ["proof (prove)\nusing this:\n  (\\<forall>i.\n      is_zero_row_upt_k i k A \\<longrightarrow>\n      \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)) \\<and>\n  (\\<forall>i j.\n      i < j \\<and>\n      \\<not> is_zero_row_upt_k i k A \\<and>\n      \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n      (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      < (LEAST n. A $ j $ n \\<noteq> (0::'a)))\n  i < j\n  \\<not> is_zero_row_upt_k i k A\n  \\<not> is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by auto"], ["", "lemma echelon_form_upt_k_if_equal:\n  assumes e: \"echelon_form_upt_k A k\"\n  and eq: \"\\<forall>a. \\<forall>b<from_nat k. A $ a $ b = B $ a $ b\"\n  and k: \"k < ncols A\"\n  shows \"echelon_form_upt_k B k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k B k", "unfolding echelon_form_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        is_zero_row_upt_k i k B \\<longrightarrow>\n        \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k B)) \\<and>\n    (\\<forall>i j.\n        i < j \\<and>\n        \\<not> is_zero_row_upt_k i k B \\<and>\n        \\<not> is_zero_row_upt_k j k B \\<longrightarrow>\n        (LEAST n. B $ i $ n \\<noteq> (0::'a))\n        < (LEAST n. B $ j $ n \\<noteq> (0::'a)))", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k B; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j k B\n 2. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "fix i j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k B; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j k B\n 2. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "assume zero_iB: \"is_zero_row_upt_k i k B\" and ij: \"i < j\""], ["proof (state)\nthis:\n  is_zero_row_upt_k i k B\n  i < j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k B; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j k B\n 2. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "have zero_iA: \"is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "fix ja::'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "assume ja_k: \"to_nat ja < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "have ja_k2: \"ja < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ja < mod_type_class.from_nat k", "by (metis (full_types) add_to_nat_def k from_nat_mono \n        ja_k monoid_add_class.add.right_neutral ncols_def to_nat_0)"], ["proof (state)\nthis:\n  ja < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "have \"A $ i $ ja = B $ i $ ja\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ ja = B $ i $ ja", "using eq ja_k2"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     b < mod_type_class.from_nat k \\<longrightarrow> A $ a $ b = B $ a $ b\n  ja < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. A $ i $ ja = B $ i $ ja", "by auto"], ["proof (state)\nthis:\n  A $ i $ ja = B $ i $ ja\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "also"], ["proof (state)\nthis:\n  A $ i $ ja = B $ i $ ja\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ i $ ja = (0::'a)", "using zero_iB ja_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k B\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. B $ i $ ja = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> B $ i $ j = (0::'a)\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. B $ i $ ja = (0::'a)", "by simp"], ["proof (state)\nthis:\n  B $ i $ ja = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  A $ i $ ja = (0::'a)", "show \"A $ i $ ja = 0\""], ["proof (prove)\nusing this:\n  A $ i $ ja = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ ja = (0::'a)", "."], ["proof (state)\nthis:\n  A $ i $ ja = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k B; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j k B\n 2. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "hence zero_jA: \"is_zero_row_upt_k j k A\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k A", "by (metis e echelon_form_upt_k_condition1 ij)"], ["proof (state)\nthis:\n  is_zero_row_upt_k j k A\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k B; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j k B\n 2. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "show \"is_zero_row_upt_k j k B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k B", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow> B $ j $ ja = (0::'a)", "fix ja::'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow> B $ j $ ja = (0::'a)", "assume ja_k: \"to_nat ja < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow> B $ j $ ja = (0::'a)", "have ja_k2: \"ja < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ja < mod_type_class.from_nat k", "by (metis (full_types) add_to_nat_def k from_nat_mono \n        ja_k monoid_add_class.add.right_neutral ncols_def to_nat_0)"], ["proof (state)\nthis:\n  ja < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow> B $ j $ ja = (0::'a)", "have \"B $ j $ ja = A $ j $ ja\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ j $ ja = A $ j $ ja", "using eq ja_k2"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     b < mod_type_class.from_nat k \\<longrightarrow> A $ a $ b = B $ a $ b\n  ja < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. B $ j $ ja = A $ j $ ja", "by auto"], ["proof (state)\nthis:\n  B $ j $ ja = A $ j $ ja\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow> B $ j $ ja = (0::'a)", "also"], ["proof (state)\nthis:\n  B $ j $ ja = A $ j $ ja\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow> B $ j $ ja = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "using zero_jA ja_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k j k A\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>ja.\n     mod_type_class.to_nat ja < k \\<longrightarrow> A $ j $ ja = (0::'a)\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $ j $ ja = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow> B $ j $ ja = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  B $ j $ ja = (0::'a)", "show \"B $ j $ ja = 0\""], ["proof (prove)\nusing this:\n  B $ j $ ja = (0::'a)\n\ngoal (1 subgoal):\n 1. B $ j $ ja = (0::'a)", "."], ["proof (state)\nthis:\n  B $ j $ ja = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k j k B\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "assume ij: \"i < j\"\n    and not_zero_iB: \"\\<not> is_zero_row_upt_k i k B\" \n    and not_zero_jB: \"\\<not> is_zero_row_upt_k j k B\""], ["proof (state)\nthis:\n  i < j\n  \\<not> is_zero_row_upt_k i k B\n  \\<not> is_zero_row_upt_k j k B\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "obtain a where Bia: \"B $ i $ a \\<noteq> 0\" and ak: \"a<from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>B $ i $ a \\<noteq> (0::'a);\n         a < mod_type_class.from_nat k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_iB k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k B\n  k < ncols A\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>B $ i $ a \\<noteq> (0::'a);\n         a < mod_type_class.from_nat k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             B $ i $ j = (0::'a))\n  k < CARD('b)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>B $ i $ a \\<noteq> (0::'a);\n         a < mod_type_class.from_nat k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add_to_nat_def from_nat_mono monoid_add_class.add.right_neutral to_nat_0)"], ["proof (state)\nthis:\n  B $ i $ a \\<noteq> (0::'a)\n  a < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "have Aia: \"A $ i $ a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ a \\<noteq> (0::'a)", "by (metis ak Bia eq)"], ["proof (state)\nthis:\n  A $ i $ a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "obtain b where Bjb: \"B $ j $ b \\<noteq> 0\" and bk: \"b<from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>B $ j $ b \\<noteq> (0::'a);\n         b < mod_type_class.from_nat k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_jB k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k j k B\n  k < ncols A\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>B $ j $ b \\<noteq> (0::'a);\n         b < mod_type_class.from_nat k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>ja.\n             mod_type_class.to_nat ja < k \\<longrightarrow>\n             B $ j $ ja = (0::'a))\n  k < CARD('b)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>B $ j $ b \\<noteq> (0::'a);\n         b < mod_type_class.from_nat k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add_to_nat_def from_nat_mono monoid_add_class.add.right_neutral to_nat_0)"], ["proof (state)\nthis:\n  B $ j $ b \\<noteq> (0::'a)\n  b < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "have Ajb: \"A $ j $ b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ b \\<noteq> (0::'a)", "by (metis bk Bjb eq)"], ["proof (state)\nthis:\n  A $ j $ b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "have not_zero_iA: \"\\<not> is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "by (metis (full_types) Aia ak is_zero_row_upt_k_def to_nat_le)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "have not_zero_jA: \"\\<not> is_zero_row_upt_k j k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k j k A", "by (metis (full_types) Ajb bk is_zero_row_upt_k_def to_nat_le)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "have \"(LEAST n. A $ i $ n \\<noteq> 0) = (LEAST n. B $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    (LEAST n. B $ i $ n \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ i $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> y", "have \"(LEAST n. B $ i $ n \\<noteq> 0) \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> a", "by (rule Least_le, simp add: Bia)"], ["proof (state)\nthis:\n  (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> a\n\ngoal (2 subgoals):\n 1. A $ i $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> y", "hence least_bi_less: \"(LEAST n. B $ i $ n \\<noteq> 0) < from_nat k\""], ["proof (prove)\nusing this:\n  (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> a\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ i $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "using ak"], ["proof (prove)\nusing this:\n  (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> a\n  a < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ i $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "by simp"], ["proof (state)\nthis:\n  (LEAST n. B $ i $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. A $ i $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> y", "thus \"A $ i $ (LEAST n. B $ i $ n \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (LEAST n. B $ i $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags, lifting) LeastI  eq is_zero_row_upt_k_def not_zero_iB)"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> y", "assume \"A $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  A $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> y", "thus \"(LEAST n. B $ i $ n \\<noteq> 0) \\<le> y\""], ["proof (prove)\nusing this:\n  A $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> y", "by (metis (mono_tags, lifting) Least_le  dual_order.strict_trans2 eq least_bi_less linear)"], ["proof (state)\nthis:\n  (LEAST n. B $ i $ n \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  (LEAST n. B $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "moreover"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  (LEAST n. B $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "have \"(LEAST n. A $ j $ n \\<noteq> 0) = (LEAST n. B $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ j $ n \\<noteq> (0::'a)) =\n    (LEAST n. B $ j $ n \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ j $ (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> y", "have \"(LEAST n. B $ j $ n \\<noteq> 0) \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> b", "by (rule Least_le, simp add: Bjb)"], ["proof (state)\nthis:\n  (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> b\n\ngoal (2 subgoals):\n 1. A $ j $ (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> y", "hence least_bi_less: \"(LEAST n. B $ j $ n \\<noteq> 0) < from_nat k\""], ["proof (prove)\nusing this:\n  (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> b\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ j $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "using bk"], ["proof (prove)\nusing this:\n  (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> b\n  b < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ j $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "by simp"], ["proof (state)\nthis:\n  (LEAST n. B $ j $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. A $ j $ (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> y", "thus \"A $ j $ (LEAST n. B $ j $ n \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (LEAST n. B $ j $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags, lifting) LeastI eq is_zero_row_upt_k_def not_zero_jB)"], ["proof (state)\nthis:\n  A $ j $ (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> y", "assume \"A $ j $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  A $ j $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> y", "thus \"(LEAST n. B $ j $ n \\<noteq> 0) \\<le> y\""], ["proof (prove)\nusing this:\n  A $ j $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> y", "by (metis (mono_tags, lifting) Least_le  dual_order.strict_trans2 eq least_bi_less linear)"], ["proof (state)\nthis:\n  (LEAST n. B $ j $ n \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. B $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "moreover"], ["proof (state)\nthis:\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. B $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "have \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by (rule echelon_form_upt_k_condition2[OF e ij not_zero_iA not_zero_jA])"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i k B;\n        \\<not> is_zero_row_upt_k j k B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "ultimately"], ["proof (chain)\npicking this:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  (LEAST n. B $ i $ n \\<noteq> (0::'a))\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. B $ j $ n \\<noteq> (0::'a))\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "show \"(LEAST n. B $ i $ n \\<noteq> 0) < (LEAST n. B $ j $ n \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  (LEAST n. B $ i $ n \\<noteq> (0::'a))\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. B $ j $ n \\<noteq> (0::'a))\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "by auto"], ["proof (state)\nthis:\n  (LEAST n. B $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. B $ j $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_upt_k_0: \"echelon_form_upt_k A 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k A 0", "unfolding echelon_form_upt_k_def is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        (\\<forall>j.\n            mod_type_class.to_nat j < 0 \\<longrightarrow>\n            A $ i $ j = (0::'a)) \\<longrightarrow>\n        \\<not> (\\<exists>j>i.\n                   \\<not> (\\<forall>ja.\n                              mod_type_class.to_nat ja < 0 \\<longrightarrow>\n                              A $ j $ ja = (0::'a)))) \\<and>\n    (\\<forall>i j.\n        i < j \\<and>\n        \\<not> (\\<forall>j.\n                   mod_type_class.to_nat j < 0 \\<longrightarrow>\n                   A $ i $ j = (0::'a)) \\<and>\n        \\<not> (\\<forall>ja.\n                   mod_type_class.to_nat ja < 0 \\<longrightarrow>\n                   A $ j $ ja = (0::'a)) \\<longrightarrow>\n        (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        < (LEAST n. A $ j $ n \\<noteq> (0::'a)))", "by auto"], ["", "lemma echelon_form_condition1:\n  assumes r: \"echelon_form A\"\n  shows \"(\\<forall>i. is_zero_row i A \\<longrightarrow> \\<not> (\\<exists>j. j>i \\<and> \\<not> is_zero_row j A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       is_zero_row i A \\<longrightarrow>\n       \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)", "using r"], ["proof (prove)\nusing this:\n  echelon_form A\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       is_zero_row i A \\<longrightarrow>\n       \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)", "unfolding echelon_form_def"], ["proof (prove)\nusing this:\n  echelon_form_upt_k A (ncols A)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       is_zero_row i A \\<longrightarrow>\n       \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)", "by (metis echelon_form_upt_k_condition1' is_zero_row_def)"], ["", "lemma echelon_form_condition2:\n  assumes r: \"echelon_form A\"\n  shows \"(\\<forall>i. i<j \\<and> \\<not> (is_zero_row i A) \\<and> \\<not> (is_zero_row j A) \n  \\<longrightarrow> ((LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       i < j \\<and>\n       \\<not> is_zero_row i A \\<and>\n       \\<not> is_zero_row j A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "using r"], ["proof (prove)\nusing this:\n  echelon_form A\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       i < j \\<and>\n       \\<not> is_zero_row i A \\<and>\n       \\<not> is_zero_row j A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "unfolding echelon_form_def"], ["proof (prove)\nusing this:\n  echelon_form_upt_k A (ncols A)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       i < j \\<and>\n       \\<not> is_zero_row i A \\<and>\n       \\<not> is_zero_row j A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by (metis echelon_form_upt_k_condition2 is_zero_row_def)"], ["", "lemma echelon_form_condition2_explicit:\n  assumes rref_A: \"echelon_form A\"\n  and i_le: \"i < j\"\n  and \"\\<not> is_zero_row i A\" and \"\\<not> is_zero_row j A\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "using echelon_form_condition2 assms"], ["proof (prove)\nusing this:\n  echelon_form ?A \\<Longrightarrow>\n  \\<forall>i.\n     i < ?j \\<and>\n     \\<not> is_zero_row i ?A \\<and>\n     \\<not> is_zero_row ?j ?A \\<longrightarrow>\n     (LEAST n. ?A $ i $ n \\<noteq> (0::?'a))\n     < (LEAST n. ?A $ ?j $ n \\<noteq> (0::?'a))\n  echelon_form A\n  i < j\n  \\<not> is_zero_row i A\n  \\<not> is_zero_row j A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by blast"], ["", "lemma echelon_form_intro:\n  assumes 1: \"(\\<forall>i. is_zero_row i A \\<longrightarrow> \\<not> (\\<exists>j. j>i \\<and> \\<not> is_zero_row j A))\"\n  and 2: \"(\\<forall>i j. i<j \\<and> \\<not> (is_zero_row i A) \\<and> \\<not> (is_zero_row j A) \n  \\<longrightarrow> ((LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)))\"\n  shows \"echelon_form A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form A", "proof (unfold echelon_form_def, rule echelon_form_upt_k_intro, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (ncols A) A; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (ncols A) A\n 2. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (ncols A) A;\n        \\<not> is_zero_row_upt_k j (ncols A) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'b))", "fix i j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (ncols A) A; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (ncols A) A\n 2. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (ncols A) A;\n        \\<not> is_zero_row_upt_k j (ncols A) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'b))", "assume \"is_zero_row_upt_k i (ncols A) A\" and \"i < j\""], ["proof (state)\nthis:\n  is_zero_row_upt_k i (ncols A) A\n  i < j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (ncols A) A; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (ncols A) A\n 2. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (ncols A) A;\n        \\<not> is_zero_row_upt_k j (ncols A) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'b))", "thus \"is_zero_row_upt_k j (ncols A) A\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (ncols A) A\n  i < j\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (ncols A) A", "using 1 is_zero_row_imp_is_zero_row_upt"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (ncols A) A\n  i < j\n  \\<forall>i.\n     is_zero_row i A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)\n  is_zero_row ?i ?A \\<Longrightarrow> is_zero_row_upt_k ?i ?k ?A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (ncols A) A", "by (metis is_zero_row_def)"], ["proof (state)\nthis:\n  is_zero_row_upt_k j (ncols A) A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (ncols A) A;\n        \\<not> is_zero_row_upt_k j (ncols A) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (ncols A) A;\n        \\<not> is_zero_row_upt_k j (ncols A) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'b))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (ncols A) A;\n        \\<not> is_zero_row_upt_k j (ncols A) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'b))", "assume \"i < j\" and \"\\<not> is_zero_row_upt_k i (ncols A) A\" and \"\\<not> is_zero_row_upt_k j (ncols A) A\""], ["proof (state)\nthis:\n  i < j\n  \\<not> is_zero_row_upt_k i (ncols A) A\n  \\<not> is_zero_row_upt_k j (ncols A) A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (ncols A) A;\n        \\<not> is_zero_row_upt_k j (ncols A) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'b))", "thus \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  i < j\n  \\<not> is_zero_row_upt_k i (ncols A) A\n  \\<not> is_zero_row_upt_k j (ncols A) A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'b))", "using 2"], ["proof (prove)\nusing this:\n  i < j\n  \\<not> is_zero_row_upt_k i (ncols A) A\n  \\<not> is_zero_row_upt_k j (ncols A) A\n  \\<forall>i j.\n     i < j \\<and>\n     \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'b))\n     < (LEAST n. A $ j $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'b))", "by (metis is_zero_row_imp_is_zero_row_upt)"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_implies_echelon_form_upt:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes rref: \"echelon_form A\"\n  shows \"echelon_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k A k", "proof (rule echelon_form_upt_k_intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i.\n       is_zero_row_upt_k i k A \\<longrightarrow>\n       \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n 2. \\<forall>i j.\n       i < j \\<and>\n       \\<not> is_zero_row_upt_k i k A \\<and>\n       \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "show \"\\<forall>i. is_zero_row_upt_k i k A \\<longrightarrow> \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       is_zero_row_upt_k i k A \\<longrightarrow>\n       \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)", "proof (auto, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k A; i < j;\n        \\<not> is_zero_row_upt_k j k A\\<rbrakk>\n       \\<Longrightarrow> False", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k A; i < j;\n        \\<not> is_zero_row_upt_k j k A\\<rbrakk>\n       \\<Longrightarrow> False", "assume zero_i_k: \"is_zero_row_upt_k i k A\" and i_less_j: \"i < j\"\n      and not_zero_j_k:\"\\<not> is_zero_row_upt_k j k A\""], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n  i < j\n  \\<not> is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k A; i < j;\n        \\<not> is_zero_row_upt_k j k A\\<rbrakk>\n       \\<Longrightarrow> False", "have not_zero_j: \"\\<not> is_zero_row j A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row j A", "using is_zero_row_imp_is_zero_row_upt not_zero_j_k"], ["proof (prove)\nusing this:\n  is_zero_row ?i ?A \\<Longrightarrow> is_zero_row_upt_k ?i ?k ?A\n  \\<not> is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row j A", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row j A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k A; i < j;\n        \\<not> is_zero_row_upt_k j k A\\<rbrakk>\n       \\<Longrightarrow> False", "hence not_zero_i: \"\\<not> is_zero_row i A\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row j A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A", "using echelon_form_condition1[OF rref] i_less_j"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row j A\n  \\<forall>i.\n     is_zero_row i A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)\n  i < j\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k A; i < j;\n        \\<not> is_zero_row_upt_k j k A\\<rbrakk>\n       \\<Longrightarrow> False", "have Least_less: \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by (rule echelon_form_condition2_explicit[OF rref i_less_j not_zero_i not_zero_j])"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k A; i < j;\n        \\<not> is_zero_row_upt_k j k A\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k A; i < j;\n        \\<not> is_zero_row_upt_k j k A\\<rbrakk>\n       \\<Longrightarrow> False", "have \"(LEAST n. A $ j $ n \\<noteq> 0) < (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ j $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ i $ n \\<noteq> (0::'a))", "proof (rule LeastI2_ex)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a. A $ i $ a \\<noteq> (0::'a)\n 2. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "show \"\\<exists>a. A $ i $ a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. A $ i $ a \\<noteq> (0::'a)", "using not_zero_i"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. \\<exists>a. A $ i $ a \\<noteq> (0::'a)", "unfolding is_zero_row_def is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < ncols A \\<longrightarrow>\n             A $ i $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>a. A $ i $ a \\<noteq> (0::'a)", "by fast"], ["proof (state)\nthis:\n  \\<exists>a. A $ i $ a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "assume Aix_not_0: \"A $ i $ x \\<noteq> 0\""], ["proof (state)\nthis:\n  A $ i $ x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "have k_less_x: \"k \\<le> to_nat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> mod_type_class.to_nat x", "using zero_i_k Aix_not_0"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n  A $ i $ x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. k \\<le> mod_type_class.to_nat x", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ i $ j = (0::'a)\n  A $ i $ x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. k \\<le> mod_type_class.to_nat x", "by force"], ["proof (state)\nthis:\n  k \\<le> mod_type_class.to_nat x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "hence k_less_ncols: \"k < ncols A\""], ["proof (prove)\nusing this:\n  k \\<le> mod_type_class.to_nat x\n\ngoal (1 subgoal):\n 1. k < ncols A", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  k \\<le> mod_type_class.to_nat x\n\ngoal (1 subgoal):\n 1. k < CARD('cols)", "using to_nat_less_card[of x]"], ["proof (prove)\nusing this:\n  k \\<le> mod_type_class.to_nat x\n  mod_type_class.to_nat x < CARD('cols)\n\ngoal (1 subgoal):\n 1. k < CARD('cols)", "by simp"], ["proof (state)\nthis:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "obtain s where Ajs_not_zero: \"A $ j $ s \\<noteq> 0\" and s_less_k: \"to_nat s < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>A $ j $ s \\<noteq> (0::'a);\n         mod_type_class.to_nat s < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_j_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>A $ j $ s \\<noteq> (0::'a);\n         mod_type_class.to_nat s < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>ja.\n             mod_type_class.to_nat ja < k \\<longrightarrow>\n             A $ j $ ja = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>A $ j $ s \\<noteq> (0::'a);\n         mod_type_class.to_nat s < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A $ j $ s \\<noteq> (0::'a)\n  mod_type_class.to_nat s < k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "have \"(LEAST n. A $ j $ n \\<noteq> 0) \\<le> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ j $ n \\<noteq> (0::'a)) \\<le> s", "using Ajs_not_zero Least_le"], ["proof (prove)\nusing this:\n  A $ j $ s \\<noteq> (0::'a)\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ j $ n \\<noteq> (0::'a)) \\<le> s", "by fast"], ["proof (state)\nthis:\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) \\<le> s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "also"], ["proof (state)\nthis:\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) \\<le> s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "have \"... = from_nat (to_nat s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = mod_type_class.from_nat (mod_type_class.to_nat s)", "unfolding from_nat_to_nat_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = s", ".."], ["proof (state)\nthis:\n  s = mod_type_class.from_nat (mod_type_class.to_nat s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "also"], ["proof (state)\nthis:\n  s = mod_type_class.from_nat (mod_type_class.to_nat s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "have \"... < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat s)\n    < mod_type_class.from_nat k", "by (rule from_nat_mono[OF s_less_k k_less_ncols[unfolded ncols_def]])"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat s)\n  < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "also"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat s)\n  < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "have \"... \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> x", "using k_less_x leD not_le_imp_less to_nat_le"], ["proof (prove)\nusing this:\n  k \\<le> mod_type_class.to_nat x\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n  \\<not> ?y \\<le> ?x \\<Longrightarrow> ?x < ?y\n  ?y < mod_type_class.from_nat ?k \\<Longrightarrow>\n  mod_type_class.to_nat ?y < ?k\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> x", "by fast"], ["proof (state)\nthis:\n  mod_type_class.from_nat k \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ i $ x \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "finally"], ["proof (chain)\npicking this:\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "show \"(LEAST n. A $ j $ n \\<noteq> 0) < x\""], ["proof (prove)\nusing this:\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x", "."], ["proof (state)\nthis:\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) < x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ j $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i k A; i < j;\n        \\<not> is_zero_row_upt_k j k A\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n  (LEAST n. A $ j $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))", "show False"], ["proof (prove)\nusing this:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n  (LEAST n. A $ j $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i.\n     is_zero_row_upt_k i k A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < j \\<and>\n       \\<not> is_zero_row_upt_k i k A \\<and>\n       \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "show \"\\<forall>i j. i < j \\<and> \\<not> is_zero_row_upt_k i k A \\<and> \\<not> is_zero_row_upt_k j k A \n    \\<longrightarrow> (LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < j \\<and>\n       \\<not> is_zero_row_upt_k i k A \\<and>\n       \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "using echelon_form_condition2[OF rref] is_zero_row_imp_is_zero_row_upt"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     i < ?j \\<and>\n     \\<not> is_zero_row i A \\<and> \\<not> is_zero_row ?j A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'a))\n     < (LEAST n. A $ ?j $ n \\<noteq> (0::'a))\n  is_zero_row ?i ?A \\<Longrightarrow> is_zero_row_upt_k ?i ?k ?A\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < j \\<and>\n       \\<not> is_zero_row_upt_k i k A \\<and>\n       \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by blast"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < j \\<and>\n     \\<not> is_zero_row_upt_k i k A \\<and>\n     \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'a))\n     < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upper_triangular_upt_k_def':\n  assumes \"\\<forall>i j. to_nat j \\<le> k \\<and> A $ i $ j \\<noteq> 0 \\<longrightarrow> j\\<ge>i\"\n  shows \"upper_triangular_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular_upt_k A k", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     mod_type_class.to_nat j \\<le> k \\<and>\n     A $ i $ j \\<noteq> (0::'b) \\<longrightarrow>\n     i \\<le> j\n\ngoal (1 subgoal):\n 1. upper_triangular_upt_k A k", "unfolding upper_triangular_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     mod_type_class.to_nat j \\<le> k \\<and>\n     A $ i $ j \\<noteq> (0::'b) \\<longrightarrow>\n     i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       j < i \\<and> mod_type_class.to_nat j < k \\<longrightarrow>\n       A $ i $ j = (0::'b)", "by (metis leD linear)"], ["", "lemma echelon_form_imp_upper_triagular_upt:\n  fixes A::\"'a::{bezout_ring}^'n::{mod_type}^'n::{mod_type}\"\n  assumes \"echelon_form A\"\n  shows \"upper_triangular_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular_upt_k A k", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. upper_triangular_upt_k A 0\n 2. \\<And>k.\n       upper_triangular_upt_k A k \\<Longrightarrow>\n       upper_triangular_upt_k A (Suc k)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. upper_triangular_upt_k A 0\n 2. \\<And>k.\n       upper_triangular_upt_k A k \\<Longrightarrow>\n       upper_triangular_upt_k A (Suc k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular_upt_k A 0", "unfolding upper_triangular_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       j < i \\<and> mod_type_class.to_nat j < 0 \\<longrightarrow>\n       A $ i $ j = (0::'a)", "by simp"], ["proof (state)\nthis:\n  upper_triangular_upt_k A 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       upper_triangular_upt_k A k \\<Longrightarrow>\n       upper_triangular_upt_k A (Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       upper_triangular_upt_k A k \\<Longrightarrow>\n       upper_triangular_upt_k A (Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  upper_triangular_upt_k A k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       upper_triangular_upt_k A k \\<Longrightarrow>\n       upper_triangular_upt_k A (Suc k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular_upt_k A (Suc k)", "unfolding upper_triangular_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       j < i \\<and> mod_type_class.to_nat j < Suc k \\<longrightarrow>\n       A $ i $ j = (0::'a)", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < i; mod_type_class.to_nat j < Suc k\\<rbrakk>\n       \\<Longrightarrow> A $ i $ j = (0::'a)", "fix i j::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < i; mod_type_class.to_nat j < Suc k\\<rbrakk>\n       \\<Longrightarrow> A $ i $ j = (0::'a)", "assume j_less_i: \"j < i\" and j_less_suc_k: \"to_nat j < Suc k\""], ["proof (state)\nthis:\n  j < i\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < i; mod_type_class.to_nat j < Suc k\\<rbrakk>\n       \\<Longrightarrow> A $ i $ j = (0::'a)", "show \"A $ i $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "proof (cases \"to_nat j < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "using Suc.hyps"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n  upper_triangular_upt_k A k\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "unfolding upper_triangular_upt_k_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n  \\<forall>i j.\n     j < i \\<and> mod_type_class.to_nat j < k \\<longrightarrow>\n     A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "using j_less_i True"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n  \\<forall>i j.\n     j < i \\<and> mod_type_class.to_nat j < k \\<longrightarrow>\n     A $ i $ j = (0::'a)\n  j < i\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "hence j_eq_k: \"to_nat j = k\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j = k", "using j_less_suc_k"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat j < k\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j = k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat j = k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "hence j_eq_k2: \"from_nat k = j\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j = k\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "by (metis from_nat_to_nat_id)"], ["proof (state)\nthis:\n  mod_type_class.from_nat k = j\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "have rref_suc: \"echelon_form_upt_k A (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k A (Suc k)", "by (metis assms echelon_form_implies_echelon_form_upt)"], ["proof (state)\nthis:\n  echelon_form_upt_k A (Suc k)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "have zero_j_k: \"is_zero_row_upt_k j k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k A", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ja.\n       mod_type_class.to_nat ja < k \\<longrightarrow> A $ j $ ja = (0::'a)", "by (metis (hide_lams, mono_tags) Suc.hyps leD le_less_linear \n          j_eq_k to_nat_mono' upper_triangular_upt_k_def)"], ["proof (state)\nthis:\n  is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "hence zero_i_k: \"is_zero_row_upt_k i k A\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "by (metis (poly_guards_query) assms echelon_form_implies_echelon_form_upt \n          echelon_form_upt_k_condition1' j_less_i)"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "proof (cases \"A $ j $ j = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ j $ j = (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)\n 2. A $ j $ j \\<noteq> (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)", "case True"], ["proof (state)\nthis:\n  A $ j $ j = (0::'a)\n\ngoal (2 subgoals):\n 1. A $ j $ j = (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)\n 2. A $ j $ j \\<noteq> (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)", "have \"is_zero_row_upt_k j (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "by (rule is_zero_row_upt_k_suc[OF zero_j_k], simp add: True j_eq_k2)"], ["proof (state)\nthis:\n  is_zero_row_upt_k j (Suc k) A\n\ngoal (2 subgoals):\n 1. A $ j $ j = (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)\n 2. A $ j $ j \\<noteq> (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)", "hence \"is_zero_row_upt_k i (Suc k) A\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k j (Suc k) A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (Suc k) A", "by (metis echelon_form_upt_k_condition1' j_less_i rref_suc)"], ["proof (state)\nthis:\n  is_zero_row_upt_k i (Suc k) A\n\ngoal (2 subgoals):\n 1. A $ j $ j = (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)\n 2. A $ j $ j \\<noteq> (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "by (metis is_zero_row_upt_k_def j_eq_k lessI)"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ j \\<noteq> (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ j $ j \\<noteq> (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)", "case False"], ["proof (state)\nthis:\n  A $ j $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ j \\<noteq> (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)", "note Ajj_not_zero=False"], ["proof (state)\nthis:\n  A $ j $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ j \\<noteq> (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)", "hence not_zero_j:\"\\<not> is_zero_row_upt_k j (Suc k) A\""], ["proof (prove)\nusing this:\n  A $ j $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k j (Suc k) A", "by (metis is_zero_row_upt_k_def j_eq_k lessI)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k j (Suc k) A\n\ngoal (1 subgoal):\n 1. A $ j $ j \\<noteq> (0::'a) \\<Longrightarrow> A $ i $ j = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ i $ j \\<noteq> (0::'a) \\<Longrightarrow> False", "assume Aij_not_zero: \"A $ i $ j \\<noteq> 0\""], ["proof (state)\nthis:\n  A $ i $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ j \\<noteq> (0::'a) \\<Longrightarrow> False", "hence not_zero_i: \"\\<not> is_zero_row_upt_k i (Suc k) A\""], ["proof (prove)\nusing this:\n  A $ i $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i (Suc k) A", "by (metis is_zero_row_upt_k_def j_eq_k lessI)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. A $ i $ j \\<noteq> (0::'a) \\<Longrightarrow> False", "have Least_eq: \"(LEAST n. A $ i $ n \\<noteq> 0) = from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"A $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)", "using Aij_not_zero j_eq_k2"], ["proof (prove)\nusing this:\n  A $ i $ j \\<noteq> (0::'a)\n  mod_type_class.from_nat k = j\n\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"\\<And>y. A $ i $ y \\<noteq> 0 \\<Longrightarrow> from_nat k \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "by (metis (full_types) is_zero_row_upt_k_def not_le_imp_less to_nat_le zero_i_k)"], ["proof (state)\nthis:\n  A $ i $ ?y \\<noteq> (0::'a) \\<Longrightarrow>\n  mod_type_class.from_nat k \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. A $ i $ j \\<noteq> (0::'a) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. A $ i $ j \\<noteq> (0::'a) \\<Longrightarrow> False", "have Least_eq2: \"(LEAST n. A $ j $ n \\<noteq> 0) = from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ j $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ j $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"A $ j $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ mod_type_class.from_nat k \\<noteq> (0::'a)", "using Ajj_not_zero j_eq_k2"], ["proof (prove)\nusing this:\n  A $ j $ j \\<noteq> (0::'a)\n  mod_type_class.from_nat k = j\n\ngoal (1 subgoal):\n 1. A $ j $ mod_type_class.from_nat k \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $ j $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"\\<And>y. A $ j $ y \\<noteq> 0 \\<Longrightarrow> from_nat k \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "by (metis (full_types) is_zero_row_upt_k_def not_le_imp_less to_nat_le zero_j_k)"], ["proof (state)\nthis:\n  A $ j $ ?y \\<noteq> (0::'a) \\<Longrightarrow>\n  mod_type_class.from_nat k \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. A $ i $ j \\<noteq> (0::'a) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k", "show False"], ["proof (prove)\nusing this:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. False", "using echelon_form_upt_k_condition2[OF rref_suc j_less_i not_zero_j not_zero_i]"], ["proof (prove)\nusing this:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n  (LEAST n. A $ j $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upper_triangular_upt_k A (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>A matrix in echelon form is upper triangular.\\<close>"], ["", "lemma echelon_form_imp_upper_triagular:\n  fixes A::\"'a::{bezout_ring}^'n::{mod_type}^'n::{mod_type}\"\n  assumes \"echelon_form A\"\n  shows \"upper_triangular A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular A", "using echelon_form_imp_upper_triagular_upt[OF assms]"], ["proof (prove)\nusing this:\n  upper_triangular_upt_k A ?k\n\ngoal (1 subgoal):\n 1. upper_triangular A", "by (metis upper_triangular_upt_imp_upper_triangular)"], ["", "lemma echelon_form_upt_k_interchange:\n  fixes A::\"'a::{bezout_ring}^'c::{mod_type}^'b::{mod_type}\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and zero_ikA: \"is_zero_row_upt_k (from_nat i) k A\"\n  and Amk_not_0: \"A $ m $ from_nat k \\<noteq> 0\"\n  and i_le_m: \"(from_nat i)\\<le>m\"\n  and k: \"k<ncols A\"\n  shows \"echelon_form_upt_k (interchange_rows A (from_nat i) \n  (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (from_nat i) \\<le> n)) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     k", "proof (rule echelon_form_upt_k_if_equal[OF e _ k], auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       b < mod_type_class.from_nat k \\<Longrightarrow>\n       A $ a $ b =\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       a $\n       b", "fix a and b::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       b < mod_type_class.from_nat k \\<Longrightarrow>\n       A $ a $ b =\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       a $\n       b", "assume b: \"b < from_nat k\""], ["proof (state)\nthis:\n  b < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       b < mod_type_class.from_nat k \\<Longrightarrow>\n       A $ a $ b =\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       a $\n       b", "let ?least = \"(LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (from_nat i) \\<le> n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       b < mod_type_class.from_nat k \\<Longrightarrow>\n       A $ a $ b =\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       a $\n       b", "let ?interchange = \"(interchange_rows A (from_nat i) ?least)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       b < mod_type_class.from_nat k \\<Longrightarrow>\n       A $ a $ b =\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       a $\n       b", "have \"(from_nat i)\\<le>?least\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i\n    \\<le> (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n)", "by (metis (mono_tags, lifting) Amk_not_0 LeastI_ex i_le_m)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i\n  \\<le> (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       b < mod_type_class.from_nat k \\<Longrightarrow>\n       A $ a $ b =\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       a $\n       b", "hence zero_leastkA: \"is_zero_row_upt_k ?least k A\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i\n  \\<le> (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n)\n     k A", "using echelon_form_upt_k_condition1[OF e zero_ikA]"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i\n  \\<le> (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n)\n  \\<not> (\\<exists>j>mod_type_class.from_nat i.\n             \\<not> is_zero_row_upt_k j k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n)\n     k A", "by (metis (poly_guards_query) dual_order.strict_iff_order zero_ikA)"], ["proof (state)\nthis:\n  is_zero_row_upt_k\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n   k A\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       b < mod_type_class.from_nat k \\<Longrightarrow>\n       A $ a $ b =\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       a $\n       b", "show \"A $ a $ b = ?interchange $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "proof (cases \"a=from_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "case True"], ["proof (state)\nthis:\n  a = mod_type_class.from_nat i\n\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "hence \"?interchange $ a $ b = A $ ?least $ b\""], ["proof (prove)\nusing this:\n  a = mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b =\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    b", "unfolding interchange_rows_def"], ["proof (prove)\nusing this:\n  a = mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = mod_type_class.from_nat i\n        then A $\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 mod_type_class.from_nat i \\<le> n) $\n             j\n        else if ia =\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq>\n                    (0::'a) \\<and>\n                    mod_type_class.from_nat i \\<le> n)\n             then A $ mod_type_class.from_nat i $ j else A $ ia $ j) $\n    a $\n    b =\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    b", "by auto"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n) $\n  b\n\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "also"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n) $\n  b\n\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    b =\n    (0::'a)", "using zero_leastkA"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n   k A\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    b =\n    (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n     j =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    b =\n    (0::'a)", "by (metis (mono_tags) b to_nat_le)"], ["proof (state)\nthis:\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n) $\n  b =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "finally"], ["proof (chain)\npicking this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)", "have \"?interchange $ a $ b = 0\""], ["proof (prove)\nusing this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b =\n    (0::'a)", "."], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "moreover"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "have \"A $ a $ b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b = (0::'a)", "by (metis True b is_zero_row_upt_k_def to_nat_le zero_ikA)"], ["proof (state)\nthis:\n  A $ a $ b = (0::'a)\n\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "ultimately"], ["proof (chain)\npicking this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)\n  A $ a $ b = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)\n  A $ a $ b = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "by simp"], ["proof (state)\nthis:\n  A $ a $ b =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "case False"], ["proof (state)\nthis:\n  a \\<noteq> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "note a_not_i=False"], ["proof (state)\nthis:\n  a \\<noteq> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "proof (cases \"a=?least\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "case True"], ["proof (state)\nthis:\n  a =\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (2 subgoals):\n 1. a =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "hence \"?interchange $ a $ b = A $ (from_nat i) $ b\""], ["proof (prove)\nusing this:\n  a =\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b =\n    A $ mod_type_class.from_nat i $ b", "unfolding interchange_rows_def"], ["proof (prove)\nusing this:\n  a =\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = mod_type_class.from_nat i\n        then A $\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 mod_type_class.from_nat i \\<le> n) $\n             j\n        else if ia =\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq>\n                    (0::'a) \\<and>\n                    mod_type_class.from_nat i \\<le> n)\n             then A $ mod_type_class.from_nat i $ j else A $ ia $ j) $\n    a $\n    b =\n    A $ mod_type_class.from_nat i $ b", "by auto"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  A $ mod_type_class.from_nat i $ b\n\ngoal (2 subgoals):\n 1. a =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "also"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  A $ mod_type_class.from_nat i $ b\n\ngoal (2 subgoals):\n 1. a =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ b = (0::'a)", "using zero_ikA"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k A\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ b = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     A $ mod_type_class.from_nat i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ b = (0::'a)", "by (metis (poly_guards_query) b to_nat_le)"], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat i $ b = (0::'a)\n\ngoal (2 subgoals):\n 1. a =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "finally"], ["proof (chain)\npicking this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)", "have \"?interchange $ a $ b = 0\""], ["proof (prove)\nusing this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b =\n    (0::'a)", "."], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. a =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "moreover"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. a =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "have \"A $ a $ b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b = (0::'a)", "by (metis True b is_zero_row_upt_k_def to_nat_le zero_leastkA)"], ["proof (state)\nthis:\n  A $ a $ b = (0::'a)\n\ngoal (2 subgoals):\n 1. a =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b\n 2. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "ultimately"], ["proof (chain)\npicking this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)\n  A $ a $ b = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b =\n  (0::'a)\n  A $ a $ b = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "by simp"], ["proof (state)\nthis:\n  A $ a $ b =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "case False"], ["proof (state)\nthis:\n  a \\<noteq>\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq>\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "using a_not_i"], ["proof (prove)\nusing this:\n  a \\<noteq>\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n  a \\<noteq> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. A $ a $ b =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    b", "unfolding interchange_rows_def"], ["proof (prove)\nusing this:\n  a \\<noteq>\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n  a \\<noteq> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. A $ a $ b =\n    (\\<chi>ia j.\n        if ia = mod_type_class.from_nat i\n        then A $\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 mod_type_class.from_nat i \\<le> n) $\n             j\n        else if ia =\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq>\n                    (0::'a) \\<and>\n                    mod_type_class.from_nat i \\<le> n)\n             then A $ mod_type_class.from_nat i $ j else A $ ia $ j) $\n    a $\n    b", "by auto"], ["proof (state)\nthis:\n  A $ a $ b =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ a $ b =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ a $ b =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  b\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>There are similar theorems to the following ones in the Gauss-Jordan developments, but\nfor matrices in reduced row echelon form. It is possible to prove that reduced row echelon form \nimplies echelon form. Then the theorems in the Gauss-Jordan development could be \nobtained with ease.\\<close>"], ["", "lemma greatest_less_zero_row:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{finite, wellorder}\"\n  assumes r: \"echelon_form_upt_k A k\"\n  and zero_i: \"is_zero_row_upt_k i k A\"\n  and not_all_zero: \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\"\n  shows \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) < i", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n           < i \\<Longrightarrow>\n    False", "assume not_less_i: \"\\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\""], ["proof (state)\nthis:\n  \\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\n\ngoal (1 subgoal):\n 1. \\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n           < i \\<Longrightarrow>\n    False", "have i_less_greatest: \"i < (GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "by (metis not_less_i neq_iff GreatestI not_all_zero zero_i)"], ["proof (state)\nthis:\n  i < (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. \\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n           < i \\<Longrightarrow>\n    False", "have \"is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A", "using r zero_i i_less_greatest"], ["proof (prove)\nusing this:\n  echelon_form_upt_k A k\n  is_zero_row_upt_k i k A\n  i < (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A", "unfolding echelon_form_upt_k_def"], ["proof (prove)\nusing this:\n  (\\<forall>i.\n      is_zero_row_upt_k i k A \\<longrightarrow>\n      \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)) \\<and>\n  (\\<forall>i j.\n      i < j \\<and>\n      \\<not> is_zero_row_upt_k i k A \\<and>\n      \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n      (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      < (LEAST n. A $ j $ n \\<noteq> (0::'a)))\n  is_zero_row_upt_k i k A\n  i < (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A", "by blast"], ["proof (state)\nthis:\n  is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A\n\ngoal (1 subgoal):\n 1. \\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n           < i \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A\n\ngoal (1 subgoal):\n 1. False", "using GreatestI_ex not_all_zero"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A\n  \\<exists>x. ?P x \\<Longrightarrow> ?P (Greatest ?P)\n  \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma greatest_ge_nonzero_row':\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"echelon_form_upt_k A k\"\n  and i: \"i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\"\n  and not_all_zero: \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\"\n  shows \"\\<not> is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "using greatest_less_zero_row[OF r] i not_all_zero"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_zero_row_upt_k ?i k A;\n   \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\\<rbrakk>\n  \\<Longrightarrow> (GREATEST m. \\<not> is_zero_row_upt_k m k A) < ?i\n  i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n  \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "by fastforce"], ["", "lemma rref_imp_ef: \n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes rref: \"reduced_row_echelon_form A\"\n  shows \"echelon_form A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form A", "proof (rule echelon_form_intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i.\n       is_zero_row i A \\<longrightarrow>\n       \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)\n 2. \\<forall>i j.\n       i < j \\<and>\n       \\<not> is_zero_row i A \\<and>\n       \\<not> is_zero_row j A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "show \"\\<forall>i. is_zero_row i A \\<longrightarrow> \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       is_zero_row i A \\<longrightarrow>\n       \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)", "by (simp add: rref rref_condition1)"], ["proof (state)\nthis:\n  \\<forall>i.\n     is_zero_row i A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < j \\<and>\n       \\<not> is_zero_row i A \\<and>\n       \\<not> is_zero_row j A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "show \"\\<forall>i j. i < j \\<and> \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \n    \\<longrightarrow> (LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < j \\<and>\n       \\<not> is_zero_row i A \\<and>\n       \\<not> is_zero_row j A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by (simp add: rref_condition3_equiv rref)"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < j \\<and>\n     \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'a))\n     < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Computing the echelon form of a matrix\\<close>"], ["", "subsubsection\\<open>Demonstration over principal ideal rings\\<close>"], ["", "text\\<open>Important remark:\n\nWe want to prove that there exist the echelon form of any matrix whose elements belong to a bezout \ndomain. In addition, we want to compute the echelon form, so we will need computable gcd \nand bezout operations which is possible over euclidean domains. \nOur approach consists of demonstrating the correctness over bezout domains\nand executing over euclidean domains.\n\nTo do that, we have studied several options:\n\n\\begin{enumerate}\n  \\item We could define a gcd in bezout rings (\\<open>bezout_ring_gcd\\<close>) as follows:\n  \\<open>gcd_bezout_ring a b = (SOME d. d dvd a \\<and> d dvd b \\<and> (\\<forall>d'. d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd d))\\<close>\n\n  And then define an algorithm that computes the Echelon Form using such a definition to the gcd.\n  This would allow us to prove the correctness over bezout rings, but we would not be able\n  to execute over euclidean rings because it is not possible to demonstrate a (code) lemma \n  stating that \\<open>(gcd_bezout_ring a b) = gcd_eucl a b\\<close> (the gcd is not unique over \n  bezout rings and GCD rings).\n  \n  \\item Create a \\<open>bezout_ring_norm\\<close> class and define a gcd normalized over bezout rings:\n  \\<open>definition gcd_bezout_ring_norm a b = gcd_bezout_ring a b div normalisation_factor (gcd_bezout_ring a b)\\<close>\n\n  Then, one could demonstrate a (code) lemma stating that: \\<open>(gcd_bezout_ring_norm a b) \n  = gcd_eucl a b\\<close>\n  This allows us to execute the gcd function, but with bezout it is not possible.\n\n  \\item The third option (and the chosen one) consists of defining the algorithm over bezout domains \n  and parametrizing the algorithm by a \\<open>bezout\\<close> operation which must satisfy \n  suitable properties (i.e @{term \"is_bezout_ext bezout\"}). Then we can prove the correctness over \n  bezout domains and we will execute over euclidean domains, since we can prove that the \n  operation  @{term \"euclid_ext2\"} is an executable operation which satisfies \n  @{term \"is_bezout_ext euclid_ext2\"}.\n\\end{enumerate}\n\\<close>"], ["", "subsubsection\\<open>Definition of the algorithm\\<close>"], ["", "context bezout_ring\nbegin"], ["", "definition \n  bezout_matrix :: \"'a^'cols^'rows \\<Rightarrow> 'rows \\<Rightarrow> 'rows \\<Rightarrow> 'cols \n                    \\<Rightarrow> ('a \\<Rightarrow> 'a \\<Rightarrow> ('a \\<times> 'a \\<times> 'a \\<times> 'a \\<times> 'a)) \\<Rightarrow> 'a^'rows^'rows\"\n  where \n  \"bezout_matrix A a b j bezout = (\\<chi> x y. \n      (let \n        (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j) \n       in\n         if x = a \\<and> y = a then p else\n         if x = a \\<and> y = b then q else\n         if x = b \\<and> y = a then u else\n         if x = b \\<and> y = b then v else\n         if x = y then 1 else 0))\""], ["", "end"], ["", "primrec\n  bezout_iterate :: \"'a::{bezout_ring}^'cols^'rows::{mod_type} \n                     \\<Rightarrow> nat \\<Rightarrow> 'rows::{mod_type} \n                     \\<Rightarrow> 'cols \\<Rightarrow> ('a \\<Rightarrow>'a \\<Rightarrow> ('a \\<times> 'a \\<times> 'a \\<times> 'a \\<times> 'a)) \\<Rightarrow> 'a^'cols^'rows::{mod_type}\"\nwhere \"bezout_iterate A 0 i j bezout = A\"\n    | \"bezout_iterate A (Suc n) i j bezout = \n        (if (Suc n) \\<le> to_nat i then A else \n              bezout_iterate (bezout_matrix A i (from_nat (Suc n)) j bezout ** A) n i j bezout)\""], ["", "text\\<open>If every element in column @{term \"k::nat\"} over index @{term \"i::nat\"} are equal to zero,\n      the same input is returned. If every element over @{term \"i::nat\"} \n      is equal to zero, except the pivot, the algorithm does nothing, but pivot @{term \"i::nat\"}\n      is increased in a unit. Finally, if there is a position @{term \"n::nat\"} \n      whose coefficient is different from zero, its row is interchanged with row \n      @{term \"i::nat\"} and the bezout coefficients are used to produce a zero in its position.\\<close>"], ["", "definition \n  \"echelon_form_of_column_k bezout A' k = \n    (let (A, i) = A' \n     in if (\\<forall>m\\<ge>from_nat i. A $ m $ from_nat k = 0) \\<or> (i = nrows A) then (A, i) else \n        if (\\<forall>m>from_nat i. A $ m $ from_nat k = 0) then (A, i + 1) else\n            let n = (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n); \n                interchange_A = interchange_rows A (from_nat i) n\n           in\n            (bezout_iterate (interchange_A) (nrows A - 1) (from_nat i) (from_nat k) bezout, i + 1))\""], ["", "definition \"echelon_form_of_upt_k A k bezout = (fst (foldl (echelon_form_of_column_k bezout) (A,0) [0..<Suc k]))\""], ["", "definition \"echelon_form_of A bezout = echelon_form_of_upt_k A (ncols A - 1) bezout\""], ["", "subsubsection\\<open>The executable definition:\\<close>"], ["", "context euclidean_space\nbegin"], ["", "definition [code_unfold]: \"echelon_form_of_euclidean A = echelon_form_of A euclid_ext2\""], ["", "end"], ["", "subsubsection\\<open>Properties of the bezout matrix\\<close>"], ["", "lemma bezout_matrix_works1:\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_not_b: \"a \\<noteq> b\"\n  shows \"(bezout_matrix A a b j bezout ** A) $ a $ j = snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ a $ j =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "proof (unfold matrix_matrix_mult_def bezout_matrix_def Let_def, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "let ?a = \"(A $ a $ j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "let ?b = \"(A $ b $ j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "let ?z = \"bezout (A $ a $ j) (A $ b $ j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "obtain p q u v d where bz: \"(p, q, u, v, d) = ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q u v d.\n        (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?z, auto)"], ["proof (state)\nthis:\n  (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "from ib"], ["proof (chain)\npicking this:\n  is_bezout_ext bezout", "have foo: \"(\\<And>a b. let (p, q, u, v, gcd_a_b) = bezout a b\n           in p * a + q * b = gcd_a_b \\<and>\n              gcd_a_b dvd a \\<and>\n              gcd_a_b dvd b \\<and> (\\<forall>d'. d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd gcd_a_b) \\<and> gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\""], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       let (p, q, u, v, gcd_a_b) = bezout a b\n       in p * a + q * b = gcd_a_b \\<and>\n          gcd_a_b dvd a \\<and>\n          gcd_a_b dvd b \\<and>\n          (\\<forall>d'.\n              d' dvd a \\<and> d' dvd b \\<longrightarrow>\n              d' dvd gcd_a_b) \\<and>\n          gcd_a_b * u = - b \\<and> gcd_a_b * v = a", "using is_bezout_ext_def [of bezout]"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n  is_bezout_ext bezout =\n  (\\<forall>a b.\n      let (p, q, u, v, gcd_a_b) = bezout a b\n      in p * a + q * b = gcd_a_b \\<and>\n         gcd_a_b dvd a \\<and>\n         gcd_a_b dvd b \\<and>\n         (\\<forall>d'.\n             d' dvd a \\<and> d' dvd b \\<longrightarrow>\n             d' dvd gcd_a_b) \\<and>\n         gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       let (p, q, u, v, gcd_a_b) = bezout a b\n       in p * a + q * b = gcd_a_b \\<and>\n          gcd_a_b dvd a \\<and>\n          gcd_a_b dvd b \\<and>\n          (\\<forall>d'.\n              d' dvd a \\<and> d' dvd b \\<longrightarrow>\n              d' dvd gcd_a_b) \\<and>\n          gcd_a_b * u = - b \\<and> gcd_a_b * v = a", "by simp"], ["proof (state)\nthis:\n  let (p, q, u, v, gcd_a_b) = bezout ?a ?b\n  in p * ?a + q * ?b = gcd_a_b \\<and>\n     gcd_a_b dvd ?a \\<and>\n     gcd_a_b dvd ?b \\<and>\n     (\\<forall>d'.\n         d' dvd ?a \\<and> d' dvd ?b \\<longrightarrow> d' dvd gcd_a_b) \\<and>\n     gcd_a_b * u = - ?b \\<and> gcd_a_b * v = ?a\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have foo: \"p * ?a + q * ?b = d \\<and> d dvd ?a \\<and>\n            d dvd ?b \\<and> (\\<forall>d'. d' dvd ?a \\<and> d' dvd ?b \\<longrightarrow> d' dvd d) \\<and> d * u = - ?b \\<and> d * v = ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * A $ a $ j + q * A $ b $ j = d \\<and>\n    d dvd A $ a $ j \\<and>\n    d dvd A $ b $ j \\<and>\n    (\\<forall>d'.\n        d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n        d' dvd d) \\<and>\n    d * u = - A $ b $ j \\<and> d * v = A $ a $ j", "using ib"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + q * A $ b $ j = d \\<and>\n    d dvd A $ a $ j \\<and>\n    d dvd A $ b $ j \\<and>\n    (\\<forall>d'.\n        d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n        d' dvd d) \\<and>\n    d * u = - A $ b $ j \\<and> d * v = A $ a $ j", "using is_bezout_ext_def"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n  is_bezout_ext ?bezout =\n  (\\<forall>a b.\n      let (p, q, u, v, gcd_a_b) = ?bezout a b\n      in p * a + q * b = gcd_a_b \\<and>\n         gcd_a_b dvd a \\<and>\n         gcd_a_b dvd b \\<and>\n         (\\<forall>d'.\n             d' dvd a \\<and> d' dvd b \\<longrightarrow>\n             d' dvd gcd_a_b) \\<and>\n         gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + q * A $ b $ j = d \\<and>\n    d dvd A $ a $ j \\<and>\n    d dvd A $ b $ j \\<and>\n    (\\<forall>d'.\n        d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n        d' dvd d) \\<and>\n    d * u = - A $ b $ j \\<and> d * v = A $ a $ j", "using bz [symmetric]"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n  is_bezout_ext ?bezout =\n  (\\<forall>a b.\n      let (p, q, u, v, gcd_a_b) = ?bezout a b\n      in p * a + q * b = gcd_a_b \\<and>\n         gcd_a_b dvd a \\<and>\n         gcd_a_b dvd b \\<and>\n         (\\<forall>d'.\n             d' dvd a \\<and> d' dvd b \\<longrightarrow>\n             d' dvd gcd_a_b) \\<and>\n         gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\n  bezout (A $ a $ j) (A $ b $ j) = (p, q, u, v, d)\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + q * A $ b $ j = d \\<and>\n    d dvd A $ a $ j \\<and>\n    d dvd A $ b $ j \\<and>\n    (\\<forall>d'.\n        d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n        d' dvd d) \\<and>\n    d * u = - A $ b $ j \\<and> d * v = A $ a $ j", "using foo [of ?a ?b]"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n  is_bezout_ext ?bezout =\n  (\\<forall>a b.\n      let (p, q, u, v, gcd_a_b) = ?bezout a b\n      in p * a + q * b = gcd_a_b \\<and>\n         gcd_a_b dvd a \\<and>\n         gcd_a_b dvd b \\<and>\n         (\\<forall>d'.\n             d' dvd a \\<and> d' dvd b \\<longrightarrow>\n             d' dvd gcd_a_b) \\<and>\n         gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\n  bezout (A $ a $ j) (A $ b $ j) = (p, q, u, v, d)\n  let (p, q, u, v, gcd_a_b) = bezout (A $ a $ j) (A $ b $ j)\n  in p * A $ a $ j + q * A $ b $ j = gcd_a_b \\<and>\n     gcd_a_b dvd A $ a $ j \\<and>\n     gcd_a_b dvd A $ b $ j \\<and>\n     (\\<forall>d'.\n         d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n         d' dvd gcd_a_b) \\<and>\n     gcd_a_b * u = - A $ b $ j \\<and> gcd_a_b * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + q * A $ b $ j = d \\<and>\n    d dvd A $ a $ j \\<and>\n    d dvd A $ b $ j \\<and>\n    (\\<forall>d'.\n        d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n        d' dvd d) \\<and>\n    d * u = - A $ b $ j \\<and> d * v = A $ a $ j", "by fastforce"], ["proof (state)\nthis:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have pa_bq_d: \"p * ?a + ?b * q = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * A $ a $ j + A $ b $ j * q = d", "using foo"], ["proof (prove)\nusing this:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + A $ b $ j * q = d", "by (auto simp add: mult.commute)"], ["proof (state)\nthis:\n  p * A $ a $ j + A $ b $ j * q = d\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "define f where \"f k = (if k = a then p\n              else if a = a \\<and> k = b then q\n              else if a = b \\<and> k = a then u\n              else if a = b \\<and> k = b then v\n              else if a = k then 1 else 0) * A $ k $ j\" for k"], ["proof (state)\nthis:\n  f ?k =\n  (if ?k = a then p\n   else if a = a \\<and> ?k = b then q\n        else if a = b \\<and> ?k = a then u\n             else if a = b \\<and> ?k = b then v\n                  else if a = ?k then 1::'a else (0::'a)) *\n  A $ ?k $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have UNIV_rw: \"UNIV = insert b (insert a (UNIV - {a} - {b}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = insert b (insert a (UNIV - {a} - {b}))", "by auto"], ["proof (state)\nthis:\n  UNIV = insert b (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have sum_rw: \"sum f (insert a (UNIV - {a} - {b})) = f a + sum f (UNIV - {a} - {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert a (UNIV - {a} - {b})) = f a + sum f (UNIV - {a} - {b})", "by (rule sum.insert, auto)"], ["proof (state)\nthis:\n  sum f (insert a (UNIV - {a} - {b})) = f a + sum f (UNIV - {a} - {b})\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have sum0: \"sum f (UNIV - {a} - {b}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (UNIV - {a} - {b}) = (0::'a)", "by (rule sum.neutral, simp add: f_def)"], ["proof (state)\nthis:\n  sum f (UNIV - {a} - {b}) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have \"(\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u else if a = b \\<and> k = b then v else if a = k then 1 else 0) *\n       A $ k $ j) = (\\<Sum>k\\<in>UNIV.\n       (if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u else if a = b \\<and> k = b then v else if a = k then 1 else 0) *\n       A $ k $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (\\<Sum>k\\<in>UNIV.\n       (if k = a then p\n        else if a = a \\<and> k = b then q\n             else if a = b \\<and> k = a then u\n                  else if a = b \\<and> k = b then v\n                       else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j)", "unfolding bz [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case (p, q, u, v, d) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (\\<Sum>k\\<in>UNIV.\n       (if k = a then p\n        else if a = a \\<and> k = b then q\n             else if a = b \\<and> k = a then u\n                  else if a = b \\<and> k = b then v\n                       else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV.\n     (case bezout (A $ a $ j) (A $ b $ j) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if k = a then p\n        else if a = a \\<and> k = b then q\n             else if a = b \\<and> k = a then u\n                  else if a = b \\<and> k = b then v\n                       else if a = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  (\\<Sum>k\\<in>UNIV.\n     (if k = a then p\n      else if a = a \\<and> k = b then q\n           else if a = b \\<and> k = a then u\n                else if a = b \\<and> k = b then v\n                     else if a = k then 1::'a else (0::'a)) *\n     A $ k $ j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV.\n     (case bezout (A $ a $ j) (A $ b $ j) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if k = a then p\n        else if a = a \\<and> k = b then q\n             else if a = b \\<and> k = a then u\n                  else if a = b \\<and> k = b then v\n                       else if a = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  (\\<Sum>k\\<in>UNIV.\n     (if k = a then p\n      else if a = a \\<and> k = b then q\n           else if a = b \\<and> k = a then u\n                else if a = b \\<and> k = b then v\n                     else if a = k then 1::'a else (0::'a)) *\n     A $ k $ j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have \"... = sum f UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (if k = a then p\n        else if a = a \\<and> k = b then q\n             else if a = b \\<and> k = a then u\n                  else if a = b \\<and> k = b then v\n                       else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    sum f UNIV", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (if k = a then p\n        else if a = a \\<and> k = b then q\n             else if a = b \\<and> k = a then u\n                  else if a = b \\<and> k = b then v\n                       else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (\\<Sum>k\\<in>UNIV.\n       (if k = a then p\n        else if a = a \\<and> k = b then q\n             else if a = b \\<and> k = a then u\n                  else if a = b \\<and> k = b then v\n                       else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j)", ".."], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV.\n     (if k = a then p\n      else if a = a \\<and> k = b then q\n           else if a = b \\<and> k = a then u\n                else if a = b \\<and> k = b then v\n                     else if a = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  sum f UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV.\n     (if k = a then p\n      else if a = a \\<and> k = b then q\n           else if a = b \\<and> k = a then u\n                else if a = b \\<and> k = b then v\n                     else if a = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  sum f UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have \"sum f UNIV = sum f (insert b (insert a (UNIV - {a} - {b})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f UNIV = sum f (insert b (insert a (UNIV - {a} - {b})))", "using UNIV_rw"], ["proof (prove)\nusing this:\n  UNIV = insert b (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. sum f UNIV = sum f (insert b (insert a (UNIV - {a} - {b})))", "by simp"], ["proof (state)\nthis:\n  sum f UNIV = sum f (insert b (insert a (UNIV - {a} - {b})))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "also"], ["proof (state)\nthis:\n  sum f UNIV = sum f (insert b (insert a (UNIV - {a} - {b})))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have \"... = f b + sum f (insert a (UNIV - {a} - {b}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert b (insert a (UNIV - {a} - {b}))) =\n    f b + sum f (insert a (UNIV - {a} - {b}))", "by (rule sum.insert, auto, metis a_not_b)"], ["proof (state)\nthis:\n  sum f (insert b (insert a (UNIV - {a} - {b}))) =\n  f b + sum f (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "also"], ["proof (state)\nthis:\n  sum f (insert b (insert a (UNIV - {a} - {b}))) =\n  f b + sum f (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have \"... = f b + f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f b + sum f (insert a (UNIV - {a} - {b})) = f b + f a", "unfolding sum_rw sum0"], ["proof (prove)\ngoal (1 subgoal):\n 1. f b + (f a + (0::'a)) = f b + f a", "by simp"], ["proof (state)\nthis:\n  f b + sum f (insert a (UNIV - {a} - {b})) = f b + f a\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "also"], ["proof (state)\nthis:\n  f b + sum f (insert a (UNIV - {a} - {b})) = f b + f a\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have \"... = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f b + f a = d", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b = a then p\n     else if a = a \\<and> b = b then q\n          else if a = b \\<and> b = a then u\n               else if a = b \\<and> b = b then v\n                    else if a = b then 1::'a else (0::'a)) *\n    A $ b $ j +\n    (if a = a then p\n     else if a = a \\<and> a = b then q\n          else if a = b \\<and> a = a then u\n               else if a = b \\<and> a = b then v\n                    else if a = a then 1::'a else (0::'a)) *\n    A $ a $ j =\n    d", "using a_not_b bz [symmetric]"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  bezout (A $ a $ j) (A $ b $ j) = (p, q, u, v, d)\n\ngoal (1 subgoal):\n 1. (if b = a then p\n     else if a = a \\<and> b = b then q\n          else if a = b \\<and> b = a then u\n               else if a = b \\<and> b = b then v\n                    else if a = b then 1::'a else (0::'a)) *\n    A $ b $ j +\n    (if a = a then p\n     else if a = a \\<and> a = b then q\n          else if a = b \\<and> a = a then u\n               else if a = b \\<and> a = b then v\n                    else if a = a then 1::'a else (0::'a)) *\n    A $ a $ j =\n    d", "by (auto, metis add.commute mult.commute pa_bq_d)"], ["proof (state)\nthis:\n  f b + f a = d\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "also"], ["proof (state)\nthis:\n  f b + f a = d\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "have \"... = snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d = snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "using bz"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n\ngoal (1 subgoal):\n 1. d = snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "by (metis snd_conv)"], ["proof (state)\nthis:\n  d = snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>k\\<in>UNIV.\n     (case bezout (A $ a $ j) (A $ b $ j) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if k = a then p\n        else if a = a \\<and> k = b then q\n             else if a = b \\<and> k = a then u\n                  else if a = b \\<and> k = b then v\n                       else if a = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "show \"(\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u else if a = b \\<and> k = b then v else if a = k then 1 else 0) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))\""], ["proof (prove)\nusing this:\n  (\\<Sum>k\\<in>UNIV.\n     (case bezout (A $ a $ j) (A $ b $ j) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if k = a then p\n        else if a = a \\<and> k = b then q\n             else if a = b \\<and> k = a then u\n                  else if a = b \\<and> k = b then v\n                       else if a = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "unfolding f_def"], ["proof (prove)\nusing this:\n  (\\<Sum>k\\<in>UNIV.\n     (case bezout (A $ a $ j) (A $ b $ j) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if k = a then p\n        else if a = a \\<and> k = b then q\n             else if a = b \\<and> k = a then u\n                  else if a = b \\<and> k = b then v\n                       else if a = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if k = a then p\n          else if a = a \\<and> k = b then q\n               else if a = b \\<and> k = a then u\n                    else if a = b \\<and> k = b then v\n                         else if a = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV.\n     (case bezout (A $ a $ j) (A $ b $ j) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if k = a then p\n        else if a = a \\<and> k = b then q\n             else if a = b \\<and> k = a then u\n                  else if a = b \\<and> k = b then v\n                       else if a = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bezout_matrix_not_zero:\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_not_b: \"a \\<noteq> b\"\n  and Aaj: \"A $ a $ j \\<noteq> 0\"\n  shows \"(bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> (0::'a)", "have \"(bezout_matrix A a b j bezout ** A) $ a $ j = snd (snd (snd(snd (bezout (A $ a $ j) (A $ b $ j)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ a $ j =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "using bezout_matrix_works1[OF ib a_not_b]"], ["proof (prove)\nusing this:\n  (bezout_matrix ?A a b ?j bezout ** ?A) $ a $ ?j =\n  snd (snd (snd (snd (bezout (?A $ a $ ?j) (?A $ b $ ?j)))))\n\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ a $ j =\n    snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))", "."], ["proof (state)\nthis:\n  (bezout_matrix A a b j bezout ** A) $ a $ j =\n  snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))\n\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> (0::'a)", "also"], ["proof (state)\nthis:\n  (bezout_matrix A a b j bezout ** A) $ a $ j =\n  snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j)))))\n\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> (0::'a)", "have \"... = (\\<lambda>a b. (case bezout a b of (_, _,_ ,_,gcd') \\<Rightarrow> (gcd'))) (A $ a $ j) (A $ b $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j))))) =\n    (case bezout (A $ a $ j) (A $ b $ j) of\n     (x, xa, xb, xc, gcd') \\<Rightarrow> gcd')", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j))))) =\n  (case bezout (A $ a $ j) (A $ b $ j) of\n   (x, xa, xb, xc, gcd') \\<Rightarrow> gcd')\n\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> (0::'a)", "also"], ["proof (state)\nthis:\n  snd (snd (snd (snd (bezout (A $ a $ j) (A $ b $ j))))) =\n  (case bezout (A $ a $ j) (A $ b $ j) of\n   (x, xa, xb, xc, gcd') \\<Rightarrow> gcd')\n\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> (0::'a)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case bezout (A $ a $ j) (A $ b $ j) of\n     (x, xa, xb, xc, gcd') \\<Rightarrow> gcd') \\<noteq>\n    (0::'a)", "using gcd'_zero[OF is_gcd_is_bezout_ext[OF ib]] Aaj"], ["proof (prove)\nusing this:\n  ((case bezout ?x ?y of (x, xa, u, v, gcd') \\<Rightarrow> gcd') =\n   (0::'a)) =\n  (?x = (0::'a) \\<and> ?y = (0::'a))\n  A $ a $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (case bezout (A $ a $ j) (A $ b $ j) of\n     (x, xa, xb, xc, gcd') \\<Rightarrow> gcd') \\<noteq>\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  (case bezout (A $ a $ j) (A $ b $ j) of\n   (x, xa, xb, xc, gcd') \\<Rightarrow> gcd') \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  (bezout_matrix A a b j bezout ** A) $ a $ j \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ua_vb_0:\n  fixes a::\"'a::bezout_domain\"\n  assumes ib: \"is_bezout_ext bezout\" and nz: \"snd (snd (snd (snd (bezout a b)))) \\<noteq> 0\"\n  shows \"fst (snd (snd (bezout a b))) * a + fst (snd (snd (snd (bezout a b)))) * b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (snd (bezout a b))) * a +\n    fst (snd (snd (snd (bezout a b)))) * b =\n    (0::'a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (snd (snd (bezout a b))) * a +\n    fst (snd (snd (snd (bezout a b)))) * b =\n    (0::'a)", "obtain p q u v d where bz: \"(p, q, u, v, d) = bezout a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q u v d.\n        (p, q, u, v, d) = bezout a b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"bezout a b\", auto)"], ["proof (state)\nthis:\n  (p, q, u, v, d) = bezout a b\n\ngoal (1 subgoal):\n 1. fst (snd (snd (bezout a b))) * a +\n    fst (snd (snd (snd (bezout a b)))) * b =\n    (0::'a)", "from ib"], ["proof (chain)\npicking this:\n  is_bezout_ext bezout", "have foo: \"(\\<And>a b. let (p, q, u, v, gcd_a_b) = bezout a b\n           in p * a + q * b = gcd_a_b \\<and>\n              gcd_a_b dvd a \\<and>\n              gcd_a_b dvd b \\<and> (\\<forall>d'. d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd gcd_a_b) \\<and> gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\""], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       let (p, q, u, v, gcd_a_b) = bezout a b\n       in p * a + q * b = gcd_a_b \\<and>\n          gcd_a_b dvd a \\<and>\n          gcd_a_b dvd b \\<and>\n          (\\<forall>d'.\n              d' dvd a \\<and> d' dvd b \\<longrightarrow>\n              d' dvd gcd_a_b) \\<and>\n          gcd_a_b * u = - b \\<and> gcd_a_b * v = a", "using is_bezout_ext_def [of bezout]"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n  is_bezout_ext bezout =\n  (\\<forall>a b.\n      let (p, q, u, v, gcd_a_b) = bezout a b\n      in p * a + q * b = gcd_a_b \\<and>\n         gcd_a_b dvd a \\<and>\n         gcd_a_b dvd b \\<and>\n         (\\<forall>d'.\n             d' dvd a \\<and> d' dvd b \\<longrightarrow>\n             d' dvd gcd_a_b) \\<and>\n         gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       let (p, q, u, v, gcd_a_b) = bezout a b\n       in p * a + q * b = gcd_a_b \\<and>\n          gcd_a_b dvd a \\<and>\n          gcd_a_b dvd b \\<and>\n          (\\<forall>d'.\n              d' dvd a \\<and> d' dvd b \\<longrightarrow>\n              d' dvd gcd_a_b) \\<and>\n          gcd_a_b * u = - b \\<and> gcd_a_b * v = a", "by simp"], ["proof (state)\nthis:\n  let (p, q, u, v, gcd_a_b) = bezout ?a ?b\n  in p * ?a + q * ?b = gcd_a_b \\<and>\n     gcd_a_b dvd ?a \\<and>\n     gcd_a_b dvd ?b \\<and>\n     (\\<forall>d'.\n         d' dvd ?a \\<and> d' dvd ?b \\<longrightarrow> d' dvd gcd_a_b) \\<and>\n     gcd_a_b * u = - ?b \\<and> gcd_a_b * v = ?a\n\ngoal (1 subgoal):\n 1. fst (snd (snd (bezout a b))) * a +\n    fst (snd (snd (snd (bezout a b)))) * b =\n    (0::'a)", "have \"p * a + q * b = d \\<and> d dvd a \\<and>\n            d dvd b \\<and> (\\<forall>d'. d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd d) \\<and> d * u = - b \\<and> d * v = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * a + q * b = d \\<and>\n    d dvd a \\<and>\n    d dvd b \\<and>\n    (\\<forall>d'.\n        d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd d) \\<and>\n    d * u = - b \\<and> d * v = a", "using foo [of a b]"], ["proof (prove)\nusing this:\n  let (p, q, u, v, gcd_a_b) = bezout a b\n  in p * a + q * b = gcd_a_b \\<and>\n     gcd_a_b dvd a \\<and>\n     gcd_a_b dvd b \\<and>\n     (\\<forall>d'.\n         d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd gcd_a_b) \\<and>\n     gcd_a_b * u = - b \\<and> gcd_a_b * v = a\n\ngoal (1 subgoal):\n 1. p * a + q * b = d \\<and>\n    d dvd a \\<and>\n    d dvd b \\<and>\n    (\\<forall>d'.\n        d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd d) \\<and>\n    d * u = - b \\<and> d * v = a", "using bz"], ["proof (prove)\nusing this:\n  let (p, q, u, v, gcd_a_b) = bezout a b\n  in p * a + q * b = gcd_a_b \\<and>\n     gcd_a_b dvd a \\<and>\n     gcd_a_b dvd b \\<and>\n     (\\<forall>d'.\n         d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd gcd_a_b) \\<and>\n     gcd_a_b * u = - b \\<and> gcd_a_b * v = a\n  (p, q, u, v, d) = bezout a b\n\ngoal (1 subgoal):\n 1. p * a + q * b = d \\<and>\n    d dvd a \\<and>\n    d dvd b \\<and>\n    (\\<forall>d'.\n        d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd d) \\<and>\n    d * u = - b \\<and> d * v = a", "by fastforce"], ["proof (state)\nthis:\n  p * a + q * b = d \\<and>\n  d dvd a \\<and>\n  d dvd b \\<and>\n  (\\<forall>d'. d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd d) \\<and>\n  d * u = - b \\<and> d * v = a\n\ngoal (1 subgoal):\n 1. fst (snd (snd (bezout a b))) * a +\n    fst (snd (snd (snd (bezout a b)))) * b =\n    (0::'a)", "hence dub: \"d * u = - b\" and dva: \"d * v = a\""], ["proof (prove)\nusing this:\n  p * a + q * b = d \\<and>\n  d dvd a \\<and>\n  d dvd b \\<and>\n  (\\<forall>d'. d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd d) \\<and>\n  d * u = - b \\<and> d * v = a\n\ngoal (1 subgoal):\n 1. d * u = - b &&& d * v = a", "by (simp_all)"], ["proof (state)\nthis:\n  d * u = - b\n  d * v = a\n\ngoal (1 subgoal):\n 1. fst (snd (snd (bezout a b))) * a +\n    fst (snd (snd (snd (bezout a b)))) * b =\n    (0::'a)", "hence \"d * u * a + d * v * b = 0\""], ["proof (prove)\nusing this:\n  d * u = - b\n  d * v = a\n\ngoal (1 subgoal):\n 1. d * u * a + d * v * b = (0::'a)", "using eq_neg_iff_add_eq_0 mult.commute mult_minus_left"], ["proof (prove)\nusing this:\n  d * u = - b\n  d * v = a\n  (?a = - ?b) = (?a + ?b = (0::?'a))\n  ?a * ?b = ?b * ?a\n  - ?a * ?b = - (?a * ?b)\n\ngoal (1 subgoal):\n 1. d * u * a + d * v * b = (0::'a)", "by auto"], ["proof (state)\nthis:\n  d * u * a + d * v * b = (0::'a)\n\ngoal (1 subgoal):\n 1. fst (snd (snd (bezout a b))) * a +\n    fst (snd (snd (snd (bezout a b)))) * b =\n    (0::'a)", "hence \"u * a + v * b = 0\""], ["proof (prove)\nusing this:\n  d * u * a + d * v * b = (0::'a)\n\ngoal (1 subgoal):\n 1. u * a + v * b = (0::'a)", "by (metis (no_types, lifting) dub dva minus_minus mult_minus_left \n          neg_eq_iff_add_eq_0 semiring_normalization_rules(18) semiring_normalization_rules(7))"], ["proof (state)\nthis:\n  u * a + v * b = (0::'a)\n\ngoal (1 subgoal):\n 1. fst (snd (snd (bezout a b))) * a +\n    fst (snd (snd (snd (bezout a b)))) * b =\n    (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  u * a + v * b = (0::'a)\n\ngoal (1 subgoal):\n 1. fst (snd (snd (bezout a b))) * a +\n    fst (snd (snd (snd (bezout a b)))) * b =\n    (0::'a)", "using bz [symmetric]"], ["proof (prove)\nusing this:\n  u * a + v * b = (0::'a)\n  bezout a b = (p, q, u, v, d)\n\ngoal (1 subgoal):\n 1. fst (snd (snd (bezout a b))) * a +\n    fst (snd (snd (snd (bezout a b)))) * b =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  fst (snd (snd (bezout a b))) * a +\n  fst (snd (snd (snd (bezout a b)))) * b =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bezout_matrix_works2:\n  fixes A::\"'a::bezout_domain^'cols^'rows\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_not_b: \"a \\<noteq> b\"\n  and not_0: \"A $ a $ j \\<noteq> 0 \\<or> A $ b $ j \\<noteq> 0\"\n  shows \"(bezout_matrix A a b j bezout ** A) $ b $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A a b j bezout ** A) $ b $ j = (0::'a)", "proof (unfold matrix_matrix_mult_def bezout_matrix_def Let_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "let ?a = \"(A $ a $ j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "let ?b = \"(A $ b $ j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "let ?z = \"bezout (A $ a $ j) (A $ b $ j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "from ib"], ["proof (chain)\npicking this:\n  is_bezout_ext bezout", "have foo: \"(\\<And>a b. let (p, q, u, v, gcd_a_b) = bezout a b\n           in p * a + q * b = gcd_a_b \\<and>\n              gcd_a_b dvd a \\<and>\n              gcd_a_b dvd b \\<and> (\\<forall>d'. d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd gcd_a_b) \\<and> gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\""], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       let (p, q, u, v, gcd_a_b) = bezout a b\n       in p * a + q * b = gcd_a_b \\<and>\n          gcd_a_b dvd a \\<and>\n          gcd_a_b dvd b \\<and>\n          (\\<forall>d'.\n              d' dvd a \\<and> d' dvd b \\<longrightarrow>\n              d' dvd gcd_a_b) \\<and>\n          gcd_a_b * u = - b \\<and> gcd_a_b * v = a", "using is_bezout_ext_def [of bezout]"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n  is_bezout_ext bezout =\n  (\\<forall>a b.\n      let (p, q, u, v, gcd_a_b) = bezout a b\n      in p * a + q * b = gcd_a_b \\<and>\n         gcd_a_b dvd a \\<and>\n         gcd_a_b dvd b \\<and>\n         (\\<forall>d'.\n             d' dvd a \\<and> d' dvd b \\<longrightarrow>\n             d' dvd gcd_a_b) \\<and>\n         gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       let (p, q, u, v, gcd_a_b) = bezout a b\n       in p * a + q * b = gcd_a_b \\<and>\n          gcd_a_b dvd a \\<and>\n          gcd_a_b dvd b \\<and>\n          (\\<forall>d'.\n              d' dvd a \\<and> d' dvd b \\<longrightarrow>\n              d' dvd gcd_a_b) \\<and>\n          gcd_a_b * u = - b \\<and> gcd_a_b * v = a", "by simp"], ["proof (state)\nthis:\n  let (p, q, u, v, gcd_a_b) = bezout ?a ?b\n  in p * ?a + q * ?b = gcd_a_b \\<and>\n     gcd_a_b dvd ?a \\<and>\n     gcd_a_b dvd ?b \\<and>\n     (\\<forall>d'.\n         d' dvd ?a \\<and> d' dvd ?b \\<longrightarrow> d' dvd gcd_a_b) \\<and>\n     gcd_a_b * u = - ?b \\<and> gcd_a_b * v = ?a\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "obtain p q u v d where bz: \"(p, q, u, v, d) = ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q u v d.\n        (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?z, auto)"], ["proof (state)\nthis:\n  (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "hence pib: \"p * ?a + q * ?b = d \\<and> d dvd ?a \\<and>\n            d dvd ?b \\<and> (\\<forall>d'. d' dvd ?a \\<and> d' dvd ?b \\<longrightarrow> d' dvd d) \\<and> d * u = - ?b \\<and> d * v = ?a\""], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + q * A $ b $ j = d \\<and>\n    d dvd A $ a $ j \\<and>\n    d dvd A $ b $ j \\<and>\n    (\\<forall>d'.\n        d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n        d' dvd d) \\<and>\n    d * u = - A $ b $ j \\<and> d * v = A $ a $ j", "using foo [of ?a ?b]"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n  let (p, q, u, v, gcd_a_b) = bezout (A $ a $ j) (A $ b $ j)\n  in p * A $ a $ j + q * A $ b $ j = gcd_a_b \\<and>\n     gcd_a_b dvd A $ a $ j \\<and>\n     gcd_a_b dvd A $ b $ j \\<and>\n     (\\<forall>d'.\n         d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n         d' dvd gcd_a_b) \\<and>\n     gcd_a_b * u = - A $ b $ j \\<and> gcd_a_b * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + q * A $ b $ j = d \\<and>\n    d dvd A $ a $ j \\<and>\n    d dvd A $ b $ j \\<and>\n    (\\<forall>d'.\n        d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n        d' dvd d) \\<and>\n    d * u = - A $ b $ j \\<and> d * v = A $ a $ j", "by fastforce"], ["proof (state)\nthis:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "hence pa_bq_d: \"p * ?a + ?b * q = d\""], ["proof (prove)\nusing this:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + A $ b $ j * q = d", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  p * A $ a $ j + A $ b $ j * q = d\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have d_dvd_a: \"d dvd ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd A $ a $ j", "using pib"], ["proof (prove)\nusing this:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. d dvd A $ a $ j", "by auto"], ["proof (state)\nthis:\n  d dvd A $ a $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have d_dvd_b: \"d dvd -?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd - A $ b $ j", "using pib"], ["proof (prove)\nusing this:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. d dvd - A $ b $ j", "by auto"], ["proof (state)\nthis:\n  d dvd - A $ b $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have pa_bq_d: \"p * ?a + ?b * q = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * A $ a $ j + A $ b $ j * q = d", "using pa_bq_d"], ["proof (prove)\nusing this:\n  p * A $ a $ j + A $ b $ j * q = d\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + A $ b $ j * q = d", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  p * A $ a $ j + A $ b $ j * q = d\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "define f where \"f k = (if b = a \\<and> k = a then p\n                 else if b = a \\<and> k = b then q\n                      else if b = b \\<and> k = a then u\n                           else if b = b \\<and> k = b then v else if b = k then 1 else 0) *\n                A $ k $ j\" for k"], ["proof (state)\nthis:\n  f ?k =\n  (if b = a \\<and> ?k = a then p\n   else if b = a \\<and> ?k = b then q\n        else if b = b \\<and> ?k = a then u\n             else if b = b \\<and> ?k = b then v\n                  else if b = ?k then 1::'a else (0::'a)) *\n  A $ ?k $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have UNIV_rw: \"UNIV = insert b (insert a (UNIV - {a} - {b}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = insert b (insert a (UNIV - {a} - {b}))", "by auto"], ["proof (state)\nthis:\n  UNIV = insert b (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have sum_rw: \"sum f (insert a (UNIV - {a} - {b})) = f a + sum f (UNIV - {a} - {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert a (UNIV - {a} - {b})) = f a + sum f (UNIV - {a} - {b})", "by (rule sum.insert, auto)"], ["proof (state)\nthis:\n  sum f (insert a (UNIV - {a} - {b})) = f a + sum f (UNIV - {a} - {b})\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have sum0: \"sum f (UNIV - {a} - {b}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (UNIV - {a} - {b}) = (0::'a)", "by (rule sum.neutral, simp add: f_def)"], ["proof (state)\nthis:\n  sum f (UNIV - {a} - {b}) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have \"(\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u else if b = b \\<and> k = b then v else if b = k then 1 else 0) *\n       A $ k $ j) = sum f UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    sum f UNIV", "unfolding f_def bz [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case (p, q, u, v, d) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (\\<Sum>k\\<in>UNIV.\n       (if b = a \\<and> k = a then p\n        else if b = a \\<and> k = b then q\n             else if b = b \\<and> k = a then u\n                  else if b = b \\<and> k = b then v\n                       else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV.\n     (case bezout (A $ a $ j) (A $ b $ j) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if b = a \\<and> k = a then p\n        else if b = a \\<and> k = b then q\n             else if b = b \\<and> k = a then u\n                  else if b = b \\<and> k = b then v\n                       else if b = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  sum f UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV.\n     (case bezout (A $ a $ j) (A $ b $ j) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if b = a \\<and> k = a then p\n        else if b = a \\<and> k = b then q\n             else if b = b \\<and> k = a then u\n                  else if b = b \\<and> k = b then v\n                       else if b = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  sum f UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have \"sum f UNIV = sum f (insert b (insert a (UNIV - {a} - {b})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f UNIV = sum f (insert b (insert a (UNIV - {a} - {b})))", "using UNIV_rw"], ["proof (prove)\nusing this:\n  UNIV = insert b (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. sum f UNIV = sum f (insert b (insert a (UNIV - {a} - {b})))", "by simp"], ["proof (state)\nthis:\n  sum f UNIV = sum f (insert b (insert a (UNIV - {a} - {b})))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  sum f UNIV = sum f (insert b (insert a (UNIV - {a} - {b})))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have \"... = f b + sum f (insert a (UNIV - {a} - {b}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert b (insert a (UNIV - {a} - {b}))) =\n    f b + sum f (insert a (UNIV - {a} - {b}))", "by (rule sum.insert, auto, metis a_not_b)"], ["proof (state)\nthis:\n  sum f (insert b (insert a (UNIV - {a} - {b}))) =\n  f b + sum f (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  sum f (insert b (insert a (UNIV - {a} - {b}))) =\n  f b + sum f (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have \"... = f b + f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f b + sum f (insert a (UNIV - {a} - {b})) = f b + f a", "unfolding sum_rw sum0"], ["proof (prove)\ngoal (1 subgoal):\n 1. f b + (f a + (0::'a)) = f b + f a", "by simp"], ["proof (state)\nthis:\n  f b + sum f (insert a (UNIV - {a} - {b})) = f b + f a\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  f b + sum f (insert a (UNIV - {a} - {b})) = f b + f a\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have \"... = v * ?b + u * ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f b + f a = v * A $ b $ j + u * A $ a $ j", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b = a \\<and> b = a then p\n     else if b = a \\<and> b = b then q\n          else if b = b \\<and> b = a then u\n               else if b = b \\<and> b = b then v\n                    else if b = b then 1::'a else (0::'a)) *\n    A $ b $ j +\n    (if b = a \\<and> a = a then p\n     else if b = a \\<and> a = b then q\n          else if b = b \\<and> a = a then u\n               else if b = b \\<and> a = b then v\n                    else if b = a then 1::'a else (0::'a)) *\n    A $ a $ j =\n    v * A $ b $ j + u * A $ a $ j", "using a_not_b"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. (if b = a \\<and> b = a then p\n     else if b = a \\<and> b = b then q\n          else if b = b \\<and> b = a then u\n               else if b = b \\<and> b = b then v\n                    else if b = b then 1::'a else (0::'a)) *\n    A $ b $ j +\n    (if b = a \\<and> a = a then p\n     else if b = a \\<and> a = b then q\n          else if b = b \\<and> a = a then u\n               else if b = b \\<and> a = b then v\n                    else if b = a then 1::'a else (0::'a)) *\n    A $ a $ j =\n    v * A $ b $ j + u * A $ a $ j", "by auto"], ["proof (state)\nthis:\n  f b + f a = v * A $ b $ j + u * A $ a $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  f b + f a = v * A $ b $ j + u * A $ a $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have \"... = u * ?a + v * ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * A $ b $ j + u * A $ a $ j = u * A $ a $ j + v * A $ b $ j", "by auto"], ["proof (state)\nthis:\n  v * A $ b $ j + u * A $ a $ j = u * A $ a $ j + v * A $ b $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  v * A $ b $ j + u * A $ a $ j = u * A $ a $ j + v * A $ b $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u * A $ a $ j + v * A $ b $ j = (0::'a)", "using ua_vb_0 [OF ib] bz"], ["proof (prove)\nusing this:\n  snd (snd (snd (snd (bezout ?a ?b)))) \\<noteq> (0::'a) \\<Longrightarrow>\n  fst (snd (snd (bezout ?a ?b))) * ?a +\n  fst (snd (snd (snd (bezout ?a ?b)))) * ?b =\n  (0::'a)\n  (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n\ngoal (1 subgoal):\n 1. u * A $ a $ j + v * A $ b $ j = (0::'a)", "by (metis fst_conv minus_minus minus_zero mult_eq_0_iff pib snd_conv)"], ["proof (state)\nthis:\n  u * A $ a $ j + v * A $ b $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>k\\<in>UNIV.\n     (case bezout (A $ a $ j) (A $ b $ j) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if b = a \\<and> k = a then p\n        else if b = a \\<and> k = b then q\n             else if b = b \\<and> k = a then u\n                  else if b = b \\<and> k = b then v\n                       else if b = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  (0::'a)", "show \"(\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u else if b = b \\<and> k = b then v else if b = k then 1 else 0) *\n       A $ k $ j) =\n       0\""], ["proof (prove)\nusing this:\n  (\\<Sum>k\\<in>UNIV.\n     (case bezout (A $ a $ j) (A $ b $ j) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if b = a \\<and> k = a then p\n        else if b = a \\<and> k = b then q\n             else if b = b \\<and> k = a then u\n                  else if b = b \\<and> k = b then v\n                       else if b = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if b = a \\<and> k = a then p\n          else if b = a \\<and> k = b then q\n               else if b = b \\<and> k = a then u\n                    else if b = b \\<and> k = b then v\n                         else if b = k then 1::'a else (0::'a)) *\n       A $ k $ j) =\n    (0::'a)", "."], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV.\n     (case bezout (A $ a $ j) (A $ b $ j) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if b = a \\<and> k = a then p\n        else if b = a \\<and> k = b then q\n             else if b = b \\<and> k = a then u\n                  else if b = b \\<and> k = b then v\n                       else if b = k then 1::'a else (0::'a)) *\n     A $ k $ j) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bezout_matrix_preserves_previous_columns:\n  assumes ib: \"is_bezout_ext bezout\"\n  and i_not_j: \"i \\<noteq> j\"\n  and Aik: \"A $ i $ k \\<noteq> 0\"\n  and b_k: \"b<k\"\n  and i: \"is_zero_row_upt_k i (to_nat k) A\" and j: \"is_zero_row_upt_k j (to_nat k) A\"\n  shows \"(bezout_matrix A i j k bezout ** A) $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i j k bezout ** A) $ a $ b = A $ a $ b", "unfolding matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        \\<Sum>ka\\<in>UNIV.\n          bezout_matrix A i j k bezout $ ia $ ka * A $ ka $ ja) $\n    a $\n    b =\n    A $ a $ b", "unfolding bezout_matrix_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        \\<Sum>ka\\<in>UNIV.\n          (\\<chi>x y.\n              case bezout (A $ i $ k) (A $ j $ k) of\n              (p, q, u, v, d) \\<Rightarrow>\n                if x = i \\<and> y = i then p\n                else if x = i \\<and> y = j then q\n                     else if x = j \\<and> y = i then u\n                          else if x = j \\<and> y = j then v\n                               else if x = y then 1::'a else (0::'a)) $\n          ia $\n          ka *\n          A $ ka $ ja) $\n    a $\n    b =\n    A $ a $ b", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "let ?B = \"bezout_matrix A i j k bezout\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "let ?i = \"(A $ i $ k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "let ?j = \"(A $ j $ k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "let ?z = \"bezout (A $ i $ k) (A $ j $ k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "from ib"], ["proof (chain)\npicking this:\n  is_bezout_ext bezout", "have foo: \"(\\<And>a b. let (p, q, u, v, gcd_a_b) = bezout a b\n           in p * a + q * b = gcd_a_b \\<and>\n              gcd_a_b dvd a \\<and>\n              gcd_a_b dvd b \\<and> (\\<forall>d'. d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd gcd_a_b) \\<and> gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\""], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       let (p, q, u, v, gcd_a_b) = bezout a b\n       in p * a + q * b = gcd_a_b \\<and>\n          gcd_a_b dvd a \\<and>\n          gcd_a_b dvd b \\<and>\n          (\\<forall>d'.\n              d' dvd a \\<and> d' dvd b \\<longrightarrow>\n              d' dvd gcd_a_b) \\<and>\n          gcd_a_b * u = - b \\<and> gcd_a_b * v = a", "using is_bezout_ext_def [of bezout]"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n  is_bezout_ext bezout =\n  (\\<forall>a b.\n      let (p, q, u, v, gcd_a_b) = bezout a b\n      in p * a + q * b = gcd_a_b \\<and>\n         gcd_a_b dvd a \\<and>\n         gcd_a_b dvd b \\<and>\n         (\\<forall>d'.\n             d' dvd a \\<and> d' dvd b \\<longrightarrow>\n             d' dvd gcd_a_b) \\<and>\n         gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       let (p, q, u, v, gcd_a_b) = bezout a b\n       in p * a + q * b = gcd_a_b \\<and>\n          gcd_a_b dvd a \\<and>\n          gcd_a_b dvd b \\<and>\n          (\\<forall>d'.\n              d' dvd a \\<and> d' dvd b \\<longrightarrow>\n              d' dvd gcd_a_b) \\<and>\n          gcd_a_b * u = - b \\<and> gcd_a_b * v = a", "by simp"], ["proof (state)\nthis:\n  let (p, q, u, v, gcd_a_b) = bezout ?a ?b\n  in p * ?a + q * ?b = gcd_a_b \\<and>\n     gcd_a_b dvd ?a \\<and>\n     gcd_a_b dvd ?b \\<and>\n     (\\<forall>d'.\n         d' dvd ?a \\<and> d' dvd ?b \\<longrightarrow> d' dvd gcd_a_b) \\<and>\n     gcd_a_b * u = - ?b \\<and> gcd_a_b * v = ?a\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "obtain p q u v d where bz: \"(p, q, u, v, d) = ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q u v d.\n        (p, q, u, v, d) = bezout (A $ i $ k) (A $ j $ k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?z, auto)"], ["proof (state)\nthis:\n  (p, q, u, v, d) = bezout (A $ i $ k) (A $ j $ k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have Aib: \"A $ i $ b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ b = (0::'a)", "by (metis b_k i is_zero_row_upt_k_def to_nat_mono)"], ["proof (state)\nthis:\n  A $ i $ b = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have Ajb: \"A $ j $ b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ b = (0::'a)", "by (metis b_k j is_zero_row_upt_k_def to_nat_mono)"], ["proof (state)\nthis:\n  A $ j $ b = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "define f where \"f ka = (if a = i \\<and> ka = i then p\n                  else if a = i \\<and> ka = j then q\n                  else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v else if a = ka then 1 else 0) * A $ ka $ b\" for ka"], ["proof (state)\nthis:\n  f ?ka =\n  (if a = i \\<and> ?ka = i then p\n   else if a = i \\<and> ?ka = j then q\n        else if a = j \\<and> ?ka = i then u\n             else if a = j \\<and> ?ka = j then v\n                  else if a = ?ka then 1::'a else (0::'a)) *\n  A $ ?ka $ b\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "show \"(\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u else if a = j \\<and> ka = j then v else if a = ka then 1 else 0) *\n       A $ ka $ b) =\n    A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "proof (cases \"a=i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "case True"], ["proof (state)\nthis:\n  a = i\n\ngoal (2 subgoals):\n 1. a = i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"(\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u else if a = j \\<and> ka = j then v else if a = ka then 1 else 0) *\n       A $ ka $ b) = sum f UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    sum f UNIV", "unfolding f_def bz [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case (p, q, u, v, d) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    (\\<Sum>ka\\<in>UNIV.\n       (if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  sum f UNIV\n\ngoal (2 subgoals):\n 1. a = i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  sum f UNIV\n\ngoal (2 subgoals):\n 1. a = i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"sum f UNIV = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f UNIV = (0::'a)", "by (rule sum.neutral, auto simp add: Aib Ajb f_def True i_not_j)"], ["proof (state)\nthis:\n  sum f UNIV = (0::'a)\n\ngoal (2 subgoals):\n 1. a = i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  sum f UNIV = (0::'a)\n\ngoal (2 subgoals):\n 1. a = i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"... = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) = A $ a $ b", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) = A $ i $ b", "using Aib"], ["proof (prove)\nusing this:\n  A $ i $ b = (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) = A $ i $ b", "by simp"], ["proof (state)\nthis:\n  (0::'a) = A $ a $ b\n\ngoal (2 subgoals):\n 1. a = i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  A $ a $ b", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "."], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. a \\<noteq> i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "case False"], ["proof (state)\nthis:\n  a \\<noteq> i\n\ngoal (1 subgoal):\n 1. a \\<noteq> i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "note a_not_i=False"], ["proof (state)\nthis:\n  a \\<noteq> i\n\ngoal (1 subgoal):\n 1. a \\<noteq> i \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "proof (cases \"a=j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "case True"], ["proof (state)\nthis:\n  a = j\n\ngoal (2 subgoals):\n 1. a = j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"(\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u else if a = j \\<and> ka = j then v else if a = ka then 1 else 0) *\n       A $ ka $ b) = sum f UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    sum f UNIV", "unfolding f_def bz [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case (p, q, u, v, d) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    (\\<Sum>ka\\<in>UNIV.\n       (if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  sum f UNIV\n\ngoal (2 subgoals):\n 1. a = j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  sum f UNIV\n\ngoal (2 subgoals):\n 1. a = j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"sum f UNIV = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f UNIV = (0::'a)", "by (rule sum.neutral, auto simp add: Aib Ajb f_def True i_not_j)"], ["proof (state)\nthis:\n  sum f UNIV = (0::'a)\n\ngoal (2 subgoals):\n 1. a = j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  sum f UNIV = (0::'a)\n\ngoal (2 subgoals):\n 1. a = j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"... = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) = A $ a $ b", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) = A $ j $ b", "using Ajb"], ["proof (prove)\nusing this:\n  A $ j $ b = (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) = A $ j $ b", "by simp"], ["proof (state)\nthis:\n  (0::'a) = A $ a $ b\n\ngoal (2 subgoals):\n 1. a = j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b\n 2. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  A $ a $ b", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "."], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "case False"], ["proof (state)\nthis:\n  a \\<noteq> j\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have UNIV_rw: \"UNIV = insert j (insert i (UNIV - {i} - {j}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = insert j (insert i (UNIV - {i} - {j}))", "by auto"], ["proof (state)\nthis:\n  UNIV = insert j (insert i (UNIV - {i} - {j}))\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have UNIV_rw2: \"UNIV - {i} - {j} = insert a (UNIV - {i} - {j}-{a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV - {i} - {j} = insert a (UNIV - {i} - {j} - {a})", "using False a_not_i"], ["proof (prove)\nusing this:\n  a \\<noteq> j\n  a \\<noteq> i\n\ngoal (1 subgoal):\n 1. UNIV - {i} - {j} = insert a (UNIV - {i} - {j} - {a})", "by auto"], ["proof (state)\nthis:\n  UNIV - {i} - {j} = insert a (UNIV - {i} - {j} - {a})\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have sum0: \"sum f (UNIV - {i} - {j} - {a}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (UNIV - {i} - {j} - {a}) = (0::'a)", "by (rule sum.neutral, simp add: f_def)"], ["proof (state)\nthis:\n  sum f (UNIV - {i} - {j} - {a}) = (0::'a)\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"(\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u else if a = j \\<and> ka = j then v else if a = ka then 1 else 0) *\n       A $ ka $ b) = sum f UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    sum f UNIV", "unfolding f_def bz [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case (p, q, u, v, d) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    (\\<Sum>ka\\<in>UNIV.\n       (if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  sum f UNIV\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  sum f UNIV\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"sum f UNIV = sum f (insert j (insert i (UNIV - {i} - {j})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f UNIV = sum f (insert j (insert i (UNIV - {i} - {j})))", "using UNIV_rw"], ["proof (prove)\nusing this:\n  UNIV = insert j (insert i (UNIV - {i} - {j}))\n\ngoal (1 subgoal):\n 1. sum f UNIV = sum f (insert j (insert i (UNIV - {i} - {j})))", "by simp"], ["proof (state)\nthis:\n  sum f UNIV = sum f (insert j (insert i (UNIV - {i} - {j})))\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  sum f UNIV = sum f (insert j (insert i (UNIV - {i} - {j})))\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"... = f j + sum f (insert i (UNIV - {i} - {j}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert j (insert i (UNIV - {i} - {j}))) =\n    f j + sum f (insert i (UNIV - {i} - {j}))", "by (rule sum.insert, auto, metis i_not_j)"], ["proof (state)\nthis:\n  sum f (insert j (insert i (UNIV - {i} - {j}))) =\n  f j + sum f (insert i (UNIV - {i} - {j}))\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  sum f (insert j (insert i (UNIV - {i} - {j}))) =\n  f j + sum f (insert i (UNIV - {i} - {j}))\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"... = sum f (insert i (UNIV - {i} - {j}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f j + sum f (insert i (UNIV - {i} - {j})) =\n    sum f (insert i (UNIV - {i} - {j}))", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = i \\<and> j = i then p\n     else if a = i \\<and> j = j then q\n          else if a = j \\<and> j = i then u\n               else if a = j \\<and> j = j then v\n                    else if a = j then 1::'a else (0::'a)) *\n    A $ j $ b +\n    (\\<Sum>ka\\<in>insert i (UNIV - {i} - {j}).\n       (if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    (\\<Sum>ka\\<in>insert i (UNIV - {i} - {j}).\n       (if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b)", "using False a_not_i"], ["proof (prove)\nusing this:\n  a \\<noteq> j\n  a \\<noteq> i\n\ngoal (1 subgoal):\n 1. (if a = i \\<and> j = i then p\n     else if a = i \\<and> j = j then q\n          else if a = j \\<and> j = i then u\n               else if a = j \\<and> j = j then v\n                    else if a = j then 1::'a else (0::'a)) *\n    A $ j $ b +\n    (\\<Sum>ka\\<in>insert i (UNIV - {i} - {j}).\n       (if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    (\\<Sum>ka\\<in>insert i (UNIV - {i} - {j}).\n       (if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b)", "by auto"], ["proof (state)\nthis:\n  f j + sum f (insert i (UNIV - {i} - {j})) =\n  sum f (insert i (UNIV - {i} - {j}))\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  f j + sum f (insert i (UNIV - {i} - {j})) =\n  sum f (insert i (UNIV - {i} - {j}))\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"... = f i + sum f (UNIV - {i} - {j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert i (UNIV - {i} - {j})) = f i + sum f (UNIV - {i} - {j})", "by (rule sum.insert, auto)"], ["proof (state)\nthis:\n  sum f (insert i (UNIV - {i} - {j})) = f i + sum f (UNIV - {i} - {j})\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  sum f (insert i (UNIV - {i} - {j})) = f i + sum f (UNIV - {i} - {j})\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"... = sum f (UNIV - {i} - {j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i + sum f (UNIV - {i} - {j}) = sum f (UNIV - {i} - {j})", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = i \\<and> i = i then p\n     else if a = i \\<and> i = j then q\n          else if a = j \\<and> i = i then u\n               else if a = j \\<and> i = j then v\n                    else if a = i then 1::'a else (0::'a)) *\n    A $ i $ b +\n    (\\<Sum>ka\\<in>UNIV - {i} - {j}.\n       (if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    (\\<Sum>ka\\<in>UNIV - {i} - {j}.\n       (if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b)", "using False a_not_i"], ["proof (prove)\nusing this:\n  a \\<noteq> j\n  a \\<noteq> i\n\ngoal (1 subgoal):\n 1. (if a = i \\<and> i = i then p\n     else if a = i \\<and> i = j then q\n          else if a = j \\<and> i = i then u\n               else if a = j \\<and> i = j then v\n                    else if a = i then 1::'a else (0::'a)) *\n    A $ i $ b +\n    (\\<Sum>ka\\<in>UNIV - {i} - {j}.\n       (if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    (\\<Sum>ka\\<in>UNIV - {i} - {j}.\n       (if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b)", "by auto"], ["proof (state)\nthis:\n  f i + sum f (UNIV - {i} - {j}) = sum f (UNIV - {i} - {j})\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  f i + sum f (UNIV - {i} - {j}) = sum f (UNIV - {i} - {j})\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"... = sum f (insert a (UNIV - {i} - {j} - {a}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (UNIV - {i} - {j}) = sum f (insert a (UNIV - {i} - {j} - {a}))", "using UNIV_rw2"], ["proof (prove)\nusing this:\n  UNIV - {i} - {j} = insert a (UNIV - {i} - {j} - {a})\n\ngoal (1 subgoal):\n 1. sum f (UNIV - {i} - {j}) = sum f (insert a (UNIV - {i} - {j} - {a}))", "by simp"], ["proof (state)\nthis:\n  sum f (UNIV - {i} - {j}) = sum f (insert a (UNIV - {i} - {j} - {a}))\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  sum f (UNIV - {i} - {j}) = sum f (insert a (UNIV - {i} - {j} - {a}))\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"... = f a + sum f (UNIV - {i} - {j} - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert a (UNIV - {i} - {j} - {a})) =\n    f a + sum f (UNIV - {i} - {j} - {a})", "by (rule sum.insert, auto)"], ["proof (state)\nthis:\n  sum f (insert a (UNIV - {i} - {j} - {a})) =\n  f a + sum f (UNIV - {i} - {j} - {a})\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  sum f (insert a (UNIV - {i} - {j} - {a})) =\n  f a + sum f (UNIV - {i} - {j} - {a})\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"... = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a + sum f (UNIV - {i} - {j} - {a}) = f a", "unfolding sum0"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a + (0::'a) = f a", "by simp"], ["proof (state)\nthis:\n  f a + sum f (UNIV - {i} - {j} - {a}) = f a\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  f a + sum f (UNIV - {i} - {j} - {a}) = f a\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "have \"... = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a = A $ a $ b", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = i \\<and> a = i then p\n     else if a = i \\<and> a = j then q\n          else if a = j \\<and> a = i then u\n               else if a = j \\<and> a = j then v\n                    else if a = a then 1::'a else (0::'a)) *\n    A $ a $ b =\n    A $ a $ b", "using False a_not_i"], ["proof (prove)\nusing this:\n  a \\<noteq> j\n  a \\<noteq> i\n\ngoal (1 subgoal):\n 1. (if a = i \\<and> a = i then p\n     else if a = i \\<and> a = j then q\n          else if a = j \\<and> a = i then u\n               else if a = j \\<and> a = j then v\n                    else if a = a then 1::'a else (0::'a)) *\n    A $ a $ b =\n    A $ a $ b", "by auto"], ["proof (state)\nthis:\n  f a = A $ a $ b\n\ngoal (1 subgoal):\n 1. a \\<noteq> j \\<Longrightarrow>\n    (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  A $ a $ b", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV.\n       (case bezout (A $ i $ k) (A $ j $ k) of\n        (p, q, u, v, d) \\<Rightarrow>\n          if a = i \\<and> ka = i then p\n          else if a = i \\<and> ka = j then q\n               else if a = j \\<and> ka = i then u\n                    else if a = j \\<and> ka = j then v\n                         else if a = ka then 1::'a else (0::'a)) *\n       A $ ka $ b) =\n    A $ a $ b", "."], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV.\n     (case bezout (A $ i $ k) (A $ j $ k) of\n      (p, q, u, v, d) \\<Rightarrow>\n        if a = i \\<and> ka = i then p\n        else if a = i \\<and> ka = j then q\n             else if a = j \\<and> ka = i then u\n                  else if a = j \\<and> ka = j then v\n                       else if a = ka then 1::'a else (0::'a)) *\n     A $ ka $ b) =\n  A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_bezout_matrix:\n  fixes A::\"'a::{bezout_domain}^'cols^'rows::{finite,wellorder}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_less_b: \"a < b\"\n  and aj: \"A $ a $ j \\<noteq> 0\"\n  shows \"det (bezout_matrix A a b j bezout) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "let ?B = \"bezout_matrix A a b j bezout\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "let ?a = \"(A $ a $ j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "let ?b = \"(A $ b $ j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "let ?z = \"bezout ?a ?b\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "from ib"], ["proof (chain)\npicking this:\n  is_bezout_ext bezout", "have foo: \"(\\<And>a b. let (p, q, u, v, gcd_a_b) = bezout a b\n           in p * a + q * b = gcd_a_b \\<and>\n              gcd_a_b dvd a \\<and>\n              gcd_a_b dvd b \\<and> (\\<forall>d'. d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd gcd_a_b) \\<and> gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\""], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       let (p, q, u, v, gcd_a_b) = bezout a b\n       in p * a + q * b = gcd_a_b \\<and>\n          gcd_a_b dvd a \\<and>\n          gcd_a_b dvd b \\<and>\n          (\\<forall>d'.\n              d' dvd a \\<and> d' dvd b \\<longrightarrow>\n              d' dvd gcd_a_b) \\<and>\n          gcd_a_b * u = - b \\<and> gcd_a_b * v = a", "using is_bezout_ext_def [of bezout]"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n  is_bezout_ext bezout =\n  (\\<forall>a b.\n      let (p, q, u, v, gcd_a_b) = bezout a b\n      in p * a + q * b = gcd_a_b \\<and>\n         gcd_a_b dvd a \\<and>\n         gcd_a_b dvd b \\<and>\n         (\\<forall>d'.\n             d' dvd a \\<and> d' dvd b \\<longrightarrow>\n             d' dvd gcd_a_b) \\<and>\n         gcd_a_b * u = - b \\<and> gcd_a_b * v = a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       let (p, q, u, v, gcd_a_b) = bezout a b\n       in p * a + q * b = gcd_a_b \\<and>\n          gcd_a_b dvd a \\<and>\n          gcd_a_b dvd b \\<and>\n          (\\<forall>d'.\n              d' dvd a \\<and> d' dvd b \\<longrightarrow>\n              d' dvd gcd_a_b) \\<and>\n          gcd_a_b * u = - b \\<and> gcd_a_b * v = a", "by simp"], ["proof (state)\nthis:\n  let (p, q, u, v, gcd_a_b) = bezout ?a ?b\n  in p * ?a + q * ?b = gcd_a_b \\<and>\n     gcd_a_b dvd ?a \\<and>\n     gcd_a_b dvd ?b \\<and>\n     (\\<forall>d'.\n         d' dvd ?a \\<and> d' dvd ?b \\<longrightarrow> d' dvd gcd_a_b) \\<and>\n     gcd_a_b * u = - ?b \\<and> gcd_a_b * v = ?a\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "obtain p q u v d where bz: \"(p, q, u, v, d) = ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q u v d.\n        (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?z, auto)"], ["proof (state)\nthis:\n  (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "hence pib: \"p * ?a + q * ?b = d \\<and> d dvd ?a \\<and>\n            d dvd ?b \\<and> (\\<forall>d'. d' dvd ?a \\<and> d' dvd ?b \\<longrightarrow> d' dvd d) \\<and> d * u = - ?b \\<and> d * v = ?a\""], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + q * A $ b $ j = d \\<and>\n    d dvd A $ a $ j \\<and>\n    d dvd A $ b $ j \\<and>\n    (\\<forall>d'.\n        d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n        d' dvd d) \\<and>\n    d * u = - A $ b $ j \\<and> d * v = A $ a $ j", "using foo [of ?a ?b]"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n  let (p, q, u, v, gcd_a_b) = bezout (A $ a $ j) (A $ b $ j)\n  in p * A $ a $ j + q * A $ b $ j = gcd_a_b \\<and>\n     gcd_a_b dvd A $ a $ j \\<and>\n     gcd_a_b dvd A $ b $ j \\<and>\n     (\\<forall>d'.\n         d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n         d' dvd gcd_a_b) \\<and>\n     gcd_a_b * u = - A $ b $ j \\<and> gcd_a_b * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + q * A $ b $ j = d \\<and>\n    d dvd A $ a $ j \\<and>\n    d dvd A $ b $ j \\<and>\n    (\\<forall>d'.\n        d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n        d' dvd d) \\<and>\n    d * u = - A $ b $ j \\<and> d * v = A $ a $ j", "by fastforce"], ["proof (state)\nthis:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "hence pa_bq_d: \"p * ?a + ?b * q = d\""], ["proof (prove)\nusing this:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. p * A $ a $ j + A $ b $ j * q = d", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  p * A $ a $ j + A $ b $ j * q = d\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "have a_not_b: \"a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b", "using a_less_b"], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "have d_dvd_a: \"d dvd ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd A $ a $ j", "using pib"], ["proof (prove)\nusing this:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. d dvd A $ a $ j", "by auto"], ["proof (state)\nthis:\n  d dvd A $ a $ j\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "have UNIV_rw: \"UNIV = insert b (insert a (UNIV - {a} - {b}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = insert b (insert a (UNIV - {a} - {b}))", "by auto"], ["proof (state)\nthis:\n  UNIV = insert b (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "case True"], ["proof (state)\nthis:\n  p = (0::'a)\n\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "note p0=True"], ["proof (state)\nthis:\n  p = (0::'a)\n\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "have q_not_0: \"q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> (0::'a)", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. q = (0::'a) \\<Longrightarrow> False", "assume q: \"q = 0\""], ["proof (state)\nthis:\n  q = (0::'a)\n\ngoal (1 subgoal):\n 1. q = (0::'a) \\<Longrightarrow> False", "have \"d = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d = (0::'a)", "using pib"], ["proof (prove)\nusing this:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. d = (0::'a)", "by (metis True q add.right_neutral mult.commute mult_zero_right)"], ["proof (state)\nthis:\n  d = (0::'a)\n\ngoal (1 subgoal):\n 1. q = (0::'a) \\<Longrightarrow> False", "hence \"A $ a $ j = 0 \\<and> A $ b $ j = 0\""], ["proof (prove)\nusing this:\n  d = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ a $ j = (0::'a) \\<and> A $ b $ j = (0::'a)", "by (metis aj d_dvd_a dvd_0_left_iff)"], ["proof (state)\nthis:\n  A $ a $ j = (0::'a) \\<and> A $ b $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. q = (0::'a) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  A $ a $ j = (0::'a) \\<and> A $ b $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using aj"], ["proof (prove)\nusing this:\n  A $ a $ j = (0::'a) \\<and> A $ b $ j = (0::'a)\n  A $ a $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "have d_not_0: \"d \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<noteq> (0::'a)", "by (metis aj d_dvd_a dvd_0_left_iff)"], ["proof (state)\nthis:\n  d \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "have qb_not_0: \"q *(-?b) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q * - A $ b $ j \\<noteq> (0::'a)", "by (metis d_not_0 mult_cancel_left1 neg_equal_0_iff_equal \n          no_zero_divisors p0 pa_bq_d q_not_0 right_minus)"], ["proof (state)\nthis:\n  q * - A $ b $ j \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "have \"det (interchange_rows ?B a b) = (\\<Prod>i\\<in>UNIV. (interchange_rows ?B a b) $ i $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (interchange_rows (bezout_matrix A a b j bezout) a b) =\n    (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i)", "proof (rule det_upperdiagonal)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ja.\n       ja < i \\<Longrightarrow>\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ ja =\n       (0::'a)", "fix i ja::'rows"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ja.\n       ja < i \\<Longrightarrow>\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ ja =\n       (0::'a)", "assume ja_i: \"ja<i\""], ["proof (state)\nthis:\n  ja < i\n\ngoal (1 subgoal):\n 1. \\<And>i ja.\n       ja < i \\<Longrightarrow>\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ ja =\n       (0::'a)", "show \"interchange_rows (bezout_matrix A a b j bezout) a b $ i $ ja = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows (bezout_matrix A a b j bezout) a b $ i $ ja = (0::'a)", "unfolding interchange_rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = a then bezout_matrix A a b j bezout $ b $ ja\n        else if i = b then bezout_matrix A a b j bezout $ a $ ja\n             else bezout_matrix A a b j bezout $ i $ ja) $\n    i $\n    ja =\n    (0::'a)", "using a_less_b ja_i p0 a_not_b"], ["proof (prove)\nusing this:\n  a < b\n  ja < i\n  p = (0::'a)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = a then bezout_matrix A a b j bezout $ b $ ja\n        else if i = b then bezout_matrix A a b j bezout $ a $ ja\n             else bezout_matrix A a b j bezout $ i $ ja) $\n    i $\n    ja =\n    (0::'a)", "using bz [symmetric]"], ["proof (prove)\nusing this:\n  a < b\n  ja < i\n  p = (0::'a)\n  a \\<noteq> b\n  bezout (A $ a $ j) (A $ b $ j) = (p, q, u, v, d)\n\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = a then bezout_matrix A a b j bezout $ b $ ja\n        else if i = b then bezout_matrix A a b j bezout $ a $ ja\n             else bezout_matrix A a b j bezout $ i $ ja) $\n    i $\n    ja =\n    (0::'a)", "unfolding bezout_matrix_def Let_def"], ["proof (prove)\nusing this:\n  a < b\n  ja < i\n  p = (0::'a)\n  a \\<noteq> b\n  bezout (A $ a $ j) (A $ b $ j) = (p, q, u, v, d)\n\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = a\n        then (\\<chi>x y.\n                 case bezout (A $ a $ j) (A $ b $ j) of\n                 (p, q, u, v, d) \\<Rightarrow>\n                   if x = a \\<and> y = a then p\n                   else if x = a \\<and> y = b then q\n                        else if x = b \\<and> y = a then u\n                             else if x = b \\<and> y = b then v\n                                  else if x = y then 1::'a else (0::'a)) $\n             b $\n             ja\n        else if i = b\n             then (\\<chi>x y.\n                      case bezout (A $ a $ j) (A $ b $ j) of\n                      (p, q, u, v, d) \\<Rightarrow>\n                        if x = a \\<and> y = a then p\n                        else if x = a \\<and> y = b then q\n                             else if x = b \\<and> y = a then u\n                                  else if x = b \\<and> y = b then v\n else if x = y then 1::'a else (0::'a)) $\n                  a $\n                  ja\n             else (\\<chi>x y.\n                      case bezout (A $ a $ j) (A $ b $ j) of\n                      (p, q, u, v, d) \\<Rightarrow>\n                        if x = a \\<and> y = a then p\n                        else if x = a \\<and> y = b then q\n                             else if x = b \\<and> y = a then u\n                                  else if x = b \\<and> y = b then v\n else if x = y then 1::'a else (0::'a)) $\n                  i $\n                  ja) $\n    i $\n    ja =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  interchange_rows (bezout_matrix A a b j bezout) a b $ i $ ja = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (interchange_rows (bezout_matrix A a b j bezout) a b) =\n  (\\<Prod>i\\<in>UNIV.\n     interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i)\n\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "also"], ["proof (state)\nthis:\n  det (interchange_rows (bezout_matrix A a b j bezout) a b) =\n  (\\<Prod>i\\<in>UNIV.\n     interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i)\n\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "have \"\\<dots> = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "define f where \"f i = interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i\" for i"], ["proof (state)\nthis:\n  f ?i = interchange_rows (bezout_matrix A a b j bezout) a b $ ?i $ ?i\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "have prod_rw: \"prod f (insert a (UNIV - {a} - {b})) \n        =  f a * prod f (UNIV - {a} - {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f (insert a (UNIV - {a} - {b})) = f a * prod f (UNIV - {a} - {b})", "by (rule prod.insert, simp_all)"], ["proof (state)\nthis:\n  prod f (insert a (UNIV - {a} - {b})) = f a * prod f (UNIV - {a} - {b})\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "have prod1: \"prod f (UNIV - {a} - {b}) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f (UNIV - {a} - {b}) = (1::'a)", "by (rule prod.neutral) \n            (simp add: f_def interchange_rows_def bezout_matrix_def Let_def)"], ["proof (state)\nthis:\n  prod f (UNIV - {a} - {b}) = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "have \"prod f UNIV = prod f (insert b (insert a (UNIV - {a} - {b})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f UNIV = prod f (insert b (insert a (UNIV - {a} - {b})))", "using UNIV_rw"], ["proof (prove)\nusing this:\n  UNIV = insert b (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. prod f UNIV = prod f (insert b (insert a (UNIV - {a} - {b})))", "by simp"], ["proof (state)\nthis:\n  prod f UNIV = prod f (insert b (insert a (UNIV - {a} - {b})))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "also"], ["proof (state)\nthis:\n  prod f UNIV = prod f (insert b (insert a (UNIV - {a} - {b})))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "have \"... = f b * prod f (insert a (UNIV - {a} - {b}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f (insert b (insert a (UNIV - {a} - {b}))) =\n    f b * prod f (insert a (UNIV - {a} - {b}))", "proof (rule prod.insert, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> insert a (UNIV - {a} - {b})", "show \"b \\<notin> insert a (UNIV - {a} - {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> insert a (UNIV - {a} - {b})", "using a_not_b"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. b \\<notin> insert a (UNIV - {a} - {b})", "by auto"], ["proof (state)\nthis:\n  b \\<notin> insert a (UNIV - {a} - {b})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod f (insert b (insert a (UNIV - {a} - {b}))) =\n  f b * prod f (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "also"], ["proof (state)\nthis:\n  prod f (insert b (insert a (UNIV - {a} - {b}))) =\n  f b * prod f (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "have \"... = f b * f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f b * prod f (insert a (UNIV - {a} - {b})) = f b * f a", "unfolding prod_rw prod1"], ["proof (prove)\ngoal (1 subgoal):\n 1. f b * (f a * (1::'a)) = f b * f a", "by auto"], ["proof (state)\nthis:\n  f b * prod f (insert a (UNIV - {a} - {b})) = f b * f a\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "also"], ["proof (state)\nthis:\n  f b * prod f (insert a (UNIV - {a} - {b})) = f b * f a\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "have \"... = q * u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f b * f a = q * u", "using a_not_b"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. f b * f a = q * u", "using bz [symmetric]"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  bezout (A $ a $ j) (A $ b $ j) = (p, q, u, v, d)\n\ngoal (1 subgoal):\n 1. f b * f a = q * u", "unfolding f_def interchange_rows_def bezout_matrix_def Let_def"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  bezout (A $ a $ j) (A $ b $ j) = (p, q, u, v, d)\n\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = a\n        then (\\<chi>x y.\n                 case bezout (A $ a $ j) (A $ b $ j) of\n                 (p, q, u, v, d) \\<Rightarrow>\n                   if x = a \\<and> y = a then p\n                   else if x = a \\<and> y = b then q\n                        else if x = b \\<and> y = a then u\n                             else if x = b \\<and> y = b then v\n                                  else if x = y then 1::'a else (0::'a)) $\n             b $\n             ja\n        else if i = b\n             then (\\<chi>x y.\n                      case bezout (A $ a $ j) (A $ b $ j) of\n                      (p, q, u, v, d) \\<Rightarrow>\n                        if x = a \\<and> y = a then p\n                        else if x = a \\<and> y = b then q\n                             else if x = b \\<and> y = a then u\n                                  else if x = b \\<and> y = b then v\n else if x = y then 1::'a else (0::'a)) $\n                  a $\n                  ja\n             else (\\<chi>x y.\n                      case bezout (A $ a $ j) (A $ b $ j) of\n                      (p, q, u, v, d) \\<Rightarrow>\n                        if x = a \\<and> y = a then p\n                        else if x = a \\<and> y = b then q\n                             else if x = b \\<and> y = a then u\n                                  else if x = b \\<and> y = b then v\n else if x = y then 1::'a else (0::'a)) $\n                  i $\n                  ja) $\n    b $\n    b *\n    (\\<chi>i ja.\n        if i = a\n        then (\\<chi>x y.\n                 case bezout (A $ a $ j) (A $ b $ j) of\n                 (p, q, u, v, d) \\<Rightarrow>\n                   if x = a \\<and> y = a then p\n                   else if x = a \\<and> y = b then q\n                        else if x = b \\<and> y = a then u\n                             else if x = b \\<and> y = b then v\n                                  else if x = y then 1::'a else (0::'a)) $\n             b $\n             ja\n        else if i = b\n             then (\\<chi>x y.\n                      case bezout (A $ a $ j) (A $ b $ j) of\n                      (p, q, u, v, d) \\<Rightarrow>\n                        if x = a \\<and> y = a then p\n                        else if x = a \\<and> y = b then q\n                             else if x = b \\<and> y = a then u\n                                  else if x = b \\<and> y = b then v\n else if x = y then 1::'a else (0::'a)) $\n                  a $\n                  ja\n             else (\\<chi>x y.\n                      case bezout (A $ a $ j) (A $ b $ j) of\n                      (p, q, u, v, d) \\<Rightarrow>\n                        if x = a \\<and> y = a then p\n                        else if x = a \\<and> y = b then q\n                             else if x = b \\<and> y = a then u\n                                  else if x = b \\<and> y = b then v\n else if x = y then 1::'a else (0::'a)) $\n                  i $\n                  ja) $\n    a $\n    a =\n    q * u", "by auto"], ["proof (state)\nthis:\n  f b * f a = q * u\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "also"], ["proof (state)\nthis:\n  f b * f a = q * u\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "have \"... = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "let ?r = \"q * u\""], ["proof (state)\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "have du_b: \" d * u = -?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * u = - A $ b $ j", "using pib"], ["proof (prove)\nusing this:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. d * u = - A $ b $ j", "by auto"], ["proof (state)\nthis:\n  d * u = - A $ b $ j\n\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "hence \"q * (-?b) = d * ?r\""], ["proof (prove)\nusing this:\n  d * u = - A $ b $ j\n\ngoal (1 subgoal):\n 1. q * - A $ b $ j = d * (q * u)", "by (metis mult.left_commute)"], ["proof (state)\nthis:\n  q * - A $ b $ j = d * (q * u)\n\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "also"], ["proof (state)\nthis:\n  q * - A $ b $ j = d * (q * u)\n\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "have \"... = (p * ?a + ?b * q) * ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * (q * u) = (p * A $ a $ j + A $ b $ j * q) * (q * u)", "unfolding pa_bq_d"], ["proof (prove)\ngoal (1 subgoal):\n 1. d * (q * u) = d * (q * u)", "by auto"], ["proof (state)\nthis:\n  d * (q * u) = (p * A $ a $ j + A $ b $ j * q) * (q * u)\n\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "also"], ["proof (state)\nthis:\n  d * (q * u) = (p * A $ a $ j + A $ b $ j * q) * (q * u)\n\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "have \"... = ?b * q * ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p * A $ a $ j + A $ b $ j * q) * (q * u) = A $ b $ j * q * (q * u)", "using True"], ["proof (prove)\nusing this:\n  p = (0::'a)\n\ngoal (1 subgoal):\n 1. (p * A $ a $ j + A $ b $ j * q) * (q * u) = A $ b $ j * q * (q * u)", "by auto"], ["proof (state)\nthis:\n  (p * A $ a $ j + A $ b $ j * q) * (q * u) = A $ b $ j * q * (q * u)\n\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "also"], ["proof (state)\nthis:\n  (p * A $ a $ j + A $ b $ j * q) * (q * u) = A $ b $ j * q * (q * u)\n\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "have \"... = q * (-?b) * (-?r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ b $ j * q * (q * u) = q * - A $ b $ j * - (q * u)", "by auto"], ["proof (state)\nthis:\n  A $ b $ j * q * (q * u) = q * - A $ b $ j * - (q * u)\n\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "finally"], ["proof (chain)\npicking this:\n  q * - A $ b $ j = q * - A $ b $ j * - (q * u)", "show ?thesis"], ["proof (prove)\nusing this:\n  q * - A $ b $ j = q * - A $ b $ j * - (q * u)\n\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "using qb_not_0"], ["proof (prove)\nusing this:\n  q * - A $ b $ j = q * - A $ b $ j * - (q * u)\n  q * - A $ b $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "unfolding mult_cancel_left1"], ["proof (prove)\nusing this:\n  q * - A $ b $ j = (0::'a) \\<or> - (q * u) = (1::'a)\n  q * - A $ b $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. q * u = - (1::'a)", "by (metis minus_minus)"], ["proof (state)\nthis:\n  q * u = - (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q * u = - (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "finally"], ["proof (chain)\npicking this:\n  prod f UNIV = - (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  prod f UNIV = - (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "unfolding f_def"], ["proof (prove)\nusing this:\n  (\\<Prod>i\\<in>UNIV.\n     interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n  - (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n    - (1::'a)", "."], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>UNIV.\n     interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n  - (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>UNIV.\n     interchange_rows (bezout_matrix A a b j bezout) a b $ i $ i) =\n  - (1::'a)\n\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "finally"], ["proof (chain)\npicking this:\n  det (interchange_rows (bezout_matrix A a b j bezout) a b) = - (1::'a)", "have det_inter_1: \"det (interchange_rows ?B a b) = - 1\""], ["proof (prove)\nusing this:\n  det (interchange_rows (bezout_matrix A a b j bezout) a b) = - (1::'a)\n\ngoal (1 subgoal):\n 1. det (interchange_rows (bezout_matrix A a b j bezout) a b) = - (1::'a)", "."], ["proof (state)\nthis:\n  det (interchange_rows (bezout_matrix A a b j bezout) a b) = - (1::'a)\n\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "have \"det (bezout_matrix A a b j bezout) = - 1 * det (interchange_rows ?B a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) =\n    - (1::'a) * det (interchange_rows (bezout_matrix A a b j bezout) a b)", "unfolding det_interchange_rows"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) =\n    - (1::'a) *\n    (of_int (if a = b then 1 else - 1) * det (bezout_matrix A a b j bezout))", "using a_not_b"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) =\n    - (1::'a) *\n    (of_int (if a = b then 1 else - 1) * det (bezout_matrix A a b j bezout))", "by auto"], ["proof (state)\nthis:\n  det (bezout_matrix A a b j bezout) =\n  - (1::'a) * det (interchange_rows (bezout_matrix A a b j bezout) a b)\n\ngoal (2 subgoals):\n 1. p = (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)\n 2. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  det (bezout_matrix A a b j bezout) =\n  - (1::'a) * det (interchange_rows (bezout_matrix A a b j bezout) a b)\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "unfolding det_inter_1"], ["proof (prove)\nusing this:\n  det (bezout_matrix A a b j bezout) = - (1::'a) * - (1::'a)\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "by simp"], ["proof (state)\nthis:\n  det (bezout_matrix A a b j bezout) = (1::'a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "define mult_b_dp where \"mult_b_dp = mult_row ?B b (d * p)\""], ["proof (state)\nthis:\n  mult_b_dp = mult_row (bezout_matrix A a b j bezout) b (d * p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "define sum_ab where \"sum_ab = row_add mult_b_dp b a ?b\""], ["proof (state)\nthis:\n  sum_ab = row_add mult_b_dp b a (A $ b $ j)\n\ngoal (1 subgoal):\n 1. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "have \"det (sum_ab) = prod (\\<lambda>i. sum_ab $ i $ i) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det sum_ab = (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i)", "proof (rule det_upperdiagonal)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j. j < i \\<Longrightarrow> sum_ab $ i $ j = (0::'a)", "fix i j::'rows"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j. j < i \\<Longrightarrow> sum_ab $ i $ j = (0::'a)", "assume j_less_i: \"j < i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>i j. j < i \\<Longrightarrow> sum_ab $ i $ j = (0::'a)", "have \"d * p * u + ?b * p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * p * u + A $ b $ j * p = (0::'a)", "using pib"], ["proof (prove)\nusing this:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n\ngoal (1 subgoal):\n 1. d * p * u + A $ b $ j * p = (0::'a)", "by (metis eq_neg_iff_add_eq_0 mult_minus_left semiring_normalization_rules(16))"], ["proof (state)\nthis:\n  d * p * u + A $ b $ j * p = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j. j < i \\<Longrightarrow> sum_ab $ i $ j = (0::'a)", "thus \"sum_ab $ i $ j = 0\""], ["proof (prove)\nusing this:\n  d * p * u + A $ b $ j * p = (0::'a)\n\ngoal (1 subgoal):\n 1. sum_ab $ i $ j = (0::'a)", "unfolding sum_ab_def mult_b_dp_def"], ["proof (prove)\nusing this:\n  d * p * u + A $ b $ j * p = (0::'a)\n\ngoal (1 subgoal):\n 1. row_add (mult_row (bezout_matrix A a b j bezout) b (d * p)) b a\n     (A $ b $ j) $\n    i $\n    j =\n    (0::'a)", "unfolding row_add_def"], ["proof (prove)\nusing this:\n  d * p * u + A $ b $ j * p = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = b\n        then mult_row (bezout_matrix A a b j bezout) b (d * p) $ b $ ja +\n             A $ b $ j *\n             mult_row (bezout_matrix A a b j bezout) b (d * p) $ a $ ja\n        else mult_row (bezout_matrix A a b j bezout) b (d * p) $ i $ ja) $\n    i $\n    j =\n    (0::'a)", "unfolding mult_row_def bezout_matrix_def"], ["proof (prove)\nusing this:\n  d * p * u + A $ b $ j * p = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = b\n        then (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             b $\n             ja +\n             A $ b $ j *\n             (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             a $\n             ja\n        else (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             i $\n             ja) $\n    i $\n    j =\n    (0::'a)", "using a_not_b j_less_i a_less_b"], ["proof (prove)\nusing this:\n  d * p * u + A $ b $ j * p = (0::'a)\n  a \\<noteq> b\n  j < i\n  a < b\n\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = b\n        then (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             b $\n             ja +\n             A $ b $ j *\n             (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             a $\n             ja\n        else (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             i $\n             ja) $\n    i $\n    j =\n    (0::'a)", "unfolding bz [symmetric]"], ["proof (prove)\nusing this:\n  d * p * u + A $ b $ j * p = (0::'a)\n  a \\<noteq> b\n  j < i\n  a < b\n\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = b\n        then (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             b $\n             ja +\n             A $ b $ j *\n             (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             a $\n             ja\n        else (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             i $\n             ja) $\n    i $\n    j =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  sum_ab $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det sum_ab = (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i)\n\ngoal (1 subgoal):\n 1. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "also"], ["proof (state)\nthis:\n  det sum_ab = (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i)\n\ngoal (1 subgoal):\n 1. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "have \"... = d * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "define f where \"f i = sum_ab $ i $ i\" for i"], ["proof (state)\nthis:\n  f ?i = sum_ab $ ?i $ ?i\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "have prod_rw: \"prod f (insert a (UNIV - {a} - {b})) \n        =  f a * prod f (UNIV - {a} - {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f (insert a (UNIV - {a} - {b})) = f a * prod f (UNIV - {a} - {b})", "by (rule prod.insert, simp_all)"], ["proof (state)\nthis:\n  prod f (insert a (UNIV - {a} - {b})) = f a * prod f (UNIV - {a} - {b})\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "have prod1: \"prod f (UNIV - {a} - {b}) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f (UNIV - {a} - {b}) = (1::'a)", "by (rule prod.neutral) (simp add: f_def sum_ab_def row_add_def \n          mult_b_dp_def mult_row_def bezout_matrix_def Let_def)"], ["proof (state)\nthis:\n  prod f (UNIV - {a} - {b}) = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "have ap_bq_d: \"A $ a $ j * p + A $ b $ j * q = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ j * p + A $ b $ j * q = d", "by (metis mult.commute pa_bq_d)"], ["proof (state)\nthis:\n  A $ a $ j * p + A $ b $ j * q = d\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "have \"prod f UNIV = prod f (insert b (insert a (UNIV - {a} - {b})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f UNIV = prod f (insert b (insert a (UNIV - {a} - {b})))", "using UNIV_rw"], ["proof (prove)\nusing this:\n  UNIV = insert b (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. prod f UNIV = prod f (insert b (insert a (UNIV - {a} - {b})))", "by simp"], ["proof (state)\nthis:\n  prod f UNIV = prod f (insert b (insert a (UNIV - {a} - {b})))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "also"], ["proof (state)\nthis:\n  prod f UNIV = prod f (insert b (insert a (UNIV - {a} - {b})))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "have \"... = f b * prod f (insert a (UNIV - {a} - {b}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f (insert b (insert a (UNIV - {a} - {b}))) =\n    f b * prod f (insert a (UNIV - {a} - {b}))", "proof (rule prod.insert, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> insert a (UNIV - {a} - {b})", "show \"b \\<notin> insert a (UNIV - {a} - {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> insert a (UNIV - {a} - {b})", "using a_not_b"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. b \\<notin> insert a (UNIV - {a} - {b})", "by auto"], ["proof (state)\nthis:\n  b \\<notin> insert a (UNIV - {a} - {b})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod f (insert b (insert a (UNIV - {a} - {b}))) =\n  f b * prod f (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "also"], ["proof (state)\nthis:\n  prod f (insert b (insert a (UNIV - {a} - {b}))) =\n  f b * prod f (insert a (UNIV - {a} - {b}))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "have \"... = f b * f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f b * prod f (insert a (UNIV - {a} - {b})) = f b * f a", "unfolding prod_rw prod1"], ["proof (prove)\ngoal (1 subgoal):\n 1. f b * (f a * (1::'a)) = f b * f a", "by auto"], ["proof (state)\nthis:\n  f b * prod f (insert a (UNIV - {a} - {b})) = f b * f a\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "also"], ["proof (state)\nthis:\n  f b * prod f (insert a (UNIV - {a} - {b})) = f b * f a\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "have \"... = (d * p * v + ?b * q) * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f b * f a = (d * p * v + A $ b $ j * q) * p", "unfolding f_def sum_ab_def row_add_def mult_b_dp_def mult_row_def bezout_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = b\n        then (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             b $\n             ja +\n             A $ b $ j *\n             (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             a $\n             ja\n        else (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             i $\n             ja) $\n    b $\n    b *\n    (\\<chi>i ja.\n        if i = b\n        then (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             b $\n             ja +\n             A $ b $ j *\n             (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             a $\n             ja\n        else (\\<chi>i ja.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      ja\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) =\n                                bezout (A $ a $ j) (A $ b $ j)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      ja) $\n             i $\n             ja) $\n    a $\n    a =\n    (d * p * v + A $ b $ j * q) * p", "unfolding bz [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = b\n        then (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             b $\n             ja +\n             A $ b $ j *\n             (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             a $\n             ja\n        else (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             i $\n             ja) $\n    b $\n    b *\n    (\\<chi>i ja.\n        if i = b\n        then (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             b $\n             ja +\n             A $ b $ j *\n             (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             a $\n             ja\n        else (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             i $\n             ja) $\n    a $\n    a =\n    (d * p * v + A $ b $ j * q) * p", "using a_not_b"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. (\\<chi>i ja.\n        if i = b\n        then (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             b $\n             ja +\n             A $ b $ j *\n             (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             a $\n             ja\n        else (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             i $\n             ja) $\n    b $\n    b *\n    (\\<chi>i ja.\n        if i = b\n        then (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             b $\n             ja +\n             A $ b $ j *\n             (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             a $\n             ja\n        else (\\<chi>i j.\n                 if i = b\n                 then d * p *\n                      (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      b $\n                      j\n                 else (\\<chi>x y.\n                          let (p, q, u, v, d) = (p, q, u, v, d)\n                          in if x = a \\<and> y = a then p\n                             else if x = a \\<and> y = b then q\n                                  else if x = b \\<and> y = a then u\n else if x = b \\<and> y = b then v else if x = y then 1::'a else (0::'a)) $\n                      i $\n                      j) $\n             i $\n             ja) $\n    a $\n    a =\n    (d * p * v + A $ b $ j * q) * p", "by auto"], ["proof (state)\nthis:\n  f b * f a = (d * p * v + A $ b $ j * q) * p\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "also"], ["proof (state)\nthis:\n  f b * f a = (d * p * v + A $ b $ j * q) * p\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "have \"... = d * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d * p * v + A $ b $ j * q) * p = d * p", "using pib ap_bq_d semiring_normalization_rules(16)"], ["proof (prove)\nusing this:\n  p * A $ a $ j + q * A $ b $ j = d \\<and>\n  d dvd A $ a $ j \\<and>\n  d dvd A $ b $ j \\<and>\n  (\\<forall>d'.\n      d' dvd A $ a $ j \\<and> d' dvd A $ b $ j \\<longrightarrow>\n      d' dvd d) \\<and>\n  d * u = - A $ b $ j \\<and> d * v = A $ a $ j\n  A $ a $ j * p + A $ b $ j * q = d\n  ?lx * ?ly * ?rx = ?lx * ?rx * ?ly\n\ngoal (1 subgoal):\n 1. (d * p * v + A $ b $ j * q) * p = d * p", "by auto"], ["proof (state)\nthis:\n  (d * p * v + A $ b $ j * q) * p = d * p\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "finally"], ["proof (chain)\npicking this:\n  prod f UNIV = d * p", "show ?thesis"], ["proof (prove)\nusing this:\n  prod f UNIV = d * p\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "unfolding f_def"], ["proof (prove)\nusing this:\n  (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p", "."], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>UNIV. sum_ab $ i $ i) = d * p\n\ngoal (1 subgoal):\n 1. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "finally"], ["proof (chain)\npicking this:\n  det sum_ab = d * p", "have \"det (sum_ab) = d * p\""], ["proof (prove)\nusing this:\n  det sum_ab = d * p\n\ngoal (1 subgoal):\n 1. det sum_ab = d * p", "."], ["proof (state)\nthis:\n  det sum_ab = d * p\n\ngoal (1 subgoal):\n 1. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "moreover"], ["proof (state)\nthis:\n  det sum_ab = d * p\n\ngoal (1 subgoal):\n 1. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "have \"det (sum_ab) = d * p * det ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det sum_ab = d * p * det (bezout_matrix A a b j bezout)", "unfolding sum_ab_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add mult_b_dp b a (A $ b $ j)) =\n    d * p * det (bezout_matrix A a b j bezout)", "unfolding det_row_add'[OF not_sym[OF a_not_b]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det mult_b_dp = d * p * det (bezout_matrix A a b j bezout)", "unfolding mult_b_dp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mult_row (bezout_matrix A a b j bezout) b (d * p)) =\n    d * p * det (bezout_matrix A a b j bezout)", "unfolding det_mult_row"], ["proof (prove)\ngoal (1 subgoal):\n 1. d * p * det (bezout_matrix A a b j bezout) =\n    d * p * det (bezout_matrix A a b j bezout)", ".."], ["proof (state)\nthis:\n  det sum_ab = d * p * det (bezout_matrix A a b j bezout)\n\ngoal (1 subgoal):\n 1. p \\<noteq> (0::'a) \\<Longrightarrow>\n    det (bezout_matrix A a b j bezout) = (1::'a)", "ultimately"], ["proof (chain)\npicking this:\n  det sum_ab = d * p\n  det sum_ab = d * p * det (bezout_matrix A a b j bezout)", "show ?thesis"], ["proof (prove)\nusing this:\n  det sum_ab = d * p\n  det sum_ab = d * p * det (bezout_matrix A a b j bezout)\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A a b j bezout) = (1::'a)", "by (metis (erased, hide_lams) False aj d_dvd_a dvd_0_left_iff mult_cancel_left1 mult_eq_0_iff)"], ["proof (state)\nthis:\n  det (bezout_matrix A a b j bezout) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (bezout_matrix A a b j bezout) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_bezout_matrix:\n  fixes A::\"'a::{bezout_ring_div}^'cols^'rows::{finite,wellorder}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_less_b: \"a < b\"\n  and aj: \"A $ a $ j \\<noteq> 0\"\n  shows \"invertible (bezout_matrix A a b j bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (bezout_matrix A a b j bezout)", "unfolding invertible_iff_is_unit"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (det (bezout_matrix A a b j bezout))", "unfolding det_bezout_matrix[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (1::'a)", "by simp"], ["", "lemma echelon_form_upt_k_bezout_matrix:\n  fixes A k and i::\"'b::mod_type\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and ib: \"is_bezout_ext bezout\"\n  and Aik_0: \"A $ i $ from_nat k \\<noteq> 0\"\n  and zero_i: \"is_zero_row_upt_k i k A\" \n  and i_less_n: \"i<n\"\n  and k: \"k<ncols A\"\n  shows \"echelon_form_upt_k (bezout_matrix A i n (from_nat k) bezout ** A) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) k", "let ?B=\"(bezout_matrix A i n (from_nat k) bezout ** A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) k", "have i_not_n: \"i \\<noteq> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> n", "using i_less_n"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. i \\<noteq> n", "by simp"], ["proof (state)\nthis:\n  i \\<noteq> n\n\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) k", "have zero_n: \"is_zero_row_upt_k n k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k n k A", "by (metis assms(5) e echelon_form_upt_k_condition1 zero_i)"], ["proof (state)\nthis:\n  is_zero_row_upt_k n k A\n\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) k", "have zero_i2: \"is_zero_row_upt_k i (to_nat (from_nat k::'c)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A", "using zero_i"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A", "by (metis k ncols_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k)) A\n\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) k", "have zero_n2: \"is_zero_row_upt_k n (to_nat (from_nat k::'c)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k n (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A", "using zero_n"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k n k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k n (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A", "by (metis k ncols_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  is_zero_row_upt_k n (mod_type_class.to_nat (mod_type_class.from_nat k)) A\n\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) k", "unfolding echelon_form_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ia.\n        is_zero_row_upt_k ia k\n         (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n          A) \\<longrightarrow>\n        \\<not> (\\<exists>j>ia.\n                   \\<not> is_zero_row_upt_k j k\n                           (bezout_matrix A i n (mod_type_class.from_nat k)\n                             bezout **\n                            A))) \\<and>\n    (\\<forall>ia j.\n        ia < j \\<and>\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A) \\<and>\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A) \\<longrightarrow>\n        (LEAST na.\n            (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $\n            ia $\n            na \\<noteq>\n            (0::'a))\n        < (LEAST na.\n              (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n               A) $\n              j $\n              na \\<noteq>\n              (0::'a)))", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>is_zero_row_upt_k ia k\n                 (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                  A);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j k\n                          (bezout_matrix A i n (mod_type_class.from_nat k)\n                            bezout **\n                           A)\n 2. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "fix ia j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>is_zero_row_upt_k ia k\n                 (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                  A);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j k\n                          (bezout_matrix A i n (mod_type_class.from_nat k)\n                            bezout **\n                           A)\n 2. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "assume ia: \"is_zero_row_upt_k ia k ?B\"\n      and ia_j: \"ia < j\""], ["proof (state)\nthis:\n  is_zero_row_upt_k ia k\n   (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A)\n  ia < j\n\ngoal (2 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>is_zero_row_upt_k ia k\n                 (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                  A);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j k\n                          (bezout_matrix A i n (mod_type_class.from_nat k)\n                            bezout **\n                           A)\n 2. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have ia_A: \"is_zero_row_upt_k ia k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k ia k A", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ ia $ j = (0::'a)", "fix j::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ ia $ j = (0::'a)", "assume j_less_k: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ ia $ j = (0::'a)", "have \"A $ ia $ j = ?B $ ia $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ia $ j =\n    (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $ j", "proof (rule bezout_matrix_preserves_previous_columns\n          [symmetric, OF ib i_not_n Aik_0 _ zero_i2 zero_n2])"], ["proof (state)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "show \"j < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "using j_less_k k"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n  k < ncols A\n\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ ia $ j =\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ ia $ j = (0::'a)", "also"], ["proof (state)\nthis:\n  A $ ia $ j =\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ ia $ j = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $ j =\n    (0::'a)", "by (metis ia is_zero_row_upt_k_def j_less_k)"], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $ j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ ia $ j = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  A $ ia $ j = (0::'a)", "show \"A $ ia $ j = 0\""], ["proof (prove)\nusing this:\n  A $ ia $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ j = (0::'a)", "."], ["proof (state)\nthis:\n  A $ ia $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k ia k A\n\ngoal (2 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>is_zero_row_upt_k ia k\n                 (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                  A);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j k\n                          (bezout_matrix A i n (mod_type_class.from_nat k)\n                            bezout **\n                           A)\n 2. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "show \"is_zero_row_upt_k j k ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k\n     (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A)", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow>\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       ja =\n       (0::'a)", "fix ja::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow>\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       ja =\n       (0::'a)", "assume ja_less_k: \"to_nat ja < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow>\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       ja =\n       (0::'a)", "have \"?B $ j $ ja = A $ j $ ja\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ ja =\n    A $ j $ ja", "proof (rule bezout_matrix_preserves_previous_columns[OF ib i_not_n Aik_0 _ zero_i2 zero_n2])"], ["proof (state)\ngoal (1 subgoal):\n 1. ja < mod_type_class.from_nat k", "show \"ja < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ja < mod_type_class.from_nat k", "using ja_less_k k"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ja < k\n  k < ncols A\n\ngoal (1 subgoal):\n 1. ja < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id ncols_def)"], ["proof (state)\nthis:\n  ja < mod_type_class.from_nat k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ ja =\n  A $ j $ ja\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow>\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       ja =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ ja =\n  A $ j $ ja\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow>\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       ja =\n       (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "by (metis e echelon_form_upt_k_condition1 ia_A ia_j is_zero_row_upt_k_def ja_less_k)"], ["proof (state)\nthis:\n  A $ j $ ja = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < k \\<Longrightarrow>\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       ja =\n       (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ ja =\n  (0::'a)", "show \"?B $ j $ ja = 0\""], ["proof (prove)\nusing this:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ ja =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ ja =\n    (0::'a)", "."], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ ja =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k j k\n   (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A)\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "fix ia j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "assume ia_j: \"ia < j\"\n     and not_zero_ia_B: \"\\<not> is_zero_row_upt_k ia k ?B\"\n     and not_zero_j_B: \"\\<not> is_zero_row_upt_k j k ?B\""], ["proof (state)\nthis:\n  ia < j\n  \\<not> is_zero_row_upt_k ia k\n          (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A)\n  \\<not> is_zero_row_upt_k j k\n          (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A)\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "obtain na where na: \"to_nat na < k\" and Biana: \"?B $ ia $ na \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>na.\n        \\<lbrakk>mod_type_class.to_nat na < k;\n         (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $\n         ia $\n         na \\<noteq>\n         (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_ia_B"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ia k\n          (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A)\n\ngoal (1 subgoal):\n 1. (\\<And>na.\n        \\<lbrakk>mod_type_class.to_nat na < k;\n         (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $\n         ia $\n         na \\<noteq>\n         (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $\n             ia $\n             j =\n             (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>na.\n        \\<lbrakk>mod_type_class.to_nat na < k;\n         (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $\n         ia $\n         na \\<noteq>\n         (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat na < k\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n  na \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "obtain na2 where na2: \"to_nat na2 < k\" and Bjna2: \"?B $ j $ na2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>na2.\n        \\<lbrakk>mod_type_class.to_nat na2 < k;\n         (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n         na2 \\<noteq>\n         (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_j_B"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k j k\n          (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A)\n\ngoal (1 subgoal):\n 1. (\\<And>na2.\n        \\<lbrakk>mod_type_class.to_nat na2 < k;\n         (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n         na2 \\<noteq>\n         (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>ja.\n             mod_type_class.to_nat ja < k \\<longrightarrow>\n             (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $\n             j $\n             ja =\n             (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>na2.\n        \\<lbrakk>mod_type_class.to_nat na2 < k;\n         (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n         na2 \\<noteq>\n         (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat na2 < k\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n  na2 \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have na_less_fn: \"na < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. na < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id k na ncols_def)"], ["proof (state)\nthis:\n  na < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have \"A $ ia $ na = ?B $ ia $ na\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ia $ na =\n    (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $ na", "by (rule bezout_matrix_preserves_previous_columns\n     [symmetric, OF ib i_not_n Aik_0 na_less_fn zero_i2 zero_n2])"], ["proof (state)\nthis:\n  A $ ia $ na =\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $ na\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "also"], ["proof (state)\nthis:\n  A $ ia $ na =\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $ na\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n    na \\<noteq>\n    (0::'a)", "using Biana"], ["proof (prove)\nusing this:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n  na \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n    na \\<noteq>\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n  na \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "finally"], ["proof (chain)\npicking this:\n  A $ ia $ na \\<noteq> (0::'a)", "have A: \"A $ ia $ na \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A $ ia $ na \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ na \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A $ ia $ na \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have na_less_fn2: \"na2 < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. na2 < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id k na2 ncols_def)"], ["proof (state)\nthis:\n  na2 < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have \"A $ j $ na2 = ?B $ j $ na2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ na2 =\n    (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ na2", "by (rule bezout_matrix_preserves_previous_columns\n     [symmetric, OF ib i_not_n Aik_0 na_less_fn2 zero_i2 zero_n2])"], ["proof (state)\nthis:\n  A $ j $ na2 =\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ na2\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "also"], ["proof (state)\nthis:\n  A $ j $ na2 =\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ na2\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n    na2 \\<noteq>\n    (0::'a)", "using Bjna2"], ["proof (prove)\nusing this:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n  na2 \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n    na2 \\<noteq>\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n  na2 \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "finally"], ["proof (chain)\npicking this:\n  A $ j $ na2 \\<noteq> (0::'a)", "have A2: \"A $ j $ na2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A $ j $ na2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ na2 \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A $ j $ na2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have not_zero_ia_A: \"\\<not> is_zero_row_upt_k ia k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k ia k A", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < k \\<longrightarrow>\n               A $ ia $ j = (0::'a))", "using na A"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat na < k\n  A $ ia $ na \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < k \\<longrightarrow>\n               A $ ia $ j = (0::'a))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k ia k A\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have not_zero_j_A: \"\\<not> is_zero_row_upt_k j k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k j k A", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ja.\n               mod_type_class.to_nat ja < k \\<longrightarrow>\n               A $ j $ ja = (0::'a))", "using na2 A2"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat na2 < k\n  A $ j $ na2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ja.\n               mod_type_class.to_nat ja < k \\<longrightarrow>\n               A $ j $ ja = (0::'a))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "obtain na where A: \"A $ ia $ na \\<noteq> 0\" and na_less_k: \"to_nat na<k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>na.\n        \\<lbrakk>A $ ia $ na \\<noteq> (0::'a);\n         mod_type_class.to_nat na < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_ia_A"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ia k A\n\ngoal (1 subgoal):\n 1. (\\<And>na.\n        \\<lbrakk>A $ ia $ na \\<noteq> (0::'a);\n         mod_type_class.to_nat na < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ ia $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>na.\n        \\<lbrakk>A $ ia $ na \\<noteq> (0::'a);\n         mod_type_class.to_nat na < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A $ ia $ na \\<noteq> (0::'a)\n  mod_type_class.to_nat na < k\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have na_less_fn: \"na<from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. na < mod_type_class.from_nat k", "using na_less_k"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat na < k\n\ngoal (1 subgoal):\n 1. na < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id k ncols_def)"], ["proof (state)\nthis:\n  na < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "obtain na2 where A2: \"A $ j $ na2 \\<noteq> 0\" and na2_less_k: \"to_nat na2<k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>na2.\n        \\<lbrakk>A $ j $ na2 \\<noteq> (0::'a);\n         mod_type_class.to_nat na2 < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_j_A"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. (\\<And>na2.\n        \\<lbrakk>A $ j $ na2 \\<noteq> (0::'a);\n         mod_type_class.to_nat na2 < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>ja.\n             mod_type_class.to_nat ja < k \\<longrightarrow>\n             A $ j $ ja = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>na2.\n        \\<lbrakk>A $ j $ na2 \\<noteq> (0::'a);\n         mod_type_class.to_nat na2 < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A $ j $ na2 \\<noteq> (0::'a)\n  mod_type_class.to_nat na2 < k\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have na_less_fn2: \"na2<from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. na2 < mod_type_class.from_nat k", "using na2_less_k"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat na2 < k\n\ngoal (1 subgoal):\n 1. na2 < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id k ncols_def)"], ["proof (state)\nthis:\n  na2 < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have least_eq: \"(LEAST na. ?B $ ia $ na \\<noteq> 0) = (LEAST na. A $ ia $ na \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na.\n        (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n        na \\<noteq>\n        (0::'a)) =\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "have \"?B $ ia $ (LEAST na. A $ ia $ na \\<noteq> 0) = A $ ia $ (LEAST na. A $ ia $ na \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) =\n    A $ ia $ (LEAST na. A $ ia $ na \\<noteq> (0::'a))", "proof (rule bezout_matrix_preserves_previous_columns[OF ib i_not_n Aik_0 _ zero_i2 zero_n2])"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST na. A $ ia $ na \\<noteq> (0::'a)) < mod_type_class.from_nat k", "show \"(LEAST na. A $ ia $ na \\<noteq> 0) < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na. A $ ia $ na \\<noteq> (0::'a)) < mod_type_class.from_nat k", "using Least_le A na_less_fn"], ["proof (prove)\nusing this:\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n  A $ ia $ na \\<noteq> (0::'a)\n  na < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST na. A $ ia $ na \\<noteq> (0::'a)) < mod_type_class.from_nat k", "by fastforce"], ["proof (state)\nthis:\n  (LEAST na. A $ ia $ na \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n  (LEAST na. A $ ia $ na \\<noteq> (0::'a)) =\n  A $ ia $ (LEAST na. A $ ia $ na \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n  (LEAST na. A $ ia $ na \\<noteq> (0::'a)) =\n  A $ ia $ (LEAST na. A $ ia $ na \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags) A LeastI)"], ["proof (state)\nthis:\n  A $ ia $ (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n  (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)", "show \"?B $ ia $ (LEAST na. A $ ia $ na \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n  (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "."], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n  (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "assume B_ia_y: \"?B $ ia $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "show \"(LEAST na. A $ ia $ na \\<noteq> 0) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "proof (cases \"y<from_nat k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "case True"], ["proof (state)\nthis:\n  y < mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "proof (rule Least_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ ia $ y \\<noteq> (0::'a)", "have \"A $ ia $ y = ?B $ ia $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ia $ y =\n    (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $ y", "by (rule bezout_matrix_preserves_previous_columns[symmetric, \n             OF ib i_not_n Aik_0 True zero_i2 zero_n2])"], ["proof (state)\nthis:\n  A $ ia $ y =\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $ y\n\ngoal (1 subgoal):\n 1. A $ ia $ y \\<noteq> (0::'a)", "also"], ["proof (state)\nthis:\n  A $ ia $ y =\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $ y\n\ngoal (1 subgoal):\n 1. A $ ia $ y \\<noteq> (0::'a)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n    y \\<noteq>\n    (0::'a)", "using B_ia_y"], ["proof (prove)\nusing this:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n    y \\<noteq>\n    (0::'a)", "."], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ y \\<noteq> (0::'a)", "finally"], ["proof (chain)\npicking this:\n  A $ ia $ y \\<noteq> (0::'a)", "show \"A $ ia $ y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A $ ia $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ y \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A $ ia $ y \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> y < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "using False"], ["proof (prove)\nusing this:\n  \\<not> y < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y", "by (metis (mono_tags) A Least_le dual_order.strict_iff_order\n            le_less_trans na_less_fn not_le)"], ["proof (state)\nthis:\n  (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST na. A $ ia $ na \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST na.\n      (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n      na \\<noteq>\n      (0::'a)) =\n  (LEAST na. A $ ia $ na \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "have least_eq2: \"(LEAST na. ?B $ j $ na \\<noteq> 0) = (LEAST na. A $ j $ na \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na.\n        (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n        na \\<noteq>\n        (0::'a)) =\n    (LEAST na. A $ j $ na \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "have \"?B $ j $ (LEAST na. A $ j $ na \\<noteq> 0) = A $ j $ (LEAST na. A $ j $ na \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) =\n    A $ j $ (LEAST na. A $ j $ na \\<noteq> (0::'a))", "proof (rule bezout_matrix_preserves_previous_columns[OF ib i_not_n Aik_0 _ zero_i2 zero_n2])"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST na. A $ j $ na \\<noteq> (0::'a)) < mod_type_class.from_nat k", "show \"(LEAST na. A $ j $ na \\<noteq> 0) < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na. A $ j $ na \\<noteq> (0::'a)) < mod_type_class.from_nat k", "using Least_le A2 na_less_fn2"], ["proof (prove)\nusing this:\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n  A $ j $ na2 \\<noteq> (0::'a)\n  na2 < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST na. A $ j $ na \\<noteq> (0::'a)) < mod_type_class.from_nat k", "by fastforce"], ["proof (state)\nthis:\n  (LEAST na. A $ j $ na \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n  (LEAST na. A $ j $ na \\<noteq> (0::'a)) =\n  A $ j $ (LEAST na. A $ j $ na \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n  (LEAST na. A $ j $ na \\<noteq> (0::'a)) =\n  A $ j $ (LEAST na. A $ j $ na \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags) A2 LeastI)"], ["proof (state)\nthis:\n  A $ j $ (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n  (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)", "show \"?B $ j $ (LEAST na. A $ j $ na \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n  (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "."], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n  (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "assume B_ia_y: \"?B $ j $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "show \"(LEAST na. A $ j $ na \\<noteq> 0) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "proof (cases \"y<from_nat k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "case True"], ["proof (state)\nthis:\n  y < mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "proof (rule Least_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ j $ y \\<noteq> (0::'a)", "have \"A $ j $ y = ?B $ j $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ y =\n    (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ y", "by (rule bezout_matrix_preserves_previous_columns[symmetric, \n            OF ib i_not_n Aik_0 True zero_i2 zero_n2])"], ["proof (state)\nthis:\n  A $ j $ y =\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ y\n\ngoal (1 subgoal):\n 1. A $ j $ y \\<noteq> (0::'a)", "also"], ["proof (state)\nthis:\n  A $ j $ y =\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $ y\n\ngoal (1 subgoal):\n 1. A $ j $ y \\<noteq> (0::'a)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n    y \\<noteq>\n    (0::'a)", "using B_ia_y"], ["proof (prove)\nusing this:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n    y \\<noteq>\n    (0::'a)", "."], ["proof (state)\nthis:\n  (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ y \\<noteq> (0::'a)", "finally"], ["proof (chain)\npicking this:\n  A $ j $ y \\<noteq> (0::'a)", "show \"A $ j $ y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A $ j $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ y \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A $ j $ y \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> y < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "using False"], ["proof (prove)\nusing this:\n  \\<not> y < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y", "by (metis (mono_tags) A2 Least_le dual_order.strict_iff_order\n            le_less_trans na_less_fn2 not_le)"], ["proof (state)\nthis:\n  (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST na. A $ j $ na \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST na.\n      (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n      na \\<noteq>\n      (0::'a)) =\n  (LEAST na. A $ j $ na \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < j;\n        \\<not> is_zero_row_upt_k ia k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A);\n        \\<not> is_zero_row_upt_k j k\n                (bezout_matrix A i n (mod_type_class.from_nat k) bezout **\n                 A)\\<rbrakk>\n       \\<Longrightarrow> (LEAST na.\n                             (bezout_matrix A i n\n                               (mod_type_class.from_nat k) bezout **\n                              A) $\n                             ia $\n                             na \\<noteq>\n                             (0::'a))\n                         < (LEAST na.\n                               (bezout_matrix A i n\n                                 (mod_type_class.from_nat k) bezout **\n                                A) $\n                               j $\n                               na \\<noteq>\n                               (0::'a))", "show \"(LEAST na. ?B $ ia $ na \\<noteq> 0) < (LEAST na. ?B $ j $ na \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na.\n        (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n        na \\<noteq>\n        (0::'a))\n    < (LEAST na.\n          (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $\n          j $\n          na \\<noteq>\n          (0::'a))", "unfolding least_eq least_eq2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST na. A $ ia $ na \\<noteq> (0::'a))\n    < (LEAST na. A $ j $ na \\<noteq> (0::'a))", "by (rule echelon_form_upt_k_condition2[OF e ia_j not_zero_ia_A not_zero_j_A])"], ["proof (state)\nthis:\n  (LEAST na.\n      (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ ia $\n      na \\<noteq>\n      (0::'a))\n  < (LEAST na.\n        (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) $ j $\n        na \\<noteq>\n        (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (bezout_matrix A i n (mod_type_class.from_nat k) bezout ** A) k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bezout_matrix_preserves_rest:\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_not_n: \"a\\<noteq>n\"\n  and i_not_n: \"i\\<noteq>n\"\n  and a_not_i: \"a\\<noteq>i\"\n  and Aik_0: \"A $ i $ k \\<noteq> 0\"\n  and zero_ikA: \"is_zero_row_upt_k i (to_nat k) A\"\n  shows \"(bezout_matrix A i n k bezout ** A) $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i n k bezout ** A) $ a $ b = A $ a $ b", "unfolding matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        \\<Sum>ka\\<in>UNIV.\n          bezout_matrix A i n k bezout $ ia $ ka * A $ ka $ j) $\n    a $\n    b =\n    A $ a $ b", "unfolding bezout_matrix_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        \\<Sum>ka\\<in>UNIV.\n          (\\<chi>x y.\n              case bezout (A $ i $ k) (A $ n $ k) of\n              (p, q, u, v, d) \\<Rightarrow>\n                if x = i \\<and> y = i then p\n                else if x = i \\<and> y = n then q\n                     else if x = n \\<and> y = i then u\n                          else if x = n \\<and> y = n then v\n                               else if x = y then 1::'a else (0::'a)) $\n          ia $\n          ka *\n          A $ ka $ j) $\n    a $\n    b =\n    A $ a $ b", "proof (auto simp add: a_not_n i_not_n a_not_i)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "have UNIV_rw: \"UNIV = insert a (UNIV - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = insert a (UNIV - {a})", "by auto"], ["proof (state)\nthis:\n  UNIV = insert a (UNIV - {a})\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "let ?f=\"(\\<lambda>k. (if a = k then 1 else 0) * A $ k $ b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "have sum0: \"sum ?f (UNIV - {a}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV - {a}.\n       (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    (0::'a)", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV - {a}. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "have \"sum ?f UNIV = sum ?f (insert a (UNIV - {a}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    (\\<Sum>k\\<in>insert a (UNIV - {a}).\n       (if a = k then 1::'a else (0::'a)) * A $ k $ b)", "using UNIV_rw"], ["proof (prove)\nusing this:\n  UNIV = insert a (UNIV - {a})\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    (\\<Sum>k\\<in>insert a (UNIV - {a}).\n       (if a = k then 1::'a else (0::'a)) * A $ k $ b)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n  (\\<Sum>k\\<in>insert a (UNIV - {a}).\n     (if a = k then 1::'a else (0::'a)) * A $ k $ b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n  (\\<Sum>k\\<in>insert a (UNIV - {a}).\n     (if a = k then 1::'a else (0::'a)) * A $ k $ b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "have \"... = ?f a + sum ?f (UNIV - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>insert a (UNIV - {a}).\n       (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    (if a = a then 1::'a else (0::'a)) * A $ a $ b +\n    (\\<Sum>k\\<in>UNIV - {a}. (if a = k then 1::'a else (0::'a)) * A $ k $ b)", "by (rule sum.insert, simp_all)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert a (UNIV - {a}).\n     (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n  (if a = a then 1::'a else (0::'a)) * A $ a $ b +\n  (\\<Sum>k\\<in>UNIV - {a}. (if a = k then 1::'a else (0::'a)) * A $ k $ b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert a (UNIV - {a}).\n     (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n  (if a = a then 1::'a else (0::'a)) * A $ a $ b +\n  (\\<Sum>k\\<in>UNIV - {a}. (if a = k then 1::'a else (0::'a)) * A $ k $ b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "have \"... = ?f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = a then 1::'a else (0::'a)) * A $ a $ b +\n    (\\<Sum>k\\<in>UNIV - {a}.\n       (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    (if a = a then 1::'a else (0::'a)) * A $ a $ b", "using sum0"], ["proof (prove)\nusing this:\n  (\\<Sum>k\\<in>UNIV - {a}. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (if a = a then 1::'a else (0::'a)) * A $ a $ b +\n    (\\<Sum>k\\<in>UNIV - {a}.\n       (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    (if a = a then 1::'a else (0::'a)) * A $ a $ b", "by auto"], ["proof (state)\nthis:\n  (if a = a then 1::'a else (0::'a)) * A $ a $ b +\n  (\\<Sum>k\\<in>UNIV - {a}. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n  (if a = a then 1::'a else (0::'a)) * A $ a $ b\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  (if a = a then 1::'a else (0::'a)) * A $ a $ b +\n  (\\<Sum>k\\<in>UNIV - {a}. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n  (if a = a then 1::'a else (0::'a)) * A $ a $ b\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "have \"... = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = a then 1::'a else (0::'a)) * A $ a $ b = A $ a $ b", "by simp"], ["proof (state)\nthis:\n  (if a = a then 1::'a else (0::'a)) * A $ a $ b = A $ a $ b\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n  A $ a $ b", "show \"sum ?f UNIV = A $ a $ b\""], ["proof (prove)\nusing this:\n  (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n    A $ a $ b", "."], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. (if a = k then 1::'a else (0::'a)) * A $ k $ b) =\n  A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Code equations to execute the bezout matrix\\<close>"], ["", "definition \"bezout_matrix_row A a b j bezout x\n  = (let (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j) \n      in\n         vec_lambda (\\<lambda>y. if x = a \\<and> y = a then p else\n                         if x = a \\<and> y = b then q else\n                         if x = b \\<and> y = a then u else\n                         if x = b \\<and> y = b then v else\n                         if x = y then 1 else 0))\""], ["", "lemma bezout_matrix_row_code [code abstract]:\n  \"vec_nth (bezout_matrix_row A a b j bezout x) = \n      (let (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n        in\n          (\\<lambda>y. if x = a \\<and> y = a then p else\n               if x = a \\<and> y = b then q else\n               if x = b \\<and> y = a then u else\n               if x = b \\<and> y = b then v else\n               if x = y then 1 else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (bezout_matrix_row A a b j bezout x) =\n    (let (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n     in (\\<lambda>y.\n            if x = a \\<and> y = a then p\n            else if x = a \\<and> y = b then q\n                 else if x = b \\<and> y = a then u\n                      else if x = b \\<and> y = b then v\n                           else if x = y then 1::'b else (0::'b)))", "unfolding bezout_matrix_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (let (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n         in \\<chi>y.\n               if x = a \\<and> y = a then p\n               else if x = a \\<and> y = b then q\n                    else if x = b \\<and> y = a then u\n                         else if x = b \\<and> y = b then v\n                              else if x = y then 1::'b else (0::'b)) =\n    (let (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n     in (\\<lambda>y.\n            if x = a \\<and> y = a then p\n            else if x = a \\<and> y = b then q\n                 else if x = b \\<and> y = a then u\n                      else if x = b \\<and> y = b then v\n                           else if x = y then 1::'b else (0::'b)))", "by (cases \"bezout (A $ a $ j) (A $ b $ j)\") auto"], ["", "lemma [code abstract]: \"vec_nth (bezout_matrix A a b j bezout) = bezout_matrix_row A a b j bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (bezout_matrix A a b j bezout) = bezout_matrix_row A a b j bezout", "unfolding bezout_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>x y.\n            let (p, q, u, v, d) = bezout (A $ a $ j) (A $ b $ j)\n            in if x = a \\<and> y = a then p\n               else if x = a \\<and> y = b then q\n                    else if x = b \\<and> y = a then u\n                         else if x = b \\<and> y = b then v\n                              else if x = y then 1::'b else (0::'b)) =\n    bezout_matrix_row A a b j bezout", "unfolding bezout_matrix_row_def[abs_def] Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>x y.\n            case bezout (A $ a $ j) (A $ b $ j) of\n            (p, q, u, v, d) \\<Rightarrow>\n              if x = a \\<and> y = a then p\n              else if x = a \\<and> y = b then q\n                   else if x = b \\<and> y = a then u\n                        else if x = b \\<and> y = b then v\n                             else if x = y then 1::'b else (0::'b)) =\n    (\\<lambda>x.\n        case bezout (A $ a $ j) (A $ b $ j) of\n        (p, q, u, v, d) \\<Rightarrow>\n          \\<chi>y.\n             if x = a \\<and> y = a then p\n             else if x = a \\<and> y = b then q\n                  else if x = b \\<and> y = a then u\n                       else if x = b \\<and> y = b then v\n                            else if x = y then 1::'b else (0::'b))", "by (cases \"bezout (A $ a $ j) (A $ b $ j)\") auto"], ["", "subsubsection\\<open>Properties of the bezout iterate function\\<close>"], ["", "lemma bezout_iterate_not_zero:\n  assumes Aik_0: \"A $ i $ from_nat k \\<noteq> 0\"\n  and n: \"n<nrows A\"\n  and a: \"to_nat i \\<le> n\"\n  and ib: \"is_bezout_ext bezout\"\n  shows \"bezout_iterate A n i (from_nat k) bezout $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A n i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using Aik_0 n a"], ["proof (prove)\nusing this:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  n < nrows A\n  mod_type_class.to_nat i \\<le> n\n\ngoal (1 subgoal):\n 1. bezout_iterate A n i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        0 < nrows A; mod_type_class.to_nat i \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A 0 i (mod_type_class.from_nat k)\n                          bezout $\n                         i $\n                         mod_type_class.from_nat k \\<noteq>\n                         (0::'a)\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     i $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a);\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         i $\n                         mod_type_class.from_nat k \\<noteq>\n                         (0::'a)", "case 0"], ["proof (state)\nthis:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  0 < nrows A\n  mod_type_class.to_nat i \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        0 < nrows A; mod_type_class.to_nat i \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A 0 i (mod_type_class.from_nat k)\n                          bezout $\n                         i $\n                         mod_type_class.from_nat k \\<noteq>\n                         (0::'a)\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     i $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a);\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         i $\n                         mod_type_class.from_nat k \\<noteq>\n                         (0::'a)", "have \"to_nat i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i = 0", "by (metis \"0.prems\"(3) le_0_eq)"], ["proof (state)\nthis:\n  mod_type_class.to_nat i = 0\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        0 < nrows A; mod_type_class.to_nat i \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A 0 i (mod_type_class.from_nat k)\n                          bezout $\n                         i $\n                         mod_type_class.from_nat k \\<noteq>\n                         (0::'a)\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     i $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a);\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         i $\n                         mod_type_class.from_nat k \\<noteq>\n                         (0::'a)", "hence i0: \"i=0\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i = 0\n\ngoal (1 subgoal):\n 1. i = (0::'c)", "by (metis to_nat_eq_0)"], ["proof (state)\nthis:\n  i = (0::'c)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        0 < nrows A; mod_type_class.to_nat i \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A 0 i (mod_type_class.from_nat k)\n                          bezout $\n                         i $\n                         mod_type_class.from_nat k \\<noteq>\n                         (0::'a)\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     i $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a);\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         i $\n                         mod_type_class.from_nat k \\<noteq>\n                         (0::'a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A 0 i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using \"0.prems\"(1)"], ["proof (prove)\nusing this:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate A 0 i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "unfolding i0"], ["proof (prove)\nusing this:\n  A $ (0::'c) $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate A 0 (0::'c) (mod_type_class.from_nat k) bezout $\n    (0::'c) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  bezout_iterate A 0 i (mod_type_class.from_nat k) bezout $ i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     i $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a);\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         i $\n                         mod_type_class.from_nat k \\<noteq>\n                         (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     i $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a);\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         i $\n                         mod_type_class.from_nat k \\<noteq>\n                         (0::'a)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>?A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n   n < nrows ?A; mod_type_class.to_nat i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> bezout_iterate ?A n i (mod_type_class.from_nat k)\n                     bezout $\n                    i $\n                    mod_type_class.from_nat k \\<noteq>\n                    (0::'a)\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  Suc n < nrows A\n  mod_type_class.to_nat i \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     i $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a);\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         i $\n                         mod_type_class.from_nat k \\<noteq>\n                         (0::'a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "proof (cases \"Suc n = to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using True Suc.prems(1)"], ["proof (prove)\nusing this:\n  Suc n = mod_type_class.to_nat i\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "let ?B=\"(bezout_matrix A i (from_nat (Suc n)) (from_nat k) bezout ** A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "have i_le_n: \"to_nat i < Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc n", "using Suc.prems(3) False"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<le> Suc n\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc n", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "have \"bezout_iterate A (Suc n) i (from_nat k) bezout $ i $ from_nat k \n      = bezout_iterate ?B n i (from_nat k) bezout $ i $ from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    i $\n    mod_type_class.from_nat k", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    i $\n    mod_type_class.from_nat k =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    i $\n    mod_type_class.from_nat k", "using i_le_n"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    i $\n    mod_type_class.from_nat k =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    i $\n    mod_type_class.from_nat k", "by auto"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n  mod_type_class.from_nat k =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  i $\n  mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "also"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n  mod_type_class.from_nat k =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  i $\n  mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "proof (rule Suc.hyps, rule bezout_matrix_not_zero[OF ib])"], ["proof (state)\ngoal (4 subgoals):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)\n 2. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 3. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 4. mod_type_class.to_nat i \\<le> n", "show \"i \\<noteq> from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)", "by (metis False Suc.prems(2) nrows_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat (Suc n)\n\ngoal (3 subgoals):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 2. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 3. mod_type_class.to_nat i \\<le> n", "show \"A $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)", "by (rule Suc.prems(1))"], ["proof (state)\nthis:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 2. mod_type_class.to_nat i \\<le> n", "show \"n < nrows ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "by (metis Suc.prems(2) Suc_lessD nrows_def)"], ["proof (state)\nthis:\n  n < nrows\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> n", "show \"to_nat i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> n", "using i_le_n"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> n", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "."], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bezout_iterate_preserves:\n  fixes A k and i::\"'b::mod_type\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and ib: \"is_bezout_ext bezout\"\n  and Aik_0: \"A $ i $ from_nat k \\<noteq> 0\"\n  and n: \"n<nrows A\"\n  and \"b < from_nat k\"\n  and i_le_n: \"to_nat i \\<le> n\"\n  and k: \"k<ncols A\"\n  and zero_upt_k_i: \"is_zero_row_upt_k i k A\" \n  shows \"bezout_iterate A n i (from_nat k) bezout $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A n i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "using Aik_0 n i_le_n k zero_upt_k_i  e"], ["proof (prove)\nusing this:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  n < nrows A\n  mod_type_class.to_nat i \\<le> n\n  k < ncols A\n  is_zero_row_upt_k i k A\n  echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. bezout_iterate A n i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        0 < nrows A; mod_type_class.to_nat i \\<le> 0; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A 0 i (mod_type_class.from_nat k)\n                          bezout $\n                         a $\n                         b =\n                         A $ a $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n;\n                    k < ncols A; is_zero_row_upt_k i k A;\n                    echelon_form_upt_k A k\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     b =\n                                     A $ a $ b;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         b =\n                         A $ a $ b", "case 0"], ["proof (state)\nthis:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  0 < nrows A\n  mod_type_class.to_nat i \\<le> 0\n  k < ncols A\n  is_zero_row_upt_k i k A\n  echelon_form_upt_k A k\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        0 < nrows A; mod_type_class.to_nat i \\<le> 0; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A 0 i (mod_type_class.from_nat k)\n                          bezout $\n                         a $\n                         b =\n                         A $ a $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n;\n                    k < ncols A; is_zero_row_upt_k i k A;\n                    echelon_form_upt_k A k\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     b =\n                                     A $ a $ b;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         b =\n                         A $ a $ b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A 0 i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b = A $ a $ b", ".."], ["proof (state)\nthis:\n  bezout_iterate A 0 i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n;\n                    k < ncols A; is_zero_row_upt_k i k A;\n                    echelon_form_upt_k A k\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     b =\n                                     A $ a $ b;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         b =\n                         A $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n;\n                    k < ncols A; is_zero_row_upt_k i k A;\n                    echelon_form_upt_k A k\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     b =\n                                     A $ a $ b;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         b =\n                         A $ a $ b", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>?A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n   n < nrows ?A; mod_type_class.to_nat i \\<le> n; k < ncols ?A;\n   is_zero_row_upt_k i k ?A; echelon_form_upt_k ?A k\\<rbrakk>\n  \\<Longrightarrow> bezout_iterate ?A n i (mod_type_class.from_nat k)\n                     bezout $\n                    a $\n                    b =\n                    ?A $ a $ b\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  Suc n < nrows A\n  mod_type_class.to_nat i \\<le> Suc n\n  k < ncols A\n  is_zero_row_upt_k i k A\n  echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n;\n                    k < ncols A; is_zero_row_upt_k i k A;\n                    echelon_form_upt_k A k\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     b =\n                                     A $ a $ b;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         b =\n                         A $ a $ b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "proof (cases \"Suc n = to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "case True"], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    b =\n    A $ a $ b", "using True"], ["proof (prove)\nusing this:\n  Suc n = mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    b =\n    A $ a $ b", "by simp"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "case False"], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "have i_not_fn:\" i \\<noteq> from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)", "by (metis False Suc.prems(2) nrows_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat (Suc n)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "let ?B=\"(bezout_matrix A i (from_nat (Suc n)) (from_nat k) bezout ** A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "have i_le_n: \"to_nat i < Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc n", "by (metis False Suc.prems(3) le_imp_less_or_eq)"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "have \"bezout_iterate A (Suc n) i (from_nat k) bezout $ a $ b \n      = bezout_iterate ?B n i (from_nat k) bezout $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    b", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    b =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    b", "using i_le_n"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    b =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    b", "by auto"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "have \"... = ?B $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    b =\n    (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    a $\n    b", "proof (rule Suc.hyps)"], ["proof (state)\ngoal (6 subgoals):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 3. mod_type_class.to_nat i \\<le> n\n 4. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 5. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n 6. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k", "show \"?B $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis False Suc.prems(1) Suc.prems(2) bezout_matrix_not_zero \n            ib nrows_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (5 subgoals):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 2. mod_type_class.to_nat i \\<le> n\n 3. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 4. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n 5. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k", "show \"n < nrows ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "by (metis Suc.prems(2) Suc_lessD nrows_def)"], ["proof (state)\nthis:\n  n < nrows\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A)\n\ngoal (4 subgoals):\n 1. mod_type_class.to_nat i \\<le> n\n 2. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 3. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n 4. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k", "show \"k < ncols ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "by (metis Suc.prems(4) ncols_def)"], ["proof (state)\nthis:\n  k < ncols\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A)\n\ngoal (3 subgoals):\n 1. mod_type_class.to_nat i \\<le> n\n 2. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n 3. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k", "show \"to_nat i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> n", "using i_le_n"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> n", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> n\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n 2. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k", "show \"is_zero_row_upt_k i k ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "fix j::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "assume j_k: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "have j_k2: \"j < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id j_k k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "have \"?B $ i $ j = A $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    j =\n    A $ i $ j", "proof (rule bezout_matrix_preserves_previous_columns[OF ib i_not_fn Suc.prems(1) j_k2], \n            unfold to_nat_from_nat_id[OF Suc.prems(4)[unfolded ncols_def]])"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A\n 2. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "show \"is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "by (rule Suc.prems(5))"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "show \"is_zero_row_upt_k (from_nat (Suc n)) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "using echelon_form_upt_k_condition1[OF Suc.prems(6) Suc.prems(5)]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "by (metis Suc.prems(2) from_nat_mono from_nat_to_nat_id i_le_n nrows_def)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  A $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  A $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "by (metis Suc.prems(5) is_zero_row_upt_k_def j_k)"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  (0::'a)", "show \"?B $ i $ j = 0\""], ["proof (prove)\nusing this:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    j =\n    (0::'a)", "."], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k", "show \"echelon_form_upt_k ?B k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k", "proof (rule echelon_form_upt_k_bezout_matrix)"], ["proof (state)\ngoal (6 subgoals):\n 1. echelon_form_upt_k A k\n 2. is_bezout_ext bezout\n 3. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 4. is_zero_row_upt_k i k A\n 5. i < mod_type_class.from_nat (Suc n)\n 6. k < ncols A", "show \"echelon_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k A k", "by (metis Suc.prems(6))"], ["proof (state)\nthis:\n  echelon_form_upt_k A k\n\ngoal (5 subgoals):\n 1. is_bezout_ext bezout\n 2. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 3. is_zero_row_upt_k i k A\n 4. i < mod_type_class.from_nat (Suc n)\n 5. k < ncols A", "show \"is_bezout_ext bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bezout_ext bezout", "by (rule ib)"], ["proof (state)\nthis:\n  is_bezout_ext bezout\n\ngoal (4 subgoals):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 2. is_zero_row_upt_k i k A\n 3. i < mod_type_class.from_nat (Suc n)\n 4. k < ncols A", "show \"A $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)", "by (rule Suc.prems(1))"], ["proof (state)\nthis:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. is_zero_row_upt_k i k A\n 2. i < mod_type_class.from_nat (Suc n)\n 3. k < ncols A", "show \"is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "by (rule Suc.prems(5))"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (2 subgoals):\n 1. i < mod_type_class.from_nat (Suc n)\n 2. k < ncols A", "have \"(from_nat (to_nat i)::'b)\\<le>from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat i)\n    \\<le> mod_type_class.from_nat (Suc n)", "by (rule from_nat_mono'[OF Suc.prems(3) Suc.prems(2)[unfolded nrows_def]])"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat i)\n  \\<le> mod_type_class.from_nat (Suc n)\n\ngoal (2 subgoals):\n 1. i < mod_type_class.from_nat (Suc n)\n 2. k < ncols A", "thus \"i < from_nat (Suc n)\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (mod_type_class.to_nat i)\n  \\<le> mod_type_class.from_nat (Suc n)\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "using i_not_fn"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (mod_type_class.to_nat i)\n  \\<le> mod_type_class.from_nat (Suc n)\n  i \\<noteq> mod_type_class.from_nat (Suc n)\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "by auto"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat (Suc n)\n\ngoal (1 subgoal):\n 1. k < ncols A", "show \"k < ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols A", "by (rule Suc.prems(4))"], ["proof (state)\nthis:\n  k < ncols A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  b =\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  b =\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "have \"... = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    a $\n    b =\n    A $ a $ b", "proof (rule bezout_matrix_preserves_previous_columns[OF ib])"], ["proof (state)\ngoal (5 subgoals):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)\n 2. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 3. b < mod_type_class.from_nat k\n 4. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A\n 5. is_zero_row_upt_k (mod_type_class.from_nat (Suc n))\n     (mod_type_class.to_nat (mod_type_class.from_nat k)) A", "show \"i \\<noteq> from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)", "by (metis False Suc.prems(2) nrows_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat (Suc n)\n\ngoal (4 subgoals):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 2. b < mod_type_class.from_nat k\n 3. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A\n 4. is_zero_row_upt_k (mod_type_class.from_nat (Suc n))\n     (mod_type_class.to_nat (mod_type_class.from_nat k)) A", "show \"A $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)", "by (rule Suc.prems(1))"], ["proof (state)\nthis:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. b < mod_type_class.from_nat k\n 2. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A\n 3. is_zero_row_upt_k (mod_type_class.from_nat (Suc n))\n     (mod_type_class.to_nat (mod_type_class.from_nat k)) A", "show \"b < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < mod_type_class.from_nat k", "by (rule assms(5))"], ["proof (state)\nthis:\n  b < mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A\n 2. is_zero_row_upt_k (mod_type_class.from_nat (Suc n))\n     (mod_type_class.to_nat (mod_type_class.from_nat k)) A", "show \"is_zero_row_upt_k i (to_nat (from_nat k::'c)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A", "unfolding to_nat_from_nat_id[OF Suc.prems(4)[unfolded ncols_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "by (rule Suc.prems(5))"], ["proof (state)\nthis:\n  is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k)) A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n))\n     (mod_type_class.to_nat (mod_type_class.from_nat k)) A", "show \"is_zero_row_upt_k (from_nat (Suc n)) (to_nat (from_nat k::'c)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n))\n     (mod_type_class.to_nat (mod_type_class.from_nat k)) A", "unfolding to_nat_from_nat_id[OF Suc.prems(4)[unfolded ncols_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "by (metis Suc.prems(2) Suc.prems(5) Suc.prems(6) add_to_nat_def\n          echelon_form_upt_k_condition1 from_nat_mono i_le_n monoid_add_class.add.right_neutral \n          nrows_def to_nat_0)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat (Suc n))\n   (mod_type_class.to_nat (mod_type_class.from_nat k)) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  a $\n  b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "finally"], ["proof (chain)\npicking this:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b", "show ?thesis"], ["proof (prove)\nusing this:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "."], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bezout_iterate_preserves_below_n:\n  assumes e: \"echelon_form_upt_k A k\"\n  and ib: \"is_bezout_ext bezout\"\n  and Aik_0: \"A $ i $ from_nat k \\<noteq> 0\"\n  and n: \"n<nrows A\"\n  and n_less_a: \"n < to_nat a\"\n  and k: \"k<ncols A\"\n  and i_le_n: \"to_nat i \\<le> n\"\n  and zero_upt_k_i: \"is_zero_row_upt_k i k A\"\n  shows \"bezout_iterate A n i (from_nat k) bezout $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A n i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "using Aik_0 n i_le_n k zero_upt_k_i e n_less_a"], ["proof (prove)\nusing this:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  n < nrows A\n  mod_type_class.to_nat i \\<le> n\n  k < ncols A\n  is_zero_row_upt_k i k A\n  echelon_form_upt_k A k\n  n < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. bezout_iterate A n i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        0 < nrows A; mod_type_class.to_nat i \\<le> 0; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k;\n        0 < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A 0 i (mod_type_class.from_nat k)\n                          bezout $\n                         a $\n                         b =\n                         A $ a $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n;\n                    k < ncols A; is_zero_row_upt_k i k A;\n                    echelon_form_upt_k A k;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     b =\n                                     A $ a $ b;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k;\n        Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         b =\n                         A $ a $ b", "case 0"], ["proof (state)\nthis:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  0 < nrows A\n  mod_type_class.to_nat i \\<le> 0\n  k < ncols A\n  is_zero_row_upt_k i k A\n  echelon_form_upt_k A k\n  0 < mod_type_class.to_nat a\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        0 < nrows A; mod_type_class.to_nat i \\<le> 0; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k;\n        0 < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A 0 i (mod_type_class.from_nat k)\n                          bezout $\n                         a $\n                         b =\n                         A $ a $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n;\n                    k < ncols A; is_zero_row_upt_k i k A;\n                    echelon_form_upt_k A k;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     b =\n                                     A $ a $ b;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k;\n        Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         b =\n                         A $ a $ b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A 0 i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b = A $ a $ b", ".."], ["proof (state)\nthis:\n  bezout_iterate A 0 i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n;\n                    k < ncols A; is_zero_row_upt_k i k A;\n                    echelon_form_upt_k A k;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     b =\n                                     A $ a $ b;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k;\n        Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         b =\n                         A $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n;\n                    k < ncols A; is_zero_row_upt_k i k A;\n                    echelon_form_upt_k A k;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     b =\n                                     A $ a $ b;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k;\n        Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         b =\n                         A $ a $ b", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>?A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n   n < nrows ?A; mod_type_class.to_nat i \\<le> n; k < ncols ?A;\n   is_zero_row_upt_k i k ?A; echelon_form_upt_k ?A k;\n   n < mod_type_class.to_nat a\\<rbrakk>\n  \\<Longrightarrow> bezout_iterate ?A n i (mod_type_class.from_nat k)\n                     bezout $\n                    a $\n                    b =\n                    ?A $ a $ b\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  Suc n < nrows A\n  mod_type_class.to_nat i \\<le> Suc n\n  k < ncols A\n  is_zero_row_upt_k i k A\n  echelon_form_upt_k A k\n  Suc n < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < nrows A; mod_type_class.to_nat i \\<le> n;\n                    k < ncols A; is_zero_row_upt_k i k A;\n                    echelon_form_upt_k A k;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     b =\n                                     A $ a $ b;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n; k < ncols A;\n        is_zero_row_upt_k i k A; echelon_form_upt_k A k;\n        Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         b =\n                         A $ a $ b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "proof (cases \"Suc n = to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "case True"], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    b =\n    A $ a $ b", "using True"], ["proof (prove)\nusing this:\n  Suc n = mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    b =\n    A $ a $ b", "by simp"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "case False"], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "have i_not_fn:\" i \\<noteq> from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)", "by (metis False Suc.prems(2) nrows_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat (Suc n)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "let ?B=\"(bezout_matrix A i (from_nat (Suc n)) (from_nat k) bezout ** A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "have i_le_n: \"to_nat i < Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc n", "by (metis False Suc.prems(3) le_imp_less_or_eq)"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "have zero_ikB: \"is_zero_row_upt_k i k ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "fix j::'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "assume j_k: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "have j_k2: \"j < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id j_k k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "have \"?B $ i $ j = A $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    j =\n    A $ i $ j", "proof (rule bezout_matrix_preserves_previous_columns[OF ib i_not_fn Suc.prems(1) j_k2], \n          unfold to_nat_from_nat_id[OF Suc.prems(4)[unfolded ncols_def]])"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A\n 2. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "show \"is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "by (rule Suc.prems(5))"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "show \"is_zero_row_upt_k (from_nat (Suc n)) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "using echelon_form_upt_k_condition1[OF Suc.prems(6) Suc.prems(5)]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "by (metis Suc.prems(2) from_nat_mono from_nat_to_nat_id i_le_n nrows_def)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  A $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  A $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "by (metis Suc.prems(5) is_zero_row_upt_k_def j_k)"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  (0::'a)", "show \"?B $ i $ j = 0\""], ["proof (prove)\nusing this:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    j =\n    (0::'a)", "."], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "have \"bezout_iterate A (Suc n) i (from_nat k) bezout $ a $ b \n      = bezout_iterate ?B n i (from_nat k) bezout $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    b", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    b =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    b", "using i_le_n"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    b =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    b", "by auto"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "have \"... = ?B $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    b =\n    (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    a $\n    b", "proof (rule Suc.hyps)"], ["proof (state)\ngoal (7 subgoals):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 3. mod_type_class.to_nat i \\<le> n\n 4. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 5. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n 6. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k\n 7. n < mod_type_class.to_nat a", "show \"?B $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis Suc.prems(1) bezout_matrix_not_zero i_not_fn ib)"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (6 subgoals):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 2. mod_type_class.to_nat i \\<le> n\n 3. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 4. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n 5. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k\n 6. n < mod_type_class.to_nat a", "show \"n < nrows ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "by (metis Suc.prems(2) Suc_lessD nrows_def)"], ["proof (state)\nthis:\n  n < nrows\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A)\n\ngoal (5 subgoals):\n 1. mod_type_class.to_nat i \\<le> n\n 2. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 3. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n 4. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k\n 5. n < mod_type_class.to_nat a", "show \"to_nat i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> n", "by (metis i_le_n less_Suc_eq_le)"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> n\n\ngoal (4 subgoals):\n 1. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 2. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n 3. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k\n 4. n < mod_type_class.to_nat a", "show \"k < ncols ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "by (metis Suc.prems(4) ncols_def)"], ["proof (state)\nthis:\n  k < ncols\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A)\n\ngoal (3 subgoals):\n 1. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n 2. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k\n 3. n < mod_type_class.to_nat a", "show \"is_zero_row_upt_k i k ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "by (rule zero_ikB)"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n\ngoal (2 subgoals):\n 1. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k\n 2. n < mod_type_class.to_nat a", "show \"echelon_form_upt_k ?B k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k", "proof (rule echelon_form_upt_k_bezout_matrix[OF Suc.prems(6) ib \n          Suc.prems(1) Suc.prems(5) _ Suc.prems(4)])"], ["proof (state)\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "show \"i < from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "by (metis (no_types) Suc.prems(7) add_to_nat_def dual_order.strict_iff_order from_nat_mono\n            i_le_n le_less_trans monoid_add_class.add.right_neutral to_nat_0 to_nat_less_card)"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   k\n\ngoal (1 subgoal):\n 1. n < mod_type_class.to_nat a", "show \"n < to_nat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < mod_type_class.to_nat a", "by (metis Suc.prems(7) Suc_lessD)"], ["proof (state)\nthis:\n  n < mod_type_class.to_nat a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  b =\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  b =\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "have \"... = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    a $\n    b =\n    A $ a $ b", "proof (rule bezout_matrix_preserves_rest[OF ib _ _ _ Suc.prems(1)])"], ["proof (state)\ngoal (4 subgoals):\n 1. a \\<noteq> mod_type_class.from_nat (Suc n)\n 2. i \\<noteq> mod_type_class.from_nat (Suc n)\n 3. a \\<noteq> i\n 4. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A", "show \"a \\<noteq> from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> mod_type_class.from_nat (Suc n)", "by (metis Suc.prems(7) add_to_nat_def from_nat_mono less_irrefl\n          monoid_add_class.add.right_neutral to_nat_0 to_nat_less_card)"], ["proof (state)\nthis:\n  a \\<noteq> mod_type_class.from_nat (Suc n)\n\ngoal (3 subgoals):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)\n 2. a \\<noteq> i\n 3. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A", "show \"i \\<noteq> from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)", "by (rule i_not_fn)"], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat (Suc n)\n\ngoal (2 subgoals):\n 1. a \\<noteq> i\n 2. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A", "show \"a \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> i", "by (metis assms(7) n_less_a not_le)"], ["proof (state)\nthis:\n  a \\<noteq> i\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A", "show \"is_zero_row_upt_k i (to_nat (from_nat k::'b)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k))\n     A", "by (metis Suc.prems(4) Suc.prems(5) ncols_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  is_zero_row_upt_k i (mod_type_class.to_nat (mod_type_class.from_nat k)) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  a $\n  b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "finally"], ["proof (chain)\npicking this:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b", "show ?thesis"], ["proof (prove)\nusing this:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n    A $ a $ b", "."], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $ b =\n  A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bezout_iterate_zero_column_k:\n  fixes A::\"'a::bezout_domain^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and ib: \"is_bezout_ext bezout\"\n  and Aik_0: \"A $ i $ from_nat k \\<noteq> 0\"\n  and n: \"n<nrows A\"\n  and i_le_a: \"i<a\"\n  and k: \"k<ncols A\"\n  and a_n: \"to_nat a\\<le>n\"\n  and zero_upt_k_i: \"is_zero_row_upt_k i k A\"\n  shows \"bezout_iterate A n i (from_nat k) bezout $ a $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A n i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "using e Aik_0 n k a_n zero_upt_k_i"], ["proof (prove)\nusing this:\n  echelon_form_upt_k A k\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  n < nrows A\n  k < ncols A\n  mod_type_class.to_nat a \\<le> n\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. bezout_iterate A n i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>echelon_form_upt_k A k;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); 0 < nrows A;\n        k < ncols A; mod_type_class.to_nat a \\<le> 0;\n        is_zero_row_upt_k i k A\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A 0 i (mod_type_class.from_nat k)\n                          bezout $\n                         a $\n                         mod_type_class.from_nat k =\n                         (0::'a)\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>echelon_form_upt_k A k;\n                    A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n                    n < nrows A; k < ncols A;\n                    mod_type_class.to_nat a \\<le> n;\n                    is_zero_row_upt_k i k A\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     mod_type_class.from_nat k =\n                                     (0::'a);\n        echelon_form_upt_k A k;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        k < ncols A; mod_type_class.to_nat a \\<le> Suc n;\n        is_zero_row_upt_k i k A\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         mod_type_class.from_nat k =\n                         (0::'a)", "case 0"], ["proof (state)\nthis:\n  echelon_form_upt_k A k\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  0 < nrows A\n  k < ncols A\n  mod_type_class.to_nat a \\<le> 0\n  is_zero_row_upt_k i k A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>echelon_form_upt_k A k;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); 0 < nrows A;\n        k < ncols A; mod_type_class.to_nat a \\<le> 0;\n        is_zero_row_upt_k i k A\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A 0 i (mod_type_class.from_nat k)\n                          bezout $\n                         a $\n                         mod_type_class.from_nat k =\n                         (0::'a)\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>echelon_form_upt_k A k;\n                    A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n                    n < nrows A; k < ncols A;\n                    mod_type_class.to_nat a \\<le> n;\n                    is_zero_row_upt_k i k A\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     mod_type_class.from_nat k =\n                                     (0::'a);\n        echelon_form_upt_k A k;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        k < ncols A; mod_type_class.to_nat a \\<le> Suc n;\n        is_zero_row_upt_k i k A\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         mod_type_class.from_nat k =\n                         (0::'a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A 0 i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ mod_type_class.from_nat k = (0::'a)", "using \"0.prems\"(5) i_le_a to_nat_from_nat to_nat_le to_nat_mono"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a \\<le> 0\n  i < a\n  mod_type_class.to_nat ?j = ?k \\<Longrightarrow>\n  mod_type_class.from_nat ?k = ?j\n  ?y < mod_type_class.from_nat ?k \\<Longrightarrow>\n  mod_type_class.to_nat ?y < ?k\n  ?a < ?b \\<Longrightarrow>\n  mod_type_class.to_nat ?a < mod_type_class.to_nat ?b\n\ngoal (1 subgoal):\n 1. A $ a $ mod_type_class.from_nat k = (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  bezout_iterate A 0 i (mod_type_class.from_nat k) bezout $ a $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>echelon_form_upt_k A k;\n                    A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n                    n < nrows A; k < ncols A;\n                    mod_type_class.to_nat a \\<le> n;\n                    is_zero_row_upt_k i k A\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     mod_type_class.from_nat k =\n                                     (0::'a);\n        echelon_form_upt_k A k;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        k < ncols A; mod_type_class.to_nat a \\<le> Suc n;\n        is_zero_row_upt_k i k A\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         mod_type_class.from_nat k =\n                         (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>echelon_form_upt_k A k;\n                    A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n                    n < nrows A; k < ncols A;\n                    mod_type_class.to_nat a \\<le> n;\n                    is_zero_row_upt_k i k A\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     mod_type_class.from_nat k =\n                                     (0::'a);\n        echelon_form_upt_k A k;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        k < ncols A; mod_type_class.to_nat a \\<le> Suc n;\n        is_zero_row_upt_k i k A\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         mod_type_class.from_nat k =\n                         (0::'a)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>echelon_form_upt_k ?A k;\n   ?A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); n < nrows ?A;\n   k < ncols ?A; mod_type_class.to_nat a \\<le> n;\n   is_zero_row_upt_k i k ?A\\<rbrakk>\n  \\<Longrightarrow> bezout_iterate ?A n i (mod_type_class.from_nat k)\n                     bezout $\n                    a $\n                    mod_type_class.from_nat k =\n                    (0::'a)\n  echelon_form_upt_k A k\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  Suc n < nrows A\n  k < ncols A\n  mod_type_class.to_nat a \\<le> Suc n\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>echelon_form_upt_k A k;\n                    A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n                    n < nrows A; k < ncols A;\n                    mod_type_class.to_nat a \\<le> n;\n                    is_zero_row_upt_k i k A\\<rbrakk>\n                   \\<Longrightarrow> bezout_iterate A n i\n(mod_type_class.from_nat k) bezout $\n                                     a $\n                                     mod_type_class.from_nat k =\n                                     (0::'a);\n        echelon_form_upt_k A k;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a); Suc n < nrows A;\n        k < ncols A; mod_type_class.to_nat a \\<le> Suc n;\n        is_zero_row_upt_k i k A\\<rbrakk>\n       \\<Longrightarrow> bezout_iterate A (Suc n) i\n                          (mod_type_class.from_nat k) bezout $\n                         a $\n                         mod_type_class.from_nat k =\n                         (0::'a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "proof (cases \"Suc n = to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "using True"], ["proof (prove)\nusing this:\n  Suc n = mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "by (metis Suc.prems(5) i_le_a leD to_nat_mono)"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "have i_not_fn:\" i \\<noteq> from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)", "by (metis False Suc.prems(3) nrows_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat (Suc n)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "let ?B=\"(bezout_matrix A i (from_nat (Suc n)) (from_nat k) bezout ** A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "have i_le_n: \"to_nat i < Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc n", "by (metis Suc.prems(5) i_le_a le_less_trans not_le to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "have zero_ikB: \"is_zero_row_upt_k i k ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "fix j::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "assume j_k: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "have j_k2: \"j < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "using from_nat_mono[OF j_k Suc.prems(4)[unfolded ncols_def]]"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (mod_type_class.to_nat j)\n  < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "unfolding from_nat_to_nat_id"], ["proof (prove)\nusing this:\n  j < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "."], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "have \"?B $ i $ j = A $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    j =\n    A $ i $ j", "proof (rule bezout_matrix_preserves_previous_columns[OF ib i_not_fn Suc.prems(2) j_k2],\n          unfold to_nat_from_nat_id[OF Suc.prems(4)[unfolded ncols_def]])"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A\n 2. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "show \"is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "by (rule Suc.prems(6))"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "show \"is_zero_row_upt_k (from_nat (Suc n)) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "using echelon_form_upt_k_condition1[OF Suc.prems(1)]"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k ?i k A \\<Longrightarrow>\n  \\<not> (\\<exists>j>?i. \\<not> is_zero_row_upt_k j k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A", "by (metis (mono_tags) Suc.prems(3) Suc.prems(6) add_to_nat_def \n            from_nat_mono i_le_n monoid_add_class.add.right_neutral nrows_def to_nat_0)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat (Suc n)) k A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  A $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  A $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "by (metis Suc.prems(6) is_zero_row_upt_k_def j_k)"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A) $\n       i $\n       j =\n       (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  (0::'a)", "show \"?B $ i $ j = 0\""], ["proof (prove)\nusing this:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    j =\n    (0::'a)", "."], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "have \"bezout_iterate A (Suc n) i (from_nat k) bezout $ a $ (from_nat k) \n      = bezout_iterate ?B n i (from_nat k) bezout $ a $ (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    mod_type_class.from_nat k =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k", "using i_le_n"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) $\n    a $\n    mod_type_class.from_nat k =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k", "by auto"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n  mod_type_class.from_nat k =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n  mod_type_class.from_nat k =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "proof (cases \"to_nat a = Suc n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)\n 2. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat a = Suc n\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)\n 2. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "have \"bezout_iterate ?B n i (from_nat k) bezout $ a $ (from_nat k) = ?B $ a $ from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    a $\n    mod_type_class.from_nat k", "proof (rule bezout_iterate_preserves_below_n[OF _ ib])"], ["proof (state)\ngoal (7 subgoals):\n 1. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k\n 2. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 3. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 4. n < mod_type_class.to_nat a\n 5. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 6. mod_type_class.to_nat i \\<le> n\n 7. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"echelon_form_upt_k ?B k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k", "by (metis (erased, hide_lams) Suc.prems(1) Suc.prems(2) Suc.prems(4) Suc.prems(6) True\n            echelon_form_upt_k_bezout_matrix from_nat_to_nat_id i_le_a ib)"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   k\n\ngoal (6 subgoals):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 3. n < mod_type_class.to_nat a\n 4. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 5. mod_type_class.to_nat i \\<le> n\n 6. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"?B $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis Suc.prems(2) bezout_matrix_not_zero i_not_fn ib)"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (5 subgoals):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 2. n < mod_type_class.to_nat a\n 3. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 4. mod_type_class.to_nat i \\<le> n\n 5. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"n < nrows ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "by (metis Suc.prems(3) Suc_lessD nrows_def)"], ["proof (state)\nthis:\n  n < nrows\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A)\n\ngoal (4 subgoals):\n 1. n < mod_type_class.to_nat a\n 2. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 3. mod_type_class.to_nat i \\<le> n\n 4. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"n < to_nat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < mod_type_class.to_nat a", "by (metis True lessI)"], ["proof (state)\nthis:\n  n < mod_type_class.to_nat a\n\ngoal (3 subgoals):\n 1. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 2. mod_type_class.to_nat i \\<le> n\n 3. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"k < ncols ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "by (metis Suc.prems(4) ncols_def)"], ["proof (state)\nthis:\n  k < ncols\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i \\<le> n\n 2. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"to_nat i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> n", "by (metis i_le_n less_Suc_eq_le)"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> n\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"is_zero_row_upt_k i k ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "by (rule zero_ikB)"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  mod_type_class.from_nat k =\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  a $\n  mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)\n 2. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  mod_type_class.from_nat k =\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  a $\n  mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)\n 2. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "by (metis Suc.prems(2) True bezout_matrix_works2 \n           i_not_fn ib to_nat_from_nat)"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  a $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)\n 2. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  mod_type_class.from_nat k =\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "."], ["proof (state)\nthis:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  mod_type_class.to_nat a \\<noteq> Suc n\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "proof (rule Suc.hyps)"], ["proof (state)\ngoal (6 subgoals):\n 1. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k\n 2. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 3. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 4. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 5. mod_type_class.to_nat a \\<le> n\n 6. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"echelon_form_upt_k ?B k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     k", "proof (rule echelon_form_upt_k_bezout_matrix\n          [OF Suc.prems(1) ib Suc.prems(2) Suc.prems(6) _ Suc.prems(4)])"], ["proof (state)\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "show \"i < from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "by (metis (mono_tags) Suc.prems(3) from_nat_mono from_nat_to_nat_id i_le_n nrows_def)"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   k\n\ngoal (5 subgoals):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 3. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 4. mod_type_class.to_nat a \\<le> n\n 5. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"?B $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n      (mod_type_class.from_nat k) bezout **\n     A) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis Suc.prems(2) bezout_matrix_not_zero i_not_fn ib)"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n    (mod_type_class.from_nat k) bezout **\n   A) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (4 subgoals):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 2. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 3. mod_type_class.to_nat a \\<le> n\n 4. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"n < nrows ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "by (metis Suc.prems(3) Suc_lessD nrows_def)"], ["proof (state)\nthis:\n  n < nrows\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A)\n\ngoal (3 subgoals):\n 1. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)\n 2. mod_type_class.to_nat a \\<le> n\n 3. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"k < ncols ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "by (metis Suc.prems(4) ncols_def)"], ["proof (state)\nthis:\n  k < ncols\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a \\<le> n\n 2. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"to_nat a \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<le> n", "by (metis False Suc.prems(5) le_SucE)"], ["proof (state)\nthis:\n  mod_type_class.to_nat a \\<le> n\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "show \"is_zero_row_upt_k i k ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)", "by (rule zero_ikB)"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout $\n  a $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n  mod_type_class.from_nat k =\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n    mod_type_class.from_nat k =\n    (0::'a)", "."], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout $ a $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Proving the correctness\\<close>"], ["", "lemma condition1_index_le_zero_row: \n  fixes A k\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and \"is_zero_row_upt_k a (Suc k) A\"\n  shows \"from_nat i\\<le>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> a", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat i \\<le> a \\<Longrightarrow> False", "have zero_ik: \"is_zero_row_upt_k a k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k A", "by (metis assms(3) is_zero_row_upt_k_le)"], ["proof (state)\nthis:\n  is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat i \\<le> a \\<Longrightarrow> False", "assume a: \"\\<not> from_nat i \\<le> (a::'a)\""], ["proof (state)\nthis:\n  \\<not> mod_type_class.from_nat i \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat i \\<le> a \\<Longrightarrow> False", "hence ai: \"a < from_nat i\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.from_nat i \\<le> a\n\ngoal (1 subgoal):\n 1. a < mod_type_class.from_nat i", "by simp"], ["proof (state)\nthis:\n  a < mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat i \\<le> a \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"(from_nat i::'a)=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.from_nat i = (0::'a) \\<Longrightarrow> False\n 2. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  mod_type_class.from_nat i = (0::'a)\n\ngoal (2 subgoals):\n 1. mod_type_class.from_nat i = (0::'a) \\<Longrightarrow> False\n 2. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using ai least_mod_type[of a]"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i = (0::'a)\n  a < mod_type_class.from_nat i\n  (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. False", "unfolding True from_nat_0"], ["proof (prove)\nusing this:\n  (0::'a) = (0::'a)\n  a < (0::'a)\n  (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "from a"], ["proof (chain)\npicking this:\n  \\<not> mod_type_class.from_nat i \\<le> a", "have \"a \\<le> from_nat i - 1\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.from_nat i \\<le> a\n\ngoal (1 subgoal):\n 1. a \\<le> mod_type_class.from_nat i - (1::'a)", "by (intro leI) (auto dest: le_Suc)"], ["proof (state)\nthis:\n  a \\<le> mod_type_class.from_nat i - (1::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  a \\<le> mod_type_class.from_nat i - (1::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "from False"], ["proof (chain)\npicking this:\n  mod_type_class.from_nat i \\<noteq> (0::'a)", "have \"i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0", "by (intro notI) (simp_all add: from_nat_0)"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "hence \"i = (i - 1) + 1\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i = i - 1 + 1", "by simp"], ["proof (state)\nthis:\n  i = i - 1 + 1\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  i = i - 1 + 1\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "have \"from_nat \\<dots> = from_nat (i - 1) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (i - 1 + 1) =\n    mod_type_class.from_nat (i - 1) + (1::'d)", "by (rule from_nat_suc)"], ["proof (state)\nthis:\n  mod_type_class.from_nat (i - 1 + 1) =\n  mod_type_class.from_nat (i - 1) + (1::?'d1)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  a \\<le> mod_type_class.from_nat (i - 1) + (1::'a) - (1::'a)", "have ai2: \"a \\<le> from_nat (i - 1)\""], ["proof (prove)\nusing this:\n  a \\<le> mod_type_class.from_nat (i - 1) + (1::'a) - (1::'a)\n\ngoal (1 subgoal):\n 1. a \\<le> mod_type_class.from_nat (i - 1)", "by simp"], ["proof (state)\nthis:\n  a \\<le> mod_type_class.from_nat (i - 1)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "have \"i = to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using i False"], ["proof (prove)\nusing this:\n  i \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n  mod_type_class.from_nat i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. i =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by (metis from_nat_0)"], ["proof (state)\nthis:\n  i = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "hence \"i - 1 = to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (prove)\nusing this:\n  i = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. i - 1 =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "by simp"], ["proof (state)\nthis:\n  i - 1 = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "hence \"from_nat (i - 1) = (GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (prove)\nusing this:\n  i - 1 = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (i - 1) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "using from_nat_to_nat_id"], ["proof (prove)\nusing this:\n  i - 1 = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  mod_type_class.from_nat (mod_type_class.to_nat ?x) = ?x\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (i - 1) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "by auto"], ["proof (state)\nthis:\n  mod_type_class.from_nat (i - 1) =\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "hence \"\\<not> is_zero_row_upt_k (from_nat (i - 1)) k A\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (i - 1) =\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A", "using False GreatestI_ex i"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (i - 1) =\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  mod_type_class.from_nat i \\<noteq> (0::'a)\n  \\<exists>x. ?P x \\<Longrightarrow> ?P (Greatest ?P)\n  i \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A", "by (metis from_nat_to_nat_id to_nat_0)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "have \"is_zero_row_upt_k (from_nat (i - 1)) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A", "using echelon_form_upt_k_condition1[OF e zero_ik]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j>a. \\<not> is_zero_row_upt_k j k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A", "using ai2 zero_ik"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j>a. \\<not> is_zero_row_upt_k j k A)\n  a \\<le> mod_type_class.from_nat (i - 1)\n  is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A", "by (cases \"a = from_nat (i - 1)\", auto)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'a) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A\n  is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A", "show False"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A\n  is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition1_part1: \n  fixes A k\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n    else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and a: \"is_zero_row_upt_k a (Suc k) A\"\n  and ab: \"a < b\"\n  and all_zero: \"\\<forall>m\\<ge>from_nat i. A $ m $ from_nat k = 0\"\n  shows \"is_zero_row_upt_k b (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "proof (rule is_zero_row_upt_k_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k A\n 2. A $ b $ mod_type_class.from_nat k = (0::'b)", "have zero_ik: \"is_zero_row_upt_k a k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k A", "by (metis assms(3) is_zero_row_upt_k_le)"], ["proof (state)\nthis:\n  is_zero_row_upt_k a k A\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k A\n 2. A $ b $ mod_type_class.from_nat k = (0::'b)", "show \"is_zero_row_upt_k b k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k A", "using echelon_form_upt_k_condition1[OF e zero_ik]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j>a. \\<not> is_zero_row_upt_k j k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k A", "using ab"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j>a. \\<not> is_zero_row_upt_k j k A)\n  a < b\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k A", "by auto"], ["proof (state)\nthis:\n  is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k = (0::'b)", "have \"from_nat i\\<le>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> a", "using condition1_index_le_zero_row[OF e a] all_zero"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1)\n  \\<le> a\n  \\<forall>m\\<ge>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'b)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> a", "unfolding i"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1)\n  \\<le> a\n  \\<forall>m\\<ge>mod_type_class.from_nat\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1).\n     A $ m $ mod_type_class.from_nat k = (0::'b)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (if \\<forall>m. is_zero_row_upt_k m k A then 0\n      else mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1)\n    \\<le> a", "by auto"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> a\n\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k = (0::'b)", "thus \"A $ b $ from_nat k = 0\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<le> a\n\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k = (0::'b)", "using all_zero ab"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<le> a\n  \\<forall>m\\<ge>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'b)\n  a < b\n\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k = (0::'b)", "by auto"], ["proof (state)\nthis:\n  A $ b $ mod_type_class.from_nat k = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition1_part2: \n  fixes A k\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and a: \"is_zero_row_upt_k a (Suc k) A\"\n  and ab: \"a < b\"\n  and i_last: \"i = nrows A\"\n  and all_zero: \"\\<forall>m>from_nat (nrows A). A $ m $ from_nat k = 0\"\n  shows \"is_zero_row_upt_k b (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "have zero_ik: \"is_zero_row_upt_k a k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k A", "by (metis assms(3) is_zero_row_upt_k_le)"], ["proof (state)\nthis:\n  is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "have i_le_a: \"from_nat i\\<le>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> a", "using condition1_index_le_zero_row[OF e a]"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1)\n  \\<le> a\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> a", "unfolding i"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1)\n  \\<le> a\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (if \\<forall>m. is_zero_row_upt_k m k A then 0\n      else mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1)\n    \\<le> a", "."], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> a\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "have \"(from_nat (nrows A)::'a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (nrows A) = (0::'a)", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat CARD('a) = (0::'a)", "using from_nat_CARD"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat CARD(?'a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat CARD('a) = (0::'a)", "."], ["proof (state)\nthis:\n  mod_type_class.from_nat (nrows A) = (0::'a)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (nrows A) = (0::'a)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "using ab i_last i_le_a"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (nrows A) = (0::'a)\n  a < b\n  i = nrows A\n  mod_type_class.from_nat i \\<le> a\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "by (metis all_zero e echelon_form_upt_k_condition1 is_zero_row_upt_k_suc le_less_trans zero_ik)"], ["proof (state)\nthis:\n  is_zero_row_upt_k b (Suc k) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition1_part3:\n  fixes A k bezout\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B: \"B \\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes e: \"echelon_form_upt_k A k\" and ib: \"is_bezout_ext bezout\"\n  and a: \"is_zero_row_upt_k a (Suc k) B\"\n  and \"a < b\"\n  and all_zero: \"\\<forall>m>from_nat i. A $ m $ from_nat k = 0\"\n  and i_not_last: \"i \\<noteq> nrows A\"\n  and i_le_m: \"from_nat i \\<le> m\"\n  and Amk_not_0: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"is_zero_row_upt_k b (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "proof (rule is_zero_row_upt_k_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k A\n 2. A $ b $ mod_type_class.from_nat k = (0::'b)", "have AB: \"A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "unfolding B echelon_form_of_column_k_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A =\n    fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'b)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'b)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'b) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1))", "using all_zero"], ["proof (prove)\nusing this:\n  \\<forall>m>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'b)\n\ngoal (1 subgoal):\n 1. A =\n    fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'b)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'b)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'b) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1))", "by auto"], ["proof (state)\nthis:\n  A = B\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k A\n 2. A $ b $ mod_type_class.from_nat k = (0::'b)", "have i_le_a: \"from_nat i\\<le>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> a", "using condition1_index_le_zero_row[OF e a[unfolded AB[symmetric]]]"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1)\n  \\<le> a\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> a", "unfolding i"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1)\n  \\<le> a\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (if \\<forall>m. is_zero_row_upt_k m k A then 0\n      else mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1)\n    \\<le> a", "."], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> a\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k A\n 2. A $ b $ mod_type_class.from_nat k = (0::'b)", "show \"A $ b $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k = (0::'b)", "by (metis i_le_a all_zero assms(6) le_less_trans)"], ["proof (state)\nthis:\n  A $ b $ mod_type_class.from_nat k = (0::'b)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k A", "show \"is_zero_row_upt_k b k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k A", "by (metis (poly_guards_query) AB a assms(6) e \n        echelon_form_upt_k_condition1 is_zero_row_upt_k_le)"], ["proof (state)\nthis:\n  is_zero_row_upt_k b k A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition1_part4:\n  fixes A k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B: \"B\\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  assumes a: \"is_zero_row_upt_k a (Suc k) A\"\n  and i_nrows: \"i = nrows A\"\n  shows \"is_zero_row_upt_k b (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "have eq_G: \"from_nat (i - 1) = (GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (i - 1) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "by (metis One_nat_def Suc_eq_plus1 i_nrows diff_Suc_Suc \n        diff_zero from_nat_to_nat_id i nrows_not_0)"], ["proof (state)\nthis:\n  mod_type_class.from_nat (i - 1) =\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "hence a_le: \"a\\<le>from_nat (i - 1)\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (i - 1) =\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. a \\<le> mod_type_class.from_nat (i - 1)", "by (metis One_nat_def Suc_pred i_nrows lessI not_less not_less_eq nrows_def \n      to_nat_from_nat_id to_nat_less_card to_nat_mono zero_less_card_finite)"], ["proof (state)\nthis:\n  a \\<le> mod_type_class.from_nat (i - 1)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "have not_zero_G: \"\\<not> is_zero_row_upt_k (from_nat(i - 1)) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A", "unfolding eq_G"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (GREATEST n. \\<not> is_zero_row_upt_k n k A) k\n            A", "by (metis (mono_tags) GreatestI_ex i_nrows i nrows_not_0)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "hence \"\\<not> is_zero_row_upt_k a k A\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k (mod_type_class.from_nat (i - 1)) k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "by (metis a_le dual_order.strict_iff_order e echelon_form_upt_k_condition1)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "hence \"\\<not> is_zero_row_upt_k a (Suc k) A\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a (Suc k) A", "by (metis is_zero_row_upt_k_le)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a (Suc k) A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a (Suc k) A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "using a"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a (Suc k) A\n  is_zero_row_upt_k a (Suc k) A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "by contradiction"], ["proof (state)\nthis:\n  is_zero_row_upt_k b (Suc k) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition1_part5:\n  fixes A::\"'a::bezout_domain^'cols::{mod_type}^'rows::{mod_type}\"\n  and k bezout\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n    else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B: \"B \\<equiv> fst((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes ib: \"is_bezout_ext bezout\" and e: \"echelon_form_upt_k A k\"\n  assumes zero_a_B: \"is_zero_row_upt_k a (Suc k) B\"\n  and ab: \"a < b\"\n  and im: \"from_nat i < m\"\n  and Amk_not_0: \"A $ m $ from_nat k \\<noteq> 0\"\n  and not_last_row: \"i \\<noteq> nrows A\"\n  and k: \"k<ncols A\"\n  shows \"is_zero_row_upt_k b (Suc k) (bezout_iterate \n  (interchange_rows A (from_nat i) (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (from_nat i) \\<le> n)) \n  (nrows A - Suc 0) (from_nat i) (from_nat k) bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k)\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)", "proof (rule is_zero_row_upt_k_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "let ?least=\"(LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n)\""], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "let ?interchange=\"(interchange_rows A (from_nat i) ?least)\""], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "let ?bezout_iterate=\"(bezout_iterate ?interchange \n    (nrows A - Suc 0) (from_nat i) (from_nat k) bezout)\""], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "have B_eq: \"B = ?bezout_iterate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "unfolding B echelon_form_of_column_k_def\n    Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "using im Amk_not_0 not_last_row"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i < m\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  i \\<noteq> nrows A\n\ngoal (1 subgoal):\n 1. fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "by auto"], ["proof (state)\nthis:\n  B =\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "have zero_ikA: \"is_zero_row_upt_k (from_nat i) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k A", "proof (cases \"\\<forall>m. is_zero_row_upt_k m k A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>m. is_zero_row_upt_k m k A \\<Longrightarrow>\n    is_zero_row_upt_k (mod_type_class.from_nat i) k A\n 2. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    is_zero_row_upt_k (mod_type_class.from_nat i) k A", "case True"], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (2 subgoals):\n 1. \\<forall>m. is_zero_row_upt_k m k A \\<Longrightarrow>\n    is_zero_row_upt_k (mod_type_class.from_nat i) k A\n 2. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    is_zero_row_upt_k (mod_type_class.from_nat i) k A", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k A", "by simp"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    is_zero_row_upt_k (mod_type_class.from_nat i) k A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    is_zero_row_upt_k (mod_type_class.from_nat i) k A", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    is_zero_row_upt_k (mod_type_class.from_nat i) k A", "hence i_eq: \"i=to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. i =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding i"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by auto"], ["proof (state)\nthis:\n  i = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    is_zero_row_upt_k (mod_type_class.from_nat i) k A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k A", "proof (rule row_greater_greatest_is_zero, simp add: i_eq from_nat_to_nat_greatest,rule Suc_le')"], ["proof (state)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "show \" (GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "have \"\\<And>x\\<^sub>1. \\<not> x\\<^sub>1 < i \\<or> \\<not> to_nat (GREATEST R. \\<not> is_zero_row_upt_k R k A) < x\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>1.\n       \\<not> x\\<^sub>1 < i \\<or>\n       \\<not> mod_type_class.to_nat\n               (GREATEST R. \\<not> is_zero_row_upt_k R k A)\n              < x\\<^sub>1", "using i_eq"], ["proof (prove)\nusing this:\n  i = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>1.\n       \\<not> x\\<^sub>1 < i \\<or>\n       \\<not> mod_type_class.to_nat\n               (GREATEST R. \\<not> is_zero_row_upt_k R k A)\n              < x\\<^sub>1", "by linarith"], ["proof (state)\nthis:\n  \\<not> ?x\\<^sub>1 < i \\<or>\n  \\<not> mod_type_class.to_nat (GREATEST R. \\<not> is_zero_row_upt_k R k A)\n         < ?x\\<^sub>1\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "thus \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> ?x\\<^sub>1 < i \\<or>\n  \\<not> mod_type_class.to_nat (GREATEST R. \\<not> is_zero_row_upt_k R k A)\n         < ?x\\<^sub>1\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "by (metis One_nat_def add_Suc_right neq_iff \n            from_nat_to_nat_greatest i_eq monoid_add_class.add.right_neutral \n            nat.distinct(1) not_last_row nrows_def to_nat_0 to_nat_from_nat_id to_nat_less_card)"], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<noteq>\n  (0::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<noteq>\n  (0::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k A\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "have zero_interchange: \"is_zero_row_upt_k (from_nat i) k ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       mod_type_class.from_nat i $\n       j =\n       (0::'a)", "fix j::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       mod_type_class.from_nat i $\n       j =\n       (0::'a)", "assume j_less_k: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       mod_type_class.from_nat i $\n       j =\n       (0::'a)", "have i_le_least: \"from_nat i\\<le>?least\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i\n    \\<le> (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n)", "by (metis (mono_tags, lifting) Amk_not_0 LeastI2_wellorder less_imp_le im)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i\n  \\<le> (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       mod_type_class.from_nat i $\n       j =\n       (0::'a)", "hence zero_least_kA: \"is_zero_row_upt_k ?least k A\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i\n  \\<le> (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n)\n     k A", "using echelon_form_upt_k_condition1[OF e zero_ikA]"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i\n  \\<le> (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n)\n  \\<not> (\\<exists>j>mod_type_class.from_nat i.\n             \\<not> is_zero_row_upt_k j k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n)\n     k A", "by (metis (poly_guards_query) dual_order.strict_iff_order zero_ikA)"], ["proof (state)\nthis:\n  is_zero_row_upt_k\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n   k A\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       mod_type_class.from_nat i $\n       j =\n       (0::'a)", "have \"?interchange $ from_nat i $ j = A $ ?least $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    j =\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    j", "by simp"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  j =\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n) $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       mod_type_class.from_nat i $\n       j =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  j =\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n) $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       mod_type_class.from_nat i $\n       j =\n       (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    j =\n    (0::'a)", "using zero_least_kA j_less_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n   k A\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    j =\n    (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n     j =\n     (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    j =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n) $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       mod_type_class.from_nat i $\n       j =\n       (0::'a)", "finally"], ["proof (chain)\npicking this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  j =\n  (0::'a)", "show \"?interchange $ from_nat i $ j = 0\""], ["proof (prove)\nusing this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    j =\n    (0::'a)", "."], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "have zero_a_k: \"is_zero_row_upt_k a k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k A", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ a $ j = (0::'a)", "fix j::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ a $ j = (0::'a)", "assume j_less_k: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ a $ j = (0::'a)", "have \"?interchange $ a $ j = ?bezout_iterate $ a $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    j =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    a $\n    j", "proof (rule bezout_iterate_preserves[symmetric])"], ["proof (state)\ngoal (8 subgoals):\n 1. echelon_form_upt_k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     k\n 2. is_bezout_ext bezout\n 3. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 4. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 5. j < mod_type_class.from_nat k\n 6. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 7. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 8. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"echelon_form_upt_k ?interchange k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     k", "proof (rule echelon_form_upt_k_interchange[OF e zero_ikA Amk_not_0 _ k])"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "show \"from_nat i \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "using im"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i < m\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "by auto"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   k\n\ngoal (7 subgoals):\n 1. is_bezout_ext bezout\n 2. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 3. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 4. j < mod_type_class.from_nat k\n 5. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 6. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 7. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"is_bezout_ext bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bezout_ext bezout", "using ib"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n\ngoal (1 subgoal):\n 1. is_bezout_ext bezout", "."], ["proof (state)\nthis:\n  is_bezout_ext bezout\n\ngoal (6 subgoals):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 3. j < mod_type_class.from_nat k\n 4. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 5. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 6. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"?interchange $ (from_nat i) $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) Amk_not_0 LeastI_ex dual_order.strict_iff_order \n          im interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (5 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 2. j < mod_type_class.from_nat k\n 3. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 4. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 5. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"nrows A - Suc 0 < nrows ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n\ngoal (4 subgoals):\n 1. j < mod_type_class.from_nat k\n 2. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 3. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 4. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"j < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id j_less_k k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (3 subgoals):\n 1. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 2. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 3. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"to_nat (from_nat i::'rows) \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0", "by (metis Suc_eq_plus1 Suc_le_mono Suc_pred \n          discrete nrows_def to_nat_less_card zero_less_card_finite)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n\ngoal (2 subgoals):\n 1. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 2. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"k < ncols ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))", "using k"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  k < CARD('cols)\n\ngoal (1 subgoal):\n 1. k < CARD('cols)", "by auto"], ["proof (state)\nthis:\n  k < ncols\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"is_zero_row_upt_k (from_nat i) k ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "using zero_interchange"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "."], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  j =\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout $\n  a $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ a $ j = (0::'a)", "also"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  j =\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout $\n  a $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ a $ j = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    a $\n    j =\n    (0::'a)", "using zero_a_B j_less_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k a (Suc k) B\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    a $\n    j =\n    (0::'a)", "unfolding B_eq is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < Suc k \\<longrightarrow>\n     bezout_iterate\n      (interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n))\n      (nrows A - Suc 0) (mod_type_class.from_nat i)\n      (mod_type_class.from_nat k) bezout $\n     a $\n     j =\n     (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    a $\n    j =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout $\n  a $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ a $ j = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  j =\n  (0::'a)", "have *: \"?interchange $ a $ j = 0\""], ["proof (prove)\nusing this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    j =\n    (0::'a)", "."], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ a $ j = (0::'a)", "show \"A $ a $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ j = (0::'a)", "proof (cases \"a=from_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat i \\<Longrightarrow> A $ a $ j = (0::'a)\n 2. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "case True"], ["proof (state)\nthis:\n  a = mod_type_class.from_nat i\n\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat i \\<Longrightarrow> A $ a $ j = (0::'a)\n 2. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ j = (0::'a)", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ j = (0::'a)", "using zero_ikA j_less_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k A\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ j = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     A $ mod_type_class.from_nat i $ j = (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ j = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ a $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "note a_not_i=False"], ["proof (state)\nthis:\n  a \\<noteq> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. a \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ j = (0::'a)", "proof (cases \"a=?least\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ j = (0::'a)\n 2. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "case True"], ["proof (state)\nthis:\n  a =\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (2 subgoals):\n 1. a =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ j = (0::'a)\n 2. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ j = (0::'a)", "using zero_interchange"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. A $ a $ j = (0::'a)", "unfolding True is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     interchange_rows A (mod_type_class.from_nat i)\n      (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          mod_type_class.from_nat i \\<le> n) $\n     mod_type_class.from_nat i $\n     j =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    j =\n    (0::'a)", "using j_less_k"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     interchange_rows A (mod_type_class.from_nat i)\n      (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          mod_type_class.from_nat i \\<le> n) $\n     mod_type_class.from_nat i $\n     j =\n     (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    j =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ a $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "case False"], ["proof (state)\nthis:\n  a \\<noteq>\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "note a_not_least=False"], ["proof (state)\nthis:\n  a \\<noteq>\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "have \"?interchange $ a $ j = A $ a $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    j =\n    A $ a $ j", "using a_not_least a_not_i"], ["proof (prove)\nusing this:\n  a \\<noteq>\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n  a \\<noteq> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    j =\n    A $ a $ j", "by (metis (erased, lifting) interchange_rows_preserves)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  j =\n  A $ a $ j\n\ngoal (1 subgoal):\n 1. a \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    A $ a $ j = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  j =\n  A $ a $ j\n\ngoal (1 subgoal):\n 1. A $ a $ j = (0::'a)", "unfolding *"], ["proof (prove)\nusing this:\n  (0::'a) = A $ a $ j\n\ngoal (1 subgoal):\n 1. A $ a $ j = (0::'a)", ".."], ["proof (state)\nthis:\n  A $ a $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ a $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ a $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k a k A\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "hence zero_b_k: \"is_zero_row_upt_k b k A\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k A", "by (metis ab e echelon_form_upt_k_condition1)"], ["proof (state)\nthis:\n  is_zero_row_upt_k b k A\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "have i_le_a: \"from_nat i\\<le>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> a", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (if \\<forall>m. is_zero_row_upt_k m k A then 0\n      else mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1)\n    \\<le> a", "proof (auto simp add: from_nat_to_nat_greatest from_nat_0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>m. is_zero_row_upt_k m k A \\<Longrightarrow> (0::'rows) \\<le> a\n 2. \\<And>m.\n       \\<not> is_zero_row_upt_k m k A \\<Longrightarrow>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> a", "show \"0 \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'rows) \\<le> a", "by (metis least_mod_type)"], ["proof (state)\nthis:\n  (0::'rows) \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<not> is_zero_row_upt_k m k A \\<Longrightarrow>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> a", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<not> is_zero_row_upt_k m k A \\<Longrightarrow>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> a", "assume m: \"\\<not> is_zero_row_upt_k m k A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<not> is_zero_row_upt_k m k A \\<Longrightarrow>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> a", "have \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < a", "by (metis (no_types, lifting) GreatestI_ex neq_iff \n        e echelon_form_upt_k_condition1 m zero_a_k)"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < a\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<not> is_zero_row_upt_k m k A \\<Longrightarrow>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> a", "thus \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> a\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < a\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> a", "by (metis le_Suc)"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> a\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "have i_not_b: \"from_nat i \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> b", "using i_le_a ab"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<le> a\n  a < b\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> b", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<noteq> b\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "show \"is_zero_row_upt_k b k ?bezout_iterate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout $\n       b $\n       j =\n       (0::'a)", "fix j::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout $\n       b $\n       j =\n       (0::'a)", "assume j_less_k: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout $\n       b $\n       j =\n       (0::'a)", "have \"?bezout_iterate $ b $ j = ?interchange $ b $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    j =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j", "proof (rule bezout_iterate_preserves)"], ["proof (state)\ngoal (8 subgoals):\n 1. echelon_form_upt_k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     k\n 2. is_bezout_ext bezout\n 3. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 4. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 5. j < mod_type_class.from_nat k\n 6. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 7. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 8. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"echelon_form_upt_k ?interchange k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     k", "proof (rule echelon_form_upt_k_interchange[OF e zero_ikA Amk_not_0 _ k])"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "show \"from_nat i \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "using im"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i < m\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "by auto"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   k\n\ngoal (7 subgoals):\n 1. is_bezout_ext bezout\n 2. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 3. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 4. j < mod_type_class.from_nat k\n 5. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 6. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 7. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"is_bezout_ext bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bezout_ext bezout", "using ib"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n\ngoal (1 subgoal):\n 1. is_bezout_ext bezout", "."], ["proof (state)\nthis:\n  is_bezout_ext bezout\n\ngoal (6 subgoals):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 3. j < mod_type_class.from_nat k\n 4. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 5. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 6. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"?interchange $ from_nat i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) Amk_not_0 LeastI_ex \n          dual_order.strict_iff_order im interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (5 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 2. j < mod_type_class.from_nat k\n 3. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 4. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 5. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"nrows A - Suc 0 < nrows ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n\ngoal (4 subgoals):\n 1. j < mod_type_class.from_nat k\n 2. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 3. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 4. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"j < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id j_less_k k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (3 subgoals):\n 1. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 2. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 3. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"to_nat (from_nat i::'rows) \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0", "by (metis Suc_eq_plus1 Suc_le_mono Suc_pred \n          discrete nrows_def to_nat_less_card zero_less_card_finite)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n\ngoal (2 subgoals):\n 1. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 2. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"k < ncols ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))", "using k"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  k < CARD('cols)\n\ngoal (1 subgoal):\n 1. k < CARD('cols)", "by auto"], ["proof (state)\nthis:\n  k < ncols\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"is_zero_row_upt_k (from_nat i) k ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "by (rule zero_interchange)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout $\n  b $\n  j =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout $\n       b $\n       j =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout $\n  b $\n  j =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout $\n       b $\n       j =\n       (0::'a)", "have \"... = A $ b $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "proof (cases \"b=?least\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j\n 2. b \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "case True"], ["proof (state)\nthis:\n  b =\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (2 subgoals):\n 1. b =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j\n 2. b \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "have \"?interchange $ b $ j = A $ (from_nat i) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ mod_type_class.from_nat i $ j", "using True"], ["proof (prove)\nusing this:\n  b =\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ mod_type_class.from_nat i $ j", "by auto"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  A $ mod_type_class.from_nat i $ j\n\ngoal (2 subgoals):\n 1. b =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j\n 2. b \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "also"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  A $ mod_type_class.from_nat i $ j\n\ngoal (2 subgoals):\n 1. b =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j\n 2. b \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "have \"... = A $ b $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ j = A $ b $ j", "using zero_b_k zero_ikA j_less_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k b k A\n  is_zero_row_upt_k (mod_type_class.from_nat i) k A\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ j = A $ b $ j", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ b $ j = (0::'a)\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     A $ mod_type_class.from_nat i $ j = (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ j = A $ b $ j", "by auto"], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat i $ j = A $ b $ j\n\ngoal (2 subgoals):\n 1. b =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j\n 2. b \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "finally"], ["proof (chain)\npicking this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  A $ b $ j", "show ?thesis"], ["proof (prove)\nusing this:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  A $ b $ j\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "."], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  A $ b $ j\n\ngoal (1 subgoal):\n 1. b \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "case False"], ["proof (state)\nthis:\n  b \\<noteq>\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. b \\<noteq>\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "using False"], ["proof (prove)\nusing this:\n  b \\<noteq>\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "using interchange_rows_preserves[OF i_not_b]"], ["proof (prove)\nusing this:\n  b \\<noteq>\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n  ?j \\<noteq> b \\<Longrightarrow>\n  interchange_rows ?A (mod_type_class.from_nat i) ?j $ b = ?A $ b\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $ b $ j", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  A $ b $ j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  A $ b $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout $\n       b $\n       j =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  A $ b $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout $\n       b $\n       j =\n       (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ b $ j = (0::'a)", "using zero_b_k j_less_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k b k A\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ b $ j = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ b $ j = (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ b $ j = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ b $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout $\n       b $\n       j =\n       (0::'a)", "finally"], ["proof (chain)\npicking this:\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout $\n  b $\n  j =\n  (0::'a)", "show \"?bezout_iterate $ b $ j = 0\""], ["proof (prove)\nusing this:\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout $\n  b $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    j =\n    (0::'a)", "."], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout $\n  b $\n  j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k b k\n   (bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "show \"?bezout_iterate $ b $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    b $\n    mod_type_class.from_nat k =\n    (0::'a)", "proof (rule bezout_iterate_zero_column_k[OF _ ib])"], ["proof (state)\ngoal (7 subgoals):\n 1. echelon_form_upt_k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     k\n 2. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 3. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 4. mod_type_class.from_nat i < b\n 5. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 6. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 7. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"echelon_form_upt_k ?interchange k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     k", "proof (rule echelon_form_upt_k_interchange[OF e zero_ikA Amk_not_0 _ k])"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "show \"from_nat i \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "using im"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i < m\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "by auto"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   k\n\ngoal (6 subgoals):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 3. mod_type_class.from_nat i < b\n 4. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 5. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 6. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"?interchange $ from_nat i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) Amk_not_0 LeastI_ex \n        dual_order.strict_iff_order im interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (5 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 2. mod_type_class.from_nat i < b\n 3. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 4. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 5. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"nrows A - Suc 0 < nrows ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n\ngoal (4 subgoals):\n 1. mod_type_class.from_nat i < b\n 2. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 3. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 4. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"from_nat i < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < b", "by (metis ab i_le_a le_less_trans)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i < b\n\ngoal (3 subgoals):\n 1. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n 2. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 3. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"k < ncols ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))", "by (metis (full_types, lifting) k ncols_def)"], ["proof (state)\nthis:\n  k < ncols\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 2. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"to_nat b \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b \\<le> nrows A - Suc 0", "by (metis Suc_pred leD not_less_eq_eq nrows_def to_nat_less_card zero_less_card_finite)"], ["proof (state)\nthis:\n  mod_type_class.to_nat b \\<le> nrows A - Suc 0\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"is_zero_row_upt_k (from_nat i) k ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "by (rule zero_interchange)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout $\n  b $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition2_part1:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n    else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B:\"B \\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and ab: \"a < b\" and not_zero_aB: \"\\<not> is_zero_row_upt_k a (Suc k) B\" \n  and not_zero_bB: \"\\<not> is_zero_row_upt_k b (Suc k) B\"\n  and all_zero: \"\\<forall>m\\<ge>from_nat i. A $ m $ from_nat k = 0\" \n  shows \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B echelon_form_of_column_k_def Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    A", "using all_zero"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    A", "by auto"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "proof (cases \"\\<forall>m. is_zero_row_upt_k m k A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>m. is_zero_row_upt_k m k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "case True"], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (2 subgoals):\n 1. \\<forall>m. is_zero_row_upt_k m k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have i0: \"i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = 0", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    0", "using True"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    0", "by simp"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. \\<forall>m. is_zero_row_upt_k m k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have \"is_zero_row_upt_k a k B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k B", "using True"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k B", "unfolding B_eq_A"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k A", "by auto"], ["proof (state)\nthis:\n  is_zero_row_upt_k a k B\n\ngoal (2 subgoals):\n 1. \\<forall>m. is_zero_row_upt_k m k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "moreover"], ["proof (state)\nthis:\n  is_zero_row_upt_k a k B\n\ngoal (2 subgoals):\n 1. \\<forall>m. is_zero_row_upt_k m k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have \"B $ a $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ a $ mod_type_class.from_nat k = (0::'a)", "using all_zero"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. B $ a $ mod_type_class.from_nat k = (0::'a)", "unfolding i0 from_nat_0"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. B $ a $ mod_type_class.from_nat k = (0::'a)", "by (metis B_eq_A least_mod_type)"], ["proof (state)\nthis:\n  B $ a $ mod_type_class.from_nat k = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<forall>m. is_zero_row_upt_k m k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "ultimately"], ["proof (chain)\npicking this:\n  is_zero_row_upt_k a k B\n  B $ a $ mod_type_class.from_nat k = (0::'a)", "have \"is_zero_row_upt_k a (Suc k) B\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k a k B\n  B $ a $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a (Suc k) B", "by (rule is_zero_row_upt_k_suc)"], ["proof (state)\nthis:\n  is_zero_row_upt_k a (Suc k) B\n\ngoal (2 subgoals):\n 1. \\<forall>m. is_zero_row_upt_k m k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k a (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "using not_zero_aB"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k a (Suc k) B\n  \\<not> is_zero_row_upt_k a (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by contradiction"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "note not_all_zero=False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have i2: \"i = to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by auto"], ["proof (state)\nthis:\n  i = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have not_zero_aA: \"\\<not> is_zero_row_upt_k a k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "by (metis (erased, lifting) B_eq_A GreatestI_ex add_to_nat_def all_zero neq_iff e \n        echelon_form_upt_k_condition1 i2 is_zero_row_upt_k_suc le_Suc \n        not_all_zero not_zero_aB to_nat_1)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "moreover"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have not_zero_bA: \"\\<not> is_zero_row_upt_k b k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k b k A", "by (metis (erased, lifting) B_eq_A GreatestI_ex add_to_nat_def all_zero neq_iff e \n        echelon_form_upt_k_condition1 i2 is_zero_row_upt_k_suc le_Suc \n        not_all_zero not_zero_bB to_nat_1)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_zero_row_upt_k a k A\n  \\<not> is_zero_row_upt_k b k A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "using echelon_form_upt_k_condition2[OF e ab]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n  \\<not> is_zero_row_upt_k b k A\n  \\<lbrakk>\\<not> is_zero_row_upt_k a k A;\n   \\<not> is_zero_row_upt_k b k A\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition2_part2: \n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else \n  to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  assumes e: \"echelon_form_upt_k A k\"\n  and ab: \"a < b\"\n  and all_zero: \"\\<forall>m>from_nat (nrows A). A $ m $ from_nat k = 0\" \n  and i_nrows: \"i = nrows A\"\n  shows \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have not_all_zero: \"\\<not> (\\<forall>m. is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A)", "by (metis i i_nrows nrows_not_0)"], ["proof (state)\nthis:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) = (0::'rows)", "by (metis (mono_tags, lifting) add_0_right One_nat_def Suc_le' add_Suc_right i i_nrows \n      less_not_refl less_trans_Suc nrows_def to_nat_less_card to_nat_mono zero_less_card_finite)"], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "hence g_minus_1: \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) = - 1\""], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) = - (1::'rows)", "by (simp add: a_eq_minus_1)"], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) = - (1::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have \"\\<not> is_zero_row_upt_k a k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "proof (rule greatest_ge_nonzero_row'[OF e _ not_all_zero])"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "show \"a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "by (simp add: Greatest_is_minus_1 g_minus_1)"], ["proof (state)\nthis:\n  a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "moreover"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have \"\\<not> is_zero_row_upt_k b k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k b k A", "proof (rule greatest_ge_nonzero_row'[OF e _ not_all_zero])"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "show \"b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "by (simp add: Greatest_is_minus_1 g_minus_1)"], ["proof (state)\nthis:\n  b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_zero_row_upt_k a k A\n  \\<not> is_zero_row_upt_k b k A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "using echelon_form_upt_k_condition2[OF e ab]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n  \\<not> is_zero_row_upt_k b k A\n  \\<lbrakk>\\<not> is_zero_row_upt_k a k A;\n   \\<not> is_zero_row_upt_k b k A\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition2_part3:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n    else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B:\"B \\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes e: \"echelon_form_upt_k A k\" and k: \"k<ncols A\"\n  and ab: \"a < b\" and not_zero_aB: \"\\<not> is_zero_row_upt_k a (Suc k) B\" \n  and not_zero_bB: \"\\<not> is_zero_row_upt_k b (Suc k) B\"\n  and all_zero: \"\\<forall>m>from_nat i. A $ m $ from_nat k = 0\"\n  and i_ma: \"from_nat i \\<le> ma\" and A_ma_k: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B echelon_form_of_column_k_def Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    A", "using all_zero"], ["proof (prove)\nusing this:\n  \\<forall>m>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    A", "by simp"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have not_all_zero: \"\\<not> (\\<forall>m. is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A)", "by (metis B_eq_A ab all_zero from_nat_0 i is_zero_row_upt_k_suc \n      le_less_trans least_mod_type not_zero_bB)"], ["proof (state)\nthis:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have i2: \"i = to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_all_zero"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by auto"], ["proof (state)\nthis:\n  i = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have not_zero_aA: \"\\<not> is_zero_row_upt_k a k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "have \"\\<And>x\\<^sub>1 x\\<^sub>2. from_nat (to_nat (x\\<^sub>1::'rows) + 1) \\<le> x\\<^sub>2 \\<or> \\<not> x\\<^sub>1 < x\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>1 x\\<^sub>2.\n       mod_type_class.from_nat (mod_type_class.to_nat x\\<^sub>1 + 1)\n       \\<le> x\\<^sub>2 \\<or>\n       \\<not> x\\<^sub>1 < x\\<^sub>2", "by (metis (no_types) add_to_nat_def le_Suc to_nat_1)"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat ?x\\<^sub>1 + 1)\n  \\<le> ?x\\<^sub>2 \\<or>\n  \\<not> ?x\\<^sub>1 < ?x\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "moreover"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat ?x\\<^sub>1 + 1)\n  \\<le> ?x\\<^sub>2 \\<or>\n  \\<not> ?x\\<^sub>1 < ?x\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "{"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat ?x\\<^sub>1 + 1)\n  \\<le> ?x\\<^sub>2 \\<or>\n  \\<not> ?x\\<^sub>1 < ?x\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "assume \"\\<not> is_zero_row_upt_k b k A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "hence \"\\<not> is_zero_row_upt_k a k A\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "using ab e echelon_form_upt_k_condition1"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k b k A\n  a < b\n  echelon_form_upt_k A k\n  \\<lbrakk>echelon_form_upt_k ?A ?k; is_zero_row_upt_k ?i ?k ?A\\<rbrakk>\n  \\<Longrightarrow> \\<not> (\\<exists>j>?i. \\<not> is_zero_row_upt_k j ?k ?A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "}"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "ultimately"], ["proof (chain)\npicking this:\n  mod_type_class.from_nat (mod_type_class.to_nat ?x\\<^sub>1 + 1)\n  \\<le> ?x\\<^sub>2 \\<or>\n  \\<not> ?x\\<^sub>1 < ?x\\<^sub>2\n  \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n  \\<not> is_zero_row_upt_k a k A", "show \"\\<not> is_zero_row_upt_k a k A\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (mod_type_class.to_nat ?x\\<^sub>1 + 1)\n  \\<le> ?x\\<^sub>2 \\<or>\n  \\<not> ?x\\<^sub>1 < ?x\\<^sub>2\n  \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "by (metis B_eq_A greatest_less_zero_row ab all_zero le_imp_less_or_eq e i2 \n        is_zero_row_upt_k_suc not_all_zero not_zero_aB not_zero_bB)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "proof (cases \"\\<not> is_zero_row_upt_k b k A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "case True"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "using not_zero_aA echelon_form_upt_k_condition2[OF e ab]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k b k A\n  \\<not> is_zero_row_upt_k a k A\n  \\<lbrakk>\\<not> is_zero_row_upt_k a k A;\n   \\<not> is_zero_row_upt_k b k A\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "case False"], ["proof (state)\nthis:\n  \\<not> \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "note zero_bA=False"], ["proof (state)\nthis:\n  \\<not> \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "obtain v where Aav: \"A $ a $ v \\<noteq> 0\" and v: \"v<from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>A $ a $ v \\<noteq> (0::'a);\n         v < mod_type_class.from_nat k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_aA"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>A $ a $ v \\<noteq> (0::'a);\n         v < mod_type_class.from_nat k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ a $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>A $ a $ v \\<noteq> (0::'a);\n         v < mod_type_class.from_nat k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis from_nat_mono from_nat_to_nat_id k ncols_def)"], ["proof (state)\nthis:\n  A $ a $ v \\<noteq> (0::'a)\n  v < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have least_v: \"(LEAST n. A $ a $ n \\<noteq> 0) \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> v", "by (rule Least_le, simp add: Aav)"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> v\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have b_ge_greatest: \"b>(GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < b", "using False"], ["proof (prove)\nusing this:\n  \\<not> \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < b", "by (simp add: greatest_less_zero_row e not_all_zero)"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < b\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have i_eq_b: \"from_nat i = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i = b", "proof (rule ccontr, cases \"from_nat i < b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     \\<not> mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  mod_type_class.from_nat i < b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     \\<not> mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False", "hence Abk_0: \"A $ b $ from_nat k = 0\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i < b\n\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k = (0::'a)", "using all_zero"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i < b\n  \\<forall>m>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ b $ mod_type_class.from_nat k = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     \\<not> mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False", "have \"is_zero_row_upt_k b (Suc k) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) B", "proof (rule is_zero_row_upt_k_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k B\n 2. B $ b $ mod_type_class.from_nat k = (0::'a)", "show \"is_zero_row_upt_k b k B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k B", "using zero_bA"], ["proof (prove)\nusing this:\n  \\<not> \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k B", "unfolding B_eq_A"], ["proof (prove)\nusing this:\n  \\<not> \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k A", "by simp"], ["proof (state)\nthis:\n  is_zero_row_upt_k b k B\n\ngoal (1 subgoal):\n 1. B $ b $ mod_type_class.from_nat k = (0::'a)", "show \"B $ b $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ b $ mod_type_class.from_nat k = (0::'a)", "using Abk_0"], ["proof (prove)\nusing this:\n  A $ b $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. B $ b $ mod_type_class.from_nat k = (0::'a)", "unfolding B_eq_A"], ["proof (prove)\nusing this:\n  A $ b $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k = (0::'a)", "by simp"], ["proof (state)\nthis:\n  B $ b $ mod_type_class.from_nat k = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k b (Suc k) B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     \\<not> mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k b (Suc k) B\n\ngoal (1 subgoal):\n 1. False", "using not_zero_bB"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k b (Suc k) B\n  \\<not> is_zero_row_upt_k b (Suc k) B\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     \\<not> mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     \\<not> mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.from_nat i < b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     \\<not> mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False", "assume i_not_b: \"from_nat i \\<noteq> b\""], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     \\<not> mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False", "hence b_less_i: \"from_nat i > b\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<noteq> b\n\ngoal (1 subgoal):\n 1. b < mod_type_class.from_nat i", "using False"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<noteq> b\n  \\<not> mod_type_class.from_nat i < b\n\ngoal (1 subgoal):\n 1. b < mod_type_class.from_nat i", "by simp"], ["proof (state)\nthis:\n  b < mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mod_type_class.from_nat i \\<noteq> b;\n     \\<not> mod_type_class.from_nat i < b\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  b < mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. False", "using b_ge_greatest"], ["proof (prove)\nusing this:\n  b < mod_type_class.from_nat i\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < b\n\ngoal (1 subgoal):\n 1. False", "unfolding i"], ["proof (prove)\nusing this:\n  b < mod_type_class.from_nat\n       (if \\<forall>m. is_zero_row_upt_k m k A then 0\n        else mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n             1)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < b\n\ngoal (1 subgoal):\n 1. False", "by (metis (no_types, lifting) False Suc_less add_to_nat_def i2 i_not_b to_nat_1)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat i = b\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have Abk_not_0: \"A $ b $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)", "using False not_zero_bB"], ["proof (prove)\nusing this:\n  \\<not> \\<not> is_zero_row_upt_k b k A\n  \\<not> is_zero_row_upt_k b (Suc k) B\n\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)", "unfolding B_eq_A is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<forall>j.\n                    mod_type_class.to_nat j < k \\<longrightarrow>\n                    A $ b $ j = (0::'a))\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < Suc k \\<longrightarrow>\n             A $ b $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)", "by (metis B_eq_A False is_zero_row_upt_k_suc not_zero_bB)"], ["proof (state)\nthis:\n  A $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have \"(LEAST n. A $ b $ n \\<noteq> 0) = from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"A $ b $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)", "by (rule Abk_not_0)"], ["proof (state)\nthis:\n  A $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"\\<And>y. A $ b $ y \\<noteq> 0 \\<Longrightarrow> from_nat k \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "by (metis False is_zero_row_upt_k_def k ncols_def not_less to_nat_from_nat_id to_nat_mono)"], ["proof (state)\nthis:\n  A $ b $ ?y \\<noteq> (0::'a) \\<Longrightarrow>\n  mod_type_class.from_nat k \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> is_zero_row_upt_k b k A \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "using least_v v"], ["proof (prove)\nusing this:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> v\n  v < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by auto"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition2_part4:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  assumes  e: \"echelon_form_upt_k A k\"\n  and ab: \"a < b\" \n  and i_nrows: \"i = nrows A\"\n  shows \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have not_all_zero: \"\\<not> (\\<forall>m. is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A)", "by (metis i_nrows i nrows_not_0)"], ["proof (state)\nthis:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)", "have \"i = to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. i =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by (simp add: i)"], ["proof (state)\nthis:\n  i = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "then"], ["proof (chain)\npicking this:\n  i = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "have \"nrows A = to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1\""], ["proof (prove)\nusing this:\n  i = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. nrows A =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by (simp add: i_nrows)"], ["proof (state)\nthis:\n  nrows A =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "then"], ["proof (chain)\npicking this:\n  nrows A =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "have \"CARD('rows) = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\nusing this:\n  nrows A =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. CARD('rows) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  CARD('rows) =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. CARD('rows) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "."], ["proof (state)\nthis:\n  CARD('rows) =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "then"], ["proof (chain)\npicking this:\n  CARD('rows) =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "have \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 = 0\""], ["proof (prove)\nusing this:\n  CARD('rows) =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "using to_nat_plus_one_less_card"], ["proof (prove)\nusing this:\n  CARD('rows) =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n  \\<forall>a.\n     a + (1::?'a) \\<noteq> (0::?'a) \\<longrightarrow>\n     mod_type_class.to_nat a + 1 < CARD(?'a)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "by auto"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "hence g: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) = -1\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)", "by (simp add: a_eq_minus_1)"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have \"\\<not> is_zero_row_upt_k a k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "proof (rule greatest_ge_nonzero_row'[OF e _ not_all_zero])"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "show \"a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "by (simp add: Greatest_is_minus_1 g)"], ["proof (state)\nthis:\n  a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "moreover"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "have \"\\<not> is_zero_row_upt_k b k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k b k A", "proof (rule greatest_ge_nonzero_row'[OF e _ not_all_zero])"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "show \"b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "by (simp add: Greatest_is_minus_1 g)"], ["proof (state)\nthis:\n  b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_zero_row_upt_k a k A\n  \\<not> is_zero_row_upt_k b k A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "using echelon_form_upt_k_condition2[OF e ab]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n  \\<not> is_zero_row_upt_k b k A\n  \\<lbrakk>\\<not> is_zero_row_upt_k a k A;\n   \\<not> is_zero_row_upt_k b k A\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition2_part5:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout i\n  defines i:\"i\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B:\"B \\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes ib: \"is_bezout_ext bezout\" and e: \"echelon_form_upt_k A k\" and k: \"k<ncols A\"\n  and ab: \"a < b\" and not_zero_aB: \"\\<not> is_zero_row_upt_k a (Suc k) B\" \n  and not_zero_bB: \"\\<not> is_zero_row_upt_k b (Suc k) B\"\n  and i_m:\"from_nat i < m\"\n  and A_mk: \"A $ m $ from_nat k \\<noteq> 0\"\n  and i_not_nrows: \"i \\<noteq> nrows A\"\n  shows \"(LEAST n. B $ a $ n \\<noteq> 0) < (LEAST n. B $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have B_eq: \"B = bezout_iterate (interchange_rows A (from_nat i)\n    (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n)) \n    (nrows A - Suc 0) (from_nat i) (from_nat k) bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "unfolding B echelon_form_of_column_k_def Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "using i_m A_mk i_not_nrows"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i < m\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  i \\<noteq> nrows A\n\ngoal (1 subgoal):\n 1. fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "by auto"], ["proof (state)\nthis:\n  B =\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "let ?least=\"(LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "let ?interchange=\"interchange_rows A (from_nat i) ?least\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "let ?greatest=\"(GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have nrows_less: \"nrows A - Suc 0 < nrows ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by auto"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have interchange_ik_not_zero: \"?interchange $ from_nat i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) A_mk LeastI_ex dual_order.strict_iff_order \n      i_m interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have k2: \"k < ncols ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))", "using k"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  k < CARD('cols)\n\ngoal (1 subgoal):\n 1. k < CARD('cols)", "by simp"], ["proof (state)\nthis:\n  k < ncols\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have to_nat_b: \"to_nat b \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b \\<le> nrows A - Suc 0", "by (metis Suc_pred leD not_less_eq_eq nrows_def to_nat_less_card zero_less_card_finite)"], ["proof (state)\nthis:\n  mod_type_class.to_nat b \\<le> nrows A - Suc 0\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have to_nat_from_nat_i: \"to_nat (from_nat i::'rows) \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0", "using i_not_nrows"], ["proof (prove)\nusing this:\n  i \\<noteq> nrows A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  i \\<noteq> CARD('rows)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat i)\n    \\<le> CARD('rows) - Suc 0", "by (metis Suc_pred less_Suc_eq_le to_nat_less_card zero_less_card_finite)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have not_all_zero: \"\\<not> (\\<forall>m. is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m. is_zero_row_upt_k m k A)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    False", "assume all_zero: \"\\<not>\\<not>(\\<forall>m. is_zero_row_upt_k m k A)\""], ["proof (state)\nthis:\n  \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    False", "hence zero_aA: \"is_zero_row_upt_k a k A\" and zero_bA: \"is_zero_row_upt_k b k A\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k A &&& is_zero_row_upt_k b k A", "by auto"], ["proof (state)\nthis:\n  is_zero_row_upt_k a k A\n  is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    False", "have echelon_interchange: \"echelon_form_upt_k ?interchange k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     k", "proof (rule echelon_form_upt_k_interchange[OF e _ A_mk _ k])"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k A\n 2. mod_type_class.from_nat i \\<le> m", "show \"is_zero_row_upt_k (from_nat i) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k A", "using all_zero"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k A", "by auto"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "show \"from_nat i \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "using i_m"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i < m\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "by auto"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   k\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    False", "have zero_i_interchange: \"is_zero_row_upt_k (from_nat i) k ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "using all_zero"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<forall>m j.\n                    mod_type_class.to_nat j < k \\<longrightarrow>\n                    A $ m $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < k \\<longrightarrow>\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) $\n       mod_type_class.from_nat i $\n       j =\n       (0::'a)", "by auto"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    False", "have zero_bB: \"is_zero_row_upt_k b k B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k B", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "fix j::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "assume j: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "have \"B $ b $ j = ?interchange $ b $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ b $ j =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j", "proof (unfold B_eq, rule bezout_iterate_preserves\n          [OF echelon_interchange ib interchange_ik_not_zero nrows_less _ \n            to_nat_from_nat_i k2 zero_i_interchange])"], ["proof (state)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "show \"j < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "using j"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B $ b $ j =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "also"], ["proof (state)\nthis:\n  B $ b $ j =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    (0::'a)", "using all_zero j"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    (0::'a)", "unfolding is_zero_row_upt_k_def interchange_rows_def"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<forall>m j.\n                    mod_type_class.to_nat j < k \\<longrightarrow>\n                    A $ m $ j = (0::'a))\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = mod_type_class.from_nat i\n        then A $\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 mod_type_class.from_nat i \\<le> n) $\n             j\n        else if ia =\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq>\n                    (0::'a) \\<and>\n                    mod_type_class.from_nat i \\<le> n)\n             then A $ mod_type_class.from_nat i $ j else A $ ia $ j) $\n    b $\n    j =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  B $ b $ j = (0::'a)", "show \"B $ b $ j = 0\""], ["proof (prove)\nusing this:\n  B $ b $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. B $ b $ j = (0::'a)", "."], ["proof (state)\nthis:\n  B $ b $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k b k B\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    False", "have i_not_b: \"from_nat i \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> b", "using i all_zero ab least_mod_type"], ["proof (prove)\nusing this:\n  i \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n  \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n  a < b\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> b", "by (metis leD from_nat_0)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    False", "have \"B $ b $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)", "by (metis is_zero_row_upt_k_suc not_zero_bB zero_bB)"], ["proof (state)\nthis:\n  B $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  B $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    False", "have \"B $ b $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ b $ mod_type_class.from_nat k = (0::'a)", "proof (unfold B_eq, rule bezout_iterate_zero_column_k\n        [OF echelon_interchange ib interchange_ik_not_zero nrows_less \n          _ k2 to_nat_b zero_i_interchange])"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < b", "show \"from_nat i < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < b", "by (metis all_zero antisym_conv1 from_nat_0 i i_not_b least_mod_type)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i < b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B $ b $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>m. is_zero_row_upt_k m k A) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  B $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  B $ b $ mod_type_class.from_nat k = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  B $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  B $ b $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have i2: \"i = to_nat (?greatest) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_all_zero"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>m. is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by auto"], ["proof (state)\nthis:\n  i = mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have g_rw: \"(from_nat (to_nat ?greatest + 1))\n    = ?greatest + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n      1) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "by (metis add_to_nat_def to_nat_1)"], ["proof (state)\nthis:\n  mod_type_class.from_nat\n   (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n    1) =\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have zero_least_kA: \"is_zero_row_upt_k ?least k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n)\n     k A", "proof (rule row_greater_greatest_is_zero)"], ["proof (state)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n    < (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          mod_type_class.from_nat i \\<le> n)", "have \"?greatest < from_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < mod_type_class.from_nat i", "by (metis Suc_eq_plus1 Suc_le' add_to_nat_def neq_iff from_nat_0 from_nat_mono \n        i2 i_not_nrows not_less_eq nrows_def to_nat_1 to_nat_less_card zero_less_Suc)"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n    < (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          mod_type_class.from_nat i \\<le> n)", "also"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n    < (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          mod_type_class.from_nat i \\<le> n)", "have \"... \\<le> ?least\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i\n    \\<le> (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n)", "by (metis (mono_tags, lifting) A_mk LeastI_ex dual_order.strict_iff_order i_m)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i\n  \\<le> (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n    < (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          mod_type_class.from_nat i \\<le> n)", "finally"], ["proof (chain)\npicking this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  < (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n)", "show \"?greatest < ?least\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  < (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n    < (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          mod_type_class.from_nat i \\<le> n)", "."], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  < (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n   k A\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have zero_ik_interchange: \"is_zero_row_upt_k (from_nat i) k ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "by (metis (no_types, lifting) interchange_rows_i is_zero_row_upt_k_def zero_least_kA)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have echelon_form_interchange: \"echelon_form_upt_k ?interchange k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     k", "proof (rule echelon_form_upt_k_interchange[OF e _ A_mk _ k])"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k A\n 2. mod_type_class.from_nat i \\<le> m", "show \"is_zero_row_upt_k (from_nat i) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat i) k A", "by (metis (mono_tags) greatest_ge_nonzero_row' Greatest_is_minus_1 Suc_le' \n        a_eq_minus_1 e g_rw i2 row_greater_greatest_is_zero zero_least_kA)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat i) k A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "show \"from_nat i \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "using i_m"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i < m\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> m", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   k\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have b_le_i: \"b \\<le> from_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> mod_type_class.from_nat i", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b \\<le> mod_type_class.from_nat i \\<Longrightarrow> False", "assume \"\\<not> b \\<le> from_nat i\""], ["proof (state)\nthis:\n  \\<not> b \\<le> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> mod_type_class.from_nat i \\<Longrightarrow> False", "hence b_gr_i: \"b > from_nat i\""], ["proof (prove)\nusing this:\n  \\<not> b \\<le> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < b", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat i < b\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> mod_type_class.from_nat i \\<Longrightarrow> False", "have \"is_zero_row_upt_k b (Suc k) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) B", "proof (rule is_zero_row_upt_k_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k b k B\n 2. B $ b $ mod_type_class.from_nat k = (0::'a)", "show \"B $ b $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ b $ mod_type_class.from_nat k = (0::'a)", "by (unfold B_eq, rule bezout_iterate_zero_column_k[OF echelon_form_interchange ib \n          interchange_ik_not_zero nrows_less b_gr_i k2 to_nat_b zero_ik_interchange])"], ["proof (state)\nthis:\n  B $ b $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k B", "show \"is_zero_row_upt_k b k B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k B", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "fix j::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "assume j_k: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "have \"B $ b $ j = ?interchange $ b $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ b $ j =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j", "proof (unfold B_eq, rule bezout_iterate_preserves[OF echelon_form_interchange ib \n            interchange_ik_not_zero nrows_less _ to_nat_from_nat_i k2 zero_ik_interchange])"], ["proof (state)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "show \"j < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id j_k k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B $ b $ j =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "also"], ["proof (state)\nthis:\n  B $ b $ j =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    (0::'a)", "by (metis (erased, lifting) b_gr_i echelon_form_interchange echelon_form_upt_k_condition1 \n            is_zero_row_upt_k_def j_k zero_ik_interchange)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  B $ b $ j = (0::'a)", "show \"B $ b $ j = 0\""], ["proof (prove)\nusing this:\n  B $ b $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. B $ b $ j = (0::'a)", "."], ["proof (state)\nthis:\n  B $ b $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k b k B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k b (Suc k) B\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> mod_type_class.from_nat i \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k b (Suc k) B\n\ngoal (1 subgoal):\n 1. False", "using not_zero_bB"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k b (Suc k) B\n  \\<not> is_zero_row_upt_k b (Suc k) B\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<le> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "hence a_less_i: \"a < from_nat i\""], ["proof (prove)\nusing this:\n  b \\<le> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. a < mod_type_class.from_nat i", "using ab"], ["proof (prove)\nusing this:\n  b \\<le> mod_type_class.from_nat i\n  a < b\n\ngoal (1 subgoal):\n 1. a < mod_type_class.from_nat i", "by simp"], ["proof (state)\nthis:\n  a < mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have not_zero_aA: \"\\<not> is_zero_row_upt_k a k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "proof (rule greatest_ge_nonzero_row'[OF e _ not_all_zero])"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "show \" a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "using a_less_i"], ["proof (prove)\nusing this:\n  a < mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "unfolding i2 g_rw"], ["proof (prove)\nusing this:\n  a < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "by (metis le_Suc not_le)"], ["proof (state)\nthis:\n  a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have least_eq1:\"(LEAST n. B $ a $ n \\<noteq> 0) = (LEAST n. A $ a $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ a $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "have \"B $ a $ (LEAST n. A $ a $ n \\<noteq> 0) = ?interchange $ a $ (LEAST n. A $ a $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))", "proof (unfold B_eq, rule bezout_iterate_preserves[OF echelon_form_interchange ib \n        interchange_ik_not_zero nrows_less _ to_nat_from_nat_i k2 zero_ik_interchange])"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "obtain j::'cols where j: \"to_nat j < k\" and Aaj: \"A $ a $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ a $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_aA"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ a $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ a $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ a $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n  A $ a $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "have \"(LEAST n. A $ a $ n \\<noteq> 0) \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> j", "by (rule Least_le, simp add: Aaj)"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> j\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "also"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> j\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "have \"... < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis (full_types) from_nat_mono from_nat_to_nat_id j k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "finally"], ["proof (chain)\npicking this:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "show \"(LEAST n. A $ a $ n \\<noteq> 0) < from_nat k\""], ["proof (prove)\nusing this:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "."], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ a $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ a $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "have \"... = A $ a $ (LEAST n. A $ a $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n    A $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a))", "by (metis (no_types, lifting) ab b_le_i interchange_rows_preserves \n        leD not_zero_aA zero_least_kA)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n  A $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ a $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n  A $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ a $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags) LeastI is_zero_row_def' is_zero_row_imp_is_zero_row_upt not_zero_aA)"], ["proof (state)\nthis:\n  A $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ a $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "show \"B $ a $ (LEAST n. A $ a $ n \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  B $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       B $ a $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       B $ a $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "assume Bay:\"B $ a $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  B $ a $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       B $ a $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "show \"(LEAST n. A $ a $ n \\<noteq> 0) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "proof (cases \"y<from_nat k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "case True"], ["proof (state)\nthis:\n  y < mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "have \"B $ a $ y = ?interchange $ a $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ a $ y =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    y", "by (unfold B_eq, rule bezout_iterate_preserves[OF echelon_form_interchange ib\n          interchange_ik_not_zero nrows_less True to_nat_from_nat_i k2 zero_ik_interchange])"], ["proof (state)\nthis:\n  B $ a $ y =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  y\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  B $ a $ y =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  y\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "have \"... = A $ a $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    a $\n    y =\n    A $ a $ y", "by (metis (no_types, lifting) ab b_le_i interchange_rows_preserves \n          leD not_zero_aA zero_least_kA)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  a $\n  y =\n  A $ a $ y\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  B $ a $ y = A $ a $ y", "have \"A $ a $ y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  B $ a $ y = A $ a $ y\n\ngoal (1 subgoal):\n 1. A $ a $ y \\<noteq> (0::'a)", "using Bay"], ["proof (prove)\nusing this:\n  B $ a $ y = A $ a $ y\n  B $ a $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ a $ y \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $ a $ y \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  A $ a $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "using Least_le"], ["proof (prove)\nusing this:\n  A $ a $ y \\<noteq> (0::'a)\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "by fast"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> y < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "obtain j::'cols where j: \"to_nat j < k\" and Aaj: \"A $ a $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ a $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_aA"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ a $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ a $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ a $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n  A $ a $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "have \"(LEAST n. A $ a $ n \\<noteq> 0) \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> j", "by (rule Least_le, simp add: Aaj)"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "have \"... < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis (full_types) from_nat_mono from_nat_to_nat_id j k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "have \"...\\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "using False"], ["proof (prove)\nusing this:\n  \\<not> y < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "by auto"], ["proof (state)\nthis:\n  mod_type_class.from_nat k \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) < y", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) < y\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y", "by simp"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. B $ a $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "proof (cases \"b=from_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n 2. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "case True"], ["proof (state)\nthis:\n  b = mod_type_class.from_nat i\n\ngoal (2 subgoals):\n 1. b = mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n 2. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have zero_bB: \"is_zero_row_upt_k b k B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b k B", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "fix j::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "assume jk:\"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "have jk2: \"j < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id jk k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "have \"B $ b $ j = ?interchange $ b $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ b $ j =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j", "by (unfold B_eq, rule bezout_iterate_preserves[OF echelon_form_interchange ib\n          interchange_ik_not_zero nrows_less jk2 to_nat_from_nat_i k2 zero_ik_interchange])"], ["proof (state)\nthis:\n  B $ b $ j =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "also"], ["proof (state)\nthis:\n  B $ b $ j =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "have \"... = A $ ?least $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    j =\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    j", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    j =\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    j", "by auto"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n) $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "also"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  j =\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n) $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    j =\n    (0::'a)", "using zero_least_kA jk"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n   k A\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    j =\n    (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n     j =\n     (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) $\n    j =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n) $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> B $ b $ j = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  B $ b $ j = (0::'a)", "show \"B $ b $ j = 0\""], ["proof (prove)\nusing this:\n  B $ b $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. B $ b $ j = (0::'a)", "."], ["proof (state)\nthis:\n  B $ b $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k b k B\n\ngoal (2 subgoals):\n 1. b = mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n 2. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have least_eq2: \"(LEAST n. B $ b $ n \\<noteq> 0) = from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. B $ b $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. B $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"B $ b $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)", "unfolding B_eq True"], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (rule bezout_iterate_not_zero[OF interchange_ik_not_zero \n            nrows_less to_nat_from_nat_i ib])"], ["proof (state)\nthis:\n  B $ b $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"\\<And>y. B $ b $ y \\<noteq> 0 \\<Longrightarrow> from_nat k \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "by (metis is_zero_row_upt_k_def le_less_linear to_nat_le zero_bB)"], ["proof (state)\nthis:\n  B $ b $ ?y \\<noteq> (0::'a) \\<Longrightarrow>\n  mod_type_class.from_nat k \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. B $ b $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. b = mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n 2. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "obtain j::'cols where j: \"to_nat j < k\" and Abj: \"A $ a $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ a $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_aA"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ a $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ a $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ a $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n  A $ a $ j \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. b = mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n 2. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have \"(LEAST n. A $ a $ n \\<noteq> 0) \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> j", "by (rule Least_le, simp add: Abj)"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> j\n\ngoal (2 subgoals):\n 1. b = mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n 2. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "also"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<le> j\n\ngoal (2 subgoals):\n 1. b = mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n 2. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have \"... < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis (full_types) from_nat_mono from_nat_to_nat_id j k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. b = mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n 2. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "finally"], ["proof (chain)\npicking this:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "unfolding least_eq1 least_eq2"], ["proof (prove)\nusing this:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "."], ["proof (state)\nthis:\n  (LEAST n. B $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "case False"], ["proof (state)\nthis:\n  b \\<noteq> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "note b_not_i=False"], ["proof (state)\nthis:\n  b \\<noteq> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "hence b_less_i: \"b < from_nat i\""], ["proof (prove)\nusing this:\n  b \\<noteq> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. b < mod_type_class.from_nat i", "using b_le_i"], ["proof (prove)\nusing this:\n  b \\<noteq> mod_type_class.from_nat i\n  b \\<le> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. b < mod_type_class.from_nat i", "by simp"], ["proof (state)\nthis:\n  b < mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have not_zero_bA: \"\\<not> is_zero_row_upt_k b k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k b k A", "proof (rule greatest_ge_nonzero_row'[OF e _ not_all_zero])"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "show \" b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "using b_less_i"], ["proof (prove)\nusing this:\n  b < mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "unfolding i2 g_rw"], ["proof (prove)\nusing this:\n  b < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "by (metis le_Suc not_le)"], ["proof (state)\nthis:\n  b \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "have least_eq2: \"(LEAST n. B $ b $ n \\<noteq> 0) = (LEAST n. A $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. B $ b $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ b $ n \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "have \"B $ b $ (LEAST n. A $ b $ n \\<noteq> 0) = ?interchange $ b $ (LEAST n. A $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    (LEAST n. A $ b $ n \\<noteq> (0::'a))", "proof (unfold B_eq, rule bezout_iterate_preserves[OF echelon_form_interchange ib \n          interchange_ik_not_zero nrows_less _ to_nat_from_nat_i k2 zero_ik_interchange])"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "obtain j::'cols where j: \"to_nat j < k\" and Abj: \"A $ b $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ b $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_bA"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ b $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ b $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ b $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n  A $ b $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "have \"(LEAST n. A $ b $ n \\<noteq> 0) \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> j", "by (rule Least_le, simp add: Abj)"], ["proof (state)\nthis:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> j\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "also"], ["proof (state)\nthis:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> j\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "have \"... < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis (full_types) from_nat_mono from_nat_to_nat_id j k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "finally"], ["proof (chain)\npicking this:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "show \"(LEAST n. A $ b $ n \\<noteq> 0) < from_nat k\""], ["proof (prove)\nusing this:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "."], ["proof (state)\nthis:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "have \"... = A $ b $ (LEAST n. A $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) =\n    A $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by (metis (mono_tags) b_not_i interchange_rows_preserves not_zero_bA zero_least_kA)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) =\n  A $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) =\n  A $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags) LeastI is_zero_row_def' is_zero_row_imp_is_zero_row_upt not_zero_bA)"], ["proof (state)\nthis:\n  A $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "show \"B $ b $ (LEAST n. A $ b $ n \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  B $ b $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "assume Bby:\"B $ b $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  B $ b $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       B $ b $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "show \"(LEAST n. A $ b $ n \\<noteq> 0) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "proof (cases \"y<from_nat k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "case True"], ["proof (state)\nthis:\n  y < mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "have \"B $ b $ y = ?interchange $ b $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ b $ y =\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    y", "by (unfold B_eq, rule bezout_iterate_preserves[OF echelon_form_interchange ib\n            interchange_ik_not_zero nrows_less True to_nat_from_nat_i k2 zero_ik_interchange])"], ["proof (state)\nthis:\n  B $ b $ y =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  y\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  B $ b $ y =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  y\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "have \"... = A $ b $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    b $\n    y =\n    A $ b $ y", "by (metis (mono_tags) b_not_i interchange_rows_preserves not_zero_bA zero_least_kA)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  b $\n  y =\n  A $ b $ y\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  B $ b $ y = A $ b $ y", "have \"A $ b $ y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  B $ b $ y = A $ b $ y\n\ngoal (1 subgoal):\n 1. A $ b $ y \\<noteq> (0::'a)", "using Bby"], ["proof (prove)\nusing this:\n  B $ b $ y = A $ b $ y\n  B $ b $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ b $ y \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $ b $ y \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  A $ b $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "using Least_le"], ["proof (prove)\nusing this:\n  A $ b $ y \\<noteq> (0::'a)\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "by fast"], ["proof (state)\nthis:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> y < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "obtain j::'cols where j: \"to_nat j < k\" and Abj: \"A $ b $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ b $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_bA"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k b k A\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ b $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ b $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>mod_type_class.to_nat j < k;\n         A $ b $ j \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n  A $ b $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "have \"(LEAST n. A $ b $ n \\<noteq> 0) \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> j", "by (rule Least_le, simp add: Abj)"], ["proof (state)\nthis:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "have \"... < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis (full_types) from_nat_mono from_nat_to_nat_id j k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "have \"...\\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "using False"], ["proof (prove)\nusing this:\n  \\<not> y < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "by auto"], ["proof (state)\nthis:\n  mod_type_class.from_nat k \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> y < mod_type_class.from_nat k \\<Longrightarrow>\n    (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) < y", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) < y\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y", "by simp"], ["proof (state)\nthis:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ b $ n \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. B $ b $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. b \\<noteq> mod_type_class.from_nat i \\<Longrightarrow>\n    (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "unfolding least_eq1 least_eq2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by (rule echelon_form_upt_k_condition2[OF e ab not_zero_aA not_zero_bA])"], ["proof (state)\nthis:\n  (LEAST n. B $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. B $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_echelon_form_column_k:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\" and k bezout\n  defines i:\"i \\<equiv> (if \\<forall>m. is_zero_row_upt_k m k A then 0 \n  else to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A)) + 1)\"\n  defines B: \"B \\<equiv> fst ((echelon_form_of_column_k bezout) (A,i) k)\"\n  assumes ib: \"is_bezout_ext bezout\" and e: \"echelon_form_upt_k A k\" and k: \"k<ncols A\"\n  shows \"echelon_form_upt_k B (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k B (Suc k)", "unfolding echelon_form_upt_k_def echelon_form_of_column_k_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        is_zero_row_upt_k i (Suc k) B \\<longrightarrow>\n        \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j (Suc k) B)) \\<and>\n    (\\<forall>i j.\n        i < j \\<and>\n        \\<not> is_zero_row_upt_k i (Suc k) B \\<and>\n        \\<not> is_zero_row_upt_k j (Suc k) B \\<longrightarrow>\n        (LEAST n. B $ i $ n \\<noteq> (0::'a))\n        < (LEAST n. B $ j $ n \\<noteq> (0::'a)))", "proof auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) B; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) B\n 2. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k j (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "fix a b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) B; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) B\n 2. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k j (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "let ?B2=\"(fst (if \\<forall>m\\<ge>from_nat i. A $ m $ from_nat k = 0 then (A, i)\n    else if \\<forall>m>from_nat i. A $ m $ from_nat k = 0 then (A, i + 1)\n    else (bezout_iterate\n    (interchange_rows A (from_nat i) (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n))\n    (nrows A - 1) (from_nat i) (from_nat k) bezout, i + 1)))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) B; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) B\n 2. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k j (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "show \"is_zero_row_upt_k a (Suc k) B \\<Longrightarrow> a < b \\<Longrightarrow> is_zero_row_upt_k b (Suc k) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_zero_row_upt_k a (Suc k) B; a < b\\<rbrakk>\n    \\<Longrightarrow> is_zero_row_upt_k b (Suc k) B", "proof (unfold B echelon_form_of_column_k_def Let_def fst_conv snd_conv, auto)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n     \\<forall>m\\<ge>mod_type_class.from_nat i.\n        A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n     \\<forall>m>mod_type_class.from_nat (nrows A).\n        A $ m $ mod_type_class.from_nat k = (0::'a);\n     i = nrows A\\<rbrakk>\n    \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 3. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b;\n        \\<forall>m>mod_type_class.from_nat i.\n           A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 4. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 5. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "assume 1: \"is_zero_row_upt_k a (Suc k) A\" and 2: \"a < b\" \n      and 3: \"\\<forall>m\\<ge>from_nat i. A $ m $ from_nat k = 0\""], ["proof (state)\nthis:\n  is_zero_row_upt_k a (Suc k) A\n  a < b\n  \\<forall>m\\<ge>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n     \\<forall>m\\<ge>mod_type_class.from_nat i.\n        A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n     \\<forall>m>mod_type_class.from_nat (nrows A).\n        A $ m $ mod_type_class.from_nat k = (0::'a);\n     i = nrows A\\<rbrakk>\n    \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 3. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b;\n        \\<forall>m>mod_type_class.from_nat i.\n           A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 4. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 5. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "show \"is_zero_row_upt_k b (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "by (rule condition1_part1[OF e 1 2 3[unfolded i]])"], ["proof (state)\nthis:\n  is_zero_row_upt_k b (Suc k) A\n\ngoal (4 subgoals):\n 1. \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n     \\<forall>m>mod_type_class.from_nat (nrows A).\n        A $ m $ mod_type_class.from_nat k = (0::'a);\n     i = nrows A\\<rbrakk>\n    \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b;\n        \\<forall>m>mod_type_class.from_nat i.\n           A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 3. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 4. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n     \\<forall>m>mod_type_class.from_nat (nrows A).\n        A $ m $ mod_type_class.from_nat k = (0::'a);\n     i = nrows A\\<rbrakk>\n    \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b;\n        \\<forall>m>mod_type_class.from_nat i.\n           A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 3. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 4. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "assume 1: \"is_zero_row_upt_k a (Suc k) A\" and 2: \"a < b\"\n      and 3: \"i = nrows A \" and 4: \"\\<forall>m>from_nat (nrows A). A $ m $ from_nat k = 0\""], ["proof (state)\nthis:\n  is_zero_row_upt_k a (Suc k) A\n  a < b\n  i = nrows A\n  \\<forall>m>mod_type_class.from_nat (nrows A).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n     \\<forall>m>mod_type_class.from_nat (nrows A).\n        A $ m $ mod_type_class.from_nat k = (0::'a);\n     i = nrows A\\<rbrakk>\n    \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b;\n        \\<forall>m>mod_type_class.from_nat i.\n           A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 3. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 4. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "show \"is_zero_row_upt_k b (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "by (rule condition1_part2[OF e 1 2 3[unfolded i] 4])"], ["proof (state)\nthis:\n  is_zero_row_upt_k b (Suc k) A\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b;\n        \\<forall>m>mod_type_class.from_nat i.\n           A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 3. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b;\n        \\<forall>m>mod_type_class.from_nat i.\n           A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 3. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b;\n        \\<forall>m>mod_type_class.from_nat i.\n           A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 3. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "assume 1: \"is_zero_row_upt_k a (Suc k) ?B2\"\n      and 2: \"a < b\" and 3: \"\\<forall>m>from_nat i. A $ m $ from_nat k = 0\"\n      and 4: \"i \\<noteq> nrows A\" and 5: \"from_nat i \\<le> m\" \n      and 6: \"A $ m $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  is_zero_row_upt_k a (Suc k)\n   (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n               A $ m $ mod_type_class.from_nat k = (0::'a)\n         then (A, i)\n         else if \\<forall>m>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat k = (0::'a)\n              then (A, i + 1)\n              else (bezout_iterate\n                     (interchange_rows A (mod_type_class.from_nat i)\n                       (LEAST n.\n                           A $ n $ mod_type_class.from_nat k \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat i \\<le> n))\n                     (nrows A - 1) (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k) bezout,\n                    i + 1)))\n  a < b\n  \\<forall>m>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  i \\<noteq> nrows A\n  mod_type_class.from_nat i \\<le> m\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b;\n        \\<forall>m>mod_type_class.from_nat i.\n           A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 3. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "show \"is_zero_row_upt_k b (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "using condition1_part3[OF e ib _ 2 _ _ _ 6]"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_zero_row_upt_k a (Suc k)\n            (fst (echelon_form_of_column_k bezout\n                   (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                       else mod_type_class.to_nat\n                             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                            1)\n                   k));\n   \\<forall>m>mod_type_class.from_nat\n               (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                else mod_type_class.to_nat\n                      (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     1).\n      A $ m $ mod_type_class.from_nat k = (0::'a);\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1) \\<noteq>\n   nrows A;\n   mod_type_class.from_nat\n    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1)\n   \\<le> m\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "using 1 3 4 5"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_zero_row_upt_k a (Suc k)\n            (fst (echelon_form_of_column_k bezout\n                   (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                       else mod_type_class.to_nat\n                             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                            1)\n                   k));\n   \\<forall>m>mod_type_class.from_nat\n               (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                else mod_type_class.to_nat\n                      (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     1).\n      A $ m $ mod_type_class.from_nat k = (0::'a);\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1) \\<noteq>\n   nrows A;\n   mod_type_class.from_nat\n    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1)\n   \\<le> m\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n  is_zero_row_upt_k a (Suc k)\n   (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n               A $ m $ mod_type_class.from_nat k = (0::'a)\n         then (A, i)\n         else if \\<forall>m>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat k = (0::'a)\n              then (A, i + 1)\n              else (bezout_iterate\n                     (interchange_rows A (mod_type_class.from_nat i)\n                       (LEAST n.\n                           A $ n $ mod_type_class.from_nat k \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat i \\<le> n))\n                     (nrows A - 1) (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k) bezout,\n                    i + 1)))\n  \\<forall>m>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  i \\<noteq> nrows A\n  mod_type_class.from_nat i \\<le> m\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "unfolding i echelon_form_of_column_k_def Let_def fst_conv snd_conv"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_zero_row_upt_k a (Suc k)\n            (fst (case (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1) of\n                  (A, i) \\<Rightarrow>\n                    if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                           A $ m $ mod_type_class.from_nat k =\n                           (0::'a)) \\<or>\n                       i = nrows A\n                    then (A, i)\n                    else if \\<forall>m>mod_type_class.from_nat i.\n                               A $ m $ mod_type_class.from_nat k = (0::'a)\n                         then (A, i + 1)\n                         else (bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - 1) (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout,\n                               i + 1)));\n   \\<forall>m>mod_type_class.from_nat\n               (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                else mod_type_class.to_nat\n                      (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     1).\n      A $ m $ mod_type_class.from_nat k = (0::'a);\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1) \\<noteq>\n   nrows A;\n   mod_type_class.from_nat\n    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1)\n   \\<le> m\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n  is_zero_row_upt_k a (Suc k)\n   (fst (if \\<forall>m\\<ge>mod_type_class.from_nat\n                            (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                             else mod_type_class.to_nat\n                                   (GREATEST n.\n \\<not> is_zero_row_upt_k n k A) +\n                                  1).\n               A $ m $ mod_type_class.from_nat k = (0::'a)\n         then (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1)\n         else if \\<forall>m>mod_type_class.from_nat\n                             (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                              else mod_type_class.to_nat\n                                    (GREATEST n.\n  \\<not> is_zero_row_upt_k n k A) +\n                                   1).\n                    A $ m $ mod_type_class.from_nat k = (0::'a)\n              then (A, (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                        else mod_type_class.to_nat\n                              (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             1) +\n                       1)\n              else (bezout_iterate\n                     (interchange_rows A\n                       (mod_type_class.from_nat\n                         (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n k A) +\n                               1))\n                       (LEAST n.\n                           A $ n $ mod_type_class.from_nat k \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat\n                            (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                             else mod_type_class.to_nat\n                                   (GREATEST n.\n \\<not> is_zero_row_upt_k n k A) +\n                                  1)\n                           \\<le> n))\n                     (nrows A - 1)\n                     (mod_type_class.from_nat\n                       (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                        else mod_type_class.to_nat\n                              (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             1))\n                     (mod_type_class.from_nat k) bezout,\n                    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                     else mod_type_class.to_nat\n                           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                          1) +\n                    1)))\n  \\<forall>m>mod_type_class.from_nat\n              (if \\<forall>m. is_zero_row_upt_k m k A then 0\n               else mod_type_class.to_nat\n                     (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    1).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n   else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        1) \\<noteq>\n  nrows A\n  mod_type_class.from_nat\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1)\n  \\<le> m\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "by auto"], ["proof (state)\nthis:\n  is_zero_row_upt_k b (Suc k) A\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "fix m::'c"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "assume 1: \"is_zero_row_upt_k a (Suc k) A\" and 2: \"i = nrows A\""], ["proof (state)\nthis:\n  is_zero_row_upt_k a (Suc k) A\n  i = nrows A\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k) A; a < b;\n        mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k) A\n 2. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "show \"is_zero_row_upt_k b (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k) A", "by (rule condition1_part4[OF e 1 2[unfolded i]])"], ["proof (state)\nthis:\n  is_zero_row_upt_k b (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "let ?B2=\"(fst (if \\<forall>m\\<ge>from_nat i. A $ m $ from_nat k = 0 then (A, i)\n      else if \\<forall>m>from_nat i. A $ m $ from_nat k = 0 then (A, i + 1)\n      else (bezout_iterate\n      (interchange_rows A (from_nat i)\n      (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n))\n      (nrows A - 1) (from_nat i) (from_nat k) bezout,\n      i + 1)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "assume 1: \"is_zero_row_upt_k a (Suc k) ?B2\"                 \n      and 2: \"a < b\"\n      and 3: \"from_nat i < m\"\n      and 4: \"A $ m $ from_nat k \\<noteq> 0\"\n      and 5: \"i \\<noteq> nrows A\""], ["proof (state)\nthis:\n  is_zero_row_upt_k a (Suc k)\n   (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n               A $ m $ mod_type_class.from_nat k = (0::'a)\n         then (A, i)\n         else if \\<forall>m>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat k = (0::'a)\n              then (A, i + 1)\n              else (bezout_iterate\n                     (interchange_rows A (mod_type_class.from_nat i)\n                       (LEAST n.\n                           A $ n $ mod_type_class.from_nat k \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat i \\<le> n))\n                     (nrows A - 1) (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k) bezout,\n                    i + 1)))\n  a < b\n  mod_type_class.from_nat i < m\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  i \\<noteq> nrows A\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>is_zero_row_upt_k a (Suc k)\n                 (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n                             A $ m $ mod_type_class.from_nat k = (0::'a)\n                       then (A, i)\n                       else if \\<forall>m>mod_type_class.from_nat i.\n                                  A $ m $ mod_type_class.from_nat k =\n                                  (0::'a)\n                            then (A, i + 1)\n                            else (bezout_iterate\n                                   (interchange_rows A\n                                     (mod_type_class.from_nat i)\n                                     (LEAST n.\n   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n   mod_type_class.from_nat i \\<le> n))\n                                   (nrows A - 1) (mod_type_class.from_nat i)\n                                   (mod_type_class.from_nat k) bezout,\n                                  i + 1)));\n        a < b; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                          (bezout_iterate\n                            (interchange_rows A (mod_type_class.from_nat i)\n                              (LEAST n.\n                                  A $ n $ mod_type_class.from_nat k \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n))\n                            (nrows A - Suc 0) (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat k) bezout)", "show \"is_zero_row_upt_k b (Suc k)\n      (bezout_iterate\n      (interchange_rows A (from_nat i) (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n))\n      (nrows A - Suc 0) (from_nat i) (from_nat k) bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k)\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)", "using condition1_part5[OF ib e _ 2 _ 4 _ k]"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_zero_row_upt_k a (Suc k)\n            (fst (echelon_form_of_column_k bezout\n                   (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                       else mod_type_class.to_nat\n                             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                            1)\n                   k));\n   mod_type_class.from_nat\n    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1)\n   < m;\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1) \\<noteq>\n   nrows A\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                     (bezout_iterate\n                       (interchange_rows A\n                         (mod_type_class.from_nat\n                           (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                            else mod_type_class.to_nat\n                                  (GREATEST n.\n\\<not> is_zero_row_upt_k n k A) +\n                                 1))\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat\n                              (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                               else mod_type_class.to_nat\n                                     (GREATEST n.\n   \\<not> is_zero_row_upt_k n k A) +\n                                    1)\n                             \\<le> n))\n                       (nrows A - Suc 0)\n                       (mod_type_class.from_nat\n                         (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n k A) +\n                               1))\n                       (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k)\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)", "using 1 3 5"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_zero_row_upt_k a (Suc k)\n            (fst (echelon_form_of_column_k bezout\n                   (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                       else mod_type_class.to_nat\n                             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                            1)\n                   k));\n   mod_type_class.from_nat\n    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1)\n   < m;\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1) \\<noteq>\n   nrows A\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                     (bezout_iterate\n                       (interchange_rows A\n                         (mod_type_class.from_nat\n                           (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                            else mod_type_class.to_nat\n                                  (GREATEST n.\n\\<not> is_zero_row_upt_k n k A) +\n                                 1))\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat\n                              (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                               else mod_type_class.to_nat\n                                     (GREATEST n.\n   \\<not> is_zero_row_upt_k n k A) +\n                                    1)\n                             \\<le> n))\n                       (nrows A - Suc 0)\n                       (mod_type_class.from_nat\n                         (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n k A) +\n                               1))\n                       (mod_type_class.from_nat k) bezout)\n  is_zero_row_upt_k a (Suc k)\n   (fst (if \\<forall>m\\<ge>mod_type_class.from_nat i.\n               A $ m $ mod_type_class.from_nat k = (0::'a)\n         then (A, i)\n         else if \\<forall>m>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat k = (0::'a)\n              then (A, i + 1)\n              else (bezout_iterate\n                     (interchange_rows A (mod_type_class.from_nat i)\n                       (LEAST n.\n                           A $ n $ mod_type_class.from_nat k \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat i \\<le> n))\n                     (nrows A - 1) (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k) bezout,\n                    i + 1)))\n  mod_type_class.from_nat i < m\n  i \\<noteq> nrows A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k)\n     (bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout)", "unfolding i echelon_form_of_column_k_def Let_def fst_conv snd_conv"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_zero_row_upt_k a (Suc k)\n            (fst (case (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1) of\n                  (A, i) \\<Rightarrow>\n                    if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                           A $ m $ mod_type_class.from_nat k =\n                           (0::'a)) \\<or>\n                       i = nrows A\n                    then (A, i)\n                    else if \\<forall>m>mod_type_class.from_nat i.\n                               A $ m $ mod_type_class.from_nat k = (0::'a)\n                         then (A, i + 1)\n                         else (bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - 1) (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout,\n                               i + 1)));\n   mod_type_class.from_nat\n    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1)\n   < m;\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1) \\<noteq>\n   nrows A\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k b (Suc k)\n                     (bezout_iterate\n                       (interchange_rows A\n                         (mod_type_class.from_nat\n                           (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                            else mod_type_class.to_nat\n                                  (GREATEST n.\n\\<not> is_zero_row_upt_k n k A) +\n                                 1))\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat\n                              (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                               else mod_type_class.to_nat\n                                     (GREATEST n.\n   \\<not> is_zero_row_upt_k n k A) +\n                                    1)\n                             \\<le> n))\n                       (nrows A - Suc 0)\n                       (mod_type_class.from_nat\n                         (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n k A) +\n                               1))\n                       (mod_type_class.from_nat k) bezout)\n  is_zero_row_upt_k a (Suc k)\n   (fst (if \\<forall>m\\<ge>mod_type_class.from_nat\n                            (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                             else mod_type_class.to_nat\n                                   (GREATEST n.\n \\<not> is_zero_row_upt_k n k A) +\n                                  1).\n               A $ m $ mod_type_class.from_nat k = (0::'a)\n         then (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1)\n         else if \\<forall>m>mod_type_class.from_nat\n                             (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                              else mod_type_class.to_nat\n                                    (GREATEST n.\n  \\<not> is_zero_row_upt_k n k A) +\n                                   1).\n                    A $ m $ mod_type_class.from_nat k = (0::'a)\n              then (A, (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                        else mod_type_class.to_nat\n                              (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             1) +\n                       1)\n              else (bezout_iterate\n                     (interchange_rows A\n                       (mod_type_class.from_nat\n                         (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n k A) +\n                               1))\n                       (LEAST n.\n                           A $ n $ mod_type_class.from_nat k \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat\n                            (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                             else mod_type_class.to_nat\n                                   (GREATEST n.\n \\<not> is_zero_row_upt_k n k A) +\n                                  1)\n                           \\<le> n))\n                     (nrows A - 1)\n                     (mod_type_class.from_nat\n                       (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                        else mod_type_class.to_nat\n                              (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             1))\n                     (mod_type_class.from_nat k) bezout,\n                    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                     else mod_type_class.to_nat\n                           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                          1) +\n                    1)))\n  mod_type_class.from_nat\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1)\n  < m\n  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n   else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        1) \\<noteq>\n  nrows A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k b (Suc k)\n     (bezout_iterate\n       (interchange_rows A\n         (mod_type_class.from_nat\n           (if \\<forall>m. is_zero_row_upt_k m k A then 0\n            else mod_type_class.to_nat\n                  (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                 1))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat\n              (if \\<forall>m. is_zero_row_upt_k m k A then 0\n               else mod_type_class.to_nat\n                     (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    1)\n             \\<le> n))\n       (nrows A - Suc 0)\n       (mod_type_class.from_nat\n         (if \\<forall>m. is_zero_row_upt_k m k A then 0\n          else mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1))\n       (mod_type_class.from_nat k) bezout)", "by auto"], ["proof (state)\nthis:\n  is_zero_row_upt_k b (Suc k)\n   (bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>is_zero_row_upt_k a (Suc k) B; a < b\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k b (Suc k) B\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k j (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k j (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k j (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "assume ab: \"a < b\" and not_zero_aB: \"\\<not> is_zero_row_upt_k a (Suc k) B\" \n    and not_zero_bB: \"\\<not> is_zero_row_upt_k b (Suc k) B\""], ["proof (state)\nthis:\n  a < b\n  \\<not> is_zero_row_upt_k a (Suc k) B\n  \\<not> is_zero_row_upt_k b (Suc k) B\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k j (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. B $ j $ n \\<noteq> (0::'a))", "show \"(LEAST n. B $ a $ n \\<noteq> 0) < (LEAST n. B $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. B $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ b $ n \\<noteq> (0::'a))", "proof (unfold B echelon_form_of_column_k_def Let_def fst_conv snd_conv, auto)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<forall>m\\<ge>mod_type_class.from_nat i.\n       A $ m $ mod_type_class.from_nat k = (0::'a) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<lbrakk>\\<forall>m>mod_type_class.from_nat (nrows A).\n                A $ m $ mod_type_class.from_nat k = (0::'a);\n     i = nrows A\\<rbrakk>\n    \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                      < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 3. \\<And>m.\n       \\<lbrakk>\\<forall>m>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 4. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 5. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "assume all_zero: \"\\<forall>m\\<ge>from_nat i. A $ m $ from_nat k = 0\""], ["proof (state)\nthis:\n  \\<forall>m\\<ge>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<forall>m\\<ge>mod_type_class.from_nat i.\n       A $ m $ mod_type_class.from_nat k = (0::'a) \\<Longrightarrow>\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<lbrakk>\\<forall>m>mod_type_class.from_nat (nrows A).\n                A $ m $ mod_type_class.from_nat k = (0::'a);\n     i = nrows A\\<rbrakk>\n    \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                      < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 3. \\<And>m.\n       \\<lbrakk>\\<forall>m>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 4. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 5. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "show \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "using condition2_part1[OF e ab] not_zero_aB not_zero_bB all_zero"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k a (Suc k)\n                   (fst (echelon_form_of_column_k ?bezout\n                          (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                              else mod_type_class.to_nat\n                                    (GREATEST n.\n  \\<not> is_zero_row_upt_k n k A) +\n                                   1)\n                          k));\n   \\<not> is_zero_row_upt_k b (Suc k)\n           (fst (echelon_form_of_column_k ?bezout\n                  (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                      else mod_type_class.to_nat\n                            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           1)\n                  k));\n   \\<forall>m\\<ge>mod_type_class.from_nat\n                   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                    else mod_type_class.to_nat\n                          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                         1).\n      A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n  \\<not> is_zero_row_upt_k a (Suc k) B\n  \\<not> is_zero_row_upt_k b (Suc k) B\n  \\<forall>m\\<ge>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "unfolding B i"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k a (Suc k)\n                   (fst (echelon_form_of_column_k ?bezout\n                          (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                              else mod_type_class.to_nat\n                                    (GREATEST n.\n  \\<not> is_zero_row_upt_k n k A) +\n                                   1)\n                          k));\n   \\<not> is_zero_row_upt_k b (Suc k)\n           (fst (echelon_form_of_column_k ?bezout\n                  (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                      else mod_type_class.to_nat\n                            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           1)\n                  k));\n   \\<forall>m\\<ge>mod_type_class.from_nat\n                   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                    else mod_type_class.to_nat\n                          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                         1).\n      A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n  \\<not> is_zero_row_upt_k a (Suc k)\n          (fst (echelon_form_of_column_k bezout\n                 (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                     else mod_type_class.to_nat\n                           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                          1)\n                 k))\n  \\<not> is_zero_row_upt_k b (Suc k)\n          (fst (echelon_form_of_column_k bezout\n                 (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                     else mod_type_class.to_nat\n                           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                          1)\n                 k))\n  \\<forall>m\\<ge>mod_type_class.from_nat\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>m>mod_type_class.from_nat (nrows A).\n                A $ m $ mod_type_class.from_nat k = (0::'a);\n     i = nrows A\\<rbrakk>\n    \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                      < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 3. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 4. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>m>mod_type_class.from_nat (nrows A).\n                A $ m $ mod_type_class.from_nat k = (0::'a);\n     i = nrows A\\<rbrakk>\n    \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                      < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 3. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 4. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "assume 1: \"\\<forall>m>from_nat (nrows A). A $ m $ from_nat k = 0\" and 2: \"i = nrows A\""], ["proof (state)\nthis:\n  \\<forall>m>mod_type_class.from_nat (nrows A).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  i = nrows A\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>m>mod_type_class.from_nat (nrows A).\n                A $ m $ mod_type_class.from_nat k = (0::'a);\n     i = nrows A\\<rbrakk>\n    \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                      < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 3. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 4. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "show \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "using condition2_part2[OF e ab 1] 2"], ["proof (prove)\nusing this:\n  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n   else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        1) =\n  nrows A \\<Longrightarrow>\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n  i = nrows A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "unfolding i"], ["proof (prove)\nusing this:\n  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n   else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        1) =\n  nrows A \\<Longrightarrow>\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n   else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        1) =\n  nrows A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 3. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 3. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "fix ma"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 3. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "assume 1: \"\\<forall>m>from_nat i. A $ m $ from_nat k = 0\"\n      and 2: \"from_nat i \\<le> ma\" and 3: \"A $ ma $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<forall>m>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  mod_type_class.from_nat i \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat k = (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 3. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "show \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "using condition2_part3[OF e k ab _ _ _ _ 3]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k a (Suc k)\n                   (fst (echelon_form_of_column_k ?bezout\n                          (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                              else mod_type_class.to_nat\n                                    (GREATEST n.\n  \\<not> is_zero_row_upt_k n k A) +\n                                   1)\n                          k));\n   \\<not> is_zero_row_upt_k b (Suc k)\n           (fst (echelon_form_of_column_k ?bezout\n                  (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                      else mod_type_class.to_nat\n                            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           1)\n                  k));\n   \\<forall>m>mod_type_class.from_nat\n               (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                else mod_type_class.to_nat\n                      (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     1).\n      A $ m $ mod_type_class.from_nat k = (0::'a);\n   mod_type_class.from_nat\n    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1)\n   \\<le> ma\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "using 1 2 not_zero_aB not_zero_bB"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k a (Suc k)\n                   (fst (echelon_form_of_column_k ?bezout\n                          (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                              else mod_type_class.to_nat\n                                    (GREATEST n.\n  \\<not> is_zero_row_upt_k n k A) +\n                                   1)\n                          k));\n   \\<not> is_zero_row_upt_k b (Suc k)\n           (fst (echelon_form_of_column_k ?bezout\n                  (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                      else mod_type_class.to_nat\n                            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           1)\n                  k));\n   \\<forall>m>mod_type_class.from_nat\n               (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                else mod_type_class.to_nat\n                      (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     1).\n      A $ m $ mod_type_class.from_nat k = (0::'a);\n   mod_type_class.from_nat\n    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1)\n   \\<le> ma\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n  \\<forall>m>mod_type_class.from_nat i.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  mod_type_class.from_nat i \\<le> ma\n  \\<not> is_zero_row_upt_k a (Suc k) B\n  \\<not> is_zero_row_upt_k b (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "unfolding i B"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k a (Suc k)\n                   (fst (echelon_form_of_column_k ?bezout\n                          (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                              else mod_type_class.to_nat\n                                    (GREATEST n.\n  \\<not> is_zero_row_upt_k n k A) +\n                                   1)\n                          k));\n   \\<not> is_zero_row_upt_k b (Suc k)\n           (fst (echelon_form_of_column_k ?bezout\n                  (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                      else mod_type_class.to_nat\n                            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           1)\n                  k));\n   \\<forall>m>mod_type_class.from_nat\n               (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                else mod_type_class.to_nat\n                      (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     1).\n      A $ m $ mod_type_class.from_nat k = (0::'a);\n   mod_type_class.from_nat\n    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1)\n   \\<le> ma\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n  \\<forall>m>mod_type_class.from_nat\n              (if \\<forall>m. is_zero_row_upt_k m k A then 0\n               else mod_type_class.to_nat\n                     (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    1).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  mod_type_class.from_nat\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1)\n  \\<le> ma\n  \\<not> is_zero_row_upt_k a (Suc k)\n          (fst (echelon_form_of_column_k bezout\n                 (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                     else mod_type_class.to_nat\n                           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                          1)\n                 k))\n  \\<not> is_zero_row_upt_k b (Suc k)\n          (fst (echelon_form_of_column_k bezout\n                 (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                     else mod_type_class.to_nat\n                           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                          1)\n                 k))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by auto"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "assume \"i = nrows A\""], ["proof (state)\nthis:\n  i = nrows A\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>mod_type_class.from_nat (nrows A) < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i = nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ a $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n 2. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "thus \"(LEAST n. A $ a $ n \\<noteq> 0) < (LEAST n. A $ b $ n \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  i = nrows A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "using condition2_part4[OF e ab]"], ["proof (prove)\nusing this:\n  i = nrows A\n  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n   else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        1) =\n  nrows A \\<Longrightarrow>\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "unfolding i"], ["proof (prove)\nusing this:\n  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n   else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        1) =\n  nrows A\n  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n   else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        1) =\n  nrows A \\<Longrightarrow>\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ b $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ b $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "let ?B2=\"bezout_iterate (interchange_rows A (from_nat i) \n      (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n)) \n      (nrows A - Suc 0) (from_nat i) (from_nat k) bezout\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "assume 1: \"from_nat i < m\"\n      and 2: \"A $ m $ from_nat k \\<noteq> 0\"\n      and 3: \"i \\<noteq> nrows A\""], ["proof (state)\nthis:\n  mod_type_class.from_nat i < m\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  i \\<noteq> nrows A\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "have B_eq: \"B=?B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "unfolding B echelon_form_of_column_k_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "using 1 2 3"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i < m\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  i \\<noteq> nrows A\n\ngoal (1 subgoal):\n 1. fst (case (A, i) of\n         (A, i) \\<Rightarrow>\n           if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (A, i)\n           else if \\<forall>m>mod_type_class.from_nat i.\n                      A $ m $ mod_type_class.from_nat k = (0::'a)\n                then (A, i + 1)\n                else (bezout_iterate\n                       (interchange_rows A (mod_type_class.from_nat i)\n                         (LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n))\n                       (nrows A - 1) (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "by auto"], ["proof (state)\nthis:\n  B =\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             bezout_iterate\n                              (interchange_rows A\n                                (mod_type_class.from_nat i)\n                                (LEAST n.\n                                    A $ n $\n                                    mod_type_class.from_nat k \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat i \\<le> n))\n                              (nrows A - Suc 0) (mod_type_class.from_nat i)\n                              (mod_type_class.from_nat k) bezout $\n                             a $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - Suc 0)\n                                (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat k) bezout $\n                               b $\n                               n \\<noteq>\n                               (0::'a))", "show \"(LEAST n. ?B2 $ a $ n \\<noteq> 0) < (LEAST n. ?B2 $ b $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        bezout_iterate\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n         (nrows A - Suc 0) (mod_type_class.from_nat i)\n         (mod_type_class.from_nat k) bezout $\n        a $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          bezout_iterate\n           (interchange_rows A (mod_type_class.from_nat i)\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 mod_type_class.from_nat i \\<le> n))\n           (nrows A - Suc 0) (mod_type_class.from_nat i)\n           (mod_type_class.from_nat k) bezout $\n          b $\n          n \\<noteq>\n          (0::'a))", "using condition2_part5[OF ib e k ab _ _ _ 2] 1 3 not_zero_aB not_zero_bB"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k a (Suc k)\n                   (fst (echelon_form_of_column_k bezout\n                          (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                              else mod_type_class.to_nat\n                                    (GREATEST n.\n  \\<not> is_zero_row_upt_k n k A) +\n                                   1)\n                          k));\n   \\<not> is_zero_row_upt_k b (Suc k)\n           (fst (echelon_form_of_column_k bezout\n                  (A, if \\<forall>m. is_zero_row_upt_k m k A then 0\n                      else mod_type_class.to_nat\n                            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           1)\n                  k));\n   mod_type_class.from_nat\n    (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1)\n   < m;\n   (if \\<forall>m. is_zero_row_upt_k m k A then 0\n    else mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1) \\<noteq>\n   nrows A\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        fst (echelon_form_of_column_k bezout\n                              (A, if \\<forall>m. is_zero_row_upt_k m k A\n                                  then 0\n                                  else mod_type_class.to_nat\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n 1)\n                              k) $\n                        a $\n                        n \\<noteq>\n                        (0::'a))\n                    < (LEAST n.\n                          fst (echelon_form_of_column_k bezout\n                                (A, if \\<forall>m. is_zero_row_upt_k m k A\n                                    then 0\n                                    else mod_type_class.to_nat\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n   1)\n                                k) $\n                          b $\n                          n \\<noteq>\n                          (0::'a))\n  mod_type_class.from_nat i < m\n  i \\<noteq> nrows A\n  \\<not> is_zero_row_upt_k a (Suc k) B\n  \\<not> is_zero_row_upt_k b (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        bezout_iterate\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n         (nrows A - Suc 0) (mod_type_class.from_nat i)\n         (mod_type_class.from_nat k) bezout $\n        a $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          bezout_iterate\n           (interchange_rows A (mod_type_class.from_nat i)\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 mod_type_class.from_nat i \\<le> n))\n           (nrows A - Suc 0) (mod_type_class.from_nat i)\n           (mod_type_class.from_nat k) bezout $\n          b $\n          n \\<noteq>\n          (0::'a))", "unfolding i[symmetric] B[symmetric]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k a (Suc k) B;\n   \\<not> is_zero_row_upt_k b (Suc k) B; mod_type_class.from_nat i < m;\n   i \\<noteq> nrows A\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. B $ a $ n \\<noteq> (0::'a))\n                    < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n  mod_type_class.from_nat i < m\n  i \\<noteq> nrows A\n  \\<not> is_zero_row_upt_k a (Suc k) B\n  \\<not> is_zero_row_upt_k b (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        bezout_iterate\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n         (nrows A - Suc 0) (mod_type_class.from_nat i)\n         (mod_type_class.from_nat k) bezout $\n        a $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          bezout_iterate\n           (interchange_rows A (mod_type_class.from_nat i)\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 mod_type_class.from_nat i \\<le> n))\n           (nrows A - Suc 0) (mod_type_class.from_nat i)\n           (mod_type_class.from_nat k) bezout $\n          b $\n          n \\<noteq>\n          (0::'a))", "unfolding B_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k a (Suc k)\n                   (bezout_iterate\n                     (interchange_rows A (mod_type_class.from_nat i)\n                       (LEAST n.\n                           A $ n $ mod_type_class.from_nat k \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat i \\<le> n))\n                     (nrows A - Suc 0) (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k) bezout);\n   \\<not> is_zero_row_upt_k b (Suc k)\n           (bezout_iterate\n             (interchange_rows A (mod_type_class.from_nat i)\n               (LEAST n.\n                   A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                   mod_type_class.from_nat i \\<le> n))\n             (nrows A - Suc 0) (mod_type_class.from_nat i)\n             (mod_type_class.from_nat k) bezout);\n   mod_type_class.from_nat i < m; i \\<noteq> nrows A\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        bezout_iterate\n                         (interchange_rows A (mod_type_class.from_nat i)\n                           (LEAST n.\n                               A $ n $ mod_type_class.from_nat k \\<noteq>\n                               (0::'a) \\<and>\n                               mod_type_class.from_nat i \\<le> n))\n                         (nrows A - Suc 0) (mod_type_class.from_nat i)\n                         (mod_type_class.from_nat k) bezout $\n                        a $\n                        n \\<noteq>\n                        (0::'a))\n                    < (LEAST n.\n                          bezout_iterate\n                           (interchange_rows A (mod_type_class.from_nat i)\n                             (LEAST n.\n                                 A $ n $ mod_type_class.from_nat k \\<noteq>\n                                 (0::'a) \\<and>\n                                 mod_type_class.from_nat i \\<le> n))\n                           (nrows A - Suc 0) (mod_type_class.from_nat i)\n                           (mod_type_class.from_nat k) bezout $\n                          b $\n                          n \\<noteq>\n                          (0::'a))\n  mod_type_class.from_nat i < m\n  i \\<noteq> nrows A\n  \\<not> is_zero_row_upt_k a (Suc k)\n          (bezout_iterate\n            (interchange_rows A (mod_type_class.from_nat i)\n              (LEAST n.\n                  A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                  mod_type_class.from_nat i \\<le> n))\n            (nrows A - Suc 0) (mod_type_class.from_nat i)\n            (mod_type_class.from_nat k) bezout)\n  \\<not> is_zero_row_upt_k b (Suc k)\n          (bezout_iterate\n            (interchange_rows A (mod_type_class.from_nat i)\n              (LEAST n.\n                  A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                  mod_type_class.from_nat i \\<le> n))\n            (nrows A - Suc 0) (mod_type_class.from_nat i)\n            (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        bezout_iterate\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n         (nrows A - Suc 0) (mod_type_class.from_nat i)\n         (mod_type_class.from_nat k) bezout $\n        a $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          bezout_iterate\n           (interchange_rows A (mod_type_class.from_nat i)\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 mod_type_class.from_nat i \\<le> n))\n           (nrows A - Suc 0) (mod_type_class.from_nat i)\n           (mod_type_class.from_nat k) bezout $\n          b $\n          n \\<noteq>\n          (0::'a))", "by auto"], ["proof (state)\nthis:\n  (LEAST n.\n      bezout_iterate\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (nrows A - Suc 0) (mod_type_class.from_nat i)\n       (mod_type_class.from_nat k) bezout $\n      a $\n      n \\<noteq>\n      (0::'a))\n  < (LEAST n.\n        bezout_iterate\n         (interchange_rows A (mod_type_class.from_nat i)\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               mod_type_class.from_nat i \\<le> n))\n         (nrows A - Suc 0) (mod_type_class.from_nat i)\n         (mod_type_class.from_nat k) bezout $\n        b $\n        n \\<noteq>\n        (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. B $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. B $ b $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_foldl_condition1:\n  assumes ib: \"is_bezout_ext bezout\"\n  and \"A $ ma $ from_nat (Suc k) \\<noteq> 0\"\n  and k: \"k<ncols A\"\n  shows \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k))\n  (bezout_iterate (interchange_rows A 0 (LEAST n. A $ n $ from_nat (Suc k) \\<noteq> 0)) \n  (nrows A - Suc 0) 0 (from_nat (Suc k)) bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc (Suc k))\n               (bezout_iterate\n                 (interchange_rows A (0::'c)\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                       (0::'a)))\n                 (nrows A - Suc 0) (0::'c) (mod_type_class.from_nat (Suc k))\n                 bezout)", "proof (rule exI[of _ 0], unfold is_zero_row_upt_k_def, \n    auto, rule exI[of _ \"from_nat (Suc k)\"], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) < Suc (Suc k)\n 2. bezout_iterate\n     (interchange_rows A (0::'c)\n       (LEAST n. A $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'c) (mod_type_class.from_nat (Suc k)) bezout $\n    (0::'c) $\n    mod_type_class.from_nat (Suc k) \\<noteq>\n    (0::'a)", "show \"to_nat (from_nat (Suc k)) < Suc (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) < Suc (Suc k)", "by (metis from_nat_mono from_nat_to_nat_id less_irrefl not_less_eq to_nat_less_card)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) < Suc (Suc k)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'c)\n       (LEAST n. A $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'c) (mod_type_class.from_nat (Suc k)) bezout $\n    (0::'c) $\n    mod_type_class.from_nat (Suc k) \\<noteq>\n    (0::'a)", "show \"bezout_iterate (interchange_rows A 0 (LEAST n. A $ n $ from_nat (Suc k) \\<noteq> 0)) \n    (nrows A - Suc 0) 0 (from_nat (Suc k)) bezout $ 0 $ from_nat (Suc k) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'c)\n       (LEAST n. A $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'c) (mod_type_class.from_nat (Suc k)) bezout $\n    (0::'c) $\n    mod_type_class.from_nat (Suc k) \\<noteq>\n    (0::'a)", "proof (rule bezout_iterate_not_zero[OF _ _ _ ib])"], ["proof (state)\ngoal (3 subgoals):\n 1. interchange_rows A (0::'c)\n     (LEAST n. A $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)) $\n    (0::'c) $\n    mod_type_class.from_nat (Suc k) \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'c)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n 3. mod_type_class.to_nat (0::'c) \\<le> nrows A - Suc 0", "show \"interchange_rows A 0 (LEAST n. A $ n $ from_nat (Suc k) \\<noteq> 0) $ 0 $ from_nat (Suc k) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (0::'c)\n     (LEAST n. A $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)) $\n    (0::'c) $\n    mod_type_class.from_nat (Suc k) \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) LeastI_ex assms(2) interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (0::'c)\n   (LEAST n. A $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)) $\n  (0::'c) $\n  mod_type_class.from_nat (Suc k) \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'c)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n 2. mod_type_class.to_nat (0::'c) \\<le> nrows A - Suc 0", "show \"nrows A - Suc 0 < nrows (interchange_rows A 0 (LEAST n. A $ n $ from_nat (Suc k) \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'c)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('c) - Suc 0 < CARD('c)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A (0::'c)\n       (LEAST n. A $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (0::'c) \\<le> nrows A - Suc 0", "show \"to_nat 0 \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (0::'d) \\<le> nrows A - Suc 0", "unfolding to_nat_0 nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> CARD('c) - Suc 0", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat (0::?'d2) \\<le> nrows A - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'c)\n     (LEAST n. A $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'c) (mod_type_class.from_nat (Suc k)) bezout $\n  (0::'c) $\n  mod_type_class.from_nat (Suc k) \\<noteq>\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_foldl_condition2:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes n: \"\\<not> is_zero_row_upt_k ma k A\"\n  and all_zero: \"\\<forall>m\\<ge> (GREATEST n. \\<not> is_zero_row_upt_k n k A)+1. A $ m $ from_nat k = 0\"\n  shows \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) = (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "proof (rule Greatest_equality[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n            (Suc k) A\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "show \"\\<not> is_zero_row_upt_k (GREATEST n. \\<not> is_zero_row_upt_k n k A) (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n            (Suc k) A", "by (metis GreatestI_ex n is_zero_row_upt_k_le)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n          (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "assume y: \"\\<not> is_zero_row_upt_k y (Suc k) A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k y (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "show \"y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n.\n                       \\<not> is_zero_row_upt_k n k A) \\<Longrightarrow>\n    False", "assume \" \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (state)\nthis:\n  \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n.\n                       \\<not> is_zero_row_upt_k n k A) \\<Longrightarrow>\n    False", "hence y2: \"y > (GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y", "by simp"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n.\n                       \\<not> is_zero_row_upt_k n k A) \\<Longrightarrow>\n    False", "hence \"is_zero_row_upt_k y k A\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y k A", "by (metis row_greater_greatest_is_zero)"], ["proof (state)\nthis:\n  is_zero_row_upt_k y k A\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n.\n                       \\<not> is_zero_row_upt_k n k A) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  is_zero_row_upt_k y k A\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n.\n                       \\<not> is_zero_row_upt_k n k A) \\<Longrightarrow>\n    False", "have \"A $ y $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ y $ mod_type_class.from_nat k = (0::'a)", "by (metis (no_types, lifting)  all_zero le_Suc y2)"], ["proof (state)\nthis:\n  A $ y $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n.\n                       \\<not> is_zero_row_upt_k n k A) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  is_zero_row_upt_k y k A\n  A $ y $ mod_type_class.from_nat k = (0::'a)", "have \"is_zero_row_upt_k y (Suc k) A\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y k A\n  A $ y $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y (Suc k) A", "by (rule is_zero_row_upt_k_suc)"], ["proof (state)\nthis:\n  is_zero_row_upt_k y (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n.\n                       \\<not> is_zero_row_upt_k n k A) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k) A\n\ngoal (1 subgoal):\n 1. False", "using y"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k) A\n  \\<not> is_zero_row_upt_k y (Suc k) A\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_foldl_condition3:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and Am0: \"A $ m $ from_nat k \\<noteq> 0\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and e: \"echelon_form_upt_k A k\"\n  and k: \"k < ncols A\"\n  shows \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k)\n  (bezout_iterate (interchange_rows A 0 (LEAST n. A $ n $ from_nat k \\<noteq> 0)) \n  (nrows A - (Suc 0)) 0 (from_nat k) bezout)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (bezout_iterate\n                   (interchange_rows A (0::'rows)\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a)))\n                   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n                   bezout)) =\n    0", "proof (unfold to_nat_eq_0, rule Greatest_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (bezout_iterate\n              (interchange_rows A (0::'rows)\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n              (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n              bezout)\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A (0::'rows)\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n                 (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n                 bezout) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "let ?interchange=\"(interchange_rows A 0 (LEAST n. A $ n $ from_nat k \\<noteq> 0))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (bezout_iterate\n              (interchange_rows A (0::'rows)\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n              (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n              bezout)\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A (0::'rows)\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n                 (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n                 bezout) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "let ?b=\"(bezout_iterate ?interchange (nrows A - (Suc 0)) 0 (from_nat k) bezout)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (bezout_iterate\n              (interchange_rows A (0::'rows)\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n              (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n              bezout)\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A (0::'rows)\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n                 (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n                 bezout) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "have b0k: \"?b $ 0 $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "proof (rule bezout_iterate_not_zero[OF _ _ _ ib])"], ["proof (state)\ngoal (3 subgoals):\n 1. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 3. mod_type_class.to_nat (0::'rows) \\<le> nrows A - Suc 0", "show \"interchange_rows A 0 (LEAST n. A $ n $ from_nat k \\<noteq> 0) $ 0 $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) LeastI Am0 interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (0::'rows)\n   (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n  (0::'rows) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 2. mod_type_class.to_nat (0::'rows) \\<le> nrows A - Suc 0", "show \"nrows A - (Suc 0) < nrows (interchange_rows A 0 (LEAST n. A $ n $ from_nat k \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (0::'rows) \\<le> nrows A - Suc 0", "show \"to_nat 0 \\<le> nrows A - (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (0::'b) \\<le> nrows A - Suc 0", "unfolding to_nat_0 nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> CARD('rows) - Suc 0", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat (0::?'b1) \\<le> nrows A - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n  (0::'rows) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (bezout_iterate\n              (interchange_rows A (0::'rows)\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n              (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n              bezout)\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A (0::'rows)\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n                 (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n                 bezout) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "have least_eq: \"(LEAST n. A $ n $ from_nat k \\<noteq> 0) \n    = (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> 0 \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (0::'rows) \\<le> n)", "by (metis least_mod_type)"], ["proof (state)\nthis:\n  (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) =\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (0::'rows) \\<le> n)\n\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (bezout_iterate\n              (interchange_rows A (0::'rows)\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n              (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n              bezout)\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A (0::'rows)\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n                 (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n                 bezout) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "have all_zero_below: \"\\<forall>a>0. ?b $ a $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a>0::'rows.\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n       a $\n       mod_type_class.from_nat k =\n       (0::'a)", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (0::'rows) < a \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n       a $\n       mod_type_class.from_nat k =\n       (0::'a)", "fix a::'rows"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (0::'rows) < a \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n       a $\n       mod_type_class.from_nat k =\n       (0::'a)", "assume a: \"0 < a\""], ["proof (state)\nthis:\n  (0::'rows) < a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       (0::'rows) < a \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n       a $\n       mod_type_class.from_nat k =\n       (0::'a)", "show \"bezout_iterate (interchange_rows A 0 (LEAST n. A $ n $ from_nat k \\<noteq> 0)) \n      (nrows A - Suc 0) 0 (from_nat k) bezout $ a $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n    a $\n    mod_type_class.from_nat k =\n    (0::'a)", "proof (rule bezout_iterate_zero_column_k[OF _ ib _ _ a])"], ["proof (state)\ngoal (6 subgoals):\n 1. echelon_form_upt_k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     k\n 2. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 3. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 4. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 5. mod_type_class.to_nat a \\<le> nrows A - Suc 0\n 6. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"echelon_form_upt_k (interchange_rows A 0 (LEAST n. A $ n $ from_nat k \\<noteq> 0)) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     k", "proof(unfold from_nat_0[symmetric] least_eq, \n          rule echelon_form_upt_k_interchange[OF e _ Am0 _ k])"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (mod_type_class.from_nat 0) k A\n 2. mod_type_class.from_nat 0 \\<le> m", "show \"is_zero_row_upt_k (from_nat 0) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat 0) k A", "by (metis all_zero)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat 0) k A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat 0 \\<le> m", "show \"from_nat 0 \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat 0 \\<le> m", "unfolding from_nat_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'rows) \\<le> m", "by (metis least_mod_type)"], ["proof (state)\nthis:\n  mod_type_class.from_nat 0 \\<le> m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n   k\n\ngoal (5 subgoals):\n 1. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 3. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 4. mod_type_class.to_nat a \\<le> nrows A - Suc 0\n 5. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"interchange_rows A 0 (LEAST n. A $ n $ from_nat k \\<noteq> 0) $ 0 $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) Am0 LeastI interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (0::'rows)\n   (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n  (0::'rows) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (4 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 2. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 3. mod_type_class.to_nat a \\<le> nrows A - Suc 0\n 4. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"nrows A - Suc 0 < nrows (interchange_rows A 0 (LEAST n. A $ n $ from_nat k \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n\ngoal (3 subgoals):\n 1. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 2. mod_type_class.to_nat a \\<le> nrows A - Suc 0\n 3. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"k < ncols (interchange_rows A 0 (LEAST n. A $ n $ from_nat k \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "using k"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  k < CARD('cols)\n\ngoal (1 subgoal):\n 1. k < CARD('cols)", "by simp"], ["proof (state)\nthis:\n  k < ncols\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a \\<le> nrows A - Suc 0\n 2. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"to_nat a \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<le> nrows A - Suc 0", "by (metis (erased, hide_lams) One_nat_def Suc_leI Suc_le_D diff_Suc_eq_diff_pred \n          not_le nrows_def to_nat_less_card zero_less_diff)"], ["proof (state)\nthis:\n  mod_type_class.to_nat a \\<le> nrows A - Suc 0\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"is_zero_row_upt_k 0 k (interchange_rows A 0 (LEAST n. A $ n $ from_nat k \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "by (metis all_zero interchange_rows_i is_zero_row_upt_k_def)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (0::'rows) k\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n  a $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a>0::'rows.\n     bezout_iterate\n      (interchange_rows A (0::'rows)\n        (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n      (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n     a $\n     mod_type_class.from_nat k =\n     (0::'a)\n\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (bezout_iterate\n              (interchange_rows A (0::'rows)\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n              (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n              bezout)\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A (0::'rows)\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n                 (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n                 bezout) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "show \"\\<not> is_zero_row_upt_k 0 (Suc k) ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (bezout_iterate\n              (interchange_rows A (0::'rows)\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n              (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n              bezout)", "by (metis b0k is_zero_row_upt_k_def k lessI ncols_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n          (bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A (0::'rows)\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n                 (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n                 bezout) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A (0::'rows)\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n                 (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n                 bezout) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "assume  y: \"\\<not> is_zero_row_upt_k y (Suc k) ?b\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k y (Suc k)\n          (bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A (0::'rows)\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n                 (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k)\n                 bezout) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "show \"y \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> (0::'rows)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (0::'rows) \\<Longrightarrow> False", "assume \"\\<not> y \\<le> 0\""], ["proof (state)\nthis:\n  \\<not> y \\<le> (0::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (0::'rows) \\<Longrightarrow> False", "hence y2: \"y>0\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> (0::'rows)\n\ngoal (1 subgoal):\n 1. (0::'rows) < y", "by simp"], ["proof (state)\nthis:\n  (0::'rows) < y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (0::'rows) \\<Longrightarrow> False", "have \"is_zero_row_upt_k y (Suc k) ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y (Suc k)\n     (bezout_iterate\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n       (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout)", "proof (rule is_zero_row_upt_k_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k y k\n     (bezout_iterate\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n       (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n    y $\n    mod_type_class.from_nat k =\n    (0::'a)", "show \"is_zero_row_upt_k y k ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y k\n     (bezout_iterate\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n       (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout)", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "fix j::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "assume j: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "have \"?b $ y $ j = ?interchange $ y $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n    y $\n    j =\n    interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n    y $\n    j", "proof (rule bezout_iterate_preserves[OF _ ib])"], ["proof (state)\ngoal (7 subgoals):\n 1. echelon_form_upt_k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     k\n 2. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 3. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 4. j < mod_type_class.from_nat k\n 5. mod_type_class.to_nat (0::'rows) \\<le> nrows A - Suc 0\n 6. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 7. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"echelon_form_upt_k ?interchange k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     k", "proof (unfold least_eq from_nat_0[symmetric], \n              rule echelon_form_upt_k_interchange[OF e _ Am0 _ k])"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (mod_type_class.from_nat 0) k A\n 2. mod_type_class.from_nat 0 \\<le> m", "show \"is_zero_row_upt_k (from_nat 0) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (mod_type_class.from_nat 0) k A", "by (metis all_zero)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (mod_type_class.from_nat 0) k A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat 0 \\<le> m", "show \"from_nat 0 \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat 0 \\<le> m", "by (metis from_nat_0 least_mod_type)"], ["proof (state)\nthis:\n  mod_type_class.from_nat 0 \\<le> m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n   k\n\ngoal (6 subgoals):\n 1. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 3. j < mod_type_class.from_nat k\n 4. mod_type_class.to_nat (0::'rows) \\<le> nrows A - Suc 0\n 5. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 6. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"?interchange $ 0 $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) Am0 LeastI interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (0::'rows)\n   (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n  (0::'rows) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (5 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 2. j < mod_type_class.from_nat k\n 3. mod_type_class.to_nat (0::'rows) \\<le> nrows A - Suc 0\n 4. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 5. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"nrows A - Suc 0 < nrows ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n\ngoal (4 subgoals):\n 1. j < mod_type_class.from_nat k\n 2. mod_type_class.to_nat (0::'rows) \\<le> nrows A - Suc 0\n 3. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 4. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"j < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis (full_types) j from_nat_mono from_nat_to_nat_id k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (3 subgoals):\n 1. mod_type_class.to_nat (0::'rows) \\<le> nrows A - Suc 0\n 2. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 3. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"to_nat 0 \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (0::'b) \\<le> nrows A - Suc 0", "by (metis le0 to_nat_0)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (0::?'b1) \\<le> nrows A - Suc 0\n\ngoal (2 subgoals):\n 1. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n 2. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"k < ncols ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "using k"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  k < CARD('cols)\n\ngoal (1 subgoal):\n 1. k < CARD('cols)", "by simp"], ["proof (state)\nthis:\n  k < ncols\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "show \"is_zero_row_upt_k 0 k ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (0::'rows) k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))", "by (metis all_zero interchange_rows_i is_zero_row_upt_k_def)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (0::'rows) k\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n  y $\n  j =\n  interchange_rows A (0::'rows)\n   (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n  y $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n  y $\n  j =\n  interchange_rows A (0::'rows)\n   (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n  y $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n    y $\n    j =\n    (0::'a)", "by (metis all_zero dual_order.strict_iff_order interchange_rows_j \n            interchange_rows_preserves is_zero_row_upt_k_def j y2)"], ["proof (state)\nthis:\n  interchange_rows A (0::'rows)\n   (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)) $\n  y $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "finally"], ["proof (chain)\npicking this:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n  y $\n  j =\n  (0::'a)", "show \"?b $ y $ j = 0\""], ["proof (prove)\nusing this:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n  y $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n    y $\n    j =\n    (0::'a)", "."], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n  y $\n  j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k y k\n   (bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n    y $\n    mod_type_class.from_nat k =\n    (0::'a)", "show \"?b $ y $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n    y $\n    mod_type_class.from_nat k =\n    (0::'a)", "using all_zero_below"], ["proof (prove)\nusing this:\n  \\<forall>a>0::'rows.\n     bezout_iterate\n      (interchange_rows A (0::'rows)\n        (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n      (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n     a $\n     mod_type_class.from_nat k =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n    y $\n    mod_type_class.from_nat k =\n    (0::'a)", "using y2"], ["proof (prove)\nusing this:\n  \\<forall>a>0::'rows.\n     bezout_iterate\n      (interchange_rows A (0::'rows)\n        (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n      (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n     a $\n     mod_type_class.from_nat k =\n     (0::'a)\n  (0::'rows) < y\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n    y $\n    mod_type_class.from_nat k =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout $\n  y $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k y (Suc k)\n   (bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (0::'rows) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k)\n   (bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. False", "using y"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k)\n   (bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout)\n  \\<not> is_zero_row_upt_k y (Suc k)\n          (bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> (0::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_foldl_condition4:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes all_zero: \"\\<forall>m>(GREATEST n. \\<not> is_zero_row_upt_k n k A)+1.\n  A $ m $ from_nat k = 0\"\n  and greatest_nrows: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and le_mb: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A)+1 \\<le> mb\"\n  and A_mb_k: \"A $ mb $ from_nat k \\<noteq> 0\"\n  shows \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "let ?greatest = \"(GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "have mb_eq: \"mb=(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mb = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "by (metis all_zero le_mb A_mb_k le_less )"], ["proof (state)\nthis:\n  mb = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "have \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \n    = (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "proof (rule Greatest_equality[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (Suc k) A\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "show \"\\<not> is_zero_row_upt_k (?greatest + 1) (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (Suc k) A", "by (metis (no_types, lifting) A_mb_k is_zero_row_upt_k_def less_Suc_eq less_trans \n        mb_eq not_less_eq to_nat_from_nat_id to_nat_less_card)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k\n          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n          (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "assume y: \"\\<not> is_zero_row_upt_k y (Suc k) A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k y (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "show \"y \\<le> ?greatest + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "assume \"\\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (state)\nthis:\n  \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "hence y_greatest: \"y >  ?greatest + 1\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) < y", "by simp"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) < y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "have \"is_zero_row_upt_k y (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y (Suc k) A", "proof (rule is_zero_row_upt_k_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k y k A\n 2. A $ y $ mod_type_class.from_nat k = (0::'a)", "show \"is_zero_row_upt_k y k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y k A", "proof (rule row_greater_greatest_is_zero)"], ["proof (state)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) < y", "show \"?greatest < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y", "using y_greatest greatest_nrows"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) < y\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) < y\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  CARD('rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y", "by (metis Suc_eq_plus1 dual_order.strict_implies_order \n              le_Suc' suc_not_zero to_nat_plus_one_less_card')"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k y k A\n\ngoal (1 subgoal):\n 1. A $ y $ mod_type_class.from_nat k = (0::'a)", "show \"A $ y $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ y $ mod_type_class.from_nat k = (0::'a)", "using all_zero y_greatest"], ["proof (prove)\nusing this:\n  \\<forall>m>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) < y\n\ngoal (1 subgoal):\n 1. A $ y $ mod_type_class.from_nat k = (0::'a)", "unfolding from_nat_to_nat_greatest"], ["proof (prove)\nusing this:\n  \\<forall>m>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) < y\n\ngoal (1 subgoal):\n 1. A $ y $ mod_type_class.from_nat k = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ y $ mod_type_class.from_nat k = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k y (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k) A\n\ngoal (1 subgoal):\n 1. False", "using y"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k) A\n  \\<not> is_zero_row_upt_k y (Suc k) A\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) =\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) =\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "by (metis (mono_tags, lifting) Suc_eq_plus1 Suc_lessI add_to_nat_def greatest_nrows \n      nrows_def to_nat_1 to_nat_from_nat_id to_nat_less_card)"], ["proof (state)\nthis:\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_foldl_condition5:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"        \n  assumes mb: \"\\<not> is_zero_row_upt_k mb k A\"\n  and nrows: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"nrows A = Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))", "by (metis (no_types, lifting) GreatestI Suc_lessI Suc_less_eq mb nrows from_nat_mono \n    from_nat_to_nat_id is_zero_row_upt_k_le not_greater_Greatest nrows_def to_nat_less_card)"], ["", "lemma echelon_foldl_condition6:\n  fixes A::\"'a::{bezout_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and g_mc: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> mc\"\n  and A_mc_k: \"A $ mc $ from_nat k \\<noteq> 0\"\n  shows \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc k)\n  (bezout_iterate (interchange_rows A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\n  (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> n))\n  (nrows A - Suc 0) ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout)", "let ?greatest=\"(GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout)", "let ?interchange=\"interchange_rows A (?greatest + 1) \n    (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> ?greatest + 1 \\<le> n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout)", "let ?B=\"(bezout_iterate ?interchange (nrows A - Suc 0) (?greatest + 1) (from_nat k) bezout)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout)", "have \"?B $ (?greatest + 1) $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n     (nrows A - Suc 0)\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) bezout $\n    ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "proof (rule bezout_iterate_not_zero[OF _ _ _ ib])"], ["proof (state)\ngoal (3 subgoals):\n 1. interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n         \\<le> n) $\n    ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < nrows\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n 3. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0", "show \"?interchange $ (?greatest + 1) $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n         \\<le> n) $\n    ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) LeastI_ex g_mc A_mc_k interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n) $\n  ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n 2. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0", "show \"nrows A - Suc 0 < nrows ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0", "show \"to_nat (?greatest + 1) \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0", "by (metis Suc_pred less_Suc_eq_le nrows_def to_nat_less_card zero_less_card_finite)"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n  \\<le> nrows A - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n   (nrows A - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) bezout $\n  ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout)", "thus ?thesis"], ["proof (prove)\nusing this:\n  bezout_iterate\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n   (nrows A - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) bezout $\n  ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout)", "by (metis (no_types, lifting) from_nat_mono from_nat_to_nat_id is_zero_row_upt_k_def \n      less_irrefl not_less_eq to_nat_less_card)"], ["proof (state)\nthis:\n  \\<exists>m.\n     \\<not> is_zero_row_upt_k m (Suc k)\n             (bezout_iterate\n               (interchange_rows A\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (LEAST n.\n                     A $ n $ mod_type_class.from_nat k \\<noteq>\n                     (0::'a) \\<and>\n                     (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     (1::'rows)\n                     \\<le> n))\n               (nrows A - Suc 0)\n               ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n               (mod_type_class.from_nat k) bezout)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_foldl_condition7:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and e: \"echelon_form_upt_k A k\"\n  and k: \"k<ncols A\"\n  and mb: \"\\<not> is_zero_row_upt_k mb k A\"\n  and not_nrows: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and g_mc: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> mc\"\n  and A_mc_k: \"A $ mc $ from_nat k \\<noteq> 0\"\n  shows \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (bezout_iterate\n  (interchange_rows A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\n  (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> n))\n  (nrows A - Suc 0) ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) bezout))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (bezout_iterate\n                   (interchange_rows A\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                      (1::'rows))\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k) bezout))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (bezout_iterate\n                   (interchange_rows A\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                      (1::'rows))\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k) bezout))", "let ?greatest=\"(GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (bezout_iterate\n                   (interchange_rows A\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                      (1::'rows))\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k) bezout))", "let ?interchange=\"interchange_rows A (?greatest + 1) \n    (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> ?greatest + 1 \\<le> n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (bezout_iterate\n                   (interchange_rows A\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                      (1::'rows))\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k) bezout))", "let ?B=\"(bezout_iterate ?interchange (nrows A - Suc 0) (?greatest + 1) (from_nat k) bezout)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (bezout_iterate\n                   (interchange_rows A\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                      (1::'rows))\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k) bezout))", "have g_rw: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \n    = from_nat (to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) =\n    mod_type_class.from_nat\n     (mod_type_class.to_nat\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)))", "unfolding from_nat_to_nat_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", ".."], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) =\n  mod_type_class.from_nat\n   (mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)))\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (bezout_iterate\n                   (interchange_rows A\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                      (1::'rows))\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k) bezout))", "have B_gk:\"?B $ (?greatest + 1) $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n     (nrows A - Suc 0)\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) bezout $\n    ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "proof (rule bezout_iterate_not_zero[OF _ _ _ ib])"], ["proof (state)\ngoal (3 subgoals):\n 1. interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n         \\<le> n) $\n    ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < nrows\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n 3. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0", "show \"?interchange $ ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n         \\<le> n) $\n    ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) LeastI_ex g_mc A_mc_k interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n) $\n  ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n 2. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0", "show \"nrows A - Suc 0 < nrows (?interchange)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0", "show \"to_nat (?greatest + 1) \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0", "by (metis Suc_pred less_Suc_eq_le nrows_def to_nat_less_card \n        zero_less_card_finite)"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n  \\<le> nrows A - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n   (nrows A - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) bezout $\n  ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (bezout_iterate\n                   (interchange_rows A\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                      (1::'rows))\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k) bezout))", "have \"(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) ?B) = ?greatest + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n.\n        \\<not> is_zero_row_upt_k n (Suc k)\n                (bezout_iterate\n                  (interchange_rows A\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     (1::'rows))\n                    (LEAST n.\n                        A $ n $ mod_type_class.from_nat k \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows))\n                  (mod_type_class.from_nat k) bezout)) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "proof (rule Greatest_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (Suc k)\n            (bezout_iterate\n              (interchange_rows A\n                ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq>\n                    (0::'a) \\<and>\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows)\n                    \\<le> n))\n              (nrows A - Suc 0)\n              ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n              (mod_type_class.from_nat k) bezout)\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout) \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "show \"\\<not> is_zero_row_upt_k (?greatest + 1) (Suc k) ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (Suc k)\n            (bezout_iterate\n              (interchange_rows A\n                ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                (LEAST n.\n                    A $ n $ mod_type_class.from_nat k \\<noteq>\n                    (0::'a) \\<and>\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows)\n                    \\<le> n))\n              (nrows A - Suc 0)\n              ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n              (mod_type_class.from_nat k) bezout)", "by (metis (no_types, lifting) B_gk from_nat_mono from_nat_to_nat_id \n        is_zero_row_upt_k_def less_irrefl not_less_eq to_nat_less_card)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k\n          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n          (Suc k)\n          (bezout_iterate\n            (interchange_rows A\n              ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n              (LEAST n.\n                  A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n                  \\<le> n))\n            (nrows A - Suc 0)\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout) \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout) \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "assume y: \"\\<not> is_zero_row_upt_k y (Suc k) ?B\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k y (Suc k)\n          (bezout_iterate\n            (interchange_rows A\n              ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n              (LEAST n.\n                  A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n                  \\<le> n))\n            (nrows A - Suc 0)\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout) \\<Longrightarrow>\n       y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "show \"y \\<le> ?greatest + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "assume \" \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (state)\nthis:\n  \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "hence y_gr: \" y > (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) < y", "by simp"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) < y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "hence y_gr2: \"y > (GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) < y\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y", "by (metis (erased, lifting) Suc_eq_plus1 leI le_Suc' less_irrefl less_trans \n          not_nrows nrows_def suc_not_zero to_nat_plus_one_less_card')"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "have echelon_interchange: \"echelon_form_upt_k ?interchange k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n     k", "proof (subst (1 2) from_nat_to_nat_id\n          [of \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\", symmetric], \n            rule echelon_form_upt_k_interchange[OF e _ A_mc_k _ k])"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k\n     (mod_type_class.from_nat\n       (mod_type_class.to_nat\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))))\n     k A\n 2. mod_type_class.from_nat\n     (mod_type_class.to_nat\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)))\n    \\<le> mc", "show \"is_zero_row_upt_k \n          (from_nat (to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1))) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k\n     (mod_type_class.from_nat\n       (mod_type_class.to_nat\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))))\n     k A", "by (metis Suc_eq_plus1 Suc_le' g_rw not_nrows nrows_def \n            row_greater_greatest_is_zero suc_not_zero)"], ["proof (state)\nthis:\n  is_zero_row_upt_k\n   (mod_type_class.from_nat\n     (mod_type_class.to_nat\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))))\n   k A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (mod_type_class.to_nat\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)))\n    \\<le> mc", "show \"from_nat (to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)) \\<le> mc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (mod_type_class.to_nat\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)))\n    \\<le> mc", "by (metis g_mc g_rw)"], ["proof (state)\nthis:\n  mod_type_class.from_nat\n   (mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)))\n  \\<le> mc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n   k\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "have i: \"?interchange $ (?greatest + 1) $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n         \\<le> n) $\n    ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) A_mc_k LeastI_ex g_mc interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n) $\n  ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "have zero_greatest: \"is_zero_row_upt_k (?greatest + 1) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) k A", "by (metis Suc_eq_plus1 Suc_le' not_nrows nrows_def \n          row_greater_greatest_is_zero suc_not_zero)"], ["proof (state)\nthis:\n  is_zero_row_upt_k\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) k A\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  is_zero_row_upt_k\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) k A\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "fix j::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "assume \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "have \"?greatest < ?greatest + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n    < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "by (metis greatest_less_zero_row e mb zero_greatest)"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "have \"... \\<le>(LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (?greatest + 1) \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n    \\<le> (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n              \\<le> n)", "by (metis (mono_tags, lifting) A_mc_k LeastI_ex g_mc)"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n  \\<le> (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n            \\<le> n)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  < (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n)", "have least_less: \"?greatest \n          < (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (?greatest + 1) \\<le> n)\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  < (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n    < (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n)", "."], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  < (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "have \"is_zero_row_upt_k (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (?greatest + 1) \\<le> n) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n)\n     k A", "by (rule row_greater_greatest_is_zero[OF least_less])"], ["proof (state)\nthis:\n  is_zero_row_upt_k\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n)\n   k A\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  mod_type_class.to_nat ?j2 < k \\<Longrightarrow>\n  is_zero_row_upt_k\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n)\n   k A\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "hence zero_g1: \"is_zero_row_upt_k (?greatest + 1) k ?interchange\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?j2 < k \\<Longrightarrow>\n  is_zero_row_upt_k\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n)\n   k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) k\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?j2 < k \\<Longrightarrow>\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n.\n             \\<not> (\\<forall>j.\n                        mod_type_class.to_nat j < k \\<longrightarrow>\n                        A $ n $ j = (0::'a))) +\n         (1::'rows)\n         \\<le> n) $\n     j =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < k \\<longrightarrow>\n       interchange_rows A\n        ((GREATEST n.\n             \\<not> (\\<forall>j.\n                        mod_type_class.to_nat j < k \\<longrightarrow>\n                        A $ n $ j = (0::'a))) +\n         (1::'rows))\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            (GREATEST n.\n                \\<not> (\\<forall>j.\n                           mod_type_class.to_nat j < k \\<longrightarrow>\n                           A $ n $ j = (0::'a))) +\n            (1::'rows)\n            \\<le> n) $\n       ((GREATEST n.\n            \\<not> (\\<forall>j.\n                       mod_type_class.to_nat j < k \\<longrightarrow>\n                       A $ n $ j = (0::'a))) +\n        (1::'rows)) $\n       j =\n       (0::'a)", "by auto"], ["proof (state)\nthis:\n  is_zero_row_upt_k\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) k\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "hence zero_y: \"is_zero_row_upt_k y k ?interchange\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) k\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y k\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))", "by (metis (erased, lifting) echelon_form_upt_k_condition1' echelon_interchange y_gr)"], ["proof (state)\nthis:\n  is_zero_row_upt_k y k\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "have \"is_zero_row_upt_k y (Suc k) ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y (Suc k)\n     (bezout_iterate\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n       (nrows A - Suc 0)\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) bezout)", "proof (rule is_zero_row_upt_k_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k y k\n     (bezout_iterate\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n       (nrows A - Suc 0)\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) bezout)\n 2. bezout_iterate\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n     (nrows A - Suc 0)\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) bezout $\n    y $\n    mod_type_class.from_nat k =\n    (0::'a)", "show \"?B $ y $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n     (nrows A - Suc 0)\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) bezout $\n    y $\n    mod_type_class.from_nat k =\n    (0::'a)", "proof (rule bezout_iterate_zero_column_k[OF echelon_interchange ib i _ y_gr _ _ zero_g1])"], ["proof (state)\ngoal (3 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n 2. k < ncols\n         (interchange_rows A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n               \\<le> n))\n 3. mod_type_class.to_nat y \\<le> nrows A - Suc 0", "show \"nrows A - Suc 0 < nrows ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n\ngoal (2 subgoals):\n 1. k < ncols\n         (interchange_rows A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n               \\<le> n))\n 2. mod_type_class.to_nat y \\<le> nrows A - Suc 0", "show \"k < ncols ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n               \\<le> n))", "using k"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n               \\<le> n))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  k < CARD('cols)\n\ngoal (1 subgoal):\n 1. k < CARD('cols)", "by simp"], ["proof (state)\nthis:\n  k < ncols\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y \\<le> nrows A - Suc 0", "show \"to_nat y \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y \\<le> nrows A - Suc 0", "by (metis One_nat_def Suc_eq_plus1 Suc_leI nrows_def \n              le_diff_conv2 to_nat_less_card zero_less_card_finite)"], ["proof (state)\nthis:\n  mod_type_class.to_nat y \\<le> nrows A - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n   (nrows A - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) bezout $\n  y $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y k\n     (bezout_iterate\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n       (nrows A - Suc 0)\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) bezout)", "show \"is_zero_row_upt_k y k ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y k\n     (bezout_iterate\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n       (nrows A - Suc 0)\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) bezout)", "proof (subst is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A\n          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n              \\<le> n))\n        (nrows A - Suc 0)\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "fix j::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A\n          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n              \\<le> n))\n        (nrows A - Suc 0)\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "assume j: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A\n          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n              \\<le> n))\n        (nrows A - Suc 0)\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "have \"?B $ y $ j = ?interchange $ y $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n     (nrows A - Suc 0)\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) bezout $\n    y $\n    j =\n    interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n         \\<le> n) $\n    y $\n    j", "proof (rule bezout_iterate_preserves[OF echelon_interchange ib i _ _ _ _ zero_g1])"], ["proof (state)\ngoal (4 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n 2. j < mod_type_class.from_nat k\n 3. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0\n 4. k < ncols\n         (interchange_rows A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n               \\<le> n))", "show \"nrows A - Suc 0 < nrows ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n\ngoal (3 subgoals):\n 1. j < mod_type_class.from_nat k\n 2. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0\n 3. k < ncols\n         (interchange_rows A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n               \\<le> n))", "show \"j < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "using j"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. j < mod_type_class.from_nat k", "by (metis (poly_guards_query) from_nat_mono from_nat_to_nat_id k ncols_def)"], ["proof (state)\nthis:\n  j < mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0\n 2. k < ncols\n         (interchange_rows A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n               \\<le> n))", "show \"to_nat ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n    \\<le> nrows A - Suc 0", "by (metis Suc_pred less_Suc_eq_le nrows_def to_nat_less_card zero_less_card_finite)"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n  \\<le> nrows A - Suc 0\n\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n               \\<le> n))", "show \"k < ncols ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n               \\<le> n))", "using k"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. k < ncols\n         (interchange_rows A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (LEAST n.\n               A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n               (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n               \\<le> n))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  k < CARD('cols)\n\ngoal (1 subgoal):\n 1. k < CARD('cols)", "."], ["proof (state)\nthis:\n  k < ncols\n       (interchange_rows A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n             \\<le> n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n   (nrows A - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) bezout $\n  y $\n  j =\n  interchange_rows A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n) $\n  y $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A\n          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n              \\<le> n))\n        (nrows A - Suc 0)\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n   (nrows A - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) bezout $\n  y $\n  j =\n  interchange_rows A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n) $\n  y $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A\n          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n              \\<le> n))\n        (nrows A - Suc 0)\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n         \\<le> n) $\n    y $\n    j =\n    (0::'a)", "using zero_y"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y k\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n\ngoal (1 subgoal):\n 1. interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n         \\<le> n) $\n    y $\n    j =\n    (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     interchange_rows A\n      ((GREATEST n.\n           \\<not> (\\<forall>j.\n                      mod_type_class.to_nat j < k \\<longrightarrow>\n                      A $ n $ j = (0::'a))) +\n       (1::'rows))\n      (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          (GREATEST n.\n              \\<not> (\\<forall>j.\n                         mod_type_class.to_nat j < k \\<longrightarrow>\n                         A $ n $ j = (0::'a))) +\n          (1::'rows)\n          \\<le> n) $\n     y $\n     j =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. interchange_rows A\n     ((GREATEST n.\n          \\<not> (\\<forall>j.\n                     mod_type_class.to_nat j < k \\<longrightarrow>\n                     A $ n $ j = (0::'a))) +\n      (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n.\n             \\<not> (\\<forall>j.\n                        mod_type_class.to_nat j < k \\<longrightarrow>\n                        A $ n $ j = (0::'a))) +\n         (1::'rows)\n         \\<le> n) $\n    y $\n    j =\n    (0::'a)", "using j"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     interchange_rows A\n      ((GREATEST n.\n           \\<not> (\\<forall>j.\n                      mod_type_class.to_nat j < k \\<longrightarrow>\n                      A $ n $ j = (0::'a))) +\n       (1::'rows))\n      (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          (GREATEST n.\n              \\<not> (\\<forall>j.\n                         mod_type_class.to_nat j < k \\<longrightarrow>\n                         A $ n $ j = (0::'a))) +\n          (1::'rows)\n          \\<le> n) $\n     y $\n     j =\n     (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. interchange_rows A\n     ((GREATEST n.\n          \\<not> (\\<forall>j.\n                     mod_type_class.to_nat j < k \\<longrightarrow>\n                     A $ n $ j = (0::'a))) +\n      (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n.\n             \\<not> (\\<forall>j.\n                        mod_type_class.to_nat j < k \\<longrightarrow>\n                        A $ n $ j = (0::'a))) +\n         (1::'rows)\n         \\<le> n) $\n    y $\n    j =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  interchange_rows A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n) $\n  y $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A\n          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n              \\<le> n))\n        (nrows A - Suc 0)\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) bezout $\n       y $\n       j =\n       (0::'a)", "finally"], ["proof (chain)\npicking this:\n  bezout_iterate\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n   (nrows A - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) bezout $\n  y $\n  j =\n  (0::'a)", "show \"?B $ y $ j = 0\""], ["proof (prove)\nusing this:\n  bezout_iterate\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n   (nrows A - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) bezout $\n  y $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n     (nrows A - Suc 0)\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) bezout $\n    y $\n    j =\n    (0::'a)", "."], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n))\n   (nrows A - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) bezout $\n  y $\n  j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k y k\n   (bezout_iterate\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n     (nrows A - Suc 0)\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) bezout)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k y (Suc k)\n   (bezout_iterate\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n     (nrows A - Suc 0)\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k)\n   (bezout_iterate\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n     (nrows A - Suc 0)\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. False", "using y"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k)\n   (bezout_iterate\n     (interchange_rows A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n           \\<le> n))\n     (nrows A - Suc 0)\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) bezout)\n  \\<not> is_zero_row_upt_k y (Suc k)\n          (bezout_iterate\n            (interchange_rows A\n              ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n              (LEAST n.\n                  A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n                  \\<le> n))\n            (nrows A - Suc 0)\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (GREATEST n.\n      \\<not> is_zero_row_upt_k n (Suc k)\n              (bezout_iterate\n                (interchange_rows A\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows))\n                  (LEAST n.\n                      A $ n $ mod_type_class.from_nat k \\<noteq>\n                      (0::'a) \\<and>\n                      (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                      (1::'rows)\n                      \\<le> n))\n                (nrows A - Suc 0)\n                ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                (mod_type_class.from_nat k) bezout)) =\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (bezout_iterate\n                   (interchange_rows A\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                      (1::'rows))\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k) bezout))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (GREATEST n.\n      \\<not> is_zero_row_upt_k n (Suc k)\n              (bezout_iterate\n                (interchange_rows A\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   (1::'rows))\n                  (LEAST n.\n                      A $ n $ mod_type_class.from_nat k \\<noteq>\n                      (0::'a) \\<and>\n                      (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                      (1::'rows)\n                      \\<le> n))\n                (nrows A - Suc 0)\n                ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                (mod_type_class.from_nat k) bezout)) =\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (bezout_iterate\n                   (interchange_rows A\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                      (1::'rows))\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k) bezout))", "by (metis (erased, lifting) Suc_eq_plus1 add_to_nat_def not_nrows nrows_def suc_not_zero \n      to_nat_1 to_nat_from_nat_id to_nat_plus_one_less_card')"], ["proof (state)\nthis:\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  mod_type_class.to_nat\n   (GREATEST n.\n       \\<not> is_zero_row_upt_k n (Suc k)\n               (bezout_iterate\n                 (interchange_rows A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (LEAST n.\n                       A $ n $ mod_type_class.from_nat k \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k) bezout))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\" and ib: \"is_bezout_ext bezout\"\n  shows echelon_echelon_form_of_upt_k:\n  \"echelon_form_upt_k (echelon_form_of_upt_k A k bezout) (Suc k)\"\n  and \"foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]), \n  if \\<forall>m. is_zero_row_upt_k m (Suc k) \n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])) then 0\n  else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) \n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k (echelon_form_of_upt_k A k bezout) (Suc k) &&&\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc k)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc k]))) +\n          1)", "using k"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. echelon_form_upt_k (echelon_form_of_upt_k A k bezout) (Suc k) &&&\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc k)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc k]))) +\n          1)", "proof (induct k)"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    echelon_form_upt_k (echelon_form_of_upt_k A 0 bezout) (Suc 0)\n 2. 0 < ncols A \\<Longrightarrow>\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc 0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc 0]))) +\n          1)\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 4. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "let ?interchange=\"interchange_rows A 0 (LEAST n. A $ n $ 0 \\<noteq> 0)\""], ["proof (state)\ngoal (4 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    echelon_form_upt_k (echelon_form_of_upt_k A 0 bezout) (Suc 0)\n 2. 0 < ncols A \\<Longrightarrow>\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc 0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc 0]))) +\n          1)\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 4. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "have i_rw: \"(if \\<forall>m. is_zero_row_upt_k m 0 A then 0 \n    else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n 0 A) + 1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m 0 A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n 0 A) +\n          1) =\n    0", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m j.\n           mod_type_class.to_nat j < 0 \\<longrightarrow> A $ m $ j = (0::'a)\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> (\\<forall>j.\n                          mod_type_class.to_nat j < 0 \\<longrightarrow>\n                          A $ n $ j = (0::'a))) +\n          1) =\n    0", "by auto"], ["proof (state)\nthis:\n  (if \\<forall>m. is_zero_row_upt_k m 0 A then 0\n   else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n 0 A) +\n        1) =\n  0\n\ngoal (4 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    echelon_form_upt_k (echelon_form_of_upt_k A 0 bezout) (Suc 0)\n 2. 0 < ncols A \\<Longrightarrow>\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc 0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc 0]))) +\n          1)\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 4. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "show \"echelon_form_upt_k (echelon_form_of_upt_k A 0 bezout) (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k (echelon_form_of_upt_k A 0 bezout) (Suc 0)", "unfolding echelon_form_of_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]))\n     (Suc 0)", "by (auto, subst i_rw[symmetric], rule echelon_echelon_form_column_k[OF ib echelon_form_upt_k_0], \n      simp add: ncols_def)"], ["proof (state)\nthis:\n  echelon_form_upt_k (echelon_form_of_upt_k A 0 bezout) (Suc 0)\n\ngoal (3 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc 0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc 0]))) +\n          1)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "have rw_upt: \"[0..<Suc 0] = [0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc 0] = [0]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc 0] = [0]\n\ngoal (3 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc 0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc 0]))) +\n          1)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "show \"foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]),\n    if \\<forall>m. is_zero_row_upt_k m (Suc 0) (fst (foldl (echelon_form_of_column_k bezout) \n    (A, 0) [0..<Suc 0])) then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc 0) \n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]))) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc 0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc 0]))) +\n          1)", "unfolding rw_upt"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (echelon_form_of_column_k bezout) (A, 0) [0] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0]))) +\n          1)", "unfolding foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_of_column_k bezout (A, 0) 0 =\n    (fst (echelon_form_of_column_k bezout (A, 0) 0),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (echelon_form_of_column_k bezout (A, 0) 0))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (echelon_form_of_column_k bezout (A, 0) 0))) +\n          1)", "unfolding echelon_form_of_column_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (A, i) = (A, 0)\n     in if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n               A $ m $ mod_type_class.from_nat 0 = (0::'a)) \\<or>\n           i = nrows A\n        then (A, i)\n        else if \\<forall>m>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat 0 = (0::'a)\n             then (A, i + 1)\n             else let n = LEAST n.\n                             A $ n $ mod_type_class.from_nat 0 \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n;\n                      interchange_A =\n                        interchange_rows A (mod_type_class.from_nat i) n\n                  in (bezout_iterate interchange_A (nrows A - 1)\n                       (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat 0) bezout,\n                      i + 1)) =\n    (fst (let (A, i) = (A, 0)\n          in if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat 0 = (0::'a)) \\<or>\n                i = nrows A\n             then (A, i)\n             else if \\<forall>m>mod_type_class.from_nat i.\n                        A $ m $ mod_type_class.from_nat 0 = (0::'a)\n                  then (A, i + 1)\n                  else let n = LEAST n.\n                                  A $ n $ mod_type_class.from_nat 0 \\<noteq>\n                                  (0::'a) \\<and>\n                                  mod_type_class.from_nat i \\<le> n;\n                           interchange_A =\n                             interchange_rows A (mod_type_class.from_nat i)\n                              n\n                       in (bezout_iterate interchange_A (nrows A - 1)\n                            (mod_type_class.from_nat i)\n                            (mod_type_class.from_nat 0) bezout,\n                           i + 1)),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (let (A, i) = (A, 0)\n                  in if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                            A $ m $ mod_type_class.from_nat 0 =\n                            (0::'a)) \\<or>\n                        i = nrows A\n                     then (A, i)\n                     else if \\<forall>m>mod_type_class.from_nat i.\n                                A $ m $ mod_type_class.from_nat 0 = (0::'a)\n                          then (A, i + 1)\n                          else let n = LEAST n.\n    A $ n $ mod_type_class.from_nat 0 \\<noteq> (0::'a) \\<and>\n    mod_type_class.from_nat i \\<le> n;\n                                   interchange_A =\n                                     interchange_rows A\n(mod_type_class.from_nat i) n\n                               in (bezout_iterate interchange_A\n                                    (nrows A - 1)\n                                    (mod_type_class.from_nat i)\n                                    (mod_type_class.from_nat 0) bezout,\n                                   i + 1)))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (let (A, i) = (A, 0)\n                             in if (\\<forall>m\\<ge>mod_type_class.from_nat\n              i.\n A $ m $ mod_type_class.from_nat 0 = (0::'a)) \\<or>\n                                   i = nrows A\n                                then (A, i)\n                                else if \\<forall>m>mod_type_class.from_nat\n              i.\n     A $ m $ mod_type_class.from_nat 0 = (0::'a)\n                                     then (A, i + 1)\n                                     else let n =\n          LEAST n.\n             A $ n $ mod_type_class.from_nat 0 \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n;\n        interchange_A = interchange_rows A (mod_type_class.from_nat i) n\n    in (bezout_iterate interchange_A (nrows A - 1)\n         (mod_type_class.from_nat i) (mod_type_class.from_nat 0) bezout,\n        i + 1)))) +\n          1)", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (A, 0) of\n     (A, i) \\<Rightarrow>\n       if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n              A $ m $ mod_type_class.from_nat 0 = (0::'a)) \\<or>\n          i = nrows A\n       then (A, i)\n       else if \\<forall>m>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat 0 = (0::'a)\n            then (A, i + 1)\n            else (bezout_iterate\n                   (interchange_rows A (mod_type_class.from_nat i)\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat 0 \\<noteq>\n                         (0::'a) \\<and>\n                         mod_type_class.from_nat i \\<le> n))\n                   (nrows A - 1) (mod_type_class.from_nat i)\n                   (mod_type_class.from_nat 0) bezout,\n                  i + 1)) =\n    (fst (case (A, 0) of\n          (A, i) \\<Rightarrow>\n            if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat 0 = (0::'a)) \\<or>\n               i = nrows A\n            then (A, i)\n            else if \\<forall>m>mod_type_class.from_nat i.\n                       A $ m $ mod_type_class.from_nat 0 = (0::'a)\n                 then (A, i + 1)\n                 else (bezout_iterate\n                        (interchange_rows A (mod_type_class.from_nat i)\n                          (LEAST n.\n                              A $ n $ mod_type_class.from_nat 0 \\<noteq>\n                              (0::'a) \\<and>\n                              mod_type_class.from_nat i \\<le> n))\n                        (nrows A - 1) (mod_type_class.from_nat i)\n                        (mod_type_class.from_nat 0) bezout,\n                       i + 1)),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (case (A, 0) of\n                  (A, i) \\<Rightarrow>\n                    if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                           A $ m $ mod_type_class.from_nat 0 =\n                           (0::'a)) \\<or>\n                       i = nrows A\n                    then (A, i)\n                    else if \\<forall>m>mod_type_class.from_nat i.\n                               A $ m $ mod_type_class.from_nat 0 = (0::'a)\n                         then (A, i + 1)\n                         else (bezout_iterate\n                                (interchange_rows A\n                                  (mod_type_class.from_nat i)\n                                  (LEAST n.\nA $ n $ mod_type_class.from_nat 0 \\<noteq> (0::'a) \\<and>\nmod_type_class.from_nat i \\<le> n))\n                                (nrows A - 1) (mod_type_class.from_nat i)\n                                (mod_type_class.from_nat 0) bezout,\n                               i + 1)))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (case (A, 0) of\n                             (A, i) \\<Rightarrow>\n                               if (\\<forall>m\\<ge>mod_type_class.from_nat i.\nA $ m $ mod_type_class.from_nat 0 = (0::'a)) \\<or>\n                                  i = nrows A\n                               then (A, i)\n                               else if \\<forall>m>mod_type_class.from_nat i.\n    A $ m $ mod_type_class.from_nat 0 = (0::'a)\n                                    then (A, i + 1)\n                                    else (bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat 0 \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - 1) (mod_type_class.from_nat i) (mod_type_class.from_nat 0)\n     bezout,\n    i + 1)))) +\n          1)", "unfolding split_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (\\<forall>m\\<ge>mod_type_class.from_nat (snd (A, 0)).\n            fst (A, 0) $ m $ mod_type_class.from_nat 0 = (0::'a)) \\<or>\n        snd (A, 0) = nrows (fst (A, 0))\n     then (fst (A, 0), snd (A, 0))\n     else if \\<forall>m>mod_type_class.from_nat (snd (A, 0)).\n                fst (A, 0) $ m $ mod_type_class.from_nat 0 = (0::'a)\n          then (fst (A, 0), snd (A, 0) + 1)\n          else (bezout_iterate\n                 (interchange_rows (fst (A, 0))\n                   (mod_type_class.from_nat (snd (A, 0)))\n                   (LEAST n.\n                       fst (A, 0) $ n $ mod_type_class.from_nat 0 \\<noteq>\n                       (0::'a) \\<and>\n                       mod_type_class.from_nat (snd (A, 0)) \\<le> n))\n                 (nrows (fst (A, 0)) - 1)\n                 (mod_type_class.from_nat (snd (A, 0)))\n                 (mod_type_class.from_nat 0) bezout,\n                snd (A, 0) + 1)) =\n    (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat (snd (A, 0)).\n                 fst (A, 0) $ m $ mod_type_class.from_nat 0 = (0::'a)) \\<or>\n             snd (A, 0) = nrows (fst (A, 0))\n          then (fst (A, 0), snd (A, 0))\n          else if \\<forall>m>mod_type_class.from_nat (snd (A, 0)).\n                     fst (A, 0) $ m $ mod_type_class.from_nat 0 = (0::'a)\n               then (fst (A, 0), snd (A, 0) + 1)\n               else (bezout_iterate\n                      (interchange_rows (fst (A, 0))\n                        (mod_type_class.from_nat (snd (A, 0)))\n                        (LEAST n.\n                            fst (A, 0) $ n $\n                            mod_type_class.from_nat 0 \\<noteq>\n                            (0::'a) \\<and>\n                            mod_type_class.from_nat (snd (A, 0)) \\<le> n))\n                      (nrows (fst (A, 0)) - 1)\n                      (mod_type_class.from_nat (snd (A, 0)))\n                      (mod_type_class.from_nat 0) bezout,\n                     snd (A, 0) + 1)),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat (snd (A, 0)).\n                         fst (A, 0) $ m $ mod_type_class.from_nat 0 =\n                         (0::'a)) \\<or>\n                     snd (A, 0) = nrows (fst (A, 0))\n                  then (fst (A, 0), snd (A, 0))\n                  else if \\<forall>m>mod_type_class.from_nat (snd (A, 0)).\n                             fst (A, 0) $ m $ mod_type_class.from_nat 0 =\n                             (0::'a)\n                       then (fst (A, 0), snd (A, 0) + 1)\n                       else (bezout_iterate\n                              (interchange_rows (fst (A, 0))\n                                (mod_type_class.from_nat (snd (A, 0)))\n                                (LEAST n.\n                                    fst (A, 0) $ n $\n                                    mod_type_class.from_nat 0 \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat (snd (A, 0))\n                                    \\<le> n))\n                              (nrows (fst (A, 0)) - 1)\n                              (mod_type_class.from_nat (snd (A, 0)))\n                              (mod_type_class.from_nat 0) bezout,\n                             snd (A, 0) + 1)))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat\n           (snd (A, 0)).\n                                    fst (A, 0) $ m $\n                                    mod_type_class.from_nat 0 =\n                                    (0::'a)) \\<or>\n                                snd (A, 0) = nrows (fst (A, 0))\n                             then (fst (A, 0), snd (A, 0))\n                             else if \\<forall>m>mod_type_class.from_nat\n           (snd (A, 0)).\n  fst (A, 0) $ m $ mod_type_class.from_nat 0 = (0::'a)\n                                  then (fst (A, 0), snd (A, 0) + 1)\n                                  else (bezout_iterate\n   (interchange_rows (fst (A, 0)) (mod_type_class.from_nat (snd (A, 0)))\n     (LEAST n.\n         fst (A, 0) $ n $ mod_type_class.from_nat 0 \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat (snd (A, 0)) \\<le> n))\n   (nrows (fst (A, 0)) - 1) (mod_type_class.from_nat (snd (A, 0)))\n   (mod_type_class.from_nat 0) bezout,\n  snd (A, 0) + 1)))) +\n          1)", "unfolding from_nat_0 fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (\\<forall>m\\<ge>0::'rows. A $ m $ (0::'cols) = (0::'a)) \\<or>\n        0 = nrows A\n     then (A, 0)\n     else if \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\n          then (A, 0 + 1)\n          else (bezout_iterate\n                 (interchange_rows A (0::'rows)\n                   (LEAST n.\n                       A $ n $ (0::'cols) \\<noteq> (0::'a) \\<and>\n                       (0::'rows) \\<le> n))\n                 (nrows A - 1) (0::'rows) (0::'cols) bezout,\n                0 + 1)) =\n    (fst (if (\\<forall>m\\<ge>0::'rows. A $ m $ (0::'cols) = (0::'a)) \\<or>\n             0 = nrows A\n          then (A, 0)\n          else if \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\n               then (A, 0 + 1)\n               else (bezout_iterate\n                      (interchange_rows A (0::'rows)\n                        (LEAST n.\n                            A $ n $ (0::'cols) \\<noteq> (0::'a) \\<and>\n                            (0::'rows) \\<le> n))\n                      (nrows A - 1) (0::'rows) (0::'cols) bezout,\n                     0 + 1)),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (fst (if (\\<forall>m\\<ge>0::'rows.\n                         A $ m $ (0::'cols) = (0::'a)) \\<or>\n                     0 = nrows A\n                  then (A, 0)\n                  else if \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\n                       then (A, 0 + 1)\n                       else (bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq>\n                                    (0::'a) \\<and>\n                                    (0::'rows) \\<le> n))\n                              (nrows A - 1) (0::'rows) (0::'cols) bezout,\n                             0 + 1)))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (fst (if (\\<forall>m\\<ge>0::'rows.\n                                    A $ m $ (0::'cols) = (0::'a)) \\<or>\n                                0 = nrows A\n                             then (A, 0)\n                             else if \\<forall>m>0::'rows.\n  A $ m $ (0::'cols) = (0::'a)\n                                  then (A, 0 + 1)\n                                  else (bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n.\n         A $ n $ (0::'cols) \\<noteq> (0::'a) \\<and> (0::'rows) \\<le> n))\n   (nrows A - 1) (0::'rows) (0::'cols) bezout,\n  0 + 1)))) +\n          1)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (\\<forall>m\\<ge>0::'rows. A $ m $ (0::'cols) = (0::'a)) \\<or>\n        0 = nrows A\n     then (A, 0)\n     else if \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\n          then (A, 0 + 1)\n          else (bezout_iterate\n                 (interchange_rows A (0::'rows)\n                   (LEAST n.\n                       A $ n $ (0::'cols) \\<noteq> (0::'a) \\<and>\n                       (0::'rows) \\<le> n))\n                 (nrows A - 1) (0::'rows) (0::'cols) bezout,\n                0 + 1)) =\n    (fst (if (\\<forall>m\\<ge>0::'rows. A $ m $ (0::'cols) = (0::'a)) \\<or>\n             0 = nrows A\n          then (A, 0)\n          else if \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\n               then (A, 0 + 1)\n               else (bezout_iterate\n                      (interchange_rows A (0::'rows)\n                        (LEAST n.\n                            A $ n $ (0::'cols) \\<noteq> (0::'a) \\<and>\n                            (0::'rows) \\<le> n))\n                      (nrows A - 1) (0::'rows) (0::'cols) bezout,\n                     0 + 1)),\n     if \\<forall>m j.\n           mod_type_class.to_nat j < Suc 0 \\<longrightarrow>\n           fst (if (\\<forall>m\\<ge>0::'rows.\n                       A $ m $ (0::'cols) = (0::'a)) \\<or>\n                   0 = nrows A\n                then (A, 0)\n                else if \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\n                     then (A, 0 + 1)\n                     else (bezout_iterate\n                            (interchange_rows A (0::'rows)\n                              (LEAST n.\n                                  A $ n $ (0::'cols) \\<noteq> (0::'a) \\<and>\n                                  (0::'rows) \\<le> n))\n                            (nrows A - 1) (0::'rows) (0::'cols) bezout,\n                           0 + 1)) $\n           m $\n           j =\n           (0::'a)\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> (\\<forall>j.\n                          mod_type_class.to_nat j < Suc 0 \\<longrightarrow>\n                          fst (if (\\<forall>m\\<ge>0::'rows.\nA $ m $ (0::'cols) = (0::'a)) \\<or>\n                                  0 = nrows A\n                               then (A, 0)\n                               else if \\<forall>m>0::'rows.\n    A $ m $ (0::'cols) = (0::'a)\n                                    then (A, 0 + 1)\n                                    else (bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n.\n           A $ n $ (0::'cols) \\<noteq> (0::'a) \\<and> (0::'rows) \\<le> n))\n     (nrows A - 1) (0::'rows) (0::'cols) bezout,\n    0 + 1)) $\n                          n $\n                          j =\n                          (0::'a))) +\n          1)", "apply (auto simp add: least_mod_type to_nat_eq_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        \\<forall>m.\n           bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n           m $\n           (0::'cols) =\n           (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 2. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        \\<forall>m.\n           bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n           m $\n           (0::'cols) =\n           (0::'a);\n        (0::'rows) < ma; A $ ma $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ mb $ (0::'cols) = (0::'a)\n 3. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 4. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "apply (metis (mono_tags, lifting) GreatestI least_mod_type less_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        \\<forall>m.\n           bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n           m $\n           (0::'cols) =\n           (0::'a);\n        (0::'rows) < ma; A $ ma $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ mb $ (0::'cols) = (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 3. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        \\<forall>m.\n           bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n           m $\n           (0::'cols) =\n           (0::'a);\n        (0::'rows) < ma; A $ ma $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ mb $ (0::'cols) = (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 3. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "fix m mb"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        \\<forall>m.\n           bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n           m $\n           (0::'cols) =\n           (0::'a);\n        (0::'rows) < ma; A $ ma $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ mb $ (0::'cols) = (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 3. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "assume\"A $ m $ 0 \\<noteq> 0\"\n      and all_zero: \"\\<forall>m. bezout_iterate ?interchange (nrows A - Suc 0) 0 0 bezout $ m $ 0 = 0\""], ["proof (state)\nthis:\n  A $ m $ (0::'cols) \\<noteq> (0::'a)\n  \\<forall>m.\n     bezout_iterate\n      (interchange_rows A (0::'rows)\n        (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n      (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n     m $\n     (0::'cols) =\n     (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        \\<forall>m.\n           bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n           m $\n           (0::'cols) =\n           (0::'a);\n        (0::'rows) < ma; A $ ma $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ mb $ (0::'cols) = (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 3. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "have \"bezout_iterate ?interchange (nrows A - Suc 0) 0 0 bezout $ 0 $ 0 = \n      bezout_iterate ?interchange (nrows A - Suc 0) 0 (from_nat 0) bezout $ 0 $ from_nat 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n    (0::'rows) $\n    (0::'cols) =\n    bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n    (0::'rows) $\n    mod_type_class.from_nat 0", "using from_nat_0"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat 0 = (0::?'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n    (0::'rows) $\n    (0::'cols) =\n    bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n    (0::'rows) $\n    mod_type_class.from_nat 0", "by metis"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) =\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n  (0::'rows) $\n  mod_type_class.from_nat 0\n\ngoal (3 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        \\<forall>m.\n           bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n           m $\n           (0::'cols) =\n           (0::'a);\n        (0::'rows) < ma; A $ ma $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ mb $ (0::'cols) = (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 3. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "also"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) =\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n  (0::'rows) $\n  mod_type_class.from_nat 0\n\ngoal (3 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        \\<forall>m.\n           bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n           m $\n           (0::'cols) =\n           (0::'a);\n        (0::'rows) < ma; A $ ma $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ mb $ (0::'cols) = (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 3. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n    (0::'rows) $\n    mod_type_class.from_nat 0 \\<noteq>\n    (0::'a)", "proof (rule bezout_iterate_not_zero[OF _ _ _ ib], simp_all add: nrows_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) $\n    mod_type_class.from_nat 0 \\<noteq>\n    (0::'a)\n 2. mod_type_class.to_nat (0::'rows) \\<le> CARD('rows) - Suc 0", "show \"A $ (LEAST n. A $ n $ 0 \\<noteq> 0) $ from_nat 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) $\n    mod_type_class.from_nat 0 \\<noteq>\n    (0::'a)", "by (metis (mono_tags) LeastI \\<open>A $ m $ 0 \\<noteq> 0\\<close> from_nat_0)"], ["proof (state)\nthis:\n  A $ (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) $\n  mod_type_class.from_nat 0 \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (0::'rows) \\<le> CARD('rows) - Suc 0", "show \"to_nat 0 \\<le> CARD('rows) - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (0::'b) \\<le> CARD('rows) - Suc 0", "by (metis le0 to_nat_0)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (0::?'b1) \\<le> CARD('rows) - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n  (0::'rows) $\n  mod_type_class.from_nat 0 \\<noteq>\n  (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        \\<forall>m.\n           bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n           m $\n           (0::'cols) =\n           (0::'a);\n        (0::'rows) < ma; A $ ma $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ mb $ (0::'cols) = (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 3. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "finally"], ["proof (chain)\npicking this:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) \\<noteq>\n  (0::'a)", "have \" bezout_iterate ?interchange (nrows A - Suc 0) 0 0 bezout $ 0 $ 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n    (0::'rows) $\n    (0::'cols) \\<noteq>\n    (0::'a)", "."], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) \\<noteq>\n  (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        \\<forall>m.\n           bezout_iterate\n            (interchange_rows A (0::'rows)\n              (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n            (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n           m $\n           (0::'cols) =\n           (0::'a);\n        (0::'rows) < ma; A $ ma $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ mb $ (0::'cols) = (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 3. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "thus \"A $ mb $ 0 = 0\""], ["proof (prove)\nusing this:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ mb $ (0::'cols) = (0::'a)", "using all_zero"], ["proof (prove)\nusing this:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) \\<noteq>\n  (0::'a)\n  \\<forall>m.\n     bezout_iterate\n      (interchange_rows A (0::'rows)\n        (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n      (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n     m $\n     (0::'cols) =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. A $ mb $ (0::'cols) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ mb $ (0::'cols) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 2. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 2. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 2. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "assume Am0: \"A $ m $ 0 \\<noteq> 0\"\n      and all_zero: \"\\<forall>m>0. A $ m $ 0 = 0\""], ["proof (state)\nthis:\n  A $ m $ (0::'cols) \\<noteq> (0::'a)\n  \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) =\n                         (0::'rows)\n 2. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "thus \"(GREATEST n. A $ n $ 0 \\<noteq> 0) = 0\""], ["proof (prove)\nusing this:\n  A $ m $ (0::'cols) \\<noteq> (0::'a)\n  \\<forall>m>0::'rows. A $ m $ (0::'cols) = (0::'a)\n\ngoal (1 subgoal):\n 1. (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) = (0::'rows)", "by (metis (mono_tags, lifting) GreatestI neq_iff not_less0 to_nat_0 to_nat_mono)"], ["proof (state)\nthis:\n  (GREATEST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) = (0::'rows)\n\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "fix m ma mb"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "assume \"A $ m $ 0 \\<noteq> 0\" and \"bezout_iterate (interchange_rows A 0 (LEAST n. A $ n $ 0 \\<noteq> 0)) \n      (nrows A - Suc 0) 0 0 bezout $ ma $ 0 \\<noteq> 0\""], ["proof (state)\nthis:\n  A $ m $ (0::'cols) \\<noteq> (0::'a)\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  ma $\n  (0::'cols) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "have \"bezout_iterate ?interchange (nrows A - Suc 0) 0 0 bezout $ 0 $ 0 = \n      bezout_iterate ?interchange (nrows A - Suc 0) 0 (from_nat 0) bezout $ 0 $ from_nat 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n    (0::'rows) $\n    (0::'cols) =\n    bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n    (0::'rows) $\n    mod_type_class.from_nat 0", "using from_nat_0"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat 0 = (0::?'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n    (0::'rows) $\n    (0::'cols) =\n    bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n    (0::'rows) $\n    mod_type_class.from_nat 0", "by metis"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) =\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n  (0::'rows) $\n  mod_type_class.from_nat 0\n\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "also"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) =\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n  (0::'rows) $\n  mod_type_class.from_nat 0\n\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n    (0::'rows) $\n    mod_type_class.from_nat 0 \\<noteq>\n    (0::'a)", "proof (rule bezout_iterate_not_zero[OF _ _ _ ib], simp_all add: nrows_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) $\n    mod_type_class.from_nat 0 \\<noteq>\n    (0::'a)\n 2. mod_type_class.to_nat (0::'rows) \\<le> CARD('rows) - Suc 0", "show \"A $ (LEAST n. A $ n $ 0 \\<noteq> 0) $ from_nat 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) $\n    mod_type_class.from_nat 0 \\<noteq>\n    (0::'a)", "by (metis (mono_tags) LeastI \\<open>A $ m $ 0 \\<noteq> 0\\<close> from_nat_0)"], ["proof (state)\nthis:\n  A $ (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) $\n  mod_type_class.from_nat 0 \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (0::'rows) \\<le> CARD('rows) - Suc 0", "show \"to_nat 0 \\<le> CARD('rows) - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (0::'b) \\<le> CARD('rows) - Suc 0", "by (metis le0 to_nat_0)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (0::?'b1) \\<le> CARD('rows) - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n  (0::'rows) $\n  mod_type_class.from_nat 0 \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "finally"], ["proof (chain)\npicking this:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) \\<noteq>\n  (0::'a)", "have 1: \"bezout_iterate ?interchange (nrows A - Suc 0) 0 0 bezout $ 0 $ 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n    (0::'rows) $\n    (0::'cols) \\<noteq>\n    (0::'a)", "."], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  (0::'rows) $\n  (0::'cols) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "have 2: \"\\<forall>m>0. bezout_iterate ?interchange (nrows A - Suc 0) 0 0 bezout $ m $ 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m>0::'rows.\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n       m $\n       (0::'cols) =\n       (0::'a)", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       (0::'rows) < m \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n       m $\n       (0::'cols) =\n       (0::'a)", "fix b::'rows"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       (0::'rows) < m \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n       m $\n       (0::'cols) =\n       (0::'a)", "assume b: \"0<b\""], ["proof (state)\nthis:\n  (0::'rows) < b\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       (0::'rows) < m \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n       m $\n       (0::'cols) =\n       (0::'a)", "have \"bezout_iterate ?interchange (nrows A - Suc 0) 0 0 bezout $ b $ 0 \n        = bezout_iterate ?interchange (nrows A - Suc 0) 0 (from_nat 0) bezout $ b $ from_nat 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n    b $\n    (0::'cols) =\n    bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n    b $\n    mod_type_class.from_nat 0", "using from_nat_0"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat 0 = (0::?'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n    b $\n    (0::'cols) =\n    bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n    b $\n    mod_type_class.from_nat 0", "by metis"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  b $\n  (0::'cols) =\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n  b $\n  mod_type_class.from_nat 0\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       (0::'rows) < m \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n       m $\n       (0::'cols) =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  b $\n  (0::'cols) =\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n  b $\n  mod_type_class.from_nat 0\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       (0::'rows) < m \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n       m $\n       (0::'cols) =\n       (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n    b $\n    mod_type_class.from_nat 0 =\n    (0::'a)", "proof (rule bezout_iterate_zero_column_k[OF _ ib])"], ["proof (state)\ngoal (7 subgoals):\n 1. echelon_form_upt_k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     0\n 2. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) $\n    (0::'rows) $\n    mod_type_class.from_nat 0 \\<noteq>\n    (0::'a)\n 3. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n 4. (0::'rows) < b\n 5. 0 < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n 6. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 7. is_zero_row_upt_k (0::'rows) 0\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))", "show \"echelon_form_upt_k (?interchange) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     0", "by (metis echelon_form_upt_k_0)"], ["proof (state)\nthis:\n  echelon_form_upt_k\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   0\n\ngoal (6 subgoals):\n 1. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) $\n    (0::'rows) $\n    mod_type_class.from_nat 0 \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n 3. (0::'rows) < b\n 4. 0 < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n 5. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 6. is_zero_row_upt_k (0::'rows) 0\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))", "show \"?interchange $ 0 $ from_nat 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) $\n    (0::'rows) $\n    mod_type_class.from_nat 0 \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) LeastI_ex \\<open>A $ m $ 0 \\<noteq> 0\\<close> from_nat_0 interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (0::'rows)\n   (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)) $\n  (0::'rows) $\n  mod_type_class.from_nat 0 \\<noteq>\n  (0::'a)\n\ngoal (5 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n 2. (0::'rows) < b\n 3. 0 < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n 4. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 5. is_zero_row_upt_k (0::'rows) 0\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))", "show \"nrows A - Suc 0 < nrows (?interchange)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n\ngoal (4 subgoals):\n 1. (0::'rows) < b\n 2. 0 < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n 3. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 4. is_zero_row_upt_k (0::'rows) 0\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))", "show \"0 < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'rows) < b", "using b"], ["proof (prove)\nusing this:\n  (0::'rows) < b\n\ngoal (1 subgoal):\n 1. (0::'rows) < b", "."], ["proof (state)\nthis:\n  (0::'rows) < b\n\ngoal (3 subgoals):\n 1. 0 < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n 2. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 3. is_zero_row_upt_k (0::'rows) 0\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))", "show \"0 < ncols (?interchange)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ncols\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < CARD('cols)", "by auto"], ["proof (state)\nthis:\n  0 < ncols\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat b \\<le> nrows A - Suc 0\n 2. is_zero_row_upt_k (0::'rows) 0\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))", "show \"to_nat b \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b \\<le> nrows A - Suc 0", "by (metis Suc_eq_plus1 discrete less_one add.left_neutral not_le \n            nrows_def nrows_not_0 le_diff_conv2 to_nat_less_card)"], ["proof (state)\nthis:\n  mod_type_class.to_nat b \\<le> nrows A - Suc 0\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (0::'rows) 0\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))", "show \"is_zero_row_upt_k 0 0 (?interchange)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (0::'rows) 0\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))", "by (metis is_zero_row_utp_0)"], ["proof (state)\nthis:\n  is_zero_row_upt_k (0::'rows) 0\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (mod_type_class.from_nat 0) bezout $\n  b $\n  mod_type_class.from_nat 0 =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       (0::'rows) < m \\<Longrightarrow>\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n       m $\n       (0::'cols) =\n       (0::'a)", "finally"], ["proof (chain)\npicking this:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  b $\n  (0::'cols) =\n  (0::'a)", "show \"bezout_iterate (interchange_rows A 0 (LEAST n. A $ n $ 0 \\<noteq> 0)) \n        (nrows A - Suc 0) 0 0 bezout $ b $ 0 = 0\""], ["proof (prove)\nusing this:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  b $\n  (0::'cols) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. bezout_iterate\n     (interchange_rows A (0::'rows)\n       (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n     (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n    b $\n    (0::'cols) =\n    (0::'a)", "."], ["proof (state)\nthis:\n  bezout_iterate\n   (interchange_rows A (0::'rows)\n     (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n   (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n  b $\n  (0::'cols) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m>0::'rows.\n     bezout_iterate\n      (interchange_rows A (0::'rows)\n        (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n      (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n     m $\n     (0::'cols) =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>A $ m $ (0::'cols) \\<noteq> (0::'a);\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        ma $\n        (0::'cols) \\<noteq>\n        (0::'a);\n        (0::'rows) < mb; A $ mb $ (0::'cols) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             bezout_iterate\n                              (interchange_rows A (0::'rows)\n                                (LEAST n.\n                                    A $ n $ (0::'cols) \\<noteq> (0::'a)))\n                              (nrows A - Suc 0) (0::'rows) (0::'cols)\n                              bezout $\n                             n $\n                             (0::'cols) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "show \"(GREATEST n. bezout_iterate (interchange_rows A 0 (LEAST n. A $ n $ 0 \\<noteq> 0)) \n      (nrows A - Suc 0) 0 0 bezout $ n $ 0 \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n.\n        bezout_iterate\n         (interchange_rows A (0::'rows)\n           (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n         (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n        n $\n        (0::'cols) \\<noteq>\n        (0::'a)) =\n    (0::'rows)", "apply (rule Greatest_equality, simp add: 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n       y $\n       (0::'cols) \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "using 2"], ["proof (prove)\nusing this:\n  \\<forall>m>0::'rows.\n     bezout_iterate\n      (interchange_rows A (0::'rows)\n        (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n      (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n     m $\n     (0::'cols) =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       bezout_iterate\n        (interchange_rows A (0::'rows)\n          (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n        (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n       y $\n       (0::'cols) \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "by force"], ["proof (state)\nthis:\n  (GREATEST n.\n      bezout_iterate\n       (interchange_rows A (0::'rows)\n         (LEAST n. A $ n $ (0::'cols) \\<noteq> (0::'a)))\n       (nrows A - Suc 0) (0::'rows) (0::'cols) bezout $\n      n $\n      (0::'cols) \\<noteq>\n      (0::'a)) =\n  (0::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0] =\n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]),\n   if \\<forall>m.\n         is_zero_row_upt_k m (Suc 0)\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc 0)\n                     (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                            [0..<Suc 0]))) +\n        1)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "let ?fold=\"(foldl (echelon_form_of_column_k bezout)(A, 0) [0..<Suc (Suc k)])\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "let ?fold2=\"(foldl (echelon_form_of_column_k bezout) (A, 0) [0..<(Suc k)])\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "assume \"(k < ncols A \\<Longrightarrow> echelon_form_upt_k (echelon_form_of_upt_k A k bezout) (Suc k))\" and\n    \"(k < ncols A \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n    (fst ?fold2, if \\<forall>m. is_zero_row_upt_k m (Suc k) (fst ?fold2) then 0\n    else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (fst ?fold2)) + 1))\"\n    and Suc_k: \"Suc k < ncols A\""], ["proof (state)\nthis:\n  k < ncols A \\<Longrightarrow>\n  echelon_form_upt_k (echelon_form_of_upt_k A k bezout) (Suc k)\n  k < ncols A \\<Longrightarrow>\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n   if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                            [0..<Suc k]))) +\n        1)\n  Suc k < ncols A\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "hence hyp_foldl: \"foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n    (fst ?fold2, if \\<forall>m. is_zero_row_upt_k m (Suc k) (fst ?fold2) then 0\n    else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (fst ?fold2)) + 1)\" \n    and hyp_echelon: \"echelon_form_upt_k (echelon_form_of_upt_k A k bezout) (Suc k)\""], ["proof (prove)\nusing this:\n  k < ncols A \\<Longrightarrow>\n  echelon_form_upt_k (echelon_form_of_upt_k A k bezout) (Suc k)\n  k < ncols A \\<Longrightarrow>\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n   if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                            [0..<Suc k]))) +\n        1)\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc k)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc k]))) +\n          1) &&&\n    echelon_form_upt_k (echelon_form_of_upt_k A k bezout) (Suc k)", "by auto"], ["proof (state)\nthis:\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n   if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                            [0..<Suc k]))) +\n        1)\n  echelon_form_upt_k (echelon_form_of_upt_k A k bezout) (Suc k)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "have rw: \"[0..<Suc (Suc k)]= [0..<(Suc k)] @ [(Suc k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by auto"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "have rw2: \"?fold2 = (echelon_form_of_upt_k A k bezout, if \\<forall>m. is_zero_row_upt_k m (Suc k) \n    (echelon_form_of_upt_k A k bezout) then 0 else\n    to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (echelon_form_of_upt_k A k bezout)) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n    (echelon_form_of_upt_k A k bezout,\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc k) (echelon_form_of_upt_k A k bezout)\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (echelon_form_of_upt_k A k bezout)) +\n          1)", "unfolding echelon_form_of_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc k)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc k]))) +\n          1)", "using hyp_foldl"], ["proof (prove)\nusing this:\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n   if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                            [0..<Suc k]))) +\n        1)\n\ngoal (1 subgoal):\n 1. foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc k)\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc k]))) +\n          1)", "by fast"], ["proof (state)\nthis:\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n  (echelon_form_of_upt_k A k bezout,\n   if \\<forall>m.\n         is_zero_row_upt_k m (Suc k) (echelon_form_of_upt_k A k bezout)\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (echelon_form_of_upt_k A k bezout)) +\n        1)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> echelon_form_upt_k\n                          (echelon_form_of_upt_k A (Suc k) bezout)\n                          (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "show \"echelon_form_upt_k (echelon_form_of_upt_k A (Suc k) bezout) (Suc (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k (echelon_form_of_upt_k A (Suc k) bezout)\n     (Suc (Suc k))", "unfolding echelon_form_of_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n            [0..<Suc (Suc k)]))\n     (Suc (Suc k))", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n            ([0..<Suc k] @ [Suc k])))\n     (Suc (Suc k))", "unfolding foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (fst (foldl (echelon_form_of_column_k bezout)\n            (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n            [Suc k]))\n     (Suc (Suc k))", "unfolding foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (fst (echelon_form_of_column_k bezout\n            (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n            (Suc k)))\n     (Suc (Suc k))", "unfolding rw2"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (fst (echelon_form_of_column_k bezout\n            (echelon_form_of_upt_k A k bezout,\n             if \\<forall>m.\n                   is_zero_row_upt_k m (Suc k)\n                    (echelon_form_of_upt_k A k bezout)\n             then 0\n             else mod_type_class.to_nat\n                   (GREATEST n.\n                       \\<not> is_zero_row_upt_k n (Suc k)\n                               (echelon_form_of_upt_k A k bezout)) +\n                  1)\n            (Suc k)))\n     (Suc (Suc k))", "proof (rule echelon_echelon_form_column_k[OF ib hyp_echelon])"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc k < ncols (echelon_form_of_upt_k A k bezout)", "show \"Suc k < ncols (echelon_form_of_upt_k A k bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k < ncols (echelon_form_of_upt_k A k bezout)", "using Suc_k"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. Suc k < ncols (echelon_form_of_upt_k A k bezout)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('cols)\n\ngoal (1 subgoal):\n 1. Suc k < CARD('cols)", "."], ["proof (state)\nthis:\n  Suc k < ncols (echelon_form_of_upt_k A k bezout)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  echelon_form_upt_k (echelon_form_of_upt_k A (Suc k) bezout) (Suc (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                echelon_form_upt_k (echelon_form_of_upt_k A k bezout)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1);\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc (Suc k)] =\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]))) +\n                               1)", "show \"foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)] =\n    (fst ?fold,\n    if \\<forall>m. is_zero_row_upt_k m (Suc (Suc k)) \n    (fst ?fold) then 0\n    else to_nat\n    (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) \n    (fst ?fold)) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)] =\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]),\n     if \\<forall>m.\n           is_zero_row_upt_k m (Suc (Suc k))\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc (Suc k)]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc (Suc k)]))) +\n          1)", "proof (rule prod_eqI, metis fst_conv)"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc (Suc k)]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc (Suc k)]))) +\n              1)", "define A' where \"A' = fst ?fold2\""], ["proof (state)\nthis:\n  A' = fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc (Suc k)]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc (Suc k)]))) +\n              1)", "let ?greatest=\"(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')\""], ["proof (state)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc (Suc k)]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc (Suc k)]))) +\n              1)", "have k: \"k < ncols A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols A'", "using Suc_k"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. k < ncols A'", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('cols)\n\ngoal (1 subgoal):\n 1. k < CARD('cols)", "by auto"], ["proof (state)\nthis:\n  k < ncols A'\n\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc (Suc k)]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc (Suc k)]))) +\n              1)", "have k2: \"Suc k < ncols A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k < ncols A'", "using Suc_k"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. Suc k < ncols A'", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('cols)\n\ngoal (1 subgoal):\n 1. Suc k < CARD('cols)", "by auto"], ["proof (state)\nthis:\n  Suc k < ncols A'\n\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc (Suc k)]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc (Suc k)]))) +\n              1)", "have fst_snd_foldl: \"snd ?fold2 = snd (fst ?fold2,\n      if \\<forall>m. is_zero_row_upt_k m (Suc k) (fst ?fold2) then 0\n      else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (fst ?fold2)) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1)", "using hyp_foldl"], ["proof (prove)\nusing this:\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k] =\n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n   if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                            [0..<Suc k]))) +\n        1)\n\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))) +\n              1)", "by simp"], ["proof (state)\nthis:\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) =\n  snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n       if \\<forall>m.\n             is_zero_row_upt_k m (Suc k)\n              (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k]))\n       then 0\n       else mod_type_class.to_nat\n             (GREATEST n.\n                 \\<not> is_zero_row_upt_k n (Suc k)\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc k]))) +\n            1)\n\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc (Suc k)]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc (Suc k)]))) +\n              1)", "have ncols_eq: \"ncols A = ncols A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols A = ncols A'", "unfolding A'_def ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('cols) = CARD('cols)", ".."], ["proof (state)\nthis:\n  ncols A = ncols A'\n\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc (Suc k)]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc (Suc k)]))) +\n              1)", "have rref_A': \"echelon_form_upt_k A' (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k A' (Suc k)", "using hyp_echelon"], ["proof (prove)\nusing this:\n  echelon_form_upt_k (echelon_form_of_upt_k A k bezout) (Suc k)\n\ngoal (1 subgoal):\n 1. echelon_form_upt_k A' (Suc k)", "unfolding A'_def echelon_form_of_upt_k_def"], ["proof (prove)\nusing this:\n  echelon_form_upt_k\n   (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n   (Suc k)\n\ngoal (1 subgoal):\n 1. echelon_form_upt_k\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n     (Suc k)", "."], ["proof (state)\nthis:\n  echelon_form_upt_k A' (Suc k)\n\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc (Suc k)]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc (Suc k)]))) +\n              1)", "show \"snd ?fold = snd (fst ?fold, if \\<forall>m. is_zero_row_upt_k m (Suc (Suc k)) (fst ?fold) then 0\n      else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) (fst ?fold)) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc (Suc k)]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc (Suc k)]))) +\n              1)", "using [[unfold_abs_def = false]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc (Suc k)]),\n         if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc (Suc k)]))) +\n              1)", "unfolding fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc (Suc k))\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc (Suc k)]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc (Suc k)]))) +\n          1)", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n          ([0..<Suc k] @ [Suc k])) =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc (Suc k))\n            (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   ([0..<Suc k] @ [Suc k])))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              ([0..<Suc k] @ [Suc k])))) +\n          1)", "unfolding foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k bezout)\n          (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n          [Suc k]) =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc (Suc k))\n            (fst (foldl (echelon_form_of_column_k bezout)\n                   (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k])\n                   [Suc k]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                       (fst (foldl (echelon_form_of_column_k bezout)\n                              (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc k])\n                              [Suc k]))) +\n          1)", "unfolding foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k bezout\n          (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n          (Suc k)) =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc (Suc k))\n            (fst (echelon_form_of_column_k bezout\n                   (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k])\n                   (Suc k)))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                       (fst (echelon_form_of_column_k bezout\n                              (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc k])\n                              (Suc k)))) +\n          1)", "unfolding echelon_form_of_column_k_def Let_def split_beta fst_snd_foldl"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (snd (fst (foldl\n   (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n                                   if \\<forall>m.\n   is_zero_row_upt_k m (Suc k)\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                                   then 0\n                                   else mod_type_class.to_nat\n   (GREATEST n.\n       \\<not> is_zero_row_upt_k n (Suc k)\n               (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                      [0..<Suc k]))) +\n  1)).\n                fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                      [0..<Suc k]) $\n                m $\n                mod_type_class.from_nat (Suc k) =\n                (0::'a)) \\<or>\n            snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]),\n                 if \\<forall>m.\n                       is_zero_row_upt_k m (Suc k)\n                        (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc k]))\n                 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST n.\n                           \\<not> is_zero_row_upt_k n (Suc k)\n                                   (fst (foldl\n    (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))) +\n                      1) =\n            nrows\n             (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                    [0..<Suc k]))\n         then (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k]),\n               snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc k]),\n                    if \\<forall>m.\n                          is_zero_row_upt_k m (Suc k)\n                           (fst (foldl (echelon_form_of_column_k bezout)\n                                  (A, 0) [0..<Suc k]))\n                    then 0\n                    else mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k)\n(fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))) +\n                         1))\n         else if \\<forall>m>mod_type_class.from_nat\n                             (snd (fst (foldl\n   (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n                                   if \\<forall>m.\n   is_zero_row_upt_k m (Suc k)\n    (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                                   then 0\n                                   else mod_type_class.to_nat\n   (GREATEST n.\n       \\<not> is_zero_row_upt_k n (Suc k)\n               (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                      [0..<Suc k]))) +\n  1)).\n                    fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc k]) $\n                    m $\n                    mod_type_class.from_nat (Suc k) =\n                    (0::'a)\n              then (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                          [0..<Suc k]),\n                    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc k]),\n                         if \\<forall>m.\n                               is_zero_row_upt_k m (Suc k)\n                                (fst (foldl\n (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                         then 0\n                         else mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k)\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))) +\n                              1) +\n                    1)\n              else (bezout_iterate\n                     (interchange_rows\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc k]))\n                       (mod_type_class.from_nat\n                         (snd (fst (foldl (echelon_form_of_column_k bezout)\n                                     (A, 0) [0..<Suc k]),\n                               if \\<forall>m.\n                                     is_zero_row_upt_k m (Suc k)\n(fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                               then 0\n                               else mod_type_class.to_nat\n                                     (GREATEST n.\n   \\<not> is_zero_row_upt_k n (Suc k)\n           (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                  [0..<Suc k]))) +\n                                    1)))\n                       (LEAST n.\n                           fst (foldl (echelon_form_of_column_k bezout)\n                                 (A, 0) [0..<Suc k]) $\n                           n $\n                           mod_type_class.from_nat (Suc k) \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat\n                            (snd (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n                                  if \\<forall>m.\n  is_zero_row_upt_k m (Suc k)\n   (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                                  then 0\n                                  else mod_type_class.to_nat\n  (GREATEST n.\n      \\<not> is_zero_row_upt_k n (Suc k)\n              (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k]))) +\n 1))\n                           \\<le> n))\n                     (nrows\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc k])) -\n                      1)\n                     (mod_type_class.from_nat\n                       (snd (fst (foldl (echelon_form_of_column_k bezout)\n                                   (A, 0) [0..<Suc k]),\n                             if \\<forall>m.\n                                   is_zero_row_upt_k m (Suc k)\n                                    (fst\n(foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                             then 0\n                             else mod_type_class.to_nat\n                                   (GREATEST n.\n \\<not> is_zero_row_upt_k n (Suc k)\n         (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                [0..<Suc k]))) +\n                                  1)))\n                     (mod_type_class.from_nat (Suc k)) bezout,\n                    snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc k]),\n                         if \\<forall>m.\n                               is_zero_row_upt_k m (Suc k)\n                                (fst (foldl\n (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                         then 0\n                         else mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k)\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))) +\n                              1) +\n                    1)) =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc (Suc k))\n            (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat\n(snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n      if \\<forall>m.\n            is_zero_row_upt_k m (Suc k)\n             (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                    [0..<Suc k]))\n      then 0\n      else mod_type_class.to_nat\n            (GREATEST n.\n                \\<not> is_zero_row_upt_k n (Suc k)\n                        (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc k]))) +\n           1)).\n                         fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc k]) $\n                         m $\n                         mod_type_class.from_nat (Suc k) =\n                         (0::'a)) \\<or>\n                     snd (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc k]),\n                          if \\<forall>m.\n                                is_zero_row_upt_k m (Suc k)\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))) +\n                               1) =\n                     nrows\n                      (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                             [0..<Suc k]))\n                  then (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc k]),\n                        snd (fst (foldl (echelon_form_of_column_k bezout)\n                                   (A, 0) [0..<Suc k]),\n                             if \\<forall>m.\n                                   is_zero_row_upt_k m (Suc k)\n                                    (fst\n(foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                             then 0\n                             else mod_type_class.to_nat\n                                   (GREATEST n.\n \\<not> is_zero_row_upt_k n (Suc k)\n         (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                [0..<Suc k]))) +\n                                  1))\n                  else if \\<forall>m>mod_type_class.from_nat\n(snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n      if \\<forall>m.\n            is_zero_row_upt_k m (Suc k)\n             (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                    [0..<Suc k]))\n      then 0\n      else mod_type_class.to_nat\n            (GREATEST n.\n                \\<not> is_zero_row_upt_k n (Suc k)\n                        (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc k]))) +\n           1)).\n                             fst (foldl (echelon_form_of_column_k bezout)\n                                   (A, 0) [0..<Suc k]) $\n                             m $\n                             mod_type_class.from_nat (Suc k) =\n                             (0::'a)\n                       then (fst (foldl (echelon_form_of_column_k bezout)\n                                   (A, 0) [0..<Suc k]),\n                             snd (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n                                  if \\<forall>m.\n  is_zero_row_upt_k m (Suc k)\n   (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                                  then 0\n                                  else mod_type_class.to_nat\n  (GREATEST n.\n      \\<not> is_zero_row_upt_k n (Suc k)\n              (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k]))) +\n 1) +\n                             1)\n                       else (bezout_iterate\n                              (interchange_rows\n                                (fst (foldl\n (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                                (mod_type_class.from_nat\n                                  (snd (fst\n   (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n  if \\<forall>m.\n        is_zero_row_upt_k m (Suc k)\n         (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n  then 0\n  else mod_type_class.to_nat\n        (GREATEST n.\n            \\<not> is_zero_row_upt_k n (Suc k)\n                    (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                           [0..<Suc k]))) +\n       1)))\n                                (LEAST n.\n                                    fst (foldl\n    (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) $\n                                    n $\n                                    mod_type_class.from_nat (Suc k) \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat\n                                     (snd\n (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n  if \\<forall>m.\n        is_zero_row_upt_k m (Suc k)\n         (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n  then 0\n  else mod_type_class.to_nat\n        (GREATEST n.\n            \\<not> is_zero_row_upt_k n (Suc k)\n                    (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                           [0..<Suc k]))) +\n       1))\n                                    \\<le> n))\n                              (nrows\n                                (fst (foldl\n (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])) -\n                               1)\n                              (mod_type_class.from_nat\n                                (snd (fst\n (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\nif \\<forall>m.\n      is_zero_row_upt_k m (Suc k)\n       (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\nthen 0\nelse mod_type_class.to_nat\n      (GREATEST n.\n          \\<not> is_zero_row_upt_k n (Suc k)\n                  (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                         [0..<Suc k]))) +\n     1)))\n                              (mod_type_class.from_nat (Suc k)) bezout,\n                             snd (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n                                  if \\<forall>m.\n  is_zero_row_upt_k m (Suc k)\n   (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                                  then 0\n                                  else mod_type_class.to_nat\n  (GREATEST n.\n      \\<not> is_zero_row_upt_k n (Suc k)\n              (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k]))) +\n 1) +\n                             1)))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                       (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat\n           (snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]),\n                 if \\<forall>m.\n                       is_zero_row_upt_k m (Suc k)\n                        (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc k]))\n                 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST n.\n                           \\<not> is_zero_row_upt_k n (Suc k)\n                                   (fst (foldl\n    (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))) +\n                      1)).\n                                    fst (foldl\n    (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) $\n                                    m $\n                                    mod_type_class.from_nat (Suc k) =\n                                    (0::'a)) \\<or>\n                                snd (fst\n(foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n                                     if \\<forall>m.\n     is_zero_row_upt_k m (Suc k)\n      (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                                     then 0\n                                     else mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                        [0..<Suc k]))) +\n    1) =\n                                nrows\n                                 (fst (foldl\n  (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n                             then (fst (foldl\n   (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n                                   snd (fst\n   (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n  if \\<forall>m.\n        is_zero_row_upt_k m (Suc k)\n         (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n  then 0\n  else mod_type_class.to_nat\n        (GREATEST n.\n            \\<not> is_zero_row_upt_k n (Suc k)\n                    (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                           [0..<Suc k]))) +\n       1))\n                             else if \\<forall>m>mod_type_class.from_nat\n           (snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                       [0..<Suc k]),\n                 if \\<forall>m.\n                       is_zero_row_upt_k m (Suc k)\n                        (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                               [0..<Suc k]))\n                 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST n.\n                           \\<not> is_zero_row_upt_k n (Suc k)\n                                   (fst (foldl\n    (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))) +\n                      1)).\n  fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) $ m $\n  mod_type_class.from_nat (Suc k) =\n  (0::'a)\n                                  then (fst\n   (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n  snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n       if \\<forall>m.\n             is_zero_row_upt_k m (Suc k)\n              (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k]))\n       then 0\n       else mod_type_class.to_nat\n             (GREATEST n.\n                 \\<not> is_zero_row_upt_k n (Suc k)\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc k]))) +\n            1) +\n  1)\n                                  else (bezout_iterate\n   (interchange_rows\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n     (mod_type_class.from_nat\n       (snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                   [0..<Suc k]),\n             if \\<forall>m.\n                   is_zero_row_upt_k m (Suc k)\n                    (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                           [0..<Suc k]))\n             then 0\n             else mod_type_class.to_nat\n                   (GREATEST n.\n                       \\<not> is_zero_row_upt_k n (Suc k)\n                               (fst (foldl (echelon_form_of_column_k bezout)\n(A, 0) [0..<Suc k]))) +\n                  1)))\n     (LEAST n.\n         fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) $\n         n $\n         mod_type_class.from_nat (Suc k) \\<noteq>\n         (0::'a) \\<and>\n         mod_type_class.from_nat\n          (snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                      [0..<Suc k]),\n                if \\<forall>m.\n                      is_zero_row_upt_k m (Suc k)\n                       (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                              [0..<Suc k]))\n                then 0\n                else mod_type_class.to_nat\n                      (GREATEST n.\n                          \\<not> is_zero_row_upt_k n (Suc k)\n                                  (fst (foldl\n   (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))) +\n                     1))\n         \\<le> n))\n   (nrows\n     (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])) -\n    1)\n   (mod_type_class.from_nat\n     (snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n           if \\<forall>m.\n                 is_zero_row_upt_k m (Suc k)\n                  (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                         [0..<Suc k]))\n           then 0\n           else mod_type_class.to_nat\n                 (GREATEST n.\n                     \\<not> is_zero_row_upt_k n (Suc k)\n                             (fst (foldl (echelon_form_of_column_k bezout)\n                                    (A, 0) [0..<Suc k]))) +\n                1)))\n   (mod_type_class.from_nat (Suc k)) bezout,\n  snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n       if \\<forall>m.\n             is_zero_row_upt_k m (Suc k)\n              (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc k]))\n       then 0\n       else mod_type_class.to_nat\n             (GREATEST n.\n                 \\<not> is_zero_row_upt_k n (Suc k)\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc k]))) +\n            1) +\n  1)))) +\n          1)", "unfolding A'_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (snd (A',\n                                   if \\<forall>m.\n   is_zero_row_upt_k m (Suc k) A'\n                                   then 0\n                                   else mod_type_class.to_nat\n   (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n  1)).\n                A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)) \\<or>\n            snd (A',\n                 if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n                 else mod_type_class.to_nat\n                       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      1) =\n            nrows A'\n         then (A',\n               snd (A',\n                    if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n                    else mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         1))\n         else if \\<forall>m>mod_type_class.from_nat\n                             (snd (A',\n                                   if \\<forall>m.\n   is_zero_row_upt_k m (Suc k) A'\n                                   then 0\n                                   else mod_type_class.to_nat\n   (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n  1)).\n                    A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n              then (A',\n                    snd (A',\n                         if \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n                         then 0\n                         else mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A') +\n                              1) +\n                    1)\n              else (bezout_iterate\n                     (interchange_rows A'\n                       (mod_type_class.from_nat\n                         (snd (A',\n                               if \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n                               then 0\n                               else mod_type_class.to_nat\n                                     (GREATEST n.\n   \\<not> is_zero_row_upt_k n (Suc k) A') +\n                                    1)))\n                       (LEAST n.\n                           A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                           (0::'a) \\<and>\n                           mod_type_class.from_nat\n                            (snd (A',\n                                  if \\<forall>m.\n  is_zero_row_upt_k m (Suc k) A'\n                                  then 0\n                                  else mod_type_class.to_nat\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n 1))\n                           \\<le> n))\n                     (nrows A' - 1)\n                     (mod_type_class.from_nat\n                       (snd (A',\n                             if \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n                             then 0\n                             else mod_type_class.to_nat\n                                   (GREATEST n.\n \\<not> is_zero_row_upt_k n (Suc k) A') +\n                                  1)))\n                     (mod_type_class.from_nat (Suc k)) bezout,\n                    snd (A',\n                         if \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n                         then 0\n                         else mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A') +\n                              1) +\n                    1)) =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc (Suc k))\n            (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat\n(snd (A',\n      if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n      else mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n           1)).\n                         A' $ m $ mod_type_class.from_nat (Suc k) =\n                         (0::'a)) \\<or>\n                     snd (A',\n                          if \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k) A') +\n                               1) =\n                     nrows A'\n                  then (A',\n                        snd (A',\n                             if \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n                             then 0\n                             else mod_type_class.to_nat\n                                   (GREATEST n.\n \\<not> is_zero_row_upt_k n (Suc k) A') +\n                                  1))\n                  else if \\<forall>m>mod_type_class.from_nat\n(snd (A',\n      if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n      else mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n           1)).\n                             A' $ m $ mod_type_class.from_nat (Suc k) =\n                             (0::'a)\n                       then (A',\n                             snd (A',\n                                  if \\<forall>m.\n  is_zero_row_upt_k m (Suc k) A'\n                                  then 0\n                                  else mod_type_class.to_nat\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n 1) +\n                             1)\n                       else (bezout_iterate\n                              (interchange_rows A'\n                                (mod_type_class.from_nat\n                                  (snd (A',\n  if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n  else mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n       1)))\n                                (LEAST n.\n                                    A' $ n $\n                                    mod_type_class.from_nat (Suc k) \\<noteq>\n                                    (0::'a) \\<and>\n                                    mod_type_class.from_nat\n                                     (snd\n (A',\n  if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n  else mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n       1))\n                                    \\<le> n))\n                              (nrows A' - 1)\n                              (mod_type_class.from_nat\n                                (snd (A',\nif \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\nelse mod_type_class.to_nat\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n     1)))\n                              (mod_type_class.from_nat (Suc k)) bezout,\n                             snd (A',\n                                  if \\<forall>m.\n  is_zero_row_upt_k m (Suc k) A'\n                                  then 0\n                                  else mod_type_class.to_nat\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n 1) +\n                             1)))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                       (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat\n           (snd (A',\n                 if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n                 else mod_type_class.to_nat\n                       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      1)).\n                                    A' $ m $\n                                    mod_type_class.from_nat (Suc k) =\n                                    (0::'a)) \\<or>\n                                snd (A',\n                                     if \\<forall>m.\n     is_zero_row_upt_k m (Suc k) A'\n                                     then 0\n                                     else mod_type_class.to_nat\n     (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n    1) =\n                                nrows A'\n                             then (A',\n                                   snd (A',\n  if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n  else mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n       1))\n                             else if \\<forall>m>mod_type_class.from_nat\n           (snd (A',\n                 if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n                 else mod_type_class.to_nat\n                       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      1)).\n  A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n                                  then (A',\n  snd (A',\n       if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n       else mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n            1) +\n  1)\n                                  else (bezout_iterate\n   (interchange_rows A'\n     (mod_type_class.from_nat\n       (snd (A',\n             if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n             else mod_type_class.to_nat\n                   (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  1)))\n     (LEAST n.\n         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat\n          (snd (A',\n                if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n                else mod_type_class.to_nat\n                      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     1))\n         \\<le> n))\n   (nrows A' - 1)\n   (mod_type_class.from_nat\n     (snd (A',\n           if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                1)))\n   (mod_type_class.from_nat (Suc k)) bezout,\n  snd (A',\n       if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n       else mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n            1) +\n  1)))) +\n          1)", "proof (auto simp add: least_mod_type from_nat_0 from_nat_to_nat_greatest)"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 4. \\<And>m.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 7. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 10. \\<And>m ma.\n        \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                    A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         (0::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A' (0::'rows)\n   (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\nA total of 29 subgoals...", "fix m"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 4. \\<And>m.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 7. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 10. \\<And>m ma.\n        \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                    A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         (0::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A' (0::'rows)\n   (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\nA total of 29 subgoals...", "assume \"A' $ m $ from_nat (Suc k) \\<noteq> 0\""], ["proof (state)\nthis:\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (29 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 4. \\<And>m.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 7. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 10. \\<And>m ma.\n        \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                    A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         (0::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A' (0::'rows)\n   (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\nA total of 29 subgoals...", "thus \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\" \n          and \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\"\n          and \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\"\n          and \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\"\n          and \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\"\n          and \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\"\n          and \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\"\n          and \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\""], ["proof (prove)\nusing this:\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. ((\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A' &&&\n      \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A') &&&\n     \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A' &&&\n     \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A') &&&\n    (\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A' &&&\n     \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A') &&&\n    \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A' &&&\n    \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. ((\\<exists>m.\n         \\<not> (\\<forall>j.\n                    mod_type_class.to_nat j < Suc (Suc k) \\<longrightarrow>\n                    A' $ m $ j = (0::'a)) &&&\n      \\<exists>m.\n         \\<not> (\\<forall>j.\n                    mod_type_class.to_nat j < Suc (Suc k) \\<longrightarrow>\n                    A' $ m $ j = (0::'a))) &&&\n     \\<exists>m.\n        \\<not> (\\<forall>j.\n                   mod_type_class.to_nat j < Suc (Suc k) \\<longrightarrow>\n                   A' $ m $ j = (0::'a)) &&&\n     \\<exists>m.\n        \\<not> (\\<forall>j.\n                   mod_type_class.to_nat j < Suc (Suc k) \\<longrightarrow>\n                   A' $ m $ j = (0::'a))) &&&\n    (\\<exists>m.\n        \\<not> (\\<forall>j.\n                   mod_type_class.to_nat j < Suc (Suc k) \\<longrightarrow>\n                   A' $ m $ j = (0::'a)) &&&\n     \\<exists>m.\n        \\<not> (\\<forall>j.\n                   mod_type_class.to_nat j < Suc (Suc k) \\<longrightarrow>\n                   A' $ m $ j = (0::'a))) &&&\n    \\<exists>m.\n       \\<not> (\\<forall>j.\n                  mod_type_class.to_nat j < Suc (Suc k) \\<longrightarrow>\n                  A' $ m $ j = (0::'a)) &&&\n    \\<exists>m.\n       \\<not> (\\<forall>j.\n                  mod_type_class.to_nat j < Suc (Suc k) \\<longrightarrow>\n                  A' $ m $ j = (0::'a))", "by (metis add_to_nat_def from_nat_mono less_irrefl \n            monoid_add_class.add.right_neutral not_less_eq to_nat_0 to_nat_less_card)+"], ["proof (state)\nthis:\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n\ngoal (21 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 3. \\<And>m.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 6. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 10. \\<And>m ma mb.\n        \\<lbrakk>(0::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         \\<forall>m\\<ge>(GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows).\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k) A') =\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 3. \\<And>m.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 6. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 10. \\<And>m ma mb.\n        \\<lbrakk>(0::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         \\<forall>m\\<ge>(GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows).\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k) A') =\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\nA total of 21 subgoals...", "fix m"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 3. \\<And>m.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 6. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 10. \\<And>m ma mb.\n        \\<lbrakk>(0::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         \\<forall>m\\<ge>(GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows).\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k) A') =\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\nA total of 21 subgoals...", "assume \"\\<not> is_zero_row_upt_k m (Suc k) A'\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n\ngoal (21 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 3. \\<And>m.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 6. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 10. \\<And>m ma mb.\n        \\<lbrakk>(0::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         \\<forall>m\\<ge>(GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows).\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k) A') =\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\nA total of 21 subgoals...", "thus \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\" \n          and \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n\ngoal (1 subgoal):\n 1. \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A' &&&\n    \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'", "by (metis is_zero_row_upt_k_le)+"], ["proof (state)\nthis:\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n\ngoal (19 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 8. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>\\<forall>m>(GREATEST n.\n                                \\<not> is_zero_row_upt_k n (Suc k) A') +\n                            (1::'rows).\n                    A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         (0::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 8. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>\\<forall>m>(GREATEST n.\n                                \\<not> is_zero_row_upt_k n (Suc k) A') +\n                            (1::'rows).\n                    A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         (0::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\nA total of 19 subgoals...", "fix m"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 8. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>\\<forall>m>(GREATEST n.\n                                \\<not> is_zero_row_upt_k n (Suc k) A') +\n                            (1::'rows).\n                    A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         (0::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\nA total of 19 subgoals...", "assume \"\\<forall>ma. is_zero_row_upt_k ma (Suc k) A'\" and \"\\<forall>mb. A' $ mb $ from_nat (Suc k) = 0\""], ["proof (state)\nthis:\n  \\<forall>ma. is_zero_row_upt_k ma (Suc k) A'\n  \\<forall>mb. A' $ mb $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (19 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 8. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>\\<forall>m>(GREATEST n.\n                                \\<not> is_zero_row_upt_k n (Suc k) A') +\n                            (1::'rows).\n                    A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         (0::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\nA total of 19 subgoals...", "thus \"is_zero_row_upt_k m (Suc (Suc k)) A'\""], ["proof (prove)\nusing this:\n  \\<forall>ma. is_zero_row_upt_k ma (Suc k) A'\n  \\<forall>mb. A' $ mb $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k m (Suc (Suc k)) A'", "by (metis is_zero_row_upt_k_suc)"], ["proof (state)\nthis:\n  is_zero_row_upt_k m (Suc (Suc k)) A'\n\ngoal (18 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 7. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n A') =\n                          0\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 7. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n A') =\n                          0\nA total of 18 subgoals...", "fix ma"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 7. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n A') =\n                          0\nA total of 18 subgoals...", "assume \"\\<forall>m>0. A' $ m $ from_nat (Suc k) = 0\"\n          and \"\\<forall>m. is_zero_row_upt_k m (Suc k) A'\"\n          and \"\\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\""], ["proof (state)\nthis:\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n  \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\n\ngoal (18 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n                         0\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 7. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n        \\<Longrightarrow> mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n A') =\n                          0\nA total of 18 subgoals...", "thus \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') = 0\" \n          and \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') = 0\""], ["proof (prove)\nusing this:\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n  \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n    0 &&&\n    mod_type_class.to_nat\n     (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n    0", "by (metis (erased, lifting) GreatestI_ex le_less\n            is_zero_row_upt_k_suc least_mod_type to_nat_0)+"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n  0\n  mod_type_class.to_nat\n   (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A') =\n  0\n\ngoal (16 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 6. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A'\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (LEAST n.\n       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n       \\<le> n))\n (nrows A' - Suc 0)\n ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n (mod_type_class.from_nat (Suc k)) bezout)\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 6. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A'\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (LEAST n.\n       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n       \\<le> n))\n (nrows A' - Suc 0)\n ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n (mod_type_class.from_nat (Suc k)) bezout)\nA total of 16 subgoals...", "fix m"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 6. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A'\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (LEAST n.\n       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n       \\<le> n))\n (nrows A' - Suc 0)\n ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n (mod_type_class.from_nat (Suc k)) bezout)\nA total of 16 subgoals...", "assume \"\\<forall>m>0. A' $ m $ from_nat (Suc k) = 0\"\n          and \"\\<not> is_zero_row_upt_k m (Suc k) A'\"\n          and \"\\<forall>m\\<ge>?greatest+1. A' $ m $ from_nat (Suc k) = 0\""], ["proof (state)\nthis:\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows).\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (16 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>0::'rows.\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 6. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A'\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (LEAST n.\n       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n       \\<le> n))\n (nrows A' - Suc 0)\n ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n (mod_type_class.from_nat (Suc k)) bezout)\nA total of 16 subgoals...", "thus \"?greatest \n          = (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\""], ["proof (prove)\nusing this:\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows).\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') =\n    (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')", "by (metis (mono_tags, lifting) echelon_form_upt_k_condition1 from_nat_0 \n            is_zero_row_upt_k_le is_zero_row_upt_k_suc less_nat_zero_code neq_iff rref_A' to_nat_le)"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') =\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n\ngoal (15 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 5. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A'\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      (1::'rows))\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A' - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A'\n     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n     (LEAST n.\n         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> n))\n   (nrows A' - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (mod_type_class.from_nat (Suc k)) bezout))\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 5. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A'\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      (1::'rows))\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A' - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A'\n     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n     (LEAST n.\n         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> n))\n   (nrows A' - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (mod_type_class.from_nat (Suc k)) bezout))\nA total of 15 subgoals...", "fix m ma"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 5. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A'\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      (1::'rows))\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A' - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A'\n     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n     (LEAST n.\n         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> n))\n   (nrows A' - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (mod_type_class.from_nat (Suc k)) bezout))\nA total of 15 subgoals...", "assume \"\\<forall>m>?greatest+1. \n          A' $ m $ from_nat (Suc k) = 0\"\n          and \"\\<forall>m>0. A' $ m $ from_nat (Suc k) = 0\"\n          and\"Suc (to_nat ?greatest) \\<noteq> nrows A'\"\n          and \"?greatest + 1 \\<le> ma\"\n          and \"A' $ ma $ from_nat (Suc k) \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<forall>m>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n             (1::'rows).\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n  nrows A'\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> ma\n  A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (15 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 5. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 8. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m>0::'rows.\n            A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n         \\<not> is_zero_row_upt_k ma (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mb;\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A'\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      (1::'rows))\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A' - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A'\n     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n     (LEAST n.\n         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> n))\n   (nrows A' - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (mod_type_class.from_nat (Suc k)) bezout))\nA total of 15 subgoals...", "thus \"Suc (to_nat ?greatest) = to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\""], ["proof (prove)\nusing this:\n  \\<forall>m>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n             (1::'rows).\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n  nrows A'\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> ma\n  A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n    mod_type_class.to_nat\n     (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')", "by (metis (mono_tags) Suc_eq_plus1 less_linear \n            leD least_mod_type nrows_def suc_not_zero)"], ["proof (state)\nthis:\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  mod_type_class.to_nat\n   (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n\ngoal (14 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 4. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 7. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A' (0::'rows)\n   (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 4. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 7. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A' (0::'rows)\n   (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\nA total of 14 subgoals...", "fix m ma"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 4. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 7. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A' (0::'rows)\n   (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\nA total of 14 subgoals...", "assume \"\\<forall>m>?greatest + 1. A' $ m $ from_nat (Suc k) = 0\"\n          and \"\\<forall>m>0. A' $ m $ from_nat (Suc k) = 0\"\n          and \"\\<not> is_zero_row_upt_k m (Suc k) A'\"\n          and \"Suc (to_nat ?greatest) = nrows A'\"\n          and \"\\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\""], ["proof (state)\nthis:\n  \\<forall>m>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n             (1::'rows).\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  nrows A'\n  \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\n\ngoal (14 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 4. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 7. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 10. \\<And>m ma mb.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A' (0::'rows)\n   (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\nA total of 14 subgoals...", "thus \"nrows A' = Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))\""], ["proof (prove)\nusing this:\n  \\<forall>m>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n             (1::'rows).\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  nrows A'\n  \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\n\ngoal (1 subgoal):\n 1. nrows A' =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))", "by (metis echelon_foldl_condition5)"], ["proof (state)\nthis:\n  nrows A' =\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))\n\ngoal (13 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 3. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A' (0::'rows)\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a)))\n                   (nrows A' - Suc 0) (0::'rows)\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A' (0::'rows)\n     (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n   (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k))\n   bezout)) =\n                          0\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 3. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A' (0::'rows)\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a)))\n                   (nrows A' - Suc 0) (0::'rows)\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A' (0::'rows)\n     (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n   (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k))\n   bezout)) =\n                          0\nA total of 13 subgoals...", "fix ma"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 3. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A' (0::'rows)\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a)))\n                   (nrows A' - Suc 0) (0::'rows)\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A' (0::'rows)\n     (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n   (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k))\n   bezout)) =\n                          0\nA total of 13 subgoals...", "assume 1: \"A' $ ma $ from_nat (Suc k) \\<noteq> 0\""], ["proof (state)\nthis:\n  A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (13 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 3. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 9. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A' (0::'rows)\n  (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n(nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n         A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A' (0::'rows)\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a)))\n                   (nrows A' - Suc 0) (0::'rows)\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A' (0::'rows)\n     (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n   (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k))\n   bezout)) =\n                          0\nA total of 13 subgoals...", "show \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k))\n          (bezout_iterate (interchange_rows A' 0 (LEAST n. A' $ n $ from_nat (Suc k) \\<noteq> 0)) \n          (nrows A' - Suc 0) 0 (from_nat (Suc k)) bezout)\"\n          and \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k))\n          (bezout_iterate (interchange_rows A' 0 (LEAST n. A' $ n $ from_nat (Suc k) \\<noteq> 0))\n          (nrows A' - Suc 0) 0 (from_nat (Suc k)) bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc (Suc k))\n               (bezout_iterate\n                 (interchange_rows A' (0::'rows)\n                   (LEAST n.\n                       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                       (0::'a)))\n                 (nrows A' - Suc 0) (0::'rows)\n                 (mod_type_class.from_nat (Suc k)) bezout) &&&\n    \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc (Suc k))\n               (bezout_iterate\n                 (interchange_rows A' (0::'rows)\n                   (LEAST n.\n                       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                       (0::'a)))\n                 (nrows A' - Suc 0) (0::'rows)\n                 (mod_type_class.from_nat (Suc k)) bezout)", "by (rule echelon_foldl_condition1[OF ib 1 k])+"], ["proof (state)\nthis:\n  \\<exists>m.\n     \\<not> is_zero_row_upt_k m (Suc (Suc k))\n             (bezout_iterate\n               (interchange_rows A' (0::'rows)\n                 (LEAST n.\n                     A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                     (0::'a)))\n               (nrows A' - Suc 0) (0::'rows)\n               (mod_type_class.from_nat (Suc k)) bezout)\n  \\<exists>m.\n     \\<not> is_zero_row_upt_k m (Suc (Suc k))\n             (bezout_iterate\n               (interchange_rows A' (0::'rows)\n                 (LEAST n.\n                     A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                     (0::'a)))\n               (nrows A' - Suc 0) (0::'rows)\n               (mod_type_class.from_nat (Suc k)) bezout)\n\ngoal (11 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 2. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mc;\n         A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A'\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (LEAST n.\n       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n       \\<le> n))\n (nrows A' - Suc 0)\n ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n (mod_type_class.from_nat (Suc k)) bezout)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 2. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mc;\n         A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A'\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (LEAST n.\n       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n       \\<le> n))\n (nrows A' - Suc 0)\n ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n (mod_type_class.from_nat (Suc k)) bezout)\nA total of 11 subgoals...", "fix m ma mb"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 2. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mc;\n         A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A'\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (LEAST n.\n       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n       \\<le> n))\n (nrows A' - Suc 0)\n ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n (mod_type_class.from_nat (Suc k)) bezout)\nA total of 11 subgoals...", "assume 1: \"\\<not> is_zero_row_upt_k ma (Suc k) A'\"\n          and 2:\"\\<forall>m\\<ge>?greatest + 1. A' $ m $ from_nat (Suc k) = 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k ma (Suc k) A'\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows).\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (11 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 2. \\<And>m ma mb.\n       \\<lbrakk>(0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 10. \\<And>m ma mb mc.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mc;\n         A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>m.\n                             \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                     (bezout_iterate\n (interchange_rows A'\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (LEAST n.\n       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n       \\<le> n))\n (nrows A' - Suc 0)\n ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n (mod_type_class.from_nat (Suc k)) bezout)\nA total of 11 subgoals...", "show \"?greatest \n          = (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') =\n    (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')", "by (rule echelon_foldl_condition2[OF 1 2])"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') =\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n\ngoal (10 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc md.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mc;\n         A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A'\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      (1::'rows))\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A' - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A'\n     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n     (LEAST n.\n         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> n))\n   (nrows A' - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (mod_type_class.from_nat (Suc k)) bezout))", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc md.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mc;\n         A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A'\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      (1::'rows))\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A' - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A'\n     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n     (LEAST n.\n         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> n))\n   (nrows A' - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (mod_type_class.from_nat (Suc k)) bezout))", "fix m"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc md.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mc;\n         A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A'\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      (1::'rows))\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A' - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A'\n     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n     (LEAST n.\n         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> n))\n   (nrows A' - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (mod_type_class.from_nat (Suc k)) bezout))", "assume 1: \"A' $ m $ from_nat (Suc k) \\<noteq> 0\"\n          and 2: \"\\<forall>m. is_zero_row_upt_k m (Suc k) A'\""], ["proof (state)\nthis:\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n\ngoal (10 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n. False) + (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. False) + (1::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A' (0::'rows)\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a)))\n                  (nrows A' - Suc 0) (0::'rows)\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A' (0::'rows)\n    (LEAST n. A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)))\n  (nrows A' - Suc 0) (0::'rows) (mod_type_class.from_nat (Suc k)) bezout)) =\n                         0\n 8. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 9. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 10. \\<And>m ma mb mc md.\n        \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows)\n                 < m;\n         A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         (0::'rows) < ma;\n         A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k mb (Suc k) A';\n         Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n         nrows A';\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> mc;\n         A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n         \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A'\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      (1::'rows))\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A' - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n        \\<Longrightarrow> Suc (mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc k)\n      A')) =\n                          mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n (bezout_iterate\n   (interchange_rows A'\n     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n     (LEAST n.\n         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n         \\<le> n))\n   (nrows A' - Suc 0)\n   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n   (mod_type_class.from_nat (Suc k)) bezout))", "show \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k))\n          (bezout_iterate (interchange_rows A' 0 (LEAST n. A' $ n $ from_nat (Suc k) \\<noteq> 0)) \n          (nrows A' - Suc 0) 0 (from_nat (Suc k)) bezout)) = 0\" \n          and \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k))\n          (bezout_iterate (interchange_rows A' 0 (LEAST n. A' $ n $ from_nat (Suc k) \\<noteq> 0)) \n          (nrows A' - Suc 0) 0 (from_nat (Suc k)) bezout)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A' (0::'rows)\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a)))\n                   (nrows A' - Suc 0) (0::'rows)\n                   (mod_type_class.from_nat (Suc k)) bezout)) =\n    0 &&&\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A' (0::'rows)\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a)))\n                   (nrows A' - Suc 0) (0::'rows)\n                   (mod_type_class.from_nat (Suc k)) bezout)) =\n    0", "by (rule echelon_foldl_condition3[OF ib 1 2 rref_A'], metis ncols_def Suc_k)+"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (GREATEST n.\n       \\<not> is_zero_row_upt_k n (Suc (Suc k))\n               (bezout_iterate\n                 (interchange_rows A' (0::'rows)\n                   (LEAST n.\n                       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                       (0::'a)))\n                 (nrows A' - Suc 0) (0::'rows)\n                 (mod_type_class.from_nat (Suc k)) bezout)) =\n  0\n  mod_type_class.to_nat\n   (GREATEST n.\n       \\<not> is_zero_row_upt_k n (Suc (Suc k))\n               (bezout_iterate\n                 (interchange_rows A' (0::'rows)\n                   (LEAST n.\n                       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                       (0::'a)))\n                 (nrows A' - Suc 0) (0::'rows)\n                 (mod_type_class.from_nat (Suc k)) bezout)) =\n  0\n\ngoal (8 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 8. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 8. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "fix m"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 8. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "assume \"\\<forall>m>?greatest + 1. \n          A' $ m $ from_nat (Suc k) = 0\"\n          and \"0 < m\"\n          and \"A' $ m $ from_nat (Suc k) \\<noteq> 0\"\n          and \"Suc (to_nat ?greatest) = nrows A'\""], ["proof (state)\nthis:\n  \\<forall>m>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n             (1::'rows).\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  (0::'rows) < m\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  nrows A'\n\ngoal (8 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 8. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "thus \"nrows A' = Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))\""], ["proof (prove)\nusing this:\n  \\<forall>m>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n             (1::'rows).\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  (0::'rows) < m\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  nrows A'\n\ngoal (1 subgoal):\n 1. nrows A' =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))", "by (metis (mono_tags) Suc_eq_plus1 Suc_le' from_nat_suc \n            from_nat_to_nat_id not_less_eq nrows_def to_nat_less_card to_nat_mono)"], ["proof (state)\nthis:\n  nrows A' =\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))\n\ngoal (7 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "fix mb"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "assume 1: \"\\<forall>m>?greatest+1.\n          A' $ m $ from_nat (Suc k) = 0\"\n          and 2: \"Suc (to_nat ?greatest) \\<noteq> nrows A'\"\n          and 3: \"?greatest+1 \\<le> mb\"\n          and 4: \"A' $ mb $ from_nat (Suc k) \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<forall>m>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n             (1::'rows).\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n  nrows A'\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> mb\n  A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (7 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>\\<forall>m>(GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           (1::'rows).\n                   A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        (0::'rows) < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 7. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "show \"Suc (to_nat ?greatest) =\n          to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n    mod_type_class.to_nat\n     (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')", "by (rule echelon_foldl_condition4[OF 1 2 3 4])"], ["proof (state)\nthis:\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  mod_type_class.to_nat\n   (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n\ngoal (6 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "fix m"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "assume \"?greatest + 1 < m\"\n          and \"A' $ m $ from_nat (Suc k) \\<noteq> 0\"\n          and \"\\<forall>m>0. A' $ m $ from_nat (Suc k) = 0 \""], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) < m\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (6 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 6. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "thus \"nrows A' = Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) < m\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (1 subgoal):\n 1. nrows A' =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))", "by (metis le_less_trans least_mod_type)"], ["proof (state)\nthis:\n  nrows A' =\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))\n\ngoal (5 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "fix m"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "assume \"?greatest + 1 < m\"\n          and \"A' $ m $ from_nat (Suc k) \\<noteq> 0\"\n          and \"\\<forall>m>0. A' $ m $ from_nat (Suc k) = 0\""], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) < m\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<And>m ma mb.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 4. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 5. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "thus \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) (bezout_iterate\n          (interchange_rows A' (?greatest + 1) (LEAST n. A' $ n $ from_nat (Suc k) \\<noteq> 0 \n          \\<and> ?greatest + 1 \\<le> n)) (nrows A' - Suc 0) (?greatest + 1) (from_nat (Suc k)) bezout)\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) < m\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc (Suc k))\n               (bezout_iterate\n                 (interchange_rows A'\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (LEAST n.\n                       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A' - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  (1::'rows))\n                 (mod_type_class.from_nat (Suc k)) bezout)", "by (metis le_less_trans least_mod_type)"], ["proof (state)\nthis:\n  \\<exists>m.\n     \\<not> is_zero_row_upt_k m (Suc (Suc k))\n             (bezout_iterate\n               (interchange_rows A'\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  (1::'rows))\n                 (LEAST n.\n                     A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                     (0::'a) \\<and>\n                     (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows)\n                     \\<le> n))\n               (nrows A' - Suc 0)\n               ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows))\n               (mod_type_class.from_nat (Suc k)) bezout)\n\ngoal (4 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "fix mb"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "assume \"\\<not> is_zero_row_upt_k mb (Suc k) A'\"\n          and \"Suc (to_nat ?greatest) = nrows A'\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k mb (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  nrows A'\n\ngoal (4 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 4. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "thus \" nrows A' = Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k mb (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  nrows A'\n\ngoal (1 subgoal):\n 1. nrows A' =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))", "by (rule echelon_foldl_condition5)"], ["proof (state)\nthis:\n  nrows A' =\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))\n\ngoal (3 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "assume \"(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + 1 < m\"\n          and \"A' $ m $ from_nat (Suc k) \\<noteq> 0\"\n          and \"\\<forall>m>0. A' $ m $ from_nat (Suc k) = 0\""], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) < m\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<forall>m>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mb;\n        A' $ mb $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mc (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))\n 2. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 3. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "thus \"Suc (to_nat ?greatest) =\n          to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k))\n          (bezout_iterate (interchange_rows A' (?greatest + 1)\n          (LEAST n. A' $ n $ from_nat (Suc k) \\<noteq> 0 \\<and> ?greatest + 1 \\<le> n))\n          (nrows A' - Suc 0) (?greatest + 1) (from_nat (Suc k)) bezout))\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) < m\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<forall>m>0::'rows. A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A'\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      (1::'rows))\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A' - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k)) bezout))", "by (metis le_less_trans least_mod_type)"], ["proof (state)\nthis:\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  mod_type_class.to_nat\n   (GREATEST n.\n       \\<not> is_zero_row_upt_k n (Suc (Suc k))\n               (bezout_iterate\n                 (interchange_rows A'\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (LEAST n.\n                       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A' - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  (1::'rows))\n                 (mod_type_class.from_nat (Suc k)) bezout))\n\ngoal (2 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "fix mc"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "assume \"?greatest + 1 \\<le> mc\"\n          and \"A' $ mc $ from_nat (Suc k) \\<noteq> 0\""], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> mc\n  A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>m ma mb mc.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (bezout_iterate\n(interchange_rows A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (LEAST n.\n      A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n      (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n      \\<le> n))\n(nrows A' - Suc 0)\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)) bezout)\n 2. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "thus \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k))\n          (bezout_iterate (interchange_rows A' (?greatest + 1)\n          (LEAST n. A' $ n $ from_nat (Suc k) \\<noteq> 0 \\<and> ?greatest + 1 \\<le> n))\n          (nrows A' - Suc 0) (?greatest + 1) (from_nat (Suc k)) bezout)\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> mc\n  A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc (Suc k))\n               (bezout_iterate\n                 (interchange_rows A'\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (LEAST n.\n                       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A' - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  (1::'rows))\n                 (mod_type_class.from_nat (Suc k)) bezout)", "using echelon_foldl_condition6[OF ib]"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> mc\n  A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n ?k ?A) + (1::?'rows)\n           \\<le> ?mc;\n   ?A $ ?mc $ mod_type_class.from_nat ?k \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       \\<not> is_zero_row_upt_k m (Suc ?k)\n                               (bezout_iterate\n                                 (interchange_rows ?A\n                                   ((GREATEST n.\n  \\<not> is_zero_row_upt_k n ?k ?A) +\n                                    (1::?'rows))\n                                   (LEAST n.\n ?A $ n $ mod_type_class.from_nat ?k \\<noteq> (0::'a) \\<and>\n (GREATEST n. \\<not> is_zero_row_upt_k n ?k ?A) + (1::?'rows) \\<le> n))\n                                 (nrows ?A - Suc 0)\n                                 ((GREATEST n.\n\\<not> is_zero_row_upt_k n ?k ?A) +\n                                  (1::?'rows))\n                                 (mod_type_class.from_nat ?k) bezout)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc (Suc k))\n               (bezout_iterate\n                 (interchange_rows A'\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (LEAST n.\n                       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A' - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  (1::'rows))\n                 (mod_type_class.from_nat (Suc k)) bezout)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m.\n     \\<not> is_zero_row_upt_k m (Suc (Suc k))\n             (bezout_iterate\n               (interchange_rows A'\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  (1::'rows))\n                 (LEAST n.\n                     A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                     (0::'a) \\<and>\n                     (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows)\n                     \\<le> n))\n               (nrows A' - Suc 0)\n               ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows))\n               (mod_type_class.from_nat (Suc k)) bezout)\n\ngoal (1 subgoal):\n 1. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "fix mb mc"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "assume 1: \"\\<not> is_zero_row_upt_k mb (Suc k) A'\"\n          and 2: \"Suc (to_nat ?greatest) \\<noteq> nrows A'\"\n          and 3: \"?greatest + 1 \\<le> mc\"\n          and 4:\"A' $ mc $ from_nat (Suc k) \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k mb (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n  nrows A'\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> mc\n  A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma mb mc md.\n       \\<lbrakk>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows)\n                < m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        (0::'rows) < ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> mc;\n        A' $ mc $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k md (Suc (Suc k))\n                (bezout_iterate\n                  (interchange_rows A'\n                    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                     (1::'rows))\n                    (LEAST n.\n                        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                        (0::'a) \\<and>\n                        (GREATEST n.\n                            \\<not> is_zero_row_upt_k n (Suc k) A') +\n                        (1::'rows)\n                        \\<le> n))\n                  (nrows A' - Suc 0)\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)) bezout)\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(bezout_iterate\n  (interchange_rows A'\n    ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n    (LEAST n.\n        A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a) \\<and>\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> n))\n  (nrows A' - Suc 0)\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k)) bezout))", "show \" Suc (to_nat ?greatest) = to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k))\n          (bezout_iterate (interchange_rows A' (?greatest + 1)\n          (LEAST n. A' $ n $ from_nat (Suc k) \\<noteq> 0 \\<and> ?greatest + 1 \\<le> n))\n          (nrows A' - Suc 0) (?greatest + 1) (from_nat (Suc k)) bezout))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                 (bezout_iterate\n                   (interchange_rows A'\n                     ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      (1::'rows))\n                     (LEAST n.\n                         A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                         (0::'a) \\<and>\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         (1::'rows)\n                         \\<le> n))\n                   (nrows A' - Suc 0)\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k)) bezout))", "by (rule echelon_foldl_condition7[OF ib rref_A' k2 1 2 3 4 ])"], ["proof (state)\nthis:\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  mod_type_class.to_nat\n   (GREATEST n.\n       \\<not> is_zero_row_upt_k n (Suc (Suc k))\n               (bezout_iterate\n                 (interchange_rows A'\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (LEAST n.\n                       A' $ n $ mod_type_class.from_nat (Suc k) \\<noteq>\n                       (0::'a) \\<and>\n                       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows)\n                       \\<le> n))\n                 (nrows A' - Suc 0)\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  (1::'rows))\n                 (mod_type_class.from_nat (Suc k)) bezout))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]) =\n  snd (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n             [0..<Suc (Suc k)]),\n       if \\<forall>m.\n             is_zero_row_upt_k m (Suc (Suc k))\n              (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                     [0..<Suc (Suc k)]))\n       then 0\n       else mod_type_class.to_nat\n             (GREATEST n.\n                 \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                         (fst (foldl (echelon_form_of_column_k bezout)\n                                (A, 0) [0..<Suc (Suc k)]))) +\n            1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)] =\n  (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)]),\n   if \\<forall>m.\n         is_zero_row_upt_k m (Suc (Suc k))\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                 [0..<Suc (Suc k)]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                     (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                            [0..<Suc (Suc k)]))) +\n        1)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Proving the existence of invertible matrices which do the transformations\\<close>"], ["", "lemma bezout_iterate_invertible:\n  fixes A::\"'a::{bezout_domain}^'cols^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  assumes \"n<nrows A\"\n  and \"to_nat i\\<le>n\"\n  and \"A $ i $ j \\<noteq> 0\"\n  shows \"\\<exists>P. invertible P \\<and> P**A = bezout_iterate A n i j bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> P ** A = bezout_iterate A n i j bezout", "using assms"], ["proof (prove)\nusing this:\n  is_bezout_ext bezout\n  n < nrows A\n  mod_type_class.to_nat i \\<le> n\n  A $ i $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> P ** A = bezout_iterate A n i j bezout", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>is_bezout_ext bezout; 0 < nrows A;\n        mod_type_class.to_nat i \\<le> 0; A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A = bezout_iterate A 0 i j bezout\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>is_bezout_ext bezout; n < nrows A;\n                    mod_type_class.to_nat i \\<le> n;\n                    A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P.\n  invertible P \\<and> P ** A = bezout_iterate A n i j bezout;\n        is_bezout_ext bezout; Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n;\n        A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A = bezout_iterate A (Suc n) i j bezout", "case 0"], ["proof (state)\nthis:\n  is_bezout_ext bezout\n  0 < nrows A\n  mod_type_class.to_nat i \\<le> 0\n  A $ i $ j \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>is_bezout_ext bezout; 0 < nrows A;\n        mod_type_class.to_nat i \\<le> 0; A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A = bezout_iterate A 0 i j bezout\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>is_bezout_ext bezout; n < nrows A;\n                    mod_type_class.to_nat i \\<le> n;\n                    A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P.\n  invertible P \\<and> P ** A = bezout_iterate A n i j bezout;\n        is_bezout_ext bezout; Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n;\n        A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A = bezout_iterate A (Suc n) i j bezout", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> P ** A = bezout_iterate A 0 i j bezout", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> P ** A = A", "by (simp add: exI[of _ \"mat 1\"] matrix_mul_lid invertible_def)"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> P ** A = bezout_iterate A 0 i j bezout\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>is_bezout_ext bezout; n < nrows A;\n                    mod_type_class.to_nat i \\<le> n;\n                    A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P.\n  invertible P \\<and> P ** A = bezout_iterate A n i j bezout;\n        is_bezout_ext bezout; Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n;\n        A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A = bezout_iterate A (Suc n) i j bezout", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>is_bezout_ext bezout; n < nrows A;\n                    mod_type_class.to_nat i \\<le> n;\n                    A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P.\n  invertible P \\<and> P ** A = bezout_iterate A n i j bezout;\n        is_bezout_ext bezout; Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n;\n        A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A = bezout_iterate A (Suc n) i j bezout", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>is_bezout_ext bezout; n < nrows ?A;\n   mod_type_class.to_nat i \\<le> n; ?A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P.\n                       invertible P \\<and>\n                       P ** ?A = bezout_iterate ?A n i j bezout\n  is_bezout_ext bezout\n  Suc n < nrows A\n  mod_type_class.to_nat i \\<le> Suc n\n  A $ i $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>is_bezout_ext bezout; n < nrows A;\n                    mod_type_class.to_nat i \\<le> n;\n                    A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P.\n  invertible P \\<and> P ** A = bezout_iterate A n i j bezout;\n        is_bezout_ext bezout; Suc n < nrows A;\n        mod_type_class.to_nat i \\<le> Suc n;\n        A $ i $ j \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A = bezout_iterate A (Suc n) i j bezout", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "proof (cases \"Suc n = to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "case True"], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A =\n       (if Suc n \\<le> mod_type_class.to_nat i then A\n        else bezout_iterate\n              (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j\n                bezout **\n               A)\n              n i j bezout)", "using True Suc.prems(1)"], ["proof (prove)\nusing this:\n  Suc n = mod_type_class.to_nat i\n  is_bezout_ext bezout\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A =\n       (if Suc n \\<le> mod_type_class.to_nat i then A\n        else bezout_iterate\n              (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j\n                bezout **\n               A)\n              n i j bezout)", "by (simp add: exI[of _ \"mat 1\"] matrix_mul_lid invertible_def)"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "case False"], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "have i_le_n: \"to_nat i < Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc n", "using Suc.prems(3) False"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<le> Suc n\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc n", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "let ?B=\"(bezout_matrix A i (from_nat (Suc n)) j bezout ** A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "have b: \"bezout_iterate A (Suc n) i j bezout = bezout_iterate ?B n i j bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i j bezout =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i\n     j bezout", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout **\n            A)\n           n i j bezout) =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i\n     j bezout", "using i_le_n"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout **\n            A)\n           n i j bezout) =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i\n     j bezout", "by auto"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i j bezout =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i j\n   bezout\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "have \"\\<exists>P. invertible P \\<and> P**?B = bezout_iterate ?B n i j bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P **\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) =\n       bezout_iterate\n        (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A)\n        n i j bezout", "proof (rule Suc.hyps[OF ib _])"], ["proof (state)\ngoal (3 subgoals):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A)\n 2. mod_type_class.to_nat i \\<le> n\n 3. (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) $\n    i $\n    j \\<noteq>\n    (0::'a)", "show \"n < nrows ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A)", "using Suc.prems (2)"], ["proof (prove)\nusing this:\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. n < nrows\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  Suc n < CARD('rows)\n\ngoal (1 subgoal):\n 1. n < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  n < nrows\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i \\<le> n\n 2. (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) $\n    i $\n    j \\<noteq>\n    (0::'a)", "show \"to_nat i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> n", "using i_le_n"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> n", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> n\n\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) $\n    i $\n    j \\<noteq>\n    (0::'a)", "show \"?B $ i $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) $\n    i $\n    j \\<noteq>\n    (0::'a)", "by (metis False Suc.prems(2) Suc.prems(4) bezout_matrix_not_zero \n          ib nrows_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) $ i $\n  j \\<noteq>\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and>\n     P **\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) =\n     bezout_iterate\n      (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n\n      i j bezout\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "from this"], ["proof (chain)\npicking this:\n  \\<exists>P.\n     invertible P \\<and>\n     P **\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) =\n     bezout_iterate\n      (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n\n      i j bezout", "obtain P where inv_P: \"invertible P\" and P: \"P**?B = bezout_iterate ?B n i j bezout\""], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and>\n     P **\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) =\n     bezout_iterate\n      (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n\n      i j bezout\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         P **\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout **\n          A) =\n         bezout_iterate\n          (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout **\n           A)\n          n i j bezout\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  invertible P\n  P ** (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i j\n   bezout\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout", "proof (rule exI[of _ \"P ** bezout_matrix A i (from_nat (Suc n)) j bezout\"], \n        rule conjI, rule invertible_mult)"], ["proof (state)\ngoal (3 subgoals):\n 1. invertible P\n 2. invertible\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout)\n 3. P ** bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A =\n    bezout_iterate A (Suc n) i j bezout", "show \"P ** bezout_matrix A i (from_nat (Suc n)) j bezout ** A \n        = bezout_iterate A (Suc n) i j bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ** bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A =\n    bezout_iterate A (Suc n) i j bezout", "using P"], ["proof (prove)\nusing this:\n  P ** (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i j\n   bezout\n\ngoal (1 subgoal):\n 1. P ** bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A =\n    bezout_iterate A (Suc n) i j bezout", "unfolding b"], ["proof (prove)\nusing this:\n  P ** (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i j\n   bezout\n\ngoal (1 subgoal):\n 1. P ** bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A) n i\n     j bezout", "by (metis matrix_mul_assoc)"], ["proof (state)\nthis:\n  P ** bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout ** A =\n  bezout_iterate A (Suc n) i j bezout\n\ngoal (2 subgoals):\n 1. invertible P\n 2. invertible\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout)", "have \"det (bezout_matrix A i (from_nat (Suc n)) j bezout) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout) =\n    (1::'a)", "proof (rule det_bezout_matrix[OF ib])"], ["proof (state)\ngoal (2 subgoals):\n 1. i < mod_type_class.from_nat (Suc n)\n 2. A $ i $ j \\<noteq> (0::'a)", "show \"i < from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "using i_le_n from_nat_mono[of \"to_nat i\" \"Suc n\"] Suc.prems(2)"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc n\n  \\<lbrakk>mod_type_class.to_nat i < Suc n; Suc n < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat (mod_type_class.to_nat i)\n                    < mod_type_class.from_nat (Suc n)\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc n\n  \\<lbrakk>mod_type_class.to_nat i < Suc n; Suc n < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat (mod_type_class.to_nat i)\n                    < mod_type_class.from_nat (Suc n)\n  Suc n < CARD('rows)\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "by (metis from_nat_to_nat_id)"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat (Suc n)\n\ngoal (1 subgoal):\n 1. A $ i $ j \\<noteq> (0::'a)", "show \"A $ i $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j \\<noteq> (0::'a)", "by (rule Suc.prems(4))"], ["proof (state)\nthis:\n  A $ i $ j \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout) =\n  (1::'a)\n\ngoal (2 subgoals):\n 1. invertible P\n 2. invertible\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout)", "thus \"invertible (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout)\""], ["proof (prove)\nusing this:\n  det (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. invertible\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout)", "unfolding invertible_iff_is_unit"], ["proof (prove)\nusing this:\n  det (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout) dvd\n    (1::'a)", "by simp"], ["proof (state)\nthis:\n  invertible (bezout_matrix A i (mod_type_class.from_nat (Suc n)) j bezout)\n\ngoal (1 subgoal):\n 1. invertible P", "show \"invertible P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible P", "using inv_P"], ["proof (prove)\nusing this:\n  invertible P\n\ngoal (1 subgoal):\n 1. invertible P", "."], ["proof (state)\nthis:\n  invertible P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and> P ** A = bezout_iterate A (Suc n) i j bezout\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_of_column_k_invertible:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"\\<exists>P. invertible P \\<and> P ** A = fst ((echelon_form_of_column_k bezout) (A,i) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A = fst (echelon_form_of_column_k bezout (A, i) k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A = fst (echelon_form_of_column_k bezout (A, i) k)", "have \"\\<exists>P. invertible P \\<and> P ** A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> P ** A = A", "by (simp add: exI[of _ \"mat 1\"] matrix_mul_lid invertible_def)"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> P ** A = A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A = fst (echelon_form_of_column_k bezout (A, i) k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>P. invertible P \\<and> P ** A = A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A = fst (echelon_form_of_column_k bezout (A, i) k)", "proof (unfold echelon_form_of_column_k_def Let_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P m ma.\n       \\<lbrakk>invertible P; P ** A = A; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A =\n                            bezout_iterate\n                             (interchange_rows A (mod_type_class.from_nat i)\n                               (LEAST n.\n                                   A $ n $\n                                   mod_type_class.from_nat k \\<noteq>\n                                   (0::'a) \\<and>\n                                   mod_type_class.from_nat i \\<le> n))\n                             (nrows A - Suc 0) (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) bezout", "fix P m ma"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P m ma.\n       \\<lbrakk>invertible P; P ** A = A; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A =\n                            bezout_iterate\n                             (interchange_rows A (mod_type_class.from_nat i)\n                               (LEAST n.\n                                   A $ n $\n                                   mod_type_class.from_nat k \\<noteq>\n                                   (0::'a) \\<and>\n                                   mod_type_class.from_nat i \\<le> n))\n                             (nrows A - Suc 0) (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) bezout", "let ?least = \"(LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P m ma.\n       \\<lbrakk>invertible P; P ** A = A; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A =\n                            bezout_iterate\n                             (interchange_rows A (mod_type_class.from_nat i)\n                               (LEAST n.\n                                   A $ n $\n                                   mod_type_class.from_nat k \\<noteq>\n                                   (0::'a) \\<and>\n                                   mod_type_class.from_nat i \\<le> n))\n                             (nrows A - Suc 0) (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) bezout", "let ?interchange =\"(interchange_rows A (from_nat i) ?least)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P m ma.\n       \\<lbrakk>invertible P; P ** A = A; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A =\n                            bezout_iterate\n                             (interchange_rows A (mod_type_class.from_nat i)\n                               (LEAST n.\n                                   A $ n $\n                                   mod_type_class.from_nat k \\<noteq>\n                                   (0::'a) \\<and>\n                                   mod_type_class.from_nat i \\<le> n))\n                             (nrows A - Suc 0) (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) bezout", "assume i: \"i \\<noteq> nrows A\" \n      and i2: \"mod_type_class.from_nat i \\<le> ma\"\n      and ma: \"A $ ma $ mod_type_class.from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  i \\<noteq> nrows A\n  mod_type_class.from_nat i \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>P m ma.\n       \\<lbrakk>invertible P; P ** A = A; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A =\n                            bezout_iterate\n                             (interchange_rows A (mod_type_class.from_nat i)\n                               (LEAST n.\n                                   A $ n $\n                                   mod_type_class.from_nat k \\<noteq>\n                                   (0::'a) \\<and>\n                                   mod_type_class.from_nat i \\<le> n))\n                             (nrows A - Suc 0) (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) bezout", "have \"\\<exists>P. invertible P \\<and>\n      P ** ?interchange =\n      bezout_iterate ?interchange (nrows A - Suc 0) (from_nat i) (from_nat k) bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P **\n       interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n) =\n       bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout", "proof (rule bezout_iterate_invertible[OF ib])"], ["proof (state)\ngoal (3 subgoals):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n 2. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 3. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "show \"nrows A - Suc 0 < nrows ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < nrows\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - Suc 0 < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < nrows\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n 2. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "show \"to_nat (from_nat i::'rows) \\<le> nrows A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0", "by (metis Suc_leI Suc_le_mono Suc_pred nrows_def to_nat_less_card zero_less_card_finite)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat i) \\<le> nrows A - Suc 0\n\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "show \"?interchange $ from_nat i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) LeastI_ex i2 ma interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and>\n     P **\n     interchange_rows A (mod_type_class.from_nat i)\n      (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          mod_type_class.from_nat i \\<le> n) =\n     bezout_iterate\n      (interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n))\n      (nrows A - Suc 0) (mod_type_class.from_nat i)\n      (mod_type_class.from_nat k) bezout\n\ngoal (1 subgoal):\n 1. \\<And>P m ma.\n       \\<lbrakk>invertible P; P ** A = A; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A =\n                            bezout_iterate\n                             (interchange_rows A (mod_type_class.from_nat i)\n                               (LEAST n.\n                                   A $ n $\n                                   mod_type_class.from_nat k \\<noteq>\n                                   (0::'a) \\<and>\n                                   mod_type_class.from_nat i \\<le> n))\n                             (nrows A - Suc 0) (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) bezout", "from this"], ["proof (chain)\npicking this:\n  \\<exists>P.\n     invertible P \\<and>\n     P **\n     interchange_rows A (mod_type_class.from_nat i)\n      (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          mod_type_class.from_nat i \\<le> n) =\n     bezout_iterate\n      (interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n))\n      (nrows A - Suc 0) (mod_type_class.from_nat i)\n      (mod_type_class.from_nat k) bezout", "obtain P where inv_P: \"invertible P\" and P: \"P ** ?interchange =\n      bezout_iterate ?interchange (nrows A - Suc 0) (from_nat i) (from_nat k) bezout\""], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and>\n     P **\n     interchange_rows A (mod_type_class.from_nat i)\n      (LEAST n.\n          A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n          mod_type_class.from_nat i \\<le> n) =\n     bezout_iterate\n      (interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n))\n      (nrows A - Suc 0) (mod_type_class.from_nat i)\n      (mod_type_class.from_nat k) bezout\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         P **\n         interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n) =\n         bezout_iterate\n          (interchange_rows A (mod_type_class.from_nat i)\n            (LEAST n.\n                A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                mod_type_class.from_nat i \\<le> n))\n          (nrows A - Suc 0) (mod_type_class.from_nat i)\n          (mod_type_class.from_nat k) bezout\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  invertible P\n  P **\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) =\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout\n\ngoal (1 subgoal):\n 1. \\<And>P m ma.\n       \\<lbrakk>invertible P; P ** A = A; mod_type_class.from_nat i < m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            P ** A =\n                            bezout_iterate\n                             (interchange_rows A (mod_type_class.from_nat i)\n                               (LEAST n.\n                                   A $ n $\n                                   mod_type_class.from_nat k \\<noteq>\n                                   (0::'a) \\<and>\n                                   mod_type_class.from_nat i \\<le> n))\n                             (nrows A - Suc 0) (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) bezout", "show \"\\<exists>P. invertible P \\<and> P ** A \n      = bezout_iterate ?interchange (nrows A - Suc 0) (from_nat i) (from_nat k) bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A =\n       bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout", "proof (rule exI[of _ \"P ** interchange_rows (mat 1) (from_nat i) ?least\"], \n        rule conjI, rule invertible_mult)"], ["proof (state)\ngoal (3 subgoals):\n 1. invertible P\n 2. invertible\n     (interchange_rows (mat (1::'a)) (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n 3. P **\n    interchange_rows (mat (1::'a)) (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) **\n    A =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "show \"P ** interchange_rows (mat 1) (from_nat i) ?least ** A =\n        bezout_iterate ?interchange (nrows A - Suc 0) (from_nat i) (from_nat k) bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P **\n    interchange_rows (mat (1::'a)) (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) **\n    A =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "using P"], ["proof (prove)\nusing this:\n  P **\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) =\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout\n\ngoal (1 subgoal):\n 1. P **\n    interchange_rows (mat (1::'a)) (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) **\n    A =\n    bezout_iterate\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (nrows A - Suc 0) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) bezout", "by (metis (no_types, lifting) interchange_rows_mat_1 matrix_mul_assoc)"], ["proof (state)\nthis:\n  P **\n  interchange_rows (mat (1::'a)) (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) **\n  A =\n  bezout_iterate\n   (interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n   (nrows A - Suc 0) (mod_type_class.from_nat i) (mod_type_class.from_nat k)\n   bezout\n\ngoal (2 subgoals):\n 1. invertible P\n 2. invertible\n     (interchange_rows (mat (1::'a)) (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"invertible P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible P", "by (rule inv_P)"], ["proof (state)\nthis:\n  invertible P\n\ngoal (1 subgoal):\n 1. invertible\n     (interchange_rows (mat (1::'a)) (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "show \"invertible (interchange_rows (mat 1) (from_nat i) ?least)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (interchange_rows (mat (1::'b)) (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))", "by (simp add: invertible_interchange_rows)"], ["proof (state)\nthis:\n  invertible\n   (interchange_rows (mat (1::?'b1)) (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and>\n     P ** A =\n     bezout_iterate\n      (interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n))\n      (nrows A - Suc 0) (mod_type_class.from_nat i)\n      (mod_type_class.from_nat k) bezout\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and>\n     P ** A = fst (echelon_form_of_column_k bezout (A, i) k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_of_upt_k_invertible:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"\\<exists>P. invertible P \\<and> P**A = (echelon_form_of_upt_k A k bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> P ** A = echelon_form_of_upt_k A k bezout", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>P.\n       invertible P \\<and> P ** A = echelon_form_of_upt_k A 0 bezout\n 2. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A k bezout \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A (Suc k) bezout", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>P.\n       invertible P \\<and> P ** A = echelon_form_of_upt_k A 0 bezout\n 2. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A k bezout \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A (Suc k) bezout", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> P ** A = echelon_form_of_upt_k A 0 bezout", "unfolding echelon_form_of_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A =\n       fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc 0])", "by (simp add: echelon_form_of_column_k_invertible[OF ib])"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> P ** A = echelon_form_of_upt_k A 0 bezout\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A k bezout \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A (Suc k) bezout", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A k bezout \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A (Suc k) bezout", "case (Suc k)"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> P ** A = echelon_form_of_upt_k A k bezout\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A k bezout \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A (Suc k) bezout", "have set_rw: \"[0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A k bezout \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A (Suc k) bezout", "let ?foldl = \"foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A k bezout \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A (Suc k) bezout", "obtain P where invP: \"invertible P\" \n    and P: \"P ** A = fst ?foldl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         P ** A =\n         fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc k])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.hyps"], ["proof (prove)\nusing this:\n  \\<exists>P. invertible P \\<and> P ** A = echelon_form_of_upt_k A k bezout\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         P ** A =\n         fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc k])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding echelon_form_of_upt_k_def"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and>\n     P ** A =\n     fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         P ** A =\n         fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n               [0..<Suc k])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  invertible P\n  P ** A = fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A k bezout \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A (Suc k) bezout", "obtain Q where invQ: \"invertible Q\" and Q: \n    \"Q ** fst ?foldl = fst ((echelon_form_of_column_k bezout) (fst ?foldl, snd ?foldl) (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>invertible Q;\n         Q **\n         fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) =\n         fst (echelon_form_of_column_k bezout\n               (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                      [0..<Suc k]),\n                snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                      [0..<Suc k]))\n               (Suc k))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using echelon_form_of_column_k_invertible [OF ib]"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and>\n     P ** ?A = fst (echelon_form_of_column_k bezout (?A, ?i) ?k)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>invertible Q;\n         Q **\n         fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) =\n         fst (echelon_form_of_column_k bezout\n               (fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n                      [0..<Suc k]),\n                snd (foldl (echelon_form_of_column_k bezout) (A, 0)\n                      [0..<Suc k]))\n               (Suc k))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  invertible Q\n  Q ** fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) =\n  fst (echelon_form_of_column_k bezout\n        (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n         snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n        (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A k bezout \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          P ** A = echelon_form_of_upt_k A (Suc k) bezout", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> P ** A = echelon_form_of_upt_k A (Suc k) bezout", "proof (rule exI[of _ \"Q**P\"], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. invertible (Q ** P)\n 2. Q ** P ** A = echelon_form_of_upt_k A (Suc k) bezout", "show \"invertible (Q**P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (Q ** P)", "by (metis invP invQ invertible_mult)"], ["proof (state)\nthis:\n  invertible (Q ** P)\n\ngoal (1 subgoal):\n 1. Q ** P ** A = echelon_form_of_upt_k A (Suc k) bezout", "show \"Q ** P ** A = echelon_form_of_upt_k A (Suc k) bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q ** P ** A = echelon_form_of_upt_k A (Suc k) bezout", "unfolding echelon_form_of_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q ** P ** A =\n    fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc (Suc k)])", "unfolding set_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q ** P ** A =\n    fst (foldl (echelon_form_of_column_k bezout) (A, 0)\n          ([0..<Suc k] @ [Suc k]))", "unfolding foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q ** P ** A =\n    fst (foldl (echelon_form_of_column_k bezout)\n          (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n          [Suc k])", "unfolding foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q ** P ** A =\n    fst (echelon_form_of_column_k bezout\n          (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n          (Suc k))", "unfolding matrix_mul_assoc[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q ** (P ** A) =\n    fst (echelon_form_of_column_k bezout\n          (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n          (Suc k))", "unfolding P Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_column_k bezout\n          (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]),\n           snd (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))\n          (Suc k)) =\n    fst (echelon_form_of_column_k bezout\n          (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])\n          (Suc k))", "by auto"], ["proof (state)\nthis:\n  Q ** P ** A = echelon_form_of_upt_k A (Suc k) bezout\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and> P ** A = echelon_form_of_upt_k A (Suc k) bezout\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Final results\\<close>"], ["", "lemma echelon_form_echelon_form_of:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"echelon_form (echelon_form_of A bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of A bezout)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of A bezout)", "have n: \"ncols A - 1 < ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols A - 1 < ncols A", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('cols) - 1 < CARD('cols)", "by auto"], ["proof (state)\nthis:\n  ncols A - 1 < ncols A\n\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of A bezout)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of A bezout)", "unfolding echelon_form_def echelon_form_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_k (echelon_form_of_upt_k A (ncols A - 1) bezout)\n     (ncols (echelon_form_of_upt_k A (ncols A - 1) bezout))", "using echelon_echelon_form_of_upt_k[OF n ib]"], ["proof (prove)\nusing this:\n  echelon_form_upt_k (echelon_form_of_upt_k A (ncols A - 1) bezout)\n   (Suc (ncols A - 1))\n\ngoal (1 subgoal):\n 1. echelon_form_upt_k (echelon_form_of_upt_k A (ncols A - 1) bezout)\n     (ncols (echelon_form_of_upt_k A (ncols A - 1) bezout))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  echelon_form_upt_k (echelon_form_of_upt_k A (CARD('cols) - 1) bezout)\n   (Suc (CARD('cols) - 1))\n\ngoal (1 subgoal):\n 1. echelon_form_upt_k (echelon_form_of_upt_k A (CARD('cols) - 1) bezout)\n     CARD('cols)", "by simp"], ["proof (state)\nthis:\n  echelon_form (echelon_form_of A bezout)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_of_invertible:\n  fixes A::\"'a::{bezout_domain}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes ib: \"is_bezout_ext (bezout)\"\n  shows \"\\<exists>P. invertible P \n            \\<and> P ** A = (echelon_form_of A bezout) \n            \\<and> echelon_form (echelon_form_of A bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A = echelon_form_of A bezout \\<and>\n       echelon_form (echelon_form_of A bezout)", "using echelon_form_of_upt_k_invertible[OF ib] echelon_form_echelon_form_of[OF ib]"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and> P ** ?A = echelon_form_of_upt_k ?A ?k bezout\n  echelon_form (echelon_form_of ?A bezout)\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A = echelon_form_of A bezout \\<and>\n       echelon_form (echelon_form_of A bezout)", "unfolding echelon_form_of_def"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and> P ** ?A = echelon_form_of_upt_k ?A ?k bezout\n  echelon_form (echelon_form_of_upt_k ?A (ncols ?A - 1) bezout)\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A = echelon_form_of_upt_k A (ncols A - 1) bezout \\<and>\n       echelon_form (echelon_form_of_upt_k A (ncols A - 1) bezout)", "by fast"], ["", "text\\<open>Executable version\\<close>"], ["", "corollary echelon_form_echelon_form_of_euclidean:\n  fixes A::\"'a::{euclidean_ring_gcd}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"echelon_form (echelon_form_of_euclidean A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of_euclidean A)", "using echelon_form_echelon_form_of is_bezout_ext_euclid_ext2"], ["proof (prove)\nusing this:\n  is_bezout_ext ?bezout \\<Longrightarrow>\n  echelon_form (echelon_form_of ?A ?bezout)\n  is_bezout_ext euclid_ext2\n\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of_euclidean A)", "unfolding echelon_form_of_euclidean_def"], ["proof (prove)\nusing this:\n  is_bezout_ext ?bezout \\<Longrightarrow>\n  echelon_form (echelon_form_of ?A ?bezout)\n  is_bezout_ext euclid_ext2\n\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of A euclid_ext2)", "by auto"], ["", "corollary echelon_form_of_euclidean_invertible:\n  fixes A::\"'a::{euclidean_ring_gcd}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"\\<exists>P. invertible P \\<and> P**A = (echelon_form_of A euclid_ext2) \n         \\<and> echelon_form (echelon_form_of A euclid_ext2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A = echelon_form_of A euclid_ext2 \\<and>\n       echelon_form (echelon_form_of A euclid_ext2)", "using echelon_form_of_invertible[OF is_bezout_ext_euclid_ext2]"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and>\n     P ** ?A = echelon_form_of ?A euclid_ext2 \\<and>\n     echelon_form (echelon_form_of ?A euclid_ext2)\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       P ** A = echelon_form_of A euclid_ext2 \\<and>\n       echelon_form (echelon_form_of A euclid_ext2)", "."], ["", "subsection\\<open>More efficient code equations\\<close>"], ["", "definition\n  \"echelon_form_of_column_k_efficient bezout A' k =\n    (let (A, i) = A';\n         from_nat_k = from_nat k;\n         from_nat_i = from_nat i;\n         all_zero_below_i = (\\<forall>m>from_nat_i. A $ m $ from_nat_k = 0)\n     in if  (i = nrows A) \\<or> (A $ from_nat_i $ from_nat_k = 0) \\<and> all_zero_below_i  then (A, i)\n           else if all_zero_below_i then (A, i + 1)\n           else\n            let n = (LEAST n. A $ n $ from_nat_k \\<noteq> 0 \\<and> from_nat_i \\<le> n);\n               interchange_A = interchange_rows A (from_nat_i) n\n            in\n              (bezout_iterate (interchange_A) (nrows A - 1) (from_nat_i) (from_nat_k) bezout, i + 1))\""], ["", "lemma echelon_form_of_column_k_efficient[code]: \n  \"(echelon_form_of_column_k bezout) (A,i) k\n    = (echelon_form_of_column_k_efficient bezout) (A,i) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_of_column_k bezout (A, i) k =\n    echelon_form_of_column_k_efficient bezout (A, i) k", "unfolding echelon_form_of_column_k_def echelon_form_of_column_k_efficient_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (A, i) = (A, i)\n     in if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n               A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n           i = nrows A\n        then (A, i)\n        else if \\<forall>m>mod_type_class.from_nat i.\n                   A $ m $ mod_type_class.from_nat k = (0::'a)\n             then (A, i + 1)\n             else let n = LEAST n.\n                             A $ n $ mod_type_class.from_nat k \\<noteq>\n                             (0::'a) \\<and>\n                             mod_type_class.from_nat i \\<le> n;\n                      interchange_A =\n                        interchange_rows A (mod_type_class.from_nat i) n\n                  in (bezout_iterate interchange_A (nrows A - 1)\n                       (mod_type_class.from_nat i)\n                       (mod_type_class.from_nat k) bezout,\n                      i + 1)) =\n    (let (A, i) = (A, i); from_nat_k = mod_type_class.from_nat k;\n         from_nat_i = mod_type_class.from_nat i;\n         all_zero_below_i =\n           \\<forall>m>from_nat_i. A $ m $ from_nat_k = (0::'a)\n     in if i = nrows A \\<or>\n           A $ from_nat_i $ from_nat_k = (0::'a) \\<and> all_zero_below_i\n        then (A, i)\n        else if all_zero_below_i then (A, i + 1)\n             else let n = LEAST n.\n                             A $ n $ from_nat_k \\<noteq> (0::'a) \\<and>\n                             from_nat_i \\<le> n;\n                      interchange_A = interchange_rows A from_nat_i n\n                  in (bezout_iterate interchange_A (nrows A - 1) from_nat_i\n                       from_nat_k bezout,\n                      i + 1))", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (A, i) of\n     (A, i) \\<Rightarrow>\n       if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n              A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n          i = nrows A\n       then (A, i)\n       else if \\<forall>m>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)\n            then (A, i + 1)\n            else (bezout_iterate\n                   (interchange_rows A (mod_type_class.from_nat i)\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         mod_type_class.from_nat i \\<le> n))\n                   (nrows A - 1) (mod_type_class.from_nat i)\n                   (mod_type_class.from_nat k) bezout,\n                  i + 1)) =\n    (case (A, i) of\n     (A, i) \\<Rightarrow>\n       if i = nrows A \\<or>\n          A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n          (0::'a) \\<and>\n          (\\<forall>m>mod_type_class.from_nat i.\n              A $ m $ mod_type_class.from_nat k = (0::'a))\n       then (A, i)\n       else if \\<forall>m>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)\n            then (A, i + 1)\n            else (bezout_iterate\n                   (interchange_rows A (mod_type_class.from_nat i)\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         mod_type_class.from_nat i \\<le> n))\n                   (nrows A - 1) (mod_type_class.from_nat i)\n                   (mod_type_class.from_nat k) bezout,\n                  i + 1))", "by force"], ["", "end"], ["", "(*********** Possible future work: ***********)\n(* \n  - Other kind of Echelon Forms (minimal Echelon, Howell...) and more applications: \n    ranks, system of equations...\n\n  - Hermite Normal Form and its uniqueness. HNF is unique over PID (not in PIR) with respect to \n    a given complete set of associates and a given complete set of residues.\n    In general terms, with the integers we use the positive integers, \n    in F[x] we use monic polynomials...\n\n  - Smith Normal Form and its uniqueness.\n*)"]]}