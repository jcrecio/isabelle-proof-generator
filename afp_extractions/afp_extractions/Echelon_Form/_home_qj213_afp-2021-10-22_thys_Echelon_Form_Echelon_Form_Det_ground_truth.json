{"file_name": "/home/qj213/afp-2021-10-22/thys/Echelon_Form/Echelon_Form_Det.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Echelon_Form", "problem_names": ["lemma det_bezout_iterate:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and Aik: \"A $ i $ from_nat k \\<noteq> 0\"\n  and n: \"n<ncols A\"\n  shows \"det (bezout_iterate A n i (from_nat k) bezout) = det A\"", "lemma det_echelon_form_of_column_k_det:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and det: \"det_P * det B = det A\"\n  shows \"fst ((echelon_form_of_column_k_det bezout) (det_P,A,i) k) * det B \n  = det (fst (snd ((echelon_form_of_column_k_det bezout) (det_P,A,i) k)))\"", "lemma snd_echelon_form_of_column_k_det_eq:\n  shows \"snd ((echelon_form_of_column_k_det bezout) (n, A, i) k) \n  = (echelon_form_of_column_k bezout) (A,i) k\"", "lemma snd_foldl_ef_det_eq: \"snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k]) \n  = foldl (echelon_form_of_column_k bezout) (A, 0) [0..<k]\"", "lemma snd_echelon_form_of_upt_k_det_eq:\n  shows \"snd ((echelon_form_of_upt_k_det bezout) (n, A) k) = echelon_form_of_upt_k A k bezout\"", "lemma det_echelon_form_of_upt_k_det:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"fst ((echelon_form_of_upt_k_det bezout) (1::'a,A) k) *  det A \n  = det (snd ((echelon_form_of_upt_k_det bezout) (1::'a,A) k))\"", "lemma det_echelon_form_of_det:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"(fst (echelon_form_of_det A bezout)) * det A = det (snd (echelon_form_of_det A bezout))\"", "lemma echelon_form_of_column_k_det_unit:\n  fixes A::\"'a::{bezout_domain_div}^'n::{mod_type}^'n::{mod_type}\"\n  assumes det: \"is_unit (det_P)\"\n  shows \"is_unit (fst ((echelon_form_of_column_k_det bezout) (det_P,A,i) k))\"", "lemma echelon_form_of_upt_k_det_unit:\n  fixes A::\"'a::{bezout_domain_div}^'n::{mod_type}^'n::{mod_type}\"\n  shows \"is_unit (fst ((echelon_form_of_upt_k_det bezout) (1::'a,A) k))\"", "lemma echelon_form_of_unit:\n  fixes A::\"'a::{bezout_domain_div}^'n::{mod_type}^'n::{mod_type}\"\n  shows \"is_unit (fst (echelon_form_of_det A k))\"", "lemma ef_echelon_form_of_det:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"echelon_form (snd (echelon_form_of_det A bezout))\"", "lemma det_echelon_form:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ef: \"echelon_form A\"\n  shows \"det A = prod (\\<lambda>i. A $ i $ i) (UNIV:: 'n set)\""], "translations": [["", "lemma det_bezout_iterate:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and Aik: \"A $ i $ from_nat k \\<noteq> 0\"\n  and n: \"n<ncols A\"\n  shows \"det (bezout_iterate A n i (from_nat k) bezout) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_iterate A n i (mod_type_class.from_nat k) bezout) = det A", "using Aik n"], ["proof (prove)\nusing this:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  n < ncols A\n\ngoal (1 subgoal):\n 1. det (bezout_iterate A n i (mod_type_class.from_nat k) bezout) = det A", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        0 < ncols A\\<rbrakk>\n       \\<Longrightarrow> det (bezout_iterate A 0 i\n                               (mod_type_class.from_nat k) bezout) =\n                         det A\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < ncols A\\<rbrakk>\n                   \\<Longrightarrow> det\n(bezout_iterate A n i (mod_type_class.from_nat k) bezout) =\n                                     det A;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        Suc n < ncols A\\<rbrakk>\n       \\<Longrightarrow> det (bezout_iterate A (Suc n) i\n                               (mod_type_class.from_nat k) bezout) =\n                         det A", "case 0"], ["proof (state)\nthis:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  0 < ncols A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        0 < ncols A\\<rbrakk>\n       \\<Longrightarrow> det (bezout_iterate A 0 i\n                               (mod_type_class.from_nat k) bezout) =\n                         det A\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < ncols A\\<rbrakk>\n                   \\<Longrightarrow> det\n(bezout_iterate A n i (mod_type_class.from_nat k) bezout) =\n                                     det A;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        Suc n < ncols A\\<rbrakk>\n       \\<Longrightarrow> det (bezout_iterate A (Suc n) i\n                               (mod_type_class.from_nat k) bezout) =\n                         det A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_iterate A 0 i (mod_type_class.from_nat k) bezout) = det A", "unfolding bezout_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = det A", ".."], ["proof (state)\nthis:\n  det (bezout_iterate A 0 i (mod_type_class.from_nat k) bezout) = det A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < ncols A\\<rbrakk>\n                   \\<Longrightarrow> det\n(bezout_iterate A n i (mod_type_class.from_nat k) bezout) =\n                                     det A;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        Suc n < ncols A\\<rbrakk>\n       \\<Longrightarrow> det (bezout_iterate A (Suc n) i\n                               (mod_type_class.from_nat k) bezout) =\n                         det A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < ncols A\\<rbrakk>\n                   \\<Longrightarrow> det\n(bezout_iterate A n i (mod_type_class.from_nat k) bezout) =\n                                     det A;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        Suc n < ncols A\\<rbrakk>\n       \\<Longrightarrow> det (bezout_iterate A (Suc n) i\n                               (mod_type_class.from_nat k) bezout) =\n                         det A", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>?A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n   n < ncols ?A\\<rbrakk>\n  \\<Longrightarrow> det (bezout_iterate ?A n i (mod_type_class.from_nat k)\n                          bezout) =\n                    det ?A\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  Suc n < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A $ i $ mod_type_class.from_nat k \\<noteq>\n                            (0::'a);\n                    n < ncols A\\<rbrakk>\n                   \\<Longrightarrow> det\n(bezout_iterate A n i (mod_type_class.from_nat k) bezout) =\n                                     det A;\n        A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        Suc n < ncols A\\<rbrakk>\n       \\<Longrightarrow> det (bezout_iterate A (Suc n) i\n                               (mod_type_class.from_nat k) bezout) =\n                         det A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "proof (cases \"Suc n \\<le> to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A\n 2. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "case True"], ["proof (state)\nthis:\n  Suc n \\<le> mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A\n 2. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "unfolding bezout_iterate.simps"], ["proof (prove)\nusing this:\n  Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. det (if Suc n \\<le> mod_type_class.to_nat i then A\n         else bezout_iterate\n               (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n                 (mod_type_class.from_nat k) bezout **\n                A)\n               n i (mod_type_class.from_nat k) bezout) =\n    det A", "by simp"], ["proof (state)\nthis:\n  det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n  det A\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "let ?B = \"bezout_matrix A i (from_nat (Suc n)) (from_nat k) bezout\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "let ?A=\"(?B ** A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "case False"], ["proof (state)\nthis:\n  \\<not> Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "hence \"(bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) \n      = bezout_iterate ?A n i (mod_type_class.from_nat k) bezout\""], ["proof (prove)\nusing this:\n  \\<not> Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout", "unfolding bezout_iterate.simps"], ["proof (prove)\nusing this:\n  \\<not> Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. (if Suc n \\<le> mod_type_class.to_nat i then A\n     else bezout_iterate\n           (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n             (mod_type_class.from_nat k) bezout **\n            A)\n           n i (mod_type_class.from_nat k) bezout) =\n    bezout_iterate\n     (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n       (mod_type_class.from_nat k) bezout **\n      A)\n     n i (mod_type_class.from_nat k) bezout", "by auto"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "also"], ["proof (state)\nthis:\n  bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout =\n  bezout_iterate\n   (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n     (mod_type_class.from_nat k) bezout **\n    A)\n   n i (mod_type_class.from_nat k) bezout\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "have \"det (...) = det ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_iterate\n          (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n            (mod_type_class.from_nat k) bezout **\n           A)\n          n i (mod_type_class.from_nat k) bezout) =\n    det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n          (mod_type_class.from_nat k) bezout **\n         A)", "proof (rule Suc.hyps, rule bezout_matrix_not_zero[OF ib _ Suc.prems(1)])"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)\n 2. n < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "show \"n < ncols ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "using Suc.prems(2)"], ["proof (prove)\nusing this:\n  Suc n < ncols A\n\ngoal (1 subgoal):\n 1. n < ncols\n         (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n           (mod_type_class.from_nat k) bezout **\n          A)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc n < CARD('n)\n\ngoal (1 subgoal):\n 1. n < CARD('n)", "by simp"], ["proof (state)\nthis:\n  n < ncols\n       (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n         (mod_type_class.from_nat k) bezout **\n        A)\n\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)", "show \"i \\<noteq> from_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)", "using False"], ["proof (prove)\nusing this:\n  \\<not> Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc n)", "by (metis Suc.prems(2) eq_imp_le ncols_def to_nat_from_nat_id)"], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (bezout_iterate\n        (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n          (mod_type_class.from_nat k) bezout **\n         A)\n        n i (mod_type_class.from_nat k) bezout) =\n  det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n        (mod_type_class.from_nat k) bezout **\n       A)\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "also"], ["proof (state)\nthis:\n  det (bezout_iterate\n        (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n          (mod_type_class.from_nat k) bezout **\n         A)\n        n i (mod_type_class.from_nat k) bezout) =\n  det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n        (mod_type_class.from_nat k) bezout **\n       A)\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "have \"... = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n          (mod_type_class.from_nat k) bezout **\n         A) =\n    det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n          (mod_type_class.from_nat k) bezout **\n         A) =\n    det A", "have \"det ?B = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n          (mod_type_class.from_nat k) bezout) =\n    (1::'a)", "proof (rule det_bezout_matrix[OF ib _  Suc.prems(1)])"], ["proof (state)\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "have \"from_nat (to_nat i) < (from_nat (Suc n)::'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat i)\n    < mod_type_class.from_nat (Suc n)", "proof (rule from_nat_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < Suc n\n 2. Suc n < CARD('n)", "show \"to_nat i < Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc n", "using False"], ["proof (prove)\nusing this:\n  \\<not> Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc n", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < Suc n\n\ngoal (1 subgoal):\n 1. Suc n < CARD('n)", "show \"Suc n < CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n < CARD('n)", "using Suc.prems(2)"], ["proof (prove)\nusing this:\n  Suc n < ncols A\n\ngoal (1 subgoal):\n 1. Suc n < CARD('n)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc n < CARD('n)\n\ngoal (1 subgoal):\n 1. Suc n < CARD('n)", "."], ["proof (state)\nthis:\n  Suc n < CARD('n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat i)\n  < mod_type_class.from_nat (Suc n)\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "thus \"i < mod_type_class.from_nat (Suc n)\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (mod_type_class.to_nat i)\n  < mod_type_class.from_nat (Suc n)\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "unfolding from_nat_to_nat_id"], ["proof (prove)\nusing this:\n  i < mod_type_class.from_nat (Suc n)\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc n)", "."], ["proof (state)\nthis:\n  i < mod_type_class.from_nat (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n        (mod_type_class.from_nat k) bezout) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n          (mod_type_class.from_nat k) bezout **\n         A) =\n    det A", "thus ?thesis"], ["proof (prove)\nusing this:\n  det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n        (mod_type_class.from_nat k) bezout) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n          (mod_type_class.from_nat k) bezout **\n         A) =\n    det A", "unfolding  det_mul"], ["proof (prove)\nusing this:\n  det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n        (mod_type_class.from_nat k) bezout) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n          (mod_type_class.from_nat k) bezout) *\n    det A =\n    det A", "by auto"], ["proof (state)\nthis:\n  det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n        (mod_type_class.from_nat k) bezout **\n       A) =\n  det A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (bezout_matrix A i (mod_type_class.from_nat (Suc n))\n        (mod_type_class.from_nat k) bezout **\n       A) =\n  det A\n\ngoal (1 subgoal):\n 1. \\<not> Suc n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "finally"], ["proof (chain)\npicking this:\n  det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n  det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n  det A\n\ngoal (1 subgoal):\n 1. det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n    det A", "."], ["proof (state)\nthis:\n  det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n  det A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (bezout_iterate A (Suc n) i (mod_type_class.from_nat k) bezout) =\n  det A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Echelon Form of column k\\<close>"], ["", "lemma det_echelon_form_of_column_k_det:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and det: \"det_P * det B = det A\"\n  shows \"fst ((echelon_form_of_column_k_det bezout) (det_P,A,i) k) * det B \n  = det (fst (snd ((echelon_form_of_column_k_det bezout) (det_P,A,i) k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_column_k_det bezout (det_P, A, i) k) * det B =\n    det (fst (snd (echelon_form_of_column_k_det bezout (det_P, A, i) k)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_column_k_det bezout (det_P, A, i) k) * det B =\n    det (fst (snd (echelon_form_of_column_k_det bezout (det_P, A, i) k)))", "let ?interchange=\"(interchange_rows A (from_nat i) \n    (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_column_k_det bezout (det_P, A, i) k) * det B =\n    det (fst (snd (echelon_form_of_column_k_det bezout (det_P, A, i) k)))", "let ?B=\"(bezout_iterate ?interchange (nrows A - Suc 0) (from_nat i) (from_nat k) bezout)\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_column_k_det bezout (det_P, A, i) k) * det B =\n    det (fst (snd (echelon_form_of_column_k_det bezout (det_P, A, i) k)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_column_k_det bezout (det_P, A, i) k) * det B =\n    det (fst (snd (echelon_form_of_column_k_det bezout (det_P, A, i) k)))", "proof (unfold echelon_form_of_column_k_det_def Let_def echelon_form_of_column_k_def, \n      auto simp add: assms)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> - det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)\n 2. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> - det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)\n 2. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "assume i: \"from_nat i < m\"\n      and Amk: \"A $ m $ from_nat k \\<noteq> 0\"\n      and i_not_nrows: \"i \\<noteq> nrows A \"\n      and Aik: \"A $ from_nat i $ from_nat k = 0\""], ["proof (state)\nthis:\n  mod_type_class.from_nat i < m\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  i \\<noteq> nrows A\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> - det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)\n 2. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "have \"det ?B = det ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_iterate\n          (interchange_rows A (mod_type_class.from_nat i)\n            (LEAST n.\n                A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                mod_type_class.from_nat i \\<le> n))\n          (nrows A - Suc 0) (mod_type_class.from_nat i)\n          (mod_type_class.from_nat k) bezout) =\n    det (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))", "proof (rule det_bezout_iterate[OF ib])"], ["proof (state)\ngoal (2 subgoals):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < ncols\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "show \"?interchange $ from_nat i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) Amk LeastI_ex \n          dual_order.strict_iff_order i interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < ncols\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "show \"nrows A - Suc 0 < ncols ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < ncols\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "unfolding nrows_def ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) - Suc 0 < CARD('n)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < ncols\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout) =\n  det (interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n))\n\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> - det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)\n 2. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "also"], ["proof (state)\nthis:\n  det (bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout) =\n  det (interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n))\n\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> - det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)\n 2. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "have \"... = - det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n)) =\n    - det A", "proof (rule det_interchange_different_rows, rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    False", "assume i_least: \"from_nat i = (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n)\""], ["proof (state)\nthis:\n  mod_type_class.from_nat i =\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    False", "have \"A $ from_nat i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (poly_guards_query, lifting) Amk LeastI_ex \n          linear i i_least leD)"], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i =\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        mod_type_class.from_nat i \\<le> n) \\<Longrightarrow>\n    False", "thus \"False\""], ["proof (prove)\nusing this:\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using Aik"], ["proof (prove)\nusing this:\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n)) =\n  - det A\n\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> - det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)\n 2. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "finally"], ["proof (chain)\npicking this:\n  det (bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout) =\n  - det A", "show \"- det A = det ?B\""], ["proof (prove)\nusing this:\n  det (bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout) =\n  - det A\n\ngoal (1 subgoal):\n 1. - det A =\n    det (bezout_iterate\n          (interchange_rows A (mod_type_class.from_nat i)\n            (LEAST n.\n                A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                mod_type_class.from_nat i \\<le> n))\n          (nrows A - Suc 0) (mod_type_class.from_nat i)\n          (mod_type_class.from_nat k) bezout)", "by simp"], ["proof (state)\nthis:\n  - det A =\n  det (bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout)\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "assume i: \"i \\<noteq> nrows A\"\n      and Aik: \"A $ from_nat i $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  i \\<noteq> nrows A\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "have \"det ?B = det ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (bezout_iterate\n          (interchange_rows A (mod_type_class.from_nat i)\n            (LEAST n.\n                A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                mod_type_class.from_nat i \\<le> n))\n          (nrows A - Suc 0) (mod_type_class.from_nat i)\n          (mod_type_class.from_nat k) bezout) =\n    det (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))", "proof (rule det_bezout_iterate[OF ib])"], ["proof (state)\ngoal (2 subgoals):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. nrows A - Suc 0\n    < ncols\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "show \"?interchange $ from_nat i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) Aik LeastI order_refl interchange_rows_i)"], ["proof (state)\nthis:\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) $\n  mod_type_class.from_nat i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < ncols\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "show \"nrows A - Suc 0 < ncols ?interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A - Suc 0\n    < ncols\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))", "unfolding nrows_def ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) - Suc 0 < CARD('n)", "by simp"], ["proof (state)\nthis:\n  nrows A - Suc 0\n  < ncols\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout) =\n  det (interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "also"], ["proof (state)\nthis:\n  det (bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout) =\n  det (interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "have \"... = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n)) =\n    det A", "by (rule det_interchange_same_rows, rule Least_equality[symmetric], auto simp add: Aik)"], ["proof (state)\nthis:\n  det (interchange_rows A (mod_type_class.from_nat i)\n        (LEAST n.\n            A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n            mod_type_class.from_nat i \\<le> n)) =\n  det A\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        mod_type_class.from_nat i < ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a);\n        i \\<noteq> nrows A;\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat k \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> det A =\n                         det (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - Suc 0) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout)", "finally"], ["proof (chain)\npicking this:\n  det (bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout) =\n  det A", "show \"det A = det ?B\""], ["proof (prove)\nusing this:\n  det (bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout) =\n  det A\n\ngoal (1 subgoal):\n 1. det A =\n    det (bezout_iterate\n          (interchange_rows A (mod_type_class.from_nat i)\n            (LEAST n.\n                A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                mod_type_class.from_nat i \\<le> n))\n          (nrows A - Suc 0) (mod_type_class.from_nat i)\n          (mod_type_class.from_nat k) bezout)", ".."], ["proof (state)\nthis:\n  det A =\n  det (bezout_iterate\n        (interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n))\n        (nrows A - Suc 0) (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) bezout)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (echelon_form_of_column_k_det bezout (det_P, A, i) k) * det B =\n  det (fst (snd (echelon_form_of_column_k_det bezout (det_P, A, i) k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snd_echelon_form_of_column_k_det_eq:\n  shows \"snd ((echelon_form_of_column_k_det bezout) (n, A, i) k) \n  = (echelon_form_of_column_k bezout) (A,i) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k_det bezout (n, A, i) k) =\n    echelon_form_of_column_k bezout (A, i) k", "unfolding echelon_form_of_column_k_det_def echelon_form_of_column_k_def Let_def snd_conv fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (case (n, A, i) of\n         (det_P, A, i) \\<Rightarrow>\n           if i \\<noteq> nrows A \\<and>\n              A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n              (0::'a) \\<and>\n              (\\<exists>m>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a))\n           then (- (1::'a) * det_P,\n                 case (A, i) of\n                 (A, i) \\<Rightarrow>\n                   if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                          A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n                      i = nrows A\n                   then (A, i)\n                   else if \\<forall>m>mod_type_class.from_nat i.\n                              A $ m $ mod_type_class.from_nat k = (0::'a)\n                        then (A, i + 1)\n                        else (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - 1) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout,\n                              i + 1))\n           else (det_P,\n                 case (A, i) of\n                 (A, i) \\<Rightarrow>\n                   if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                          A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n                      i = nrows A\n                   then (A, i)\n                   else if \\<forall>m>mod_type_class.from_nat i.\n                              A $ m $ mod_type_class.from_nat k = (0::'a)\n                        then (A, i + 1)\n                        else (bezout_iterate\n                               (interchange_rows A\n                                 (mod_type_class.from_nat i)\n                                 (LEAST n.\n                                     A $ n $\n                                     mod_type_class.from_nat k \\<noteq>\n                                     (0::'a) \\<and>\n                                     mod_type_class.from_nat i \\<le> n))\n                               (nrows A - 1) (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k) bezout,\n                              i + 1))) =\n    (case (A, i) of\n     (A, i) \\<Rightarrow>\n       if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n              A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n          i = nrows A\n       then (A, i)\n       else if \\<forall>m>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)\n            then (A, i + 1)\n            else (bezout_iterate\n                   (interchange_rows A (mod_type_class.from_nat i)\n                     (LEAST n.\n                         A $ n $ mod_type_class.from_nat k \\<noteq>\n                         (0::'a) \\<and>\n                         mod_type_class.from_nat i \\<le> n))\n                   (nrows A - 1) (mod_type_class.from_nat i)\n                   (mod_type_class.from_nat k) bezout,\n                  i + 1))", "by auto"], ["", "subsubsection\\<open>Echelon form up to column k\\<close>"], ["", "lemma snd_foldl_ef_det_eq: \"snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k]) \n  = foldl (echelon_form_of_column_k bezout) (A, 0) [0..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k]) =\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<k]", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<0]) =\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<0]\n 2. \\<And>k.\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0)\n        [0..<k] \\<Longrightarrow>\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0)\n             [0..<Suc k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<0]) =\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<0]\n 2. \\<And>k.\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0)\n        [0..<k] \\<Longrightarrow>\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0)\n             [0..<Suc k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<0]) =\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<0]", "by (simp add: echelon_form_of_column_k_det_def Let_def)"], ["proof (state)\nthis:\n  snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<0]) =\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<0]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0)\n        [0..<k] \\<Longrightarrow>\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0)\n             [0..<Suc k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0)\n        [0..<k] \\<Longrightarrow>\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0)\n             [0..<Suc k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]", "case (Suc k)"], ["proof (state)\nthis:\n  snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k]) =\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<k]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0)\n        [0..<k] \\<Longrightarrow>\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0)\n             [0..<Suc k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]", "have Suc_rw: \"[0..<(Suc k)] = [0..<k] @ [k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc k] = [0..<k] @ [k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc k] = [0..<k] @ [k]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0)\n        [0..<k] \\<Longrightarrow>\n       snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0)\n             [0..<Suc k]) =\n       foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0)\n          [0..<Suc k]) =\n    foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]", "unfolding Suc_rw foldl_append List.foldl.simps fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k_det bezout\n          (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k])\n          k) =\n    echelon_form_of_column_k bezout\n     (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<k]) k", "using Suc.hyps[unfolded echelon_form_of_upt_k_det_def Let_def snd_conv, simplified]"], ["proof (prove)\nusing this:\n  snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k]) =\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<k]\n\ngoal (1 subgoal):\n 1. snd (echelon_form_of_column_k_det bezout\n          (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<k])\n          k) =\n    echelon_form_of_column_k bezout\n     (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<k]) k", "by (metis prod.collapse snd_echelon_form_of_column_k_det_eq)"], ["proof (state)\nthis:\n  snd (foldl (echelon_form_of_column_k_det bezout) (n, A, 0) [0..<Suc k]) =\n  foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snd_echelon_form_of_upt_k_det_eq:\n  shows \"snd ((echelon_form_of_upt_k_det bezout) (n, A) k) = echelon_form_of_upt_k A k bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (echelon_form_of_upt_k_det bezout (n, A) k) =\n    echelon_form_of_upt_k A k bezout", "unfolding echelon_form_of_upt_k_det_def echelon_form_of_upt_k_def Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n               [0..<Suc k])) =\n    fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])", "unfolding snd_foldl_ef_det_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]) =\n    fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k])", "by auto"], ["", "lemma det_echelon_form_of_upt_k_det:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"fst ((echelon_form_of_upt_k_det bezout) (1::'a,A) k) *  det A \n  = det (snd ((echelon_form_of_upt_k_det bezout) (1::'a,A) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_upt_k_det bezout (1::'a, A) k) * det A =\n    det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) k))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (echelon_form_of_upt_k_det bezout (1::'a, A) 0) * det A =\n    det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) 0))\n 2. \\<And>k.\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) k) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A)\n                  k)) \\<Longrightarrow>\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. fst (echelon_form_of_upt_k_det bezout (1::'a, A) 0) * det A =\n    det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) 0))\n 2. \\<And>k.\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) k) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A)\n                  k)) \\<Longrightarrow>\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_upt_k_det bezout (1::'a, A) 0) * det A =\n    det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) 0))", "unfolding echelon_form_of_upt_k_det_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst (foldl (echelon_form_of_column_k_det bezout)\n               (1::'a, snd (1::'a, A), 0) [0..<Suc 0]),\n         fst (snd (foldl (echelon_form_of_column_k_det bezout)\n                    (1::'a, snd (1::'a, A), 0) [0..<Suc 0]))) *\n    det A =\n    det (snd (fst (foldl (echelon_form_of_column_k_det bezout)\n                    (1::'a, snd (1::'a, A), 0) [0..<Suc 0]),\n              fst (snd (foldl (echelon_form_of_column_k_det bezout)\n                         (1::'a, snd (1::'a, A), 0) [0..<Suc 0]))))", "by (auto, rule det_echelon_form_of_column_k_det[OF ib], simp)"], ["proof (state)\nthis:\n  fst (echelon_form_of_upt_k_det bezout (1::'a, A) 0) * det A =\n  det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) 0))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) k) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A)\n                  k)) \\<Longrightarrow>\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) k) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A)\n                  k)) \\<Longrightarrow>\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "case (Suc k)"], ["proof (state)\nthis:\n  fst (echelon_form_of_upt_k_det bezout (1::'a, A) k) * det A =\n  det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) k) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A)\n                  k)) \\<Longrightarrow>\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "let ?f = \"foldl (echelon_form_of_column_k_det bezout) (1,A,0) [0..<Suc k]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) k) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A)\n                  k)) \\<Longrightarrow>\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "have Suc_rw: \"[0..<Suc (Suc k)] = [0..<(Suc k)] @ [Suc k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) k) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A)\n                  k)) \\<Longrightarrow>\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "have fold_expand: \"?f = (fst ?f, fst (snd ?f), snd (snd ?f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0) [0..<Suc k] =\n    (fst (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n           [0..<Suc k]),\n     fst (snd (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n                [0..<Suc k])),\n     snd (snd (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n                [0..<Suc k])))", "by simp"], ["proof (state)\nthis:\n  foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0) [0..<Suc k] =\n  (fst (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n         [0..<Suc k]),\n   fst (snd (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n              [0..<Suc k])),\n   snd (snd (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n              [0..<Suc k])))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) k) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A)\n                  k)) \\<Longrightarrow>\n       fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)) * det A =\n       det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)) * det A =\n    det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "unfolding echelon_form_of_upt_k_det_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst (foldl (echelon_form_of_column_k_det bezout)\n               (1::'a, snd (1::'a, A), 0) [0..<Suc (Suc k)]),\n         fst (snd (foldl (echelon_form_of_column_k_det bezout)\n                    (1::'a, snd (1::'a, A), 0) [0..<Suc (Suc k)]))) *\n    det A =\n    det (snd (fst (foldl (echelon_form_of_column_k_det bezout)\n                    (1::'a, snd (1::'a, A), 0) [0..<Suc (Suc k)]),\n              fst (snd (foldl (echelon_form_of_column_k_det bezout)\n                         (1::'a, snd (1::'a, A), 0) [0..<Suc (Suc k)]))))", "unfolding Suc_rw foldl_append List.foldl.simps fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_column_k_det bezout\n          (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n            [0..<Suc k])\n          (Suc k)) *\n    det A =\n    det (fst (snd (echelon_form_of_column_k_det bezout\n                    (foldl (echelon_form_of_column_k_det bezout)\n                      (1::'a, A, 0) [0..<Suc k])\n                    (Suc k))))", "apply (subst (1 2) fold_expand)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_column_k_det bezout\n          (fst (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n                 [0..<Suc k]),\n           fst (snd (foldl (echelon_form_of_column_k_det bezout)\n                      (1::'a, A, 0) [0..<Suc k])),\n           snd (snd (foldl (echelon_form_of_column_k_det bezout)\n                      (1::'a, A, 0) [0..<Suc k])))\n          (Suc k)) *\n    det A =\n    det (fst (snd (echelon_form_of_column_k_det bezout\n                    (fst (foldl (echelon_form_of_column_k_det bezout)\n                           (1::'a, A, 0) [0..<Suc k]),\n                     fst (snd (foldl (echelon_form_of_column_k_det bezout)\n                                (1::'a, A, 0) [0..<Suc k])),\n                     snd (snd (foldl (echelon_form_of_column_k_det bezout)\n                                (1::'a, A, 0) [0..<Suc k])))\n                    (Suc k))))", "apply (rule det_echelon_form_of_column_k_det)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_bezout_ext bezout\n 2. fst (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n          [0..<Suc k]) *\n    det A =\n    det (fst (snd (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n                    [0..<Suc k])))", "apply (rule ib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n          [0..<Suc k]) *\n    det A =\n    det (fst (snd (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n                    [0..<Suc k])))", "apply (subst (1) snd_foldl_ef_det_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n          [0..<Suc k]) *\n    det A =\n    det (fst (foldl (echelon_form_of_column_k bezout) (A, 0) [0..<Suc k]))", "by (metis Suc.hyps echelon_form_of_upt_k_det_def fst_conv snd_conv snd_foldl_ef_det_eq)"], ["proof (state)\nthis:\n  fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)) * det A =\n  det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Echelon form\\<close>"], ["", "lemma det_echelon_form_of_det:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"(fst (echelon_form_of_det A bezout)) * det A = det (snd (echelon_form_of_det A bezout))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_det A bezout) * det A =\n    det (snd (echelon_form_of_det A bezout))", "using det_echelon_form_of_upt_k_det ib"], ["proof (prove)\nusing this:\n  is_bezout_ext ?bezout \\<Longrightarrow>\n  fst (echelon_form_of_upt_k_det ?bezout (1::?'a, ?A) ?k) * det ?A =\n  det (snd (echelon_form_of_upt_k_det ?bezout (1::?'a, ?A) ?k))\n  is_bezout_ext bezout\n\ngoal (1 subgoal):\n 1. fst (echelon_form_of_det A bezout) * det A =\n    det (snd (echelon_form_of_det A bezout))", "unfolding echelon_form_of_det_def"], ["proof (prove)\nusing this:\n  is_bezout_ext ?bezout \\<Longrightarrow>\n  fst (echelon_form_of_upt_k_det ?bezout (1::?'a, ?A) ?k) * det ?A =\n  det (snd (echelon_form_of_upt_k_det ?bezout (1::?'a, ?A) ?k))\n  is_bezout_ext bezout\n\ngoal (1 subgoal):\n 1. fst (echelon_form_of_upt_k_det bezout (1::'a, A) (ncols A - 1)) *\n    det A =\n    det (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (ncols A - 1)))", "by simp"], ["", "subsubsection\\<open>Proving that the first component is a unit\\<close>"], ["", "lemma echelon_form_of_column_k_det_unit:\n  fixes A::\"'a::{bezout_domain_div}^'n::{mod_type}^'n::{mod_type}\"\n  assumes det: \"is_unit (det_P)\"\n  shows \"is_unit (fst ((echelon_form_of_column_k_det bezout) (det_P,A,i) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (fst (echelon_form_of_column_k_det bezout (det_P, A, i) k))", "unfolding echelon_form_of_column_k_det_def Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit\n     (fst (case (det_P, A, i) of\n           (det_P, A, i) \\<Rightarrow>\n             if i \\<noteq> nrows A \\<and>\n                A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n                (0::'a) \\<and>\n                (\\<exists>m>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a))\n             then (- (1::'a) * det_P,\n                   echelon_form_of_column_k bezout (A, i) k)\n             else (det_P, echelon_form_of_column_k bezout (A, i) k)))", "using det"], ["proof (prove)\nusing this:\n  is_unit det_P\n\ngoal (1 subgoal):\n 1. is_unit\n     (fst (case (det_P, A, i) of\n           (det_P, A, i) \\<Rightarrow>\n             if i \\<noteq> nrows A \\<and>\n                A $ mod_type_class.from_nat i $ mod_type_class.from_nat k =\n                (0::'a) \\<and>\n                (\\<exists>m>mod_type_class.from_nat i.\n                    A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a))\n             then (- (1::'a) * det_P,\n                   echelon_form_of_column_k bezout (A, i) k)\n             else (det_P, echelon_form_of_column_k bezout (A, i) k)))", "by auto"], ["", "lemma echelon_form_of_upt_k_det_unit:\n  fixes A::\"'a::{bezout_domain_div}^'n::{mod_type}^'n::{mod_type}\"\n  shows \"is_unit (fst ((echelon_form_of_upt_k_det bezout) (1::'a,A) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) k))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) 0))\n 2. \\<And>k.\n       is_unit\n        (fst (echelon_form_of_upt_k_det bezout (1::'a, A)\n               k)) \\<Longrightarrow>\n       is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) 0))\n 2. \\<And>k.\n       is_unit\n        (fst (echelon_form_of_upt_k_det bezout (1::'a, A)\n               k)) \\<Longrightarrow>\n       is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) 0))", "unfolding echelon_form_of_upt_k_det_def Let_def fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit\n     (fst (foldl (echelon_form_of_column_k_det bezout)\n            (1::'a, snd (1::'a, A), 0) [0..<Suc 0]))", "using echelon_form_of_column_k_det_unit[of 1]"], ["proof (prove)\nusing this:\n  is_unit (1::?'b1) \\<Longrightarrow>\n  is_unit (fst (echelon_form_of_column_k_det ?bezout (1::?'b1, ?A, ?i) ?k))\n\ngoal (1 subgoal):\n 1. is_unit\n     (fst (foldl (echelon_form_of_column_k_det bezout)\n            (1::'a, snd (1::'a, A), 0) [0..<Suc 0]))", "by auto"], ["proof (state)\nthis:\n  is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) 0))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_unit\n        (fst (echelon_form_of_upt_k_det bezout (1::'a, A)\n               k)) \\<Longrightarrow>\n       is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_unit\n        (fst (echelon_form_of_upt_k_det bezout (1::'a, A)\n               k)) \\<Longrightarrow>\n       is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "case (Suc k)"], ["proof (state)\nthis:\n  is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_unit\n        (fst (echelon_form_of_upt_k_det bezout (1::'a, A)\n               k)) \\<Longrightarrow>\n       is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "let ?f = \"foldl (echelon_form_of_column_k_det bezout) (1,A,0) [0..<Suc k]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_unit\n        (fst (echelon_form_of_upt_k_det bezout (1::'a, A)\n               k)) \\<Longrightarrow>\n       is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "have Suc_rw: \"[0..<Suc (Suc k)] = [0..<(Suc k)] @ [Suc k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_unit\n        (fst (echelon_form_of_upt_k_det bezout (1::'a, A)\n               k)) \\<Longrightarrow>\n       is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "have fold_expand: \"?f = (fst ?f, fst (snd ?f), snd (snd ?f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0) [0..<Suc k] =\n    (fst (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n           [0..<Suc k]),\n     fst (snd (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n                [0..<Suc k])),\n     snd (snd (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n                [0..<Suc k])))", "by simp"], ["proof (state)\nthis:\n  foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0) [0..<Suc k] =\n  (fst (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n         [0..<Suc k]),\n   fst (snd (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n              [0..<Suc k])),\n   snd (snd (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n              [0..<Suc k])))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       is_unit\n        (fst (echelon_form_of_upt_k_det bezout (1::'a, A)\n               k)) \\<Longrightarrow>\n       is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))", "unfolding echelon_form_of_upt_k_det_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit\n     (fst (fst (foldl (echelon_form_of_column_k_det bezout)\n                 (1::'a, snd (1::'a, A), 0) [0..<Suc (Suc k)]),\n           fst (snd (foldl (echelon_form_of_column_k_det bezout)\n                      (1::'a, snd (1::'a, A), 0) [0..<Suc (Suc k)]))))", "unfolding Suc_rw foldl_append List.foldl.simps fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit\n     (fst (echelon_form_of_column_k_det bezout\n            (foldl (echelon_form_of_column_k_det bezout) (1::'a, A, 0)\n              [0..<Suc k])\n            (Suc k)))", "by (subst fold_expand, rule echelon_form_of_column_k_det_unit\n    [OF Suc.hyps[unfolded echelon_form_of_upt_k_det_def Let_def fst_conv snd_conv]])"], ["proof (state)\nthis:\n  is_unit (fst (echelon_form_of_upt_k_det bezout (1::'a, A) (Suc k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_of_unit:\n  fixes A::\"'a::{bezout_domain_div}^'n::{mod_type}^'n::{mod_type}\"\n  shows \"is_unit (fst (echelon_form_of_det A k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (fst (echelon_form_of_det A k))", "unfolding echelon_form_of_det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (fst (echelon_form_of_upt_k_det k (1::'a, A) (ncols A - 1)))", "by (rule echelon_form_of_upt_k_det_unit)"], ["", "subsubsection\\<open>Final lemmas\\<close>"], ["", "corollary det_echelon_form_of_det':\n  fixes A::\"'a::{bezout_domain_div}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"det A = 1 div (fst (echelon_form_of_det A bezout)) \n  * det (snd (echelon_form_of_det A bezout))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (1::'a) div fst (echelon_form_of_det A bezout) *\n    det (snd (echelon_form_of_det A bezout))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (1::'a) div fst (echelon_form_of_det A bezout) *\n    det (snd (echelon_form_of_det A bezout))", "have \"(fst (echelon_form_of_det A bezout)) * det A = det (snd (echelon_form_of_det A bezout))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (echelon_form_of_det A bezout) * det A =\n    det (snd (echelon_form_of_det A bezout))", "by (rule det_echelon_form_of_det[OF ib])"], ["proof (state)\nthis:\n  fst (echelon_form_of_det A bezout) * det A =\n  det (snd (echelon_form_of_det A bezout))\n\ngoal (1 subgoal):\n 1. det A =\n    (1::'a) div fst (echelon_form_of_det A bezout) *\n    det (snd (echelon_form_of_det A bezout))", "thus \"det A = 1 div (fst (echelon_form_of_det A bezout)) \n    * det (snd (echelon_form_of_det A bezout))\""], ["proof (prove)\nusing this:\n  fst (echelon_form_of_det A bezout) * det A =\n  det (snd (echelon_form_of_det A bezout))\n\ngoal (1 subgoal):\n 1. det A =\n    (1::'a) div fst (echelon_form_of_det A bezout) *\n    det (snd (echelon_form_of_det A bezout))", "by (auto simp add: echelon_form_of_unit dest: sym)"], ["proof (state)\nthis:\n  det A =\n  (1::'a) div fst (echelon_form_of_det A bezout) *\n  det (snd (echelon_form_of_det A bezout))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ef_echelon_form_of_det:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"echelon_form (snd (echelon_form_of_det A bezout))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (snd (echelon_form_of_det A bezout))", "unfolding echelon_form_of_det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form\n     (snd (echelon_form_of_upt_k_det bezout (1::'a, A) (ncols A - 1)))", "unfolding snd_echelon_form_of_upt_k_det_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of_upt_k A (ncols A - 1) bezout)", "unfolding echelon_form_of_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of A bezout)", "by (rule echelon_form_echelon_form_of[OF ib])"], ["", "lemma det_echelon_form:\n  fixes A::\"'a::{bezout_domain}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ef: \"echelon_form A\"\n  shows \"det A = prod (\\<lambda>i. A $ i $ i) (UNIV:: 'n set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = (\\<Prod>i\\<in>UNIV. A $ i $ i)", "using det_upperdiagonal echelon_form_imp_upper_triagular[OF ef]"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      j < i \\<Longrightarrow> ?A $ i $ j = (0::?'a)) \\<Longrightarrow>\n  det ?A = (\\<Prod>i\\<in>UNIV. ?A $ i $ i)\n  upper_triangular A\n\ngoal (1 subgoal):\n 1. det A = (\\<Prod>i\\<in>UNIV. A $ i $ i)", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      j < i \\<Longrightarrow> ?A $ i $ j = (0::?'a)) \\<Longrightarrow>\n  det ?A = (\\<Prod>i\\<in>UNIV. ?A $ i $ i)\n  \\<forall>i j. j < i \\<longrightarrow> A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = (\\<Prod>i\\<in>UNIV. A $ i $ i)", "by blast"], ["", "corollary det_echelon_form_of_det_prod:\n  fixes A::\"'a::{bezout_domain_div}^'n::{mod_type}^'n::{mod_type}\"\n  assumes ib: \"is_bezout_ext bezout\"\n  shows \"det A = 1 div (fst (echelon_form_of_det A bezout)) \n  * prod (\\<lambda>i. snd (echelon_form_of_det A bezout) $ i $ i) (UNIV:: 'n set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (1::'a) div fst (echelon_form_of_det A bezout) *\n    (\\<Prod>i\\<in>UNIV. snd (echelon_form_of_det A bezout) $ i $ i)", "using det_echelon_form_of_det'[OF ib]"], ["proof (prove)\nusing this:\n  det ?A =\n  (1::'a) div fst (echelon_form_of_det ?A bezout) *\n  det (snd (echelon_form_of_det ?A bezout))\n\ngoal (1 subgoal):\n 1. det A =\n    (1::'a) div fst (echelon_form_of_det A bezout) *\n    (\\<Prod>i\\<in>UNIV. snd (echelon_form_of_det A bezout) $ i $ i)", "unfolding det_echelon_form[OF ef_echelon_form_of_det[OF ib]]"], ["proof (prove)\nusing this:\n  det ?A =\n  (1::'a) div fst (echelon_form_of_det ?A bezout) *\n  (\\<Prod>i\\<in>UNIV. snd (echelon_form_of_det ?A bezout) $ i $ i)\n\ngoal (1 subgoal):\n 1. det A =\n    (1::'a) div fst (echelon_form_of_det A bezout) *\n    (\\<Prod>i\\<in>UNIV. snd (echelon_form_of_det A bezout) $ i $ i)", "by auto"], ["", "corollary det_echelon_form_of_euclidean[code]:\n  fixes A::\"'a::{euclidean_ring_gcd}^'n::{mod_type}^'n::{mod_type}\"\n  shows \"det A = 1 div (fst (echelon_form_of_det A euclid_ext2)) \n  * prod (\\<lambda>i. snd (echelon_form_of_det A euclid_ext2) $ i $ i) (UNIV:: 'n set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (1::'a) div fst (echelon_form_of_det A euclid_ext2) *\n    (\\<Prod>i\\<in>UNIV. snd (echelon_form_of_det A euclid_ext2) $ i $ i)", "by (rule det_echelon_form_of_det_prod[OF is_bezout_ext_euclid_ext2])"], ["", "end"]]}