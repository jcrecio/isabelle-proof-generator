{"file_name": "/home/qj213/afp-2021-10-22/thys/Parity_Game/ParityGame.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Parity_Game", "problem_names": ["lemma edges_are_in_V [intro]: \"v\\<rightarrow>w \\<Longrightarrow> v \\<in> V\" \"v\\<rightarrow>w \\<Longrightarrow> w \\<in> V\"", "lemma valid_path_ltl': \"valid_path (LCons v Ps) \\<Longrightarrow> valid_path Ps\"", "lemma valid_path_ltl: \"valid_path P \\<Longrightarrow> valid_path (ltl P)\"", "lemma valid_path_drop: \"valid_path P \\<Longrightarrow> valid_path (ldropn n P)\"", "lemma valid_path_in_V: assumes \"valid_path P\" shows \"lset P \\<subseteq> V\"", "lemma valid_path_finite_in_V: \"\\<lbrakk> valid_path P; enat n < llength P \\<rbrakk> \\<Longrightarrow> P $ n \\<in> V\"", "lemma valid_path_edges': \"valid_path (LCons v (LCons w Ps)) \\<Longrightarrow> v\\<rightarrow>w\"", "lemma valid_path_edges:\n  assumes \"valid_path P\" \"enat (Suc n) < llength P\"\n  shows \"P $ n \\<rightarrow> P $ Suc n\"", "lemma valid_path_coinduct [consumes 1, case_names base step, coinduct pred: valid_path]:\n  assumes major: \"Q P\"\n    and base: \"\\<And>v P. Q (LCons v LNil) \\<Longrightarrow> v \\<in> V\"\n    and step: \"\\<And>v w P. Q (LCons v (LCons w P)) \\<Longrightarrow> v\\<rightarrow>w \\<and> (Q (LCons w P) \\<or> valid_path (LCons w P))\"\n  shows \"valid_path P\"", "lemma valid_path_no_deadends:\n  \"\\<lbrakk> valid_path P; enat (Suc i) < llength P \\<rbrakk> \\<Longrightarrow> \\<not>deadend (P $ i)\"", "lemma valid_path_ends_on_deadend:\n  \"\\<lbrakk> valid_path P; enat i < llength P; deadend (P $ i) \\<rbrakk> \\<Longrightarrow> enat (Suc i) = llength P\"", "lemma valid_path_prefix: \"\\<lbrakk> valid_path P; lprefix P' P \\<rbrakk> \\<Longrightarrow> valid_path P'\"", "lemma valid_path_lappend:\n  assumes \"valid_path P\" \"valid_path P'\" \"\\<lbrakk> \\<not>lnull P; \\<not>lnull P' \\<rbrakk> \\<Longrightarrow> llast P\\<rightarrow>lhd P'\"\n  shows \"valid_path (lappend P P')\"", "lemma valid_path_supergame:\n  assumes \"valid_path P\" and G': \"Digraph G'\" \"V \\<subseteq> V\\<^bsub>G'\\<^esub>\" \"E \\<subseteq> E\\<^bsub>G'\\<^esub>\"\n  shows \"Digraph.valid_path G' P\"", "lemma maximal_no_deadend: \"maximal_path (LCons v Ps) \\<Longrightarrow> \\<not>deadend v \\<Longrightarrow> \\<not>lnull Ps\"", "lemma maximal_ltl: \"maximal_path P \\<Longrightarrow> maximal_path (ltl P)\"", "lemma maximal_drop: \"maximal_path P \\<Longrightarrow> maximal_path (ldropn n P)\"", "lemma maximal_path_lappend:\n  assumes \"\\<not>lnull P'\" \"maximal_path P'\"\n  shows \"maximal_path (lappend P P')\"", "lemma maximal_ends_on_deadend:\n  assumes \"maximal_path P\" \"lfinite P\" \"\\<not>lnull P\"\n  shows \"deadend (llast P)\"", "lemma maximal_ends_on_deadend': \"\\<lbrakk> lfinite P; deadend (llast P) \\<rbrakk> \\<Longrightarrow> maximal_path P\"", "lemma infinite_path_is_maximal: \"\\<lbrakk> valid_path P; \\<not>lfinite P \\<rbrakk> \\<Longrightarrow> maximal_path P\"", "lemma other_other_player [simp]: \"p**** = p\"", "lemma VVp_to_V [intro]: \"v \\<in> VV p \\<Longrightarrow> v \\<in> V\"", "lemma VV_impl1: \"v \\<in> VV p \\<Longrightarrow> v \\<notin> VV p**\"", "lemma VV_impl2: \"v \\<in> VV p** \\<Longrightarrow> v \\<notin> VV p\"", "lemma VV_equivalence [iff]: \"v \\<in> V \\<Longrightarrow> v \\<notin> VV p \\<longleftrightarrow> v \\<in> VV p**\"", "lemma VV_cases [consumes 1]: \"\\<lbrakk> v \\<in> V ; v \\<in> VV p \\<Longrightarrow> P ; v \\<in> VV p** \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma deadends_in_V: \"deadends p \\<subseteq> V\"", "lemma subgame_V [simp]: \"V\\<^bsub>subgame V'\\<^esub> \\<subseteq> V\"\n  and subgame_E [simp]: \"E\\<^bsub>subgame V'\\<^esub> \\<subseteq> E\"\n  and subgame_\\<omega>: \"\\<omega>\\<^bsub>subgame V'\\<^esub> = \\<omega>\"", "lemma\n  assumes \"V' \\<subseteq> V\"\n  shows subgame_V' [simp]: \"V\\<^bsub>subgame V'\\<^esub> = V'\"\n    and subgame_E' [simp]: \"E\\<^bsub>subgame V'\\<^esub> = E \\<inter> (V\\<^bsub>subgame V'\\<^esub> \\<times> V\\<^bsub>subgame V'\\<^esub>)\"", "lemma subgame_VV [simp]: \"ParityGame.VV (subgame V') p = V' \\<inter> VV p\"", "lemma subgame_finite [simp]: \"finite (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)\"", "lemma subgame_\\<omega>_subset [simp]: \"\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub> \\<subseteq> \\<omega> ` V\"", "lemma subgame_Digraph: \"Digraph (subgame V')\"", "lemma subgame_ParityGame:\n  shows \"ParityGame (subgame V')\"", "lemma subgame_valid_path:\n  assumes P: \"valid_path P\" \"lset P \\<subseteq> V'\"\n  shows \"Digraph.valid_path (subgame V') P\"", "lemma subgame_maximal_path:\n  assumes V': \"V' \\<subseteq> V\" and P: \"maximal_path P\" \"lset P \\<subseteq> V'\"\n  shows \"Digraph.maximal_path (subgame V') P\"", "lemma path_inf_priorities_is_nonempty:\n  assumes P: \"valid_path P\" \"\\<not>lfinite P\"\n  shows \"\\<exists>k. k \\<in> path_inf_priorities P\"", "lemma path_inf_priorities_at_least_min_prio:\n  assumes P: \"valid_path P\" and a: \"a \\<in> path_inf_priorities P\"\n  shows \"Min (\\<omega> ` V) \\<le> a\"", "lemma path_inf_priorities_LCons:\n  \"path_inf_priorities P = path_inf_priorities (LCons v P)\" (is \"?A = ?B\")", "lemma paths_are_winning_for_one_player:\n  assumes \"valid_path P\"\n  shows \"winning_path p P \\<longleftrightarrow> \\<not>winning_path p** P\"", "lemma winning_path_ltl:\n  assumes P: \"winning_path p P\" \"\\<not>lnull P\" \"\\<not>lnull (ltl P)\"\n  shows \"winning_path p (ltl P)\"", "lemma winning_path_LCons:\n  assumes P: \"winning_path p P\" \"\\<not>lnull P\"\n  shows \"winning_path p (LCons v P)\"", "lemma winning_path_supergame:\n  assumes \"winning_path p P\"\n  and G': \"ParityGame G'\" \"VV p** \\<subseteq> ParityGame.VV G' p**\" \"\\<omega> = \\<omega>\\<^bsub>G'\\<^esub>\"\n  shows \"ParityGame.winning_path G' p P\"", "lemma P_LCons: \"P = LCons v0 (ltl P)\"", "lemma P_len [simp]: \"enat 0 < llength P\"", "lemma P_0 [simp]: \"P $ 0 = v0\"", "lemma P_lnth_Suc: \"P $ Suc n = ltl P $ n\"", "lemma P_no_deadends: \"enat (Suc n) < llength P \\<Longrightarrow> \\<not>deadend (P $ n)\"", "lemma P_no_deadend_v0: \"\\<not>lnull (ltl P) \\<Longrightarrow> \\<not>deadend v0\"", "lemma P_no_deadend_v0_llength: \"enat (Suc n) < llength P \\<Longrightarrow> \\<not>deadend v0\"", "lemma P_ends_on_deadend: \"\\<lbrakk> enat n < llength P; deadend (P $ n) \\<rbrakk> \\<Longrightarrow> enat (Suc n) = llength P\"", "lemma P_lnull_ltl_deadend_v0: \"lnull (ltl P) \\<Longrightarrow> deadend v0\"", "lemma P_lnull_ltl_LCons: \"lnull (ltl P) \\<Longrightarrow> P = LCons v0 LNil\"", "lemma P_deadend_v0_LCons: \"deadend v0 \\<Longrightarrow> P = LCons v0 LNil\"", "lemma Ptl_valid [simp]: \"valid_path (ltl P)\"", "lemma Ptl_maximal [simp]: \"maximal_path (ltl P)\"", "lemma Pdrop_valid [simp]: \"valid_path (ldropn n P)\"", "lemma Pdrop_maximal [simp]: \"maximal_path (ldropn n P)\"", "lemma prefix_valid [simp]: \"valid_path (ltake n P)\"", "lemma extension_valid [simp]: \"v\\<rightarrow>v0 \\<Longrightarrow> valid_path (LCons v P)\"", "lemma extension_maximal [simp]: \"maximal_path (LCons v P)\"", "lemma lappend_maximal [simp]: \"maximal_path (lappend P' P)\"", "lemma v0_V [simp]: \"v0 \\<in> V\"", "lemma v0_lset_P [simp]: \"v0 \\<in> lset P\"", "lemma v0_VV: \"v0 \\<in> VV p \\<or> v0 \\<in> VV p**\"", "lemma lset_P_V [simp]: \"lset P \\<subseteq> V\"", "lemma lset_ltl_P_V [simp]: \"lset (ltl P) \\<subseteq> V\"", "lemma finite_llast_deadend [simp]: \"lfinite P \\<Longrightarrow> deadend (llast P)\"", "lemma finite_llast_V [simp]: \"lfinite P \\<Longrightarrow> llast P \\<in> V\"", "lemma visits_deadend:\n  assumes \"lset P \\<inter> deadends p \\<noteq> {}\"\n  shows \"winning_path p** P\""], "translations": [["", "lemma edges_are_in_V [intro]: \"v\\<rightarrow>w \\<Longrightarrow> v \\<in> V\" \"v\\<rightarrow>w \\<Longrightarrow> w \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<rightarrow> w \\<Longrightarrow> v \\<in> V) &&&\n    (v \\<rightarrow> w \\<Longrightarrow> w \\<in> V)", "using valid_edge_set"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. (v \\<rightarrow> w \\<Longrightarrow> v \\<in> V) &&&\n    (v \\<rightarrow> w \\<Longrightarrow> w \\<in> V)", "by blast+"], ["", "text \\<open>A node without successors is a \\emph{deadend}.\\<close>"], ["", "abbreviation deadend :: \"'a \\<Rightarrow> bool\" where \"deadend v \\<equiv> \\<not>(\\<exists>w \\<in> V. v \\<rightarrow> w)\""], ["", "subsection \\<open>Valid Paths\\<close>"], ["", "text \\<open>\n  We say that a path is \\emph{valid} if it is empty or if it starts in @{term V} and walks along edges.\n\\<close>"], ["", "coinductive valid_path :: \"'a Path \\<Rightarrow> bool\" where\n  valid_path_base: \"valid_path LNil\"\n| valid_path_base': \"v \\<in> V \\<Longrightarrow> valid_path (LCons v LNil)\"\n| valid_path_cons: \"\\<lbrakk> v \\<in> V; w \\<in> V; v\\<rightarrow>w; valid_path Ps; \\<not>lnull Ps; lhd Ps = w \\<rbrakk>\n    \\<Longrightarrow> valid_path (LCons v Ps)\""], ["", "inductive_simps valid_path_cons_simp: \"valid_path (LCons x xs)\""], ["", "lemma valid_path_ltl': \"valid_path (LCons v Ps) \\<Longrightarrow> valid_path Ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (LCons v Ps) \\<Longrightarrow> valid_path Ps", "using valid_path.simps"], ["proof (prove)\nusing this:\n  valid_path ?a =\n  (?a = LNil \\<or>\n   (\\<exists>v. ?a = LCons v LNil \\<and> v \\<in> V) \\<or>\n   (\\<exists>v w Ps.\n       ?a = LCons v Ps \\<and>\n       v \\<in> V \\<and>\n       w \\<in> V \\<and>\n       v \\<rightarrow> w \\<and>\n       valid_path Ps \\<and> \\<not> lnull Ps \\<and> lhd Ps = w))\n\ngoal (1 subgoal):\n 1. valid_path (LCons v Ps) \\<Longrightarrow> valid_path Ps", "by blast"], ["", "lemma valid_path_ltl: \"valid_path P \\<Longrightarrow> valid_path (ltl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path P \\<Longrightarrow> valid_path (ltl P)", "by (metis llist.exhaust_sel ltl_simps(1) valid_path_ltl')"], ["", "lemma valid_path_drop: \"valid_path P \\<Longrightarrow> valid_path (ldropn n P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path P \\<Longrightarrow> valid_path (ldropn n P)", "by (simp add: valid_path_ltl ltl_ldrop)"], ["", "lemma valid_path_in_V: assumes \"valid_path P\" shows \"lset P \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset P \\<subseteq> V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lset P \\<Longrightarrow> x \\<in> V", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lset P \\<Longrightarrow> x \\<in> V", "assume \"x \\<in> lset P\""], ["proof (state)\nthis:\n  x \\<in> lset P\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lset P \\<Longrightarrow> x \\<in> V", "thus \"x \\<in> V\""], ["proof (prove)\nusing this:\n  x \\<in> lset P\n\ngoal (1 subgoal):\n 1. x \\<in> V", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> lset P\n  valid_path P\n\ngoal (1 subgoal):\n 1. x \\<in> V", "by (induct rule: llist.set_induct) (auto intro: valid_path.cases)"], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_path_finite_in_V: \"\\<lbrakk> valid_path P; enat n < llength P \\<rbrakk> \\<Longrightarrow> P $ n \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path P; enat n < llength P\\<rbrakk>\n    \\<Longrightarrow> P $ n \\<in> V", "using valid_path_in_V lset_lnth_member"], ["proof (prove)\nusing this:\n  valid_path ?P \\<Longrightarrow> lset ?P \\<subseteq> V\n  \\<lbrakk>lset ?xs \\<subseteq> ?A; enat ?n < llength ?xs\\<rbrakk>\n  \\<Longrightarrow> ?xs $ ?n \\<in> ?A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path P; enat n < llength P\\<rbrakk>\n    \\<Longrightarrow> P $ n \\<in> V", "by blast"], ["", "lemma valid_path_edges': \"valid_path (LCons v (LCons w Ps)) \\<Longrightarrow> v\\<rightarrow>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (LCons v (LCons w Ps)) \\<Longrightarrow> v \\<rightarrow> w", "using valid_path.cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_path ?a; ?a = LNil \\<Longrightarrow> ?P;\n   \\<And>v.\n      \\<lbrakk>?a = LCons v LNil; v \\<in> V\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v w Ps.\n      \\<lbrakk>?a = LCons v Ps; v \\<in> V; w \\<in> V; v \\<rightarrow> w;\n       valid_path Ps; \\<not> lnull Ps; lhd Ps = w\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. valid_path (LCons v (LCons w Ps)) \\<Longrightarrow> v \\<rightarrow> w", "by fastforce"], ["", "lemma valid_path_edges:\n  assumes \"valid_path P\" \"enat (Suc n) < llength P\"\n  shows \"P $ n \\<rightarrow> P $ Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "define P' where \"P' = ldropn n P\""], ["proof (state)\nthis:\n  P' = ldropn n P\n\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "have \"enat n < llength P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n < llength P", "using assms(2) enat_ord_simps(2) less_trans"], ["proof (prove)\nusing this:\n  enat (Suc n) < llength P\n  (enat ?m < enat ?n) = (?m < ?n)\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. enat n < llength P", "by blast"], ["proof (state)\nthis:\n  enat n < llength P\n\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "hence \"P' $ 0 = P $ n\""], ["proof (prove)\nusing this:\n  enat n < llength P\n\ngoal (1 subgoal):\n 1. P' $ 0 = P $ n", "by (simp add: P'_def)"], ["proof (state)\nthis:\n  P' $ 0 = P $ n\n\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "moreover"], ["proof (state)\nthis:\n  P' $ 0 = P $ n\n\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "have \"P' $ Suc 0 = P $ Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' $ Suc 0 = P $ Suc n", "by (metis One_nat_def P'_def Suc_eq_plus1 add.commute assms(2) lnth_ldropn)"], ["proof (state)\nthis:\n  P' $ Suc 0 = P $ Suc n\n\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "ultimately"], ["proof (chain)\npicking this:\n  P' $ 0 = P $ n\n  P' $ Suc 0 = P $ Suc n", "have \"\\<exists>Ps. P' = LCons (P $ n) (LCons (P $ Suc n) Ps)\""], ["proof (prove)\nusing this:\n  P' $ 0 = P $ n\n  P' $ Suc 0 = P $ Suc n\n\ngoal (1 subgoal):\n 1. \\<exists>Ps. P' = LCons (P $ n) (LCons (P $ Suc n) Ps)", "by (metis P'_def \\<open>enat n < llength P\\<close> assms(2) ldropn_Suc_conv_ldropn)"], ["proof (state)\nthis:\n  \\<exists>Ps. P' = LCons (P $ n) (LCons (P $ Suc n) Ps)\n\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "moreover"], ["proof (state)\nthis:\n  \\<exists>Ps. P' = LCons (P $ n) (LCons (P $ Suc n) Ps)\n\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "have \"valid_path P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path P'", "by (simp add: P'_def assms(1) valid_path_drop)"], ["proof (state)\nthis:\n  valid_path P'\n\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>Ps. P' = LCons (P $ n) (LCons (P $ Suc n) Ps)\n  valid_path P'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>Ps. P' = LCons (P $ n) (LCons (P $ Suc n) Ps)\n  valid_path P'\n\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "using valid_path_edges'"], ["proof (prove)\nusing this:\n  \\<exists>Ps. P' = LCons (P $ n) (LCons (P $ Suc n) Ps)\n  valid_path P'\n  valid_path (LCons ?v (LCons ?w ?Ps)) \\<Longrightarrow> ?v \\<rightarrow> ?w\n\ngoal (1 subgoal):\n 1. P $ n \\<rightarrow> P $ Suc n", "by blast"], ["proof (state)\nthis:\n  P $ n \\<rightarrow> P $ Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_path_coinduct [consumes 1, case_names base step, coinduct pred: valid_path]:\n  assumes major: \"Q P\"\n    and base: \"\\<And>v P. Q (LCons v LNil) \\<Longrightarrow> v \\<in> V\"\n    and step: \"\\<And>v w P. Q (LCons v (LCons w P)) \\<Longrightarrow> v\\<rightarrow>w \\<and> (Q (LCons w P) \\<or> valid_path (LCons w P))\"\n  shows \"valid_path P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path P", "using major"], ["proof (prove)\nusing this:\n  Q P\n\ngoal (1 subgoal):\n 1. valid_path P", "proof (coinduction arbitrary: P)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       Q P \\<Longrightarrow>\n       P = LNil \\<or>\n       (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n       (\\<exists>v w Ps.\n           P = LCons v Ps \\<and>\n           v \\<in> V \\<and>\n           w \\<in> V \\<and>\n           v \\<rightarrow> w \\<and>\n           ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n           \\<not> lnull Ps \\<and> lhd Ps = w)", "case valid_path"], ["proof (state)\nthis:\n  Q P\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Q P \\<Longrightarrow>\n       P = LNil \\<or>\n       (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n       (\\<exists>v w Ps.\n           P = LCons v Ps \\<and>\n           v \\<in> V \\<and>\n           w \\<in> V \\<and>\n           v \\<rightarrow> w \\<and>\n           ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n           \\<not> lnull Ps \\<and> lhd Ps = w)", "{"], ["proof (state)\nthis:\n  Q P\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Q P \\<Longrightarrow>\n       P = LNil \\<or>\n       (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n       (\\<exists>v w Ps.\n           P = LCons v Ps \\<and>\n           v \\<in> V \\<and>\n           w \\<in> V \\<and>\n           v \\<rightarrow> w \\<and>\n           ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n           \\<not> lnull Ps \\<and> lhd Ps = w)", "assume \"P \\<noteq> LNil\" \"\\<not>(\\<exists>v. P = LCons v LNil \\<and> v \\<in> V)\""], ["proof (state)\nthis:\n  P \\<noteq> LNil\n  \\<nexists>v. P = LCons v LNil \\<and> v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Q P \\<Longrightarrow>\n       P = LNil \\<or>\n       (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n       (\\<exists>v w Ps.\n           P = LCons v Ps \\<and>\n           v \\<in> V \\<and>\n           w \\<in> V \\<and>\n           v \\<rightarrow> w \\<and>\n           ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n           \\<not> lnull Ps \\<and> lhd Ps = w)", "then"], ["proof (chain)\npicking this:\n  P \\<noteq> LNil\n  \\<nexists>v. P = LCons v LNil \\<and> v \\<in> V", "obtain v w P' where \"P = LCons v (LCons w P')\""], ["proof (prove)\nusing this:\n  P \\<noteq> LNil\n  \\<nexists>v. P = LCons v LNil \\<and> v \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>v w P'.\n        P = LCons v (LCons w P') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using neq_LNil_conv base valid_path"], ["proof (prove)\nusing this:\n  P \\<noteq> LNil\n  \\<nexists>v. P = LCons v LNil \\<and> v \\<in> V\n  (?xs \\<noteq> LNil) = (\\<exists>x xs'. ?xs = LCons x xs')\n  Q (LCons ?v LNil) \\<Longrightarrow> ?v \\<in> V\n  Q P\n\ngoal (1 subgoal):\n 1. (\\<And>v w P'.\n        P = LCons v (LCons w P') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  P = LCons v (LCons w P')\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Q P \\<Longrightarrow>\n       P = LNil \\<or>\n       (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n       (\\<exists>v w Ps.\n           P = LCons v Ps \\<and>\n           v \\<in> V \\<and>\n           w \\<in> V \\<and>\n           v \\<rightarrow> w \\<and>\n           ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n           \\<not> lnull Ps \\<and> lhd Ps = w)", "hence ?case"], ["proof (prove)\nusing this:\n  P = LCons v (LCons w P')\n\ngoal (1 subgoal):\n 1. P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n    (\\<exists>v w Ps.\n        P = LCons v Ps \\<and>\n        v \\<in> V \\<and>\n        w \\<in> V \\<and>\n        v \\<rightarrow> w \\<and>\n        ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n        \\<not> lnull Ps \\<and> lhd Ps = w)", "using step valid_path"], ["proof (prove)\nusing this:\n  P = LCons v (LCons w P')\n  Q (LCons ?v (LCons ?w ?P)) \\<Longrightarrow>\n  ?v \\<rightarrow> ?w \\<and>\n  (Q (LCons ?w ?P) \\<or> valid_path (LCons ?w ?P))\n  Q P\n\ngoal (1 subgoal):\n 1. P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n    (\\<exists>v w Ps.\n        P = LCons v Ps \\<and>\n        v \\<in> V \\<and>\n        w \\<in> V \\<and>\n        v \\<rightarrow> w \\<and>\n        ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n        \\<not> lnull Ps \\<and> lhd Ps = w)", "by auto"], ["proof (state)\nthis:\n  P = LNil \\<or>\n  (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n  (\\<exists>v w Ps.\n      P = LCons v Ps \\<and>\n      v \\<in> V \\<and>\n      w \\<in> V \\<and>\n      v \\<rightarrow> w \\<and>\n      ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n      \\<not> lnull Ps \\<and> lhd Ps = w)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Q P \\<Longrightarrow>\n       P = LNil \\<or>\n       (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n       (\\<exists>v w Ps.\n           P = LCons v Ps \\<and>\n           v \\<in> V \\<and>\n           w \\<in> V \\<and>\n           v \\<rightarrow> w \\<and>\n           ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n           \\<not> lnull Ps \\<and> lhd Ps = w)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P \\<noteq> LNil;\n   \\<nexists>v. P = LCons v LNil \\<and> v \\<in> V\\<rbrakk>\n  \\<Longrightarrow> P = LNil \\<or>\n                    (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n                    (\\<exists>v w Ps.\n                        P = LCons v Ps \\<and>\n                        v \\<in> V \\<and>\n                        w \\<in> V \\<and>\n                        v \\<rightarrow> w \\<and>\n                        ((\\<exists>P. Ps = P \\<and> Q P) \\<or>\n                         valid_path Ps) \\<and>\n                        \\<not> lnull Ps \\<and> lhd Ps = w)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Q P \\<Longrightarrow>\n       P = LNil \\<or>\n       (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n       (\\<exists>v w Ps.\n           P = LCons v Ps \\<and>\n           v \\<in> V \\<and>\n           w \\<in> V \\<and>\n           v \\<rightarrow> w \\<and>\n           ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n           \\<not> lnull Ps \\<and> lhd Ps = w)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>P \\<noteq> LNil;\n   \\<nexists>v. P = LCons v LNil \\<and> v \\<in> V\\<rbrakk>\n  \\<Longrightarrow> P = LNil \\<or>\n                    (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n                    (\\<exists>v w Ps.\n                        P = LCons v Ps \\<and>\n                        v \\<in> V \\<and>\n                        w \\<in> V \\<and>\n                        v \\<rightarrow> w \\<and>\n                        ((\\<exists>P. Ps = P \\<and> Q P) \\<or>\n                         valid_path Ps) \\<and>\n                        \\<not> lnull Ps \\<and> lhd Ps = w)\n\ngoal (1 subgoal):\n 1. P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n    (\\<exists>v w Ps.\n        P = LCons v Ps \\<and>\n        v \\<in> V \\<and>\n        w \\<in> V \\<and>\n        v \\<rightarrow> w \\<and>\n        ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n        \\<not> lnull Ps \\<and> lhd Ps = w)", "by blast"], ["proof (state)\nthis:\n  P = LNil \\<or>\n  (\\<exists>v. P = LCons v LNil \\<and> v \\<in> V) \\<or>\n  (\\<exists>v w Ps.\n      P = LCons v Ps \\<and>\n      v \\<in> V \\<and>\n      w \\<in> V \\<and>\n      v \\<rightarrow> w \\<and>\n      ((\\<exists>P. Ps = P \\<and> Q P) \\<or> valid_path Ps) \\<and>\n      \\<not> lnull Ps \\<and> lhd Ps = w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_path_no_deadends:\n  \"\\<lbrakk> valid_path P; enat (Suc i) < llength P \\<rbrakk> \\<Longrightarrow> \\<not>deadend (P $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path P; enat (Suc i) < llength P\\<rbrakk>\n    \\<Longrightarrow> \\<not> deadend (P $ i)", "using valid_path_edges"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_path ?P; enat (Suc ?n) < llength ?P\\<rbrakk>\n  \\<Longrightarrow> ?P $ ?n \\<rightarrow> ?P $ Suc ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path P; enat (Suc i) < llength P\\<rbrakk>\n    \\<Longrightarrow> \\<not> deadend (P $ i)", "by blast"], ["", "lemma valid_path_ends_on_deadend:\n  \"\\<lbrakk> valid_path P; enat i < llength P; deadend (P $ i) \\<rbrakk> \\<Longrightarrow> enat (Suc i) = llength P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path P; enat i < llength P; deadend (P $ i)\\<rbrakk>\n    \\<Longrightarrow> enat (Suc i) = llength P", "using valid_path_no_deadends"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_path ?P; enat (Suc ?i) < llength ?P\\<rbrakk>\n  \\<Longrightarrow> \\<not> deadend (?P $ ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path P; enat i < llength P; deadend (P $ i)\\<rbrakk>\n    \\<Longrightarrow> enat (Suc i) = llength P", "by (metis enat_iless enat_ord_simps(2) neq_iff not_less_eq)"], ["", "lemma valid_path_prefix: \"\\<lbrakk> valid_path P; lprefix P' P \\<rbrakk> \\<Longrightarrow> valid_path P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path P; lprefix P' P\\<rbrakk>\n    \\<Longrightarrow> valid_path P'", "proof (coinduction arbitrary: P' P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v P' Pa.\n       \\<lbrakk>LCons v LNil = P'; valid_path Pa; lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\n 2. \\<And>v w P P' Pa.\n       \\<lbrakk>LCons v (LCons w P) = P'; valid_path Pa;\n        lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<rightarrow> w \\<and>\n                         ((\\<exists>P' Pa.\n                              LCons w P = P' \\<and>\n                              valid_path Pa \\<and> lprefix P' Pa) \\<or>\n                          valid_path (LCons w P))", "case (step v w P'' P' P)"], ["proof (state)\nthis:\n  LCons v (LCons w P'') = P'\n  valid_path P\n  lprefix P' P\n\ngoal (2 subgoals):\n 1. \\<And>v P' Pa.\n       \\<lbrakk>LCons v LNil = P'; valid_path Pa; lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\n 2. \\<And>v w P P' Pa.\n       \\<lbrakk>LCons v (LCons w P) = P'; valid_path Pa;\n        lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<rightarrow> w \\<and>\n                         ((\\<exists>P' Pa.\n                              LCons w P = P' \\<and>\n                              valid_path Pa \\<and> lprefix P' Pa) \\<or>\n                          valid_path (LCons w P))", "then"], ["proof (chain)\npicking this:\n  LCons v (LCons w P'') = P'\n  valid_path P\n  lprefix P' P", "obtain Ps where Ps: \"LCons v (LCons w Ps) = P\""], ["proof (prove)\nusing this:\n  LCons v (LCons w P'') = P'\n  valid_path P\n  lprefix P' P\n\ngoal (1 subgoal):\n 1. (\\<And>Ps.\n        LCons v (LCons w Ps) = P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis LCons_lprefix_conv)"], ["proof (state)\nthis:\n  LCons v (LCons w Ps) = P\n\ngoal (2 subgoals):\n 1. \\<And>v P' Pa.\n       \\<lbrakk>LCons v LNil = P'; valid_path Pa; lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\n 2. \\<And>v w P P' Pa.\n       \\<lbrakk>LCons v (LCons w P) = P'; valid_path Pa;\n        lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<rightarrow> w \\<and>\n                         ((\\<exists>P' Pa.\n                              LCons w P = P' \\<and>\n                              valid_path Pa \\<and> lprefix P' Pa) \\<or>\n                          valid_path (LCons w P))", "hence \"valid_path (LCons w Ps)\""], ["proof (prove)\nusing this:\n  LCons v (LCons w Ps) = P\n\ngoal (1 subgoal):\n 1. valid_path (LCons w Ps)", "using valid_path_ltl' step(2)"], ["proof (prove)\nusing this:\n  LCons v (LCons w Ps) = P\n  valid_path (LCons ?v ?Ps) \\<Longrightarrow> valid_path ?Ps\n  valid_path P\n\ngoal (1 subgoal):\n 1. valid_path (LCons w Ps)", "by blast"], ["proof (state)\nthis:\n  valid_path (LCons w Ps)\n\ngoal (2 subgoals):\n 1. \\<And>v P' Pa.\n       \\<lbrakk>LCons v LNil = P'; valid_path Pa; lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\n 2. \\<And>v w P P' Pa.\n       \\<lbrakk>LCons v (LCons w P) = P'; valid_path Pa;\n        lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<rightarrow> w \\<and>\n                         ((\\<exists>P' Pa.\n                              LCons w P = P' \\<and>\n                              valid_path Pa \\<and> lprefix P' Pa) \\<or>\n                          valid_path (LCons w P))", "moreover"], ["proof (state)\nthis:\n  valid_path (LCons w Ps)\n\ngoal (2 subgoals):\n 1. \\<And>v P' Pa.\n       \\<lbrakk>LCons v LNil = P'; valid_path Pa; lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\n 2. \\<And>v w P P' Pa.\n       \\<lbrakk>LCons v (LCons w P) = P'; valid_path Pa;\n        lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<rightarrow> w \\<and>\n                         ((\\<exists>P' Pa.\n                              LCons w P = P' \\<and>\n                              valid_path Pa \\<and> lprefix P' Pa) \\<or>\n                          valid_path (LCons w P))", "have \"lprefix (LCons w P'') (LCons w Ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (LCons w P'') (LCons w Ps)", "using Ps step(1,3)"], ["proof (prove)\nusing this:\n  LCons v (LCons w Ps) = P\n  LCons v (LCons w P'') = P'\n  lprefix P' P\n\ngoal (1 subgoal):\n 1. lprefix (LCons w P'') (LCons w Ps)", "by auto"], ["proof (state)\nthis:\n  lprefix (LCons w P'') (LCons w Ps)\n\ngoal (2 subgoals):\n 1. \\<And>v P' Pa.\n       \\<lbrakk>LCons v LNil = P'; valid_path Pa; lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\n 2. \\<And>v w P P' Pa.\n       \\<lbrakk>LCons v (LCons w P) = P'; valid_path Pa;\n        lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<rightarrow> w \\<and>\n                         ((\\<exists>P' Pa.\n                              LCons w P = P' \\<and>\n                              valid_path Pa \\<and> lprefix P' Pa) \\<or>\n                          valid_path (LCons w P))", "ultimately"], ["proof (chain)\npicking this:\n  valid_path (LCons w Ps)\n  lprefix (LCons w P'') (LCons w Ps)", "show ?case"], ["proof (prove)\nusing this:\n  valid_path (LCons w Ps)\n  lprefix (LCons w P'') (LCons w Ps)\n\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = P' \\<and> valid_path P \\<and> lprefix P' P) \\<or>\n     valid_path (LCons w P''))", "using Ps step(2) valid_path_edges'"], ["proof (prove)\nusing this:\n  valid_path (LCons w Ps)\n  lprefix (LCons w P'') (LCons w Ps)\n  LCons v (LCons w Ps) = P\n  valid_path P\n  valid_path (LCons ?v (LCons ?w ?Ps)) \\<Longrightarrow> ?v \\<rightarrow> ?w\n\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = P' \\<and> valid_path P \\<and> lprefix P' P) \\<or>\n     valid_path (LCons w P''))", "by blast"], ["proof (state)\nthis:\n  v \\<rightarrow> w \\<and>\n  ((\\<exists>P' P.\n       LCons w P'' = P' \\<and> valid_path P \\<and> lprefix P' P) \\<or>\n   valid_path (LCons w P''))\n\ngoal (1 subgoal):\n 1. \\<And>v P' Pa.\n       \\<lbrakk>LCons v LNil = P'; valid_path Pa; lprefix P' Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V", "qed (metis LCons_lprefix_conv valid_path_cons_simp)"], ["", "lemma valid_path_lappend:\n  assumes \"valid_path P\" \"valid_path P'\" \"\\<lbrakk> \\<not>lnull P; \\<not>lnull P' \\<rbrakk> \\<Longrightarrow> llast P\\<rightarrow>lhd P'\"\n  shows \"valid_path (lappend P P')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (lappend P P')", "proof (cases, cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>?P; ?P1\\<rbrakk> \\<Longrightarrow> valid_path (lappend P P')\n 2. \\<lbrakk>?P; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> valid_path (lappend P P')\n 3. \\<not> ?P \\<Longrightarrow> valid_path (lappend P P')", "assume \"\\<not>lnull P\" \"\\<not>lnull P'\""], ["proof (state)\nthis:\n  \\<not> lnull P\n  \\<not> lnull P'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>?P; ?P1\\<rbrakk> \\<Longrightarrow> valid_path (lappend P P')\n 2. \\<lbrakk>?P; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> valid_path (lappend P P')\n 3. \\<not> ?P \\<Longrightarrow> valid_path (lappend P P')", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lnull P\n  \\<not> lnull P'\n\ngoal (1 subgoal):\n 1. valid_path (lappend P P')", "using assms"], ["proof (prove)\nusing this:\n  \\<not> lnull P\n  \\<not> lnull P'\n  valid_path P\n  valid_path P'\n  \\<lbrakk>\\<not> lnull P; \\<not> lnull P'\\<rbrakk>\n  \\<Longrightarrow> llast P \\<rightarrow> lhd P'\n\ngoal (1 subgoal):\n 1. valid_path (lappend P P')", "proof (coinduction arbitrary: P' P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v P' Pa.\n       \\<lbrakk>LCons v LNil = lappend Pa P'; \\<not> lnull Pa;\n        \\<not> lnull P'; valid_path Pa; valid_path P';\n        \\<not> lnull Pa \\<longrightarrow>\n        \\<not> lnull P' \\<longrightarrow>\n        llast Pa \\<rightarrow> lhd P'\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\n 2. \\<And>v w P P' Pa.\n       \\<lbrakk>LCons v (LCons w P) = lappend Pa P'; \\<not> lnull Pa;\n        \\<not> lnull P'; valid_path Pa; valid_path P';\n        \\<not> lnull Pa \\<longrightarrow>\n        \\<not> lnull P' \\<longrightarrow>\n        llast Pa \\<rightarrow> lhd P'\\<rbrakk>\n       \\<Longrightarrow> v \\<rightarrow> w \\<and>\n                         ((\\<exists>P' Pa.\n                              LCons w P = lappend Pa P' \\<and>\n                              \\<not> lnull Pa \\<and>\n                              \\<not> lnull P' \\<and>\n                              valid_path Pa \\<and>\n                              valid_path P' \\<and>\n                              (\\<not> lnull Pa \\<longrightarrow>\n                               \\<not> lnull P' \\<longrightarrow>\n                               llast Pa \\<rightarrow> lhd P')) \\<or>\n                          valid_path (LCons w P))", "case (step v w P'' P' P)"], ["proof (state)\nthis:\n  LCons v (LCons w P'') = lappend P P'\n  \\<not> lnull P\n  \\<not> lnull P'\n  valid_path P\n  valid_path P'\n  \\<not> lnull P \\<longrightarrow>\n  \\<not> lnull P' \\<longrightarrow> llast P \\<rightarrow> lhd P'\n\ngoal (2 subgoals):\n 1. \\<And>v P' Pa.\n       \\<lbrakk>LCons v LNil = lappend Pa P'; \\<not> lnull Pa;\n        \\<not> lnull P'; valid_path Pa; valid_path P';\n        \\<not> lnull Pa \\<longrightarrow>\n        \\<not> lnull P' \\<longrightarrow>\n        llast Pa \\<rightarrow> lhd P'\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\n 2. \\<And>v w P P' Pa.\n       \\<lbrakk>LCons v (LCons w P) = lappend Pa P'; \\<not> lnull Pa;\n        \\<not> lnull P'; valid_path Pa; valid_path P';\n        \\<not> lnull Pa \\<longrightarrow>\n        \\<not> lnull P' \\<longrightarrow>\n        llast Pa \\<rightarrow> lhd P'\\<rbrakk>\n       \\<Longrightarrow> v \\<rightarrow> w \\<and>\n                         ((\\<exists>P' Pa.\n                              LCons w P = lappend Pa P' \\<and>\n                              \\<not> lnull Pa \\<and>\n                              \\<not> lnull P' \\<and>\n                              valid_path Pa \\<and>\n                              valid_path P' \\<and>\n                              (\\<not> lnull Pa \\<longrightarrow>\n                               \\<not> lnull P' \\<longrightarrow>\n                               llast Pa \\<rightarrow> lhd P')) \\<or>\n                          valid_path (LCons w P))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))\n 2. \\<not> ?P \\<Longrightarrow>\n    v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "assume \"lnull (ltl P)\""], ["proof (state)\nthis:\n  lnull (ltl P)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))\n 2. \\<not> ?P \\<Longrightarrow>\n    v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "thus ?case"], ["proof (prove)\nusing this:\n  lnull (ltl P)\n\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "using step(1,2,3,5,6)"], ["proof (prove)\nusing this:\n  lnull (ltl P)\n  LCons v (LCons w P'') = lappend P P'\n  \\<not> lnull P\n  \\<not> lnull P'\n  valid_path P'\n  \\<not> lnull P \\<longrightarrow>\n  \\<not> lnull P' \\<longrightarrow> llast P \\<rightarrow> lhd P'\n\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "by (metis lhd_LCons lhd_LCons_ltl lhd_lappend llast_singleton\n                  llist.collapse(1) ltl_lappend ltl_simps(2))"], ["proof (state)\nthis:\n  v \\<rightarrow> w \\<and>\n  ((\\<exists>P' P.\n       LCons w P'' = lappend P P' \\<and>\n       \\<not> lnull P \\<and>\n       \\<not> lnull P' \\<and>\n       valid_path P \\<and>\n       valid_path P' \\<and>\n       (\\<not> lnull P \\<longrightarrow>\n        \\<not> lnull P' \\<longrightarrow>\n        llast P \\<rightarrow> lhd P')) \\<or>\n   valid_path (LCons w P''))\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl P) \\<Longrightarrow>\n    v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl P) \\<Longrightarrow>\n    v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "assume \"\\<not>lnull (ltl P)\""], ["proof (state)\nthis:\n  \\<not> lnull (ltl P)\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl P) \\<Longrightarrow>\n    v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "moreover"], ["proof (state)\nthis:\n  \\<not> lnull (ltl P)\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl P) \\<Longrightarrow>\n    v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "have \"ltl (lappend P P') = lappend (ltl P) P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (lappend P P') = lappend (ltl P) P'", "using step(2)"], ["proof (prove)\nusing this:\n  \\<not> lnull P\n\ngoal (1 subgoal):\n 1. ltl (lappend P P') = lappend (ltl P) P'", "by simp"], ["proof (state)\nthis:\n  ltl (lappend P P') = lappend (ltl P) P'\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl P) \\<Longrightarrow>\n    v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> lnull (ltl P)\n  ltl (lappend P P') = lappend (ltl P) P'", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> lnull (ltl P)\n  ltl (lappend P P') = lappend (ltl P) P'\n\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "using step"], ["proof (prove)\nusing this:\n  \\<not> lnull (ltl P)\n  ltl (lappend P P') = lappend (ltl P) P'\n  LCons v (LCons w P'') = lappend P P'\n  \\<not> lnull P\n  \\<not> lnull P'\n  valid_path P\n  valid_path P'\n  \\<not> lnull P \\<longrightarrow>\n  \\<not> lnull P' \\<longrightarrow> llast P \\<rightarrow> lhd P'\n\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<and>\n    ((\\<exists>P' P.\n         LCons w P'' = lappend P P' \\<and>\n         \\<not> lnull P \\<and>\n         \\<not> lnull P' \\<and>\n         valid_path P \\<and>\n         valid_path P' \\<and>\n         (\\<not> lnull P \\<longrightarrow>\n          \\<not> lnull P' \\<longrightarrow>\n          llast P \\<rightarrow> lhd P')) \\<or>\n     valid_path (LCons w P''))", "by (metis (no_types, lifting)\n            lhd_LCons lhd_LCons_ltl lhd_lappend llast_LCons ltl_simps(2)\n            valid_path_edges' valid_path_ltl)"], ["proof (state)\nthis:\n  v \\<rightarrow> w \\<and>\n  ((\\<exists>P' P.\n       LCons w P'' = lappend P P' \\<and>\n       \\<not> lnull P \\<and>\n       \\<not> lnull P' \\<and>\n       valid_path P \\<and>\n       valid_path P' \\<and>\n       (\\<not> lnull P \\<longrightarrow>\n        \\<not> lnull P' \\<longrightarrow>\n        llast P \\<rightarrow> lhd P')) \\<or>\n   valid_path (LCons w P''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<rightarrow> w \\<and>\n  ((\\<exists>P' P.\n       LCons w P'' = lappend P P' \\<and>\n       \\<not> lnull P \\<and>\n       \\<not> lnull P' \\<and>\n       valid_path P \\<and>\n       valid_path P' \\<and>\n       (\\<not> lnull P \\<longrightarrow>\n        \\<not> lnull P' \\<longrightarrow>\n        llast P \\<rightarrow> lhd P')) \\<or>\n   valid_path (LCons w P''))\n\ngoal (1 subgoal):\n 1. \\<And>v P' Pa.\n       \\<lbrakk>LCons v LNil = lappend Pa P'; \\<not> lnull Pa;\n        \\<not> lnull P'; valid_path Pa; valid_path P';\n        \\<not> lnull Pa \\<longrightarrow>\n        \\<not> lnull P' \\<longrightarrow>\n        llast Pa \\<rightarrow> lhd P'\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V", "qed (metis llist.disc(1) lnull_lappend ltl_lappend ltl_simps(2))"], ["proof (state)\nthis:\n  valid_path (lappend P P')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lnull P; \\<not> \\<not> lnull P'\\<rbrakk>\n    \\<Longrightarrow> valid_path (lappend P P')\n 2. \\<not> \\<not> lnull P \\<Longrightarrow> valid_path (lappend P P')", "qed (simp_all add: assms(1,2) lappend_lnull1 lappend_lnull2)"], ["", "text \\<open>A valid path is still valid in a supergame.\\<close>"], ["", "lemma valid_path_supergame:\n  assumes \"valid_path P\" and G': \"Digraph G'\" \"V \\<subseteq> V\\<^bsub>G'\\<^esub>\" \"E \\<subseteq> E\\<^bsub>G'\\<^esub>\"\n  shows \"Digraph.valid_path G' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph.valid_path G' P", "using \\<open>valid_path P\\<close>"], ["proof (prove)\nusing this:\n  valid_path P\n\ngoal (1 subgoal):\n 1. Digraph.valid_path G' P", "proof (coinduction arbitrary: P\n  rule: Digraph.valid_path_coinduct[OF G'(1), case_names base step])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v Pa.\n       \\<lbrakk>LCons v LNil = Pa; valid_path Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\\<^bsub>G'\\<^esub>\n 2. \\<And>v w P Pa.\n       \\<lbrakk>LCons v (LCons w P) = Pa; valid_path Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<rightarrow>\\<^bsub>G'\\<^esub> w \\<and>\n                         ((\\<exists>Pa.\n                              LCons w P = Pa \\<and> valid_path Pa) \\<or>\n                          Digraph.valid_path G' (LCons w P))", "case base"], ["proof (state)\nthis:\n  LCons v LNil = Pa\n  valid_path Pa\n\ngoal (2 subgoals):\n 1. \\<And>v Pa.\n       \\<lbrakk>LCons v LNil = Pa; valid_path Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\\<^bsub>G'\\<^esub>\n 2. \\<And>v w P Pa.\n       \\<lbrakk>LCons v (LCons w P) = Pa; valid_path Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<rightarrow>\\<^bsub>G'\\<^esub> w \\<and>\n                         ((\\<exists>Pa.\n                              LCons w P = Pa \\<and> valid_path Pa) \\<or>\n                          Digraph.valid_path G' (LCons w P))", "thus ?case"], ["proof (prove)\nusing this:\n  LCons v LNil = Pa\n  valid_path Pa\n\ngoal (1 subgoal):\n 1. v \\<in> V\\<^bsub>G'\\<^esub>", "using G'(2) valid_path_cons_simp"], ["proof (prove)\nusing this:\n  LCons v LNil = Pa\n  valid_path Pa\n  V \\<subseteq> V\\<^bsub>G'\\<^esub>\n  valid_path (LCons ?x ?xs) =\n  (?xs = LNil \\<and> ?x \\<in> V \\<or>\n   ?x \\<in> V \\<and>\n   lhd ?xs \\<in> V \\<and>\n   ?x \\<rightarrow> lhd ?xs \\<and> valid_path ?xs \\<and> \\<not> lnull ?xs)\n\ngoal (1 subgoal):\n 1. v \\<in> V\\<^bsub>G'\\<^esub>", "by auto"], ["proof (state)\nthis:\n  v \\<in> V\\<^bsub>G'\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>v w P Pa.\n       \\<lbrakk>LCons v (LCons w P) = Pa; valid_path Pa\\<rbrakk>\n       \\<Longrightarrow> v \\<rightarrow>\\<^bsub>G'\\<^esub> w \\<and>\n                         ((\\<exists>Pa.\n                              LCons w P = Pa \\<and> valid_path Pa) \\<or>\n                          Digraph.valid_path G' (LCons w P))", "qed (meson G'(3) subset_eq valid_path_edges' valid_path_ltl')"], ["", "subsection \\<open>Maximal Paths\\<close>"], ["", "text \\<open>\n  We say that a path is \\emph{maximal} if it is empty or if it ends in a deadend.\n\\<close>"], ["", "coinductive maximal_path where\n  maximal_path_base: \"maximal_path LNil\"\n| maximal_path_base': \"deadend v \\<Longrightarrow> maximal_path (LCons v LNil)\"\n| maximal_path_cons: \"\\<not>lnull Ps \\<Longrightarrow> maximal_path Ps \\<Longrightarrow> maximal_path (LCons v Ps)\""], ["", "lemma maximal_no_deadend: \"maximal_path (LCons v Ps) \\<Longrightarrow> \\<not>deadend v \\<Longrightarrow> \\<not>lnull Ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maximal_path (LCons v Ps); \\<not> deadend v\\<rbrakk>\n    \\<Longrightarrow> \\<not> lnull Ps", "by (metis lhd_LCons llist.distinct(1) ltl_simps(2) maximal_path.simps)"], ["", "lemma maximal_ltl: \"maximal_path P \\<Longrightarrow> maximal_path (ltl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_path P \\<Longrightarrow> maximal_path (ltl P)", "by (metis ltl_simps(1) ltl_simps(2) maximal_path.simps)"], ["", "lemma maximal_drop: \"maximal_path P \\<Longrightarrow> maximal_path (ldropn n P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_path P \\<Longrightarrow> maximal_path (ldropn n P)", "by (simp add: maximal_ltl ltl_ldrop)"], ["", "lemma maximal_path_lappend:\n  assumes \"\\<not>lnull P'\" \"maximal_path P'\"\n  shows \"maximal_path (lappend P P')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_path (lappend P P')", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> maximal_path (lappend P P')\n 2. \\<not> ?P \\<Longrightarrow> maximal_path (lappend P P')", "assume \"\\<not>lnull P\""], ["proof (state)\nthis:\n  \\<not> lnull P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> maximal_path (lappend P P')\n 2. \\<not> ?P \\<Longrightarrow> maximal_path (lappend P P')", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lnull P\n\ngoal (1 subgoal):\n 1. maximal_path (lappend P P')", "using assms"], ["proof (prove)\nusing this:\n  \\<not> lnull P\n  \\<not> lnull P'\n  maximal_path P'\n\ngoal (1 subgoal):\n 1. maximal_path (lappend P P')", "proof (coinduction arbitrary: P' P rule: maximal_path.coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P' P.\n       \\<lbrakk>\\<not> lnull P; \\<not> lnull P'; maximal_path P'\\<rbrakk>\n       \\<Longrightarrow> lappend P P' = LNil \\<or>\n                         (\\<exists>v.\n                             lappend P P' = LCons v LNil \\<and>\n                             deadend v) \\<or>\n                         (\\<exists>Ps v.\n                             lappend P P' = LCons v Ps \\<and>\n                             \\<not> lnull Ps \\<and>\n                             ((\\<exists>P' P.\n                                  Ps = lappend P P' \\<and>\n                                  \\<not> lnull P \\<and>\n                                  \\<not> lnull P' \\<and>\n                                  maximal_path P') \\<or>\n                              maximal_path Ps))", "case (maximal_path P' P)"], ["proof (state)\nthis:\n  \\<not> lnull P\n  \\<not> lnull P'\n  maximal_path P'\n\ngoal (1 subgoal):\n 1. \\<And>P' P.\n       \\<lbrakk>\\<not> lnull P; \\<not> lnull P'; maximal_path P'\\<rbrakk>\n       \\<Longrightarrow> lappend P P' = LNil \\<or>\n                         (\\<exists>v.\n                             lappend P P' = LCons v LNil \\<and>\n                             deadend v) \\<or>\n                         (\\<exists>Ps v.\n                             lappend P P' = LCons v Ps \\<and>\n                             \\<not> lnull Ps \\<and>\n                             ((\\<exists>P' P.\n                                  Ps = lappend P P' \\<and>\n                                  \\<not> lnull P \\<and>\n                                  \\<not> lnull P' \\<and>\n                                  maximal_path P') \\<or>\n                              maximal_path Ps))", "let ?P = \"lappend P P'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P' P.\n       \\<lbrakk>\\<not> lnull P; \\<not> lnull P'; maximal_path P'\\<rbrakk>\n       \\<Longrightarrow> lappend P P' = LNil \\<or>\n                         (\\<exists>v.\n                             lappend P P' = LCons v LNil \\<and>\n                             deadend v) \\<or>\n                         (\\<exists>Ps v.\n                             lappend P P' = LCons v Ps \\<and>\n                             \\<not> lnull Ps \\<and>\n                             ((\\<exists>P' P.\n                                  Ps = lappend P P' \\<and>\n                                  \\<not> lnull P \\<and>\n                                  \\<not> lnull P' \\<and>\n                                  maximal_path P') \\<or>\n                              maximal_path Ps))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))", "proof (cases \"?P = LNil \\<or> (\\<exists>v. ?P = LCons v LNil \\<and> deadend v)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lappend P P' = LNil \\<or>\n    (\\<exists>v.\n        lappend P P' = LCons v LNil \\<and> deadend v) \\<Longrightarrow>\n    lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))\n 2. \\<not> (lappend P P' = LNil \\<or>\n            (\\<exists>v.\n                lappend P P' = LCons v LNil \\<and>\n                deadend v)) \\<Longrightarrow>\n    lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))", "case False"], ["proof (state)\nthis:\n  \\<not> (lappend P P' = LNil \\<or>\n          (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v))\n\ngoal (2 subgoals):\n 1. lappend P P' = LNil \\<or>\n    (\\<exists>v.\n        lappend P P' = LCons v LNil \\<and> deadend v) \\<Longrightarrow>\n    lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))\n 2. \\<not> (lappend P P' = LNil \\<or>\n            (\\<exists>v.\n                lappend P P' = LCons v LNil \\<and>\n                deadend v)) \\<Longrightarrow>\n    lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))", "then"], ["proof (chain)\npicking this:\n  \\<not> (lappend P P' = LNil \\<or>\n          (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v))", "obtain Ps v where P: \"?P = LCons v Ps\""], ["proof (prove)\nusing this:\n  \\<not> (lappend P P' = LNil \\<or>\n          (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v))\n\ngoal (1 subgoal):\n 1. (\\<And>v Ps.\n        lappend P P' = LCons v Ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson neq_LNil_conv)"], ["proof (state)\nthis:\n  lappend P P' = LCons v Ps\n\ngoal (2 subgoals):\n 1. lappend P P' = LNil \\<or>\n    (\\<exists>v.\n        lappend P P' = LCons v LNil \\<and> deadend v) \\<Longrightarrow>\n    lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))\n 2. \\<not> (lappend P P' = LNil \\<or>\n            (\\<exists>v.\n                lappend P P' = LCons v LNil \\<and>\n                deadend v)) \\<Longrightarrow>\n    lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))", "hence \"Ps = lappend (ltl P) P'\""], ["proof (prove)\nusing this:\n  lappend P P' = LCons v Ps\n\ngoal (1 subgoal):\n 1. Ps = lappend (ltl P) P'", "by (simp add: lappend_ltl maximal_path(1))"], ["proof (state)\nthis:\n  Ps = lappend (ltl P) P'\n\ngoal (2 subgoals):\n 1. lappend P P' = LNil \\<or>\n    (\\<exists>v.\n        lappend P P' = LCons v LNil \\<and> deadend v) \\<Longrightarrow>\n    lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))\n 2. \\<not> (lappend P P' = LNil \\<or>\n            (\\<exists>v.\n                lappend P P' = LCons v LNil \\<and>\n                deadend v)) \\<Longrightarrow>\n    lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))", "hence \"\\<exists>Ps1 P'. Ps = lappend Ps1 P' \\<and> \\<not>lnull P' \\<and> maximal_path P'\""], ["proof (prove)\nusing this:\n  Ps = lappend (ltl P) P'\n\ngoal (1 subgoal):\n 1. \\<exists>Ps1 P'.\n       Ps = lappend Ps1 P' \\<and> \\<not> lnull P' \\<and> maximal_path P'", "using maximal_path(2) maximal_path(3)"], ["proof (prove)\nusing this:\n  Ps = lappend (ltl P) P'\n  \\<not> lnull P'\n  maximal_path P'\n\ngoal (1 subgoal):\n 1. \\<exists>Ps1 P'.\n       Ps = lappend Ps1 P' \\<and> \\<not> lnull P' \\<and> maximal_path P'", "by auto"], ["proof (state)\nthis:\n  \\<exists>Ps1 P'.\n     Ps = lappend Ps1 P' \\<and> \\<not> lnull P' \\<and> maximal_path P'\n\ngoal (2 subgoals):\n 1. lappend P P' = LNil \\<or>\n    (\\<exists>v.\n        lappend P P' = LCons v LNil \\<and> deadend v) \\<Longrightarrow>\n    lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))\n 2. \\<not> (lappend P P' = LNil \\<or>\n            (\\<exists>v.\n                lappend P P' = LCons v LNil \\<and>\n                deadend v)) \\<Longrightarrow>\n    lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>Ps1 P'.\n     Ps = lappend Ps1 P' \\<and> \\<not> lnull P' \\<and> maximal_path P'\n\ngoal (1 subgoal):\n 1. lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))", "using P lappend_lnull1"], ["proof (prove)\nusing this:\n  \\<exists>Ps1 P'.\n     Ps = lappend Ps1 P' \\<and> \\<not> lnull P' \\<and> maximal_path P'\n  lappend P P' = LCons v Ps\n  lnull ?xs \\<Longrightarrow> lappend ?xs ?ys = ?ys\n\ngoal (1 subgoal):\n 1. lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))", "by fastforce"], ["proof (state)\nthis:\n  lappend P P' = LNil \\<or>\n  (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n  (\\<exists>Ps v.\n      lappend P P' = LCons v Ps \\<and>\n      \\<not> lnull Ps \\<and>\n      ((\\<exists>P' P.\n           Ps = lappend P P' \\<and>\n           \\<not> lnull P \\<and>\n           \\<not> lnull P' \\<and> maximal_path P') \\<or>\n       maximal_path Ps))\n\ngoal (1 subgoal):\n 1. lappend P P' = LNil \\<or>\n    (\\<exists>v.\n        lappend P P' = LCons v LNil \\<and> deadend v) \\<Longrightarrow>\n    lappend P P' = LNil \\<or>\n    (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        lappend P P' = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P' P.\n             Ps = lappend P P' \\<and>\n             \\<not> lnull P \\<and>\n             \\<not> lnull P' \\<and> maximal_path P') \\<or>\n         maximal_path Ps))", "qed blast"], ["proof (state)\nthis:\n  lappend P P' = LNil \\<or>\n  (\\<exists>v. lappend P P' = LCons v LNil \\<and> deadend v) \\<or>\n  (\\<exists>Ps v.\n      lappend P P' = LCons v Ps \\<and>\n      \\<not> lnull Ps \\<and>\n      ((\\<exists>P' P.\n           Ps = lappend P P' \\<and>\n           \\<not> lnull P \\<and>\n           \\<not> lnull P' \\<and> maximal_path P') \\<or>\n       maximal_path Ps))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  maximal_path (lappend P P')\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> lnull P \\<Longrightarrow> maximal_path (lappend P P')", "qed (simp add: assms(2) lappend_lnull1[of P P'])"], ["", "lemma maximal_ends_on_deadend:\n  assumes \"maximal_path P\" \"lfinite P\" \"\\<not>lnull P\"\n  shows \"deadend (llast P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deadend (llast P)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. deadend (llast P)", "from \\<open>lfinite P\\<close> \\<open>\\<not>lnull P\\<close>"], ["proof (chain)\npicking this:\n  lfinite P\n  \\<not> lnull P", "obtain n where n: \"llength P = enat (Suc n)\""], ["proof (prove)\nusing this:\n  lfinite P\n  \\<not> lnull P\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        llength P = enat (Suc n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis enat_ord_simps(2) gr0_implies_Suc lfinite_llength_enat lnull_0_llength)"], ["proof (state)\nthis:\n  llength P = enat (Suc n)\n\ngoal (1 subgoal):\n 1. deadend (llast P)", "define P' where \"P' = ldropn n P\""], ["proof (state)\nthis:\n  P' = ldropn n P\n\ngoal (1 subgoal):\n 1. deadend (llast P)", "hence \"maximal_path P'\""], ["proof (prove)\nusing this:\n  P' = ldropn n P\n\ngoal (1 subgoal):\n 1. maximal_path P'", "using assms(1) maximal_drop"], ["proof (prove)\nusing this:\n  P' = ldropn n P\n  maximal_path P\n  maximal_path ?P \\<Longrightarrow> maximal_path (ldropn ?n ?P)\n\ngoal (1 subgoal):\n 1. maximal_path P'", "by blast"], ["proof (state)\nthis:\n  maximal_path P'\n\ngoal (1 subgoal):\n 1. deadend (llast P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  maximal_path P'\n\ngoal (1 subgoal):\n 1. deadend (llast P)", "proof (cases rule: maximal_path.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. P' = LNil \\<Longrightarrow> deadend (llast P)\n 2. \\<And>v.\n       \\<lbrakk>P' = LCons v LNil; deadend v\\<rbrakk>\n       \\<Longrightarrow> deadend (llast P)\n 3. \\<And>Ps v.\n       \\<lbrakk>P' = LCons v Ps; \\<not> lnull Ps; maximal_path Ps\\<rbrakk>\n       \\<Longrightarrow> deadend (llast P)", "case (maximal_path_base' v)"], ["proof (state)\nthis:\n  P' = LCons v LNil\n  deadend v\n\ngoal (3 subgoals):\n 1. P' = LNil \\<Longrightarrow> deadend (llast P)\n 2. \\<And>v.\n       \\<lbrakk>P' = LCons v LNil; deadend v\\<rbrakk>\n       \\<Longrightarrow> deadend (llast P)\n 3. \\<And>Ps v.\n       \\<lbrakk>P' = LCons v Ps; \\<not> lnull Ps; maximal_path Ps\\<rbrakk>\n       \\<Longrightarrow> deadend (llast P)", "hence \"deadend (llast P')\""], ["proof (prove)\nusing this:\n  P' = LCons v LNil\n  deadend v\n\ngoal (1 subgoal):\n 1. deadend (llast P')", "unfolding P'_def"], ["proof (prove)\nusing this:\n  ldropn n P = LCons v LNil\n  deadend v\n\ngoal (1 subgoal):\n 1. deadend (llast (ldropn n P))", "by simp"], ["proof (state)\nthis:\n  deadend (llast P')\n\ngoal (3 subgoals):\n 1. P' = LNil \\<Longrightarrow> deadend (llast P)\n 2. \\<And>v.\n       \\<lbrakk>P' = LCons v LNil; deadend v\\<rbrakk>\n       \\<Longrightarrow> deadend (llast P)\n 3. \\<And>Ps v.\n       \\<lbrakk>P' = LCons v Ps; \\<not> lnull Ps; maximal_path Ps\\<rbrakk>\n       \\<Longrightarrow> deadend (llast P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  deadend (llast P')\n\ngoal (1 subgoal):\n 1. deadend (llast P)", "unfolding P'_def"], ["proof (prove)\nusing this:\n  deadend (llast (ldropn n P))\n\ngoal (1 subgoal):\n 1. deadend (llast P)", "using llast_ldropn[of n P] n"], ["proof (prove)\nusing this:\n  deadend (llast (ldropn n P))\n  enat n < llength P \\<Longrightarrow> llast (ldropn n P) = llast P\n  llength P = enat (Suc n)\n\ngoal (1 subgoal):\n 1. deadend (llast P)", "by (metis P'_def ldropn_eq_LConsD local.maximal_path_base'(1))"], ["proof (state)\nthis:\n  deadend (llast P)\n\ngoal (2 subgoals):\n 1. P' = LNil \\<Longrightarrow> deadend (llast P)\n 2. \\<And>Ps v.\n       \\<lbrakk>P' = LCons v Ps; \\<not> lnull Ps; maximal_path Ps\\<rbrakk>\n       \\<Longrightarrow> deadend (llast P)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. P' = LNil \\<Longrightarrow> deadend (llast P)\n 2. \\<And>Ps v.\n       \\<lbrakk>P' = LCons v Ps; \\<not> lnull Ps; maximal_path Ps\\<rbrakk>\n       \\<Longrightarrow> deadend (llast P)", "case (maximal_path_cons P'' v)"], ["proof (state)\nthis:\n  P' = LCons v P''\n  \\<not> lnull P''\n  maximal_path P''\n\ngoal (2 subgoals):\n 1. P' = LNil \\<Longrightarrow> deadend (llast P)\n 2. \\<And>Ps v.\n       \\<lbrakk>P' = LCons v Ps; \\<not> lnull Ps; maximal_path Ps\\<rbrakk>\n       \\<Longrightarrow> deadend (llast P)", "hence \"ldropn (Suc n) P = P''\""], ["proof (prove)\nusing this:\n  P' = LCons v P''\n  \\<not> lnull P''\n  maximal_path P''\n\ngoal (1 subgoal):\n 1. ldropn (Suc n) P = P''", "unfolding P'_def"], ["proof (prove)\nusing this:\n  ldropn n P = LCons v P''\n  \\<not> lnull P''\n  maximal_path P''\n\ngoal (1 subgoal):\n 1. ldropn (Suc n) P = P''", "by (metis ldrop_eSuc_ltl ltl_ldropn ltl_simps(2))"], ["proof (state)\nthis:\n  ldropn (Suc n) P = P''\n\ngoal (2 subgoals):\n 1. P' = LNil \\<Longrightarrow> deadend (llast P)\n 2. \\<And>Ps v.\n       \\<lbrakk>P' = LCons v Ps; \\<not> lnull Ps; maximal_path Ps\\<rbrakk>\n       \\<Longrightarrow> deadend (llast P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ldropn (Suc n) P = P''\n\ngoal (1 subgoal):\n 1. deadend (llast P)", "using n maximal_path_cons(2)"], ["proof (prove)\nusing this:\n  ldropn (Suc n) P = P''\n  llength P = enat (Suc n)\n  \\<not> lnull P''\n\ngoal (1 subgoal):\n 1. deadend (llast P)", "by auto"], ["proof (state)\nthis:\n  deadend (llast P)\n\ngoal (1 subgoal):\n 1. P' = LNil \\<Longrightarrow> deadend (llast P)", "qed (simp add: P'_def n ldropn_eq_LNil)"], ["proof (state)\nthis:\n  deadend (llast P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maximal_ends_on_deadend': \"\\<lbrakk> lfinite P; deadend (llast P) \\<rbrakk> \\<Longrightarrow> maximal_path P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lfinite P; deadend (llast P)\\<rbrakk>\n    \\<Longrightarrow> maximal_path P", "proof (coinduction arbitrary: P rule: maximal_path.coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>lfinite P; deadend (llast P)\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and> deadend v) \\<or>\n                         (\\<exists>Ps v.\n                             P = LCons v Ps \\<and>\n                             \\<not> lnull Ps \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  lfinite P \\<and> deadend (llast P)) \\<or>\n                              maximal_path Ps))", "case (maximal_path P)"], ["proof (state)\nthis:\n  lfinite P\n  deadend (llast P)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>lfinite P; deadend (llast P)\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and> deadend v) \\<or>\n                         (\\<exists>Ps v.\n                             P = LCons v Ps \\<and>\n                             \\<not> lnull Ps \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  lfinite P \\<and> deadend (llast P)) \\<or>\n                              maximal_path Ps))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))\n 2. \\<not> ?P \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))", "assume \"P \\<noteq> LNil\""], ["proof (state)\nthis:\n  P \\<noteq> LNil\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))\n 2. \\<not> ?P \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))", "then"], ["proof (chain)\npicking this:\n  P \\<noteq> LNil", "obtain v P' where P': \"P = LCons v P'\""], ["proof (prove)\nusing this:\n  P \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. (\\<And>v P'. P = LCons v P' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson neq_LNil_conv)"], ["proof (state)\nthis:\n  P = LCons v P'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))\n 2. \\<not> ?P \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))\n 2. \\<not> ?P \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))", "assume \"P' = LNil\""], ["proof (state)\nthis:\n  P' = LNil\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))\n 2. \\<not> ?P \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))", "thus ?thesis"], ["proof (prove)\nusing this:\n  P' = LNil\n\ngoal (1 subgoal):\n 1. P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))", "using P' maximal_path(2)"], ["proof (prove)\nusing this:\n  P' = LNil\n  P = LCons v P'\n  deadend (llast P)\n\ngoal (1 subgoal):\n 1. P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))", "by auto"], ["proof (state)\nthis:\n  P = LNil \\<or>\n  (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n  (\\<exists>Ps v.\n      P = LCons v Ps \\<and>\n      \\<not> lnull Ps \\<and>\n      ((\\<exists>P. Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n       maximal_path Ps))\n\ngoal (1 subgoal):\n 1. P' \\<noteq> LNil \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))", "qed (metis P' lfinite_LCons llast_LCons llist.collapse(1) maximal_path(1,2))"], ["proof (state)\nthis:\n  P = LNil \\<or>\n  (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n  (\\<exists>Ps v.\n      P = LCons v Ps \\<and>\n      \\<not> lnull Ps \\<and>\n      ((\\<exists>P. Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n       maximal_path Ps))\n\ngoal (1 subgoal):\n 1. \\<not> P \\<noteq> LNil \\<Longrightarrow>\n    P = LNil \\<or>\n    (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n    (\\<exists>Ps v.\n        P = LCons v Ps \\<and>\n        \\<not> lnull Ps \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n         maximal_path Ps))", "qed simp"], ["proof (state)\nthis:\n  P = LNil \\<or>\n  (\\<exists>v. P = LCons v LNil \\<and> deadend v) \\<or>\n  (\\<exists>Ps v.\n      P = LCons v Ps \\<and>\n      \\<not> lnull Ps \\<and>\n      ((\\<exists>P. Ps = P \\<and> lfinite P \\<and> deadend (llast P)) \\<or>\n       maximal_path Ps))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_path_is_maximal: \"\\<lbrakk> valid_path P; \\<not>lfinite P \\<rbrakk> \\<Longrightarrow> maximal_path P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path P; \\<not> lfinite P\\<rbrakk>\n    \\<Longrightarrow> maximal_path P", "by (coinduction arbitrary: P rule: maximal_path.coinduct)\n     (cases rule: valid_path.cases, auto)"], ["", "end \\<comment> \\<open>locale Digraph\\<close>"], ["", "subsection \\<open>Parity Games\\<close>"], ["", "text \\<open>Parity games are games played by two players, called \\Even and \\Odd.\\<close>"], ["", "datatype Player = Even | Odd"], ["", "abbreviation \"other_player p \\<equiv> (if p = Even then Odd else Even)\""], ["", "notation other_player (\"(_**)\" [1000] 1000)"], ["", "lemma other_other_player [simp]: \"p**** = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p**** = p", "using Player.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = Even \\<Longrightarrow> ?P;\n   ?y = Odd \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. p**** = p", "by auto"], ["", "text \\<open>\n  A parity game is tuple $(V,E,V_0,\\omega)$, where $(V,E)$ is a graph, $V_0 \\subseteq V$\n  and @{term \\<omega>} is a function from $V \\to \\mathbb{N}$ with finite image.\n\\<close>"], ["", "record 'a ParityGame = \"'a Graph\" +\n  player0 :: \"'a set\" (\"V0\\<index>\")\n  priority :: \"'a \\<Rightarrow> nat\" (\"\\<omega>\\<index>\")"], ["", "locale ParityGame = Digraph G for G :: \"('a, 'b) ParityGame_scheme\" (structure) +\n  assumes valid_player0_set: \"V0 \\<subseteq> V\"\n    and priorities_finite: \"finite (\\<omega> ` V)\"\nbegin"], ["", "text \\<open>\\<open>VV p\\<close> is the set of nodes belonging to player @{term p}.\\<close>"], ["", "abbreviation VV :: \"Player \\<Rightarrow> 'a set\" where \"VV p \\<equiv> (if p = Even then V0 else V - V0)\""], ["", "lemma VVp_to_V [intro]: \"v \\<in> VV p \\<Longrightarrow> v \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> VV p \\<Longrightarrow> v \\<in> V", "using valid_player0_set"], ["proof (prove)\nusing this:\n  V0 \\<subseteq> V\n\ngoal (1 subgoal):\n 1. v \\<in> VV p \\<Longrightarrow> v \\<in> V", "by (cases p) auto"], ["", "lemma VV_impl1: \"v \\<in> VV p \\<Longrightarrow> v \\<notin> VV p**\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> VV p \\<Longrightarrow> v \\<notin> VV p**", "by auto"], ["", "lemma VV_impl2: \"v \\<in> VV p** \\<Longrightarrow> v \\<notin> VV p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> VV p** \\<Longrightarrow> v \\<notin> VV p", "by auto"], ["", "lemma VV_equivalence [iff]: \"v \\<in> V \\<Longrightarrow> v \\<notin> VV p \\<longleftrightarrow> v \\<in> VV p**\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V \\<Longrightarrow> (v \\<notin> VV p) = (v \\<in> VV p**)", "by auto"], ["", "lemma VV_cases [consumes 1]: \"\\<lbrakk> v \\<in> V ; v \\<in> VV p \\<Longrightarrow> P ; v \\<in> VV p** \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> V; v \\<in> VV p \\<Longrightarrow> P;\n     v \\<in> VV p** \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by auto"], ["", "subsection \\<open>Sets of Deadends\\<close>"], ["", "definition \"deadends p \\<equiv> {v \\<in> VV p. deadend v}\""], ["", "lemma deadends_in_V: \"deadends p \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deadends p \\<subseteq> V", "unfolding deadends_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> VV p. deadend v} \\<subseteq> V", "by blast"], ["", "subsection \\<open>Subgames\\<close>"], ["", "text \\<open>We define a subgame by restricting the set of nodes to a given subset.\\<close>"], ["", "definition subgame where\n  \"subgame V' \\<equiv> G\\<lparr>\n    verts   := V \\<inter> V',\n    arcs    := E \\<inter> (V' \\<times> V'),\n    player0 := V0 \\<inter> V' \\<rparr>\""], ["", "lemma subgame_V [simp]: \"V\\<^bsub>subgame V'\\<^esub> \\<subseteq> V\"\n  and subgame_E [simp]: \"E\\<^bsub>subgame V'\\<^esub> \\<subseteq> E\"\n  and subgame_\\<omega>: \"\\<omega>\\<^bsub>subgame V'\\<^esub> = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^bsub>subgame V'\\<^esub> \\<subseteq> V &&&\n    E\\<^bsub>subgame V'\\<^esub> \\<subseteq> E &&&\n    \\<omega>\\<^bsub>subgame V'\\<^esub> = \\<omega>", "unfolding subgame_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>\n    \\<subseteq> V &&&\n    E\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>\n    \\<subseteq> E &&&\n    \\<omega>\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub> =\n    \\<omega>", "by simp_all"], ["", "lemma\n  assumes \"V' \\<subseteq> V\"\n  shows subgame_V' [simp]: \"V\\<^bsub>subgame V'\\<^esub> = V'\"\n    and subgame_E' [simp]: \"E\\<^bsub>subgame V'\\<^esub> = E \\<inter> (V\\<^bsub>subgame V'\\<^esub> \\<times> V\\<^bsub>subgame V'\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^bsub>subgame V'\\<^esub> = V' &&&\n    E\\<^bsub>subgame V'\\<^esub> = Restr E V\\<^bsub>subgame V'\\<^esub>", "unfolding subgame_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub> =\n    V' &&&\n    E\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub> =\n    Restr E\n     V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>", "using assms"], ["proof (prove)\nusing this:\n  V' \\<subseteq> V\n\ngoal (1 subgoal):\n 1. V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub> =\n    V' &&&\n    E\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub> =\n    Restr E\n     V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>", "by auto"], ["", "lemma subgame_VV [simp]: \"ParityGame.VV (subgame V') p = V' \\<inter> VV p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n    V' \\<inter> VV p", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (if p = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n    V' \\<inter> VV p", "have \"ParityGame.VV (subgame V') Even = V' \\<inter> VV Even\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Even = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n    V' \\<inter> VV Even", "unfolding subgame_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Even = Even\n     then V0\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>\n     else V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub> -\n          V0\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>) =\n    V' \\<inter> VV Even", "by auto"], ["proof (state)\nthis:\n  (if Even = Even then V0\\<^bsub>subgame V'\\<^esub>\n   else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n  V' \\<inter> VV Even\n\ngoal (1 subgoal):\n 1. (if p = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n    V' \\<inter> VV p", "moreover"], ["proof (state)\nthis:\n  (if Even = Even then V0\\<^bsub>subgame V'\\<^esub>\n   else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n  V' \\<inter> VV Even\n\ngoal (1 subgoal):\n 1. (if p = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n    V' \\<inter> VV p", "have \"ParityGame.VV (subgame V') Odd = V' \\<inter> VV Odd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Odd = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n    V' \\<inter> VV Odd", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (if Odd = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n    V' \\<inter> VV Odd", "have \"V' \\<inter> V - (V0 \\<inter> V') = V' \\<inter> V \\<inter> (V - V0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V' \\<inter> V - V0 \\<inter> V' = V' \\<inter> V \\<inter> (V - V0)", "by blast"], ["proof (state)\nthis:\n  V' \\<inter> V - V0 \\<inter> V' = V' \\<inter> V \\<inter> (V - V0)\n\ngoal (1 subgoal):\n 1. (if Odd = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n    V' \\<inter> VV Odd", "thus ?thesis"], ["proof (prove)\nusing this:\n  V' \\<inter> V - V0 \\<inter> V' = V' \\<inter> V \\<inter> (V - V0)\n\ngoal (1 subgoal):\n 1. (if Odd = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n    V' \\<inter> VV Odd", "unfolding subgame_def"], ["proof (prove)\nusing this:\n  V' \\<inter> V - V0 \\<inter> V' = V' \\<inter> V \\<inter> (V - V0)\n\ngoal (1 subgoal):\n 1. (if Odd = Even\n     then V0\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>\n     else V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub> -\n          V0\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>) =\n    V' \\<inter> VV Odd", "by auto"], ["proof (state)\nthis:\n  (if Odd = Even then V0\\<^bsub>subgame V'\\<^esub>\n   else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n  V' \\<inter> VV Odd\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if Odd = Even then V0\\<^bsub>subgame V'\\<^esub>\n   else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n  V' \\<inter> VV Odd\n\ngoal (1 subgoal):\n 1. (if p = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n    V' \\<inter> VV p", "ultimately"], ["proof (chain)\npicking this:\n  (if Even = Even then V0\\<^bsub>subgame V'\\<^esub>\n   else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n  V' \\<inter> VV Even\n  (if Odd = Even then V0\\<^bsub>subgame V'\\<^esub>\n   else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n  V' \\<inter> VV Odd", "show ?thesis"], ["proof (prove)\nusing this:\n  (if Even = Even then V0\\<^bsub>subgame V'\\<^esub>\n   else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n  V' \\<inter> VV Even\n  (if Odd = Even then V0\\<^bsub>subgame V'\\<^esub>\n   else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n  V' \\<inter> VV Odd\n\ngoal (1 subgoal):\n 1. (if p = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n    V' \\<inter> VV p", "by simp"], ["proof (state)\nthis:\n  (if p = Even then V0\\<^bsub>subgame V'\\<^esub>\n   else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>) =\n  V' \\<inter> VV p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subgame_VV_subset [simp]: \"ParityGame.VV (subgame V') p \\<subseteq> VV p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p = Even then V0\\<^bsub>subgame V'\\<^esub>\n     else V\\<^bsub>subgame V'\\<^esub> - V0\\<^bsub>subgame V'\\<^esub>)\n    \\<subseteq> VV p", "by simp"], ["", "lemma subgame_finite [simp]: \"finite (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)", "have \"finite (\\<omega> ` V\\<^bsub>subgame V'\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<omega> ` V\\<^bsub>subgame V'\\<^esub>)", "using subgame_V priorities_finite"], ["proof (prove)\nusing this:\n  V\\<^bsub>subgame ?V'\\<^esub> \\<subseteq> V\n  finite (\\<omega> ` V)\n\ngoal (1 subgoal):\n 1. finite (\\<omega> ` V\\<^bsub>subgame V'\\<^esub>)", "by (meson finite_subset image_mono)"], ["proof (state)\nthis:\n  finite (\\<omega> ` V\\<^bsub>subgame V'\\<^esub>)\n\ngoal (1 subgoal):\n 1. finite\n     (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (\\<omega> ` V\\<^bsub>subgame V'\\<^esub>)\n\ngoal (1 subgoal):\n 1. finite\n     (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)", "by (simp add: subgame_def)"], ["proof (state)\nthis:\n  finite (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subgame_\\<omega>_subset [simp]: \"\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub> \\<subseteq> \\<omega> ` V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>\n    \\<subseteq> \\<omega> ` V", "by (simp add: image_mono subgame_\\<omega>)"], ["", "lemma subgame_Digraph: \"Digraph (subgame V')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph (subgame V')", "by (unfold_locales) (auto simp add: subgame_def)"], ["", "lemma subgame_ParityGame:\n  shows \"ParityGame (subgame V')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ParityGame (subgame V')", "proof (unfold_locales)"], ["proof (state)\ngoal (3 subgoals):\n 1. E\\<^bsub>subgame V'\\<^esub>\n    \\<subseteq> V\\<^bsub>subgame V'\\<^esub> \\<times>\n                V\\<^bsub>subgame V'\\<^esub>\n 2. V0\\<^bsub>subgame V'\\<^esub> \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\n 3. finite\n     (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)", "show \"E\\<^bsub>subgame V'\\<^esub> \\<subseteq> V\\<^bsub>subgame V'\\<^esub> \\<times> V\\<^bsub>subgame V'\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^bsub>subgame V'\\<^esub>\n    \\<subseteq> V\\<^bsub>subgame V'\\<^esub> \\<times>\n                V\\<^bsub>subgame V'\\<^esub>", "using subgame_Digraph[unfolded Digraph_def]"], ["proof (prove)\nusing this:\n  E\\<^bsub>subgame ?V'\\<^esub>\n  \\<subseteq> V\\<^bsub>subgame ?V'\\<^esub> \\<times>\n              V\\<^bsub>subgame ?V'\\<^esub>\n\ngoal (1 subgoal):\n 1. E\\<^bsub>subgame V'\\<^esub>\n    \\<subseteq> V\\<^bsub>subgame V'\\<^esub> \\<times>\n                V\\<^bsub>subgame V'\\<^esub>", "."], ["proof (state)\nthis:\n  E\\<^bsub>subgame V'\\<^esub>\n  \\<subseteq> V\\<^bsub>subgame V'\\<^esub> \\<times>\n              V\\<^bsub>subgame V'\\<^esub>\n\ngoal (2 subgoals):\n 1. V0\\<^bsub>subgame V'\\<^esub> \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\n 2. finite\n     (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)", "show \"V0\\<^bsub>subgame V'\\<^esub> \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V0\\<^bsub>subgame V'\\<^esub> \\<subseteq> V\\<^bsub>subgame V'\\<^esub>", "unfolding subgame_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. V0\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>\n    \\<subseteq> V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>", "using valid_player0_set"], ["proof (prove)\nusing this:\n  V0 \\<subseteq> V\n\ngoal (1 subgoal):\n 1. V0\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>\n    \\<subseteq> V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>", "by auto"], ["proof (state)\nthis:\n  V0\\<^bsub>subgame V'\\<^esub> \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (1 subgoal):\n 1. finite\n     (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)", "show \"finite (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)", "by simp"], ["proof (state)\nthis:\n  finite (\\<omega>\\<^bsub>subgame V'\\<^esub> ` V\\<^bsub>subgame V'\\<^esub>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subgame_valid_path:\n  assumes P: \"valid_path P\" \"lset P \\<subseteq> V'\"\n  shows \"Digraph.valid_path (subgame V') P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph.valid_path (subgame V') P", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Digraph.valid_path (subgame V') P", "have \"lset P \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset P \\<subseteq> V", "using P(1) valid_path_in_V"], ["proof (prove)\nusing this:\n  valid_path P\n  valid_path ?P \\<Longrightarrow> lset ?P \\<subseteq> V\n\ngoal (1 subgoal):\n 1. lset P \\<subseteq> V", "by blast"], ["proof (state)\nthis:\n  lset P \\<subseteq> V\n\ngoal (1 subgoal):\n 1. Digraph.valid_path (subgame V') P", "hence \"lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\""], ["proof (prove)\nusing this:\n  lset P \\<subseteq> V\n\ngoal (1 subgoal):\n 1. lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>", "unfolding subgame_def"], ["proof (prove)\nusing this:\n  lset P \\<subseteq> V\n\ngoal (1 subgoal):\n 1. lset P\n    \\<subseteq> V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>", "using P(2)"], ["proof (prove)\nusing this:\n  lset P \\<subseteq> V\n  lset P \\<subseteq> V'\n\ngoal (1 subgoal):\n 1. lset P\n    \\<subseteq> V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>", "by auto"], ["proof (state)\nthis:\n  lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (1 subgoal):\n 1. Digraph.valid_path (subgame V') P", "with P(1)"], ["proof (chain)\npicking this:\n  valid_path P\n  lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path P\n  lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (1 subgoal):\n 1. Digraph.valid_path (subgame V') P", "proof (coinduction arbitrary: P\n    rule: Digraph.valid_path.coinduct[OF subgame_Digraph, case_names IH])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>valid_path P;\n        lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)", "case IH"], ["proof (state)\nthis:\n  valid_path P\n  lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>valid_path P;\n        lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path P\n  lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (1 subgoal):\n 1. P = LNil \\<or>\n    (\\<exists>v.\n        P = LCons v LNil \\<and> v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n    (\\<exists>v w Ps.\n        P = LCons v Ps \\<and>\n        v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n        w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n        v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and>\n             valid_path P \\<and>\n             lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n         Digraph.valid_path (subgame V') Ps) \\<and>\n        \\<not> lnull Ps \\<and> lhd Ps = w)", "proof (cases rule: valid_path.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n     P = LNil\\<rbrakk>\n    \\<Longrightarrow> P = LNil \\<or>\n                      (\\<exists>v.\n                          P = LCons v LNil \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                      (\\<exists>v w Ps.\n                          P = LCons v Ps \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n                          ((\\<exists>P.\n                               Ps = P \\<and>\n                               valid_path P \\<and>\n                               lset P\n                               \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                           Digraph.valid_path (subgame V') Ps) \\<and>\n                          \\<not> lnull Ps \\<and> lhd Ps = w)\n 2. \\<And>v.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v LNil; v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)\n 3. \\<And>v w Ps.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v Ps; v \\<in> V; w \\<in> V; v \\<rightarrow> w;\n        valid_path Ps; \\<not> lnull Ps; lhd Ps = w\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)", "case (valid_path_cons v w Ps)"], ["proof (state)\nthis:\n  P = LCons v Ps\n  v \\<in> V\n  w \\<in> V\n  v \\<rightarrow> w\n  valid_path Ps\n  \\<not> lnull Ps\n  lhd Ps = w\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n     P = LNil\\<rbrakk>\n    \\<Longrightarrow> P = LNil \\<or>\n                      (\\<exists>v.\n                          P = LCons v LNil \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                      (\\<exists>v w Ps.\n                          P = LCons v Ps \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n                          ((\\<exists>P.\n                               Ps = P \\<and>\n                               valid_path P \\<and>\n                               lset P\n                               \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                           Digraph.valid_path (subgame V') Ps) \\<and>\n                          \\<not> lnull Ps \\<and> lhd Ps = w)\n 2. \\<And>v.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v LNil; v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)\n 3. \\<And>v w Ps.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v Ps; v \\<in> V; w \\<in> V; v \\<rightarrow> w;\n        valid_path Ps; \\<not> lnull Ps; lhd Ps = w\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)", "moreover"], ["proof (state)\nthis:\n  P = LCons v Ps\n  v \\<in> V\n  w \\<in> V\n  v \\<rightarrow> w\n  valid_path Ps\n  \\<not> lnull Ps\n  lhd Ps = w\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n     P = LNil\\<rbrakk>\n    \\<Longrightarrow> P = LNil \\<or>\n                      (\\<exists>v.\n                          P = LCons v LNil \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                      (\\<exists>v w Ps.\n                          P = LCons v Ps \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n                          ((\\<exists>P.\n                               Ps = P \\<and>\n                               valid_path P \\<and>\n                               lset P\n                               \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                           Digraph.valid_path (subgame V') Ps) \\<and>\n                          \\<not> lnull Ps \\<and> lhd Ps = w)\n 2. \\<And>v.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v LNil; v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)\n 3. \\<And>v w Ps.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v Ps; v \\<in> V; w \\<in> V; v \\<rightarrow> w;\n        valid_path Ps; \\<not> lnull Ps; lhd Ps = w\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)", "hence \"v \\<in> V\\<^bsub>subgame V'\\<^esub>\" \"w \\<in> V\\<^bsub>subgame V'\\<^esub>\""], ["proof (prove)\nusing this:\n  P = LCons v Ps\n  v \\<in> V\n  w \\<in> V\n  v \\<rightarrow> w\n  valid_path Ps\n  \\<not> lnull Ps\n  lhd Ps = w\n\ngoal (1 subgoal):\n 1. v \\<in> V\\<^bsub>subgame V'\\<^esub> &&&\n    w \\<in> V\\<^bsub>subgame V'\\<^esub>", "using IH(2)"], ["proof (prove)\nusing this:\n  P = LCons v Ps\n  v \\<in> V\n  w \\<in> V\n  v \\<rightarrow> w\n  valid_path Ps\n  \\<not> lnull Ps\n  lhd Ps = w\n  lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (1 subgoal):\n 1. v \\<in> V\\<^bsub>subgame V'\\<^esub> &&&\n    w \\<in> V\\<^bsub>subgame V'\\<^esub>", "by auto"], ["proof (state)\nthis:\n  v \\<in> V\\<^bsub>subgame V'\\<^esub>\n  w \\<in> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n     P = LNil\\<rbrakk>\n    \\<Longrightarrow> P = LNil \\<or>\n                      (\\<exists>v.\n                          P = LCons v LNil \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                      (\\<exists>v w Ps.\n                          P = LCons v Ps \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n                          ((\\<exists>P.\n                               Ps = P \\<and>\n                               valid_path P \\<and>\n                               lset P\n                               \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                           Digraph.valid_path (subgame V') Ps) \\<and>\n                          \\<not> lnull Ps \\<and> lhd Ps = w)\n 2. \\<And>v.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v LNil; v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)\n 3. \\<And>v w Ps.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v Ps; v \\<in> V; w \\<in> V; v \\<rightarrow> w;\n        valid_path Ps; \\<not> lnull Ps; lhd Ps = w\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)", "moreover"], ["proof (state)\nthis:\n  v \\<in> V\\<^bsub>subgame V'\\<^esub>\n  w \\<in> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n     P = LNil\\<rbrakk>\n    \\<Longrightarrow> P = LNil \\<or>\n                      (\\<exists>v.\n                          P = LCons v LNil \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                      (\\<exists>v w Ps.\n                          P = LCons v Ps \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n                          ((\\<exists>P.\n                               Ps = P \\<and>\n                               valid_path P \\<and>\n                               lset P\n                               \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                           Digraph.valid_path (subgame V') Ps) \\<and>\n                          \\<not> lnull Ps \\<and> lhd Ps = w)\n 2. \\<And>v.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v LNil; v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)\n 3. \\<And>v w Ps.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v Ps; v \\<in> V; w \\<in> V; v \\<rightarrow> w;\n        valid_path Ps; \\<not> lnull Ps; lhd Ps = w\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)", "hence \"v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w\""], ["proof (prove)\nusing this:\n  v \\<in> V\\<^bsub>subgame V'\\<^esub>\n  w \\<in> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (1 subgoal):\n 1. v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w", "using local.valid_path_cons(4) subgame_def"], ["proof (prove)\nusing this:\n  v \\<in> V\\<^bsub>subgame V'\\<^esub>\n  w \\<in> V\\<^bsub>subgame V'\\<^esub>\n  v \\<rightarrow> w\n  subgame ?V' \\<equiv> G\n  \\<lparr>verts := V \\<inter> ?V', arcs := Restr E ?V',\n     player0 := V0 \\<inter> ?V'\\<rparr>\n\ngoal (1 subgoal):\n 1. v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w", "by auto"], ["proof (state)\nthis:\n  v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n     P = LNil\\<rbrakk>\n    \\<Longrightarrow> P = LNil \\<or>\n                      (\\<exists>v.\n                          P = LCons v LNil \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                      (\\<exists>v w Ps.\n                          P = LCons v Ps \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n                          ((\\<exists>P.\n                               Ps = P \\<and>\n                               valid_path P \\<and>\n                               lset P\n                               \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                           Digraph.valid_path (subgame V') Ps) \\<and>\n                          \\<not> lnull Ps \\<and> lhd Ps = w)\n 2. \\<And>v.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v LNil; v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)\n 3. \\<And>v w Ps.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v Ps; v \\<in> V; w \\<in> V; v \\<rightarrow> w;\n        valid_path Ps; \\<not> lnull Ps; lhd Ps = w\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)", "moreover"], ["proof (state)\nthis:\n  v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n     P = LNil\\<rbrakk>\n    \\<Longrightarrow> P = LNil \\<or>\n                      (\\<exists>v.\n                          P = LCons v LNil \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                      (\\<exists>v w Ps.\n                          P = LCons v Ps \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n                          ((\\<exists>P.\n                               Ps = P \\<and>\n                               valid_path P \\<and>\n                               lset P\n                               \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                           Digraph.valid_path (subgame V') Ps) \\<and>\n                          \\<not> lnull Ps \\<and> lhd Ps = w)\n 2. \\<And>v.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v LNil; v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)\n 3. \\<And>v w Ps.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v Ps; v \\<in> V; w \\<in> V; v \\<rightarrow> w;\n        valid_path Ps; \\<not> lnull Ps; lhd Ps = w\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)", "have \"valid_path Ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path Ps", "using IH(1) valid_path_ltl' local.valid_path_cons(1)"], ["proof (prove)\nusing this:\n  valid_path P\n  valid_path (LCons ?v ?Ps) \\<Longrightarrow> valid_path ?Ps\n  P = LCons v Ps\n\ngoal (1 subgoal):\n 1. valid_path Ps", "by blast"], ["proof (state)\nthis:\n  valid_path Ps\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n     P = LNil\\<rbrakk>\n    \\<Longrightarrow> P = LNil \\<or>\n                      (\\<exists>v.\n                          P = LCons v LNil \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                      (\\<exists>v w Ps.\n                          P = LCons v Ps \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n                          ((\\<exists>P.\n                               Ps = P \\<and>\n                               valid_path P \\<and>\n                               lset P\n                               \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                           Digraph.valid_path (subgame V') Ps) \\<and>\n                          \\<not> lnull Ps \\<and> lhd Ps = w)\n 2. \\<And>v.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v LNil; v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)\n 3. \\<And>v w Ps.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v Ps; v \\<in> V; w \\<in> V; v \\<rightarrow> w;\n        valid_path Ps; \\<not> lnull Ps; lhd Ps = w\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)", "ultimately"], ["proof (chain)\npicking this:\n  P = LCons v Ps\n  v \\<in> V\n  w \\<in> V\n  v \\<rightarrow> w\n  valid_path Ps\n  \\<not> lnull Ps\n  lhd Ps = w\n  v \\<in> V\\<^bsub>subgame V'\\<^esub>\n  w \\<in> V\\<^bsub>subgame V'\\<^esub>\n  v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w\n  valid_path Ps", "show ?thesis"], ["proof (prove)\nusing this:\n  P = LCons v Ps\n  v \\<in> V\n  w \\<in> V\n  v \\<rightarrow> w\n  valid_path Ps\n  \\<not> lnull Ps\n  lhd Ps = w\n  v \\<in> V\\<^bsub>subgame V'\\<^esub>\n  w \\<in> V\\<^bsub>subgame V'\\<^esub>\n  v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w\n  valid_path Ps\n\ngoal (1 subgoal):\n 1. P = LNil \\<or>\n    (\\<exists>v.\n        P = LCons v LNil \\<and> v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n    (\\<exists>v w Ps.\n        P = LCons v Ps \\<and>\n        v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n        w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n        v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and>\n             valid_path P \\<and>\n             lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n         Digraph.valid_path (subgame V') Ps) \\<and>\n        \\<not> lnull Ps \\<and> lhd Ps = w)", "using IH(2)"], ["proof (prove)\nusing this:\n  P = LCons v Ps\n  v \\<in> V\n  w \\<in> V\n  v \\<rightarrow> w\n  valid_path Ps\n  \\<not> lnull Ps\n  lhd Ps = w\n  v \\<in> V\\<^bsub>subgame V'\\<^esub>\n  w \\<in> V\\<^bsub>subgame V'\\<^esub>\n  v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w\n  valid_path Ps\n  lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (1 subgoal):\n 1. P = LNil \\<or>\n    (\\<exists>v.\n        P = LCons v LNil \\<and> v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n    (\\<exists>v w Ps.\n        P = LCons v Ps \\<and>\n        v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n        w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n        v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n        ((\\<exists>P.\n             Ps = P \\<and>\n             valid_path P \\<and>\n             lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n         Digraph.valid_path (subgame V') Ps) \\<and>\n        \\<not> lnull Ps \\<and> lhd Ps = w)", "by auto"], ["proof (state)\nthis:\n  P = LNil \\<or>\n  (\\<exists>v.\n      P = LCons v LNil \\<and> v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n  (\\<exists>v w Ps.\n      P = LCons v Ps \\<and>\n      v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n      w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n      v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n      ((\\<exists>P.\n           Ps = P \\<and>\n           valid_path P \\<and>\n           lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n       Digraph.valid_path (subgame V') Ps) \\<and>\n      \\<not> lnull Ps \\<and> lhd Ps = w)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n     P = LNil\\<rbrakk>\n    \\<Longrightarrow> P = LNil \\<or>\n                      (\\<exists>v.\n                          P = LCons v LNil \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                      (\\<exists>v w Ps.\n                          P = LCons v Ps \\<and>\n                          v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                          v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n                          ((\\<exists>P.\n                               Ps = P \\<and>\n                               valid_path P \\<and>\n                               lset P\n                               \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                           Digraph.valid_path (subgame V') Ps) \\<and>\n                          \\<not> lnull Ps \\<and> lhd Ps = w)\n 2. \\<And>v.\n       \\<lbrakk>lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>;\n        P = LCons v LNil; v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> P = LNil \\<or>\n                         (\\<exists>v.\n                             P = LCons v LNil \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                         (\\<exists>v w Ps.\n                             P = LCons v Ps \\<and>\n                             v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n                             v \\<rightarrow>\\<^bsub>subgame V'\\<^esub>\n                             w \\<and>\n                             ((\\<exists>P.\n                                  Ps = P \\<and>\n                                  valid_path P \\<and>\n                                  lset P\n                                  \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n                              Digraph.valid_path (subgame V') Ps) \\<and>\n                             \\<not> lnull Ps \\<and> lhd Ps = w)", "qed auto"], ["proof (state)\nthis:\n  P = LNil \\<or>\n  (\\<exists>v.\n      P = LCons v LNil \\<and> v \\<in> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n  (\\<exists>v w Ps.\n      P = LCons v Ps \\<and>\n      v \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n      w \\<in> V\\<^bsub>subgame V'\\<^esub> \\<and>\n      v \\<rightarrow>\\<^bsub>subgame V'\\<^esub> w \\<and>\n      ((\\<exists>P.\n           Ps = P \\<and>\n           valid_path P \\<and>\n           lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>) \\<or>\n       Digraph.valid_path (subgame V') Ps) \\<and>\n      \\<not> lnull Ps \\<and> lhd Ps = w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Digraph.valid_path (subgame V') P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subgame_maximal_path:\n  assumes V': \"V' \\<subseteq> V\" and P: \"maximal_path P\" \"lset P \\<subseteq> V'\"\n  shows \"Digraph.maximal_path (subgame V') P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph.maximal_path (subgame V') P", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Digraph.maximal_path (subgame V') P", "have \"lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>", "unfolding subgame_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lset P\n    \\<subseteq> V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>", "using P(2) V'"], ["proof (prove)\nusing this:\n  lset P \\<subseteq> V'\n  V' \\<subseteq> V\n\ngoal (1 subgoal):\n 1. lset P\n    \\<subseteq> V\\<^bsub>G\\<lparr>verts := V \\<inter> V', arcs := Restr E V', player0 := V0 \\<inter> V'\\<rparr>\\<^esub>", "by auto"], ["proof (state)\nthis:\n  lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (1 subgoal):\n 1. Digraph.maximal_path (subgame V') P", "with P(1) V'"], ["proof (chain)\npicking this:\n  maximal_path P\n  V' \\<subseteq> V\n  lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  maximal_path P\n  V' \\<subseteq> V\n  lset P \\<subseteq> V\\<^bsub>subgame V'\\<^esub>\n\ngoal (1 subgoal):\n 1. Digraph.maximal_path (subgame V') P", "by (coinduction arbitrary: P rule: Digraph.maximal_path.coinduct[OF subgame_Digraph])\n       (cases rule: maximal_path.cases, auto)"], ["proof (state)\nthis:\n  Digraph.maximal_path (subgame V') P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Priorities Occurring Infinitely Often\\<close>"], ["", "text \\<open>\n  The set of priorities that occur infinitely often on a given path.  We need this to define the\n  winning condition of parity games.\n\\<close>"], ["", "definition path_inf_priorities :: \"'a Path \\<Rightarrow> nat set\" where\n  \"path_inf_priorities P \\<equiv> {k. \\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))}\""], ["", "text \\<open>\n  Because @{term \\<omega>} is image-finite, by the pigeon-hole principle every infinite path has at least\n  one priority that occurs infinitely often.\n\\<close>"], ["", "lemma path_inf_priorities_is_nonempty:\n  assumes P: \"valid_path P\" \"\\<not>lfinite P\"\n  shows \"\\<exists>k. k \\<in> path_inf_priorities P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "text \\<open>Define a map from indices to priorities on the path.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "define f where \"f i = \\<omega> (P $ i)\" for i"], ["proof (state)\nthis:\n  f ?i = \\<omega> (P $ ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "have \"range f \\<subseteq> \\<omega> ` V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range f \\<subseteq> \\<omega> ` V", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>i. \\<omega> (P $ i)) \\<subseteq> \\<omega> ` V", "using valid_path_in_V[OF P(1)] lset_nth_member_inf[OF P(2)]"], ["proof (prove)\nusing this:\n  lset P \\<subseteq> V\n  lset P \\<subseteq> ?A \\<Longrightarrow> P $ ?n \\<in> ?A\n\ngoal (1 subgoal):\n 1. range (\\<lambda>i. \\<omega> (P $ i)) \\<subseteq> \\<omega> ` V", "by blast"], ["proof (state)\nthis:\n  range f \\<subseteq> \\<omega> ` V\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "hence \"finite (range f)\""], ["proof (prove)\nusing this:\n  range f \\<subseteq> \\<omega> ` V\n\ngoal (1 subgoal):\n 1. finite (range f)", "using priorities_finite finite_subset"], ["proof (prove)\nusing this:\n  range f \\<subseteq> \\<omega> ` V\n  finite (\\<omega> ` V)\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (range f)", "by blast"], ["proof (state)\nthis:\n  finite (range f)\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "then"], ["proof (chain)\npicking this:\n  finite (range f)", "obtain n0 where n0: \"\\<not>(finite {n. f n = f n0})\""], ["proof (prove)\nusing this:\n  finite (range f)\n\ngoal (1 subgoal):\n 1. (\\<And>n0.\n        infinite {n. f n = f n0} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pigeonhole_infinite[of UNIV f]"], ["proof (prove)\nusing this:\n  finite (range f)\n  \\<lbrakk>infinite UNIV; finite (range f)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a0\\<in>UNIV.\n                       infinite {a \\<in> UNIV. f a = f a0}\n\ngoal (1 subgoal):\n 1. (\\<And>n0.\n        infinite {n. f n = f n0} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  infinite {n. f n = f n0}\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "define k where \"k = f n0\""], ["proof (state)\nthis:\n  k = f n0\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "text \\<open>The priority @{term k} occurs infinitely often.\\<close>"], ["proof (state)\nthis:\n  k = f n0\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "have \"lmap \\<omega> P $ n0 = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap \\<omega> P $ n0 = k", "unfolding f_def k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap \\<omega> P $ n0 = \\<omega> (P $ n0)", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<not> lfinite P\n\ngoal (1 subgoal):\n 1. lmap \\<omega> P $ n0 = \\<omega> (P $ n0)", "by (simp add: infinite_small_llength)"], ["proof (state)\nthis:\n  lmap \\<omega> P $ n0 = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "moreover"], ["proof (state)\nthis:\n  lmap \\<omega> P $ n0 = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "{"], ["proof (state)\nthis:\n  lmap \\<omega> P $ n0 = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "assume \"lmap \\<omega> P $ n = k\""], ["proof (state)\nthis:\n  lmap \\<omega> P $ n = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "have \"\\<exists>n' > n. f n' = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n'>n. f n' = k", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n'>n. f n' = f n0", "using n0 infinite_nat_iff_unbounded"], ["proof (prove)\nusing this:\n  infinite {n. f n = f n0}\n  infinite ?S = (\\<forall>m. \\<exists>n>m. n \\<in> ?S)\n\ngoal (1 subgoal):\n 1. \\<exists>n'>n. f n' = f n0", "by auto"], ["proof (state)\nthis:\n  \\<exists>n'>n. f n' = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "hence \"\\<exists>n' > n. lmap \\<omega> P $ n' = k\""], ["proof (prove)\nusing this:\n  \\<exists>n'>n. f n' = k\n\ngoal (1 subgoal):\n 1. \\<exists>n'>n. lmap \\<omega> P $ n' = k", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<exists>n'>n. \\<omega> (P $ n') = k\n\ngoal (1 subgoal):\n 1. \\<exists>n'>n. lmap \\<omega> P $ n' = k", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<exists>n'>n. \\<omega> (P $ n') = k\n  \\<not> lfinite P\n\ngoal (1 subgoal):\n 1. \\<exists>n'>n. lmap \\<omega> P $ n' = k", "by (simp add: infinite_small_llength)"], ["proof (state)\nthis:\n  \\<exists>n'>n. lmap \\<omega> P $ n' = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "}"], ["proof (state)\nthis:\n  lmap \\<omega> P $ ?n2 = k \\<Longrightarrow>\n  \\<exists>n'>?n2. lmap \\<omega> P $ n' = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "ultimately"], ["proof (chain)\npicking this:\n  lmap \\<omega> P $ n0 = k\n  lmap \\<omega> P $ ?n2 = k \\<Longrightarrow>\n  \\<exists>n'>?n2. lmap \\<omega> P $ n' = k", "have \"\\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))\""], ["proof (prove)\nusing this:\n  lmap \\<omega> P $ n0 = k\n  lmap \\<omega> P $ ?n2 = k \\<Longrightarrow>\n  \\<exists>n'>?n2. lmap \\<omega> P $ n' = k\n\ngoal (1 subgoal):\n 1. \\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))", "using index_infinite_set[of \"lmap \\<omega> P\" n0 k] P(2) lfinite_lmap"], ["proof (prove)\nusing this:\n  lmap \\<omega> P $ n0 = k\n  lmap \\<omega> P $ ?n2 = k \\<Longrightarrow>\n  \\<exists>n'>?n2. lmap \\<omega> P $ n' = k\n  \\<lbrakk>\\<not> lfinite (lmap \\<omega> P); lmap \\<omega> P $ n0 = k;\n   \\<And>i.\n      lmap \\<omega> P $ i = k \\<Longrightarrow>\n      \\<exists>m>i. lmap \\<omega> P $ m = k\\<rbrakk>\n  \\<Longrightarrow> k \\<in> lset (ldropn ?n (lmap \\<omega> P))\n  \\<not> lfinite P\n  lfinite (lmap ?f ?xs) = lfinite ?xs\n\ngoal (1 subgoal):\n 1. \\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<in> path_inf_priorities P", "unfolding path_inf_priorities_def"], ["proof (prove)\nusing this:\n  \\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<in> {k. \\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))}", "by blast"], ["proof (state)\nthis:\n  \\<exists>k. k \\<in> path_inf_priorities P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_inf_priorities_at_least_min_prio:\n  assumes P: \"valid_path P\" and a: \"a \\<in> path_inf_priorities P\"\n  shows \"Min (\\<omega> ` V) \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (\\<omega> ` V) \\<le> a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (\\<omega> ` V) \\<le> a", "have \"a \\<in> lset (ldropn 0 (lmap \\<omega> P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> lset (ldropn 0 (lmap \\<omega> P))", "using a"], ["proof (prove)\nusing this:\n  a \\<in> path_inf_priorities P\n\ngoal (1 subgoal):\n 1. a \\<in> lset (ldropn 0 (lmap \\<omega> P))", "unfolding path_inf_priorities_def"], ["proof (prove)\nusing this:\n  a \\<in> {k. \\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))}\n\ngoal (1 subgoal):\n 1. a \\<in> lset (ldropn 0 (lmap \\<omega> P))", "by blast"], ["proof (state)\nthis:\n  a \\<in> lset (ldropn 0 (lmap \\<omega> P))\n\ngoal (1 subgoal):\n 1. Min (\\<omega> ` V) \\<le> a", "hence \"a \\<in> \\<omega> ` lset P\""], ["proof (prove)\nusing this:\n  a \\<in> lset (ldropn 0 (lmap \\<omega> P))\n\ngoal (1 subgoal):\n 1. a \\<in> \\<omega> ` lset P", "by simp"], ["proof (state)\nthis:\n  a \\<in> \\<omega> ` lset P\n\ngoal (1 subgoal):\n 1. Min (\\<omega> ` V) \\<le> a", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> \\<omega> ` lset P\n\ngoal (1 subgoal):\n 1. Min (\\<omega> ` V) \\<le> a", "using P valid_path_in_V priorities_finite Min_le"], ["proof (prove)\nusing this:\n  a \\<in> \\<omega> ` lset P\n  valid_path P\n  valid_path ?P \\<Longrightarrow> lset ?P \\<subseteq> V\n  finite (\\<omega> ` V)\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> Min ?A \\<le> ?x\n\ngoal (1 subgoal):\n 1. Min (\\<omega> ` V) \\<le> a", "by blast"], ["proof (state)\nthis:\n  Min (\\<omega> ` V) \\<le> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_inf_priorities_LCons:\n  \"path_inf_priorities P = path_inf_priorities (LCons v P)\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_inf_priorities P = path_inf_priorities (LCons v P)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. path_inf_priorities P \\<subseteq> path_inf_priorities (LCons v P)\n 2. path_inf_priorities (LCons v P) \\<subseteq> path_inf_priorities P", "show \"?A \\<subseteq> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_inf_priorities P \\<subseteq> path_inf_priorities (LCons v P)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_inf_priorities P \\<Longrightarrow>\n       x \\<in> path_inf_priorities (LCons v P)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_inf_priorities P \\<Longrightarrow>\n       x \\<in> path_inf_priorities (LCons v P)", "assume \"a \\<in> ?A\""], ["proof (state)\nthis:\n  a \\<in> path_inf_priorities P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_inf_priorities P \\<Longrightarrow>\n       x \\<in> path_inf_priorities (LCons v P)", "hence \"\\<forall>n. a \\<in> lset (ldropn n (lmap \\<omega> (LCons v P)))\""], ["proof (prove)\nusing this:\n  a \\<in> path_inf_priorities P\n\ngoal (1 subgoal):\n 1. \\<forall>n. a \\<in> lset (ldropn n (lmap \\<omega> (LCons v P)))", "unfolding path_inf_priorities_def"], ["proof (prove)\nusing this:\n  a \\<in> {k. \\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))}\n\ngoal (1 subgoal):\n 1. \\<forall>n. a \\<in> lset (ldropn n (lmap \\<omega> (LCons v P)))", "using in_lset_ltlD[of a]"], ["proof (prove)\nusing this:\n  a \\<in> {k. \\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))}\n  a \\<in> lset (ltl ?xs) \\<Longrightarrow> a \\<in> lset ?xs\n\ngoal (1 subgoal):\n 1. \\<forall>n. a \\<in> lset (ldropn n (lmap \\<omega> (LCons v P)))", "by (simp add: ltl_ldropn)"], ["proof (state)\nthis:\n  \\<forall>n. a \\<in> lset (ldropn n (lmap \\<omega> (LCons v P)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_inf_priorities P \\<Longrightarrow>\n       x \\<in> path_inf_priorities (LCons v P)", "thus \"a \\<in> ?B\""], ["proof (prove)\nusing this:\n  \\<forall>n. a \\<in> lset (ldropn n (lmap \\<omega> (LCons v P)))\n\ngoal (1 subgoal):\n 1. a \\<in> path_inf_priorities (LCons v P)", "unfolding path_inf_priorities_def"], ["proof (prove)\nusing this:\n  \\<forall>n. a \\<in> lset (ldropn n (lmap \\<omega> (LCons v P)))\n\ngoal (1 subgoal):\n 1. a \\<in> {k. \\<forall>n.\n                   k \\<in> lset (ldropn n (lmap \\<omega> (LCons v P)))}", "by blast"], ["proof (state)\nthis:\n  a \\<in> path_inf_priorities (LCons v P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path_inf_priorities P \\<subseteq> path_inf_priorities (LCons v P)\n\ngoal (1 subgoal):\n 1. path_inf_priorities (LCons v P) \\<subseteq> path_inf_priorities P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. path_inf_priorities (LCons v P) \\<subseteq> path_inf_priorities P", "show \"?B \\<subseteq> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_inf_priorities (LCons v P) \\<subseteq> path_inf_priorities P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_inf_priorities (LCons v P) \\<Longrightarrow>\n       x \\<in> path_inf_priorities P", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_inf_priorities (LCons v P) \\<Longrightarrow>\n       x \\<in> path_inf_priorities P", "assume \"a \\<in> ?B\""], ["proof (state)\nthis:\n  a \\<in> path_inf_priorities (LCons v P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_inf_priorities (LCons v P) \\<Longrightarrow>\n       x \\<in> path_inf_priorities P", "hence \"\\<forall>n. a \\<in> lset (ldropn (Suc n) (lmap \\<omega> (LCons v P)))\""], ["proof (prove)\nusing this:\n  a \\<in> path_inf_priorities (LCons v P)\n\ngoal (1 subgoal):\n 1. \\<forall>n. a \\<in> lset (ldropn (Suc n) (lmap \\<omega> (LCons v P)))", "unfolding path_inf_priorities_def"], ["proof (prove)\nusing this:\n  a \\<in> {k. \\<forall>n.\n                 k \\<in> lset (ldropn n (lmap \\<omega> (LCons v P)))}\n\ngoal (1 subgoal):\n 1. \\<forall>n. a \\<in> lset (ldropn (Suc n) (lmap \\<omega> (LCons v P)))", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. a \\<in> lset (ldropn (Suc n) (lmap \\<omega> (LCons v P)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_inf_priorities (LCons v P) \\<Longrightarrow>\n       x \\<in> path_inf_priorities P", "thus \"a \\<in> ?A\""], ["proof (prove)\nusing this:\n  \\<forall>n. a \\<in> lset (ldropn (Suc n) (lmap \\<omega> (LCons v P)))\n\ngoal (1 subgoal):\n 1. a \\<in> path_inf_priorities P", "unfolding path_inf_priorities_def"], ["proof (prove)\nusing this:\n  \\<forall>n. a \\<in> lset (ldropn (Suc n) (lmap \\<omega> (LCons v P)))\n\ngoal (1 subgoal):\n 1. a \\<in> {k. \\<forall>n. k \\<in> lset (ldropn n (lmap \\<omega> P))}", "by simp"], ["proof (state)\nthis:\n  a \\<in> path_inf_priorities P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path_inf_priorities (LCons v P) \\<subseteq> path_inf_priorities P\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary path_inf_priorities_ltl: \"path_inf_priorities P = path_inf_priorities (ltl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_inf_priorities P = path_inf_priorities (ltl P)", "by (metis llist.exhaust ltl_simps path_inf_priorities_LCons)"], ["", "subsection \\<open>Winning Condition\\<close>"], ["", "text \\<open>\n  Let $G = (V,E,V_0,\\omega)$ be a parity game.\n  An infinite path $v_0,v_1,\\ldots$ in $G$ is winning for player \\Even (\\Odd) if the minimum\n  priority occurring infinitely often is even (odd).\n  A finite path is winning for player @{term p} iff the last node on the path belongs to the other\n  player.\n\n  Empty paths are irrelevant, but it is useful to assign a fixed winner to them in order to get\n  simpler lemmas.\n\\<close>"], ["", "abbreviation \"winning_priority p \\<equiv> (if p = Even then even else odd)\""], ["", "definition winning_path :: \"Player \\<Rightarrow> 'a Path \\<Rightarrow> bool\" where\n  \"winning_path p P \\<equiv>\n    (\\<not>lfinite P \\<and> (\\<exists>a \\<in> path_inf_priorities P.\n      (\\<forall>b \\<in> path_inf_priorities P. a \\<le> b) \\<and> winning_priority p a))\n    \\<or> (\\<not>lnull P \\<and> lfinite P \\<and> llast P \\<in> VV p**)\n    \\<or> (lnull P \\<and> p = Even)\""], ["", "text \\<open>Every path has a unique winner.\\<close>"], ["", "lemma paths_are_winning_for_one_player:\n  assumes \"valid_path P\"\n  shows \"winning_path p P \\<longleftrightarrow> \\<not>winning_path p** P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p P = (\\<not> winning_path p** P)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p P = (\\<not> winning_path p** P)\n 2. \\<not> ?P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "assume \"\\<not>lnull P\""], ["proof (state)\nthis:\n  \\<not> lnull P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p P = (\\<not> winning_path p** P)\n 2. \\<not> ?P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p P = (\\<not> winning_path p** P)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p P = (\\<not> winning_path p** P)\n 2. \\<not> ?P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "assume \"lfinite P\""], ["proof (state)\nthis:\n  lfinite P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p P = (\\<not> winning_path p** P)\n 2. \\<not> ?P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite P\n\ngoal (1 subgoal):\n 1. winning_path p P = (\\<not> winning_path p** P)", "using assms lfinite_lset valid_path_in_V"], ["proof (prove)\nusing this:\n  lfinite P\n  valid_path P\n  \\<lbrakk>lfinite ?xs; \\<not> lnull ?xs\\<rbrakk>\n  \\<Longrightarrow> llast ?xs \\<in> lset ?xs\n  valid_path ?P \\<Longrightarrow> lset ?P \\<subseteq> V\n\ngoal (1 subgoal):\n 1. winning_path p P = (\\<not> winning_path p** P)", "unfolding winning_path_def"], ["proof (prove)\nusing this:\n  lfinite P\n  valid_path P\n  \\<lbrakk>lfinite ?xs; \\<not> lnull ?xs\\<rbrakk>\n  \\<Longrightarrow> llast ?xs \\<in> lset ?xs\n  valid_path ?P \\<Longrightarrow> lset ?P \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<not> lfinite P \\<and>\n     (\\<exists>a\\<in>path_inf_priorities P.\n         (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n         (if p = Even then even else odd) a) \\<or>\n     \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> VV p** \\<or>\n     lnull P \\<and> p = Even) =\n    (\\<not> (\\<not> lfinite P \\<and>\n             (\\<exists>a\\<in>path_inf_priorities P.\n                 (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n                 (if p** = Even then even else odd) a) \\<or>\n             \\<not> lnull P \\<and>\n             lfinite P \\<and> llast P \\<in> VV p**** \\<or>\n             lnull P \\<and> p** = Even))", "by auto"], ["proof (state)\nthis:\n  winning_path p P = (\\<not> winning_path p** P)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "assume \"\\<not>lfinite P\""], ["proof (state)\nthis:\n  \\<not> lfinite P\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "then"], ["proof (chain)\npicking this:\n  \\<not> lfinite P", "obtain a where \"a \\<in> path_inf_priorities P\" \"\\<And>b. b < a \\<Longrightarrow> b \\<notin> path_inf_priorities P\""], ["proof (prove)\nusing this:\n  \\<not> lfinite P\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> path_inf_priorities P;\n         \\<And>b.\n            b < a \\<Longrightarrow>\n            b \\<notin> path_inf_priorities P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms ex_least_nat_le[of \"\\<lambda>a. a \\<in> path_inf_priorities P\"] path_inf_priorities_is_nonempty"], ["proof (prove)\nusing this:\n  \\<not> lfinite P\n  valid_path P\n  \\<lbrakk>?n \\<in> path_inf_priorities P;\n   0 \\<notin> path_inf_priorities P\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<le>?n.\n                       (\\<forall>i<k.\n                           i \\<notin> path_inf_priorities P) \\<and>\n                       k \\<in> path_inf_priorities P\n  \\<lbrakk>valid_path ?P; \\<not> lfinite ?P\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k. k \\<in> path_inf_priorities ?P\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> path_inf_priorities P;\n         \\<And>b.\n            b < a \\<Longrightarrow>\n            b \\<notin> path_inf_priorities P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> path_inf_priorities P\n  ?b < a \\<Longrightarrow> ?b \\<notin> path_inf_priorities P\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "hence \"\\<forall>q. winning_priority q a \\<longleftrightarrow> winning_path q P\""], ["proof (prove)\nusing this:\n  a \\<in> path_inf_priorities P\n  ?b < a \\<Longrightarrow> ?b \\<notin> path_inf_priorities P\n\ngoal (1 subgoal):\n 1. \\<forall>q. (if q = Even then even else odd) a = winning_path q P", "unfolding winning_path_def"], ["proof (prove)\nusing this:\n  a \\<in> path_inf_priorities P\n  ?b < a \\<Longrightarrow> ?b \\<notin> path_inf_priorities P\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       (if q = Even then even else odd) a =\n       (\\<not> lfinite P \\<and>\n        (\\<exists>a\\<in>path_inf_priorities P.\n            (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n            (if q = Even then even else odd) a) \\<or>\n        \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> VV q** \\<or>\n        lnull P \\<and> q = Even)", "using \\<open>\\<not>lnull P\\<close> \\<open>\\<not>lfinite P\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> path_inf_priorities P\n  ?b < a \\<Longrightarrow> ?b \\<notin> path_inf_priorities P\n  \\<not> lnull P\n  \\<not> lfinite P\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       (if q = Even then even else odd) a =\n       (\\<not> lfinite P \\<and>\n        (\\<exists>a\\<in>path_inf_priorities P.\n            (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n            (if q = Even then even else odd) a) \\<or>\n        \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> VV q** \\<or>\n        lnull P \\<and> q = Even)", "by (metis le_antisym not_le)"], ["proof (state)\nthis:\n  \\<forall>q. (if q = Even then even else odd) a = winning_path q P\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "moreover"], ["proof (state)\nthis:\n  \\<forall>q. (if q = Even then even else odd) a = winning_path q P\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "have \"\\<forall>q. winning_priority p q \\<longleftrightarrow> \\<not>winning_priority p** q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q.\n       (if p = Even then even else odd) q =\n       (\\<not> (if p** = Even then even else odd) q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>q.\n     (if p = Even then even else odd) q =\n     (\\<not> (if p** = Even then even else odd) q)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>q. (if q = Even then even else odd) a = winning_path q P\n  \\<forall>q.\n     (if p = Even then even else odd) q =\n     (\\<not> (if p** = Even then even else odd) q)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>q. (if q = Even then even else odd) a = winning_path q P\n  \\<forall>q.\n     (if p = Even then even else odd) q =\n     (\\<not> (if p** = Even then even else odd) q)\n\ngoal (1 subgoal):\n 1. winning_path p P = (\\<not> winning_path p** P)", "by blast"], ["proof (state)\nthis:\n  winning_path p P = (\\<not> winning_path p** P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  winning_path p P = (\\<not> winning_path p** P)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> lnull P \\<Longrightarrow>\n    winning_path p P = (\\<not> winning_path p** P)", "qed (simp add: winning_path_def)"], ["", "lemma winning_path_ltl:\n  assumes P: \"winning_path p P\" \"\\<not>lnull P\" \"\\<not>lnull (ltl P)\"\n  shows \"winning_path p (ltl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p (ltl P)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p (ltl P)\n 2. \\<not> ?P \\<Longrightarrow> winning_path p (ltl P)", "assume \"lfinite P\""], ["proof (state)\nthis:\n  lfinite P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p (ltl P)\n 2. \\<not> ?P \\<Longrightarrow> winning_path p (ltl P)", "moreover"], ["proof (state)\nthis:\n  lfinite P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p (ltl P)\n 2. \\<not> ?P \\<Longrightarrow> winning_path p (ltl P)", "have \"llast P = llast (ltl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast P = llast (ltl P)", "using P(2,3)"], ["proof (prove)\nusing this:\n  \\<not> lnull P\n  \\<not> lnull (ltl P)\n\ngoal (1 subgoal):\n 1. llast P = llast (ltl P)", "by (metis llast_LCons2 ltl_simps(2) not_lnull_conv)"], ["proof (state)\nthis:\n  llast P = llast (ltl P)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p (ltl P)\n 2. \\<not> ?P \\<Longrightarrow> winning_path p (ltl P)", "ultimately"], ["proof (chain)\npicking this:\n  lfinite P\n  llast P = llast (ltl P)", "show ?thesis"], ["proof (prove)\nusing this:\n  lfinite P\n  llast P = llast (ltl P)\n\ngoal (1 subgoal):\n 1. winning_path p (ltl P)", "using P"], ["proof (prove)\nusing this:\n  lfinite P\n  llast P = llast (ltl P)\n  winning_path p P\n  \\<not> lnull P\n  \\<not> lnull (ltl P)\n\ngoal (1 subgoal):\n 1. winning_path p (ltl P)", "by (simp add: winning_path_def)"], ["proof (state)\nthis:\n  winning_path p (ltl P)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow> winning_path p (ltl P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow> winning_path p (ltl P)", "assume \"\\<not>lfinite P\""], ["proof (state)\nthis:\n  \\<not> lfinite P\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow> winning_path p (ltl P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite P\n\ngoal (1 subgoal):\n 1. winning_path p (ltl P)", "using winning_path_def path_inf_priorities_ltl P(1,2)"], ["proof (prove)\nusing this:\n  \\<not> lfinite P\n  winning_path ?p ?P \\<equiv>\n  \\<not> lfinite ?P \\<and>\n  (\\<exists>a\\<in>path_inf_priorities ?P.\n      (\\<forall>b\\<in>path_inf_priorities ?P. a \\<le> b) \\<and>\n      (if ?p = Even then even else odd) a) \\<or>\n  \\<not> lnull ?P \\<and> lfinite ?P \\<and> llast ?P \\<in> VV ?p** \\<or>\n  lnull ?P \\<and> ?p = Even\n  path_inf_priorities ?P = path_inf_priorities (ltl ?P)\n  winning_path p P\n  \\<not> lnull P\n\ngoal (1 subgoal):\n 1. winning_path p (ltl P)", "by auto"], ["proof (state)\nthis:\n  winning_path p (ltl P)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary winning_path_drop:\n  assumes \"winning_path p P\" \"enat n < llength P\"\n  shows \"winning_path p (ldropn n P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p (ldropn n P)", "using assms"], ["proof (prove)\nusing this:\n  winning_path p P\n  enat n < llength P\n\ngoal (1 subgoal):\n 1. winning_path p (ldropn n P)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>winning_path p P; enat 0 < llength P\\<rbrakk>\n    \\<Longrightarrow> winning_path p (ldropn 0 P)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>winning_path p P; enat n < llength P\\<rbrakk>\n                \\<Longrightarrow> winning_path p (ldropn n P);\n        winning_path p P; enat (Suc n) < llength P\\<rbrakk>\n       \\<Longrightarrow> winning_path p (ldropn (Suc n) P)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>winning_path p P; enat n < llength P\\<rbrakk>\n  \\<Longrightarrow> winning_path p (ldropn n P)\n  winning_path p P\n  enat (Suc n) < llength P\n\ngoal (2 subgoals):\n 1. \\<lbrakk>winning_path p P; enat 0 < llength P\\<rbrakk>\n    \\<Longrightarrow> winning_path p (ldropn 0 P)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>winning_path p P; enat n < llength P\\<rbrakk>\n                \\<Longrightarrow> winning_path p (ldropn n P);\n        winning_path p P; enat (Suc n) < llength P\\<rbrakk>\n       \\<Longrightarrow> winning_path p (ldropn (Suc n) P)", "hence \"winning_path p (ldropn n P)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>winning_path p P; enat n < llength P\\<rbrakk>\n  \\<Longrightarrow> winning_path p (ldropn n P)\n  winning_path p P\n  enat (Suc n) < llength P\n\ngoal (1 subgoal):\n 1. winning_path p (ldropn n P)", "using dual_order.strict_trans enat_ord_simps(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>winning_path p P; enat n < llength P\\<rbrakk>\n  \\<Longrightarrow> winning_path p (ldropn n P)\n  winning_path p P\n  enat (Suc n) < llength P\n  \\<lbrakk>?b < ?a; ?c < ?b\\<rbrakk> \\<Longrightarrow> ?c < ?a\n  (enat ?m < enat ?n) = (?m < ?n)\n\ngoal (1 subgoal):\n 1. winning_path p (ldropn n P)", "by blast"], ["proof (state)\nthis:\n  winning_path p (ldropn n P)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>winning_path p P; enat 0 < llength P\\<rbrakk>\n    \\<Longrightarrow> winning_path p (ldropn 0 P)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>winning_path p P; enat n < llength P\\<rbrakk>\n                \\<Longrightarrow> winning_path p (ldropn n P);\n        winning_path p P; enat (Suc n) < llength P\\<rbrakk>\n       \\<Longrightarrow> winning_path p (ldropn (Suc n) P)", "moreover"], ["proof (state)\nthis:\n  winning_path p (ldropn n P)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>winning_path p P; enat 0 < llength P\\<rbrakk>\n    \\<Longrightarrow> winning_path p (ldropn 0 P)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>winning_path p P; enat n < llength P\\<rbrakk>\n                \\<Longrightarrow> winning_path p (ldropn n P);\n        winning_path p P; enat (Suc n) < llength P\\<rbrakk>\n       \\<Longrightarrow> winning_path p (ldropn (Suc n) P)", "have \"ltl (ldropn n P) = ldropn (Suc n) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (ldropn n P) = ldropn (Suc n) P", "by (simp add: ldrop_eSuc_ltl ltl_ldropn)"], ["proof (state)\nthis:\n  ltl (ldropn n P) = ldropn (Suc n) P\n\ngoal (2 subgoals):\n 1. \\<lbrakk>winning_path p P; enat 0 < llength P\\<rbrakk>\n    \\<Longrightarrow> winning_path p (ldropn 0 P)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>winning_path p P; enat n < llength P\\<rbrakk>\n                \\<Longrightarrow> winning_path p (ldropn n P);\n        winning_path p P; enat (Suc n) < llength P\\<rbrakk>\n       \\<Longrightarrow> winning_path p (ldropn (Suc n) P)", "moreover"], ["proof (state)\nthis:\n  ltl (ldropn n P) = ldropn (Suc n) P\n\ngoal (2 subgoals):\n 1. \\<lbrakk>winning_path p P; enat 0 < llength P\\<rbrakk>\n    \\<Longrightarrow> winning_path p (ldropn 0 P)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>winning_path p P; enat n < llength P\\<rbrakk>\n                \\<Longrightarrow> winning_path p (ldropn n P);\n        winning_path p P; enat (Suc n) < llength P\\<rbrakk>\n       \\<Longrightarrow> winning_path p (ldropn (Suc n) P)", "hence \"\\<not>lnull (ldropn n P)\""], ["proof (prove)\nusing this:\n  ltl (ldropn n P) = ldropn (Suc n) P\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ldropn n P)", "using Suc.prems(2)"], ["proof (prove)\nusing this:\n  ltl (ldropn n P) = ldropn (Suc n) P\n  enat (Suc n) < llength P\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ldropn n P)", "by (metis leD lnull_ldropn lnull_ltlI)"], ["proof (state)\nthis:\n  \\<not> lnull (ldropn n P)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>winning_path p P; enat 0 < llength P\\<rbrakk>\n    \\<Longrightarrow> winning_path p (ldropn 0 P)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>winning_path p P; enat n < llength P\\<rbrakk>\n                \\<Longrightarrow> winning_path p (ldropn n P);\n        winning_path p P; enat (Suc n) < llength P\\<rbrakk>\n       \\<Longrightarrow> winning_path p (ldropn (Suc n) P)", "ultimately"], ["proof (chain)\npicking this:\n  winning_path p (ldropn n P)\n  ltl (ldropn n P) = ldropn (Suc n) P\n  \\<not> lnull (ldropn n P)", "show ?case"], ["proof (prove)\nusing this:\n  winning_path p (ldropn n P)\n  ltl (ldropn n P) = ldropn (Suc n) P\n  \\<not> lnull (ldropn n P)\n\ngoal (1 subgoal):\n 1. winning_path p (ldropn (Suc n) P)", "using winning_path_ltl[of p \"ldropn n P\"] Suc.prems(2)"], ["proof (prove)\nusing this:\n  winning_path p (ldropn n P)\n  ltl (ldropn n P) = ldropn (Suc n) P\n  \\<not> lnull (ldropn n P)\n  \\<lbrakk>winning_path p (ldropn n P); \\<not> lnull (ldropn n P);\n   \\<not> lnull (ltl (ldropn n P))\\<rbrakk>\n  \\<Longrightarrow> winning_path p (ltl (ldropn n P))\n  enat (Suc n) < llength P\n\ngoal (1 subgoal):\n 1. winning_path p (ldropn (Suc n) P)", "by auto"], ["proof (state)\nthis:\n  winning_path p (ldropn (Suc n) P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>winning_path p P; enat 0 < llength P\\<rbrakk>\n    \\<Longrightarrow> winning_path p (ldropn 0 P)", "qed simp"], ["", "corollary winning_path_drop_add:\n  assumes \"valid_path P\" \"winning_path p (ldropn n P)\" \"enat n < llength P\"\n  shows \"winning_path p P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p P", "using assms paths_are_winning_for_one_player valid_path_drop winning_path_drop"], ["proof (prove)\nusing this:\n  valid_path P\n  winning_path p (ldropn n P)\n  enat n < llength P\n  valid_path ?P \\<Longrightarrow>\n  winning_path ?p ?P = (\\<not> winning_path ?p** ?P)\n  valid_path ?P \\<Longrightarrow> valid_path (ldropn ?n ?P)\n  \\<lbrakk>winning_path ?p ?P; enat ?n < llength ?P\\<rbrakk>\n  \\<Longrightarrow> winning_path ?p (ldropn ?n ?P)\n\ngoal (1 subgoal):\n 1. winning_path p P", "by blast"], ["", "lemma winning_path_LCons:\n  assumes P: \"winning_path p P\" \"\\<not>lnull P\"\n  shows \"winning_path p (LCons v P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p (LCons v P)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p (LCons v P)\n 2. \\<not> ?P \\<Longrightarrow> winning_path p (LCons v P)", "assume \"lfinite P\""], ["proof (state)\nthis:\n  lfinite P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p (LCons v P)\n 2. \\<not> ?P \\<Longrightarrow> winning_path p (LCons v P)", "moreover"], ["proof (state)\nthis:\n  lfinite P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p (LCons v P)\n 2. \\<not> ?P \\<Longrightarrow> winning_path p (LCons v P)", "have \"llast P = llast (LCons v P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast P = llast (LCons v P)", "using P(2)"], ["proof (prove)\nusing this:\n  \\<not> lnull P\n\ngoal (1 subgoal):\n 1. llast P = llast (LCons v P)", "by (metis llast_LCons2 not_lnull_conv)"], ["proof (state)\nthis:\n  llast P = llast (LCons v P)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p (LCons v P)\n 2. \\<not> ?P \\<Longrightarrow> winning_path p (LCons v P)", "ultimately"], ["proof (chain)\npicking this:\n  lfinite P\n  llast P = llast (LCons v P)", "show ?thesis"], ["proof (prove)\nusing this:\n  lfinite P\n  llast P = llast (LCons v P)\n\ngoal (1 subgoal):\n 1. winning_path p (LCons v P)", "using P"], ["proof (prove)\nusing this:\n  lfinite P\n  llast P = llast (LCons v P)\n  winning_path p P\n  \\<not> lnull P\n\ngoal (1 subgoal):\n 1. winning_path p (LCons v P)", "unfolding winning_path_def"], ["proof (prove)\nusing this:\n  lfinite P\n  llast P = llast (LCons v P)\n  \\<not> lfinite P \\<and>\n  (\\<exists>a\\<in>path_inf_priorities P.\n      (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n      (if p = Even then even else odd) a) \\<or>\n  \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> VV p** \\<or>\n  lnull P \\<and> p = Even\n  \\<not> lnull P\n\ngoal (1 subgoal):\n 1. \\<not> lfinite (LCons v P) \\<and>\n    (\\<exists>a\\<in>path_inf_priorities (LCons v P).\n        (\\<forall>b\\<in>path_inf_priorities (LCons v P). a \\<le> b) \\<and>\n        (if p = Even then even else odd) a) \\<or>\n    \\<not> lnull (LCons v P) \\<and>\n    lfinite (LCons v P) \\<and> llast (LCons v P) \\<in> VV p** \\<or>\n    lnull (LCons v P) \\<and> p = Even", "by simp"], ["proof (state)\nthis:\n  winning_path p (LCons v P)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow> winning_path p (LCons v P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow> winning_path p (LCons v P)", "assume \"\\<not>lfinite P\""], ["proof (state)\nthis:\n  \\<not> lfinite P\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<Longrightarrow> winning_path p (LCons v P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite P\n\ngoal (1 subgoal):\n 1. winning_path p (LCons v P)", "using P path_inf_priorities_LCons"], ["proof (prove)\nusing this:\n  \\<not> lfinite P\n  winning_path p P\n  \\<not> lnull P\n  path_inf_priorities ?P = path_inf_priorities (LCons ?v ?P)\n\ngoal (1 subgoal):\n 1. winning_path p (LCons v P)", "unfolding winning_path_def"], ["proof (prove)\nusing this:\n  \\<not> lfinite P\n  \\<not> lfinite P \\<and>\n  (\\<exists>a\\<in>path_inf_priorities P.\n      (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n      (if p = Even then even else odd) a) \\<or>\n  \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> VV p** \\<or>\n  lnull P \\<and> p = Even\n  \\<not> lnull P\n  path_inf_priorities ?P = path_inf_priorities (LCons ?v ?P)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite (LCons v P) \\<and>\n    (\\<exists>a\\<in>path_inf_priorities (LCons v P).\n        (\\<forall>b\\<in>path_inf_priorities (LCons v P). a \\<le> b) \\<and>\n        (if p = Even then even else odd) a) \\<or>\n    \\<not> lnull (LCons v P) \\<and>\n    lfinite (LCons v P) \\<and> llast (LCons v P) \\<in> VV p** \\<or>\n    lnull (LCons v P) \\<and> p = Even", "by simp"], ["proof (state)\nthis:\n  winning_path p (LCons v P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma winning_path_supergame:\n  assumes \"winning_path p P\"\n  and G': \"ParityGame G'\" \"VV p** \\<subseteq> ParityGame.VV G' p**\" \"\\<omega> = \\<omega>\\<^bsub>G'\\<^esub>\"\n  shows \"ParityGame.winning_path G' p P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ParityGame.winning_path G' p P", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ParityGame.winning_path G' p P", "interpret G': ParityGame G'"], ["proof (prove)\ngoal (1 subgoal):\n 1. ParityGame G'", "using G'(1)"], ["proof (prove)\nusing this:\n  ParityGame G'\n\ngoal (1 subgoal):\n 1. ParityGame G'", "."], ["proof (state)\ngoal (1 subgoal):\n 1. G'.winning_path p P", "have \"\\<lbrakk> lfinite P; \\<not>lnull P \\<rbrakk> \\<Longrightarrow> llast P \\<in> G'.VV p**\" and \"lnull P \\<Longrightarrow> p = Even\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>lfinite P; \\<not> lnull P\\<rbrakk>\n     \\<Longrightarrow> llast P \\<in> G'.VV p**) &&&\n    (lnull P \\<Longrightarrow> p = Even)", "using assms(1)"], ["proof (prove)\nusing this:\n  winning_path p P\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>lfinite P; \\<not> lnull P\\<rbrakk>\n     \\<Longrightarrow> llast P \\<in> G'.VV p**) &&&\n    (lnull P \\<Longrightarrow> p = Even)", "unfolding winning_path_def"], ["proof (prove)\nusing this:\n  \\<not> lfinite P \\<and>\n  (\\<exists>a\\<in>path_inf_priorities P.\n      (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n      (if p = Even then even else odd) a) \\<or>\n  \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> VV p** \\<or>\n  lnull P \\<and> p = Even\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>lfinite P; \\<not> lnull P\\<rbrakk>\n     \\<Longrightarrow> llast P \\<in> G'.VV p**) &&&\n    (lnull P \\<Longrightarrow> p = Even)", "using G'(2)"], ["proof (prove)\nusing this:\n  \\<not> lfinite P \\<and>\n  (\\<exists>a\\<in>path_inf_priorities P.\n      (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n      (if p = Even then even else odd) a) \\<or>\n  \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> VV p** \\<or>\n  lnull P \\<and> p = Even\n  VV p** \\<subseteq> G'.VV p**\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>lfinite P; \\<not> lnull P\\<rbrakk>\n     \\<Longrightarrow> llast P \\<in> G'.VV p**) &&&\n    (lnull P \\<Longrightarrow> p = Even)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>lfinite P; \\<not> lnull P\\<rbrakk>\n  \\<Longrightarrow> llast P \\<in> G'.VV p**\n  lnull P \\<Longrightarrow> p = Even\n\ngoal (1 subgoal):\n 1. G'.winning_path p P", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>lfinite P; \\<not> lnull P\\<rbrakk>\n  \\<Longrightarrow> llast P \\<in> G'.VV p**\n  lnull P \\<Longrightarrow> p = Even\n\ngoal (1 subgoal):\n 1. G'.winning_path p P", "unfolding G'.winning_path_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>lfinite P; \\<not> lnull P\\<rbrakk>\n  \\<Longrightarrow> llast P \\<in> G'.VV p**\n  lnull P \\<Longrightarrow> p = Even\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<and>\n    (\\<exists>a\\<in>G'.path_inf_priorities P.\n        (\\<forall>b\\<in>G'.path_inf_priorities P. a \\<le> b) \\<and>\n        (if p = Even then even else odd) a) \\<or>\n    \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> G'.VV p** \\<or>\n    lnull P \\<and> p = Even", "using lnull_imp_lfinite assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>lfinite P; \\<not> lnull P\\<rbrakk>\n  \\<Longrightarrow> llast P \\<in> G'.VV p**\n  lnull P \\<Longrightarrow> p = Even\n  lnull ?xs \\<Longrightarrow> lfinite ?xs\n  winning_path p P\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<and>\n    (\\<exists>a\\<in>G'.path_inf_priorities P.\n        (\\<forall>b\\<in>G'.path_inf_priorities P. a \\<le> b) \\<and>\n        (if p = Even then even else odd) a) \\<or>\n    \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> G'.VV p** \\<or>\n    lnull P \\<and> p = Even", "unfolding winning_path_def path_inf_priorities_def G'.path_inf_priorities_def G'(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>lfinite P; \\<not> lnull P\\<rbrakk>\n  \\<Longrightarrow> llast P \\<in> G'.VV p**\n  lnull P \\<Longrightarrow> p = Even\n  lnull ?xs \\<Longrightarrow> lfinite ?xs\n  \\<not> lfinite P \\<and>\n  (\\<exists>a\\<in>{k. \\<forall>n.\n                         k \\<in> lset\n                                  (ldropn n\n                                    (lmap \\<omega>\\<^bsub>G'\\<^esub> P))}.\n      (\\<forall>b\\<in>{k. \\<forall>n.\n                             k \\<in> lset\n(ldropn n (lmap \\<omega>\\<^bsub>G'\\<^esub> P))}.\n          a \\<le> b) \\<and>\n      (if p = Even then even else odd) a) \\<or>\n  \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> VV p** \\<or>\n  lnull P \\<and> p = Even\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<and>\n    (\\<exists>a\\<in>{k. \\<forall>n.\n                           k \\<in> lset\n                                    (ldropn n\n(lmap \\<omega>\\<^bsub>G'\\<^esub> P))}.\n        (\\<forall>b\\<in>{k. \\<forall>n.\n                               k \\<in> lset\n  (ldropn n (lmap \\<omega>\\<^bsub>G'\\<^esub> P))}.\n            a \\<le> b) \\<and>\n        (if p = Even then even else odd) a) \\<or>\n    \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> G'.VV p** \\<or>\n    lnull P \\<and> p = Even", "by blast"], ["proof (state)\nthis:\n  G'.winning_path p P\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>locale ParityGame\\<close>"], ["", "subsection \\<open>Valid Maximal Paths\\<close>"], ["", "text \\<open>Define a locale for valid maximal paths, because we need them often.\\<close>"], ["", "locale vm_path = ParityGame +\n  fixes P v0\n  assumes P_not_null [simp]: \"\\<not>lnull P\"\n      and P_valid    [simp]: \"valid_path P\"\n      and P_maximal  [simp]: \"maximal_path P\"\n      and P_v0       [simp]: \"lhd P = v0\"\nbegin"], ["", "lemma P_LCons: \"P = LCons v0 (ltl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = LCons v0 (ltl P)", "using lhd_LCons_ltl[OF P_not_null]"], ["proof (prove)\nusing this:\n  LCons (lhd P) (ltl P) = P\n\ngoal (1 subgoal):\n 1. P = LCons v0 (ltl P)", "by simp"], ["", "lemma P_len [simp]: \"enat 0 < llength P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat 0 < llength P", "by (simp add: lnull_0_llength)"], ["", "lemma P_0 [simp]: \"P $ 0 = v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P $ 0 = v0", "by (simp add: lnth_0_conv_lhd)"], ["", "lemma P_lnth_Suc: \"P $ Suc n = ltl P $ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P $ Suc n = ltl P $ n", "by (simp add: lnth_ltl)"], ["", "lemma P_no_deadends: \"enat (Suc n) < llength P \\<Longrightarrow> \\<not>deadend (P $ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (Suc n) < llength P \\<Longrightarrow> \\<not> deadend (P $ n)", "using valid_path_no_deadends"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_path ?P; enat (Suc ?i) < llength ?P\\<rbrakk>\n  \\<Longrightarrow> \\<not> deadend (?P $ ?i)\n\ngoal (1 subgoal):\n 1. enat (Suc n) < llength P \\<Longrightarrow> \\<not> deadend (P $ n)", "by simp"], ["", "lemma P_no_deadend_v0: \"\\<not>lnull (ltl P) \\<Longrightarrow> \\<not>deadend v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl P) \\<Longrightarrow> \\<not> deadend v0", "by (metis P_LCons P_valid edges_are_in_V(2) not_lnull_conv valid_path_edges')"], ["", "lemma P_no_deadend_v0_llength: \"enat (Suc n) < llength P \\<Longrightarrow> \\<not>deadend v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (Suc n) < llength P \\<Longrightarrow> \\<not> deadend v0", "by (metis P_0 P_len P_valid enat_ord_simps(2) not_less_eq valid_path_ends_on_deadend zero_less_Suc)"], ["", "lemma P_ends_on_deadend: \"\\<lbrakk> enat n < llength P; deadend (P $ n) \\<rbrakk> \\<Longrightarrow> enat (Suc n) = llength P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enat n < llength P; deadend (P $ n)\\<rbrakk>\n    \\<Longrightarrow> enat (Suc n) = llength P", "using P_valid valid_path_ends_on_deadend"], ["proof (prove)\nusing this:\n  valid_path P\n  \\<lbrakk>valid_path ?P; enat ?i < llength ?P; deadend (?P $ ?i)\\<rbrakk>\n  \\<Longrightarrow> enat (Suc ?i) = llength ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enat n < llength P; deadend (P $ n)\\<rbrakk>\n    \\<Longrightarrow> enat (Suc n) = llength P", "by blast"], ["", "lemma P_lnull_ltl_deadend_v0: \"lnull (ltl P) \\<Longrightarrow> deadend v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (ltl P) \\<Longrightarrow> deadend v0", "using P_LCons maximal_no_deadend"], ["proof (prove)\nusing this:\n  P = LCons v0 (ltl P)\n  \\<lbrakk>maximal_path (LCons ?v ?Ps); \\<not> deadend ?v\\<rbrakk>\n  \\<Longrightarrow> \\<not> lnull ?Ps\n\ngoal (1 subgoal):\n 1. lnull (ltl P) \\<Longrightarrow> deadend v0", "by force"], ["", "lemma P_lnull_ltl_LCons: \"lnull (ltl P) \\<Longrightarrow> P = LCons v0 LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (ltl P) \\<Longrightarrow> P = LCons v0 LNil", "using P_LCons lnull_def"], ["proof (prove)\nusing this:\n  P = LCons v0 (ltl P)\n  lnull ?llist = (?llist = LNil)\n\ngoal (1 subgoal):\n 1. lnull (ltl P) \\<Longrightarrow> P = LCons v0 LNil", "by metis"], ["", "lemma P_deadend_v0_LCons: \"deadend v0 \\<Longrightarrow> P = LCons v0 LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deadend v0 \\<Longrightarrow> P = LCons v0 LNil", "using P_lnull_ltl_LCons P_no_deadend_v0"], ["proof (prove)\nusing this:\n  lnull (ltl P) \\<Longrightarrow> P = LCons v0 LNil\n  \\<not> lnull (ltl P) \\<Longrightarrow> \\<not> deadend v0\n\ngoal (1 subgoal):\n 1. deadend v0 \\<Longrightarrow> P = LCons v0 LNil", "by blast"], ["", "lemma Ptl_valid [simp]: \"valid_path (ltl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (ltl P)", "using valid_path_ltl"], ["proof (prove)\nusing this:\n  valid_path ?P \\<Longrightarrow> valid_path (ltl ?P)\n\ngoal (1 subgoal):\n 1. valid_path (ltl P)", "by auto"], ["", "lemma Ptl_maximal [simp]: \"maximal_path (ltl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_path (ltl P)", "using maximal_ltl"], ["proof (prove)\nusing this:\n  maximal_path ?P \\<Longrightarrow> maximal_path (ltl ?P)\n\ngoal (1 subgoal):\n 1. maximal_path (ltl P)", "by auto"], ["", "lemma Pdrop_valid [simp]: \"valid_path (ldropn n P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (ldropn n P)", "using valid_path_drop"], ["proof (prove)\nusing this:\n  valid_path ?P \\<Longrightarrow> valid_path (ldropn ?n ?P)\n\ngoal (1 subgoal):\n 1. valid_path (ldropn n P)", "by auto"], ["", "lemma Pdrop_maximal [simp]: \"maximal_path (ldropn n P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_path (ldropn n P)", "using maximal_drop"], ["proof (prove)\nusing this:\n  maximal_path ?P \\<Longrightarrow> maximal_path (ldropn ?n ?P)\n\ngoal (1 subgoal):\n 1. maximal_path (ldropn n P)", "by auto"], ["", "lemma prefix_valid [simp]: \"valid_path (ltake n P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (ltake n P)", "using valid_path_prefix[of P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_path P; lprefix ?P' P\\<rbrakk>\n  \\<Longrightarrow> valid_path ?P'\n\ngoal (1 subgoal):\n 1. valid_path (ltake n P)", "by auto"], ["", "lemma extension_valid [simp]: \"v\\<rightarrow>v0 \\<Longrightarrow> valid_path (LCons v P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<rightarrow> v0 \\<Longrightarrow> valid_path (LCons v P)", "using P_not_null P_v0 P_valid valid_path_cons"], ["proof (prove)\nusing this:\n  \\<not> lnull P\n  lhd P = v0\n  valid_path P\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V; ?v \\<rightarrow> ?w; valid_path ?Ps;\n   \\<not> lnull ?Ps; lhd ?Ps = ?w\\<rbrakk>\n  \\<Longrightarrow> valid_path (LCons ?v ?Ps)\n\ngoal (1 subgoal):\n 1. v \\<rightarrow> v0 \\<Longrightarrow> valid_path (LCons v P)", "by blast"], ["", "lemma extension_maximal [simp]: \"maximal_path (LCons v P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_path (LCons v P)", "by (simp add: maximal_path_cons)"], ["", "lemma lappend_maximal [simp]: \"maximal_path (lappend P' P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_path (lappend P' P)", "by (simp add: maximal_path_lappend)"], ["", "lemma v0_V [simp]: \"v0 \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<in> V", "by (metis P_LCons P_valid valid_path_cons_simp)"], ["", "lemma v0_lset_P [simp]: \"v0 \\<in> lset P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<in> lset P", "using P_not_null P_v0 llist.set_sel(1)"], ["proof (prove)\nusing this:\n  \\<not> lnull P\n  lhd P = v0\n  \\<not> lnull ?a \\<Longrightarrow> lhd ?a \\<in> lset ?a\n\ngoal (1 subgoal):\n 1. v0 \\<in> lset P", "by blast"], ["", "lemma v0_VV: \"v0 \\<in> VV p \\<or> v0 \\<in> VV p**\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<in> VV p \\<or> v0 \\<in> VV p**", "by simp"], ["", "lemma lset_P_V [simp]: \"lset P \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset P \\<subseteq> V", "by (simp add: valid_path_in_V)"], ["", "lemma lset_ltl_P_V [simp]: \"lset (ltl P) \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (ltl P) \\<subseteq> V", "by (simp add: valid_path_in_V)"], ["", "lemma finite_llast_deadend [simp]: \"lfinite P \\<Longrightarrow> deadend (llast P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite P \\<Longrightarrow> deadend (llast P)", "using P_maximal P_not_null maximal_ends_on_deadend"], ["proof (prove)\nusing this:\n  maximal_path P\n  \\<not> lnull P\n  \\<lbrakk>maximal_path ?P; lfinite ?P; \\<not> lnull ?P\\<rbrakk>\n  \\<Longrightarrow> deadend (llast ?P)\n\ngoal (1 subgoal):\n 1. lfinite P \\<Longrightarrow> deadend (llast P)", "by blast"], ["", "lemma finite_llast_V [simp]: \"lfinite P \\<Longrightarrow> llast P \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite P \\<Longrightarrow> llast P \\<in> V", "using P_not_null lfinite_lset lset_P_V"], ["proof (prove)\nusing this:\n  \\<not> lnull P\n  \\<lbrakk>lfinite ?xs; \\<not> lnull ?xs\\<rbrakk>\n  \\<Longrightarrow> llast ?xs \\<in> lset ?xs\n  lset P \\<subseteq> V\n\ngoal (1 subgoal):\n 1. lfinite P \\<Longrightarrow> llast P \\<in> V", "by blast"], ["", "text \\<open>If a path visits a deadend, it is winning for the other player.\\<close>"], ["", "lemma visits_deadend:\n  assumes \"lset P \\<inter> deadends p \\<noteq> {}\"\n  shows \"winning_path p** P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p** P", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. winning_path p** P", "obtain n where n: \"enat n < llength P\" \"P $ n \\<in> deadends p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>enat n < llength P; P $ n \\<in> deadends p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  lset P \\<inter> deadends p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>enat n < llength P; P $ n \\<in> deadends p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson lset_intersect_lnth)"], ["proof (state)\nthis:\n  enat n < llength P\n  P $ n \\<in> deadends p\n\ngoal (1 subgoal):\n 1. winning_path p** P", "hence *: \"enat (Suc n) = llength P\""], ["proof (prove)\nusing this:\n  enat n < llength P\n  P $ n \\<in> deadends p\n\ngoal (1 subgoal):\n 1. enat (Suc n) = llength P", "using P_ends_on_deadend"], ["proof (prove)\nusing this:\n  enat n < llength P\n  P $ n \\<in> deadends p\n  \\<lbrakk>enat ?n < llength P; deadend (P $ ?n)\\<rbrakk>\n  \\<Longrightarrow> enat (Suc ?n) = llength P\n\ngoal (1 subgoal):\n 1. enat (Suc n) = llength P", "unfolding deadends_def"], ["proof (prove)\nusing this:\n  enat n < llength P\n  P $ n \\<in> {v \\<in> VV p. deadend v}\n  \\<lbrakk>enat ?n < llength P; deadend (P $ ?n)\\<rbrakk>\n  \\<Longrightarrow> enat (Suc ?n) = llength P\n\ngoal (1 subgoal):\n 1. enat (Suc n) = llength P", "by blast"], ["proof (state)\nthis:\n  enat (Suc n) = llength P\n\ngoal (1 subgoal):\n 1. winning_path p** P", "hence \"llast P = P $ n\""], ["proof (prove)\nusing this:\n  enat (Suc n) = llength P\n\ngoal (1 subgoal):\n 1. llast P = P $ n", "by (simp add: eSuc_enat llast_conv_lnth)"], ["proof (state)\nthis:\n  llast P = P $ n\n\ngoal (1 subgoal):\n 1. winning_path p** P", "hence \"llast P \\<in> deadends p\""], ["proof (prove)\nusing this:\n  llast P = P $ n\n\ngoal (1 subgoal):\n 1. llast P \\<in> deadends p", "using n(2)"], ["proof (prove)\nusing this:\n  llast P = P $ n\n  P $ n \\<in> deadends p\n\ngoal (1 subgoal):\n 1. llast P \\<in> deadends p", "by simp"], ["proof (state)\nthis:\n  llast P \\<in> deadends p\n\ngoal (1 subgoal):\n 1. winning_path p** P", "moreover"], ["proof (state)\nthis:\n  llast P \\<in> deadends p\n\ngoal (1 subgoal):\n 1. winning_path p** P", "have \"lfinite P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite P", "using * llength_eq_enat_lfiniteD"], ["proof (prove)\nusing this:\n  enat (Suc n) = llength P\n  llength ?xs = enat ?n \\<Longrightarrow> lfinite ?xs\n\ngoal (1 subgoal):\n 1. lfinite P", "by force"], ["proof (state)\nthis:\n  lfinite P\n\ngoal (1 subgoal):\n 1. winning_path p** P", "ultimately"], ["proof (chain)\npicking this:\n  llast P \\<in> deadends p\n  lfinite P", "show ?thesis"], ["proof (prove)\nusing this:\n  llast P \\<in> deadends p\n  lfinite P\n\ngoal (1 subgoal):\n 1. winning_path p** P", "unfolding winning_path_def deadends_def"], ["proof (prove)\nusing this:\n  llast P \\<in> {v \\<in> VV p. deadend v}\n  lfinite P\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<and>\n    (\\<exists>a\\<in>path_inf_priorities P.\n        (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n        (if p** = Even then even else odd) a) \\<or>\n    \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> VV p**** \\<or>\n    lnull P \\<and> p** = Even", "by auto"], ["proof (state)\nthis:\n  winning_path p** P\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}