{"file_name": "/home/qj213/afp-2021-10-22/thys/Parity_Game/WinningStrategy.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Parity_Game", "problem_names": ["lemma winning_strategyI [intro]:\n  assumes \"\\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P\"\n  shows \"winning_strategy p \\<sigma> v0\"", "lemma (in vmc_path) paths_hits_winning_strategy_is_winning:\n  assumes \\<sigma>: \"winning_strategy p \\<sigma> v\"\n    and v: \"v \\<in> lset P\"\n  shows \"winning_path p P\"", "lemma winning_strategy_only_for_one_player:\n  assumes \\<sigma>: \"strategy p \\<sigma>\" \"winning_strategy p \\<sigma> v\"\n    and \\<sigma>': \"strategy p** \\<sigma>'\" \"winning_strategy p** \\<sigma>' v\"\n    and v: \"v \\<in> V\"\n  shows \"False\"", "lemma no_winning_strategy_on_deadends:\n  assumes \"v \\<in> VV p\" \"deadend v\" \"strategy p \\<sigma>\"\n  shows \"\\<not>winning_strategy p \\<sigma> v\"", "lemma winning_strategy_on_deadends:\n  assumes \"v \\<in> VV p\" \"deadend v\" \"strategy p \\<sigma>\"\n  shows \"winning_strategy p** \\<sigma> v\"", "lemma strategy_extends_VVp:\n  assumes v0: \"v0 \\<in> VV p\" \"\\<not>deadend v0\"\n  and \\<sigma>: \"strategy p \\<sigma>\" \"winning_strategy p \\<sigma> v0\"\n  shows \"winning_strategy p \\<sigma> (\\<sigma> v0)\"", "lemma strategy_extends_VVpstar:\n  assumes v0: \"v0 \\<in> VV p**\" \"v0\\<rightarrow>w0\"\n  and \\<sigma>: \"winning_strategy p \\<sigma> v0\"\n  shows \"winning_strategy p \\<sigma> w0\"", "lemma strategy_extends_backwards_VVpstar:\n  assumes v0: \"v0 \\<in> VV p**\"\n    and \\<sigma>: \"strategy p \\<sigma>\" \"\\<And>w. v0\\<rightarrow>w \\<Longrightarrow> winning_strategy p \\<sigma> w\"\n  shows \"winning_strategy p \\<sigma> v0\"", "lemma strategy_extends_backwards_VVp:\n  assumes v0: \"v0 \\<in> VV p\" \"\\<sigma> v0 = w\" \"v0\\<rightarrow>w\"\n    and \\<sigma>: \"strategy p \\<sigma>\" \"winning_strategy p \\<sigma> w\"\n  shows \"winning_strategy p \\<sigma> v0\""], "translations": [["", "lemma winning_strategyI [intro]:\n  assumes \"\\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P\"\n  shows \"winning_strategy p \\<sigma> v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_strategy p \\<sigma> v0", "unfolding winning_strategy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P.\n       vmc_path G P v0 p \\<sigma> \\<longrightarrow> winning_path p P", "using assms"], ["proof (prove)\nusing this:\n  vmc_path G ?P v0 p \\<sigma> \\<Longrightarrow> winning_path p ?P\n\ngoal (1 subgoal):\n 1. \\<forall>P.\n       vmc_path G P v0 p \\<sigma> \\<longrightarrow> winning_path p P", "by blast"], ["", "lemma (in vmc_path) paths_hits_winning_strategy_is_winning:\n  assumes \\<sigma>: \"winning_strategy p \\<sigma> v\"\n    and v: \"v \\<in> lset P\"\n  shows \"winning_path p P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p P", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. winning_path p P", "obtain n where n: \"enat n < llength P\" \"P $ n = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>enat n < llength P; P $ n = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using v"], ["proof (prove)\nusing this:\n  v \\<in> lset P\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>enat n < llength P; P $ n = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson in_lset_conv_lnth)"], ["proof (state)\nthis:\n  enat n < llength P\n  P $ n = v\n\ngoal (1 subgoal):\n 1. winning_path p P", "interpret P': vmc_path G \"ldropn n P\" v p \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vmc_path G (ldropn n P) v p \\<sigma>", "using n vmc_path_ldropn"], ["proof (prove)\nusing this:\n  enat n < llength P\n  P $ n = v\n  enat ?n < llength P \\<Longrightarrow>\n  vmc_path G (ldropn ?n P) (P $ ?n) p \\<sigma>\n\ngoal (1 subgoal):\n 1. vmc_path G (ldropn n P) v p \\<sigma>", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. winning_path p P", "have \"winning_path p (ldropn n P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p (ldropn n P)", "using \\<sigma>"], ["proof (prove)\nusing this:\n  winning_strategy p \\<sigma> v\n\ngoal (1 subgoal):\n 1. winning_path p (ldropn n P)", "by (simp add: winning_strategy_def P'.vmc_path_axioms)"], ["proof (state)\nthis:\n  winning_path p (ldropn n P)\n\ngoal (1 subgoal):\n 1. winning_path p P", "thus ?thesis"], ["proof (prove)\nusing this:\n  winning_path p (ldropn n P)\n\ngoal (1 subgoal):\n 1. winning_path p P", "using winning_path_drop_add P_valid n(1)"], ["proof (prove)\nusing this:\n  winning_path p (ldropn n P)\n  \\<lbrakk>valid_path ?P; winning_path ?p (ldropn ?n ?P);\n   enat ?n < llength ?P\\<rbrakk>\n  \\<Longrightarrow> winning_path ?p ?P\n  valid_path P\n  enat n < llength P\n\ngoal (1 subgoal):\n 1. winning_path p P", "by blast"], ["proof (state)\nthis:\n  winning_path p P\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>There cannot exist winning strategies for both players for the same node.\\<close>"], ["", "lemma winning_strategy_only_for_one_player:\n  assumes \\<sigma>: \"strategy p \\<sigma>\" \"winning_strategy p \\<sigma> v\"\n    and \\<sigma>': \"strategy p** \\<sigma>'\" \"winning_strategy p** \\<sigma>' v\"\n    and v: \"v \\<in> V\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "obtain P where \"vmc2_path G P v p \\<sigma> \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        vmc2_path G P v p \\<sigma> \\<sigma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms strategy_conforming_path_exists"], ["proof (prove)\nusing this:\n  strategy p \\<sigma>\n  winning_strategy p \\<sigma> v\n  strategy p** \\<sigma>'\n  winning_strategy p** \\<sigma>' v\n  v \\<in> V\n  \\<lbrakk>?v0.0 \\<in> V; strategy ?p ?\\<sigma>; strategy ?p** ?\\<sigma>';\n   \\<And>P.\n      vmc2_path G P ?v0.0 ?p ?\\<sigma> ?\\<sigma>' \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        vmc2_path G P v p \\<sigma> \\<sigma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vmc2_path G P v p \\<sigma> \\<sigma>'\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  vmc2_path G P v p \\<sigma> \\<sigma>'", "interpret vmc2_path G P v p \\<sigma> \\<sigma>'"], ["proof (prove)\nusing this:\n  vmc2_path G P v p \\<sigma> \\<sigma>'\n\ngoal (1 subgoal):\n 1. vmc2_path G P v p \\<sigma> \\<sigma>'", "."], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"winning_path p P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p P", "using paths_hits_winning_strategy_is_winning \\<sigma>(2) v0_lset_P"], ["proof (prove)\nusing this:\n  \\<lbrakk>winning_strategy p \\<sigma> ?v; ?v \\<in> lset P\\<rbrakk>\n  \\<Longrightarrow> winning_path p P\n  winning_strategy p \\<sigma> v\n  v \\<in> lset P\n\ngoal (1 subgoal):\n 1. winning_path p P", "by blast"], ["proof (state)\nthis:\n  winning_path p P\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  winning_path p P\n\ngoal (1 subgoal):\n 1. False", "have \"winning_path p** P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p** P", "using comp.paths_hits_winning_strategy_is_winning \\<sigma>'(2) v0_lset_P"], ["proof (prove)\nusing this:\n  \\<lbrakk>winning_strategy p** \\<sigma>' ?v; ?v \\<in> lset P\\<rbrakk>\n  \\<Longrightarrow> winning_path p** P\n  winning_strategy p** \\<sigma>' v\n  v \\<in> lset P\n\ngoal (1 subgoal):\n 1. winning_path p** P", "by blast"], ["proof (state)\nthis:\n  winning_path p** P\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  winning_path p P\n  winning_path p** P", "show False"], ["proof (prove)\nusing this:\n  winning_path p P\n  winning_path p** P\n\ngoal (1 subgoal):\n 1. False", "using P_valid paths_are_winning_for_one_player"], ["proof (prove)\nusing this:\n  winning_path p P\n  winning_path p** P\n  valid_path P\n  valid_path ?P \\<Longrightarrow>\n  winning_path ?p ?P = (\\<not> winning_path ?p** ?P)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Deadends\\<close>"], ["", "lemma no_winning_strategy_on_deadends:\n  assumes \"v \\<in> VV p\" \"deadend v\" \"strategy p \\<sigma>\"\n  shows \"\\<not>winning_strategy p \\<sigma> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> winning_strategy p \\<sigma> v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> winning_strategy p \\<sigma> v", "obtain P where \"vmc_path G P v p \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        vmc_path G P v p \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using strategy_conforming_path_exists_single assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v0.0 \\<in> V; strategy ?p ?\\<sigma>;\n   \\<And>P.\n      vmc_path G P ?v0.0 ?p ?\\<sigma> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  v \\<in> VV p\n  deadend v\n  strategy p \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        vmc_path G P v p \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vmc_path G P v p \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> winning_strategy p \\<sigma> v", "then"], ["proof (chain)\npicking this:\n  vmc_path G P v p \\<sigma>", "interpret vmc_path G P v p \\<sigma>"], ["proof (prove)\nusing this:\n  vmc_path G P v p \\<sigma>\n\ngoal (1 subgoal):\n 1. vmc_path G P v p \\<sigma>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> winning_strategy p \\<sigma> v", "have \"P = LCons v LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = LCons v LNil", "using P_deadend_v0_LCons \\<open>deadend v\\<close>"], ["proof (prove)\nusing this:\n  deadend v \\<Longrightarrow> P = LCons v LNil\n  deadend v\n\ngoal (1 subgoal):\n 1. P = LCons v LNil", "by blast"], ["proof (state)\nthis:\n  P = LCons v LNil\n\ngoal (1 subgoal):\n 1. \\<not> winning_strategy p \\<sigma> v", "hence \"\\<not>winning_path p P\""], ["proof (prove)\nusing this:\n  P = LCons v LNil\n\ngoal (1 subgoal):\n 1. \\<not> winning_path p P", "unfolding winning_path_def"], ["proof (prove)\nusing this:\n  P = LCons v LNil\n\ngoal (1 subgoal):\n 1. \\<not> (\\<not> lfinite P \\<and>\n            (\\<exists>a\\<in>path_inf_priorities P.\n                (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n                (if p = Even then even else odd) a) \\<or>\n            \\<not> lnull P \\<and>\n            lfinite P \\<and> llast P \\<in> VV p** \\<or>\n            lnull P \\<and> p = Even)", "using \\<open>v \\<in> VV p\\<close>"], ["proof (prove)\nusing this:\n  P = LCons v LNil\n  v \\<in> VV p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<not> lfinite P \\<and>\n            (\\<exists>a\\<in>path_inf_priorities P.\n                (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n                (if p = Even then even else odd) a) \\<or>\n            \\<not> lnull P \\<and>\n            lfinite P \\<and> llast P \\<in> VV p** \\<or>\n            lnull P \\<and> p = Even)", "by auto"], ["proof (state)\nthis:\n  \\<not> winning_path p P\n\ngoal (1 subgoal):\n 1. \\<not> winning_strategy p \\<sigma> v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> winning_path p P\n\ngoal (1 subgoal):\n 1. \\<not> winning_strategy p \\<sigma> v", "using winning_strategy_def vmc_path_axioms"], ["proof (prove)\nusing this:\n  \\<not> winning_path p P\n  winning_strategy ?p ?\\<sigma> ?v0.0 \\<equiv>\n  \\<forall>P.\n     vmc_path G P ?v0.0 ?p ?\\<sigma> \\<longrightarrow> winning_path ?p P\n  vmc_path G P v p \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> winning_strategy p \\<sigma> v", "by blast"], ["proof (state)\nthis:\n  \\<not> winning_strategy p \\<sigma> v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma winning_strategy_on_deadends:\n  assumes \"v \\<in> VV p\" \"deadend v\" \"strategy p \\<sigma>\"\n  shows \"winning_strategy p** \\<sigma> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_strategy p** \\<sigma> v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       vmc_path G P v p** \\<sigma> \\<Longrightarrow> winning_path p** P", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       vmc_path G P v p** \\<sigma> \\<Longrightarrow> winning_path p** P", "assume \"vmc_path G P v p** \\<sigma>\""], ["proof (state)\nthis:\n  vmc_path G P v p** \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       vmc_path G P v p** \\<sigma> \\<Longrightarrow> winning_path p** P", "then"], ["proof (chain)\npicking this:\n  vmc_path G P v p** \\<sigma>", "interpret vmc_path G P v \"p**\" \\<sigma>"], ["proof (prove)\nusing this:\n  vmc_path G P v p** \\<sigma>\n\ngoal (1 subgoal):\n 1. vmc_path G P v p** \\<sigma>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       vmc_path G P v p** \\<sigma> \\<Longrightarrow> winning_path p** P", "have \"P = LCons v LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = LCons v LNil", "using P_deadend_v0_LCons \\<open>deadend v\\<close>"], ["proof (prove)\nusing this:\n  deadend v \\<Longrightarrow> P = LCons v LNil\n  deadend v\n\ngoal (1 subgoal):\n 1. P = LCons v LNil", "by blast"], ["proof (state)\nthis:\n  P = LCons v LNil\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       vmc_path G P v p** \\<sigma> \\<Longrightarrow> winning_path p** P", "thus \"winning_path p** P\""], ["proof (prove)\nusing this:\n  P = LCons v LNil\n\ngoal (1 subgoal):\n 1. winning_path p** P", "unfolding winning_path_def"], ["proof (prove)\nusing this:\n  P = LCons v LNil\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<and>\n    (\\<exists>a\\<in>path_inf_priorities P.\n        (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n        (if p** = Even then even else odd) a) \\<or>\n    \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> VV p**** \\<or>\n    lnull P \\<and> p** = Even", "using \\<open>v \\<in> VV p\\<close> P_valid paths_are_winning_for_one_player"], ["proof (prove)\nusing this:\n  P = LCons v LNil\n  v \\<in> VV p\n  valid_path P\n  valid_path ?P \\<Longrightarrow>\n  winning_path ?p ?P = (\\<not> winning_path ?p** ?P)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite P \\<and>\n    (\\<exists>a\\<in>path_inf_priorities P.\n        (\\<forall>b\\<in>path_inf_priorities P. a \\<le> b) \\<and>\n        (if p** = Even then even else odd) a) \\<or>\n    \\<not> lnull P \\<and> lfinite P \\<and> llast P \\<in> VV p**** \\<or>\n    lnull P \\<and> p** = Even", "by auto"], ["proof (state)\nthis:\n  winning_path p** P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Extension Theorems\\<close>"], ["", "lemma strategy_extends_VVp:\n  assumes v0: \"v0 \\<in> VV p\" \"\\<not>deadend v0\"\n  and \\<sigma>: \"strategy p \\<sigma>\" \"winning_strategy p \\<sigma> v0\"\n  shows \"winning_strategy p \\<sigma> (\\<sigma> v0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_strategy p \\<sigma> (\\<sigma> v0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       vmc_path G P (\\<sigma> v0) p \\<sigma> \\<Longrightarrow>\n       winning_path p P", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       vmc_path G P (\\<sigma> v0) p \\<sigma> \\<Longrightarrow>\n       winning_path p P", "assume \"vmc_path G P (\\<sigma> v0) p \\<sigma>\""], ["proof (state)\nthis:\n  vmc_path G P (\\<sigma> v0) p \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       vmc_path G P (\\<sigma> v0) p \\<sigma> \\<Longrightarrow>\n       winning_path p P", "then"], ["proof (chain)\npicking this:\n  vmc_path G P (\\<sigma> v0) p \\<sigma>", "interpret vmc_path G P \"\\<sigma> v0\" p \\<sigma>"], ["proof (prove)\nusing this:\n  vmc_path G P (\\<sigma> v0) p \\<sigma>\n\ngoal (1 subgoal):\n 1. vmc_path G P (\\<sigma> v0) p \\<sigma>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       vmc_path G P (\\<sigma> v0) p \\<sigma> \\<Longrightarrow>\n       winning_path p P", "have \"v0\\<rightarrow>\\<sigma> v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<rightarrow> \\<sigma> v0", "using v0 \\<sigma>(1) strategy_def"], ["proof (prove)\nusing this:\n  v0 \\<in> VV p\n  \\<not> deadend v0\n  strategy p \\<sigma>\n  strategy ?p ?\\<sigma> \\<equiv>\n  \\<forall>v\\<in>VV ?p.\n     \\<not> deadend v \\<longrightarrow> v \\<rightarrow> ?\\<sigma> v\n\ngoal (1 subgoal):\n 1. v0 \\<rightarrow> \\<sigma> v0", "by blast"], ["proof (state)\nthis:\n  v0 \\<rightarrow> \\<sigma> v0\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       vmc_path G P (\\<sigma> v0) p \\<sigma> \\<Longrightarrow>\n       winning_path p P", "hence \"winning_path p (LCons v0 P)\""], ["proof (prove)\nusing this:\n  v0 \\<rightarrow> \\<sigma> v0\n\ngoal (1 subgoal):\n 1. winning_path p (LCons v0 P)", "using \\<sigma>(2) extension_valid_maximal_conforming winning_strategy_def"], ["proof (prove)\nusing this:\n  v0 \\<rightarrow> \\<sigma> v0\n  winning_strategy p \\<sigma> v0\n  \\<lbrakk>?v' \\<rightarrow> \\<sigma> v0;\n   ?v' \\<in> VV p \\<Longrightarrow> \\<sigma> ?v' = \\<sigma> v0\\<rbrakk>\n  \\<Longrightarrow> vmc_path G (LCons ?v' P) ?v' p \\<sigma>\n  winning_strategy ?p ?\\<sigma> ?v0.0 \\<equiv>\n  \\<forall>P.\n     vmc_path G P ?v0.0 ?p ?\\<sigma> \\<longrightarrow> winning_path ?p P\n\ngoal (1 subgoal):\n 1. winning_path p (LCons v0 P)", "by blast"], ["proof (state)\nthis:\n  winning_path p (LCons v0 P)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       vmc_path G P (\\<sigma> v0) p \\<sigma> \\<Longrightarrow>\n       winning_path p P", "thus \"winning_path p P\""], ["proof (prove)\nusing this:\n  winning_path p (LCons v0 P)\n\ngoal (1 subgoal):\n 1. winning_path p P", "using winning_path_ltl[of p \"LCons v0 P\"]"], ["proof (prove)\nusing this:\n  winning_path p (LCons v0 P)\n  \\<lbrakk>winning_path p (LCons v0 P); \\<not> lnull (LCons v0 P);\n   \\<not> lnull (ltl (LCons v0 P))\\<rbrakk>\n  \\<Longrightarrow> winning_path p (ltl (LCons v0 P))\n\ngoal (1 subgoal):\n 1. winning_path p P", "by simp"], ["proof (state)\nthis:\n  winning_path p P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strategy_extends_VVpstar:\n  assumes v0: \"v0 \\<in> VV p**\" \"v0\\<rightarrow>w0\"\n  and \\<sigma>: \"winning_strategy p \\<sigma> v0\"\n  shows \"winning_strategy p \\<sigma> w0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_strategy p \\<sigma> w0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P w0 p \\<sigma> \\<Longrightarrow> winning_path p P", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P w0 p \\<sigma> \\<Longrightarrow> winning_path p P", "assume \"vmc_path G P w0 p \\<sigma>\""], ["proof (state)\nthis:\n  vmc_path G P w0 p \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P w0 p \\<sigma> \\<Longrightarrow> winning_path p P", "then"], ["proof (chain)\npicking this:\n  vmc_path G P w0 p \\<sigma>", "interpret vmc_path G P w0 p \\<sigma>"], ["proof (prove)\nusing this:\n  vmc_path G P w0 p \\<sigma>\n\ngoal (1 subgoal):\n 1. vmc_path G P w0 p \\<sigma>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P w0 p \\<sigma> \\<Longrightarrow> winning_path p P", "have \"winning_path p (LCons v0 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p (LCons v0 P)", "using extension_valid_maximal_conforming VV_impl1 \\<sigma> v0 winning_strategy_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v' \\<rightarrow> w0;\n   ?v' \\<in> VV p \\<Longrightarrow> \\<sigma> ?v' = w0\\<rbrakk>\n  \\<Longrightarrow> vmc_path G (LCons ?v' P) ?v' p \\<sigma>\n  ?v \\<in> VV ?p \\<Longrightarrow> ?v \\<notin> VV ?p**\n  winning_strategy p \\<sigma> v0\n  v0 \\<in> VV p**\n  v0 \\<rightarrow> w0\n  winning_strategy ?p ?\\<sigma> ?v0.0 \\<equiv>\n  \\<forall>P.\n     vmc_path G P ?v0.0 ?p ?\\<sigma> \\<longrightarrow> winning_path ?p P\n\ngoal (1 subgoal):\n 1. winning_path p (LCons v0 P)", "by auto"], ["proof (state)\nthis:\n  winning_path p (LCons v0 P)\n\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P w0 p \\<sigma> \\<Longrightarrow> winning_path p P", "thus \"winning_path p P\""], ["proof (prove)\nusing this:\n  winning_path p (LCons v0 P)\n\ngoal (1 subgoal):\n 1. winning_path p P", "using winning_path_ltl[of p \"LCons v0 P\"]"], ["proof (prove)\nusing this:\n  winning_path p (LCons v0 P)\n  \\<lbrakk>winning_path p (LCons v0 P); \\<not> lnull (LCons v0 P);\n   \\<not> lnull (ltl (LCons v0 P))\\<rbrakk>\n  \\<Longrightarrow> winning_path p (ltl (LCons v0 P))\n\ngoal (1 subgoal):\n 1. winning_path p P", "by auto"], ["proof (state)\nthis:\n  winning_path p P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strategy_extends_backwards_VVpstar:\n  assumes v0: \"v0 \\<in> VV p**\"\n    and \\<sigma>: \"strategy p \\<sigma>\" \"\\<And>w. v0\\<rightarrow>w \\<Longrightarrow> winning_strategy p \\<sigma> w\"\n  shows \"winning_strategy p \\<sigma> v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_strategy p \\<sigma> v0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P", "assume \"vmc_path G P v0 p \\<sigma>\""], ["proof (state)\nthis:\n  vmc_path G P v0 p \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P", "then"], ["proof (chain)\npicking this:\n  vmc_path G P v0 p \\<sigma>", "interpret vmc_path G P v0 p \\<sigma>"], ["proof (prove)\nusing this:\n  vmc_path G P v0 p \\<sigma>\n\ngoal (1 subgoal):\n 1. vmc_path G P v0 p \\<sigma>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P", "show \"winning_path p P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p P", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p P\n 2. \\<not> ?P \\<Longrightarrow> winning_path p P", "assume \"deadend v0\""], ["proof (state)\nthis:\n  deadend v0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> winning_path p P\n 2. \\<not> ?P \\<Longrightarrow> winning_path p P", "thus ?thesis"], ["proof (prove)\nusing this:\n  deadend v0\n\ngoal (1 subgoal):\n 1. winning_path p P", "using P_deadend_v0_LCons winning_path_def v0"], ["proof (prove)\nusing this:\n  deadend v0\n  deadend v0 \\<Longrightarrow> P = LCons v0 LNil\n  winning_path ?p ?P \\<equiv>\n  \\<not> lfinite ?P \\<and>\n  (\\<exists>a\\<in>path_inf_priorities ?P.\n      (\\<forall>b\\<in>path_inf_priorities ?P. a \\<le> b) \\<and>\n      (if ?p = Even then even else odd) a) \\<or>\n  \\<not> lnull ?P \\<and> lfinite ?P \\<and> llast ?P \\<in> VV ?p** \\<or>\n  lnull ?P \\<and> ?p = Even\n  v0 \\<in> VV p**\n\ngoal (1 subgoal):\n 1. winning_path p P", "by auto"], ["proof (state)\nthis:\n  winning_path p P\n\ngoal (1 subgoal):\n 1. \\<not> deadend v0 \\<Longrightarrow> winning_path p P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> deadend v0 \\<Longrightarrow> winning_path p P", "assume \"\\<not>deadend v0\""], ["proof (state)\nthis:\n  \\<not> deadend v0\n\ngoal (1 subgoal):\n 1. \\<not> deadend v0 \\<Longrightarrow> winning_path p P", "then"], ["proof (chain)\npicking this:\n  \\<not> deadend v0", "interpret vmc_path_no_deadend G P v0 p \\<sigma>"], ["proof (prove)\nusing this:\n  \\<not> deadend v0\n\ngoal (1 subgoal):\n 1. vmc_path_no_deadend G P v0 p \\<sigma>", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> deadend v0 \\<Longrightarrow> winning_path p P", "interpret ltlP: vmc_path G \"ltl P\" w0 p \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vmc_path G (ltl P) w0 p \\<sigma>", "using vmc_path_ltl"], ["proof (prove)\nusing this:\n  vmc_path G (ltl P) w0 p \\<sigma>\n\ngoal (1 subgoal):\n 1. vmc_path G (ltl P) w0 p \\<sigma>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> deadend v0 \\<Longrightarrow> winning_path p P", "have \"winning_path p (ltl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p (ltl P)", "using \\<sigma>(2) v0_edge_w0 vmc_path_ltl winning_strategy_def"], ["proof (prove)\nusing this:\n  v0 \\<rightarrow> ?w \\<Longrightarrow> winning_strategy p \\<sigma> ?w\n  v0 \\<rightarrow> w0\n  vmc_path G (ltl P) w0 p \\<sigma>\n  winning_strategy ?p ?\\<sigma> ?v0.0 \\<equiv>\n  \\<forall>P.\n     vmc_path G P ?v0.0 ?p ?\\<sigma> \\<longrightarrow> winning_path ?p P\n\ngoal (1 subgoal):\n 1. winning_path p (ltl P)", "by blast"], ["proof (state)\nthis:\n  winning_path p (ltl P)\n\ngoal (1 subgoal):\n 1. \\<not> deadend v0 \\<Longrightarrow> winning_path p P", "thus \"winning_path p P\""], ["proof (prove)\nusing this:\n  winning_path p (ltl P)\n\ngoal (1 subgoal):\n 1. winning_path p P", "using winning_path_LCons"], ["proof (prove)\nusing this:\n  winning_path p (ltl P)\n  \\<lbrakk>winning_path ?p ?P; \\<not> lnull ?P\\<rbrakk>\n  \\<Longrightarrow> winning_path ?p (LCons ?v ?P)\n\ngoal (1 subgoal):\n 1. winning_path p P", "by (metis P_LCons' ltlP.P_LCons ltlP.P_not_null)"], ["proof (state)\nthis:\n  winning_path p P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  winning_path p P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strategy_extends_backwards_VVp:\n  assumes v0: \"v0 \\<in> VV p\" \"\\<sigma> v0 = w\" \"v0\\<rightarrow>w\"\n    and \\<sigma>: \"strategy p \\<sigma>\" \"winning_strategy p \\<sigma> w\"\n  shows \"winning_strategy p \\<sigma> v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_strategy p \\<sigma> v0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P", "assume \"vmc_path G P v0 p \\<sigma>\""], ["proof (state)\nthis:\n  vmc_path G P v0 p \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P", "then"], ["proof (chain)\npicking this:\n  vmc_path G P v0 p \\<sigma>", "interpret vmc_path G P v0 p \\<sigma>"], ["proof (prove)\nusing this:\n  vmc_path G P v0 p \\<sigma>\n\ngoal (1 subgoal):\n 1. vmc_path G P v0 p \\<sigma>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P", "have \"\\<not>deadend v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> deadend v0", "using \\<open>v0\\<rightarrow>w\\<close>"], ["proof (prove)\nusing this:\n  v0 \\<rightarrow> w\n\ngoal (1 subgoal):\n 1. \\<not> deadend v0", "by blast"], ["proof (state)\nthis:\n  \\<not> deadend v0\n\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P", "then"], ["proof (chain)\npicking this:\n  \\<not> deadend v0", "interpret vmc_path_no_deadend G P v0 p \\<sigma>"], ["proof (prove)\nusing this:\n  \\<not> deadend v0\n\ngoal (1 subgoal):\n 1. vmc_path_no_deadend G P v0 p \\<sigma>", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P", "have \"winning_path p (ltl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_path p (ltl P)", "using \\<sigma>(2)[unfolded winning_strategy_def] v0(1,2) v0_conforms vmc_path_ltl"], ["proof (prove)\nusing this:\n  \\<forall>P. vmc_path G P w p \\<sigma> \\<longrightarrow> winning_path p P\n  v0 \\<in> VV p\n  \\<sigma> v0 = w\n  v0 \\<in> VV p \\<Longrightarrow> \\<sigma> v0 = w0\n  vmc_path G (ltl P) w0 p \\<sigma>\n\ngoal (1 subgoal):\n 1. winning_path p (ltl P)", "by presburger"], ["proof (state)\nthis:\n  winning_path p (ltl P)\n\ngoal (1 subgoal):\n 1. \\<And>P. vmc_path G P v0 p \\<sigma> \\<Longrightarrow> winning_path p P", "thus \"winning_path p P\""], ["proof (prove)\nusing this:\n  winning_path p (ltl P)\n\ngoal (1 subgoal):\n 1. winning_path p P", "using winning_path_LCons"], ["proof (prove)\nusing this:\n  winning_path p (ltl P)\n  \\<lbrakk>winning_path ?p ?P; \\<not> lnull ?P\\<rbrakk>\n  \\<Longrightarrow> winning_path ?p (LCons ?v ?P)\n\ngoal (1 subgoal):\n 1. winning_path p P", "by (metis P_LCons Ptl_not_null)"], ["proof (state)\nthis:\n  winning_path p P\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>context ParityGame\\<close>"], ["", "end"]]}