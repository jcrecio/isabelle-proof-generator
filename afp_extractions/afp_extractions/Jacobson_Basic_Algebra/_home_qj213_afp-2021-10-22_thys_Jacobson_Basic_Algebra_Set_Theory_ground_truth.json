{"file_name": "/home/qj213/afp-2021-10-22/thys/Jacobson_Basic_Algebra/Set_Theory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jacobson_Basic_Algebra", "problem_names": ["lemma map_closed [intro, simp]:\n  \"a \\<in> S \\<Longrightarrow> \\<alpha> a \\<in> T\"", "lemma map_undefined [intro]:\n  \"a \\<notin> S \\<Longrightarrow> \\<alpha> a = undefined\"", "theorem bij_betw_iff_has_inverse:\n  \"bij_betw \\<alpha> S T \\<longleftrightarrow> (\\<exists>\\<beta> \\<in> T \\<rightarrow>\\<^sub>E S. compose S \\<beta> \\<alpha> = identity S \\<and> compose T \\<alpha> \\<beta> = identity T)\"\n    (is \"_ \\<longleftrightarrow> (\\<exists>\\<beta> \\<in> T \\<rightarrow>\\<^sub>E S. ?INV \\<beta>)\")", "lemma left_closed [intro]: (* inefficient as a simp rule *)\n  \"(a, b) \\<in> E \\<Longrightarrow> a \\<in> S\"", "lemma right_closed [intro]: (* inefficient as a simp rule *)\n  \"(a, b) \\<in> E \\<Longrightarrow> b \\<in> S\"", "lemma Class_closed [dest]:\n  \"\\<lbrakk> a \\<in> Class b; b \\<in> S \\<rbrakk> \\<Longrightarrow> a \\<in> S\"", "lemma Class_closed2 [intro, simp]:\n  \"a \\<in> S \\<Longrightarrow> Class a \\<subseteq> S\"", "lemma Class_undefined [intro, simp]:\n  \"a \\<notin> S \\<Longrightarrow> Class a = undefined\"", "lemma ClassI [intro, simp]:\n  \"(a, b) \\<in> E \\<Longrightarrow> a \\<in> Class b\"", "lemma Class_revI [intro, simp]:\n  \"(a, b) \\<in> E \\<Longrightarrow> b \\<in> Class a\"", "lemma ClassD [dest]:\n  \"\\<lbrakk> b \\<in> Class a; a \\<in> S \\<rbrakk> \\<Longrightarrow> (b, a) \\<in> E\"", "theorem Class_self [intro, simp]:\n  \"a \\<in> S \\<Longrightarrow> a \\<in> Class a\"", "theorem Class_Union [simp]:\n  \"(\\<Union>a\\<in>S. Class a) = S\"", "theorem Class_subset:\n  \"(a, b) \\<in> E \\<Longrightarrow> Class a \\<subseteq> Class b\"", "theorem Class_eq:\n  \"(a, b) \\<in> E \\<Longrightarrow> Class a = Class b\"", "theorem Class_equivalence:\n  \"\\<lbrakk> a \\<in> S; b \\<in> S \\<rbrakk> \\<Longrightarrow> Class a = Class b \\<longleftrightarrow> (a, b) \\<in> E\"", "theorem not_disjoint_implies_equal:\n  assumes not_disjoint: \"Class a \\<inter> Class b \\<noteq> {}\"\n  assumes closed: \"a \\<in> S\" \"b \\<in> S\"\n  shows \"Class a = Class b\"", "lemma Class_in_Partition [intro, simp]:\n  \"a \\<in> S \\<Longrightarrow> Class a \\<in> Partition\"", "theorem partition:\n  \"partition S Partition\"", "theorem block_exists:\n  \"a \\<in> S \\<Longrightarrow> \\<exists>A. a \\<in> A \\<and> A \\<in> P\"", "theorem block_unique:\n  \"\\<lbrakk> a \\<in> A; A \\<in> P; a \\<in> B; B \\<in> P \\<rbrakk> \\<Longrightarrow> A = B\"", "lemma block_closed [intro]: (* inefficient as a simp rule *)\n  \"\\<lbrakk> a \\<in> A; A \\<in> P \\<rbrakk> \\<Longrightarrow> a \\<in> S\"", "lemma element_exists:\n  \"A \\<in> P \\<Longrightarrow> \\<exists>a \\<in> S. a \\<in> A\"", "lemma Block_closed [intro, simp]:\n  assumes [intro]: \"a \\<in> S\" shows \"Block a \\<in> P\"", "lemma Block_undefined [intro, simp]:\n  \"a \\<notin> S \\<Longrightarrow> Block a = undefined\"", "lemma Block_self:\n  \"\\<lbrakk> a \\<in> A; A \\<in> P \\<rbrakk> \\<Longrightarrow> Block a = A\"", "theorem equivalence: \"equivalence S Equivalence\"", "theorem Class_is_Block:\n  assumes \"a \\<in> S\" shows \"Class a = Block a\"", "lemma Class_equals_Block:\n  \"Class = Block\"", "theorem partition_of_equivalence:\n  \"Partition = P\"", "theorem equivalence_of_partition:\n  \"Equivalence = E\"", "lemma representant_exists [dest]: \"A \\<in> S / E \\<Longrightarrow> \\<exists>a\\<in>S. a \\<in> A \\<and> A = Class a\"", "lemma quotient_ClassE: \"A \\<in> S / E \\<Longrightarrow> (\\<And>a. a \\<in> S \\<Longrightarrow> P (Class a)) \\<Longrightarrow> P A\"", "theorem Fiber_equality:\n  \"\\<lbrakk> a \\<in> S; b \\<in> S \\<rbrakk> \\<Longrightarrow> Class a = Class b \\<longleftrightarrow> \\<alpha> a = \\<alpha> b\"", "theorem induced_Fiber_simp [simp]:\n  assumes [intro, simp]: \"a \\<in> S\" shows \"induced (Class a) = \\<alpha> a\"", "theorem factorization_lemma:\n  \"a \\<in> S \\<Longrightarrow> compose S induced Class a = \\<alpha> a\"", "theorem factorization [simp]: \"compose S induced Class = \\<alpha>\"", "theorem uniqueness:\n  assumes map: \"\\<beta> \\<in> S / E(\\<alpha>) \\<rightarrow>\\<^sub>E T\"\n    and factorization: \"compose S \\<beta> Class = \\<alpha>\"\n  shows \"\\<beta> = induced\""], "translations": [["", "lemma map_closed [intro, simp]:\n  \"a \\<in> S \\<Longrightarrow> \\<alpha> a \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow> \\<alpha> a \\<in> T", "using graph"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> S \\<rightarrow>\\<^sub>E T\n\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow> \\<alpha> a \\<in> T", "by fast"], ["", "text \\<open>p 5, ll 21--25\\<close>"], ["", "lemma map_undefined [intro]:\n  \"a \\<notin> S \\<Longrightarrow> \\<alpha> a = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> S \\<Longrightarrow> \\<alpha> a = undefined", "using graph"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> S \\<rightarrow>\\<^sub>E T\n\ngoal (1 subgoal):\n 1. a \\<notin> S \\<Longrightarrow> \\<alpha> a = undefined", "by fast"], ["", "end"], ["", "(* map *)"], ["", "text \\<open>p 7, ll 7--8\\<close>"], ["", "locale surjective_map = map + assumes surjective [intro]: \"\\<alpha> ` S = T\""], ["", "text \\<open>p 7, ll 8--9\\<close>"], ["", "locale injective_map = map + assumes injective [intro, simp]: \"inj_on \\<alpha> S\""], ["", "text \\<open>Enables locale reasoning about the inverse @{term \"restrict (inv_into S \\<alpha>) T\"} of @{term \\<alpha>}.\\<close>"], ["", "text \\<open>p 7, ll 9--10\\<close>"], ["", "locale bijective =\n  fixes \\<alpha> and S and T\n  assumes bijective [intro, simp]: \"bij_betw \\<alpha> S T\""], ["", "text \\<open>\n  Exploit existing knowledge about @{term bij_betw} rather than extending @{locale surjective_map}\n  and @{locale injective_map}.\n\\<close>"], ["", "text \\<open>p 7, ll 9--10\\<close>"], ["", "locale bijective_map = map + bijective begin"], ["", "text \\<open>p 7, ll 9--10\\<close>"], ["", "sublocale surjective_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective_map \\<alpha> S T", "by unfold_locales (simp add: bij_betw_imp_surj_on)"], ["", "text \\<open>p 7, ll 9--10\\<close>"], ["", "sublocale injective_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. injective_map \\<alpha> S T", "using bij_betw_def"], ["proof (prove)\nusing this:\n  bij_betw ?f ?A ?B = (inj_on ?f ?A \\<and> ?f ` ?A = ?B)\n\ngoal (1 subgoal):\n 1. injective_map \\<alpha> S T", "by unfold_locales fast"], ["", "text \\<open>p 9, ll 12--13\\<close>"], ["", "sublocale inverse: map \"restrict (inv_into S \\<alpha>) T\" T S"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (restrict (inv_into S \\<alpha>) T) T S", "by unfold_locales (simp add: inv_into_into surjective)"], ["", "text \\<open>p 9, ll 12--13\\<close>"], ["", "sublocale inverse: bijective \"restrict (inv_into S \\<alpha>) T\" T S"], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective (restrict (inv_into S \\<alpha>) T) T S", "by unfold_locales (simp add: bij_betw_inv_into surjective)"], ["", "end"], ["", "(* bijective_map *)"], ["", "text \\<open>p 8, ll 14--15\\<close>"], ["", "abbreviation \"identity S \\<equiv> (\\<lambda>x \\<in> S. x)\""], ["", "context map begin"], ["", "text \\<open>p 8, ll 18--20; p 9, ll 1--8\\<close>"], ["", "theorem bij_betw_iff_has_inverse:\n  \"bij_betw \\<alpha> S T \\<longleftrightarrow> (\\<exists>\\<beta> \\<in> T \\<rightarrow>\\<^sub>E S. compose S \\<beta> \\<alpha> = identity S \\<and> compose T \\<alpha> \\<beta> = identity T)\"\n    (is \"_ \\<longleftrightarrow> (\\<exists>\\<beta> \\<in> T \\<rightarrow>\\<^sub>E S. ?INV \\<beta>)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw \\<alpha> S T =\n    (\\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n        compose S \\<beta> \\<alpha> = identity S \\<and>\n        compose T \\<alpha> \\<beta> = identity T)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw \\<alpha> S T \\<Longrightarrow>\n    \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T\n 2. \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T \\<Longrightarrow>\n    bij_betw \\<alpha> S T", "let ?inv = \"restrict (inv_into S \\<alpha>) T\""], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw \\<alpha> S T \\<Longrightarrow>\n    \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T\n 2. \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T \\<Longrightarrow>\n    bij_betw \\<alpha> S T", "assume \"bij_betw \\<alpha> S T\""], ["proof (state)\nthis:\n  bij_betw \\<alpha> S T\n\ngoal (2 subgoals):\n 1. bij_betw \\<alpha> S T \\<Longrightarrow>\n    \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T\n 2. \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T \\<Longrightarrow>\n    bij_betw \\<alpha> S T", "then"], ["proof (chain)\npicking this:\n  bij_betw \\<alpha> S T", "have \"?INV ?inv\" and \"?inv \\<in> T \\<rightarrow>\\<^sub>E S\""], ["proof (prove)\nusing this:\n  bij_betw \\<alpha> S T\n\ngoal (1 subgoal):\n 1. compose S (restrict (inv_into S \\<alpha>) T) \\<alpha> =\n    identity S \\<and>\n    compose T \\<alpha> (restrict (inv_into S \\<alpha>) T) = identity T &&&\n    restrict (inv_into S \\<alpha>) T \\<in> T \\<rightarrow>\\<^sub>E S", "by (simp_all add: compose_inv_into_id bij_betw_imp_surj_on compose_id_inv_into bij_betw_imp_funcset bij_betw_inv_into)"], ["proof (state)\nthis:\n  compose S (restrict (inv_into S \\<alpha>) T) \\<alpha> = identity S \\<and>\n  compose T \\<alpha> (restrict (inv_into S \\<alpha>) T) = identity T\n  restrict (inv_into S \\<alpha>) T \\<in> T \\<rightarrow>\\<^sub>E S\n\ngoal (2 subgoals):\n 1. bij_betw \\<alpha> S T \\<Longrightarrow>\n    \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T\n 2. \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T \\<Longrightarrow>\n    bij_betw \\<alpha> S T", "then"], ["proof (chain)\npicking this:\n  compose S (restrict (inv_into S \\<alpha>) T) \\<alpha> = identity S \\<and>\n  compose T \\<alpha> (restrict (inv_into S \\<alpha>) T) = identity T\n  restrict (inv_into S \\<alpha>) T \\<in> T \\<rightarrow>\\<^sub>E S", "show \"\\<exists>\\<beta> \\<in> T \\<rightarrow>\\<^sub>E S. ?INV \\<beta>\""], ["proof (prove)\nusing this:\n  compose S (restrict (inv_into S \\<alpha>) T) \\<alpha> = identity S \\<and>\n  compose T \\<alpha> (restrict (inv_into S \\<alpha>) T) = identity T\n  restrict (inv_into S \\<alpha>) T \\<in> T \\<rightarrow>\\<^sub>E S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T", ".."], ["proof (state)\nthis:\n  \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n     compose S \\<beta> \\<alpha> = identity S \\<and>\n     compose T \\<alpha> \\<beta> = identity T\n\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T \\<Longrightarrow>\n    bij_betw \\<alpha> S T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T \\<Longrightarrow>\n    bij_betw \\<alpha> S T", "assume \"\\<exists>\\<beta> \\<in> T \\<rightarrow>\\<^sub>E S. ?INV \\<beta>\""], ["proof (state)\nthis:\n  \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n     compose S \\<beta> \\<alpha> = identity S \\<and>\n     compose T \\<alpha> \\<beta> = identity T\n\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T \\<Longrightarrow>\n    bij_betw \\<alpha> S T", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n     compose S \\<beta> \\<alpha> = identity S \\<and>\n     compose T \\<alpha> \\<beta> = identity T", "obtain \\<beta> where \"\\<alpha> \\<in> S \\<rightarrow> T\" \"\\<beta> \\<in> T \\<rightarrow> S\" \"\\<And>x. x \\<in> S \\<Longrightarrow> \\<beta> (\\<alpha> x) = x\" \"\\<And>y. y \\<in> T \\<Longrightarrow> \\<alpha> (\\<beta> y) = y\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n     compose S \\<beta> \\<alpha> = identity S \\<and>\n     compose T \\<alpha> \\<beta> = identity T\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        \\<lbrakk>\\<alpha> \\<in> S \\<rightarrow> T;\n         \\<beta> \\<in> T \\<rightarrow> S;\n         \\<And>x. x \\<in> S \\<Longrightarrow> \\<beta> (\\<alpha> x) = x;\n         \\<And>y.\n            y \\<in> T \\<Longrightarrow> \\<alpha> (\\<beta> y) = y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis PiE_restrict compose_eq graph restrict_PiE restrict_apply)"], ["proof (state)\nthis:\n  \\<alpha> \\<in> S \\<rightarrow> T\n  \\<beta> \\<in> T \\<rightarrow> S\n  ?x \\<in> S \\<Longrightarrow> \\<beta> (\\<alpha> ?x) = ?x\n  ?y \\<in> T \\<Longrightarrow> \\<alpha> (\\<beta> ?y) = ?y\n\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>\\<in>T \\<rightarrow>\\<^sub>E S.\n       compose S \\<beta> \\<alpha> = identity S \\<and>\n       compose T \\<alpha> \\<beta> = identity T \\<Longrightarrow>\n    bij_betw \\<alpha> S T", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> S \\<rightarrow> T\n  \\<beta> \\<in> T \\<rightarrow> S\n  ?x \\<in> S \\<Longrightarrow> \\<beta> (\\<alpha> ?x) = ?x\n  ?y \\<in> T \\<Longrightarrow> \\<alpha> (\\<beta> ?y) = ?y", "show \"bij_betw \\<alpha> S T\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> S \\<rightarrow> T\n  \\<beta> \\<in> T \\<rightarrow> S\n  ?x \\<in> S \\<Longrightarrow> \\<beta> (\\<alpha> ?x) = ?x\n  ?y \\<in> T \\<Longrightarrow> \\<alpha> (\\<beta> ?y) = ?y\n\ngoal (1 subgoal):\n 1. bij_betw \\<alpha> S T", "by (rule bij_betwI)"], ["proof (state)\nthis:\n  bij_betw \\<alpha> S T\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* map *)"], ["", "subsection \\<open>Equivalence Relations.  Factoring a Map Through an Equivalence Relation\\<close>"], ["", "text \\<open>p 11, ll 6--11\\<close>"], ["", "locale equivalence =\n  fixes S and E\n  assumes closed [intro, simp]: \"E \\<subseteq> S \\<times> S\"\n    and reflexive [intro, simp]: \"a \\<in> S \\<Longrightarrow> (a, a) \\<in> E\"\n    and symmetric [sym]: \"(a, b) \\<in> E \\<Longrightarrow> (b, a) \\<in> E\"\n    and transitive [trans]: \"\\<lbrakk> (a, b) \\<in> E; (b, c) \\<in> E \\<rbrakk> \\<Longrightarrow> (a, c) \\<in> E\"\nbegin"], ["", "text \\<open>p 11, ll 6--11\\<close>"], ["", "lemma left_closed [intro]: (* inefficient as a simp rule *)\n  \"(a, b) \\<in> E \\<Longrightarrow> a \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> E \\<Longrightarrow> a \\<in> S", "using closed"], ["proof (prove)\nusing this:\n  E \\<subseteq> S \\<times> S\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> E \\<Longrightarrow> a \\<in> S", "by blast"], ["", "text \\<open>p 11, ll 6--11\\<close>"], ["", "lemma right_closed [intro]: (* inefficient as a simp rule *)\n  \"(a, b) \\<in> E \\<Longrightarrow> b \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> E \\<Longrightarrow> b \\<in> S", "using closed"], ["proof (prove)\nusing this:\n  E \\<subseteq> S \\<times> S\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> E \\<Longrightarrow> b \\<in> S", "by blast"], ["", "end"], ["", "(* equivalence *)"], ["", "text \\<open>p 11, ll 16--20\\<close>"], ["", "locale partition =\n  fixes S and P\n  assumes subset: \"P \\<subseteq> Pow S\"\n    and non_vacuous: \"{} \\<notin> P\"\n    and complete: \"\\<Union>P = S\"\n    and disjoint: \"\\<lbrakk> A \\<in> P; B \\<in> P; A \\<noteq> B \\<rbrakk> \\<Longrightarrow> A \\<inter> B = {}\""], ["", "context equivalence begin"], ["", "text \\<open>p 11, ll 24--26\\<close>"], ["", "definition \"Class = (\\<lambda>a \\<in> S. {b \\<in> S. (b, a) \\<in> E})\""], ["", "text \\<open>p 11, ll 24--26\\<close>"], ["", "lemma Class_closed [dest]:\n  \"\\<lbrakk> a \\<in> Class b; b \\<in> S \\<rbrakk> \\<Longrightarrow> a \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> Class b; b \\<in> S\\<rbrakk> \\<Longrightarrow> a \\<in> S", "unfolding Class_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> (\\<lambda>a\\<in>S. {b \\<in> S. (b, a) \\<in> E}) b;\n     b \\<in> S\\<rbrakk>\n    \\<Longrightarrow> a \\<in> S", "by auto"], ["", "text \\<open>p 11, ll 24--26\\<close>"], ["", "lemma Class_closed2 [intro, simp]:\n  \"a \\<in> S \\<Longrightarrow> Class a \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow> Class a \\<subseteq> S", "unfolding Class_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow>\n    (\\<lambda>a\\<in>S. {b \\<in> S. (b, a) \\<in> E}) a \\<subseteq> S", "by auto"], ["", "text \\<open>p 11, ll 24--26\\<close>"], ["", "lemma Class_undefined [intro, simp]:\n  \"a \\<notin> S \\<Longrightarrow> Class a = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> S \\<Longrightarrow> Class a = undefined", "unfolding Class_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> S \\<Longrightarrow>\n    (\\<lambda>a\\<in>S. {b \\<in> S. (b, a) \\<in> E}) a = undefined", "by simp"], ["", "text \\<open>p 11, ll 24--26\\<close>"], ["", "lemma ClassI [intro, simp]:\n  \"(a, b) \\<in> E \\<Longrightarrow> a \\<in> Class b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> E \\<Longrightarrow> a \\<in> Class b", "unfolding Class_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> E \\<Longrightarrow>\n    a \\<in> (\\<lambda>a\\<in>S. {b \\<in> S. (b, a) \\<in> E}) b", "by (simp add: left_closed right_closed)"], ["", "text \\<open>p 11, ll 24--26\\<close>"], ["", "lemma Class_revI [intro, simp]:\n  \"(a, b) \\<in> E \\<Longrightarrow> b \\<in> Class a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> E \\<Longrightarrow> b \\<in> Class a", "by (blast intro: symmetric)"], ["", "text \\<open>p 11, ll 24--26\\<close>"], ["", "lemma ClassD [dest]:\n  \"\\<lbrakk> b \\<in> Class a; a \\<in> S \\<rbrakk> \\<Longrightarrow> (b, a) \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> Class a; a \\<in> S\\<rbrakk>\n    \\<Longrightarrow> (b, a) \\<in> E", "unfolding Class_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> (\\<lambda>a\\<in>S. {b \\<in> S. (b, a) \\<in> E}) a;\n     a \\<in> S\\<rbrakk>\n    \\<Longrightarrow> (b, a) \\<in> E", "by simp"], ["", "text \\<open>p 11, ll 30--31\\<close>"], ["", "theorem Class_self [intro, simp]:\n  \"a \\<in> S \\<Longrightarrow> a \\<in> Class a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow> a \\<in> Class a", "unfolding Class_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow>\n    a \\<in> (\\<lambda>a\\<in>S. {b \\<in> S. (b, a) \\<in> E}) a", "by simp"], ["", "text \\<open>p 11, l 31; p 12, l 1\\<close>"], ["", "theorem Class_Union [simp]:\n  \"(\\<Union>a\\<in>S. Class a) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (Class ` S) = S", "by blast"], ["", "text \\<open>p 11, ll 2--3\\<close>"], ["", "theorem Class_subset:\n  \"(a, b) \\<in> E \\<Longrightarrow> Class a \\<subseteq> Class b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> E \\<Longrightarrow> Class a \\<subseteq> Class b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(a, b) \\<in> E; x \\<in> Class a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Class b", "fix a and b and c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(a, b) \\<in> E; x \\<in> Class a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Class b", "assume \"(a, b) \\<in> E\" and \"c \\<in> Class a\""], ["proof (state)\nthis:\n  (a, b) \\<in> E\n  c \\<in> Class a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(a, b) \\<in> E; x \\<in> Class a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Class b", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> E\n  c \\<in> Class a", "have \"(c, a) \\<in> E\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> E\n  c \\<in> Class a\n\ngoal (1 subgoal):\n 1. (c, a) \\<in> E", "by auto"], ["proof (state)\nthis:\n  (c, a) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(a, b) \\<in> E; x \\<in> Class a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Class b", "also"], ["proof (state)\nthis:\n  (c, a) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(a, b) \\<in> E; x \\<in> Class a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Class b", "note \\<open>(a, b) \\<in> E\\<close>"], ["proof (state)\nthis:\n  (a, b) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(a, b) \\<in> E; x \\<in> Class a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Class b", "finally"], ["proof (chain)\npicking this:\n  (c, b) \\<in> E", "have \"(c, b) \\<in> E\""], ["proof (prove)\nusing this:\n  (c, b) \\<in> E\n\ngoal (1 subgoal):\n 1. (c, b) \\<in> E", "by simp"], ["proof (state)\nthis:\n  (c, b) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(a, b) \\<in> E; x \\<in> Class a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Class b", "then"], ["proof (chain)\npicking this:\n  (c, b) \\<in> E", "show \"c \\<in> Class b\""], ["proof (prove)\nusing this:\n  (c, b) \\<in> E\n\ngoal (1 subgoal):\n 1. c \\<in> Class b", "by auto"], ["proof (state)\nthis:\n  c \\<in> Class b\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>p 11, ll 3--4\\<close>"], ["", "theorem Class_eq:\n  \"(a, b) \\<in> E \\<Longrightarrow> Class a = Class b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> E \\<Longrightarrow> Class a = Class b", "by (auto intro!: Class_subset intro: symmetric)"], ["", "text \\<open>p 12, ll 1--5\\<close>"], ["", "theorem Class_equivalence:\n  \"\\<lbrakk> a \\<in> S; b \\<in> S \\<rbrakk> \\<Longrightarrow> Class a = Class b \\<longleftrightarrow> (a, b) \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S\\<rbrakk>\n    \\<Longrightarrow> (Class a = Class b) = ((a, b) \\<in> E)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S; Class a = Class b\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> E\n 2. \\<lbrakk>a \\<in> S; b \\<in> S; (a, b) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> Class a = Class b", "fix a and b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S; Class a = Class b\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> E\n 2. \\<lbrakk>a \\<in> S; b \\<in> S; (a, b) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> Class a = Class b", "assume \"a \\<in> S\" \"b \\<in> S\" \"Class a = Class b\""], ["proof (state)\nthis:\n  a \\<in> S\n  b \\<in> S\n  Class a = Class b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S; Class a = Class b\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> E\n 2. \\<lbrakk>a \\<in> S; b \\<in> S; (a, b) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> Class a = Class b", "then"], ["proof (chain)\npicking this:\n  a \\<in> S\n  b \\<in> S\n  Class a = Class b", "have \"a \\<in> Class a\""], ["proof (prove)\nusing this:\n  a \\<in> S\n  b \\<in> S\n  Class a = Class b\n\ngoal (1 subgoal):\n 1. a \\<in> Class a", "by auto"], ["proof (state)\nthis:\n  a \\<in> Class a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S; Class a = Class b\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> E\n 2. \\<lbrakk>a \\<in> S; b \\<in> S; (a, b) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> Class a = Class b", "also"], ["proof (state)\nthis:\n  a \\<in> Class a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S; Class a = Class b\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> E\n 2. \\<lbrakk>a \\<in> S; b \\<in> S; (a, b) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> Class a = Class b", "note \\<open>Class a = Class b\\<close>"], ["proof (state)\nthis:\n  Class a = Class b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S; Class a = Class b\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> E\n 2. \\<lbrakk>a \\<in> S; b \\<in> S; (a, b) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> Class a = Class b", "finally"], ["proof (chain)\npicking this:\n  a \\<in> Class b", "show \"(a, b) \\<in> E\""], ["proof (prove)\nusing this:\n  a \\<in> Class b\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> E", "by (fast intro: \\<open>b \\<in> S\\<close>)"], ["proof (state)\nthis:\n  (a, b) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S; (a, b) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> Class a = Class b", "qed (rule Class_eq)"], ["", "text \\<open>p 12, ll 5--7\\<close>"], ["", "theorem not_disjoint_implies_equal:\n  assumes not_disjoint: \"Class a \\<inter> Class b \\<noteq> {}\"\n  assumes closed: \"a \\<in> S\" \"b \\<in> S\"\n  shows \"Class a = Class b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Class a = Class b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Class a = Class b", "from not_disjoint and closed"], ["proof (chain)\npicking this:\n  Class a \\<inter> Class b \\<noteq> {}\n  a \\<in> S\n  b \\<in> S", "obtain c where witness: \"c \\<in> Class a \\<inter> Class b\""], ["proof (prove)\nusing this:\n  Class a \\<inter> Class b \\<noteq> {}\n  a \\<in> S\n  b \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        c \\<in> Class a \\<inter> Class b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  c \\<in> Class a \\<inter> Class b\n\ngoal (1 subgoal):\n 1. Class a = Class b", "with closed"], ["proof (chain)\npicking this:\n  a \\<in> S\n  b \\<in> S\n  c \\<in> Class a \\<inter> Class b", "have \"(a, c) \\<in> E\""], ["proof (prove)\nusing this:\n  a \\<in> S\n  b \\<in> S\n  c \\<in> Class a \\<inter> Class b\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> E", "by (blast intro: symmetric)"], ["proof (state)\nthis:\n  (a, c) \\<in> E\n\ngoal (1 subgoal):\n 1. Class a = Class b", "also"], ["proof (state)\nthis:\n  (a, c) \\<in> E\n\ngoal (1 subgoal):\n 1. Class a = Class b", "from witness and closed"], ["proof (chain)\npicking this:\n  c \\<in> Class a \\<inter> Class b\n  a \\<in> S\n  b \\<in> S", "have \"(c, b) \\<in> E\""], ["proof (prove)\nusing this:\n  c \\<in> Class a \\<inter> Class b\n  a \\<in> S\n  b \\<in> S\n\ngoal (1 subgoal):\n 1. (c, b) \\<in> E", "by fast"], ["proof (state)\nthis:\n  (c, b) \\<in> E\n\ngoal (1 subgoal):\n 1. Class a = Class b", "finally"], ["proof (chain)\npicking this:\n  (a, b) \\<in> E", "show ?thesis"], ["proof (prove)\nusing this:\n  (a, b) \\<in> E\n\ngoal (1 subgoal):\n 1. Class a = Class b", "by (rule Class_eq)"], ["proof (state)\nthis:\n  Class a = Class b\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>p 12, ll 7--8\\<close>"], ["", "definition \"Partition = Class ` S\""], ["", "text \\<open>p 12, ll 7--8\\<close>"], ["", "lemma Class_in_Partition [intro, simp]:\n  \"a \\<in> S \\<Longrightarrow> Class a \\<in> Partition\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow> Class a \\<in> Partition", "unfolding Partition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow> Class a \\<in> Class ` S", "by fast"], ["", "text \\<open>p 12, ll 7--8\\<close>"], ["", "theorem partition:\n  \"partition S Partition\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition S Partition", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. Partition \\<subseteq> Pow S\n 2. {} \\<notin> Partition\n 3. \\<Union> Partition = S\n 4. \\<And>A B.\n       \\<lbrakk>A \\<in> Partition; B \\<in> Partition; A \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> A \\<inter> B = {}", "fix A and B"], ["proof (state)\ngoal (4 subgoals):\n 1. Partition \\<subseteq> Pow S\n 2. {} \\<notin> Partition\n 3. \\<Union> Partition = S\n 4. \\<And>A B.\n       \\<lbrakk>A \\<in> Partition; B \\<in> Partition; A \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> A \\<inter> B = {}", "assume closed: \"A \\<in> Partition\" \"B \\<in> Partition\""], ["proof (state)\nthis:\n  A \\<in> Partition\n  B \\<in> Partition\n\ngoal (4 subgoals):\n 1. Partition \\<subseteq> Pow S\n 2. {} \\<notin> Partition\n 3. \\<Union> Partition = S\n 4. \\<And>A B.\n       \\<lbrakk>A \\<in> Partition; B \\<in> Partition; A \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> A \\<inter> B = {}", "then"], ["proof (chain)\npicking this:\n  A \\<in> Partition\n  B \\<in> Partition", "obtain a and b where eq: \"A = Class a\" \"B = Class b\" and ab: \"a \\<in> S\" \"b \\<in> S\""], ["proof (prove)\nusing this:\n  A \\<in> Partition\n  B \\<in> Partition\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>A = Class a; B = Class b; a \\<in> S; b \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Partition_def"], ["proof (prove)\nusing this:\n  A \\<in> Class ` S\n  B \\<in> Class ` S\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>A = Class a; B = Class b; a \\<in> S; b \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A = Class a\n  B = Class b\n  a \\<in> S\n  b \\<in> S\n\ngoal (4 subgoals):\n 1. Partition \\<subseteq> Pow S\n 2. {} \\<notin> Partition\n 3. \\<Union> Partition = S\n 4. \\<And>A B.\n       \\<lbrakk>A \\<in> Partition; B \\<in> Partition; A \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> A \\<inter> B = {}", "assume distinct: \"A \\<noteq> B\""], ["proof (state)\nthis:\n  A \\<noteq> B\n\ngoal (4 subgoals):\n 1. Partition \\<subseteq> Pow S\n 2. {} \\<notin> Partition\n 3. \\<Union> Partition = S\n 4. \\<And>A B.\n       \\<lbrakk>A \\<in> Partition; B \\<in> Partition; A \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> A \\<inter> B = {}", "then"], ["proof (chain)\npicking this:\n  A \\<noteq> B", "show \"A \\<inter> B = {}\""], ["proof (prove)\nusing this:\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. A \\<inter> B = {}", "proof (rule contrapos_np)"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow> A = B", "assume not_disjoint: \"A \\<inter> B \\<noteq> {}\""], ["proof (state)\nthis:\n  A \\<inter> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow> A = B", "then"], ["proof (chain)\npicking this:\n  A \\<inter> B \\<noteq> {}", "show \"A = B\""], ["proof (prove)\nusing this:\n  A \\<inter> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A = B", "by (simp add: eq) (metis not_disjoint_implies_equal ab)"], ["proof (state)\nthis:\n  A = B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A \\<inter> B = {}\n\ngoal (3 subgoals):\n 1. Partition \\<subseteq> Pow S\n 2. {} \\<notin> Partition\n 3. \\<Union> Partition = S", "qed (auto simp: Partition_def)"], ["", "end"], ["", "(* equivalence *)"], ["", "context partition begin"], ["", "text \\<open>p 12, ll 9--10\\<close>"], ["", "theorem block_exists:\n  \"a \\<in> S \\<Longrightarrow> \\<exists>A. a \\<in> A \\<and> A \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow> \\<exists>A. a \\<in> A \\<and> A \\<in> P", "using complete"], ["proof (prove)\nusing this:\n  \\<Union> P = S\n\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow> \\<exists>A. a \\<in> A \\<and> A \\<in> P", "by blast"], ["", "text \\<open>p 12, ll 9--10\\<close>"], ["", "theorem block_unique:\n  \"\\<lbrakk> a \\<in> A; A \\<in> P; a \\<in> B; B \\<in> P \\<rbrakk> \\<Longrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A; A \\<in> P; a \\<in> B; B \\<in> P\\<rbrakk>\n    \\<Longrightarrow> A = B", "using disjoint"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> P; ?B \\<in> P; ?A \\<noteq> ?B\\<rbrakk>\n  \\<Longrightarrow> ?A \\<inter> ?B = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A; A \\<in> P; a \\<in> B; B \\<in> P\\<rbrakk>\n    \\<Longrightarrow> A = B", "by blast"], ["", "text \\<open>p 12, ll 9--10\\<close>"], ["", "lemma block_closed [intro]: (* inefficient as a simp rule *)\n  \"\\<lbrakk> a \\<in> A; A \\<in> P \\<rbrakk> \\<Longrightarrow> a \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A; A \\<in> P\\<rbrakk> \\<Longrightarrow> a \\<in> S", "using complete"], ["proof (prove)\nusing this:\n  \\<Union> P = S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A; A \\<in> P\\<rbrakk> \\<Longrightarrow> a \\<in> S", "by blast"], ["", "text \\<open>p 12, ll 9--10\\<close>"], ["", "lemma element_exists:\n  \"A \\<in> P \\<Longrightarrow> \\<exists>a \\<in> S. a \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> P \\<Longrightarrow> \\<exists>a\\<in>S. a \\<in> A", "by (metis non_vacuous block_closed all_not_in_conv)"], ["", "text \\<open>p 12, ll 9--10\\<close>"], ["", "definition \"Block = (\\<lambda>a \\<in> S. THE A. a \\<in> A \\<and> A \\<in> P)\""], ["", "text \\<open>p 12, ll 9--10\\<close>"], ["", "lemma Block_closed [intro, simp]:\n  assumes [intro]: \"a \\<in> S\" shows \"Block a \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Block a \\<in> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Block a \\<in> P", "obtain A where \"a \\<in> A\" \"A \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>a \\<in> A; A \\<in> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using block_exists"], ["proof (prove)\nusing this:\n  ?a \\<in> S \\<Longrightarrow> \\<exists>A. ?a \\<in> A \\<and> A \\<in> P\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>a \\<in> A; A \\<in> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> A\n  A \\<in> P\n\ngoal (1 subgoal):\n 1. Block a \\<in> P", "then"], ["proof (chain)\npicking this:\n  a \\<in> A\n  A \\<in> P", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> A\n  A \\<in> P\n\ngoal (1 subgoal):\n 1. Block a \\<in> P", "apply (auto simp: Block_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A; A \\<in> P; a \\<in> S\\<rbrakk>\n    \\<Longrightarrow> (THE A. a \\<in> A \\<and> A \\<in> P) \\<in> P", "apply (rule theI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<in> A; A \\<in> P; a \\<in> S\\<rbrakk>\n    \\<Longrightarrow> a \\<in> ?a13 \\<and> ?a13 \\<in> P\n 2. \\<And>x.\n       \\<lbrakk>a \\<in> A; A \\<in> P; a \\<in> S;\n        a \\<in> x \\<and> x \\<in> P\\<rbrakk>\n       \\<Longrightarrow> x = ?a13\n 3. \\<And>x.\n       \\<lbrakk>a \\<in> A; A \\<in> P; a \\<in> S;\n        a \\<in> x \\<and> x \\<in> P\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P", "apply (auto dest: block_unique)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Block a \\<in> P\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>p 12, ll 9--10\\<close>"], ["", "lemma Block_undefined [intro, simp]:\n  \"a \\<notin> S \\<Longrightarrow> Block a = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> S \\<Longrightarrow> Block a = undefined", "unfolding Block_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> S \\<Longrightarrow>\n    (\\<lambda>a\\<in>S. THE A. a \\<in> A \\<and> A \\<in> P) a = undefined", "by simp"], ["", "text \\<open>p 12, ll 9--10\\<close>"], ["", "lemma Block_self:\n  \"\\<lbrakk> a \\<in> A; A \\<in> P \\<rbrakk> \\<Longrightarrow> Block a = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A; A \\<in> P\\<rbrakk> \\<Longrightarrow> Block a = A", "apply (simp add: Block_def block_closed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A; A \\<in> P\\<rbrakk>\n    \\<Longrightarrow> (THE A. a \\<in> A \\<and> A \\<in> P) = A", "apply (rule the_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> A; A \\<in> P\\<rbrakk>\n    \\<Longrightarrow> a \\<in> A \\<and> A \\<in> P\n 2. \\<And>Aa.\n       \\<lbrakk>a \\<in> A; A \\<in> P; a \\<in> Aa \\<and> Aa \\<in> P\\<rbrakk>\n       \\<Longrightarrow> Aa = A", "apply (auto dest: block_unique)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>p 12, ll 10--11\\<close>"], ["", "definition \"Equivalence = {(a, b) . \\<exists>A \\<in> P. a \\<in> A \\<and> b \\<in> A}\""], ["", "text \\<open>p 12, ll 11--12\\<close>"], ["", "theorem equivalence: \"equivalence S Equivalence\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence S Equivalence", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. Equivalence \\<subseteq> S \\<times> S\n 2. \\<And>a. a \\<in> S \\<Longrightarrow> (a, a) \\<in> Equivalence\n 3. \\<And>a b.\n       (a, b) \\<in> Equivalence \\<Longrightarrow> (b, a) \\<in> Equivalence\n 4. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "show \"Equivalence \\<subseteq> S \\<times> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Equivalence \\<subseteq> S \\<times> S", "unfolding Equivalence_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}\n    \\<subseteq> S \\<times> S", "using subset"], ["proof (prove)\nusing this:\n  P \\<subseteq> Pow S\n\ngoal (1 subgoal):\n 1. {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}\n    \\<subseteq> S \\<times> S", "by auto"], ["proof (state)\nthis:\n  Equivalence \\<subseteq> S \\<times> S\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> S \\<Longrightarrow> (a, a) \\<in> Equivalence\n 2. \\<And>a b.\n       (a, b) \\<in> Equivalence \\<Longrightarrow> (b, a) \\<in> Equivalence\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> S \\<Longrightarrow> (a, a) \\<in> Equivalence\n 2. \\<And>a b.\n       (a, b) \\<in> Equivalence \\<Longrightarrow> (b, a) \\<in> Equivalence\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "fix a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> S \\<Longrightarrow> (a, a) \\<in> Equivalence\n 2. \\<And>a b.\n       (a, b) \\<in> Equivalence \\<Longrightarrow> (b, a) \\<in> Equivalence\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "assume \"a \\<in> S\""], ["proof (state)\nthis:\n  a \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<in> S \\<Longrightarrow> (a, a) \\<in> Equivalence\n 2. \\<And>a b.\n       (a, b) \\<in> Equivalence \\<Longrightarrow> (b, a) \\<in> Equivalence\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "then"], ["proof (chain)\npicking this:\n  a \\<in> S", "show \"(a, a) \\<in> Equivalence\""], ["proof (prove)\nusing this:\n  a \\<in> S\n\ngoal (1 subgoal):\n 1. (a, a) \\<in> Equivalence", "unfolding Equivalence_def"], ["proof (prove)\nusing this:\n  a \\<in> S\n\ngoal (1 subgoal):\n 1. (a, a) \\<in> {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}", "using complete"], ["proof (prove)\nusing this:\n  a \\<in> S\n  \\<Union> P = S\n\ngoal (1 subgoal):\n 1. (a, a) \\<in> {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}", "by auto"], ["proof (state)\nthis:\n  (a, a) \\<in> Equivalence\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> Equivalence \\<Longrightarrow> (b, a) \\<in> Equivalence\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> Equivalence \\<Longrightarrow> (b, a) \\<in> Equivalence\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "fix a and b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> Equivalence \\<Longrightarrow> (b, a) \\<in> Equivalence\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "assume \"(a, b) \\<in> Equivalence\""], ["proof (state)\nthis:\n  (a, b) \\<in> Equivalence\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> Equivalence \\<Longrightarrow> (b, a) \\<in> Equivalence\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> Equivalence", "show \"(b, a) \\<in> Equivalence\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> Equivalence\n\ngoal (1 subgoal):\n 1. (b, a) \\<in> Equivalence", "unfolding Equivalence_def"], ["proof (prove)\nusing this:\n  (a, b) \\<in> {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}\n\ngoal (1 subgoal):\n 1. (b, a) \\<in> {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}", "by auto"], ["proof (state)\nthis:\n  (b, a) \\<in> Equivalence\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "fix a and b and c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "assume \"(a, b) \\<in> Equivalence\" \"(b, c) \\<in> Equivalence\""], ["proof (state)\nthis:\n  (a, b) \\<in> Equivalence\n  (b, c) \\<in> Equivalence\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> Equivalence; (b, c) \\<in> Equivalence\\<rbrakk>\n       \\<Longrightarrow> (a, c) \\<in> Equivalence", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> Equivalence\n  (b, c) \\<in> Equivalence", "show \"(a, c) \\<in> Equivalence\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> Equivalence\n  (b, c) \\<in> Equivalence\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> Equivalence", "unfolding Equivalence_def"], ["proof (prove)\nusing this:\n  (a, b) \\<in> {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}\n  (b, c) \\<in> {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}", "using disjoint"], ["proof (prove)\nusing this:\n  (a, b) \\<in> {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}\n  (b, c) \\<in> {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}\n  \\<lbrakk>?A \\<in> P; ?B \\<in> P; ?A \\<noteq> ?B\\<rbrakk>\n  \\<Longrightarrow> ?A \\<inter> ?B = {}\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> {(a, b). \\<exists>A\\<in>P. a \\<in> A \\<and> b \\<in> A}", "by auto"], ["proof (state)\nthis:\n  (a, c) \\<in> Equivalence\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Temporarily introduce equivalence associated to partition.\\<close>"], ["", "text \\<open>p 12, ll 12--14\\<close>"], ["", "interpretation equivalence S Equivalence"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence S Equivalence", "by (rule equivalence)"], ["", "text \\<open>p 12, ll 12--14\\<close>"], ["", "theorem Class_is_Block:\n  assumes \"a \\<in> S\" shows \"Class a = Block a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Class a = Block a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Class a = Block a", "from \\<open>a \\<in> S\\<close> and block_exists"], ["proof (chain)\npicking this:\n  a \\<in> S\n  ?a \\<in> S \\<Longrightarrow> \\<exists>A. ?a \\<in> A \\<and> A \\<in> P", "obtain A where block: \"a \\<in> A \\<and> A \\<in> P\""], ["proof (prove)\nusing this:\n  a \\<in> S\n  ?a \\<in> S \\<Longrightarrow> \\<exists>A. ?a \\<in> A \\<and> A \\<in> P\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        a \\<in> A \\<and> A \\<in> P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> A \\<and> A \\<in> P\n\ngoal (1 subgoal):\n 1. Class a = Block a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Class a = Block a", "apply (simp add: Block_def Class_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> S \\<longrightarrow>\n    {b \\<in> S. (b, a) \\<in> Equivalence} =\n    (THE A. a \\<in> A \\<and> A \\<in> P)", "apply (rule theI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. a \\<in> ?a6 \\<and> ?a6 \\<in> P\n 2. \\<And>x. a \\<in> x \\<and> x \\<in> P \\<Longrightarrow> x = ?a6\n 3. \\<And>x.\n       a \\<in> x \\<and> x \\<in> P \\<Longrightarrow>\n       a \\<in> S \\<longrightarrow> {b \\<in> S. (b, a) \\<in> Equivalence} = x", "apply (rule block)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. a \\<in> x \\<and> x \\<in> P \\<Longrightarrow> x = A\n 2. \\<And>x.\n       a \\<in> x \\<and> x \\<in> P \\<Longrightarrow>\n       a \\<in> S \\<longrightarrow> {b \\<in> S. (b, a) \\<in> Equivalence} = x", "apply (metis block block_unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a \\<in> x \\<and> x \\<in> P \\<Longrightarrow>\n       a \\<in> S \\<longrightarrow> {b \\<in> S. (b, a) \\<in> Equivalence} = x", "apply (auto dest: block_unique simp: Equivalence_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Class a = Block a\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>p 12, l 14\\<close>"], ["", "lemma Class_equals_Block:\n  \"Class = Block\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Class = Block", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Class x = Block x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Class x = Block x", "show \"Class x = Block x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Class x = Block x", "by (cases \"x \\<in> S\") (auto simp: Class_is_Block)"], ["proof (state)\nthis:\n  Class x = Block x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>p 12, l 14\\<close>"], ["", "theorem partition_of_equivalence:\n  \"Partition = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partition = P", "by (auto simp add: Partition_def Class_equals_Block image_iff) (metis Block_self element_exists)"], ["", "end"], ["", "(* partition *)"], ["", "context equivalence begin"], ["", "text \\<open>p 12, ll 14--17\\<close>"], ["", "interpretation partition S Partition"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition S Partition", "by (rule partition)"], ["", "text \\<open>p 12, ll 14--17\\<close>"], ["", "theorem equivalence_of_partition:\n  \"Equivalence = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Equivalence = E", "unfolding Equivalence_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). \\<exists>A\\<in>Partition. a \\<in> A \\<and> b \\<in> A} = E", "unfolding Partition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). \\<exists>A\\<in>Class ` S. a \\<in> A \\<and> b \\<in> A} = E", "by auto (metis ClassD Class_closed Class_eq)"], ["", "end"], ["", "(* equivalence *)"], ["", "text \\<open>p 12, l 14\\<close>"], ["", "sublocale partition \\<subseteq> equivalence S Equivalence\n  rewrites \"equivalence.Partition S Equivalence = P\" and \"equivalence.Class S Equivalence = Block\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence S Equivalence &&&\n    equivalence.Partition S Equivalence = P &&&\n    equivalence.Class S Equivalence = Block", "apply (rule equivalence)"], ["proof (prove)\ngoal (2 subgoals):\n 1. equivalence.Partition S Equivalence = P\n 2. equivalence.Class S Equivalence = Block", "apply (rule partition_of_equivalence)"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence.Class S Equivalence = Block", "apply (rule Class_equals_Block)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>p 12, ll 14--17\\<close>"], ["", "sublocale equivalence \\<subseteq> partition S Partition\n  rewrites \"partition.Equivalence Partition = E\" and \"partition.Block S Partition = Class\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition S Partition &&&\n    partition.Equivalence Partition = E &&&\n    partition.Block S Partition = Class", "apply (rule partition)"], ["proof (prove)\ngoal (2 subgoals):\n 1. partition.Equivalence Partition = E\n 2. partition.Block S Partition = Class", "apply (rule equivalence_of_partition)"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition.Block S Partition = Class", "apply (metis equivalence_of_partition partition partition.Class_equals_Block)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Unfortunately only effective on input\\<close>"], ["", "text \\<open>p 12, ll 18--20\\<close>"], ["", "notation equivalence.Partition (infixl \"'/\" 75)"], ["", "context equivalence begin"], ["", "text \\<open>p 12, ll 18--20\\<close>"], ["", "lemma representant_exists [dest]: \"A \\<in> S / E \\<Longrightarrow> \\<exists>a\\<in>S. a \\<in> A \\<and> A = Class a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> Partition \\<Longrightarrow>\n    \\<exists>a\\<in>S. a \\<in> A \\<and> A = Class a", "by (metis Block_self element_exists)"], ["", "text \\<open>p 12, ll 18--20\\<close>"], ["", "lemma quotient_ClassE: \"A \\<in> S / E \\<Longrightarrow> (\\<And>a. a \\<in> S \\<Longrightarrow> P (Class a)) \\<Longrightarrow> P A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> Partition;\n     \\<And>a. a \\<in> S \\<Longrightarrow> P (Class a)\\<rbrakk>\n    \\<Longrightarrow> P A", "using representant_exists"], ["proof (prove)\nusing this:\n  ?A \\<in> Partition \\<Longrightarrow>\n  \\<exists>a\\<in>S. a \\<in> ?A \\<and> ?A = Class a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> Partition;\n     \\<And>a. a \\<in> S \\<Longrightarrow> P (Class a)\\<rbrakk>\n    \\<Longrightarrow> P A", "by blast"], ["", "end"], ["", "(* equivalence *)"], ["", "text \\<open>p 12, ll 21--23\\<close>"], ["", "sublocale equivalence \\<subseteq> natural: surjective_map Class S \"S / E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective_map Class S Partition", "by unfold_locales force+"], ["", "text \\<open>Technical device to achieve Jacobson's syntax; context where @{text \\<alpha>} is not a parameter.\\<close>"], ["", "text \\<open>p 12, ll 25--26\\<close>"], ["", "locale fiber_relation_notation = fixes S :: \"'a set\" begin"], ["", "text \\<open>p 12, ll 25--26\\<close>"], ["", "definition Fiber_Relation (\"E'(_')\") where \"Fiber_Relation \\<alpha> = {(x, y). x \\<in> S \\<and> y \\<in> S \\<and> \\<alpha> x = \\<alpha> y}\""], ["", "end"], ["", "(* fiber_relation_notation *)"], ["", "text \\<open>\n  Context where classes and the induced map are defined through the fiber relation.\n  This will be the case for monoid homomorphisms but not group homomorphisms.\n\\<close>"], ["", "text \\<open>Avoids infinite interpretation chain.\\<close>"], ["", "text \\<open>p 12, ll 25--26\\<close>"], ["", "locale fiber_relation = map begin"], ["", "text \\<open>Install syntax\\<close>"], ["", "text \\<open>p 12, ll 25--26\\<close>"], ["", "sublocale fiber_relation_notation"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>p 12, ll 26--27\\<close>"], ["", "sublocale equivalence where E = \"E(\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence S E(\\<alpha>)", "unfolding Fiber_Relation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence S\n     {(x, y). x \\<in> S \\<and> y \\<in> S \\<and> \\<alpha> x = \\<alpha> y}", "by unfold_locales auto"], ["", "text \\<open>``define $\\bar{\\alpha}$ by $\\bar{\\alpha}(\\bar{a}) = \\alpha(a)$''\\<close>"], ["", "text \\<open>p 13, ll 8--9\\<close>"], ["", "definition \"induced = (\\<lambda>A \\<in> S / E(\\<alpha>). THE b. \\<exists>a \\<in> A. b = \\<alpha> a)\""], ["", "text \\<open>p 13, l 10\\<close>"], ["", "theorem Fiber_equality:\n  \"\\<lbrakk> a \\<in> S; b \\<in> S \\<rbrakk> \\<Longrightarrow> Class a = Class b \\<longleftrightarrow> \\<alpha> a = \\<alpha> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S\\<rbrakk>\n    \\<Longrightarrow> (Class a = Class b) = (\\<alpha> a = \\<alpha> b)", "unfolding Class_equivalence"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S\\<rbrakk>\n    \\<Longrightarrow> ((a, b) \\<in> E(\\<alpha>)) = (\\<alpha> a = \\<alpha> b)", "unfolding Fiber_Relation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> S; b \\<in> S\\<rbrakk>\n    \\<Longrightarrow> ((a, b)\n                       \\<in> {(x, y).\n                              x \\<in> S \\<and>\n                              y \\<in> S \\<and> \\<alpha> x = \\<alpha> y}) =\n                      (\\<alpha> a = \\<alpha> b)", "by simp"], ["", "text \\<open>p 13, ll 8--9\\<close>"], ["", "theorem induced_Fiber_simp [simp]:\n  assumes [intro, simp]: \"a \\<in> S\" shows \"induced (Class a) = \\<alpha> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced (Class a) = \\<alpha> a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. induced (Class a) = \\<alpha> a", "have \"(THE b. \\<exists>a\\<in>Class a. b = \\<alpha> a) = \\<alpha> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE b. \\<exists>a\\<in>Class a. b = \\<alpha> a) = \\<alpha> a", "by (rule the_equality) (auto simp: Fiber_equality [symmetric] Block_self block_closed)"], ["proof (state)\nthis:\n  (THE b. \\<exists>a\\<in>Class a. b = \\<alpha> a) = \\<alpha> a\n\ngoal (1 subgoal):\n 1. induced (Class a) = \\<alpha> a", "then"], ["proof (chain)\npicking this:\n  (THE b. \\<exists>a\\<in>Class a. b = \\<alpha> a) = \\<alpha> a", "show ?thesis"], ["proof (prove)\nusing this:\n  (THE b. \\<exists>a\\<in>Class a. b = \\<alpha> a) = \\<alpha> a\n\ngoal (1 subgoal):\n 1. induced (Class a) = \\<alpha> a", "unfolding induced_def"], ["proof (prove)\nusing this:\n  (THE b. \\<exists>a\\<in>Class a. b = \\<alpha> a) = \\<alpha> a\n\ngoal (1 subgoal):\n 1. (\\<lambda>A\\<in>Partition. THE b. \\<exists>a\\<in>A. b = \\<alpha> a)\n     (Class a) =\n    \\<alpha> a", "by simp"], ["proof (state)\nthis:\n  induced (Class a) = \\<alpha> a\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>p 13, ll 10--11\\<close>"], ["", "interpretation induced: map induced \"S / E(\\<alpha>)\" T"], ["proof (prove)\ngoal (1 subgoal):\n 1. map induced Partition T", "proof (unfold_locales, rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> Partition \\<Longrightarrow> induced x \\<in> T\n 2. \\<And>x. x \\<notin> Partition \\<Longrightarrow> induced x = undefined", "fix A"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> Partition \\<Longrightarrow> induced x \\<in> T\n 2. \\<And>x. x \\<notin> Partition \\<Longrightarrow> induced x = undefined", "assume [intro, simp]: \"A \\<in> S / E(\\<alpha>)\""], ["proof (state)\nthis:\n  A \\<in> Partition\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> Partition \\<Longrightarrow> induced x \\<in> T\n 2. \\<And>x. x \\<notin> Partition \\<Longrightarrow> induced x = undefined", "obtain a where a: \"a \\<in> S\" \"a \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> S; a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using element_exists"], ["proof (prove)\nusing this:\n  ?A \\<in> Partition \\<Longrightarrow> \\<exists>a\\<in>S. a \\<in> ?A\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> S; a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> S\n  a \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> Partition \\<Longrightarrow> induced x \\<in> T\n 2. \\<And>x. x \\<notin> Partition \\<Longrightarrow> induced x = undefined", "have \"(THE b. \\<exists>a\\<in>A. b = \\<alpha> a) \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE b. \\<exists>a\\<in>A. b = \\<alpha> a) \\<in> T", "apply (rule theI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>a\\<in>A. ?a = \\<alpha> a\n 2. \\<And>x. \\<exists>a\\<in>A. x = \\<alpha> a \\<Longrightarrow> x = ?a\n 3. \\<And>x. \\<exists>a\\<in>A. x = \\<alpha> a \\<Longrightarrow> x \\<in> T", "using a"], ["proof (prove)\nusing this:\n  a \\<in> S\n  a \\<in> A\n\ngoal (3 subgoals):\n 1. \\<exists>a\\<in>A. ?a = \\<alpha> a\n 2. \\<And>x. \\<exists>a\\<in>A. x = \\<alpha> a \\<Longrightarrow> x = ?a\n 3. \\<And>x. \\<exists>a\\<in>A. x = \\<alpha> a \\<Longrightarrow> x \\<in> T", "apply (auto simp: Fiber_equality [symmetric] Block_self block_closed)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (THE b. \\<exists>a\\<in>A. b = \\<alpha> a) \\<in> T\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> Partition \\<Longrightarrow> induced x \\<in> T\n 2. \\<And>x. x \\<notin> Partition \\<Longrightarrow> induced x = undefined", "then"], ["proof (chain)\npicking this:\n  (THE b. \\<exists>a\\<in>A. b = \\<alpha> a) \\<in> T", "show \"induced A \\<in> T\""], ["proof (prove)\nusing this:\n  (THE b. \\<exists>a\\<in>A. b = \\<alpha> a) \\<in> T\n\ngoal (1 subgoal):\n 1. induced A \\<in> T", "unfolding induced_def"], ["proof (prove)\nusing this:\n  (THE b. \\<exists>a\\<in>A. b = \\<alpha> a) \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<lambda>A\\<in>Partition. THE b. \\<exists>a\\<in>A. b = \\<alpha> a) A\n    \\<in> T", "by simp"], ["proof (state)\nthis:\n  induced A \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> Partition \\<Longrightarrow> induced x = undefined", "qed (simp add: induced_def)"], ["", "text \\<open>p 13, ll 12--13\\<close>"], ["", "sublocale induced: injective_map induced \"S / E(\\<alpha>)\" T"], ["proof (prove)\ngoal (1 subgoal):\n 1. injective_map induced Partition T", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on induced Partition", "show \"inj_on induced Partition\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on induced Partition", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Partition.\n       \\<forall>y\\<in>Partition.\n          induced x = induced y \\<longrightarrow> x = y", "by (metis Fiber_equality Block_self element_exists induced_Fiber_simp)"], ["proof (state)\nthis:\n  inj_on induced Partition\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>p 13, ll 16--19\\<close>"], ["", "theorem factorization_lemma:\n  \"a \\<in> S \\<Longrightarrow> compose S induced Class a = \\<alpha> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow> compose S induced Class a = \\<alpha> a", "by (simp add: compose_eq)"], ["", "text \\<open>p 13, ll 16--19\\<close>"], ["", "theorem factorization [simp]: \"compose S induced Class = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose S induced Class = \\<alpha>", "by (rule ext) (simp add: compose_def map_undefined)"], ["", "text \\<open>p 14, ll 2--4\\<close>"], ["", "theorem uniqueness:\n  assumes map: \"\\<beta> \\<in> S / E(\\<alpha>) \\<rightarrow>\\<^sub>E T\"\n    and factorization: \"compose S \\<beta> Class = \\<alpha>\"\n  shows \"\\<beta> = induced\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> = induced", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<beta> x = induced x", "fix A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<beta> x = induced x", "show \"\\<beta> A = induced A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> A = induced A", "proof (cases \"A \\<in> S / E(\\<alpha>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<in> Partition \\<Longrightarrow> \\<beta> A = induced A\n 2. A \\<notin> Partition \\<Longrightarrow> \\<beta> A = induced A", "case True"], ["proof (state)\nthis:\n  A \\<in> Partition\n\ngoal (2 subgoals):\n 1. A \\<in> Partition \\<Longrightarrow> \\<beta> A = induced A\n 2. A \\<notin> Partition \\<Longrightarrow> \\<beta> A = induced A", "then"], ["proof (chain)\npicking this:\n  A \\<in> Partition", "obtain a where [simp]: \"A = Class a\" \"a \\<in> S\""], ["proof (prove)\nusing this:\n  A \\<in> Partition\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>A = Class a; a \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  A = Class a\n  a \\<in> S\n\ngoal (2 subgoals):\n 1. A \\<in> Partition \\<Longrightarrow> \\<beta> A = induced A\n 2. A \\<notin> Partition \\<Longrightarrow> \\<beta> A = induced A", "then"], ["proof (chain)\npicking this:\n  A = Class a\n  a \\<in> S", "have \"\\<beta> (Class a) = \\<alpha> a\""], ["proof (prove)\nusing this:\n  A = Class a\n  a \\<in> S\n\ngoal (1 subgoal):\n 1. \\<beta> (Class a) = \\<alpha> a", "by (metis compose_eq factorization)"], ["proof (state)\nthis:\n  \\<beta> (Class a) = \\<alpha> a\n\ngoal (2 subgoals):\n 1. A \\<in> Partition \\<Longrightarrow> \\<beta> A = induced A\n 2. A \\<notin> Partition \\<Longrightarrow> \\<beta> A = induced A", "also"], ["proof (state)\nthis:\n  \\<beta> (Class a) = \\<alpha> a\n\ngoal (2 subgoals):\n 1. A \\<in> Partition \\<Longrightarrow> \\<beta> A = induced A\n 2. A \\<notin> Partition \\<Longrightarrow> \\<beta> A = induced A", "have \"\\<dots> = induced (Class a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> a = induced (Class a)", "by simp"], ["proof (state)\nthis:\n  \\<alpha> a = induced (Class a)\n\ngoal (2 subgoals):\n 1. A \\<in> Partition \\<Longrightarrow> \\<beta> A = induced A\n 2. A \\<notin> Partition \\<Longrightarrow> \\<beta> A = induced A", "finally"], ["proof (chain)\npicking this:\n  \\<beta> (Class a) = induced (Class a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> (Class a) = induced (Class a)\n\ngoal (1 subgoal):\n 1. \\<beta> A = induced A", "by simp"], ["proof (state)\nthis:\n  \\<beta> A = induced A\n\ngoal (1 subgoal):\n 1. A \\<notin> Partition \\<Longrightarrow> \\<beta> A = induced A", "qed (simp add: induced_def PiE_arb [OF map])"], ["proof (state)\nthis:\n  \\<beta> A = induced A\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* fiber_relation *)"], ["", "end"]]}