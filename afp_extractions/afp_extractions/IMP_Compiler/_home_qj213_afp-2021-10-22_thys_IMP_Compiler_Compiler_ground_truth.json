{"file_name": "/home/qj213/afp-2021-10-22/thys/IMP_Compiler/Compiler.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IMP_Compiler", "problem_names": ["lemma inth_append [simp]:\n \"0 \\<le> i \\<Longrightarrow>\n    (xs @ ys) !! i = (if i < size xs then xs !! i else ys !! (i - size xs))\"", "lemma impCE2 [elim!]:\n \"\\<lbrakk>P \\<longrightarrow> Q; \\<not> P \\<Longrightarrow> R; P \\<Longrightarrow> Q \\<Longrightarrow> R\\<rbrakk> \\<Longrightarrow> R\"", "lemma Suc_lessI2 [intro!]:\n \"\\<lbrakk>m < n; m \\<noteq> n - 1\\<rbrakk> \\<Longrightarrow> Suc m < n\""], "translations": [["", "lemma inth_append [simp]:\n \"0 \\<le> i \\<Longrightarrow>\n    (xs @ ys) !! i = (if i < size xs then xs !! i else ys !! (i - size xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> i \\<Longrightarrow>\n    (xs @ ys) !! i = (if i < size xs then xs !! i else ys !! (i - size xs))", "by (induction xs arbitrary: i, auto simp: algebra_simps)"], ["", "text \\<open>\n\\null\n\nNext, the instruction set and its semantics are defined. Particularly, to allow for the compilation\nof non-deterministic choice commands, the instruction set is extended with an additional instruction\n@{text JMPND} performing a non-deterministic jump -- viz. as a result of its execution, the program\ncounter unconditionally either jumps by the specified offset, or just moves to the next instruction.\n\nAs instruction execution can be non-deterministic, an inductively defined predicate @{text iexec},\nrather than a simple non-recursive function as the one used in @{cite \"Klein21\"}, must be introduced\nto define instruction semantics.\n\n\\null\n\\<close>"], ["", "datatype instr = \n  LOADI int | LOAD vname | ADD | STORE vname |\n  JMP int | JMPLESS int | JMPGE int | JMPND int"], ["", "type_synonym stack = \"val list\""], ["", "type_synonym config = \"int \\<times> state \\<times> stack\""], ["", "abbreviation \"hd2 xs \\<equiv> hd (tl xs)\""], ["", "abbreviation \"tl2 xs \\<equiv> tl (tl xs)\""], ["", "inductive iexec :: \"instr \\<times> config \\<Rightarrow> config \\<Rightarrow> bool\" (infix \"\\<mapsto>\" 55) where\nLoadI:  \"(LOADI i, pc, s, stk) \\<mapsto> (pc + 1, s, i # stk)\" |\nLoad:  \"(LOAD x, pc, s, stk) \\<mapsto> (pc + 1, s, s x # stk)\" |\nAdd:  \"(ADD, pc, s, stk) \\<mapsto> (pc + 1, s, (hd2 stk + hd stk) # tl2 stk)\" |\nStore:  \"(STORE x, pc, s, stk) \\<mapsto> (pc + 1, s(x := hd stk), tl stk)\" |\nJmp:  \"(JMP i, pc, s, stk) \\<mapsto> (pc + i + 1, s, stk)\" |\nJmpLessY:  \"hd2 stk < hd stk \\<Longrightarrow>\n  (JMPLESS i, pc, s, stk) \\<mapsto> (pc + i + 1, s, tl2 stk)\" |\nJmpLessN:  \"hd stk \\<le> hd2 stk \\<Longrightarrow>\n  (JMPLESS i, pc, s, stk) \\<mapsto> (pc + 1, s, tl2 stk)\" |\nJmpGeY:  \"hd stk \\<le> hd2 stk \\<Longrightarrow>\n  (JMPGE i, pc, s, stk) \\<mapsto> (pc + i + 1, s, tl2 stk)\" |\nJmpGeN:  \"hd2 stk < hd stk \\<Longrightarrow>\n  (JMPGE i, pc, s, stk) \\<mapsto> (pc + 1, s, tl2 stk)\" |\nJmpNdY:  \"(JMPND i, pc, s, stk) \\<mapsto> (pc + i + 1, s, stk)\" |\nJmpNdN:  \"(JMPND i, pc, s, stk) \\<mapsto> (pc + 1, s, stk)\""], ["", "declare iexec.intros [intro]"], ["", "inductive_cases LoadIE  [elim!]:  \"(LOADI i, pc, s, stk) \\<mapsto> cf\""], ["", "inductive_cases LoadE  [elim!]:  \"(LOAD x, pc, s, stk) \\<mapsto> cf\""], ["", "inductive_cases AddE  [elim!]:  \"(ADD, pc, s, stk) \\<mapsto> cf\""], ["", "inductive_cases StoreE  [elim!]:  \"(STORE x, pc, s, stk) \\<mapsto> cf\""], ["", "inductive_cases JmpE  [elim!]:  \"(JMP i, pc, s, stk) \\<mapsto> cf\""], ["", "inductive_cases JmpLessE  [elim!]:  \"(JMPLESS i, pc, s, stk) \\<mapsto> cf\""], ["", "inductive_cases JmpGeE  [elim!]:  \"(JMPGE i, pc, s, stk) \\<mapsto> cf\""], ["", "inductive_cases JmpNdE  [elim!]:  \"(JMPND i, pc, s, stk) \\<mapsto> cf\""], ["", "definition exec1 :: \"instr list \\<Rightarrow> config \\<Rightarrow> config \\<Rightarrow> bool\"\n  (\"(_/ \\<turnstile>/ _/ \\<rightarrow>/ _)\" 55) where\n\"P \\<turnstile> cf \\<rightarrow> cf' \\<equiv> (P !! fst cf, cf) \\<mapsto> cf' \\<and> 0 \\<le> fst cf \\<and> fst cf < size P\""], ["", "abbreviation exec :: \"instr list \\<Rightarrow> config \\<Rightarrow> config \\<Rightarrow> bool\"\n  (\"(_/ \\<turnstile>/ _/ \\<rightarrow>*/ _)\" 55) where\n\"exec P \\<equiv> star (exec1 P)\""], ["", "text \\<open>\n\\null\n\nNext, compilation is formalized for arithmetic and boolean expressions (functions @{text acomp} and\n@{text bcomp}), as well as for commands (function @{text ccomp}). Particularly, as opposed to what\nhappens in @{cite \"Klein21\"}, here @{text bcomp} takes a single input, viz. a 3-tuple comprised of\na boolean expression, a flag, and a jump offset. In this way, all three functions accept a single\ninput, which enables to streamline the compiler correctness proof developed in what follows.\n\n\\null\n\\<close>"], ["", "primrec acomp :: \"aexp \\<Rightarrow> instr list\" where\n\"acomp (N i) = [LOADI i]\" |\n\"acomp (V x) = [LOAD x]\" |\n\"acomp (Plus a\\<^sub>1 a\\<^sub>2) = acomp a\\<^sub>1 @ acomp a\\<^sub>2 @ [ADD]\""], ["", "fun bcomp :: \"bexp \\<times> bool \\<times> int \\<Rightarrow> instr list\" where\n\"bcomp (Bc v, f, i) = (if v = f then [JMP i] else [])\" |\n\"bcomp (Not b, f, i) = bcomp (b, \\<not> f, i)\" |\n\"bcomp (And b\\<^sub>1 b\\<^sub>2, f, i) =\n  (let cb\\<^sub>2 = bcomp (b\\<^sub>2, f, i);\n     cb\\<^sub>1 = bcomp (b\\<^sub>1, False, size cb\\<^sub>2 + (if f then 0 else i))\n   in cb\\<^sub>1 @ cb\\<^sub>2)\" |\n\"bcomp (Less a\\<^sub>1 a\\<^sub>2, f, i) =\n  acomp a\\<^sub>1 @ acomp a\\<^sub>2 @ (if f then [JMPLESS i] else [JMPGE i])\""], ["", "primrec ccomp :: \"com \\<Rightarrow> instr list\" where\n\"ccomp SKIP = []\" |\n\"ccomp (x ::= a) = acomp a @ [STORE x]\" |\n\"ccomp (c\\<^sub>1;; c\\<^sub>2) = ccomp c\\<^sub>1 @ ccomp c\\<^sub>2\" |\n\"ccomp (IF b THEN c\\<^sub>1 ELSE c\\<^sub>2) =\n  (let cc\\<^sub>1 = ccomp c\\<^sub>1; cc\\<^sub>2 = ccomp c\\<^sub>2; cb = bcomp (b, False, size cc\\<^sub>1 + 1)\n   in cb @ cc\\<^sub>1 @ JMP (size cc\\<^sub>2) # cc\\<^sub>2)\" |\n\"ccomp (c\\<^sub>1 OR c\\<^sub>2) =\n  (let cc\\<^sub>1 = ccomp c\\<^sub>1; cc\\<^sub>2 = ccomp c\\<^sub>2\n   in JMPND (size cc\\<^sub>1 + 1) # cc\\<^sub>1 @ JMP (size cc\\<^sub>2) # cc\\<^sub>2)\" |\n\"ccomp (WHILE b DO c) =\n  (let cc = ccomp c; cb = bcomp (b, False, size cc + 1)\n   in cb @ cc @ [JMP (- (size cb + size cc + 1))])\""], ["", "text \\<open>\n\\null\n\nFinally, two lemmas are proven automatically (both seem not to be included in the standard library,\nthough being quite basic) and registered for use by automatic proof tactics. In more detail:\n\n  \\<^item> The former lemma is an elimination rule similar to @{thm [source] impCE}, with the difference\nthat it retains the antecedent of the implication in the premise where the consequent is assumed to\nhold. This rule permits to have both assumptions @{prop \"\\<not> bval b s\"} and @{prop \"bval b s\"} in the\nrespective cases resulting from the execution of boolean expression @{text b} in state @{text s}.\n\n  \\<^item> The latter one is an introduction rule similar to @{thm [source] Suc_lessI}, with the difference\nthat its second assumption is more convenient for proving statements of the form @{prop \"Suc m < n\"}\narising from the compiler correctness proof developed in what follows.\n\n\\null\n\\<close>"], ["", "lemma impCE2 [elim!]:\n \"\\<lbrakk>P \\<longrightarrow> Q; \\<not> P \\<Longrightarrow> R; P \\<Longrightarrow> Q \\<Longrightarrow> R\\<rbrakk> \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<longrightarrow> Q; \\<not> P \\<Longrightarrow> R;\n     \\<lbrakk>P; Q\\<rbrakk> \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "by blast"], ["", "lemma Suc_lessI2 [intro!]:\n \"\\<lbrakk>m < n; m \\<noteq> n - 1\\<rbrakk> \\<Longrightarrow> Suc m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < n; m \\<noteq> n - 1\\<rbrakk> \\<Longrightarrow> Suc m < n", "by simp"], ["", "end"]]}