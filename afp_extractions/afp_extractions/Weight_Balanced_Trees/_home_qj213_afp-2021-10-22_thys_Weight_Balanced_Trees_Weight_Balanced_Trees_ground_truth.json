{"file_name": "/home/qj213/afp-2021-10-22/thys/Weight_Balanced_Trees/Weight_Balanced_Trees.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Weight_Balanced_Trees", "problem_names": ["lemma neq_Leaf2_iff: \"t \\<noteq> Leaf \\<longleftrightarrow> (\\<exists>l a n r. t = Node l (a,n) r)\"", "lemma size_wbt_eq_size[simp]: \"wbt t \\<Longrightarrow> size_wbt t = size t\"", "lemma not_Leaf_if_not_balanced1:\n  assumes \"\\<not> balanced1 l r\"\n  shows \"r \\<noteq> Leaf\"", "lemma not_Leaf_if_not_single:\n  assumes \"\\<not> single l r\"\n  shows \"l \\<noteq> Leaf\"", "lemma inorder_rot2:\n  \"B \\<noteq> Leaf \\<Longrightarrow> inorder(rot2 A a B b C) = inorder A @ a # inorder B @ b # inorder C\"", "lemma inorder_rotateL:\n  \"r \\<noteq> Leaf \\<Longrightarrow> inorder(rotateL l a r) = inorder l @ a # inorder r\"", "lemma inorder_rotateR:\n  \"l \\<noteq> Leaf \\<Longrightarrow> inorder(rotateR l a r) = inorder l @ a # inorder r\"", "lemma inorder_insert:\n  \"sorted(inorder t) \\<Longrightarrow> inorder(insert x t) = ins_list x (inorder t)\"", "lemma split_minD:\n  \"split_min t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> x # inorder t' = inorder t\"", "lemma del_maxD:\n  \"del_max t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> inorder t' @ [x] = inorder t\"", "lemma inorder_combine:\n  \"inorder(combine l r) = inorder l @ inorder r\"", "lemma inorder_delete:\n  \"sorted(inorder t) \\<Longrightarrow> inorder(delete x t) = del_list x (inorder t)\"", "lemma size_rot2L[simp]:\n  \"B \\<noteq> Leaf \\<Longrightarrow> size(rot2 A a B b C) = size A + size B + size C + 2\"", "lemma size_rotateR[simp]:\n  \"l \\<noteq> Leaf \\<Longrightarrow> size(rotateR l a r) = size l + size r + 1\"", "lemma size_rotateL[simp]:\n  \"r \\<noteq> Leaf \\<Longrightarrow> size(rotateL l a r) = size l + size r + 1\"", "lemma size_length: \"size t = length (inorder t)\"", "lemma size_insert: \"size (insert x t) = (if isin t x then size t else Suc (size t))\"", "lemma size_delete_if_isin: \"isin t x \\<Longrightarrow> size t = Suc (size(delete x t))\"", "lemma delete_id_if_wbt_notin: \"wbt t \\<Longrightarrow> \\<not> isin t x \\<Longrightarrow> delete x t = t\"", "lemma size_split_min: \"t \\<noteq> Leaf \\<Longrightarrow> size t = Suc (size (snd (split_min t)))\"", "lemma size_del_max: \"t \\<noteq> Leaf \\<Longrightarrow> size t = Suc(size(snd(del_max t)))\"", "lemma wbt_insert:\n  \"wbt t \\<Longrightarrow> wbt (insert x t)\"", "lemma wbt_balanceL:\n  assumes \"wbt (Node l (a, n) r)\" \"wbt l'\" \"size l = size l' + 1\"\n  shows \"wbt (balanceL l' a' r)\"", "lemma wbt_balanceR:\n  assumes \"wbt (Node l (a, n) r)\" \"wbt r'\" \"size r = size r' + 1\"\n  shows \"wbt (balanceR l a' r')\"", "lemma wbt_split_min: \"t \\<noteq> Leaf \\<Longrightarrow> wbt t \\<Longrightarrow> wbt (snd (split_min t))\"", "lemma wbt_del_max: \"t \\<noteq> Leaf \\<Longrightarrow> wbt t \\<Longrightarrow> wbt (snd (del_max t))\"", "lemma wbt_delete: \"wbt t \\<Longrightarrow> wbt (delete x t)\""], "translations": [["", "lemma neq_Leaf2_iff: \"t \\<noteq> Leaf \\<longleftrightarrow> (\\<exists>l a n r. t = Node l (a,n) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<noteq> \\<langle>\\<rangle>) =\n    (\\<exists>l a n r. t = \\<langle>l, (a, n), r\\<rangle>)", "by(cases t) auto"], ["", "type_synonym 'a wbt = \"('a * nat) tree\""], ["", "fun size_wbt :: \"'a wbt \\<Rightarrow> nat\" where\n\"size_wbt Leaf = 0\" |\n\"size_wbt (Node _ (_, n) _) = n\""], ["", "text \\<open>Smart constructor:\\<close>"], ["", "fun N :: \"'a wbt \\<Rightarrow> 'a \\<Rightarrow> 'a wbt \\<Rightarrow> 'a wbt\" where\n\"N l a r = Node l (a, size_wbt l + size_wbt r + 1) r\""], ["", "text \"Basic Rotations:\""], ["", "fun rot1L :: \"'a wbt \\<Rightarrow> 'a \\<Rightarrow> 'a wbt \\<Rightarrow> 'a \\<Rightarrow> 'a wbt \\<Rightarrow> 'a wbt\" where\n\"rot1L A a B b C = N (N A a B) b C\""], ["", "fun rot1R :: \"'a wbt \\<Rightarrow> 'a \\<Rightarrow> 'a wbt \\<Rightarrow> 'a \\<Rightarrow> 'a wbt \\<Rightarrow> 'a wbt\" where\n\"rot1R A a B b C = N A a (N B b C)\""], ["", "fun rot2 :: \"'a wbt \\<Rightarrow> 'a \\<Rightarrow> 'a wbt \\<Rightarrow> 'a \\<Rightarrow> 'a wbt \\<Rightarrow> 'a wbt\" where\n\"rot2 A a (Node B1 (b,_) B2) c C = N (N A a B1) b (N B2 c C)\""], ["", "subsection \"WB trees\""], ["", "text \\<open>\nParameters:\n  \\<^descr> \\<open>\\<Delta>\\<close> determines when a tree needs to be rebalanced\n  \\<^descr> \\<open>\\<Gamma>\\<close> determines whether it needs to be single or double rotation.\n\n\\noindent We represent rational numbers as pairs: \\<open>\\<Delta> = \\<Delta>1/\\<Delta>2\\<close> and \\<open>\\<Gamma> = \\<Gamma>1/\\<Gamma>2\\<close>.\n\\bigskip\n\nHirai and Yamamoto \\cite{HiraiY11} proved that under the following constraints\ninsertion and deletion preserve the WB invariant, i.e.\\\n\\<open>\\<Delta>\\<close> and \\<open>\\<Gamma>\\<close> are \\emph{valid}:\\<close>"], ["", "definition valid_params :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n\"valid_params \\<Delta>1 \\<Delta>2 \\<Gamma>1 \\<Gamma>2 = (\n  \\<Delta>1 * 2 < \\<Delta>2 * 9  \\<comment> \\<open>right: \\<open>\\<Delta> < 4.5\\<close>\\<close> \\<and>\n  \\<Gamma>1 * \\<Delta>2 + \\<Gamma>2 * \\<Delta>2 \\<le> \\<Gamma>2 * \\<Delta>1 \\<comment> \\<open>left: \\<open>\\<Gamma> + 1 \\<le> \\<Delta>\\<close>\\<close> \\<and>\n  \\<Gamma>1 * \\<Delta>1 \\<ge> \\<Gamma>2 * (\\<Delta>1 + \\<Delta>2)  \\<comment> \\<open>lower: \\<open>\\<Gamma> \\<ge> (\\<Delta> + 1) / \\<Delta>\\<close>\\<close> \\<and>\n  \\<comment> \\<open>upper:\\<close>\n  (5*\\<Delta>2 \\<le> 2*\\<Delta>1 \\<and> 1*\\<Delta>1 < 3*\\<Delta>2 \\<longrightarrow> \\<Gamma>1*2 \\<le> \\<Gamma>2*3)\n     \\<comment> \\<open>\\<open>\\<Gamma> \\<le> 3/2\\<close> if \\<open>2.5 \\<le> \\<Delta> < 3\\<close>\\<close> \\<and>\n  (3*\\<Delta>2 \\<le> 1*\\<Delta>1 \\<and> 2*\\<Delta>1 < 7*\\<Delta>2 \\<longrightarrow> \\<Gamma>1*2 \\<le> \\<Gamma>2*4)\n     \\<comment> \\<open>\\<open>\\<Gamma> \\<le> 4/2\\<close> if \\<open>3 \\<le> \\<Delta> < 3.5\\<close>\\<close> \\<and>\n  (7*\\<Delta>2 \\<le> 2*\\<Delta>1 \\<and> 1*\\<Delta>1 < 4*\\<Delta>2 \\<longrightarrow> \\<Gamma>1*3 \\<le> \\<Gamma>2*4)\n     \\<comment> \\<open>\\<open>\\<Gamma> \\<le> 4/3\\<close> when \\<open>3.5 \\<le> \\<Delta> < 4\\<close>\\<close> \\<and>\n  (4*\\<Delta>2 \\<le> 1*\\<Delta>1 \\<and> 2*\\<Delta>1 < 9*\\<Delta>2 \\<longrightarrow> \\<Gamma>1*3 \\<le> \\<Gamma>2*5)\n     \\<comment> \\<open>\\<open>\\<Gamma> \\<le> 5/3\\<close> when \\<open>4 \\<le> \\<Delta> < 4.5\\<close>\\<close>\n  )\""], ["", "text \\<open>We do not make use of these constraints and do not prove that they guarantee\npreservation of the invariant. Instead, we provide generic proofs of invariant preservation\nthat work for many (all?) interpretations of locale \\<open>WBT\\<close> (below) with valid parameters.\nFurther down we demonstrate this by interpreting \\<open>WBT\\<close> with a selection of valid parameters.\n[For some parameters, some \\<open>smt\\<close> proofs fail because \\<open>smt\\<close> on \\<open>nat\\<close>s fails although\non non-negative \\<open>int\\<close>s it succeeds, i.e.\\ the goal should be provable.\nThis is a shortcoming of \\<open>smt\\<close> that is under investigation.]\n\nLocale \\<open>WBT\\<close> comes with some minimal assumptions (\\<open>\\<Gamma>1 > \\<Gamma>2\\<close> and \\<open>\\<Delta>1 > \\<Delta>2\\<close>) which follow\nfrom @{const valid_params} and from which we conclude some simple lemmas.\n\\<close>"], ["", "locale WBT =\nfixes \\<Delta>1 \\<Delta>2 :: nat and \\<Gamma>1 \\<Gamma>2 :: nat\nassumes Delta_gr1: \"\\<Delta>1 > \\<Delta>2\" and Gamma_gr1: \"\\<Gamma>1 > \\<Gamma>2\"\nbegin"], ["", "(* How to prove the assumptions from valid_params:\nlemma Gamma_gr1: \"\\<Gamma>1 > \\<Gamma>2\"\nproof -\n  have \"\\<not> (\\<Delta>1 + \\<Delta>2) * \\<Gamma>2 \\<le> \\<Delta>1 * \\<Gamma>2\" by (simp add: not0)\n  thus ?thesis by (metis order.trans lower mult.commute mult_le_cancel2 not_le)\nqed\n\nlemma Delta_gr2: \"\\<Delta>1 > 2 * \\<Delta>2\"\nproof -\n  from Gamma_gr1 have \"\\<Gamma>2 * \\<Delta>2 < \\<Gamma>1 * \\<Delta>2\" by (simp add: not0)\n  with left have \"2 * \\<Gamma>2 * \\<Delta>2 < \\<Gamma>2 * \\<Delta>1\" by linarith\n  thus ?thesis by(simp)\nqed\n*)"], ["", "subsubsection \"Balance Indicators\""], ["", "fun balanced1 :: \"'a wbt \\<Rightarrow> 'a wbt \\<Rightarrow> bool\" where\n\"balanced1 t1 t2 = (\\<Delta>1 * (size_wbt t1 + 1) \\<ge> \\<Delta>2 * (size_wbt t2 + 1))\""], ["", "text \\<open>The global weight-balanced tree invariant:\\<close>"], ["", "fun wbt :: \"'a wbt \\<Rightarrow> bool\" where\n\"wbt Leaf = True\"|\n\"wbt (Node l (_, n) r) =\n  (n = size l + size r + 1 \\<and> balanced1 l r \\<and> balanced1 r l \\<and> wbt l \\<and> wbt r)\""], ["", "lemma size_wbt_eq_size[simp]: \"wbt t \\<Longrightarrow> size_wbt t = size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt t \\<Longrightarrow> size_wbt t = size t", "by(induction t) auto"], ["", "fun single :: \"'a wbt \\<Rightarrow> 'a wbt \\<Rightarrow> bool\" where\n\"single t1 t2 = (\\<Gamma>1 * (size_wbt t2 + 1) > \\<Gamma>2 * (size_wbt t1 + 1))\""], ["", "subsubsection \"Code\""], ["", "fun rotateL :: \"'a wbt \\<Rightarrow> 'a \\<Rightarrow> 'a wbt \\<Rightarrow> 'a wbt\" where\n\"rotateL A a (Node B (b, _) C) =\n   (if single B C then rot1L A a B b C else rot2 A a B b C)\""], ["", "fun balanceL :: \"'a wbt \\<Rightarrow> 'a \\<Rightarrow> 'a wbt \\<Rightarrow> 'a wbt\" where\n\"balanceL l a r = (if balanced1 l r then N l a r else rotateL l a r)\""], ["", "fun rotateR :: \"'a wbt \\<Rightarrow> 'a \\<Rightarrow> 'a wbt \\<Rightarrow> 'a wbt\" where\n\"rotateR (Node A (a, _) B) b C =\n  (if single B A then rot1R A a B b C else rot2 A a B b C)\""], ["", "fun balanceR :: \"'a wbt \\<Rightarrow> 'a \\<Rightarrow> 'a wbt \\<Rightarrow> 'a wbt\" where\n\"balanceR l a r = (if balanced1 r l then N l a r else rotateR l a r)\""], ["", "fun insert :: \"'a::linorder \\<Rightarrow> 'a wbt \\<Rightarrow> 'a wbt\" where\n\"insert x Leaf = Node Leaf (x, 1) Leaf\" |\n\"insert x (Node l (a, n) r) =\n   (case cmp x a of\n      LT \\<Rightarrow> balanceR (insert x l) a r |\n      GT \\<Rightarrow> balanceL l a (insert x r) |\n      EQ \\<Rightarrow> Node l (a, n) r )\""], ["", "fun split_min :: \"'a wbt \\<Rightarrow> 'a * 'a wbt\" where\n\"split_min (Node l (a, _) r) =\n   (if l = Leaf then (a,r) else let (x,l') = split_min l in (x, balanceL l' a r))\""], ["", "fun del_max :: \"'a wbt \\<Rightarrow> 'a * 'a wbt\" where\n\"del_max (Node l (a, _) r) =\n   (if r = Leaf then (a,l) else let (x,r') = del_max r in (x, balanceR l a r'))\""], ["", "fun combine :: \"'a wbt \\<Rightarrow> 'a wbt \\<Rightarrow> 'a wbt\"  where\n\"combine Leaf Leaf = Leaf\"|\n\"combine Leaf r = r\"|\n\"combine l Leaf = l\"|\n\"combine l r =\n   (if size l > size r then\n      let (lMax, l') = del_max l in balanceL l' lMax r\n    else\n      let (rMin, r') = split_min r in balanceR l rMin r')\""], ["", "fun delete :: \"'a::linorder \\<Rightarrow> 'a wbt \\<Rightarrow> 'a wbt\" where\n\"delete _ Leaf = Leaf\" |\n\"delete x (Node l (a, _) r) =\n  (case cmp x a of\n     LT \\<Rightarrow> balanceL (delete x l) a r |\n     GT \\<Rightarrow> balanceR l a (delete x r) |\n     EQ \\<Rightarrow> combine l r)\""], ["", "subsection \"Functional Correctness Proofs\""], ["", "text \\<open>A WB tree must be of a certain structure if balanced1 and single are False.\\<close>"], ["", "lemma not_Leaf_if_not_balanced1:\n  assumes \"\\<not> balanced1 l r\"\n  shows \"r \\<noteq> Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> \\<langle>\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. r = \\<langle>\\<rangle> \\<Longrightarrow> False", "assume \"r = Leaf\""], ["proof (state)\nthis:\n  r = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. r = \\<langle>\\<rangle> \\<Longrightarrow> False", "with assms Delta_gr1"], ["proof (chain)\npicking this:\n  \\<not> balanced1 l r\n  \\<Delta>2 < \\<Delta>1\n  r = \\<langle>\\<rangle>", "show False"], ["proof (prove)\nusing this:\n  \\<not> balanced1 l r\n  \\<Delta>2 < \\<Delta>1\n  r = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_Leaf_if_not_single:\n  assumes \"\\<not> single l r\"\n  shows \"l \\<noteq> Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> \\<langle>\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. l = \\<langle>\\<rangle> \\<Longrightarrow> False", "assume \"l = Leaf\""], ["proof (state)\nthis:\n  l = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. l = \\<langle>\\<rangle> \\<Longrightarrow> False", "with assms Gamma_gr1"], ["proof (chain)\npicking this:\n  \\<not> single l r\n  \\<Gamma>2 < \\<Gamma>1\n  l = \\<langle>\\<rangle>", "show False"], ["proof (prove)\nusing this:\n  \\<not> single l r\n  \\<Gamma>2 < \\<Gamma>1\n  l = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Inorder Properties\""], ["", "lemma inorder_rot2:\n  \"B \\<noteq> Leaf \\<Longrightarrow> inorder(rot2 A a B b C) = inorder A @ a # inorder B @ b # inorder C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    Tree2.inorder (rot2 A a B b C) =\n    Tree2.inorder A @ a # Tree2.inorder B @ b # Tree2.inorder C", "by (cases \"(A,a,B,b,C)\" rule: rot2.cases) (auto)"], ["", "lemma inorder_rotateL:\n  \"r \\<noteq> Leaf \\<Longrightarrow> inorder(rotateL l a r) = inorder l @ a # inorder r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    Tree2.inorder (rotateL l a r) = Tree2.inorder l @ a # Tree2.inorder r", "by (induction l a r rule: rotateL.induct) (auto simp add: inorder_rot2 not_Leaf_if_not_single)"], ["", "lemma inorder_rotateR:\n  \"l \\<noteq> Leaf \\<Longrightarrow> inorder(rotateR l a r) = inorder l @ a # inorder r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    Tree2.inorder (rotateR l a r) = Tree2.inorder l @ a # Tree2.inorder r", "by (induction l a r rule: rotateR.induct) (auto simp add: inorder_rot2 not_Leaf_if_not_single)"], ["", "lemma inorder_insert:\n  \"sorted(inorder t) \\<Longrightarrow> inorder(insert x t) = ins_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n    Tree2.inorder (local.insert x t) = ins_list x (Tree2.inorder t)", "by (induction t)\n   (auto simp: ins_list_simps inorder_rotateL inorder_rotateR not_Leaf_if_not_balanced1)"], ["", "lemma split_minD:\n  \"split_min t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> x # inorder t' = inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>split_min t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> x # Tree2.inorder t' = Tree2.inorder t", "by (induction t arbitrary: t' rule: split_min.induct)\n   (auto simp: sorted_lems inorder_rotateL not_Leaf_if_not_balanced1\n     split: prod.splits if_splits)"], ["", "lemma del_maxD:\n  \"del_max t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> inorder t' @ [x] = inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_max t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Tree2.inorder t' @ [x] = Tree2.inorder t", "by (induction t arbitrary: t' rule: del_max.induct)\n   (auto simp: sorted_lems inorder_rotateR not_Leaf_if_not_balanced1\n     split: prod.splits if_splits)"], ["", "lemma inorder_combine:\n  \"inorder(combine l r) = inorder l @ inorder r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Tree2.inorder (combine l r) = Tree2.inorder l @ Tree2.inorder r", "by(induction l r rule: combine.induct)\n  (auto simp: del_maxD split_minD inorder_rotateL inorder_rotateR not_Leaf_if_not_balanced1\n    simp del: rotateL.simps rotateR.simps split: prod.splits)"], ["", "lemma inorder_delete:\n  \"sorted(inorder t) \\<Longrightarrow> inorder(delete x t) = del_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n    Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)", "by(induction t)\n  (auto simp: del_list_simps inorder_combine inorder_rotateL inorder_rotateR\n     not_Leaf_if_not_balanced1 simp del: rotateL.simps rotateR.simps)"], ["", "subsection \"Size Lemmas\""], ["", "subsubsection \"Insertion\""], ["", "lemma size_rot2L[simp]:\n  \"B \\<noteq> Leaf \\<Longrightarrow> size(rot2 A a B b C) = size A + size B + size C + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    size (rot2 A a B b C) = size A + size B + size C + 2", "by(induction A a B b C rule: rot2.induct) auto"], ["", "lemma size_rotateR[simp]:\n  \"l \\<noteq> Leaf \\<Longrightarrow> size(rotateR l a r) = size l + size r + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    size (rotateR l a r) = size l + size r + 1", "by(induction l a r rule: rotateR.induct)\n  (auto simp: not_Leaf_if_not_single simp del: rot2.simps)"], ["", "lemma size_rotateL[simp]:\n  \"r \\<noteq> Leaf \\<Longrightarrow> size(rotateL l a r) = size l + size r + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    size (rotateL l a r) = size l + size r + 1", "by(induction l a r rule: rotateL.induct)\n  (auto simp: not_Leaf_if_not_single simp del: rot2.simps)"], ["", "lemma size_length: \"size t = length (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size t = length (Tree2.inorder t)", "by (induction t rule: inorder.induct) auto"], ["", "lemma size_insert: \"size (insert x t) = (if isin t x then size t else Suc (size t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (local.insert x t) = (if isin t x then size t else Suc (size t))", "by (induction t rule: tree2_induct) (auto simp: not_Leaf_if_not_balanced1)"], ["", "subsubsection \"Deletion\""], ["", "lemma size_delete_if_isin: \"isin t x \\<Longrightarrow> size t = Suc (size(delete x t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isin t x \\<Longrightarrow> size t = Suc (size (delete x t))", "proof (induction t rule: tree2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. isin \\<langle>\\<rangle> x \\<Longrightarrow>\n    size \\<langle>\\<rangle> = Suc (size (delete x \\<langle>\\<rangle>))\n 2. \\<And>x1 a b x3.\n       \\<lbrakk>isin x1 x \\<Longrightarrow>\n                size x1 = Suc (size (delete x x1));\n        isin x3 x \\<Longrightarrow> size x3 = Suc (size (delete x x3));\n        isin \\<langle>x1, (a, b), x3\\<rangle> x\\<rbrakk>\n       \\<Longrightarrow> size \\<langle>x1, (a, b), x3\\<rangle> =\n                         Suc (size\n                               (delete x \\<langle>x1, (a, b), x3\\<rangle>))", "case (Node _ a _ _)"], ["proof (state)\nthis:\n  isin x1_ x \\<Longrightarrow> size x1_ = Suc (size (delete x x1_))\n  isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_))\n  isin \\<langle>x1_, (a, b_), x3_\\<rangle> x\n\ngoal (2 subgoals):\n 1. isin \\<langle>\\<rangle> x \\<Longrightarrow>\n    size \\<langle>\\<rangle> = Suc (size (delete x \\<langle>\\<rangle>))\n 2. \\<And>x1 a b x3.\n       \\<lbrakk>isin x1 x \\<Longrightarrow>\n                size x1 = Suc (size (delete x x1));\n        isin x3 x \\<Longrightarrow> size x3 = Suc (size (delete x x3));\n        isin \\<langle>x1, (a, b), x3\\<rangle> x\\<rbrakk>\n       \\<Longrightarrow> size \\<langle>x1, (a, b), x3\\<rangle> =\n                         Suc (size\n                               (delete x \\<langle>x1, (a, b), x3\\<rangle>))", "thus ?case"], ["proof (prove)\nusing this:\n  isin x1_ x \\<Longrightarrow> size x1_ = Suc (size (delete x x1_))\n  isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_))\n  isin \\<langle>x1_, (a, b_), x3_\\<rangle> x\n\ngoal (1 subgoal):\n 1. size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n    Suc (size (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "proof (cases \"cmp x a\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = LT\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))\n 2. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))\n 3. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "case LT"], ["proof (state)\nthis:\n  cmp x a = LT\n\ngoal (3 subgoals):\n 1. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = LT\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))\n 2. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))\n 3. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  cmp x a = LT\n\ngoal (1 subgoal):\n 1. size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n    Suc (size (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "using Node.prems"], ["proof (prove)\nusing this:\n  cmp x a = LT\n  isin \\<langle>x1_, (a, b_), x3_\\<rangle> x\n\ngoal (1 subgoal):\n 1. size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n    Suc (size (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "by (simp add: Node.IH(1) not_Leaf_if_not_balanced1)"], ["proof (state)\nthis:\n  size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n  Suc (size (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))\n 2. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))\n 2. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "case EQ"], ["proof (state)\nthis:\n  cmp x a = EQ\n\ngoal (2 subgoals):\n 1. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))\n 2. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  cmp x a = EQ\n\ngoal (1 subgoal):\n 1. size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n    Suc (size (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "by simp (metis size_length inorder_combine length_append)"], ["proof (state)\nthis:\n  size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n  Suc (size (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "case GT"], ["proof (state)\nthis:\n  cmp x a = GT\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin x1_ x \\<Longrightarrow>\n             size x1_ = Suc (size (delete x x1_));\n     isin x3_ x \\<Longrightarrow> size x3_ = Suc (size (delete x x3_));\n     isin \\<langle>x1_, (a, b_), x3_\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n                      Suc (size\n                            (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  cmp x a = GT\n\ngoal (1 subgoal):\n 1. size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n    Suc (size (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "using Node.prems"], ["proof (prove)\nusing this:\n  cmp x a = GT\n  isin \\<langle>x1_, (a, b_), x3_\\<rangle> x\n\ngoal (1 subgoal):\n 1. size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n    Suc (size (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))", "by (simp add: Node.IH(2) not_Leaf_if_not_balanced1)"], ["proof (state)\nthis:\n  size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n  Suc (size (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  size \\<langle>x1_, (a, b_), x3_\\<rangle> =\n  Suc (size (delete x \\<langle>x1_, (a, b_), x3_\\<rangle>))\n\ngoal (1 subgoal):\n 1. isin \\<langle>\\<rangle> x \\<Longrightarrow>\n    size \\<langle>\\<rangle> = Suc (size (delete x \\<langle>\\<rangle>))", "qed (auto)"], ["", "lemma delete_id_if_wbt_notin: \"wbt t \\<Longrightarrow> \\<not> isin t x \\<Longrightarrow> delete x t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wbt t; \\<not> isin t x\\<rbrakk>\n    \\<Longrightarrow> delete x t = t", "by (induction t) auto"], ["", "lemma size_split_min: \"t \\<noteq> Leaf \\<Longrightarrow> size t = Suc (size (snd (split_min t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    size t = Suc (size (snd (split_min t)))", "by(induction t) (auto simp: not_Leaf_if_not_balanced1 split: if_splits prod.splits)"], ["", "lemma size_del_max: \"t \\<noteq> Leaf \\<Longrightarrow> size t = Suc(size(snd(del_max t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    size t = Suc (size (snd (del_max t)))", "by(induction t) (auto simp: not_Leaf_if_not_balanced1 split: if_splits prod.splits)"], ["", "subsection \"Auxiliary Definitions\""], ["", "fun balanced1_arith :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n\"balanced1_arith a b = (\\<Delta>1 * (a + 1) \\<ge> \\<Delta>2 * (b + 1))\""], ["", "fun balanced2_arith :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n\"balanced2_arith a b = (balanced1_arith a b \\<and> balanced1_arith b a)\""], ["", "fun singly_balanced_arith :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n\"singly_balanced_arith x y w = (balanced2_arith x y \\<and> balanced2_arith (x+y+1) w)\""], ["", "fun doubly_balanced_arith :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n\"doubly_balanced_arith x y z w =\n  (balanced2_arith x y \\<and> balanced2_arith z w \\<and> balanced2_arith (x+y+1) (z+w+1))\""], ["", "end"], ["", "subsection \"Preservation of WB tree Invariant for Concrete Parameters\""], ["", "text \\<open>A number of sample interpretations with valid parameters:\\<close>"], ["", "interpretation WBT where\n  \\<Delta>1 = 25 and \\<Delta>2 = 10 and \\<Gamma>1 = 14 and \\<Gamma>2 = 10"], ["proof (prove)\ngoal (1 subgoal):\n 1. WBT 25 10 14 10", "(* \\<Delta>1 = 25 and \\<Delta>2 = 10 and \\<Gamma>1 = 15 and \\<Gamma>2 = 10*)\n(* \\<Delta>1 = 28 and \\<Delta>2 = 10 and \\<Gamma>1 = 10 and \\<Gamma>2 = 7*)\n\n(* \\<Delta>1 = 3 and \\<Delta>2 = \"Suc 0\" and \\<Gamma>1 = 4 and \\<Gamma>2 = 3*)\n  (* The only integer solution: *)\n(* \\<Delta>1 = 3 and \\<Delta>2 = \"Suc 0\" and \\<Gamma>1 = 2 and \\<Gamma>2 = \"Suc 0\"*)\n(* \\<Delta>1 = 31 and \\<Delta>2 = 10 and \\<Gamma>1 = 18 and \\<Gamma>2 = 10*)\n\n(* \\<Delta>1 = 35 and \\<Delta>2 = 10 and \\<Gamma>1 = 45 and \\<Gamma>2 = 35*)\n(* \\<Delta>1 = 35 and \\<Delta>2 = 10 and \\<Gamma>1 = 4 and \\<Gamma>2 = 3*)\n(* \\<Delta>1 = 37 and \\<Delta>2 = 10 and \\<Gamma>1 = 13 and \\<Gamma>2 = 10*)\n\n(* \\<Delta>1 = 4 and \\<Delta>2 = \"Suc 0\" and \\<Gamma>1 = 5 and \\<Gamma>2 = 4*)\n(* \\<Delta>1 = 4 and \\<Delta>2 = \"Suc 0\" and \\<Gamma>1 = 5 and \\<Gamma>2 = 3*)\n(* \\<Delta>1 = 17 and \\<Delta>2 = 4 and \\<Gamma>1 = 5 and \\<Gamma>2 = 3 *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. WBT 25 10 14 10", "by (auto simp add: WBT_def)"], ["", "lemma wbt_insert:\n  \"wbt t \\<Longrightarrow> wbt (insert x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt t \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x t)", "proof (induction t rule: tree2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. wbt \\<langle>\\<rangle> \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>\\<rangle>)\n 2. \\<And>x1 a b x3.\n       \\<lbrakk>wbt x1 \\<Longrightarrow>\n                wbt (Weight_Balanced_Trees.insert x x1);\n        wbt x3 \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x x3);\n        wbt \\<langle>x1, (a, b), x3\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x\n                               \\<langle>x1, (a, b), x3\\<rangle>)", "case Leaf"], ["proof (state)\nthis:\n  wbt \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. wbt \\<langle>\\<rangle> \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>\\<rangle>)\n 2. \\<And>x1 a b x3.\n       \\<lbrakk>wbt x1 \\<Longrightarrow>\n                wbt (Weight_Balanced_Trees.insert x x1);\n        wbt x3 \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x x3);\n        wbt \\<langle>x1, (a, b), x3\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x\n                               \\<langle>x1, (a, b), x3\\<rangle>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 a b x3.\n       \\<lbrakk>wbt x1 \\<Longrightarrow>\n                wbt (Weight_Balanced_Trees.insert x x1);\n        wbt x3 \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x x3);\n        wbt \\<langle>x1, (a, b), x3\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x\n                               \\<langle>x1, (a, b), x3\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 a b x3.\n       \\<lbrakk>wbt x1 \\<Longrightarrow>\n                wbt (Weight_Balanced_Trees.insert x x1);\n        wbt x3 \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x x3);\n        wbt \\<langle>x1, (a, b), x3\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x\n                               \\<langle>x1, (a, b), x3\\<rangle>)", "case (Node l a _ r)"], ["proof (state)\nthis:\n  wbt l \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x l)\n  wbt r \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x r)\n  wbt \\<langle>l, (a, b_), r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x1 a b x3.\n       \\<lbrakk>wbt x1 \\<Longrightarrow>\n                wbt (Weight_Balanced_Trees.insert x x1);\n        wbt x3 \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x x3);\n        wbt \\<langle>x1, (a, b), x3\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x\n                               \\<langle>x1, (a, b), x3\\<rangle>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "proof (cases \"cmp x a\")"], ["proof (state)\ngoal (3 subgoals):\n 1. cmp x a = LT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. cmp x a = EQ \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 3. cmp x a = GT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "case EQ"], ["proof (state)\nthis:\n  cmp x a = EQ\n\ngoal (3 subgoals):\n 1. cmp x a = LT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. cmp x a = EQ \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 3. cmp x a = GT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cmp x a = EQ\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "using Node.prems"], ["proof (prove)\nusing this:\n  cmp x a = EQ\n  wbt \\<langle>l, (a, b_), r\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal (2 subgoals):\n 1. cmp x a = LT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. cmp x a = GT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. cmp x a = LT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. cmp x a = GT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "case [simp]: LT"], ["proof (state)\nthis:\n  cmp x a = LT\n\ngoal (2 subgoals):\n 1. cmp x a = LT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. cmp x a = GT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "let ?l' = \"insert x l\""], ["proof (state)\ngoal (2 subgoals):\n 1. cmp x a = LT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. cmp x a = GT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "proof (cases \"balanced1 r ?l'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. balanced1 r (Weight_Balanced_Trees.insert x l) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. \\<not> balanced1 r (Weight_Balanced_Trees.insert x l) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "case True"], ["proof (state)\nthis:\n  balanced1 r (Weight_Balanced_Trees.insert x l)\n\ngoal (2 subgoals):\n 1. balanced1 r (Weight_Balanced_Trees.insert x l) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. \\<not> balanced1 r (Weight_Balanced_Trees.insert x l) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  balanced1 r (Weight_Balanced_Trees.insert x l)\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "using Node size_insert[of x l]"], ["proof (prove)\nusing this:\n  balanced1 r (Weight_Balanced_Trees.insert x l)\n  wbt l \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x l)\n  wbt r \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x r)\n  wbt \\<langle>l, (a, b_), r\\<rangle>\n  size (Weight_Balanced_Trees.insert x l) =\n  (if isin l x then size l else Suc (size l))\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 r (Weight_Balanced_Trees.insert x l) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> balanced1 r (Weight_Balanced_Trees.insert x l) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "case [simp]: False"], ["proof (state)\nthis:\n  \\<not> balanced1 r (Weight_Balanced_Trees.insert x l)\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 r (Weight_Balanced_Trees.insert x l) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "hence \"?l' \\<noteq> Leaf\""], ["proof (prove)\nusing this:\n  \\<not> balanced1 r (Weight_Balanced_Trees.insert x l)\n\ngoal (1 subgoal):\n 1. Weight_Balanced_Trees.insert x l \\<noteq> \\<langle>\\<rangle>", "using not_Leaf_if_not_balanced1"], ["proof (prove)\nusing this:\n  \\<not> balanced1 r (Weight_Balanced_Trees.insert x l)\n  \\<not> balanced1 ?l ?r \\<Longrightarrow> ?r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. Weight_Balanced_Trees.insert x l \\<noteq> \\<langle>\\<rangle>", "by auto"], ["proof (state)\nthis:\n  Weight_Balanced_Trees.insert x l \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 r (Weight_Balanced_Trees.insert x l) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "then"], ["proof (chain)\npicking this:\n  Weight_Balanced_Trees.insert x l \\<noteq> \\<langle>\\<rangle>", "obtain k ll' al' rl' where [simp]: \"?l' = (Node ll' (al', k) rl')\""], ["proof (prove)\nusing this:\n  Weight_Balanced_Trees.insert x l \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>ll' al' k rl'.\n        Weight_Balanced_Trees.insert x l =\n        \\<langle>ll', (al', k), rl'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(meson neq_Leaf2_iff)"], ["proof (state)\nthis:\n  Weight_Balanced_Trees.insert x l = \\<langle>ll', (al', k), rl'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 r (Weight_Balanced_Trees.insert x l) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "proof (cases \"single rl' ll'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. single rl' ll' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. \\<not> single rl' ll' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "case True"], ["proof (state)\nthis:\n  single rl' ll'\n\ngoal (2 subgoals):\n 1. single rl' ll' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. \\<not> single rl' ll' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  single rl' ll'\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "using Node size_insert[of x l]"], ["proof (prove)\nusing this:\n  single rl' ll'\n  wbt l \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x l)\n  wbt r \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x r)\n  wbt \\<langle>l, (a, b_), r\\<rangle>\n  size (Weight_Balanced_Trees.insert x l) =\n  (if isin l x then size l else Suc (size l))\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> single rl' ll' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> single rl' ll' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "case isDouble: False"], ["proof (state)\nthis:\n  \\<not> single rl' ll'\n\ngoal (1 subgoal):\n 1. \\<not> single rl' ll' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "then"], ["proof (chain)\npicking this:\n  \\<not> single rl' ll'", "obtain k llr' alr' rlr' where [simp]: \"rl' = (Node llr' (alr', k) rlr')\""], ["proof (prove)\nusing this:\n  \\<not> single rl' ll'\n\ngoal (1 subgoal):\n 1. (\\<And>llr' alr' k rlr'.\n        rl' = \\<langle>llr', (alr', k), rlr'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using not_Leaf_if_not_single tree2_cases"], ["proof (prove)\nusing this:\n  \\<not> single rl' ll'\n  \\<not> single ?l ?r \\<Longrightarrow> ?l \\<noteq> \\<langle>\\<rangle>\n  \\<lbrakk>?y = \\<langle>\\<rangle> \\<Longrightarrow> ?P;\n   \\<And>x21 a b x23.\n      ?y = \\<langle>x21, (a, b), x23\\<rangle> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>llr' alr' k rlr'.\n        rl' = \\<langle>llr', (alr', k), rlr'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rl' = \\<langle>llr', (alr', k), rlr'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> single rl' ll' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "using isDouble Node size_insert[of x l]"], ["proof (prove)\nusing this:\n  \\<not> single rl' ll'\n  wbt l \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x l)\n  wbt r \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x r)\n  wbt \\<langle>l, (a, b_), r\\<rangle>\n  size (Weight_Balanced_Trees.insert x l) =\n  (if isin l x then size l else Suc (size l))\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. cmp x a = GT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cmp x a = GT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "case [simp]: GT"], ["proof (state)\nthis:\n  cmp x a = GT\n\ngoal (1 subgoal):\n 1. cmp x a = GT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "let ?r' = \"insert x r\""], ["proof (state)\ngoal (1 subgoal):\n 1. cmp x a = GT \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "proof (cases \"balanced1 l ?r'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. balanced1 l (Weight_Balanced_Trees.insert x r) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. \\<not> balanced1 l (Weight_Balanced_Trees.insert x r) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "case True"], ["proof (state)\nthis:\n  balanced1 l (Weight_Balanced_Trees.insert x r)\n\ngoal (2 subgoals):\n 1. balanced1 l (Weight_Balanced_Trees.insert x r) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. \\<not> balanced1 l (Weight_Balanced_Trees.insert x r) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  balanced1 l (Weight_Balanced_Trees.insert x r)\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "using Node size_insert[of x r]"], ["proof (prove)\nusing this:\n  balanced1 l (Weight_Balanced_Trees.insert x r)\n  wbt l \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x l)\n  wbt r \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x r)\n  wbt \\<langle>l, (a, b_), r\\<rangle>\n  size (Weight_Balanced_Trees.insert x r) =\n  (if isin r x then size r else Suc (size r))\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 l (Weight_Balanced_Trees.insert x r) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> balanced1 l (Weight_Balanced_Trees.insert x r) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "case [simp]: False"], ["proof (state)\nthis:\n  \\<not> balanced1 l (Weight_Balanced_Trees.insert x r)\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 l (Weight_Balanced_Trees.insert x r) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "hence \"?r' \\<noteq> Leaf\""], ["proof (prove)\nusing this:\n  \\<not> balanced1 l (Weight_Balanced_Trees.insert x r)\n\ngoal (1 subgoal):\n 1. Weight_Balanced_Trees.insert x r \\<noteq> \\<langle>\\<rangle>", "using not_Leaf_if_not_balanced1"], ["proof (prove)\nusing this:\n  \\<not> balanced1 l (Weight_Balanced_Trees.insert x r)\n  \\<not> balanced1 ?l ?r \\<Longrightarrow> ?r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. Weight_Balanced_Trees.insert x r \\<noteq> \\<langle>\\<rangle>", "by auto"], ["proof (state)\nthis:\n  Weight_Balanced_Trees.insert x r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 l (Weight_Balanced_Trees.insert x r) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "then"], ["proof (chain)\npicking this:\n  Weight_Balanced_Trees.insert x r \\<noteq> \\<langle>\\<rangle>", "obtain k lr' ar' rr' where [simp]: \"?r' = (Node lr' (ar', k) rr')\""], ["proof (prove)\nusing this:\n  Weight_Balanced_Trees.insert x r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>lr' ar' k rr'.\n        Weight_Balanced_Trees.insert x r =\n        \\<langle>lr', (ar', k), rr'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(meson neq_Leaf2_iff)"], ["proof (state)\nthis:\n  Weight_Balanced_Trees.insert x r = \\<langle>lr', (ar', k), rr'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 l (Weight_Balanced_Trees.insert x r) \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "proof (cases \"single lr' rr'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. single lr' rr' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. \\<not> single lr' rr' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "case True"], ["proof (state)\nthis:\n  single lr' rr'\n\ngoal (2 subgoals):\n 1. single lr' rr' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n 2. \\<not> single lr' rr' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  single lr' rr'\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "using Node size_insert[of x r]"], ["proof (prove)\nusing this:\n  single lr' rr'\n  wbt l \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x l)\n  wbt r \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x r)\n  wbt \\<langle>l, (a, b_), r\\<rangle>\n  size (Weight_Balanced_Trees.insert x r) =\n  (if isin r x then size r else Suc (size r))\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> single lr' rr' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> single lr' rr' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "case isDouble: False"], ["proof (state)\nthis:\n  \\<not> single lr' rr'\n\ngoal (1 subgoal):\n 1. \\<not> single lr' rr' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "hence \"lr' \\<noteq> Leaf\""], ["proof (prove)\nusing this:\n  \\<not> single lr' rr'\n\ngoal (1 subgoal):\n 1. lr' \\<noteq> \\<langle>\\<rangle>", "using not_Leaf_if_not_single"], ["proof (prove)\nusing this:\n  \\<not> single lr' rr'\n  \\<not> single ?l ?r \\<Longrightarrow> ?l \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. lr' \\<noteq> \\<langle>\\<rangle>", "by auto"], ["proof (state)\nthis:\n  lr' \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> single lr' rr' \\<Longrightarrow>\n    wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lr' \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "using Node isDouble size_insert[of x r]"], ["proof (prove)\nusing this:\n  lr' \\<noteq> \\<langle>\\<rangle>\n  wbt l \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x l)\n  wbt r \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert x r)\n  wbt \\<langle>l, (a, b_), r\\<rangle>\n  \\<not> single lr' rr'\n  size (Weight_Balanced_Trees.insert x r) =\n  (if isin r x then size r else Suc (size r))\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)", "by (auto simp: neq_Leaf2_iff split: if_splits)"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x \\<langle>l, (a, b_), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare [[smt_nat_as_int]]"], ["", "text \\<open>\n  Show that invariant is preserved by deletion in the left/right subtree:\n\\<close>"], ["", "lemma wbt_balanceL:\n  assumes \"wbt (Node l (a, n) r)\" \"wbt l'\" \"size l = size l' + 1\"\n  shows \"wbt (balanceL l' a' r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "have rl'Balanced: \"balanced1 r l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. balanced1 r l'", "using assms"], ["proof (prove)\nusing this:\n  wbt \\<langle>l, (a, n), r\\<rangle>\n  wbt l'\n  size l = size l' + 1\n\ngoal (1 subgoal):\n 1. balanced1 r l'", "by auto"], ["proof (state)\nthis:\n  balanced1 r l'\n\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "have rBalanced: \"wbt r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt r", "using assms(1)"], ["proof (prove)\nusing this:\n  wbt \\<langle>l, (a, n), r\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt r", "by simp"], ["proof (state)\nthis:\n  wbt r\n\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "proof (cases \"balanced1 l' r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. balanced1 l' r \\<Longrightarrow> wbt (balanceL l' a' r)\n 2. \\<not> balanced1 l' r \\<Longrightarrow> wbt (balanceL l' a' r)", "case True"], ["proof (state)\nthis:\n  balanced1 l' r\n\ngoal (2 subgoals):\n 1. balanced1 l' r \\<Longrightarrow> wbt (balanceL l' a' r)\n 2. \\<not> balanced1 l' r \\<Longrightarrow> wbt (balanceL l' a' r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  balanced1 l' r\n\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "using assms(2) rBalanced rl'Balanced"], ["proof (prove)\nusing this:\n  balanced1 l' r\n  wbt l'\n  wbt r\n  balanced1 r l'\n\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "by auto"], ["proof (state)\nthis:\n  wbt (balanceL l' a' r)\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 l' r \\<Longrightarrow> wbt (balanceL l' a' r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> balanced1 l' r \\<Longrightarrow> wbt (balanceL l' a' r)", "case notBalanced: False"], ["proof (state)\nthis:\n  \\<not> balanced1 l' r\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 l' r \\<Longrightarrow> wbt (balanceL l' a' r)", "hence \"r \\<noteq> Leaf\""], ["proof (prove)\nusing this:\n  \\<not> balanced1 l' r\n\ngoal (1 subgoal):\n 1. r \\<noteq> \\<langle>\\<rangle>", "using not_Leaf_if_not_balanced1"], ["proof (prove)\nusing this:\n  \\<not> balanced1 l' r\n  \\<not> balanced1 ?l ?r \\<Longrightarrow> ?r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. r \\<noteq> \\<langle>\\<rangle>", "by auto"], ["proof (state)\nthis:\n  r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 l' r \\<Longrightarrow> wbt (balanceL l' a' r)", "then"], ["proof (chain)\npicking this:\n  r \\<noteq> \\<langle>\\<rangle>", "obtain k lr ar rr where [simp]: \"r = Node lr (ar, k) rr\""], ["proof (prove)\nusing this:\n  r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>lr ar k rr.\n        r = \\<langle>lr, (ar, k), rr\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(meson neq_Leaf2_iff)"], ["proof (state)\nthis:\n  r = \\<langle>lr, (ar, k), rr\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 l' r \\<Longrightarrow> wbt (balanceL l' a' r)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "proof (cases \"single lr rr\")"], ["proof (state)\ngoal (2 subgoals):\n 1. single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)\n 2. \\<not> single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)", "case single: True"], ["proof (state)\nthis:\n  single lr rr\n\ngoal (2 subgoals):\n 1. single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)\n 2. \\<not> single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)", "have \"singly_balanced_arith (size l') (size lr) (size rr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singly_balanced_arith (size l') (size lr) (size rr)", "using assms(1) notBalanced rl'Balanced rBalanced single assms"], ["proof (prove)\nusing this:\n  wbt \\<langle>l, (a, n), r\\<rangle>\n  \\<not> balanced1 l' r\n  balanced1 r l'\n  wbt r\n  single lr rr\n  wbt \\<langle>l, (a, n), r\\<rangle>\n  wbt l'\n  size l = size l' + 1\n\ngoal (1 subgoal):\n 1. singly_balanced_arith (size l') (size lr) (size rr)", "by (simp) (smt?)"], ["proof (state)\nthis:\n  singly_balanced_arith (size l') (size lr) (size rr)\n\ngoal (2 subgoals):\n 1. single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)\n 2. \\<not> single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  singly_balanced_arith (size l') (size lr) (size rr)\n\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "using notBalanced single assms(2) rBalanced"], ["proof (prove)\nusing this:\n  singly_balanced_arith (size l') (size lr) (size rr)\n  \\<not> balanced1 l' r\n  single lr rr\n  wbt l'\n  wbt r\n\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "by simp"], ["proof (state)\nthis:\n  wbt (balanceL l' a' r)\n\ngoal (1 subgoal):\n 1. \\<not> single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)", "case isDouble: False"], ["proof (state)\nthis:\n  \\<not> single lr rr\n\ngoal (1 subgoal):\n 1. \\<not> single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)", "hence \"lr \\<noteq> Leaf\""], ["proof (prove)\nusing this:\n  \\<not> single lr rr\n\ngoal (1 subgoal):\n 1. lr \\<noteq> \\<langle>\\<rangle>", "using not_Leaf_if_not_single"], ["proof (prove)\nusing this:\n  \\<not> single lr rr\n  \\<not> single ?l ?r \\<Longrightarrow> ?l \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. lr \\<noteq> \\<langle>\\<rangle>", "by auto"], ["proof (state)\nthis:\n  lr \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)", "then"], ["proof (chain)\npicking this:\n  lr \\<noteq> \\<langle>\\<rangle>", "obtain k2 llr alr rlr where [simp]: \"lr = (Node llr (alr, k2) rlr)\""], ["proof (prove)\nusing this:\n  lr \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>llr alr k2 rlr.\n        lr = \\<langle>llr, (alr, k2), rlr\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(meson neq_Leaf2_iff)"], ["proof (state)\nthis:\n  lr = \\<langle>llr, (alr, k2), rlr\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)", "have \"doubly_balanced_arith (size l') (size llr) (size rlr) (size rr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doubly_balanced_arith (size l') (size llr) (size rlr) (size rr)", "using assms(1) notBalanced rl'Balanced rBalanced isDouble assms(2,3)"], ["proof (prove)\nusing this:\n  wbt \\<langle>l, (a, n), r\\<rangle>\n  \\<not> balanced1 l' r\n  balanced1 r l'\n  wbt r\n  \\<not> single lr rr\n  wbt l'\n  size l = size l' + 1\n\ngoal (1 subgoal):\n 1. doubly_balanced_arith (size l') (size llr) (size rlr) (size rr)", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "apply((thin_tac \"_ = _\")+, smt)?"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  doubly_balanced_arith (size l') (size llr) (size rlr) (size rr)\n\ngoal (1 subgoal):\n 1. \\<not> single lr rr \\<Longrightarrow> wbt (balanceL l' a' r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  doubly_balanced_arith (size l') (size llr) (size rlr) (size rr)\n\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "using notBalanced isDouble assms(2) rBalanced"], ["proof (prove)\nusing this:\n  doubly_balanced_arith (size l') (size llr) (size rlr) (size rr)\n  \\<not> balanced1 l' r\n  \\<not> single lr rr\n  wbt l'\n  wbt r\n\ngoal (1 subgoal):\n 1. wbt (balanceL l' a' r)", "by simp"], ["proof (state)\nthis:\n  wbt (balanceL l' a' r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (balanceL l' a' r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (balanceL l' a' r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wbt_balanceR:\n  assumes \"wbt (Node l (a, n) r)\" \"wbt r'\" \"size r = size r' + 1\"\n  shows \"wbt (balanceR l a' r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "have lr'Balanced: \"balanced1 l r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. balanced1 l r'", "using assms"], ["proof (prove)\nusing this:\n  wbt \\<langle>l, (a, n), r\\<rangle>\n  wbt r'\n  size r = size r' + 1\n\ngoal (1 subgoal):\n 1. balanced1 l r'", "by auto"], ["proof (state)\nthis:\n  balanced1 l r'\n\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "have lBalanced: \"wbt l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt l", "using assms(1)"], ["proof (prove)\nusing this:\n  wbt \\<langle>l, (a, n), r\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt l", "by simp"], ["proof (state)\nthis:\n  wbt l\n\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "proof (cases \"balanced1 r' l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. balanced1 r' l \\<Longrightarrow> wbt (balanceR l a' r')\n 2. \\<not> balanced1 r' l \\<Longrightarrow> wbt (balanceR l a' r')", "case True"], ["proof (state)\nthis:\n  balanced1 r' l\n\ngoal (2 subgoals):\n 1. balanced1 r' l \\<Longrightarrow> wbt (balanceR l a' r')\n 2. \\<not> balanced1 r' l \\<Longrightarrow> wbt (balanceR l a' r')", "thus ?thesis"], ["proof (prove)\nusing this:\n  balanced1 r' l\n\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "using assms(2) lBalanced lr'Balanced"], ["proof (prove)\nusing this:\n  balanced1 r' l\n  wbt r'\n  wbt l\n  balanced1 l r'\n\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "by simp"], ["proof (state)\nthis:\n  wbt (balanceR l a' r')\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 r' l \\<Longrightarrow> wbt (balanceR l a' r')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> balanced1 r' l \\<Longrightarrow> wbt (balanceR l a' r')", "case notBalanced: False"], ["proof (state)\nthis:\n  \\<not> balanced1 r' l\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 r' l \\<Longrightarrow> wbt (balanceR l a' r')", "hence \"l \\<noteq> Leaf\""], ["proof (prove)\nusing this:\n  \\<not> balanced1 r' l\n\ngoal (1 subgoal):\n 1. l \\<noteq> \\<langle>\\<rangle>", "using not_Leaf_if_not_balanced1"], ["proof (prove)\nusing this:\n  \\<not> balanced1 r' l\n  \\<not> balanced1 ?l ?r \\<Longrightarrow> ?r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. l \\<noteq> \\<langle>\\<rangle>", "by auto"], ["proof (state)\nthis:\n  l \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 r' l \\<Longrightarrow> wbt (balanceR l a' r')", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> \\<langle>\\<rangle>", "obtain k ll al rl where [simp]: \"l = (Node ll (al, k) rl)\""], ["proof (prove)\nusing this:\n  l \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>ll al k rl.\n        l = \\<langle>ll, (al, k), rl\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(meson neq_Leaf2_iff)"], ["proof (state)\nthis:\n  l = \\<langle>ll, (al, k), rl\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> balanced1 r' l \\<Longrightarrow> wbt (balanceR l a' r')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "proof (cases \"single rl ll\")"], ["proof (state)\ngoal (2 subgoals):\n 1. single rl ll \\<Longrightarrow> wbt (balanceR l a' r')\n 2. \\<not> single rl ll \\<Longrightarrow> wbt (balanceR l a' r')", "case single: True"], ["proof (state)\nthis:\n  single rl ll\n\ngoal (2 subgoals):\n 1. single rl ll \\<Longrightarrow> wbt (balanceR l a' r')\n 2. \\<not> single rl ll \\<Longrightarrow> wbt (balanceR l a' r')", "have \"singly_balanced_arith (size rl) (size r') (size ll)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singly_balanced_arith (size rl) (size r') (size ll)", "using assms(1) notBalanced lr'Balanced lBalanced single assms(2,3)"], ["proof (prove)\nusing this:\n  wbt \\<langle>l, (a, n), r\\<rangle>\n  \\<not> balanced1 r' l\n  balanced1 l r'\n  wbt l\n  single rl ll\n  wbt r'\n  size r = size r' + 1\n\ngoal (1 subgoal):\n 1. singly_balanced_arith (size rl) (size r') (size ll)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 10 * size ll + 10 * size rl \\<le> 5 + 25 * size r';\n     10 * size ll \\<le> 15 + 25 * size rl; 10 * size rl < 4 + 14 * size ll;\n     wbt r'; size r = Suc (size r');\n     n = Suc (Suc (Suc (size ll + size rl + size r')));\n     10 * size ll + 10 * size rl \\<le> 30 + 25 * size r';\n     k = Suc (size ll + size rl); wbt ll; wbt rl; wbt r\\<rbrakk>\n    \\<Longrightarrow> 10 * size rl \\<le> 15 + 25 * size r'", "apply((thin_tac \"_ = _\")+, smt)?"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  singly_balanced_arith (size rl) (size r') (size ll)\n\ngoal (2 subgoals):\n 1. single rl ll \\<Longrightarrow> wbt (balanceR l a' r')\n 2. \\<not> single rl ll \\<Longrightarrow> wbt (balanceR l a' r')", "thus ?thesis"], ["proof (prove)\nusing this:\n  singly_balanced_arith (size rl) (size r') (size ll)\n\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "using assms(2) lBalanced notBalanced single"], ["proof (prove)\nusing this:\n  singly_balanced_arith (size rl) (size r') (size ll)\n  wbt r'\n  wbt l\n  \\<not> balanced1 r' l\n  single rl ll\n\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "by simp"], ["proof (state)\nthis:\n  wbt (balanceR l a' r')\n\ngoal (1 subgoal):\n 1. \\<not> single rl ll \\<Longrightarrow> wbt (balanceR l a' r')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> single rl ll \\<Longrightarrow> wbt (balanceR l a' r')", "case isDouble: False"], ["proof (state)\nthis:\n  \\<not> single rl ll\n\ngoal (1 subgoal):\n 1. \\<not> single rl ll \\<Longrightarrow> wbt (balanceR l a' r')", "hence \"rl \\<noteq> Leaf\""], ["proof (prove)\nusing this:\n  \\<not> single rl ll\n\ngoal (1 subgoal):\n 1. rl \\<noteq> \\<langle>\\<rangle>", "using not_Leaf_if_not_single"], ["proof (prove)\nusing this:\n  \\<not> single rl ll\n  \\<not> single ?l ?r \\<Longrightarrow> ?l \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. rl \\<noteq> \\<langle>\\<rangle>", "by auto"], ["proof (state)\nthis:\n  rl \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> single rl ll \\<Longrightarrow> wbt (balanceR l a' r')", "then"], ["proof (chain)\npicking this:\n  rl \\<noteq> \\<langle>\\<rangle>", "obtain k lrl arl rrl where [simp]: \"rl = (Node lrl (arl, k) rrl)\""], ["proof (prove)\nusing this:\n  rl \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>lrl arl k rrl.\n        rl = \\<langle>lrl, (arl, k), rrl\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(meson neq_Leaf2_iff)"], ["proof (state)\nthis:\n  rl = \\<langle>lrl, (arl, k), rrl\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> single rl ll \\<Longrightarrow> wbt (balanceR l a' r')", "have \"doubly_balanced_arith (size ll) (size lrl) (size rrl) (size r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doubly_balanced_arith (size ll) (size lrl) (size rrl) (size r')", "using assms(1) notBalanced lr'Balanced lBalanced isDouble assms(2,3)"], ["proof (prove)\nusing this:\n  wbt \\<langle>l, (a, n), r\\<rangle>\n  \\<not> balanced1 r' l\n  balanced1 l r'\n  wbt l\n  \\<not> single rl ll\n  wbt r'\n  size r = size r' + 1\n\ngoal (1 subgoal):\n 1. doubly_balanced_arith (size ll) (size lrl) (size rrl) (size r')", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "apply((thin_tac \"_ = _\")+, smt)?"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  doubly_balanced_arith (size ll) (size lrl) (size rrl) (size r')\n\ngoal (1 subgoal):\n 1. \\<not> single rl ll \\<Longrightarrow> wbt (balanceR l a' r')", "thus ?thesis"], ["proof (prove)\nusing this:\n  doubly_balanced_arith (size ll) (size lrl) (size rrl) (size r')\n\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "using assms(2) lBalanced notBalanced isDouble"], ["proof (prove)\nusing this:\n  doubly_balanced_arith (size ll) (size lrl) (size rrl) (size r')\n  wbt r'\n  wbt l\n  \\<not> balanced1 r' l\n  \\<not> single rl ll\n\ngoal (1 subgoal):\n 1. wbt (balanceR l a' r')", "by simp"], ["proof (state)\nthis:\n  wbt (balanceR l a' r')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (balanceR l a' r')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (balanceR l a' r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wbt_split_min: \"t \\<noteq> Leaf \\<Longrightarrow> wbt t \\<Longrightarrow> wbt (snd (split_min t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> \\<langle>\\<rangle>; wbt t\\<rbrakk>\n    \\<Longrightarrow> wbt (snd (split_min t))", "proof (induction t rule: split_min.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l a uu_ r.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> \\<langle>\\<rangle>;\n                 l \\<noteq> \\<langle>\\<rangle>; wbt l\\<rbrakk>\n                \\<Longrightarrow> wbt (snd (split_min l));\n        \\<langle>l, (a, uu_), r\\<rangle> \\<noteq> \\<langle>\\<rangle>;\n        wbt \\<langle>l, (a, uu_), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (snd (split_min\n                                    \\<langle>l, (a, uu_), r\\<rangle>))\n 2. \\<lbrakk>\\<langle>\\<rangle> \\<noteq> \\<langle>\\<rangle>;\n     wbt \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> wbt (snd (split_min \\<langle>\\<rangle>))", "case (1 l a m r)"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<noteq> \\<langle>\\<rangle>; l \\<noteq> \\<langle>\\<rangle>;\n   wbt l\\<rbrakk>\n  \\<Longrightarrow> wbt (snd (split_min l))\n  \\<langle>l, (a, m), r\\<rangle> \\<noteq> \\<langle>\\<rangle>\n  wbt \\<langle>l, (a, m), r\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>l a uu_ r.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> \\<langle>\\<rangle>;\n                 l \\<noteq> \\<langle>\\<rangle>; wbt l\\<rbrakk>\n                \\<Longrightarrow> wbt (snd (split_min l));\n        \\<langle>l, (a, uu_), r\\<rangle> \\<noteq> \\<langle>\\<rangle>;\n        wbt \\<langle>l, (a, uu_), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (snd (split_min\n                                    \\<langle>l, (a, uu_), r\\<rangle>))\n 2. \\<lbrakk>\\<langle>\\<rangle> \\<noteq> \\<langle>\\<rangle>;\n     wbt \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> wbt (snd (split_min \\<langle>\\<rangle>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "proof (cases l rule: tree2_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. l = \\<langle>\\<rangle> \\<Longrightarrow>\n    wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))\n 2. \\<And>x21 aa b x23.\n       l = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "case Leaf"], ["proof (state)\nthis:\n  l = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. l = \\<langle>\\<rangle> \\<Longrightarrow>\n    wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))\n 2. \\<And>x21 aa b x23.\n       l = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "using \"1.prems\"(2)"], ["proof (prove)\nusing this:\n  l = \\<langle>\\<rangle>\n  wbt \\<langle>l, (a, m), r\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "by simp"], ["proof (state)\nthis:\n  wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       l = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       l = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "case (Node ll al n rl)"], ["proof (state)\nthis:\n  l = \\<langle>ll, (al, n), rl\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       l = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "let ?l' = \"snd (split_min (Node ll (al, n) rl))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       l = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "have delBalanceL: \"snd (split_min (Node l (a, m) r)) = balanceL ?l' a r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (split_min \\<langle>l, (a, m), r\\<rangle>) =\n    balanceL (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) a r", "using Node"], ["proof (prove)\nusing this:\n  l = \\<langle>ll, (al, n), rl\\<rangle>\n\ngoal (1 subgoal):\n 1. snd (split_min \\<langle>l, (a, m), r\\<rangle>) =\n    balanceL (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) a r", "by(auto split: prod.splits)"], ["proof (state)\nthis:\n  snd (split_min \\<langle>l, (a, m), r\\<rangle>) =\n  balanceL (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       l = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "have \"wbt ?l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>))", "using \"1\"(1) \"1.prems\"(2) Node"], ["proof (prove)\nusing this:\n  \\<lbrakk>l \\<noteq> \\<langle>\\<rangle>; l \\<noteq> \\<langle>\\<rangle>;\n   wbt l\\<rbrakk>\n  \\<Longrightarrow> wbt (snd (split_min l))\n  wbt \\<langle>l, (a, m), r\\<rangle>\n  l = \\<langle>ll, (al, n), rl\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>))", "by auto"], ["proof (state)\nthis:\n  wbt (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>))\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       l = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "moreover"], ["proof (state)\nthis:\n  wbt (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>))\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       l = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "have \"size l = size ?l' + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size l = size (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) + 1", "using Node size_split_min"], ["proof (prove)\nusing this:\n  l = \\<langle>ll, (al, n), rl\\<rangle>\n  ?t \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  size ?t = Suc (size (snd (split_min ?t)))\n\ngoal (1 subgoal):\n 1. size l = size (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) + 1", "by (metis Suc_eq_plus1 neq_Leaf2_iff)"], ["proof (state)\nthis:\n  size l = size (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) + 1\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       l = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "ultimately"], ["proof (chain)\npicking this:\n  wbt (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>))\n  size l = size (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) + 1", "have \"wbt (balanceL ?l' a r)\""], ["proof (prove)\nusing this:\n  wbt (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>))\n  size l = size (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) + 1\n\ngoal (1 subgoal):\n 1. wbt (balanceL (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) a r)", "by (meson \"1.prems\"(2) wbt_balanceL)"], ["proof (state)\nthis:\n  wbt (balanceL (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) a r)\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       l = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  wbt (balanceL (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) a r)\n\ngoal (1 subgoal):\n 1. wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "using delBalanceL"], ["proof (prove)\nusing this:\n  wbt (balanceL (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) a r)\n  snd (split_min \\<langle>l, (a, m), r\\<rangle>) =\n  balanceL (snd (split_min \\<langle>ll, (al, n), rl\\<rangle>)) a r\n\ngoal (1 subgoal):\n 1. wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))", "by auto"], ["proof (state)\nthis:\n  wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (snd (split_min \\<langle>l, (a, m), r\\<rangle>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>\\<rangle> \\<noteq> \\<langle>\\<rangle>;\n     wbt \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> wbt (snd (split_min \\<langle>\\<rangle>))", "qed (blast)"], ["", "lemma wbt_del_max: \"t \\<noteq> Leaf \\<Longrightarrow> wbt t \\<Longrightarrow> wbt (snd (del_max t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> \\<langle>\\<rangle>; wbt t\\<rbrakk>\n    \\<Longrightarrow> wbt (snd (del_max t))", "proof (induction t rule: del_max.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l a uu_ r.\n       \\<lbrakk>\\<lbrakk>r \\<noteq> \\<langle>\\<rangle>;\n                 r \\<noteq> \\<langle>\\<rangle>; wbt r\\<rbrakk>\n                \\<Longrightarrow> wbt (snd (del_max r));\n        \\<langle>l, (a, uu_), r\\<rangle> \\<noteq> \\<langle>\\<rangle>;\n        wbt \\<langle>l, (a, uu_), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (snd (del_max\n                                    \\<langle>l, (a, uu_), r\\<rangle>))\n 2. \\<lbrakk>\\<langle>\\<rangle> \\<noteq> \\<langle>\\<rangle>;\n     wbt \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> wbt (snd (del_max \\<langle>\\<rangle>))", "case (1 l a m r)"], ["proof (state)\nthis:\n  \\<lbrakk>r \\<noteq> \\<langle>\\<rangle>; r \\<noteq> \\<langle>\\<rangle>;\n   wbt r\\<rbrakk>\n  \\<Longrightarrow> wbt (snd (del_max r))\n  \\<langle>l, (a, m), r\\<rangle> \\<noteq> \\<langle>\\<rangle>\n  wbt \\<langle>l, (a, m), r\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>l a uu_ r.\n       \\<lbrakk>\\<lbrakk>r \\<noteq> \\<langle>\\<rangle>;\n                 r \\<noteq> \\<langle>\\<rangle>; wbt r\\<rbrakk>\n                \\<Longrightarrow> wbt (snd (del_max r));\n        \\<langle>l, (a, uu_), r\\<rangle> \\<noteq> \\<langle>\\<rangle>;\n        wbt \\<langle>l, (a, uu_), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (snd (del_max\n                                    \\<langle>l, (a, uu_), r\\<rangle>))\n 2. \\<lbrakk>\\<langle>\\<rangle> \\<noteq> \\<langle>\\<rangle>;\n     wbt \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> wbt (snd (del_max \\<langle>\\<rangle>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "proof (cases r rule: tree2_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. r = \\<langle>\\<rangle> \\<Longrightarrow>\n    wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))\n 2. \\<And>x21 aa b x23.\n       r = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "case Leaf"], ["proof (state)\nthis:\n  r = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. r = \\<langle>\\<rangle> \\<Longrightarrow>\n    wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))\n 2. \\<And>x21 aa b x23.\n       r = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "using \"1.prems\"(2)"], ["proof (prove)\nusing this:\n  r = \\<langle>\\<rangle>\n  wbt \\<langle>l, (a, m), r\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "by simp"], ["proof (state)\nthis:\n  wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       r = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       r = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "case (Node lr ar n rr)"], ["proof (state)\nthis:\n  r = \\<langle>lr, (ar, n), rr\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       r = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "then"], ["proof (chain)\npicking this:\n  r = \\<langle>lr, (ar, n), rr\\<rangle>", "obtain r' where delMaxR: \"r' = snd (del_max (Node lr (ar, n) rr))\""], ["proof (prove)\nusing this:\n  r = \\<langle>lr, (ar, n), rr\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        r' =\n        snd (del_max \\<langle>lr, (ar, n), rr\\<rangle>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  r' = snd (del_max \\<langle>lr, (ar, n), rr\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       r = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "hence delBalanceR: \"snd (del_max (Node l (a, m) r)) = balanceR l a r'\""], ["proof (prove)\nusing this:\n  r' = snd (del_max \\<langle>lr, (ar, n), rr\\<rangle>)\n\ngoal (1 subgoal):\n 1. snd (del_max \\<langle>l, (a, m), r\\<rangle>) = balanceR l a r'", "using Node"], ["proof (prove)\nusing this:\n  r' = snd (del_max \\<langle>lr, (ar, n), rr\\<rangle>)\n  r = \\<langle>lr, (ar, n), rr\\<rangle>\n\ngoal (1 subgoal):\n 1. snd (del_max \\<langle>l, (a, m), r\\<rangle>) = balanceR l a r'", "by(auto split: prod.splits)"], ["proof (state)\nthis:\n  snd (del_max \\<langle>l, (a, m), r\\<rangle>) = balanceR l a r'\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       r = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "have \"wbt r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt r'", "using \"1\"(1) \"1.prems\"(2) Node delMaxR"], ["proof (prove)\nusing this:\n  \\<lbrakk>r \\<noteq> \\<langle>\\<rangle>; r \\<noteq> \\<langle>\\<rangle>;\n   wbt r\\<rbrakk>\n  \\<Longrightarrow> wbt (snd (del_max r))\n  wbt \\<langle>l, (a, m), r\\<rangle>\n  r = \\<langle>lr, (ar, n), rr\\<rangle>\n  r' = snd (del_max \\<langle>lr, (ar, n), rr\\<rangle>)\n\ngoal (1 subgoal):\n 1. wbt r'", "by auto"], ["proof (state)\nthis:\n  wbt r'\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       r = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "moreover"], ["proof (state)\nthis:\n  wbt r'\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       r = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "have \"size r = size r' + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size r = size r' + 1", "using size_del_max Node delMaxR"], ["proof (prove)\nusing this:\n  ?t \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  size ?t = Suc (size (snd (del_max ?t)))\n  r = \\<langle>lr, (ar, n), rr\\<rangle>\n  r' = snd (del_max \\<langle>lr, (ar, n), rr\\<rangle>)\n\ngoal (1 subgoal):\n 1. size r = size r' + 1", "by (metis Suc_eq_plus1 tree.simps(3))"], ["proof (state)\nthis:\n  size r = size r' + 1\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       r = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "ultimately"], ["proof (chain)\npicking this:\n  wbt r'\n  size r = size r' + 1", "have \"wbt (balanceR l a r')\""], ["proof (prove)\nusing this:\n  wbt r'\n  size r = size r' + 1\n\ngoal (1 subgoal):\n 1. wbt (balanceR l a r')", "using wbt_balanceR"], ["proof (prove)\nusing this:\n  wbt r'\n  size r = size r' + 1\n  \\<lbrakk>wbt \\<langle>?l, (?a, ?n), ?r\\<rangle>; wbt ?r';\n   size ?r = size ?r' + 1\\<rbrakk>\n  \\<Longrightarrow> wbt (balanceR ?l ?a' ?r')\n\ngoal (1 subgoal):\n 1. wbt (balanceR l a r')", "by (metis \"1.prems\"(2))"], ["proof (state)\nthis:\n  wbt (balanceR l a r')\n\ngoal (1 subgoal):\n 1. \\<And>x21 aa b x23.\n       r = \\<langle>x21, (aa, b), x23\\<rangle> \\<Longrightarrow>\n       wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  wbt (balanceR l a r')\n\ngoal (1 subgoal):\n 1. wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "using delBalanceR"], ["proof (prove)\nusing this:\n  wbt (balanceR l a r')\n  snd (del_max \\<langle>l, (a, m), r\\<rangle>) = balanceR l a r'\n\ngoal (1 subgoal):\n 1. wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))", "by auto"], ["proof (state)\nthis:\n  wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (snd (del_max \\<langle>l, (a, m), r\\<rangle>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>\\<rangle> \\<noteq> \\<langle>\\<rangle>;\n     wbt \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> wbt (snd (del_max \\<langle>\\<rangle>))", "qed (blast)"], ["", "lemma wbt_delete: \"wbt t \\<Longrightarrow> wbt (delete x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt t \\<Longrightarrow> wbt (delete x t)", "proof (induction t rule: tree2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. wbt \\<langle>\\<rangle> \\<Longrightarrow>\n    wbt (delete x \\<langle>\\<rangle>)\n 2. \\<And>x1 a b x3.\n       \\<lbrakk>wbt x1 \\<Longrightarrow> wbt (delete x x1);\n        wbt x3 \\<Longrightarrow> wbt (delete x x3);\n        wbt \\<langle>x1, (a, b), x3\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (delete x \\<langle>x1, (a, b), x3\\<rangle>)", "case Leaf"], ["proof (state)\nthis:\n  wbt \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. wbt \\<langle>\\<rangle> \\<Longrightarrow>\n    wbt (delete x \\<langle>\\<rangle>)\n 2. \\<And>x1 a b x3.\n       \\<lbrakk>wbt x1 \\<Longrightarrow> wbt (delete x x1);\n        wbt x3 \\<Longrightarrow> wbt (delete x x3);\n        wbt \\<langle>x1, (a, b), x3\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (delete x \\<langle>x1, (a, b), x3\\<rangle>)", "thus ?case"], ["proof (prove)\nusing this:\n  wbt \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 a b x3.\n       \\<lbrakk>wbt x1 \\<Longrightarrow> wbt (delete x x1);\n        wbt x3 \\<Longrightarrow> wbt (delete x x3);\n        wbt \\<langle>x1, (a, b), x3\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (delete x \\<langle>x1, (a, b), x3\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 a b x3.\n       \\<lbrakk>wbt x1 \\<Longrightarrow> wbt (delete x x1);\n        wbt x3 \\<Longrightarrow> wbt (delete x x3);\n        wbt \\<langle>x1, (a, b), x3\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (delete x \\<langle>x1, (a, b), x3\\<rangle>)", "case (Node l a n r)"], ["proof (state)\nthis:\n  wbt l \\<Longrightarrow> wbt (delete x l)\n  wbt r \\<Longrightarrow> wbt (delete x r)\n  wbt \\<langle>l, (a, n), r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x1 a b x3.\n       \\<lbrakk>wbt x1 \\<Longrightarrow> wbt (delete x x1);\n        wbt x3 \\<Longrightarrow> wbt (delete x x3);\n        wbt \\<langle>x1, (a, b), x3\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> wbt (delete x \\<langle>x1, (a, b), x3\\<rangle>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "proof (cases \"isin (Node l (a, n) r) x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. isin \\<langle>l, (a, n), r\\<rangle> x \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<not> isin \\<langle>l, (a, n), r\\<rangle> x \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "case False"], ["proof (state)\nthis:\n  \\<not> isin \\<langle>l, (a, n), r\\<rangle> x\n\ngoal (2 subgoals):\n 1. isin \\<langle>l, (a, n), r\\<rangle> x \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<not> isin \\<langle>l, (a, n), r\\<rangle> x \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> isin \\<langle>l, (a, n), r\\<rangle> x\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "using Node.prems delete_id_if_wbt_notin"], ["proof (prove)\nusing this:\n  \\<not> isin \\<langle>l, (a, n), r\\<rangle> x\n  wbt \\<langle>l, (a, n), r\\<rangle>\n  \\<lbrakk>wbt ?t; \\<not> isin ?t ?x\\<rbrakk>\n  \\<Longrightarrow> delete ?x ?t = ?t\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "by metis"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. isin \\<langle>l, (a, n), r\\<rangle> x \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. isin \\<langle>l, (a, n), r\\<rangle> x \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "case isin: True"], ["proof (state)\nthis:\n  isin \\<langle>l, (a, n), r\\<rangle> x\n\ngoal (1 subgoal):\n 1. isin \\<langle>l, (a, n), r\\<rangle> x \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  isin \\<langle>l, (a, n), r\\<rangle> x\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "proof (cases \"cmp x a\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = LT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 3. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "case LT"], ["proof (state)\nthis:\n  cmp x a = LT\n\ngoal (3 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = LT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 3. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "let ?l' = \"delete x l\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = LT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 3. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "have \"size l = size ?l' + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size l = size (delete x l) + 1", "using LT isin"], ["proof (prove)\nusing this:\n  cmp x a = LT\n  isin \\<langle>l, (a, n), r\\<rangle> x\n\ngoal (1 subgoal):\n 1. size l = size (delete x l) + 1", "by (auto simp: size_delete_if_isin)"], ["proof (state)\nthis:\n  size l = size (delete x l) + 1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = LT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 3. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "hence \"wbt (balanceL ?l' a r)\""], ["proof (prove)\nusing this:\n  size l = size (delete x l) + 1\n\ngoal (1 subgoal):\n 1. wbt (balanceL (delete x l) a r)", "using Node.IH(1) Node.prems"], ["proof (prove)\nusing this:\n  size l = size (delete x l) + 1\n  wbt l \\<Longrightarrow> wbt (delete x l)\n  wbt \\<langle>l, (a, n), r\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (balanceL (delete x l) a r)", "by (fastforce intro: wbt_balanceL)"], ["proof (state)\nthis:\n  wbt (balanceL (delete x l) a r)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = LT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 3. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  wbt (balanceL (delete x l) a r)\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "by (simp add: LT)"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "case GT"], ["proof (state)\nthis:\n  cmp x a = GT\n\ngoal (2 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "let ?r' = \"delete x r\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "have \"wbt ?r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (delete x r)", "using Node.IH(2) Node.prems"], ["proof (prove)\nusing this:\n  wbt r \\<Longrightarrow> wbt (delete x r)\n  wbt \\<langle>l, (a, n), r\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (delete x r)", "by simp"], ["proof (state)\nthis:\n  wbt (delete x r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "moreover"], ["proof (state)\nthis:\n  wbt (delete x r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "have \"size r = size ?r' + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size r = size (delete x r) + 1", "using GT Node.prems isin size_delete_if_isin"], ["proof (prove)\nusing this:\n  cmp x a = GT\n  wbt \\<langle>l, (a, n), r\\<rangle>\n  isin \\<langle>l, (a, n), r\\<rangle> x\n  isin ?t ?x \\<Longrightarrow> size ?t = Suc (size (delete ?x ?t))\n\ngoal (1 subgoal):\n 1. size r = size (delete x r) + 1", "by auto"], ["proof (state)\nthis:\n  size r = size (delete x r) + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "ultimately"], ["proof (chain)\npicking this:\n  wbt (delete x r)\n  size r = size (delete x r) + 1", "have \"wbt (balanceR l a ?r')\""], ["proof (prove)\nusing this:\n  wbt (delete x r)\n  size r = size (delete x r) + 1\n\ngoal (1 subgoal):\n 1. wbt (balanceR l a (delete x r))", "by (meson Node.prems wbt_balanceR)"], ["proof (state)\nthis:\n  wbt (balanceR l a (delete x r))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = GT\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  wbt (balanceR l a (delete x r))\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "by (simp add: GT)"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "case [simp]: EQ"], ["proof (state)\nthis:\n  cmp x a = EQ\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "hence xCombine: \"delete x (Node l (a, n) r) = combine l r\""], ["proof (prove)\nusing this:\n  cmp x a = EQ\n\ngoal (1 subgoal):\n 1. delete x \\<langle>l, (a, n), r\\<rangle> = combine l r", "by simp"], ["proof (state)\nthis:\n  delete x \\<langle>l, (a, n), r\\<rangle> = combine l r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "{"], ["proof (state)\nthis:\n  delete x \\<langle>l, (a, n), r\\<rangle> = combine l r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "assume \"l = Leaf\" \"r = Leaf\""], ["proof (state)\nthis:\n  l = \\<langle>\\<rangle>\n  r = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "hence ?thesis"], ["proof (prove)\nusing this:\n  l = \\<langle>\\<rangle>\n  r = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>l = \\<langle>\\<rangle>; r = \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>l = \\<langle>\\<rangle>; r = \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>l = \\<langle>\\<rangle>; r = \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "assume \"l = Leaf\" \"r \\<noteq> Leaf\""], ["proof (state)\nthis:\n  l = \\<langle>\\<rangle>\n  r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "hence ?thesis"], ["proof (prove)\nusing this:\n  l = \\<langle>\\<rangle>\n  r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "using Node.prems"], ["proof (prove)\nusing this:\n  l = \\<langle>\\<rangle>\n  r \\<noteq> \\<langle>\\<rangle>\n  wbt \\<langle>l, (a, n), r\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "by (auto simp: neq_Leaf2_iff)"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>l = \\<langle>\\<rangle>; r \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>l = \\<langle>\\<rangle>; r \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>l = \\<langle>\\<rangle>; r \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "assume \"l \\<noteq> Leaf\" \"r = Leaf\""], ["proof (state)\nthis:\n  l \\<noteq> \\<langle>\\<rangle>\n  r = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "hence ?thesis"], ["proof (prove)\nusing this:\n  l \\<noteq> \\<langle>\\<rangle>\n  r = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "using Node.prems"], ["proof (prove)\nusing this:\n  l \\<noteq> \\<langle>\\<rangle>\n  r = \\<langle>\\<rangle>\n  wbt \\<langle>l, (a, n), r\\<rangle>\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "by (auto simp: neq_Leaf2_iff)"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<noteq> \\<langle>\\<rangle>; r = \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<noteq> \\<langle>\\<rangle>; r = \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<noteq> \\<langle>\\<rangle>; r = \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "assume lrNotLeaf: \"l \\<noteq> Leaf\" \"r \\<noteq> Leaf\""], ["proof (state)\nthis:\n  l \\<noteq> \\<langle>\\<rangle>\n  r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> \\<langle>\\<rangle>\n  r \\<noteq> \\<langle>\\<rangle>", "obtain kl kr ll al rl lr ar rr\n          where [simp]: \"l = (Node ll (al, kl) rl)\" \"r = (Node lr (ar, kr) rr)\""], ["proof (prove)\nusing this:\n  l \\<noteq> \\<langle>\\<rangle>\n  r \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>ll al kl rl lr ar kr rr.\n        \\<lbrakk>l = \\<langle>ll, (al, kl), rl\\<rangle>;\n         r = \\<langle>lr, (ar, kr), rr\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson neq_Leaf2_iff)"], ["proof (state)\nthis:\n  l = \\<langle>ll, (al, kl), rl\\<rangle>\n  r = \\<langle>lr, (ar, kr), rr\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "proof (cases \"size l > size r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "case True"], ["proof (state)\nthis:\n  size r < size l\n\ngoal (2 subgoals):\n 1. size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "obtain lMax l' where letMax: \"del_max l = (lMax, l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lMax l'.\n        del_max l = (lMax, l') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  del_max l = (lMax, l')\n\ngoal (2 subgoals):\n 1. size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "hence balanceLeft: \"combine l r = balanceL l' lMax r\""], ["proof (prove)\nusing this:\n  del_max l = (lMax, l')\n\ngoal (1 subgoal):\n 1. combine l r = balanceL l' lMax r", "using \\<open>size l > size r\\<close>"], ["proof (prove)\nusing this:\n  del_max l = (lMax, l')\n  size r < size l\n\ngoal (1 subgoal):\n 1. combine l r = balanceL l' lMax r", "by (simp)"], ["proof (state)\nthis:\n  combine l r = balanceL l' lMax r\n\ngoal (2 subgoals):\n 1. size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "have \"wbt l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt l'", "using Node.prems wbt_del_max[OF lrNotLeaf(1)] letMax"], ["proof (prove)\nusing this:\n  wbt \\<langle>l, (a, n), r\\<rangle>\n  wbt l \\<Longrightarrow> wbt (snd (del_max l))\n  del_max l = (lMax, l')\n\ngoal (1 subgoal):\n 1. wbt l'", "by (metis wbt.simps(2) snd_conv)"], ["proof (state)\nthis:\n  wbt l'\n\ngoal (2 subgoals):\n 1. size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "moreover"], ["proof (state)\nthis:\n  wbt l'\n\ngoal (2 subgoals):\n 1. size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "have \"size l = size l' + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size l = size l' + 1", "using size_del_max[OF lrNotLeaf(1)] letMax"], ["proof (prove)\nusing this:\n  size l = Suc (size (snd (del_max l)))\n  del_max l = (lMax, l')\n\ngoal (1 subgoal):\n 1. size l = size l' + 1", "by (simp)"], ["proof (state)\nthis:\n  size l = size l' + 1\n\ngoal (2 subgoals):\n 1. size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "ultimately"], ["proof (chain)\npicking this:\n  wbt l'\n  size l = size l' + 1", "have \"wbt(balanceL l' lMax r)\""], ["proof (prove)\nusing this:\n  wbt l'\n  size l = size l' + 1\n\ngoal (1 subgoal):\n 1. wbt (balanceL l' lMax r)", "using wbt_balanceL"], ["proof (prove)\nusing this:\n  wbt l'\n  size l = size l' + 1\n  \\<lbrakk>wbt \\<langle>?l, (?a, ?n), ?r\\<rangle>; wbt ?l';\n   size ?l = size ?l' + 1\\<rbrakk>\n  \\<Longrightarrow> wbt (balanceL ?l' ?a' ?r)\n\ngoal (1 subgoal):\n 1. wbt (balanceL l' lMax r)", "by (metis Node.prems)"], ["proof (state)\nthis:\n  wbt (balanceL l' lMax r)\n\ngoal (2 subgoals):\n 1. size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n 2. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  wbt (balanceL l' lMax r)\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "using balanceLeft"], ["proof (prove)\nusing this:\n  wbt (balanceL l' lMax r)\n  combine l r = balanceL l' lMax r\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "case False"], ["proof (state)\nthis:\n  \\<not> size r < size l\n\ngoal (1 subgoal):\n 1. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "obtain rMin r' where letMin: \"split_min r = (rMin, r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rMin r'.\n        split_min r = (rMin, r') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  split_min r = (rMin, r')\n\ngoal (1 subgoal):\n 1. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "hence balanceRight: \"combine l r = balanceR l rMin r'\""], ["proof (prove)\nusing this:\n  split_min r = (rMin, r')\n\ngoal (1 subgoal):\n 1. combine l r = balanceR l rMin r'", "using \\<open>\\<not> size l > size r\\<close>"], ["proof (prove)\nusing this:\n  split_min r = (rMin, r')\n  \\<not> size r < size l\n\ngoal (1 subgoal):\n 1. combine l r = balanceR l rMin r'", "by (simp)"], ["proof (state)\nthis:\n  combine l r = balanceR l rMin r'\n\ngoal (1 subgoal):\n 1. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "have \"wbt r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt r'", "using Node.prems wbt_split_min[OF lrNotLeaf(2)] letMin"], ["proof (prove)\nusing this:\n  wbt \\<langle>l, (a, n), r\\<rangle>\n  wbt r \\<Longrightarrow> wbt (snd (split_min r))\n  split_min r = (rMin, r')\n\ngoal (1 subgoal):\n 1. wbt r'", "by (metis wbt.simps(2) snd_conv)"], ["proof (state)\nthis:\n  wbt r'\n\ngoal (1 subgoal):\n 1. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "moreover"], ["proof (state)\nthis:\n  wbt r'\n\ngoal (1 subgoal):\n 1. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "have \"size r = size r' + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size r = size r' + 1", "using size_split_min[OF lrNotLeaf(2)] letMin"], ["proof (prove)\nusing this:\n  size r = Suc (size (snd (split_min r)))\n  split_min r = (rMin, r')\n\ngoal (1 subgoal):\n 1. size r = size r' + 1", "by simp"], ["proof (state)\nthis:\n  size r = size r' + 1\n\ngoal (1 subgoal):\n 1. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "ultimately"], ["proof (chain)\npicking this:\n  wbt r'\n  size r = size r' + 1", "have \"wbt(balanceR l rMin r')\""], ["proof (prove)\nusing this:\n  wbt r'\n  size r = size r' + 1\n\ngoal (1 subgoal):\n 1. wbt (balanceR l rMin r')", "using wbt_balanceR"], ["proof (prove)\nusing this:\n  wbt r'\n  size r = size r' + 1\n  \\<lbrakk>wbt \\<langle>?l, (?a, ?n), ?r\\<rangle>; wbt ?r';\n   size ?r = size ?r' + 1\\<rbrakk>\n  \\<Longrightarrow> wbt (balanceR ?l ?a' ?r')\n\ngoal (1 subgoal):\n 1. wbt (balanceR l rMin r')", "by (metis Node.prems)"], ["proof (state)\nthis:\n  wbt (balanceR l rMin r')\n\ngoal (1 subgoal):\n 1. \\<not> size r < size l \\<Longrightarrow>\n    wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  wbt (balanceR l rMin r')\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "using balanceRight"], ["proof (prove)\nusing this:\n  wbt (balanceR l rMin r')\n  combine l r = balanceR l rMin r'\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<noteq> \\<langle>\\<rangle>;\n   r \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isin \\<langle>l, (a, n), r\\<rangle> x; cmp x a = EQ\\<rbrakk>\n    \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>l = \\<langle>\\<rangle>; r = \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n  \\<lbrakk>l = \\<langle>\\<rangle>; r \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n  \\<lbrakk>l \\<noteq> \\<langle>\\<rangle>; r = \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n  \\<lbrakk>l \\<noteq> \\<langle>\\<rangle>;\n   r \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>l = \\<langle>\\<rangle>; r = \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n  \\<lbrakk>l = \\<langle>\\<rangle>; r \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n  \\<lbrakk>l \\<noteq> \\<langle>\\<rangle>; r = \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n  \\<lbrakk>l \\<noteq> \\<langle>\\<rangle>;\n   r \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. wbt (delete x \\<langle>l, (a, n), r\\<rangle>)", "by blast"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wbt (delete x \\<langle>l, (a, n), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The final correctness proof\\<close>"], ["", "interpretation S: Set_by_Ordered\nwhere empty = Leaf and isin = isin and insert = insert and delete = delete\nand inorder = inorder and inv = wbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. Set_by_Ordered \\<langle>\\<rangle> Weight_Balanced_Trees.insert delete\n     isin Tree2.inorder wbt", "proof (standard, goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. Tree2.inorder \\<langle>\\<rangle> = []\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       isin t x = (x \\<in> set (Tree2.inorder t))\n 3. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (Weight_Balanced_Trees.insert x t) =\n       ins_list x (Tree2.inorder t)\n 4. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)\n 5. wbt \\<langle>\\<rangle>\n 6. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 7. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. Tree2.inorder \\<langle>\\<rangle> = []\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       isin t x = (x \\<in> set (Tree2.inorder t))\n 3. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (Weight_Balanced_Trees.insert x t) =\n       ins_list x (Tree2.inorder t)\n 4. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)\n 5. wbt \\<langle>\\<rangle>\n 6. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 7. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tree2.inorder \\<langle>\\<rangle> = []", "by simp"], ["proof (state)\nthis:\n  Tree2.inorder \\<langle>\\<rangle> = []\n\ngoal (6 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       isin t x = (x \\<in> set (Tree2.inorder t))\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (Weight_Balanced_Trees.insert x t) =\n       ins_list x (Tree2.inorder t)\n 3. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)\n 4. wbt \\<langle>\\<rangle>\n 5. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 6. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       isin t x = (x \\<in> set (Tree2.inorder t))\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (Weight_Balanced_Trees.insert x t) =\n       ins_list x (Tree2.inorder t)\n 3. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)\n 4. wbt \\<langle>\\<rangle>\n 5. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 6. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "case 2"], ["proof (state)\nthis:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n\ngoal (6 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       isin t x = (x \\<in> set (Tree2.inorder t))\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (Weight_Balanced_Trees.insert x t) =\n       ins_list x (Tree2.inorder t)\n 3. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)\n 4. wbt \\<langle>\\<rangle>\n 5. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 6. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "thus ?case"], ["proof (prove)\nusing this:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n\ngoal (1 subgoal):\n 1. isin t_ x_ = (x_ \\<in> set (Tree2.inorder t_))", "by(simp add: isin_set_inorder)"], ["proof (state)\nthis:\n  isin t_ x_ = (x_ \\<in> set (Tree2.inorder t_))\n\ngoal (5 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (Weight_Balanced_Trees.insert x t) =\n       ins_list x (Tree2.inorder t)\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)\n 3. wbt \\<langle>\\<rangle>\n 4. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 5. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (Weight_Balanced_Trees.insert x t) =\n       ins_list x (Tree2.inorder t)\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)\n 3. wbt \\<langle>\\<rangle>\n 4. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 5. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "case 3"], ["proof (state)\nthis:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n\ngoal (5 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (Weight_Balanced_Trees.insert x t) =\n       ins_list x (Tree2.inorder t)\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)\n 3. wbt \\<langle>\\<rangle>\n 4. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 5. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "thus ?case"], ["proof (prove)\nusing this:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n\ngoal (1 subgoal):\n 1. Tree2.inorder (Weight_Balanced_Trees.insert x_ t_) =\n    ins_list x_ (Tree2.inorder t_)", "by(simp add: inorder_insert)"], ["proof (state)\nthis:\n  Tree2.inorder (Weight_Balanced_Trees.insert x_ t_) =\n  ins_list x_ (Tree2.inorder t_)\n\ngoal (4 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)\n 2. wbt \\<langle>\\<rangle>\n 3. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 4. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)\n 2. wbt \\<langle>\\<rangle>\n 3. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 4. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "case 4"], ["proof (state)\nthis:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n\ngoal (4 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       Tree2.inorder (delete x t) = del_list x (Tree2.inorder t)\n 2. wbt \\<langle>\\<rangle>\n 3. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 4. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "thus ?case"], ["proof (prove)\nusing this:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n\ngoal (1 subgoal):\n 1. Tree2.inorder (delete x_ t_) = del_list x_ (Tree2.inorder t_)", "by(simp add: inorder_delete)"], ["proof (state)\nthis:\n  Tree2.inorder (delete x_ t_) = del_list x_ (Tree2.inorder t_)\n\ngoal (3 subgoals):\n 1. wbt \\<langle>\\<rangle>\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 3. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. wbt \\<langle>\\<rangle>\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 3. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. wbt \\<langle>\\<rangle>\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 3. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wbt \\<langle>\\<rangle>", "by simp"], ["proof (state)\nthis:\n  wbt \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "case 6"], ["proof (state)\nthis:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n\ngoal (2 subgoals):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (Weight_Balanced_Trees.insert x t)\n 2. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "thus ?case"], ["proof (prove)\nusing this:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x_ t_)", "using wbt_insert"], ["proof (prove)\nusing this:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n  wbt ?t \\<Longrightarrow> wbt (Weight_Balanced_Trees.insert ?x ?t)\n\ngoal (1 subgoal):\n 1. wbt (Weight_Balanced_Trees.insert x_ t_)", "by blast"], ["proof (state)\nthis:\n  wbt (Weight_Balanced_Trees.insert x_ t_)\n\ngoal (1 subgoal):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "case 7"], ["proof (state)\nthis:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n\ngoal (1 subgoal):\n 1. \\<And>t x.\n       wbt t \\<and> Sorted_Less.sorted (Tree2.inorder t) \\<Longrightarrow>\n       wbt (delete x t)", "thus ?case"], ["proof (prove)\nusing this:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n\ngoal (1 subgoal):\n 1. wbt (delete x_ t_)", "using wbt_delete"], ["proof (prove)\nusing this:\n  wbt t_ \\<and> Sorted_Less.sorted (Tree2.inorder t_)\n  wbt ?t \\<Longrightarrow> wbt (delete ?x ?t)\n\ngoal (1 subgoal):\n 1. wbt (delete x_ t_)", "by blast"], ["proof (state)\nthis:\n  wbt (delete x_ t_)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}