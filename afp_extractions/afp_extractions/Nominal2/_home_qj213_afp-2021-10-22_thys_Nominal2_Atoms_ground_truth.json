{"file_name": "/home/qj213/afp-2021-10-22/thys/Nominal2/Atoms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nominal2", "problem_names": ["lemma not_fresh_nat_of:\n  shows \"\\<not> a \\<sharp> nat_of\"", "lemma supp_nat_of:\n  shows \"supp nat_of = UNIV\"", "lemma sort_of_atom_name: \n  shows \"sort_of (atom (a::name)) = Sort ''name'' []\"", "lemma \n  \"sort_of (atom (a::name2)) \\<noteq> sort_of (atom (b::name))\"", "lemma\n  fixes a b::\"atom\"\n  assumes \"sort_of a = sort_of b\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> (a, b) = (b, a)\"", "lemma\n  fixes a b::\"name2\"\n  shows \"(a \\<leftrightarrow> b) \\<bullet> (a, b) = (b, a)\"", "lemma sort_of_ty_eq_iff:\n  shows \"sort_of_ty x = sort_of_ty y \\<longleftrightarrow> x = y\"", "lemma Var_eq_iff [simp]:\n  shows \"Var x s = Var y t \\<longleftrightarrow> x = y \\<and> s = t\"", "lemma sort_of_atom_var [simp]:\n  \"sort_of (atom (Var n ty)) = sort_of_ty ty\"", "lemma \n  assumes \"\\<alpha> \\<noteq> \\<beta>\" \n  shows \"(Var x \\<alpha> \\<leftrightarrow> Var y \\<alpha>) \\<bullet> (Var x \\<alpha>, Var x \\<beta>) = (Var y \\<alpha>, Var x \\<beta>)\"", "lemma ty_of_Var [simp]:\n  shows \"ty_of (Var x t) = t\"", "lemma ty_of_permute [simp]:\n  shows \"ty_of (p \\<bullet> x) = ty_of x\"", "lemma\n  fixes a::\"var1\" and b::\"var2\"\n  shows \"a \\<sharp> t \\<and> b \\<sharp> t\"", "lemma\n  fixes as::\"var1 set\"\n  shows \"atom ` as \\<sharp>* t\""], "translations": [["", "lemma not_fresh_nat_of:\n  shows \"\\<not> a \\<sharp> nat_of\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> a \\<sharp> nat_of", "unfolding fresh_def supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> a \\<notin> {a. infinite\n                           {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n                               nat_of}}", "proof (clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "assume \"finite {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq> nat_of}\""], ["proof (state)\nthis:\n  finite {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq> nat_of}\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "hence \"finite ({a} \\<union> {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq> nat_of})\""], ["proof (prove)\nusing this:\n  finite {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq> nat_of}\n\ngoal (1 subgoal):\n 1. finite\n     ({a} \\<union>\n      {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq> nat_of})", "by simp"], ["proof (state)\nthis:\n  finite\n   ({a} \\<union>\n    {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq> nat_of})\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  finite\n   ({a} \\<union>\n    {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq> nat_of})", "obtain b where\n    b1: \"b \\<noteq> a\" and\n    b2: \"sort_of b = sort_of a\" and\n    b3: \"(a \\<rightleftharpoons> b) \\<bullet> nat_of = nat_of\""], ["proof (prove)\nusing this:\n  finite\n   ({a} \\<union>\n    {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq> nat_of})\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<noteq> a; sort_of b = sort_of a;\n         (a \\<rightleftharpoons> b) \\<bullet> nat_of = nat_of\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_atom) auto"], ["proof (state)\nthis:\n  b \\<noteq> a\n  sort_of b = sort_of a\n  (a \\<rightleftharpoons> b) \\<bullet> nat_of = nat_of\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "have \"nat_of a = (a \\<rightleftharpoons> b) \\<bullet> (nat_of a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of a = (a \\<rightleftharpoons> b) \\<bullet> nat_of a", "by (simp add: permute_nat_def)"], ["proof (state)\nthis:\n  nat_of a = (a \\<rightleftharpoons> b) \\<bullet> nat_of a\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  nat_of a = (a \\<rightleftharpoons> b) \\<bullet> nat_of a\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "have \"\\<dots> = ((a \\<rightleftharpoons> b) \\<bullet> nat_of) ((a \\<rightleftharpoons> b) \\<bullet> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> nat_of a =\n    ((a \\<rightleftharpoons> b) \\<bullet> nat_of)\n     ((a \\<rightleftharpoons> b) \\<bullet> a)", "by (simp add: permute_fun_app_eq)"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> nat_of a =\n  ((a \\<rightleftharpoons> b) \\<bullet> nat_of)\n   ((a \\<rightleftharpoons> b) \\<bullet> a)\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> nat_of a =\n  ((a \\<rightleftharpoons> b) \\<bullet> nat_of)\n   ((a \\<rightleftharpoons> b) \\<bullet> a)\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "have \"\\<dots> = nat_of ((a \\<rightleftharpoons> b) \\<bullet> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a \\<rightleftharpoons> b) \\<bullet> nat_of)\n     ((a \\<rightleftharpoons> b) \\<bullet> a) =\n    nat_of ((a \\<rightleftharpoons> b) \\<bullet> a)", "using b3"], ["proof (prove)\nusing this:\n  (a \\<rightleftharpoons> b) \\<bullet> nat_of = nat_of\n\ngoal (1 subgoal):\n 1. ((a \\<rightleftharpoons> b) \\<bullet> nat_of)\n     ((a \\<rightleftharpoons> b) \\<bullet> a) =\n    nat_of ((a \\<rightleftharpoons> b) \\<bullet> a)", "by simp"], ["proof (state)\nthis:\n  ((a \\<rightleftharpoons> b) \\<bullet> nat_of)\n   ((a \\<rightleftharpoons> b) \\<bullet> a) =\n  nat_of ((a \\<rightleftharpoons> b) \\<bullet> a)\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  ((a \\<rightleftharpoons> b) \\<bullet> nat_of)\n   ((a \\<rightleftharpoons> b) \\<bullet> a) =\n  nat_of ((a \\<rightleftharpoons> b) \\<bullet> a)\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "have \"\\<dots> = nat_of b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of ((a \\<rightleftharpoons> b) \\<bullet> a) = nat_of b", "using b2"], ["proof (prove)\nusing this:\n  sort_of b = sort_of a\n\ngoal (1 subgoal):\n 1. nat_of ((a \\<rightleftharpoons> b) \\<bullet> a) = nat_of b", "by simp"], ["proof (state)\nthis:\n  nat_of ((a \\<rightleftharpoons> b) \\<bullet> a) = nat_of b\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  nat_of a = nat_of b", "have \"nat_of a = nat_of b\""], ["proof (prove)\nusing this:\n  nat_of a = nat_of b\n\ngoal (1 subgoal):\n 1. nat_of a = nat_of b", "by simp"], ["proof (state)\nthis:\n  nat_of a = nat_of b\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "with b2"], ["proof (chain)\npicking this:\n  sort_of b = sort_of a\n  nat_of a = nat_of b", "have \"a = b\""], ["proof (prove)\nusing this:\n  sort_of b = sort_of a\n  nat_of a = nat_of b\n\ngoal (1 subgoal):\n 1. a = b", "by (simp add: atom_components_eq_iff)"], ["proof (state)\nthis:\n  a = b\n\ngoal (1 subgoal):\n 1. finite\n     {b. (a \\<rightleftharpoons> b) \\<bullet> nat_of \\<noteq>\n         nat_of} \\<Longrightarrow>\n    False", "with b1"], ["proof (chain)\npicking this:\n  b \\<noteq> a\n  a = b", "show \"False\""], ["proof (prove)\nusing this:\n  b \\<noteq> a\n  a = b\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_nat_of:\n  shows \"supp nat_of = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp nat_of = UNIV", "using not_fresh_nat_of [unfolded fresh_def]"], ["proof (prove)\nusing this:\n  \\<not> ?a \\<notin> supp nat_of\n\ngoal (1 subgoal):\n 1. supp nat_of = UNIV", "by auto"], ["", "section \\<open>Manual instantiation of class \\<open>at\\<close>.\\<close>"], ["", "typedef name = \"{a. sort_of a = Sort ''name'' []}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {a. sort_of a = Sort ''name'' []}", "by (rule exists_eq_simple_sort)"], ["", "instantiation name :: at\nbegin"], ["", "definition\n  \"p \\<bullet> a = Abs_name (p \\<bullet> Rep_name a)\""], ["", "definition\n  \"atom a = Rep_name a\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(name, at_class)", "apply (rule at_class)"], ["proof (prove)\ngoal (3 subgoals):\n 1. type_definition ?Rep ?Abs {a. sort_of a = ?s}\n 2. \\<And>a. atom a = ?Rep a\n 3. \\<And>p a. p \\<bullet> a = ?Abs (p \\<bullet> ?Rep a)", "apply (rule type_definition_name)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. atom a = Rep_name a\n 2. \\<And>p a. p \\<bullet> a = Abs_name (p \\<bullet> Rep_name a)", "apply (rule atom_name_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p a. p \\<bullet> a = Abs_name (p \\<bullet> Rep_name a)", "apply (rule permute_name_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma sort_of_atom_name: \n  shows \"sort_of (atom (a::name)) = Sort ''name'' []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of (atom a) = Sort ''name'' []", "by (simp add: atom_name_def Rep_name[simplified])"], ["", "text \\<open>Custom syntax for concrete atoms of type at\\<close>"], ["", "term \"a:::name\""], ["", "section \\<open>Automatic instantiation of class \\<open>at\\<close>.\\<close>"], ["", "atom_decl name2"], ["", "lemma \n  \"sort_of (atom (a::name2)) \\<noteq> sort_of (atom (b::name))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of (atom a) \\<noteq> sort_of (atom b)", "by (simp add: sort_of_atom_name)"], ["", "text \\<open>example swappings\\<close>"], ["", "lemma\n  fixes a b::\"atom\"\n  assumes \"sort_of a = sort_of b\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> (a, b) = (b, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> (a, b) = (b, a)", "using assms"], ["proof (prove)\nusing this:\n  sort_of a = sort_of b\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> (a, b) = (b, a)", "by simp"], ["", "lemma\n  fixes a b::\"name2\"\n  shows \"(a \\<leftrightarrow> b) \\<bullet> (a, b) = (b, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<leftrightarrow> b) \\<bullet> (a, b) = (b, a)", "by simp"], ["", "section \\<open>An example for multiple-sort atoms\\<close>"], ["", "datatype ty =\n  TVar string\n| Fun ty ty (\"_ \\<rightarrow> _\")"], ["", "primrec\n  sort_of_ty::\"ty \\<Rightarrow> atom_sort\"\nwhere\n  \"sort_of_ty (TVar s) = Sort ''TVar'' [Sort s []]\"\n| \"sort_of_ty (Fun ty1 ty2) = Sort ''Fun'' [sort_of_ty ty1, sort_of_ty ty2]\""], ["", "lemma sort_of_ty_eq_iff:\n  shows \"sort_of_ty x = sort_of_ty y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sort_of_ty x = sort_of_ty y) = (x = y)", "apply(induct x arbitrary: y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (sort_of_ty (TVar x) = sort_of_ty y) = (TVar x = y)\n 2. \\<And>x1 x2 y.\n       \\<lbrakk>\\<And>y. (sort_of_ty x1 = sort_of_ty y) = (x1 = y);\n        \\<And>y. (sort_of_ty x2 = sort_of_ty y) = (x2 = y)\\<rbrakk>\n       \\<Longrightarrow> (sort_of_ty x1 \\<rightarrow> x2 = sort_of_ty y) =\n                         (x1 \\<rightarrow> x2 = y)", "apply(case_tac [!] y)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y x1.\n       y = TVar x1 \\<Longrightarrow>\n       (sort_of_ty (TVar x) = sort_of_ty y) = (TVar x = y)\n 2. \\<And>x y x21 x22.\n       y = x21 \\<rightarrow> x22 \\<Longrightarrow>\n       (sort_of_ty (TVar x) = sort_of_ty y) = (TVar x = y)\n 3. \\<And>x1 x2 y x1a.\n       \\<lbrakk>\\<And>y. (sort_of_ty x1 = sort_of_ty y) = (x1 = y);\n        \\<And>y. (sort_of_ty x2 = sort_of_ty y) = (x2 = y);\n        y = TVar x1a\\<rbrakk>\n       \\<Longrightarrow> (sort_of_ty x1 \\<rightarrow> x2 = sort_of_ty y) =\n                         (x1 \\<rightarrow> x2 = y)\n 4. \\<And>x1 x2 y x21 x22.\n       \\<lbrakk>\\<And>y. (sort_of_ty x1 = sort_of_ty y) = (x1 = y);\n        \\<And>y. (sort_of_ty x2 = sort_of_ty y) = (x2 = y);\n        y = x21 \\<rightarrow> x22\\<rbrakk>\n       \\<Longrightarrow> (sort_of_ty x1 \\<rightarrow> x2 = sort_of_ty y) =\n                         (x1 \\<rightarrow> x2 = y)", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare sort_of_ty.simps [simp del]"], ["", "typedef var = \"{a. sort_of a \\<in> range sort_of_ty}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {a. sort_of a \\<in> range sort_of_ty}", "by (rule_tac x=\"Atom (sort_of_ty x) y\" in exI, simp)"], ["", "instantiation var :: at_base\nbegin"], ["", "definition\n  \"p \\<bullet> a = Abs_var (p \\<bullet> Rep_var a)\""], ["", "definition\n  \"atom a = Rep_var a\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Atoms.var, at_base_class)", "apply (rule at_base_class)"], ["proof (prove)\ngoal (3 subgoals):\n 1. type_definition ?Rep ?Abs {a. sort_of a \\<in> range ?sort_fun}\n 2. \\<And>a. atom a = ?Rep a\n 3. \\<And>p a. p \\<bullet> a = ?Abs (p \\<bullet> ?Rep a)", "apply (rule type_definition_var)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. atom a = Rep_var a\n 2. \\<And>p a. p \\<bullet> a = Abs_var (p \\<bullet> Rep_var a)", "apply (rule atom_var_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p a. p \\<bullet> a = Abs_var (p \\<bullet> Rep_var a)", "apply (rule permute_var_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>Constructor for variables.\\<close>"], ["", "definition\n  Var :: \"nat \\<Rightarrow> ty \\<Rightarrow> var\"\nwhere\n  \"Var x t = Abs_var (Atom (sort_of_ty t) x)\""], ["", "lemma Var_eq_iff [simp]:\n  shows \"Var x s = Var y t \\<longleftrightarrow> x = y \\<and> s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var x s = Var y t) = (x = y \\<and> s = t)", "unfolding Var_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_var (Atom (sort_of_ty s) x) = Abs_var (Atom (sort_of_ty t) y)) =\n    (x = y \\<and> s = t)", "by (auto simp add: Abs_var_inject sort_of_ty_eq_iff)"], ["", "lemma sort_of_atom_var [simp]:\n  \"sort_of (atom (Var n ty)) = sort_of_ty ty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of (atom (Var n ty)) = sort_of_ty ty", "unfolding atom_var_def Var_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of (Rep_var (Abs_var (Atom (sort_of_ty ty) n))) = sort_of_ty ty", "by (simp add: Abs_var_inverse)"], ["", "lemma \n  assumes \"\\<alpha> \\<noteq> \\<beta>\" \n  shows \"(Var x \\<alpha> \\<leftrightarrow> Var y \\<alpha>) \\<bullet> (Var x \\<alpha>, Var x \\<beta>) = (Var y \\<alpha>, Var x \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var x\n      \\<alpha> \\<leftrightarrow> Var y\n                                  \\<alpha>) \\<bullet> (Var x \\<alpha>,\n                 Var x \\<beta>) =\n    (Var y \\<alpha>, Var x \\<beta>)", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> \\<beta>\n\ngoal (1 subgoal):\n 1. (Var x\n      \\<alpha> \\<leftrightarrow> Var y\n                                  \\<alpha>) \\<bullet> (Var x \\<alpha>,\n                 Var x \\<beta>) =\n    (Var y \\<alpha>, Var x \\<beta>)", "by simp"], ["", "text \\<open>Projecting out the type component of a variable.\\<close>"], ["", "definition\n  ty_of :: \"var \\<Rightarrow> ty\"\nwhere\n  \"ty_of x = inv sort_of_ty (sort_of (atom x))\""], ["", "text \\<open>\n  Functions @{term Var}/@{term ty_of} satisfy many of the same\n  properties as @{term Atom}/@{term sort_of}.\n\\<close>"], ["", "lemma ty_of_Var [simp]:\n  shows \"ty_of (Var x t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ty_of (Var x t) = t", "unfolding ty_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv sort_of_ty (sort_of (atom (Var x t))) = t", "unfolding sort_of_atom_var"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv sort_of_ty (sort_of_ty t) = t", "apply (rule inv_f_f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj sort_of_ty", "apply (simp add: inj_on_def sort_of_ty_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ty_of_permute [simp]:\n  shows \"ty_of (p \\<bullet> x) = ty_of x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ty_of (p \\<bullet> x) = ty_of x", "unfolding ty_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv sort_of_ty (sort_of (atom (p \\<bullet> x))) =\n    inv sort_of_ty (sort_of (atom x))", "unfolding atom_eqvt [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv sort_of_ty (sort_of (p \\<bullet> atom x)) =\n    inv sort_of_ty (sort_of (atom x))", "by (simp only: sort_of_permute)"], ["", "section \\<open>Tests with subtyping and automatic coercions\\<close>"], ["", "declare [[coercion_enabled]]"], ["", "atom_decl var1"], ["", "atom_decl var2"], ["", "declare [[coercion \"atom::var1\\<Rightarrow>atom\"]]"], ["", "declare [[coercion \"atom::var2\\<Rightarrow>atom\"]]"], ["", "lemma\n  fixes a::\"var1\" and b::\"var2\"\n  shows \"a \\<sharp> t \\<and> b \\<sharp> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom a \\<sharp> t \\<and> atom b \\<sharp> t", "oops"], ["", "(* does not yet work: it needs image as\n   coercion map *)"], ["", "lemma\n  fixes as::\"var1 set\"\n  shows \"atom ` as \\<sharp>* t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ` as \\<sharp>* t", "oops"], ["", "end"]]}