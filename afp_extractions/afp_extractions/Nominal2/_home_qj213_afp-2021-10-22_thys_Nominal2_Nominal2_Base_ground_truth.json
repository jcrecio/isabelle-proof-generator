{"file_name": "/home/qj213/afp-2021-10-22/thys/Nominal2/Nominal2_Base.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nominal2", "problem_names": ["lemma INFM_sort_of_eq:\n  shows \"INFM a. sort_of a = s\"", "lemma infinite_sort_of_eq:\n  shows \"infinite {a. sort_of a = s}\"", "lemma atom_infinite [simp]:\n  shows \"infinite (UNIV :: atom set)\"", "lemma obtain_atom:\n  fixes X :: \"atom set\"\n  assumes X: \"finite X\"\n  obtains a where \"a \\<notin> X\" \"sort_of a = s\"", "lemma atom_components_eq_iff:\n  fixes a b :: atom\n  shows \"a = b \\<longleftrightarrow> sort_of a = sort_of b \\<and> nat_of a = nat_of b\"", "lemma permI:\n  assumes \"bij f\" and \"MOST x. f x = x\" and \"\\<And>a. sort_of (f a) = sort_of a\"\n  shows \"f \\<in> perm\"", "lemma perm_is_bij: \"f \\<in> perm \\<Longrightarrow> bij f\"", "lemma perm_is_finite: \"f \\<in> perm \\<Longrightarrow> finite {a. f a \\<noteq> a}\"", "lemma perm_is_sort_respecting: \"f \\<in> perm \\<Longrightarrow> sort_of (f a) = sort_of a\"", "lemma perm_MOST: \"f \\<in> perm \\<Longrightarrow> MOST x. f x = x\"", "lemma perm_id: \"id \\<in> perm\"", "lemma perm_comp:\n  assumes f: \"f \\<in> perm\" and g: \"g \\<in> perm\"\n  shows \"(f \\<circ> g) \\<in> perm\"", "lemma perm_inv:\n  assumes f: \"f \\<in> perm\"\n  shows \"(inv f) \\<in> perm\"", "lemma bij_Rep_perm: \"bij (Rep_perm p)\"", "lemma finite_Rep_perm: \"finite {a. Rep_perm p a \\<noteq> a}\"", "lemma sort_of_Rep_perm: \"sort_of (Rep_perm p a) = sort_of a\"", "lemma Rep_perm_ext:\n  \"Rep_perm p1 = Rep_perm p2 \\<Longrightarrow> p1 = p2\"", "lemma Rep_perm_0: \"Rep_perm 0 = id\"", "lemma Rep_perm_add:\n  \"Rep_perm (p1 + p2) = Rep_perm p1 \\<circ> Rep_perm p2\"", "lemma Rep_perm_uminus:\n  \"Rep_perm (- p) = inv (Rep_perm p)\"", "lemma Rep_perm_swap:\n  \"Rep_perm (a \\<rightleftharpoons> b) =\n    (if sort_of a = sort_of b\n     then (\\<lambda>c. if a = c then b else if b = c then a else c)\n     else id)\"", "lemmas Rep_perm_simps =\n  Rep_perm_0\n  Rep_perm_add\n  Rep_perm_uminus\n  Rep_perm_swap", "lemma swap_different_sorts [simp]:\n  \"sort_of a \\<noteq> sort_of b \\<Longrightarrow> (a \\<rightleftharpoons> b) = 0\"", "lemma swap_cancel:\n  shows \"(a \\<rightleftharpoons> b) + (a \\<rightleftharpoons> b) = 0\"\n  and   \"(a \\<rightleftharpoons> b) + (b \\<rightleftharpoons> a) = 0\"", "lemma swap_self [simp]:\n  \"(a \\<rightleftharpoons> a) = 0\"", "lemma minus_swap [simp]:\n  \"- (a \\<rightleftharpoons> b) = (a \\<rightleftharpoons> b)\"", "lemma swap_commute:\n  \"(a \\<rightleftharpoons> b) = (b \\<rightleftharpoons> a)\"", "lemma swap_triple:\n  assumes \"a \\<noteq> b\" and \"c \\<noteq> b\"\n  assumes \"sort_of a = sort_of b\" \"sort_of b = sort_of c\"\n  shows \"(a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) + (a \\<rightleftharpoons> c) = (a \\<rightleftharpoons> b)\"", "lemma permute_diff [simp]:\n  shows \"(p - q) \\<bullet> x = p \\<bullet> - q \\<bullet> x\"", "lemma permute_minus_cancel [simp]:\n  shows \"p \\<bullet> - p \\<bullet> x = x\"\n  and   \"- p \\<bullet> p \\<bullet> x = x\"", "lemma permute_swap_cancel [simp]:\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> (a \\<rightleftharpoons> b) \\<bullet> x = x\"", "lemma permute_swap_cancel2 [simp]:\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> (b \\<rightleftharpoons> a) \\<bullet> x = x\"", "lemma inj_permute [simp]:\n  shows \"inj (permute p)\"", "lemma surj_permute [simp]:\n  shows \"surj (permute p)\"", "lemma bij_permute [simp]:\n  shows \"bij (permute p)\"", "lemma inv_permute:\n  shows \"inv (permute p) = permute (- p)\"", "lemma permute_minus:\n  shows \"permute (- p) = inv (permute p)\"", "lemma permute_eq_iff [simp]:\n  shows \"p \\<bullet> x = p \\<bullet> y \\<longleftrightarrow> x = y\"", "lemma sort_of_permute [simp]:\n  shows \"sort_of (p \\<bullet> a) = sort_of a\"", "lemma swap_atom:\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> c =\n           (if sort_of a = sort_of b\n            then (if c = a then b else if c = b then a else c) else c)\"", "lemma swap_atom_simps [simp]:\n  \"sort_of a = sort_of b \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> a = b\"\n  \"sort_of a = sort_of b \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> b = a\"\n  \"c \\<noteq> a \\<Longrightarrow> c \\<noteq> b \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> c = c\"", "lemma perm_eq_iff:\n  fixes p q :: \"perm\"\n  shows \"p = q \\<longleftrightarrow> (\\<forall>a::atom. p \\<bullet> a = q \\<bullet> a)\"", "lemma permute_self:\n  shows \"p \\<bullet> p = p\"", "lemma pemute_minus_self:\n  shows \"- p \\<bullet> p = p\"", "lemma permute_fun_app_eq:\n  shows \"p \\<bullet> (f x) = (p \\<bullet> f) (p \\<bullet> x)\"", "lemma permute_fun_comp:\n  shows \"p \\<bullet> f  = (permute p) o f o (permute (-p))\"", "lemma permute_boolE:\n  fixes P::\"bool\"\n  shows \"p \\<bullet> P \\<Longrightarrow> P\"", "lemma permute_boolI:\n  fixes P::\"bool\"\n  shows \"P \\<Longrightarrow> p \\<bullet> P\"", "lemma permute_set_eq:\n shows \"p \\<bullet> X = {x. - p \\<bullet> x \\<in> X}\"", "lemma permute_set_eq_image:\n  shows \"p \\<bullet> X = permute p ` X\"", "lemma permute_set_eq_vimage:\n  shows \"p \\<bullet> X = permute (- p) -` X\"", "lemma permute_finite [simp]:\n  shows \"finite (p \\<bullet> X) = finite X\"", "lemma swap_set_not_in:\n  assumes a: \"a \\<notin> S\" \"b \\<notin> S\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> S = S\"", "lemma swap_set_in:\n  assumes a: \"a \\<in> S\" \"b \\<notin> S\" \"sort_of a = sort_of b\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S\"", "lemma swap_set_in_eq:\n  assumes a: \"a \\<in> S\" \"b \\<notin> S\" \"sort_of a = sort_of b\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> S = (S - {a}) \\<union> {b}\"", "lemma swap_set_both_in:\n  assumes a: \"a \\<in> S\" \"b \\<in> S\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> S = S\"", "lemma mem_permute_iff:\n  shows \"(p \\<bullet> x) \\<in> (p \\<bullet> X) \\<longleftrightarrow> x \\<in> X\"", "lemma empty_eqvt:\n  shows \"p \\<bullet> {} = {}\"", "lemma insert_eqvt:\n  shows \"p \\<bullet> (insert x A) = insert (p \\<bullet> x) (p \\<bullet> A)\"", "lemma set_eqvt:\n  shows \"p \\<bullet> (set xs) = set (p \\<bullet> xs)\"", "lemma permute_multiset [simp]:\n  fixes M N::\"('a::pt) multiset\"\n  shows \"(p \\<bullet> {#}) = ({#} ::('a::pt) multiset)\"\n  and   \"(p \\<bullet> add_mset x M) = add_mset (p \\<bullet> x) (p \\<bullet> M)\"\n  and   \"(p \\<bullet> (M + N)) = (p \\<bullet> M) + (p \\<bullet> N)\"", "lemma permute_fset [simp]:\n  fixes S::\"('a::pt) fset\"\n  shows \"(p \\<bullet> {||}) = ({||} ::('a::pt) fset)\"\n  and   \"(p \\<bullet> finsert x S) = finsert (p \\<bullet> x) (p \\<bullet> S)\"", "lemma fset_eqvt:\n  shows \"p \\<bullet> (fset S) = fset (p \\<bullet> S)\"", "lemmas [eqvt] =\n  (* pt types *)\n  permute_prod.simps\n  permute_list.simps\n  permute_option.simps\n  permute_sum.simps\n\n  (* sets *)\n  empty_eqvt insert_eqvt set_eqvt\n\n  (* fsets *)\n  permute_fset fset_eqvt\n\n  (* multisets *)\n  permute_multiset", "lemma eqvt_apply:\n  fixes f :: \"'a::pt \\<Rightarrow> 'b::pt\"\n  and x :: \"'a::pt\"\n  shows \"p \\<bullet> (f x) \\<equiv> (p \\<bullet> f) (p \\<bullet> x)\"", "lemma eqvt_lambda:\n  fixes f :: \"'a::pt \\<Rightarrow> 'b::pt\"\n  shows \"p \\<bullet> f \\<equiv> (\\<lambda>x. p \\<bullet> (f (unpermute p x)))\"", "lemma eqvt_bound:\n  shows \"p \\<bullet> unpermute p x \\<equiv> x\"", "lemma permute_eqvt:\n  shows \"p \\<bullet> (q \\<bullet> x) = (p \\<bullet> q) \\<bullet> (p \\<bullet> x)\"", "lemma permute_eqvt_raw [eqvt_raw]:\n  shows \"p \\<bullet> permute \\<equiv> permute\"", "lemma zero_perm_eqvt [eqvt]:\n  shows \"p \\<bullet> (0::perm) = 0\"", "lemma add_perm_eqvt [eqvt]:\n  fixes p p1 p2 :: perm\n  shows \"p \\<bullet> (p1 + p2) = p \\<bullet> p1 + p \\<bullet> p2\"", "lemma swap_eqvt [eqvt]:\n  shows \"p \\<bullet> (a \\<rightleftharpoons> b) = (p \\<bullet> a \\<rightleftharpoons> p \\<bullet> b)\"", "lemma uminus_eqvt [eqvt]:\n  fixes p q::\"perm\"\n  shows \"p \\<bullet> (- q) = - (p \\<bullet> q)\"", "lemma eq_eqvt [eqvt]:\n  shows \"p \\<bullet> (x = y) \\<longleftrightarrow> (p \\<bullet> x) = (p \\<bullet> y)\"", "lemma Not_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<not> A) \\<longleftrightarrow> \\<not> (p \\<bullet> A)\"", "lemma conj_eqvt [eqvt]:\n  shows \"p \\<bullet> (A \\<and> B) \\<longleftrightarrow> (p \\<bullet> A) \\<and> (p \\<bullet> B)\"", "lemma imp_eqvt [eqvt]:\n  shows \"p \\<bullet> (A \\<longrightarrow> B) \\<longleftrightarrow> (p \\<bullet> A) \\<longrightarrow> (p \\<bullet> B)\"", "lemma all_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<forall>x. P x) = (\\<forall>x. (p \\<bullet> P) x)\"", "lemma ex_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<exists>x. P x) = (\\<exists>x. (p \\<bullet> P) x)\"", "lemma ex1_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<exists>!x. P x) = (\\<exists>!x. (p \\<bullet> P) x)\"", "lemma if_eqvt [eqvt]:\n  shows \"p \\<bullet> (if b then x else y) = (if p \\<bullet> b then p \\<bullet> x else p \\<bullet> y)\"", "lemma True_eqvt [eqvt]:\n  shows \"p \\<bullet> True = True\"", "lemma False_eqvt [eqvt]:\n  shows \"p \\<bullet> False = False\"", "lemma disj_eqvt [eqvt]:\n  shows \"p \\<bullet> (A \\<or> B) \\<longleftrightarrow> (p \\<bullet> A) \\<or> (p \\<bullet> B)\"", "lemma all_eqvt2:\n  shows \"p \\<bullet> (\\<forall>x. P x) = (\\<forall>x. p \\<bullet> P (- p \\<bullet> x))\"", "lemma ex_eqvt2:\n  shows \"p \\<bullet> (\\<exists>x. P x) = (\\<exists>x. p \\<bullet> P (- p \\<bullet> x))\"", "lemma ex1_eqvt2:\n  shows \"p \\<bullet> (\\<exists>!x. P x) = (\\<exists>!x. p \\<bullet> P (- p \\<bullet> x))\"", "lemma the_eqvt:\n  assumes unique: \"\\<exists>!x. P x\"\n  shows \"(p \\<bullet> (THE x. P x)) = (THE x. (p \\<bullet> P) x)\"", "lemma the_eqvt2:\n  assumes unique: \"\\<exists>!x. P x\"\n  shows \"(p \\<bullet> (THE x. P x)) = (THE x. p \\<bullet> P (- p \\<bullet> x))\"", "lemma mem_eqvt [eqvt]:\n  shows \"p \\<bullet> (x \\<in> A) \\<longleftrightarrow> (p \\<bullet> x) \\<in> (p \\<bullet> A)\"", "lemma Collect_eqvt [eqvt]:\n  shows \"p \\<bullet> {x. P x} = {x. (p \\<bullet> P) x}\"", "lemma Bex_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<exists>x \\<in> S. P x) = (\\<exists>x \\<in> (p \\<bullet> S). (p \\<bullet> P) x)\"", "lemma Ball_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<forall>x \\<in> S. P x) = (\\<forall>x \\<in> (p \\<bullet> S). (p \\<bullet> P) x)\"", "lemma image_eqvt [eqvt]:\n  shows \"p \\<bullet> (f ` A) = (p \\<bullet> f) ` (p \\<bullet> A)\"", "lemma Image_eqvt [eqvt]:\n  shows \"p \\<bullet> (R `` A) = (p \\<bullet> R) `` (p \\<bullet> A)\"", "lemma UNIV_eqvt [eqvt]:\n  shows \"p \\<bullet> UNIV = UNIV\"", "lemma inter_eqvt [eqvt]:\n  shows \"p \\<bullet> (A \\<inter> B) = (p \\<bullet> A) \\<inter> (p \\<bullet> B)\"", "lemma Inter_eqvt [eqvt]:\n  shows \"p \\<bullet> \\<Inter>S = \\<Inter>(p \\<bullet> S)\"", "lemma union_eqvt [eqvt]:\n  shows \"p \\<bullet> (A \\<union> B) = (p \\<bullet> A) \\<union> (p \\<bullet> B)\"", "lemma Union_eqvt [eqvt]:\n  shows \"p \\<bullet> \\<Union>A = \\<Union>(p \\<bullet> A)\"", "lemma Diff_eqvt [eqvt]:\n  fixes A B :: \"'a::pt set\"\n  shows \"p \\<bullet> (A - B) = (p \\<bullet> A) - (p \\<bullet> B)\"", "lemma Compl_eqvt [eqvt]:\n  fixes A :: \"'a::pt set\"\n  shows \"p \\<bullet> (- A) = - (p \\<bullet> A)\"", "lemma subset_eqvt [eqvt]:\n  shows \"p \\<bullet> (S \\<subseteq> T) \\<longleftrightarrow> (p \\<bullet> S) \\<subseteq> (p \\<bullet> T)\"", "lemma psubset_eqvt [eqvt]:\n  shows \"p \\<bullet> (S \\<subset> T) \\<longleftrightarrow> (p \\<bullet> S) \\<subset> (p \\<bullet> T)\"", "lemma vimage_eqvt [eqvt]:\n  shows \"p \\<bullet> (f -` A) = (p \\<bullet> f) -` (p \\<bullet> A)\"", "lemma foldr_eqvt[eqvt]:\n  \"p \\<bullet> foldr f xs = foldr (p \\<bullet> f) (p \\<bullet> xs)\"", "lemma Sigma_eqvt:\n  shows \"(p \\<bullet> (X \\<times> Y)) = (p \\<bullet> X) \\<times> (p \\<bullet> Y)\"", "lemma lfp_eqvt [eqvt]:\n  fixes F::\"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a::pt \\<Rightarrow> 'b::{inf_eqvt, le_eqvt})\"\n  shows \"p \\<bullet> (lfp F) = lfp (p \\<bullet> F)\"", "lemma finite_eqvt [eqvt]:\n  shows \"p \\<bullet> finite A = finite (p \\<bullet> A)\"", "lemma fun_upd_eqvt[eqvt]:\n  shows \"p \\<bullet> (f(x := y)) = (p \\<bullet> f)((p \\<bullet> x) := (p \\<bullet> y))\"", "lemma comp_eqvt [eqvt]:\n  shows \"p \\<bullet> (f \\<circ> g) = (p \\<bullet> f) \\<circ> (p \\<bullet> g)\"", "lemma fst_eqvt [eqvt]:\n  shows \"p \\<bullet> (fst x) = fst (p \\<bullet> x)\"", "lemma snd_eqvt [eqvt]:\n  shows \"p \\<bullet> (snd x) = snd (p \\<bullet> x)\"", "lemma split_eqvt [eqvt]:\n  shows \"p \\<bullet> (case_prod P x) = case_prod (p \\<bullet> P) (p \\<bullet> x)\"", "lemma append_eqvt [eqvt]:\n  shows \"p \\<bullet> (xs @ ys) = (p \\<bullet> xs) @ (p \\<bullet> ys)\"", "lemma rev_eqvt [eqvt]:\n  shows \"p \\<bullet> (rev xs) = rev (p \\<bullet> xs)\"", "lemma map_eqvt [eqvt]:\n  shows \"p \\<bullet> (map f xs) = map (p \\<bullet> f) (p \\<bullet> xs)\"", "lemma removeAll_eqvt [eqvt]:\n  shows \"p \\<bullet> (removeAll x xs) = removeAll (p \\<bullet> x) (p \\<bullet> xs)\"", "lemma filter_eqvt [eqvt]:\n  shows \"p \\<bullet> (filter f xs) = filter (p \\<bullet> f) (p \\<bullet> xs)\"", "lemma distinct_eqvt [eqvt]:\n  shows \"p \\<bullet> (distinct xs) = distinct (p \\<bullet> xs)\"", "lemma length_eqvt [eqvt]:\n  shows \"p \\<bullet> (length xs) = length (p \\<bullet> xs)\"", "lemma map_option_eqvt[eqvt]:\n  shows \"p \\<bullet> (map_option f x) = map_option (p \\<bullet> f) (p \\<bullet> x)\"", "lemma in_fset_eqvt [eqvt]:\n  shows \"(p \\<bullet> (x |\\<in>| S)) = ((p \\<bullet> x) |\\<in>| (p \\<bullet> S))\"", "lemma union_fset_eqvt [eqvt]:\n  shows \"(p \\<bullet> (S |\\<union>| T)) = ((p \\<bullet> S) |\\<union>| (p \\<bullet> T))\"", "lemma inter_fset_eqvt [eqvt]:\n  shows \"(p \\<bullet> (S |\\<inter>| T)) = ((p \\<bullet> S) |\\<inter>| (p \\<bullet> T))\"", "lemma subset_fset_eqvt [eqvt]:\n  shows \"(p \\<bullet> (S |\\<subseteq>| T)) = ((p \\<bullet> S) |\\<subseteq>| (p \\<bullet> T))\"", "lemma map_fset_eqvt [eqvt]:\n  shows \"p \\<bullet> (f |`| S) = (p \\<bullet> f) |`| (p \\<bullet> S)\"", "lemma finfun_update_eqvt [eqvt]:\n  shows \"(p \\<bullet> (finfun_update f a b)) = finfun_update (p \\<bullet> f) (p \\<bullet> a) (p \\<bullet> b)\"", "lemma finfun_const_eqvt [eqvt]:\n  shows \"(p \\<bullet> (finfun_const b)) = finfun_const (p \\<bullet> b)\"", "lemma finfun_apply_eqvt [eqvt]:\n  shows \"(p \\<bullet> (finfun_apply f b)) = finfun_apply (p \\<bullet> f) (p \\<bullet> b)\"", "lemma supp_conv_fresh:\n  shows \"supp x = {a. \\<not> a \\<sharp> x}\"", "lemma swap_rel_trans:\n  assumes \"sort_of a = sort_of b\"\n  assumes \"sort_of b = sort_of c\"\n  assumes \"(a \\<rightleftharpoons> c) \\<bullet> x = x\"\n  assumes \"(b \\<rightleftharpoons> c) \\<bullet> x = x\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> x = x\"", "lemma swap_fresh_fresh:\n  assumes a: \"a \\<sharp> x\"\n  and     b: \"b \\<sharp> x\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> x = x\"", "lemma supp_eqvt [eqvt]:\n  shows \"p \\<bullet> (supp x) = supp (p \\<bullet> x)\"", "lemma fresh_eqvt [eqvt]:\n  shows \"p \\<bullet> (a \\<sharp> x) = (p \\<bullet> a) \\<sharp> (p \\<bullet> x)\"", "lemma fresh_permute_iff:\n  shows \"(p \\<bullet> a) \\<sharp> (p \\<bullet> x) \\<longleftrightarrow> a \\<sharp> x\"", "lemma fresh_permute_left:\n  shows \"a \\<sharp> p \\<bullet> x \\<longleftrightarrow> - p \\<bullet> a \\<sharp> x\"", "lemma supp_is_subset:\n  fixes S :: \"atom set\"\n  and   x :: \"'a::pt\"\n  assumes a1: \"S supports x\"\n  and     a2: \"finite S\"\n  shows \"(supp x) \\<subseteq> S\"", "lemma supports_finite:\n  fixes S :: \"atom set\"\n  and   x :: \"'a::pt\"\n  assumes a1: \"S supports x\"\n  and     a2: \"finite S\"\n  shows \"finite (supp x)\"", "lemma supp_supports:\n  fixes x :: \"'a::pt\"\n  shows \"(supp x) supports x\"", "lemma supports_fresh:\n  fixes x :: \"'a::pt\"\n  assumes a1: \"S supports x\"\n  and     a2: \"finite S\"\n  and     a3: \"a \\<notin> S\"\n  shows \"a \\<sharp> x\"", "lemma supp_is_least_supports:\n  fixes S :: \"atom set\"\n  and   x :: \"'a::pt\"\n  assumes  a1: \"S supports x\"\n  and      a2: \"finite S\"\n  and      a3: \"\\<And>S'. finite S' \\<Longrightarrow> (S' supports x) \\<Longrightarrow> S \\<subseteq> S'\"\n  shows \"(supp x) = S\"", "lemma subsetCI:\n  shows \"(\\<And>x. x \\<in> A \\<Longrightarrow> x \\<notin> B \\<Longrightarrow> False) \\<Longrightarrow> A \\<subseteq> B\"", "lemma finite_supp_unique:\n  assumes a1: \"S supports x\"\n  assumes a2: \"finite S\"\n  assumes a3: \"\\<And>a b. \\<lbrakk>a \\<in> S; b \\<notin> S; sort_of a = sort_of b\\<rbrakk> \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x\"\n  shows \"(supp x) = S\"", "lemma pure_supp:\n  fixes x::\"'a::pure\"\n  shows \"supp x = {}\"", "lemma pure_fresh:\n  fixes x::\"'a::pure\"\n  shows \"a \\<sharp> x\"", "lemma supp_atom:\n  shows \"supp a = {a}\"", "lemma fresh_atom:\n  shows \"a \\<sharp> b \\<longleftrightarrow> a \\<noteq> b\"", "lemma perm_swap_eq:\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> p = p \\<longleftrightarrow> (p \\<bullet> (a \\<rightleftharpoons> b)) = (a \\<rightleftharpoons> b)\"", "lemma supports_perm:\n  shows \"{a. p \\<bullet> a \\<noteq> a} supports p\"", "lemma finite_perm_lemma:\n  shows \"finite {a::atom. p \\<bullet> a \\<noteq> a}\"", "lemma supp_perm:\n  shows \"supp p = {a. p \\<bullet> a \\<noteq> a}\"", "lemma fresh_perm:\n  shows \"a \\<sharp> p \\<longleftrightarrow> p \\<bullet> a = a\"", "lemma supp_swap:\n  shows \"supp (a \\<rightleftharpoons> b) = (if a = b \\<or> sort_of a \\<noteq> sort_of b then {} else {a, b})\"", "lemma fresh_swap:\n  shows \"a \\<sharp> (b \\<rightleftharpoons> c) \\<longleftrightarrow> (sort_of b \\<noteq> sort_of c) \\<or> b = c \\<or> (a \\<sharp> b \\<and> a \\<sharp> c)\"", "lemma fresh_zero_perm:\n  shows \"a \\<sharp> (0::perm)\"", "lemma supp_zero_perm:\n  shows \"supp (0::perm) = {}\"", "lemma fresh_plus_perm:\n  fixes p q::perm\n  assumes \"a \\<sharp> p\" \"a \\<sharp> q\"\n  shows \"a \\<sharp> (p + q)\"", "lemma supp_plus_perm:\n  fixes p q::perm\n  shows \"supp (p + q) \\<subseteq> supp p \\<union> supp q\"", "lemma fresh_minus_perm:\n  fixes p::perm\n  shows \"a \\<sharp> (- p) \\<longleftrightarrow> a \\<sharp> p\"", "lemma supp_minus_perm:\n  fixes p::perm\n  shows \"supp (- p) = supp p\"", "lemma plus_perm_eq:\n  fixes p q::\"perm\"\n  assumes asm: \"supp p \\<inter> supp q = {}\"\n  shows \"p + q = q + p\"", "lemma supp_plus_perm_eq:\n  fixes p q::perm\n  assumes asm: \"supp p \\<inter> supp q = {}\"\n  shows \"supp (p + q) = supp p \\<union> supp q\"", "lemma perm_eq_iff2:\n  fixes p q :: \"perm\"\n  shows \"p = q \\<longleftrightarrow> (\\<forall>a::atom \\<in> supp p \\<union> supp q. p \\<bullet> a = q \\<bullet> a)\"", "lemma supp_Pair:\n  shows \"supp (x, y) = supp x \\<union> supp y\"", "lemma fresh_Pair:\n  shows \"a \\<sharp> (x, y) \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> y\"", "lemma supp_Unit:\n  shows \"supp () = {}\"", "lemma fresh_Unit:\n  shows \"a \\<sharp> ()\"", "lemma supp_Inl:\n  shows \"supp (Inl x) = supp x\"", "lemma supp_Inr:\n  shows \"supp (Inr x) = supp x\"", "lemma fresh_Inl:\n  shows \"a \\<sharp> Inl x \\<longleftrightarrow> a \\<sharp> x\"", "lemma fresh_Inr:\n  shows \"a \\<sharp> Inr y \\<longleftrightarrow> a \\<sharp> y\"", "lemma supp_None:\n  shows \"supp None = {}\"", "lemma supp_Some:\n  shows \"supp (Some x) = supp x\"", "lemma fresh_None:\n  shows \"a \\<sharp> None\"", "lemma fresh_Some:\n  shows \"a \\<sharp> Some x \\<longleftrightarrow> a \\<sharp> x\"", "lemma supp_Nil:\n  shows \"supp [] = {}\"", "lemma fresh_Nil:\n  shows \"a \\<sharp> []\"", "lemma supp_Cons:\n  shows \"supp (x # xs) = supp x \\<union> supp xs\"", "lemma fresh_Cons:\n  shows \"a \\<sharp> (x # xs) \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> xs\"", "lemma supp_append:\n  shows \"supp (xs @ ys) = supp xs \\<union> supp ys\"", "lemma fresh_append:\n  shows \"a \\<sharp> (xs @ ys) \\<longleftrightarrow> a \\<sharp> xs \\<and> a \\<sharp> ys\"", "lemma supp_rev:\n  shows \"supp (rev xs) = supp xs\"", "lemma fresh_rev:\n  shows \"a \\<sharp> rev xs \\<longleftrightarrow> a \\<sharp> xs\"", "lemma supp_removeAll:\n  fixes x::\"atom\"\n  shows \"supp (removeAll x xs) = supp xs - {x}\"", "lemma supp_of_atom_list:\n  fixes as::\"atom list\"\n  shows \"supp as = set as\"", "lemma fresh_conv_MOST:\n  shows \"a \\<sharp> x \\<longleftrightarrow> (MOST b. (a \\<rightleftharpoons> b) \\<bullet> x = x)\"", "lemma fresh_fun_app:\n  assumes \"a \\<sharp> f\" and \"a \\<sharp> x\"\n  shows \"a \\<sharp> f x\"", "lemma supp_fun_app:\n  shows \"supp (f x) \\<subseteq> (supp f) \\<union> (supp x)\"", "lemma eqvt_boolI:\n  fixes f::\"bool\"\n  shows \"eqvt f\"", "lemma eqvtI:\n  shows \"(\\<And>p. p \\<bullet> f \\<equiv> f) \\<Longrightarrow> eqvt f\"", "lemma eqvt_at_perm:\n  assumes \"eqvt_at f x\"\n  shows \"eqvt_at f (q \\<bullet> x)\"", "lemma supp_fun_eqvt:\n  assumes a: \"eqvt f\"\n  shows \"supp f = {}\"", "lemma fresh_fun_eqvt:\n  assumes a: \"eqvt f\"\n  shows \"a \\<sharp> f\"", "lemma fresh_fun_eqvt_app:\n  assumes a: \"eqvt f\"\n  shows \"a \\<sharp> x \\<Longrightarrow> a \\<sharp> f x\"", "lemma supp_fun_app_eqvt:\n  assumes a: \"eqvt f\"\n  shows \"supp (f x) \\<subseteq> supp x\"", "lemma supp_eqvt_at:\n  assumes asm: \"eqvt_at f x\"\n  and     fin: \"finite (supp x)\"\n  shows \"supp (f x) \\<subseteq> supp x\"", "lemma finite_supp_eqvt_at:\n  assumes asm: \"eqvt_at f x\"\n  and     fin: \"finite (supp x)\"\n  shows \"finite (supp (f x))\"", "lemma fresh_eqvt_at:\n  assumes asm: \"eqvt_at f x\"\n  and     fin: \"finite (supp x)\"\n  and     fresh: \"a \\<sharp> x\"\n  shows \"a \\<sharp> f x\"", "lemma THE_defaultI2:\n  assumes \"\\<exists>!x. P x\" \"\\<And>x. P x \\<Longrightarrow> Q x\"\n  shows \"Q (THE_default d P)\"", "lemma the_default_eqvt:\n  assumes unique: \"\\<exists>!x. P x\"\n  shows \"(p \\<bullet> (THE_default d P)) = (THE_default (p \\<bullet> d) (p \\<bullet> P))\"", "lemma fundef_ex1_eqvt:\n  fixes x::\"'a::pt\"\n  assumes f_def: \"f == (\\<lambda>x::'a. THE_default (d x) (G x))\"\n  assumes eqvt: \"eqvt G\"\n  assumes ex1: \"\\<exists>!y. G x y\"\n  shows \"(p \\<bullet> (f x)) = f (p \\<bullet> x)\"", "lemma fundef_ex1_eqvt_at:\n  fixes x::\"'a::pt\"\n  assumes f_def: \"f == (\\<lambda>x::'a. THE_default (d x) (G x))\"\n  assumes eqvt: \"eqvt G\"\n  assumes ex1: \"\\<exists>!y. G x y\"\n  shows \"eqvt_at f x\"", "lemma fundef_ex1_prop:\n  fixes x::\"'a::pt\"\n  assumes f_def: \"f == (\\<lambda>x::'a. THE_default (d x) (G x))\"\n  assumes P_all: \"\\<And>x y. G x y \\<Longrightarrow> P x y\"\n  assumes ex1: \"\\<exists>!y. G x y\"\n  shows \"P x (f x)\"", "lemma supp_finite_atom_set:\n  fixes S::\"atom set\"\n  assumes \"finite S\"\n  shows \"supp S = S\"", "lemma supp_cofinite_atom_set:\n  fixes S::\"atom set\"\n  assumes \"finite (UNIV - S)\"\n  shows \"supp S = (UNIV - S)\"", "lemma fresh_finite_atom_set:\n  fixes S::\"atom set\"\n  assumes \"finite S\"\n  shows \"a \\<sharp> S \\<longleftrightarrow> a \\<notin> S\"", "lemma fresh_minus_atom_set:\n  fixes S::\"atom set\"\n  assumes \"finite S\"\n  shows \"a \\<sharp> S - T \\<longleftrightarrow> (a \\<notin> T \\<longrightarrow> a \\<sharp> S)\"", "lemma Union_supports_set:\n  shows \"(\\<Union>x \\<in> S. supp x) supports S\"", "lemma Union_of_finite_supp_sets:\n  fixes S::\"('a::fs set)\"\n  assumes fin: \"finite S\"\n  shows \"finite (\\<Union>x\\<in>S. supp x)\"", "lemma Union_included_in_supp:\n  fixes S::\"('a::fs set)\"\n  assumes fin: \"finite S\"\n  shows \"(\\<Union>x\\<in>S. supp x) \\<subseteq> supp S\"", "lemma supp_of_finite_sets:\n  fixes S::\"('a::fs set)\"\n  assumes fin: \"finite S\"\n  shows \"(supp S) = (\\<Union>x\\<in>S. supp x)\"", "lemma finite_sets_supp:\n  fixes S::\"('a::fs set)\"\n  assumes \"finite S\"\n  shows \"finite (supp S)\"", "lemma supp_of_finite_union:\n  fixes S T::\"('a::fs) set\"\n  assumes fin1: \"finite S\"\n  and     fin2: \"finite T\"\n  shows \"supp (S \\<union> T) = supp S \\<union> supp T\"", "lemma fresh_finite_union:\n  fixes S T::\"('a::fs) set\"\n  assumes fin1: \"finite S\"\n  and     fin2: \"finite T\"\n  shows \"a \\<sharp> (S \\<union> T) \\<longleftrightarrow> a \\<sharp> S \\<and> a \\<sharp> T\"", "lemma supp_of_finite_insert:\n  fixes S::\"('a::fs) set\"\n  assumes fin:  \"finite S\"\n  shows \"supp (insert x S) = supp x \\<union> supp S\"", "lemma fresh_finite_insert:\n  fixes S::\"('a::fs) set\"\n  assumes fin:  \"finite S\"\n  shows \"a \\<sharp> (insert x S) \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> S\"", "lemma supp_set_empty:\n  shows \"supp {} = {}\"", "lemma fresh_set_empty:\n  shows \"a \\<sharp> {}\"", "lemma supp_set:\n  fixes xs :: \"('a::fs) list\"\n  shows \"supp (set xs) = supp xs\"", "lemma fresh_set:\n  fixes xs :: \"('a::fs) list\"\n  shows \"a \\<sharp> (set xs) \\<longleftrightarrow> a \\<sharp> xs\"", "lemma set_mset_eqvt [eqvt]:\n  shows \"p \\<bullet> (set_mset M) = set_mset (p \\<bullet> M)\"", "lemma supp_set_mset:\n  shows \"supp (set_mset M) \\<subseteq> supp M\"", "lemma Union_finite_multiset:\n  fixes M::\"'a::fs multiset\"\n  shows \"finite (\\<Union>{supp x | x. x \\<in># M})\"", "lemma Union_supports_multiset:\n  shows \"\\<Union>{supp x | x. x \\<in># M} supports M\"", "lemma Union_included_multiset:\n  fixes M::\"('a::fs multiset)\"\n  shows \"(\\<Union>{supp x | x. x \\<in># M}) \\<subseteq> supp M\"", "lemma supp_of_multisets:\n  fixes M::\"('a::fs multiset)\"\n  shows \"(supp M) = (\\<Union>{supp x | x. x \\<in># M})\"", "lemma multisets_supp_finite:\n  fixes M::\"('a::fs multiset)\"\n  shows \"finite (supp M)\"", "lemma supp_of_multiset_union:\n  fixes M N::\"('a::fs) multiset\"\n  shows \"supp (M + N) = supp M \\<union> supp N\"", "lemma supp_empty_mset [simp]:\n  shows \"supp {#} = {}\"", "lemma supp_fset [simp]:\n  shows \"supp (fset S) = supp S\"", "lemma supp_empty_fset [simp]:\n  shows \"supp {||} = {}\"", "lemma fresh_empty_fset:\n  shows \"a \\<sharp> {||}\"", "lemma supp_finsert [simp]:\n  fixes x::\"'a::fs\"\n  and   S::\"'a fset\"\n  shows \"supp (finsert x S) = supp x \\<union> supp S\"", "lemma fresh_finsert:\n  fixes x::\"'a::fs\"\n  and   S::\"'a fset\"\n  shows \"a \\<sharp> finsert x S \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> S\"", "lemma fset_finite_supp:\n  fixes S::\"('a::fs) fset\"\n  shows \"finite (supp S)\"", "lemma supp_union_fset:\n  fixes S T::\"'a::fs fset\"\n  shows \"supp (S |\\<union>| T) = supp S \\<union> supp T\"", "lemma fresh_union_fset:\n  fixes S T::\"'a::fs fset\"\n  shows \"a \\<sharp> S |\\<union>| T \\<longleftrightarrow> a \\<sharp> S \\<and> a \\<sharp> T\"", "lemma fresh_finfun_const:\n  shows \"a \\<sharp> (finfun_const b) \\<longleftrightarrow> a \\<sharp> b\"", "lemma fresh_finfun_update:\n  shows \"\\<lbrakk>a \\<sharp> f; a \\<sharp> x; a \\<sharp> y\\<rbrakk> \\<Longrightarrow> a \\<sharp> finfun_update f x y\"", "lemma supp_finfun_const:\n  shows \"supp (finfun_const b) = supp(b)\"", "lemma supp_finfun_update:\n  shows \"supp (finfun_update f x y) \\<subseteq> supp(f, x, y)\"", "lemma fresh_Unit_elim:\n  shows \"(a \\<sharp> () \\<Longrightarrow> PROP C) \\<equiv> PROP C\"", "lemma fresh_Pair_elim:\n  shows \"(a \\<sharp> (x, y) \\<Longrightarrow> PROP C) \\<equiv> (a \\<sharp> x \\<Longrightarrow> a \\<sharp> y \\<Longrightarrow> PROP C)\"", "lemma [simp]:\n  shows \"a \\<sharp> x1 \\<Longrightarrow> a \\<sharp> x2 \\<Longrightarrow> a \\<sharp> (x1, x2)\"", "lemma fresh_PairD:\n  shows \"a \\<sharp> (x, y) \\<Longrightarrow> a \\<sharp> x\"\n  and   \"a \\<sharp> (x, y) \\<Longrightarrow> a \\<sharp> y\"", "lemma fresh_star_supp_conv:\n  shows \"supp x \\<sharp>* y \\<Longrightarrow> supp y \\<sharp>* x\"", "lemma fresh_star_perm_set_conv:\n  fixes p::\"perm\"\n  assumes fresh: \"as \\<sharp>* p\"\n  and     fin: \"finite as\"\n  shows \"supp p \\<sharp>* as\"", "lemma fresh_star_atom_set_conv:\n  assumes fresh: \"as \\<sharp>* bs\"\n  and     fin: \"finite as\" \"finite bs\"\n  shows \"bs \\<sharp>* as\"", "lemma atom_fresh_star_disjoint:\n  assumes fin: \"finite bs\"\n  shows \"as \\<sharp>* bs \\<longleftrightarrow> (as \\<inter> bs = {})\"", "lemma fresh_star_Pair:\n  shows \"as \\<sharp>* (x, y) = (as \\<sharp>* x \\<and> as \\<sharp>* y)\"", "lemma fresh_star_list:\n  shows \"as \\<sharp>* (xs @ ys) \\<longleftrightarrow> as \\<sharp>* xs \\<and> as \\<sharp>* ys\"\n  and   \"as \\<sharp>* (x # xs) \\<longleftrightarrow> as \\<sharp>* x \\<and> as \\<sharp>* xs\"\n  and   \"as \\<sharp>* []\"", "lemma fresh_star_set:\n  fixes xs::\"('a::fs) list\"\n  shows \"as \\<sharp>* set xs \\<longleftrightarrow> as \\<sharp>* xs\"", "lemma fresh_star_singleton:\n  fixes a::\"atom\"\n  shows \"as \\<sharp>* {a} \\<longleftrightarrow> as \\<sharp>* a\"", "lemma fresh_star_fset:\n  fixes xs::\"('a::fs) list\"\n  shows \"as \\<sharp>* fset S \\<longleftrightarrow> as \\<sharp>* S\"", "lemma fresh_star_Un:\n  shows \"(as \\<union> bs) \\<sharp>* x = (as \\<sharp>* x \\<and> bs \\<sharp>* x)\"", "lemma fresh_star_insert:\n  shows \"(insert a as) \\<sharp>* x = (a \\<sharp> x \\<and> as \\<sharp>* x)\"", "lemma fresh_star_Un_elim:\n  \"((as \\<union> bs) \\<sharp>* x \\<Longrightarrow> PROP C) \\<equiv> (as \\<sharp>* x \\<Longrightarrow> bs \\<sharp>* x \\<Longrightarrow> PROP C)\"", "lemma fresh_star_insert_elim:\n  \"(insert a as \\<sharp>* x \\<Longrightarrow> PROP C) \\<equiv> (a \\<sharp> x \\<Longrightarrow> as \\<sharp>* x \\<Longrightarrow> PROP C)\"", "lemma fresh_star_empty_elim:\n  \"({} \\<sharp>* x \\<Longrightarrow> PROP C) \\<equiv> PROP C\"", "lemma fresh_star_Unit_elim:\n  shows \"(a \\<sharp>* () \\<Longrightarrow> PROP C) \\<equiv> PROP C\"", "lemma fresh_star_Pair_elim:\n  shows \"(a \\<sharp>* (x, y) \\<Longrightarrow> PROP C) \\<equiv> (a \\<sharp>* x \\<Longrightarrow> a \\<sharp>* y \\<Longrightarrow> PROP C)\"", "lemma fresh_star_zero:\n  shows \"as \\<sharp>* (0::perm)\"", "lemma fresh_star_plus:\n  fixes p q::perm\n  shows \"\\<lbrakk>a \\<sharp>* p;  a \\<sharp>* q\\<rbrakk> \\<Longrightarrow> a \\<sharp>* (p + q)\"", "lemma fresh_star_permute_iff:\n  shows \"(p \\<bullet> a) \\<sharp>* (p \\<bullet> x) \\<longleftrightarrow> a \\<sharp>* x\"", "lemma fresh_star_eqvt [eqvt]:\n  shows \"p \\<bullet> (as \\<sharp>* x) \\<longleftrightarrow> (p \\<bullet> as) \\<sharp>* (p \\<bullet> x)\"", "lemma smaller_supp:\n  assumes a: \"a \\<in> supp p\"\n  shows \"supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p\"", "lemma perm_struct_induct[consumes 1, case_names zero swap]:\n  assumes S: \"supp p \\<subseteq> S\"\n  and zero: \"P 0\"\n  and swap: \"\\<And>p a b. \\<lbrakk>P p; supp p \\<subseteq> S; a \\<in> S; b \\<in> S; a \\<noteq> b; sort_of a = sort_of b\\<rbrakk> \\<Longrightarrow> P ((a \\<rightleftharpoons> b) + p)\"\n  shows \"P p\"", "lemma perm_simple_struct_induct[case_names zero swap]:\n  assumes zero: \"P 0\"\n  and     swap: \"\\<And>p a b. \\<lbrakk>P p; a \\<noteq> b; sort_of a = sort_of b\\<rbrakk> \\<Longrightarrow> P ((a \\<rightleftharpoons> b) + p)\"\n  shows \"P p\"", "lemma perm_struct_induct2[consumes 1, case_names zero swap plus]:\n  assumes S: \"supp p \\<subseteq> S\"\n  assumes zero: \"P 0\"\n  assumes swap: \"\\<And>a b. \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b; a \\<in> S; b \\<in> S\\<rbrakk> \\<Longrightarrow> P (a \\<rightleftharpoons> b)\"\n  assumes plus: \"\\<And>p1 p2. \\<lbrakk>P p1; P p2; supp p1 \\<subseteq> S; supp p2 \\<subseteq> S\\<rbrakk> \\<Longrightarrow> P (p1 + p2)\"\n  shows \"P p\"", "lemma perm_simple_struct_induct2[case_names zero swap plus]:\n  assumes zero: \"P 0\"\n  assumes swap: \"\\<And>a b. \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b\\<rbrakk> \\<Longrightarrow> P (a \\<rightleftharpoons> b)\"\n  assumes plus: \"\\<And>p1 p2. \\<lbrakk>P p1; P p2\\<rbrakk> \\<Longrightarrow> P (p1 + p2)\"\n  shows \"P p\"", "lemma supp_perm_singleton:\n  fixes p::\"perm\"\n  shows \"supp p \\<subseteq> {b} \\<longleftrightarrow> p = 0\"", "lemma supp_perm_pair:\n  fixes p::\"perm\"\n  shows \"supp p \\<subseteq> {a, b} \\<longleftrightarrow> p = 0 \\<or> p = (b \\<rightleftharpoons> a)\"", "lemma supp_perm_eq:\n  assumes \"(supp x) \\<sharp>* p\"\n  shows \"p \\<bullet> x = x\"", "lemma supp_perm_eq_test:\n  assumes \"(supp x) \\<sharp>* p\"\n  shows \"p \\<bullet> x = x\"", "lemma perm_supp_eq:\n  assumes a: \"(supp p) \\<sharp>* x\"\n  shows \"p \\<bullet> x = x\"", "lemma supp_perm_perm_eq:\n  assumes a: \"\\<forall>a \\<in> supp x. p \\<bullet> a = q \\<bullet> a\"\n  shows \"p \\<bullet> x = q \\<bullet> x\"", "lemma ds_fresh:\n  assumes \"dset p q \\<sharp>* x\"\n  shows \"p \\<bullet> x = q \\<bullet> x\"", "lemma atom_set_perm_eq:\n  assumes a: \"as \\<sharp>* p\"\n  shows \"p \\<bullet> as = as\"", "lemma at_set_avoiding_aux:\n  fixes Xs::\"atom set\"\n  and   As::\"atom set\"\n  assumes b: \"Xs \\<subseteq> As\"\n  and     c: \"finite As\"\n  shows \"\\<exists>p. (p \\<bullet> Xs) \\<inter> As = {} \\<and> (supp p) = (Xs \\<union> (p \\<bullet> Xs))\"", "lemma at_set_avoiding:\n  assumes a: \"finite Xs\"\n  and     b: \"finite (supp c)\"\n  obtains p::\"perm\" where \"(p \\<bullet> Xs)\\<sharp>*c\" and \"(supp p) = (Xs \\<union> (p \\<bullet> Xs))\"", "lemma at_set_avoiding1:\n  assumes \"finite xs\"\n  and     \"finite (supp c)\"\n  shows \"\\<exists>p. (p \\<bullet> xs) \\<sharp>* c\"", "lemma at_set_avoiding2:\n  assumes \"finite xs\"\n  and     \"finite (supp c)\" \"finite (supp x)\"\n  and     \"xs \\<sharp>* x\"\n  shows \"\\<exists>p. (p \\<bullet> xs) \\<sharp>* c \\<and> supp x \\<sharp>* p\"", "lemma at_set_avoiding3:\n  assumes \"finite xs\"\n  and     \"finite (supp c)\" \"finite (supp x)\"\n  and     \"xs \\<sharp>* x\"\n  shows \"\\<exists>p. (p \\<bullet> xs) \\<sharp>* c \\<and> supp x \\<sharp>* p \\<and> supp p = xs \\<union> (p \\<bullet> xs)\"", "lemma at_set_avoiding2_atom:\n  assumes \"finite (supp c)\" \"finite (supp x)\"\n  and     b: \"a \\<sharp> x\"\n  shows \"\\<exists>p. (p \\<bullet> a) \\<sharp> c \\<and> supp x \\<sharp>* p\"", "lemma set_renaming_perm:\n  assumes b: \"finite bs\"\n  shows \"\\<exists>q. (\\<forall>b \\<in> bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> bs \\<union> (p \\<bullet> bs)\"", "lemma set_renaming_perm2:\n  shows \"\\<exists>q. (\\<forall>b \\<in> bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> bs \\<union> (p \\<bullet> bs)\"", "lemma list_renaming_perm:\n  shows \"\\<exists>q. (\\<forall>b \\<in> set bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> set bs \\<union> (p \\<bullet> set bs)\"", "lemma sort_ineq [simp]:\n  assumes \"sort_of (atom a) \\<noteq> sort_of (atom b)\"\n  shows \"atom a \\<noteq> atom b\"", "lemma supp_at_base:\n  fixes a::\"'a::at_base\"\n  shows \"supp a = {atom a}\"", "lemma fresh_at_base:\n  shows  \"sort_of a \\<noteq> sort_of (atom b) \\<Longrightarrow> a \\<sharp> b\"\n  and \"a \\<sharp> b \\<longleftrightarrow> a \\<noteq> atom b\"", "lemma fresh_ineq_at_base [simp]:\n  shows \"a \\<noteq> atom b \\<Longrightarrow> a \\<sharp> b\"", "lemma fresh_atom_at_base [simp]:\n  fixes b::\"'a::at_base\"\n  shows \"a \\<sharp> atom b \\<longleftrightarrow> a \\<sharp> b\"", "lemma fresh_star_atom_at_base:\n  fixes b::\"'a::at_base\"\n  shows \"as \\<sharp>* atom b \\<longleftrightarrow> as \\<sharp>* b\"", "lemma if_fresh_at_base [simp]:\n  shows \"atom a \\<sharp> x \\<Longrightarrow> P (if a = x then t else s) = P s\"\n  and   \"atom a \\<sharp> x \\<Longrightarrow> P (if x = a then t else s) = P s\"", "lemma at_base_infinite [simp]:\n  shows \"infinite (UNIV :: 'a::at_base set)\" (is \"infinite ?U\")", "lemma swap_at_base_simps [simp]:\n  fixes x y::\"'a::at_base\"\n  shows \"sort_of (atom x) = sort_of (atom y) \\<Longrightarrow> (atom x \\<rightleftharpoons> atom y) \\<bullet> x = y\"\n  and   \"sort_of (atom x) = sort_of (atom y) \\<Longrightarrow> (atom x \\<rightleftharpoons> atom y) \\<bullet> y = x\"\n  and   \"atom x \\<noteq> a \\<Longrightarrow> atom x \\<noteq> b \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\"", "lemma obtain_at_base:\n  assumes X: \"finite X\"\n  obtains a::\"'a::at_base\" where \"atom a \\<notin> X\"", "lemma obtain_fresh':\n  assumes fin: \"finite (supp x)\"\n  obtains a::\"'a::at_base\" where \"atom a \\<sharp> x\"", "lemma obtain_fresh:\n  fixes x::\"'b::fs\"\n  obtains a::\"'a::at_base\" where \"atom a \\<sharp> x\"", "lemma supp_finite_set_at_base:\n  assumes a: \"finite S\"\n  shows \"supp S = atom ` S\"", "lemma fresh_finite_set_at_base:\n  fixes a::\"'a::at_base\"\n  assumes a: \"finite S\"\n  shows \"atom a \\<sharp> S \\<longleftrightarrow> a \\<notin> S\"", "lemma fresh_at_base_permute_iff [simp]:\n  fixes a::\"'a::at_base\"\n  shows \"atom (p \\<bullet> a) \\<sharp> p \\<bullet> x \\<longleftrightarrow> atom a \\<sharp> x\"", "lemma fresh_at_base_permI:\n  shows \"atom a \\<sharp> p \\<Longrightarrow> p \\<bullet> a = a\"", "lemma flip_fresh_fresh:\n  assumes \"atom a \\<sharp> x\" \"atom b \\<sharp> x\"\n  shows \"(a \\<leftrightarrow> b) \\<bullet> x = x\"", "lemma flip_self [simp]: \"(a \\<leftrightarrow> a) = 0\"", "lemma flip_commute: \"(a \\<leftrightarrow> b) = (b \\<leftrightarrow> a)\"", "lemma minus_flip [simp]: \"- (a \\<leftrightarrow> b) = (a \\<leftrightarrow> b)\"", "lemma add_flip_cancel: \"(a \\<leftrightarrow> b) + (a \\<leftrightarrow> b) = 0\"", "lemma permute_flip_cancel [simp]: \"(a \\<leftrightarrow> b) \\<bullet> (a \\<leftrightarrow> b) \\<bullet> x = x\"", "lemma permute_flip_cancel2 [simp]: \"(a \\<leftrightarrow> b) \\<bullet> (b \\<leftrightarrow> a) \\<bullet> x = x\"", "lemma flip_eqvt [eqvt]:\n  shows \"p \\<bullet> (a \\<leftrightarrow> b) = (p \\<bullet> a \\<leftrightarrow> p \\<bullet> b)\"", "lemma flip_at_base_simps [simp]:\n  shows \"sort_of (atom a) = sort_of (atom b) \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> a = b\"\n  and   \"sort_of (atom a) = sort_of (atom b) \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> b = a\"\n  and   \"\\<lbrakk>a \\<noteq> c; b \\<noteq> c\\<rbrakk> \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> c = c\"\n  and   \"sort_of (atom a) \\<noteq> sort_of (atom b) \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> x = x\"", "lemma flip_triple:\n  fixes a b c::\"'a::at\"\n  assumes \"a \\<noteq> b\" and \"c \\<noteq> b\"\n  shows \"(a \\<leftrightarrow> c) + (b \\<leftrightarrow> c) + (a \\<leftrightarrow> c) = (a \\<leftrightarrow> b)\"", "lemma permute_flip_at:\n  fixes a b c::\"'a::at\"\n  shows \"(a \\<leftrightarrow> b) \\<bullet> c = (if c = a then b else if c = b then a else c)\"", "lemma flip_at_simps [simp]:\n  fixes a b::\"'a::at\"\n  shows \"(a \\<leftrightarrow> b) \\<bullet> a = b\"\n  and   \"(a \\<leftrightarrow> b) \\<bullet> b = a\"", "lemma exists_eq_simple_sort:\n  shows \"\\<exists>a. a \\<in> {a. sort_of a = s}\"", "lemma exists_eq_sort:\n  shows \"\\<exists>a. a \\<in> {a. sort_of a \\<in> range sort_fun}\"", "lemma at_base_class:\n  fixes sort_fun :: \"'b \\<Rightarrow> atom_sort\"\n  fixes Rep :: \"'a \\<Rightarrow> atom\" and Abs :: \"atom \\<Rightarrow> 'a\"\n  assumes type: \"type_definition Rep Abs {a. sort_of a \\<in> range sort_fun}\"\n  assumes atom_def: \"\\<And>a. atom a = Rep a\"\n  assumes permute_def: \"\\<And>p a. p \\<bullet> a = Abs (p \\<bullet> Rep a)\"\n  shows \"OFCLASS('a, at_base_class)\"", "lemma at_class:\n  fixes s :: atom_sort\n  fixes Rep :: \"'a \\<Rightarrow> atom\" and Abs :: \"atom \\<Rightarrow> 'a\"\n  assumes type: \"type_definition Rep Abs {a. sort_of a = s}\"\n  assumes atom_def: \"\\<And>a. atom a = Rep a\"\n  assumes permute_def: \"\\<And>p a. p \\<bullet> a = Abs (p \\<bullet> Rep a)\"\n  shows \"OFCLASS('a, at_class)\"", "lemma at_class_sort:\n  fixes s :: atom_sort\n  fixes Rep :: \"'a \\<Rightarrow> atom\" and Abs :: \"atom \\<Rightarrow> 'a\"\n  fixes a::\"'a\"\n  assumes type: \"type_definition Rep Abs {a. sort_of a = s}\"\n  assumes atom_def: \"\\<And>a. atom a = Rep a\"\n  shows \"sort_of (atom a) = s\"", "lemma freshness_lemma:\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"\\<exists>a. atom a \\<sharp> (h, h a)\"\n  shows  \"\\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\"", "lemma freshness_lemma_unique:\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"\\<exists>a. atom a \\<sharp> (h, h a)\"\n  shows \"\\<exists>!x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\"", "lemma Fresh_apply:\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"\\<exists>a. atom a \\<sharp> (h, h a)\"\n  assumes b: \"atom a \\<sharp> h\"\n  shows \"Fresh h = h a\"", "lemma Fresh_apply':\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"atom a \\<sharp> h\" \"atom a \\<sharp> h a\"\n  shows \"Fresh h = h a\"", "lemma Fresh_eqvt:\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"\\<exists>a. atom a \\<sharp> (h, h a)\"\n  shows \"p \\<bullet> (Fresh h) = Fresh (p \\<bullet> h)\"", "lemma Fresh_supports:\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"\\<exists>a. atom a \\<sharp> (h, h a)\"\n  shows \"(supp h) supports (Fresh h)\"", "lemma FRESH_f_iff:\n  fixes P :: \"'a::at \\<Rightarrow> 'b::pure\"\n  fixes f :: \"'b \\<Rightarrow> 'c::pure\"\n  assumes P: \"finite (supp P)\"\n  shows \"(FRESH x. f (P x)) = f (FRESH x. P x)\"", "lemma FRESH_binop_iff:\n  fixes P :: \"'a::at \\<Rightarrow> 'b::pure\"\n  fixes Q :: \"'a::at \\<Rightarrow> 'c::pure\"\n  fixes binop :: \"'b \\<Rightarrow> 'c \\<Rightarrow> 'd::pure\"\n  assumes P: \"finite (supp P)\"\n  and     Q: \"finite (supp Q)\"\n  shows \"(FRESH x. binop (P x) (Q x)) = binop (FRESH x. P x) (FRESH x. Q x)\"", "lemma FRESH_conj_iff:\n  fixes P Q :: \"'a::at \\<Rightarrow> bool\"\n  assumes P: \"finite (supp P)\" and Q: \"finite (supp Q)\"\n  shows \"(FRESH x. P x \\<and> Q x) \\<longleftrightarrow> (FRESH x. P x) \\<and> (FRESH x. Q x)\"", "lemma FRESH_disj_iff:\n  fixes P Q :: \"'a::at \\<Rightarrow> bool\"\n  assumes P: \"finite (supp P)\" and Q: \"finite (supp Q)\"\n  shows \"(FRESH x. P x \\<or> Q x) \\<longleftrightarrow> (FRESH x. P x) \\<or> (FRESH x. Q x)\""], "translations": [["", "lemma INFM_sort_of_eq:\n  shows \"INFM a. sort_of a = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>a. sort_of a = s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>a. sort_of a = s", "have \"INFM i. sort_of (Atom s i) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>i. sort_of (Atom s i) = s", "by simp"], ["proof (state)\nthis:\n  \\<exists>\\<^sub>\\<infinity>i. sort_of (Atom s i) = s\n\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>a. sort_of a = s", "moreover"], ["proof (state)\nthis:\n  \\<exists>\\<^sub>\\<infinity>i. sort_of (Atom s i) = s\n\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>a. sort_of a = s", "have \"inj (Atom s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (Atom s)", "by (simp add: inj_on_def)"], ["proof (state)\nthis:\n  inj (Atom s)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>a. sort_of a = s", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>\\<^sub>\\<infinity>i. sort_of (Atom s i) = s\n  inj (Atom s)", "show \"INFM a. sort_of a = s\""], ["proof (prove)\nusing this:\n  \\<exists>\\<^sub>\\<infinity>i. sort_of (Atom s i) = s\n  inj (Atom s)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>a. sort_of a = s", "by (rule INFM_inj)"], ["proof (state)\nthis:\n  \\<exists>\\<^sub>\\<infinity>a. sort_of a = s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_sort_of_eq:\n  shows \"infinite {a. sort_of a = s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {a. sort_of a = s}", "using INFM_sort_of_eq"], ["proof (prove)\nusing this:\n  \\<exists>\\<^sub>\\<infinity>a. sort_of a = ?s\n\ngoal (1 subgoal):\n 1. infinite {a. sort_of a = s}", "unfolding INFM_iff_infinite"], ["proof (prove)\nusing this:\n  infinite {a. sort_of a = ?s}\n\ngoal (1 subgoal):\n 1. infinite {a. sort_of a = s}", "."], ["", "lemma atom_infinite [simp]:\n  shows \"infinite (UNIV :: atom set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "using subset_UNIV infinite_sort_of_eq"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> UNIV\n  infinite {a. sort_of a = ?s}\n\ngoal (1 subgoal):\n 1. infinite UNIV", "by (rule infinite_super)"], ["", "lemma obtain_atom:\n  fixes X :: \"atom set\"\n  assumes X: \"finite X\"\n  obtains a where \"a \\<notin> X\" \"sort_of a = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<notin> X; sort_of a = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<notin> X; sort_of a = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from X"], ["proof (chain)\npicking this:\n  finite X", "have \"MOST a. a \\<notin> X\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>a. a \\<notin> X", "unfolding MOST_iff_cofinite"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. finite {x. \\<not> x \\<notin> X}", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>\\<infinity>a. a \\<notin> X\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<notin> X; sort_of a = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with INFM_sort_of_eq"], ["proof (chain)\npicking this:\n  \\<exists>\\<^sub>\\<infinity>a. sort_of a = ?s\n  \\<forall>\\<^sub>\\<infinity>a. a \\<notin> X", "have \"INFM a. sort_of a = s \\<and> a \\<notin> X\""], ["proof (prove)\nusing this:\n  \\<exists>\\<^sub>\\<infinity>a. sort_of a = ?s\n  \\<forall>\\<^sub>\\<infinity>a. a \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>a. sort_of a = s \\<and> a \\<notin> X", "by (rule INFM_conjI)"], ["proof (state)\nthis:\n  \\<exists>\\<^sub>\\<infinity>a. sort_of a = s \\<and> a \\<notin> X\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<notin> X; sort_of a = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<^sub>\\<infinity>a. sort_of a = s \\<and> a \\<notin> X", "obtain a where \"a \\<notin> X\" \"sort_of a = s\""], ["proof (prove)\nusing this:\n  \\<exists>\\<^sub>\\<infinity>a. sort_of a = s \\<and> a \\<notin> X\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<notin> X; sort_of a = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: INFM_E)"], ["proof (state)\nthis:\n  a \\<notin> X\n  sort_of a = s\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<notin> X; sort_of a = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  a \\<notin> X\n  sort_of a = s", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<notin> X\n  sort_of a = s\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atom_components_eq_iff:\n  fixes a b :: atom\n  shows \"a = b \\<longleftrightarrow> sort_of a = sort_of b \\<and> nat_of a = nat_of b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a = b) = (sort_of a = sort_of b \\<and> nat_of a = nat_of b)", "by (induct a, induct b, simp)"], ["", "section \\<open>Sort-Respecting Permutations\\<close>"], ["", "definition\n  \"perm \\<equiv> {f. bij f \\<and> finite {a. f a \\<noteq> a} \\<and> (\\<forall>a. sort_of (f a) = sort_of a)}\""], ["", "typedef perm = \"perm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> perm", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> perm", "show \"id \\<in> perm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<in> perm", "unfolding perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<in> {f. bij f \\<and>\n                 finite {a. f a \\<noteq> a} \\<and>\n                 (\\<forall>a. sort_of (f a) = sort_of a)}", "by simp"], ["proof (state)\nthis:\n  id \\<in> perm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permI:\n  assumes \"bij f\" and \"MOST x. f x = x\" and \"\\<And>a. sort_of (f a) = sort_of a\"\n  shows \"f \\<in> perm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> perm", "using assms"], ["proof (prove)\nusing this:\n  bij f\n  \\<forall>\\<^sub>\\<infinity>x. f x = x\n  sort_of (f ?a) = sort_of ?a\n\ngoal (1 subgoal):\n 1. f \\<in> perm", "unfolding perm_def MOST_iff_cofinite"], ["proof (prove)\nusing this:\n  bij f\n  finite {x. f x \\<noteq> x}\n  sort_of (f ?a) = sort_of ?a\n\ngoal (1 subgoal):\n 1. f \\<in> {f. bij f \\<and>\n                finite {a. f a \\<noteq> a} \\<and>\n                (\\<forall>a. sort_of (f a) = sort_of a)}", "by simp"], ["", "lemma perm_is_bij: \"f \\<in> perm \\<Longrightarrow> bij f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> perm \\<Longrightarrow> bij f", "unfolding perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> {f. bij f \\<and>\n                finite {a. f a \\<noteq> a} \\<and>\n                (\\<forall>a. sort_of (f a) = sort_of a)} \\<Longrightarrow>\n    bij f", "by simp"], ["", "lemma perm_is_finite: \"f \\<in> perm \\<Longrightarrow> finite {a. f a \\<noteq> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> perm \\<Longrightarrow> finite {a. f a \\<noteq> a}", "unfolding perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> {f. bij f \\<and>\n                finite {a. f a \\<noteq> a} \\<and>\n                (\\<forall>a. sort_of (f a) = sort_of a)} \\<Longrightarrow>\n    finite {a. f a \\<noteq> a}", "by simp"], ["", "lemma perm_is_sort_respecting: \"f \\<in> perm \\<Longrightarrow> sort_of (f a) = sort_of a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> perm \\<Longrightarrow> sort_of (f a) = sort_of a", "unfolding perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> {f. bij f \\<and>\n                finite {a. f a \\<noteq> a} \\<and>\n                (\\<forall>a. sort_of (f a) = sort_of a)} \\<Longrightarrow>\n    sort_of (f a) = sort_of a", "by simp"], ["", "lemma perm_MOST: \"f \\<in> perm \\<Longrightarrow> MOST x. f x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> perm \\<Longrightarrow> \\<forall>\\<^sub>\\<infinity>x. f x = x", "unfolding perm_def MOST_iff_cofinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> {f. bij f \\<and>\n                finite {a. f a \\<noteq> a} \\<and>\n                (\\<forall>a. sort_of (f a) = sort_of a)} \\<Longrightarrow>\n    finite {x. f x \\<noteq> x}", "by simp"], ["", "lemma perm_id: \"id \\<in> perm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<in> perm", "unfolding perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<in> {f. bij f \\<and>\n                 finite {a. f a \\<noteq> a} \\<and>\n                 (\\<forall>a. sort_of (f a) = sort_of a)}", "by simp"], ["", "lemma perm_comp:\n  assumes f: \"f \\<in> perm\" and g: \"g \\<in> perm\"\n  shows \"(f \\<circ> g) \\<in> perm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> g \\<in> perm", "apply (rule permI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. bij (f \\<circ> g)\n 2. \\<forall>\\<^sub>\\<infinity>x. (f \\<circ> g) x = x\n 3. \\<And>a. sort_of ((f \\<circ> g) a) = sort_of a", "apply (rule bij_comp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. bij g\n 2. bij f\n 3. \\<forall>\\<^sub>\\<infinity>x. (f \\<circ> g) x = x\n 4. \\<And>a. sort_of ((f \\<circ> g) a) = sort_of a", "apply (rule perm_is_bij [OF g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. bij f\n 2. \\<forall>\\<^sub>\\<infinity>x. (f \\<circ> g) x = x\n 3. \\<And>a. sort_of ((f \\<circ> g) a) = sort_of a", "apply (rule perm_is_bij [OF f])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>\\<infinity>x. (f \\<circ> g) x = x\n 2. \\<And>a. sort_of ((f \\<circ> g) a) = sort_of a", "apply (rule MOST_rev_mp [OF perm_MOST [OF g]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>\\<infinity>x.\n       g x = x \\<longrightarrow> (f \\<circ> g) x = x\n 2. \\<And>a. sort_of ((f \\<circ> g) a) = sort_of a", "apply (rule MOST_rev_mp [OF perm_MOST [OF f]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>\\<infinity>x.\n       f x = x \\<longrightarrow>\n       g x = x \\<longrightarrow> (f \\<circ> g) x = x\n 2. \\<And>a. sort_of ((f \\<circ> g) a) = sort_of a", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. sort_of ((f \\<circ> g) a) = sort_of a", "apply (simp add: perm_is_sort_respecting [OF f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. sort_of (g a) = sort_of a", "apply (simp add: perm_is_sort_respecting [OF g])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma perm_inv:\n  assumes f: \"f \\<in> perm\"\n  shows \"(inv f) \\<in> perm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv f \\<in> perm", "apply (rule permI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. bij (inv f)\n 2. \\<forall>\\<^sub>\\<infinity>x. inv f x = x\n 3. \\<And>a. sort_of (inv f a) = sort_of a", "apply (rule bij_imp_bij_inv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. bij f\n 2. \\<forall>\\<^sub>\\<infinity>x. inv f x = x\n 3. \\<And>a. sort_of (inv f a) = sort_of a", "apply (rule perm_is_bij [OF f])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>\\<infinity>x. inv f x = x\n 2. \\<And>a. sort_of (inv f a) = sort_of a", "apply (rule MOST_mono [OF perm_MOST [OF f]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. f x = x \\<Longrightarrow> inv f x = x\n 2. \\<And>a. sort_of (inv f a) = sort_of a", "apply (erule subst, rule inv_f_f)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. inj f\n 2. \\<And>a. sort_of (inv f a) = sort_of a", "apply (rule bij_is_inj [OF perm_is_bij [OF f]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. sort_of (inv f a) = sort_of a", "apply (rule perm_is_sort_respecting [OF f, THEN sym, THEN trans])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. sort_of (f (inv f a)) = sort_of a", "apply (simp add: surj_f_inv_f [OF bij_is_surj [OF perm_is_bij [OF f]]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bij_Rep_perm: \"bij (Rep_perm p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (Rep_perm p)", "using Rep_perm [of p]"], ["proof (prove)\nusing this:\n  Rep_perm p \\<in> perm\n\ngoal (1 subgoal):\n 1. bij (Rep_perm p)", "unfolding perm_def"], ["proof (prove)\nusing this:\n  Rep_perm p\n  \\<in> {f. bij f \\<and>\n            finite {a. f a \\<noteq> a} \\<and>\n            (\\<forall>a. sort_of (f a) = sort_of a)}\n\ngoal (1 subgoal):\n 1. bij (Rep_perm p)", "by simp"], ["", "lemma finite_Rep_perm: \"finite {a. Rep_perm p a \\<noteq> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a. Rep_perm p a \\<noteq> a}", "using Rep_perm [of p]"], ["proof (prove)\nusing this:\n  Rep_perm p \\<in> perm\n\ngoal (1 subgoal):\n 1. finite {a. Rep_perm p a \\<noteq> a}", "unfolding perm_def"], ["proof (prove)\nusing this:\n  Rep_perm p\n  \\<in> {f. bij f \\<and>\n            finite {a. f a \\<noteq> a} \\<and>\n            (\\<forall>a. sort_of (f a) = sort_of a)}\n\ngoal (1 subgoal):\n 1. finite {a. Rep_perm p a \\<noteq> a}", "by simp"], ["", "lemma sort_of_Rep_perm: \"sort_of (Rep_perm p a) = sort_of a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of (Rep_perm p a) = sort_of a", "using Rep_perm [of p]"], ["proof (prove)\nusing this:\n  Rep_perm p \\<in> perm\n\ngoal (1 subgoal):\n 1. sort_of (Rep_perm p a) = sort_of a", "unfolding perm_def"], ["proof (prove)\nusing this:\n  Rep_perm p\n  \\<in> {f. bij f \\<and>\n            finite {a. f a \\<noteq> a} \\<and>\n            (\\<forall>a. sort_of (f a) = sort_of a)}\n\ngoal (1 subgoal):\n 1. sort_of (Rep_perm p a) = sort_of a", "by simp"], ["", "lemma Rep_perm_ext:\n  \"Rep_perm p1 = Rep_perm p2 \\<Longrightarrow> p1 = p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_perm p1 = Rep_perm p2 \\<Longrightarrow> p1 = p2", "by (simp add: fun_eq_iff Rep_perm_inject [symmetric])"], ["", "instance perm :: size"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(perm, size_class)", ".."], ["", "subsection \\<open>Permutations form a (multiplicative) group\\<close>"], ["", "instantiation perm :: group_add\nbegin"], ["", "definition\n  \"0 = Abs_perm id\""], ["", "definition\n  \"- p = Abs_perm (inv (Rep_perm p))\""], ["", "definition\n  \"p + q = Abs_perm (Rep_perm p \\<circ> Rep_perm q)\""], ["", "definition\n  \"(p1::perm) - p2 = p1 + - p2\""], ["", "lemma Rep_perm_0: \"Rep_perm 0 = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_perm 0 = id", "unfolding zero_perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_perm (Abs_perm id) = id", "by (simp add: Abs_perm_inverse perm_id)"], ["", "lemma Rep_perm_add:\n  \"Rep_perm (p1 + p2) = Rep_perm p1 \\<circ> Rep_perm p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_perm (p1 + p2) = Rep_perm p1 \\<circ> Rep_perm p2", "unfolding plus_perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_perm (Abs_perm (Rep_perm p1 \\<circ> Rep_perm p2)) =\n    Rep_perm p1 \\<circ> Rep_perm p2", "by (simp add: Abs_perm_inverse perm_comp Rep_perm)"], ["", "lemma Rep_perm_uminus:\n  \"Rep_perm (- p) = inv (Rep_perm p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_perm (- p) = inv (Rep_perm p)", "unfolding uminus_perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_perm (Abs_perm (inv (Rep_perm p))) = inv (Rep_perm p)", "by (simp add: Abs_perm_inverse perm_inv Rep_perm)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(perm, group_add_class)", "apply standard"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a. 0 + a = a\n 3. \\<And>a. a + 0 = a\n 4. \\<And>a. - a + a = 0\n 5. \\<And>a b. a + - b = a - b", "unfolding Rep_perm_inject [symmetric]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c. Rep_perm (a + b + c) = Rep_perm (a + (b + c))\n 2. \\<And>a. Rep_perm (0 + a) = Rep_perm a\n 3. \\<And>a. Rep_perm (a + 0) = Rep_perm a\n 4. \\<And>a. Rep_perm (- a + a) = Rep_perm 0\n 5. \\<And>a b. Rep_perm (a + - b) = Rep_perm (a - b)", "unfolding minus_perm_def"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c. Rep_perm (a + b + c) = Rep_perm (a + (b + c))\n 2. \\<And>a. Rep_perm (0 + a) = Rep_perm a\n 3. \\<And>a. Rep_perm (a + 0) = Rep_perm a\n 4. \\<And>a. Rep_perm (- a + a) = Rep_perm 0\n 5. \\<And>a b. Rep_perm (a + - b) = Rep_perm (a + - b)", "unfolding Rep_perm_add"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c.\n       Rep_perm a \\<circ> Rep_perm b \\<circ> Rep_perm c =\n       Rep_perm a \\<circ> (Rep_perm b \\<circ> Rep_perm c)\n 2. \\<And>a. Rep_perm 0 \\<circ> Rep_perm a = Rep_perm a\n 3. \\<And>a. Rep_perm a \\<circ> Rep_perm 0 = Rep_perm a\n 4. \\<And>a. Rep_perm (- a) \\<circ> Rep_perm a = Rep_perm 0\n 5. \\<And>a b.\n       Rep_perm a \\<circ> Rep_perm (- b) = Rep_perm a \\<circ> Rep_perm (- b)", "unfolding Rep_perm_uminus"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c.\n       Rep_perm a \\<circ> Rep_perm b \\<circ> Rep_perm c =\n       Rep_perm a \\<circ> (Rep_perm b \\<circ> Rep_perm c)\n 2. \\<And>a. Rep_perm 0 \\<circ> Rep_perm a = Rep_perm a\n 3. \\<And>a. Rep_perm a \\<circ> Rep_perm 0 = Rep_perm a\n 4. \\<And>a. inv (Rep_perm a) \\<circ> Rep_perm a = Rep_perm 0\n 5. \\<And>a b.\n       Rep_perm a \\<circ> inv (Rep_perm b) =\n       Rep_perm a \\<circ> inv (Rep_perm b)", "unfolding Rep_perm_0"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c.\n       Rep_perm a \\<circ> Rep_perm b \\<circ> Rep_perm c =\n       Rep_perm a \\<circ> (Rep_perm b \\<circ> Rep_perm c)\n 2. \\<And>a. id \\<circ> Rep_perm a = Rep_perm a\n 3. \\<And>a. Rep_perm a \\<circ> id = Rep_perm a\n 4. \\<And>a. inv (Rep_perm a) \\<circ> Rep_perm a = id\n 5. \\<And>a b.\n       Rep_perm a \\<circ> inv (Rep_perm b) =\n       Rep_perm a \\<circ> inv (Rep_perm b)", "by (simp_all add: o_assoc inv_o_cancel [OF bij_is_inj [OF bij_Rep_perm]])"], ["", "end"], ["", "section \\<open>Implementation of swappings\\<close>"], ["", "definition\n  swap :: \"atom \\<Rightarrow> atom \\<Rightarrow> perm\" (\"'(_ \\<rightleftharpoons> _')\")\nwhere\n  \"(a \\<rightleftharpoons> b) =\n    Abs_perm (if sort_of a = sort_of b\n              then (\\<lambda>c. if a = c then b else if b = c then a else c)\n              else id)\""], ["", "lemma Rep_perm_swap:\n  \"Rep_perm (a \\<rightleftharpoons> b) =\n    (if sort_of a = sort_of b\n     then (\\<lambda>c. if a = c then b else if b = c then a else c)\n     else id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_perm (a \\<rightleftharpoons> b) =\n    (if sort_of a = sort_of b\n     then \\<lambda>c. if a = c then b else if b = c then a else c else id)", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_perm\n     (Abs_perm\n       (if sort_of a = sort_of b\n        then \\<lambda>c. if a = c then b else if b = c then a else c\n        else id)) =\n    (if sort_of a = sort_of b\n     then \\<lambda>c. if a = c then b else if b = c then a else c else id)", "apply (rule Abs_perm_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if sort_of a = sort_of b\n     then \\<lambda>c. if a = c then b else if b = c then a else c else id)\n    \\<in> perm", "apply (rule permI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. bij (if sort_of a = sort_of b\n         then \\<lambda>c. if a = c then b else if b = c then a else c\n         else id)\n 2. \\<forall>\\<^sub>\\<infinity>x.\n       (if sort_of a = sort_of b\n        then \\<lambda>c. if a = c then b else if b = c then a else c\n        else id)\n        x =\n       x\n 3. \\<And>aa.\n       sort_of\n        ((if sort_of a = sort_of b\n          then \\<lambda>c. if a = c then b else if b = c then a else c\n          else id)\n          aa) =\n       sort_of aa", "apply (auto simp: bij_def inj_on_def surj_def)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>\\<infinity>x.\n       (if sort_of a = sort_of b\n        then \\<lambda>c. if a = c then b else if b = c then a else c\n        else id)\n        x =\n       x\n 2. \\<And>aa.\n       sort_of\n        ((if sort_of a = sort_of b\n          then \\<lambda>c. if a = c then b else if b = c then a else c\n          else id)\n          aa) =\n       sort_of aa", "apply (rule MOST_rev_mp [OF MOST_neq(1) [of a]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>\\<infinity>x.\n       x \\<noteq> a \\<longrightarrow>\n       (if sort_of a = sort_of b\n        then \\<lambda>c. if a = c then b else if b = c then a else c\n        else id)\n        x =\n       x\n 2. \\<And>aa.\n       sort_of\n        ((if sort_of a = sort_of b\n          then \\<lambda>c. if a = c then b else if b = c then a else c\n          else id)\n          aa) =\n       sort_of aa", "apply (rule MOST_rev_mp [OF MOST_neq(1) [of b]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>\\<infinity>x.\n       x \\<noteq> b \\<longrightarrow>\n       x \\<noteq> a \\<longrightarrow>\n       (if sort_of a = sort_of b\n        then \\<lambda>c. if a = c then b else if b = c then a else c\n        else id)\n        x =\n       x\n 2. \\<And>aa.\n       sort_of\n        ((if sort_of a = sort_of b\n          then \\<lambda>c. if a = c then b else if b = c then a else c\n          else id)\n          aa) =\n       sort_of aa", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       sort_of\n        ((if sort_of a = sort_of b\n          then \\<lambda>c. if a = c then b else if b = c then a else c\n          else id)\n          aa) =\n       sort_of aa", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas Rep_perm_simps =\n  Rep_perm_0\n  Rep_perm_add\n  Rep_perm_uminus\n  Rep_perm_swap"], ["", "lemma swap_different_sorts [simp]:\n  \"sort_of a \\<noteq> sort_of b \\<Longrightarrow> (a \\<rightleftharpoons> b) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of a \\<noteq> sort_of b \\<Longrightarrow>\n    (a \\<rightleftharpoons> b) = 0", "by (rule Rep_perm_ext) (simp add: Rep_perm_simps)"], ["", "lemma swap_cancel:\n  shows \"(a \\<rightleftharpoons> b) + (a \\<rightleftharpoons> b) = 0\"\n  and   \"(a \\<rightleftharpoons> b) + (b \\<rightleftharpoons> a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) + (a \\<rightleftharpoons> b) = 0 &&&\n    (a \\<rightleftharpoons> b) + (b \\<rightleftharpoons> a) = 0", "by (rule_tac [!] Rep_perm_ext)\n     (simp_all add: Rep_perm_simps fun_eq_iff)"], ["", "lemma swap_self [simp]:\n  \"(a \\<rightleftharpoons> a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> a) = 0", "by (rule Rep_perm_ext, simp add: Rep_perm_simps fun_eq_iff)"], ["", "lemma minus_swap [simp]:\n  \"- (a \\<rightleftharpoons> b) = (a \\<rightleftharpoons> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (a \\<rightleftharpoons> b) = (a \\<rightleftharpoons> b)", "by (rule minus_unique [OF swap_cancel(1)])"], ["", "lemma swap_commute:\n  \"(a \\<rightleftharpoons> b) = (b \\<rightleftharpoons> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) = (b \\<rightleftharpoons> a)", "by (rule Rep_perm_ext)\n     (simp add: Rep_perm_swap fun_eq_iff)"], ["", "lemma swap_triple:\n  assumes \"a \\<noteq> b\" and \"c \\<noteq> b\"\n  assumes \"sort_of a = sort_of b\" \"sort_of b = sort_of c\"\n  shows \"(a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) + (a \\<rightleftharpoons> c) = (a \\<rightleftharpoons> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) +\n    (a \\<rightleftharpoons> c) =\n    (a \\<rightleftharpoons> b)", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  c \\<noteq> b\n  sort_of a = sort_of b\n  sort_of b = sort_of c\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) +\n    (a \\<rightleftharpoons> c) =\n    (a \\<rightleftharpoons> b)", "by (rule_tac Rep_perm_ext)\n     (auto simp: Rep_perm_simps fun_eq_iff)"], ["", "section \\<open>Permutation Types\\<close>"], ["", "text \\<open>\n  Infix syntax for \\<open>permute\\<close> has higher precedence than\n  addition, but lower than unary minus.\n\\<close>"], ["", "class pt =\n  fixes permute :: \"perm \\<Rightarrow> 'a \\<Rightarrow> 'a\" (\"_ \\<bullet> _\" [76, 75] 75)\n  assumes permute_zero [simp]: \"0 \\<bullet> x = x\"\n  assumes permute_plus [simp]: \"(p + q) \\<bullet> x = p \\<bullet> (q \\<bullet> x)\"\nbegin"], ["", "lemma permute_diff [simp]:\n  shows \"(p - q) \\<bullet> x = p \\<bullet> - q \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p - q) \\<bullet> x = p \\<bullet> - q \\<bullet> x", "using permute_plus [of p \"- q\" x]"], ["proof (prove)\nusing this:\n  (p + - q) \\<bullet> x = p \\<bullet> - q \\<bullet> x\n\ngoal (1 subgoal):\n 1. (p - q) \\<bullet> x = p \\<bullet> - q \\<bullet> x", "by simp"], ["", "lemma permute_minus_cancel [simp]:\n  shows \"p \\<bullet> - p \\<bullet> x = x\"\n  and   \"- p \\<bullet> p \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> - p \\<bullet> x = x &&& - p \\<bullet> p \\<bullet> x = x", "unfolding permute_plus [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p + - p) \\<bullet> x = x &&& (- p + p) \\<bullet> x = x", "by simp_all"], ["", "lemma permute_swap_cancel [simp]:\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> (a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> (a \\<rightleftharpoons> b) \\<bullet> x =\n    x", "unfolding permute_plus [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a \\<rightleftharpoons> b) + (a \\<rightleftharpoons> b)) \\<bullet> x =\n    x", "by (simp add: swap_cancel)"], ["", "lemma permute_swap_cancel2 [simp]:\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> (b \\<rightleftharpoons> a) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> (b \\<rightleftharpoons> a) \\<bullet> x =\n    x", "unfolding permute_plus [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a \\<rightleftharpoons> b) + (b \\<rightleftharpoons> a)) \\<bullet> x =\n    x", "by (simp add: swap_commute)"], ["", "lemma inj_permute [simp]:\n  shows \"inj (permute p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (permute p)", "by (rule inj_on_inverseI)\n     (rule permute_minus_cancel)"], ["", "lemma surj_permute [simp]:\n  shows \"surj (permute p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj (permute p)", "by (rule surjI, rule permute_minus_cancel)"], ["", "lemma bij_permute [simp]:\n  shows \"bij (permute p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (permute p)", "by (rule bijI [OF inj_permute surj_permute])"], ["", "lemma inv_permute:\n  shows \"inv (permute p) = permute (- p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (permute p) = permute (- p)", "by (rule inv_equality) (simp_all)"], ["", "lemma permute_minus:\n  shows \"permute (- p) = inv (permute p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permute (- p) = inv (permute p)", "by (simp add: inv_permute)"], ["", "lemma permute_eq_iff [simp]:\n  shows \"p \\<bullet> x = p \\<bullet> y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> x = p \\<bullet> y) = (x = y)", "by (rule inj_permute [THEN inj_eq])"], ["", "end"], ["", "subsection \\<open>Permutations for atoms\\<close>"], ["", "instantiation atom :: pt\nbegin"], ["", "definition\n  \"p \\<bullet> a = (Rep_perm p) a\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(atom, pt_class)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply(simp_all add: permute_atom_def Rep_perm_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma sort_of_permute [simp]:\n  shows \"sort_of (p \\<bullet> a) = sort_of a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of (p \\<bullet> a) = sort_of a", "unfolding permute_atom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of (Rep_perm p a) = sort_of a", "by (rule sort_of_Rep_perm)"], ["", "lemma swap_atom:\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> c =\n           (if sort_of a = sort_of b\n            then (if c = a then b else if c = b then a else c) else c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> c =\n    (if sort_of a = sort_of b\n     then if c = a then b else if c = b then a else c else c)", "unfolding permute_atom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_perm (a \\<rightleftharpoons> b) c =\n    (if sort_of a = sort_of b\n     then if c = a then b else if c = b then a else c else c)", "by (simp add: Rep_perm_swap)"], ["", "lemma swap_atom_simps [simp]:\n  \"sort_of a = sort_of b \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> a = b\"\n  \"sort_of a = sort_of b \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> b = a\"\n  \"c \\<noteq> a \\<Longrightarrow> c \\<noteq> b \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> c = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sort_of a = sort_of b \\<Longrightarrow>\n     (a \\<rightleftharpoons> b) \\<bullet> a = b) &&&\n    (sort_of a = sort_of b \\<Longrightarrow>\n     (a \\<rightleftharpoons> b) \\<bullet> b = a) &&&\n    (\\<lbrakk>c \\<noteq> a; c \\<noteq> b\\<rbrakk>\n     \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> c = c)", "unfolding swap_atom"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sort_of a = sort_of b \\<Longrightarrow>\n     (if sort_of a = sort_of b\n      then if a = a then b else if a = b then a else a else a) =\n     b) &&&\n    (sort_of a = sort_of b \\<Longrightarrow>\n     (if sort_of a = sort_of b\n      then if b = a then b else if b = b then a else b else b) =\n     a) &&&\n    (\\<lbrakk>c \\<noteq> a; c \\<noteq> b\\<rbrakk>\n     \\<Longrightarrow> (if sort_of a = sort_of b\n                        then if c = a then b else if c = b then a else c\n                        else c) =\n                       c)", "by simp_all"], ["", "lemma perm_eq_iff:\n  fixes p q :: \"perm\"\n  shows \"p = q \\<longleftrightarrow> (\\<forall>a::atom. p \\<bullet> a = q \\<bullet> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = q) = (\\<forall>a. p \\<bullet> a = q \\<bullet> a)", "unfolding permute_atom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = q) = (\\<forall>a. Rep_perm p a = Rep_perm q a)", "by (metis Rep_perm_ext ext)"], ["", "subsection \\<open>Permutations for permutations\\<close>"], ["", "instantiation perm :: pt\nbegin"], ["", "definition\n  \"p \\<bullet> q = p + q - p\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(perm, pt_class)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply (simp add: permute_perm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply (simp add: permute_perm_def algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma permute_self:\n  shows \"p \\<bullet> p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> p = p", "unfolding permute_perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p + p - p = p", "by (simp add: add.assoc)"], ["", "lemma pemute_minus_self:\n  shows \"- p \\<bullet> p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<bullet> p = p", "unfolding permute_perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - p + p - - p = p", "by (simp add: add.assoc)"], ["", "subsection \\<open>Permutations for functions\\<close>"], ["", "instantiation \"fun\" :: (pt, pt) pt\nbegin"], ["", "definition\n  \"p \\<bullet> f = (\\<lambda>x. p \\<bullet> (f (- p \\<bullet> x)))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, pt_class)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply (simp add: permute_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply (simp add: permute_fun_def minus_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma permute_fun_app_eq:\n  shows \"p \\<bullet> (f x) = (p \\<bullet> f) (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f x = (p \\<bullet> f) (p \\<bullet> x)", "unfolding permute_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f x = p \\<bullet> f (- p \\<bullet> p \\<bullet> x)", "by simp"], ["", "lemma permute_fun_comp:\n  shows \"p \\<bullet> f  = (permute p) o f o (permute (-p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f = permute p \\<circ> f \\<circ> permute (- p)", "by (simp add: comp_def permute_fun_def)"], ["", "subsection \\<open>Permutations for booleans\\<close>"], ["", "instantiation bool :: pt\nbegin"], ["", "definition \"p \\<bullet> (b::bool) = b\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, pt_class)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply(simp_all add: permute_bool_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma permute_boolE:\n  fixes P::\"bool\"\n  shows \"p \\<bullet> P \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> P \\<Longrightarrow> P", "by (simp add: permute_bool_def)"], ["", "lemma permute_boolI:\n  fixes P::\"bool\"\n  shows \"P \\<Longrightarrow> p \\<bullet> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> p \\<bullet> P", "by(simp add: permute_bool_def)"], ["", "subsection \\<open>Permutations for sets\\<close>"], ["", "instantiation \"set\" :: (pt) pt\nbegin"], ["", "definition\n  \"p \\<bullet> X = {p \\<bullet> x | x. x \\<in> X}\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, pt_class)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply (auto simp: permute_set_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma permute_set_eq:\n shows \"p \\<bullet> X = {x. - p \\<bullet> x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> X = {x. - p \\<bullet> x \\<in> X}", "unfolding permute_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p \\<bullet> x |x. x \\<in> X} = {x. - p \\<bullet> x \\<in> X}", "by (auto) (metis permute_minus_cancel(1))"], ["", "lemma permute_set_eq_image:\n  shows \"p \\<bullet> X = permute p ` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> X = permute p ` X", "unfolding permute_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p \\<bullet> x |x. x \\<in> X} = permute p ` X", "by auto"], ["", "lemma permute_set_eq_vimage:\n  shows \"p \\<bullet> X = permute (- p) -` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> X = permute (- p) -` X", "unfolding permute_set_eq vimage_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. - p \\<bullet> x \\<in> X} = {x. - p \\<bullet> x \\<in> X}", "by simp"], ["", "lemma permute_finite [simp]:\n  shows \"finite (p \\<bullet> X) = finite X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (p \\<bullet> X) = finite X", "unfolding permute_set_eq_vimage"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (permute (- p) -` X) = finite X", "using bij_permute"], ["proof (prove)\nusing this:\n  bij (permute ?p)\n\ngoal (1 subgoal):\n 1. finite (permute (- p) -` X) = finite X", "by (rule finite_vimage_iff)"], ["", "lemma swap_set_not_in:\n  assumes a: \"a \\<notin> S\" \"b \\<notin> S\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> S = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> S = S", "unfolding permute_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a \\<rightleftharpoons> b) \\<bullet> x |x. x \\<in> S} = S", "using a"], ["proof (prove)\nusing this:\n  a \\<notin> S\n  b \\<notin> S\n\ngoal (1 subgoal):\n 1. {(a \\<rightleftharpoons> b) \\<bullet> x |x. x \\<in> S} = S", "by (auto simp: swap_atom)"], ["", "lemma swap_set_in:\n  assumes a: \"a \\<in> S\" \"b \\<notin> S\" \"sort_of a = sort_of b\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S", "unfolding permute_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a \\<rightleftharpoons> b) \\<bullet> x |x. x \\<in> S} \\<noteq> S", "using a"], ["proof (prove)\nusing this:\n  a \\<in> S\n  b \\<notin> S\n  sort_of a = sort_of b\n\ngoal (1 subgoal):\n 1. {(a \\<rightleftharpoons> b) \\<bullet> x |x. x \\<in> S} \\<noteq> S", "by (auto simp: swap_atom)"], ["", "lemma swap_set_in_eq:\n  assumes a: \"a \\<in> S\" \"b \\<notin> S\" \"sort_of a = sort_of b\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> S = (S - {a}) \\<union> {b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> S = S - {a} \\<union> {b}", "unfolding permute_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a \\<rightleftharpoons> b) \\<bullet> x |x. x \\<in> S} =\n    S - {a} \\<union> {b}", "using a"], ["proof (prove)\nusing this:\n  a \\<in> S\n  b \\<notin> S\n  sort_of a = sort_of b\n\ngoal (1 subgoal):\n 1. {(a \\<rightleftharpoons> b) \\<bullet> x |x. x \\<in> S} =\n    S - {a} \\<union> {b}", "by (auto simp: swap_atom)"], ["", "lemma swap_set_both_in:\n  assumes a: \"a \\<in> S\" \"b \\<in> S\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> S = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> S = S", "unfolding permute_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a \\<rightleftharpoons> b) \\<bullet> x |x. x \\<in> S} = S", "using a"], ["proof (prove)\nusing this:\n  a \\<in> S\n  b \\<in> S\n\ngoal (1 subgoal):\n 1. {(a \\<rightleftharpoons> b) \\<bullet> x |x. x \\<in> S} = S", "by (auto simp: swap_atom)"], ["", "lemma mem_permute_iff:\n  shows \"(p \\<bullet> x) \\<in> (p \\<bullet> X) \\<longleftrightarrow> x \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> x \\<in> p \\<bullet> X) = (x \\<in> X)", "unfolding permute_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> x \\<in> {p \\<bullet> x |x. x \\<in> X}) = (x \\<in> X)", "by auto"], ["", "lemma empty_eqvt:\n  shows \"p \\<bullet> {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {} = {}", "unfolding permute_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p \\<bullet> x |x. x \\<in> {}} = {}", "by (simp)"], ["", "lemma insert_eqvt:\n  shows \"p \\<bullet> (insert x A) = insert (p \\<bullet> x) (p \\<bullet> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> insert x A = insert (p \\<bullet> x) (p \\<bullet> A)", "unfolding permute_set_eq_image image_insert"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (p \\<bullet> x) (permute p ` A) =\n    insert (p \\<bullet> x) (permute p ` A)", ".."], ["", "subsection \\<open>Permutations for @{typ unit}\\<close>"], ["", "instantiation unit :: pt\nbegin"], ["", "definition \"p \\<bullet> (u::unit) = u\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, pt_class)", "by standard (simp_all add: permute_unit_def)"], ["", "end"], ["", "subsection \\<open>Permutations for products\\<close>"], ["", "instantiation prod :: (pt, pt) pt\nbegin"], ["", "primrec\n  permute_prod\nwhere\n  Pair_eqvt: \"p \\<bullet> (x, y) = (p \\<bullet> x, p \\<bullet> y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, pt_class)", "by standard auto"], ["", "end"], ["", "subsection \\<open>Permutations for sums\\<close>"], ["", "instantiation sum :: (pt, pt) pt\nbegin"], ["", "primrec\n  permute_sum\nwhere\n  Inl_eqvt: \"p \\<bullet> (Inl x) = Inl (p \\<bullet> x)\"\n| Inr_eqvt: \"p \\<bullet> (Inr y) = Inr (p \\<bullet> y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, pt_class)", "by standard (case_tac [!] x, simp_all)"], ["", "end"], ["", "subsection \\<open>Permutations for @{typ \"'a list\"}\\<close>"], ["", "instantiation list :: (pt) pt\nbegin"], ["", "primrec\n  permute_list\nwhere\n  Nil_eqvt:  \"p \\<bullet> [] = []\"\n| Cons_eqvt: \"p \\<bullet> (x # xs) = p \\<bullet> x # p \\<bullet> xs\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, pt_class)", "by standard (induct_tac [!] x, simp_all)"], ["", "end"], ["", "lemma set_eqvt:\n  shows \"p \\<bullet> (set xs) = set (p \\<bullet> xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> set xs = set (p \\<bullet> xs)", "by (induct xs) (simp_all add: empty_eqvt insert_eqvt)"], ["", "subsection \\<open>Permutations for @{typ \"'a option\"}\\<close>"], ["", "instantiation option :: (pt) pt\nbegin"], ["", "primrec\n  permute_option\nwhere\n  None_eqvt: \"p \\<bullet> None = None\"\n| Some_eqvt: \"p \\<bullet> (Some x) = Some (p \\<bullet> x)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, pt_class)", "by standard (induct_tac [!] x, simp_all)"], ["", "end"], ["", "subsection \\<open>Permutations for @{typ \"'a multiset\"}\\<close>"], ["", "instantiation multiset :: (pt) pt\nbegin"], ["", "definition\n  \"p \\<bullet> M = {# p \\<bullet> x. x :# M #}\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a multiset, pt_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "fix M :: \"'a multiset\" and p q :: \"perm\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "show \"0 \\<bullet> M = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<bullet> M = M", "unfolding permute_multiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset (permute 0) M = M", "by (induct_tac M) (simp_all)"], ["proof (state)\nthis:\n  0 \\<bullet> M = M\n\ngoal (1 subgoal):\n 1. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "show \"(p + q) \\<bullet> M = p \\<bullet> q \\<bullet> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> M = p \\<bullet> q \\<bullet> M", "unfolding permute_multiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset (permute (p + q)) M =\n    image_mset (permute p) (image_mset (permute q) M)", "by (induct_tac M) (simp_all)"], ["proof (state)\nthis:\n  (p + q) \\<bullet> M = p \\<bullet> q \\<bullet> M\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma permute_multiset [simp]:\n  fixes M N::\"('a::pt) multiset\"\n  shows \"(p \\<bullet> {#}) = ({#} ::('a::pt) multiset)\"\n  and   \"(p \\<bullet> add_mset x M) = add_mset (p \\<bullet> x) (p \\<bullet> M)\"\n  and   \"(p \\<bullet> (M + N)) = (p \\<bullet> M) + (p \\<bullet> N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {#} = {#} &&&\n    p \\<bullet> add_mset x M = add_mset (p \\<bullet> x) (p \\<bullet> M) &&&\n    p \\<bullet> (M + N) = p \\<bullet> M + p \\<bullet> N", "unfolding permute_multiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset (permute p) {#} = {#} &&&\n    image_mset (permute p) (add_mset x M) =\n    add_mset (p \\<bullet> x) (image_mset (permute p) M) &&&\n    image_mset (permute p) (M + N) =\n    image_mset (permute p) M + image_mset (permute p) N", "by (simp_all)"], ["", "subsection \\<open>Permutations for @{typ \"'a fset\"}\\<close>"], ["", "instantiation fset :: (pt) pt\nbegin"], ["", "context includes fset.lifting begin"], ["", "lift_definition\n  \"permute_fset\" :: \"perm \\<Rightarrow> 'a fset \\<Rightarrow> 'a fset\"\nis \"permute :: perm \\<Rightarrow> 'a set \\<Rightarrow> 'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>perm set. finite set \\<Longrightarrow> finite (perm \\<bullet> set)", "by simp"], ["", "end"], ["", "context includes fset.lifting begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a fset, pt_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "fix x :: \"'a fset\" and p q :: \"perm\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "show \"0 \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<bullet> x = x", "by transfer simp"], ["proof (state)\nthis:\n  0 \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "show \"(p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "by transfer simp"], ["proof (state)\nthis:\n  (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "context includes fset.lifting\nbegin"], ["", "lemma permute_fset [simp]:\n  fixes S::\"('a::pt) fset\"\n  shows \"(p \\<bullet> {||}) = ({||} ::('a::pt) fset)\"\n  and   \"(p \\<bullet> finsert x S) = finsert (p \\<bullet> x) (p \\<bullet> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {||} = {||} &&&\n    p \\<bullet> finsert x S = finsert (p \\<bullet> x) (p \\<bullet> S)", "apply (transfer, simp add: empty_eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> finsert x S = finsert (p \\<bullet> x) (p \\<bullet> S)", "apply (transfer, simp add: insert_eqvt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fset_eqvt:\n  shows \"p \\<bullet> (fset S) = fset (p \\<bullet> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> fset S = fset (p \\<bullet> S)", "by transfer simp"], ["", "end"], ["", "subsection \\<open>Permutations for @{typ \"('a, 'b) finfun\"}\\<close>"], ["", "instantiation finfun :: (pt, pt) pt\nbegin"], ["", "lift_definition\n  permute_finfun :: \"perm \\<Rightarrow> ('a, 'b) finfun \\<Rightarrow> ('a, 'b) finfun\"\nis\n  \"permute :: perm \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>perm fun.\n       fun \\<in> finfun \\<Longrightarrow> perm \\<bullet> fun \\<in> finfun", "apply(simp add: permute_fun_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>perm fun.\n       fun \\<in> finfun \\<Longrightarrow>\n       permute perm \\<circ> fun \\<circ> permute (- perm) \\<in> finfun", "apply(rule finfun_right_compose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>perm fun.\n       fun \\<in> finfun \\<Longrightarrow>\n       permute perm \\<circ> fun \\<in> finfun\n 2. \\<And>perm fun.\n       fun \\<in> finfun \\<Longrightarrow> inj (permute (- perm))", "apply(rule finfun_left_compose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>perm fun. fun \\<in> finfun \\<Longrightarrow> fun \\<in> finfun\n 2. \\<And>perm fun.\n       fun \\<in> finfun \\<Longrightarrow> inj (permute (- perm))", "apply(assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>perm fun.\n       fun \\<in> finfun \\<Longrightarrow> inj (permute (- perm))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) finfun, pt_class)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply(transfer)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> finfun \\<Longrightarrow> 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply(transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q x.\n       x \\<in> finfun \\<Longrightarrow>\n       (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Permutations for @{typ char}, @{typ nat}, and @{typ int}\\<close>"], ["", "instantiation char :: pt\nbegin"], ["", "definition \"p \\<bullet> (c::char) = c\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(char, pt_class)", "by standard (simp_all add: permute_char_def)"], ["", "end"], ["", "instantiation nat :: pt\nbegin"], ["", "definition \"p \\<bullet> (n::nat) = n\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, pt_class)", "by standard (simp_all add: permute_nat_def)"], ["", "end"], ["", "instantiation int :: pt\nbegin"], ["", "definition \"p \\<bullet> (i::int) = i\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, pt_class)", "by standard (simp_all add: permute_int_def)"], ["", "end"], ["", "section \\<open>Pure types\\<close>"], ["", "text \\<open>Pure types will have always empty support.\\<close>"], ["", "class pure = pt +\n  assumes permute_pure: \"p \\<bullet> x = x\""], ["", "text \\<open>Types @{typ unit} and @{typ bool} are pure.\\<close>"], ["", "instance unit :: pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, pure_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p x. p \\<bullet> x = x", "qed (rule permute_unit_def)"], ["", "instance bool :: pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, pure_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p x. p \\<bullet> x = x", "qed (rule permute_bool_def)"], ["", "text \\<open>Other type constructors preserve purity.\\<close>"], ["", "instance \"fun\" :: (pure, pure) pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, pure_class)", "by standard (simp add: permute_fun_def permute_pure)"], ["", "instance set :: (pure) pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, pure_class)", "by standard (simp add: permute_set_def permute_pure)"], ["", "instance prod :: (pure, pure) pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, pure_class)", "by standard (induct_tac x, simp add: permute_pure)"], ["", "instance sum :: (pure, pure) pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, pure_class)", "by standard (induct_tac x, simp_all add: permute_pure)"], ["", "instance list :: (pure) pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, pure_class)", "by standard (induct_tac x, simp_all add: permute_pure)"], ["", "instance option :: (pure) pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, pure_class)", "by standard (induct_tac x, simp_all add: permute_pure)"], ["", "subsection \\<open>Types @{typ char}, @{typ nat}, and @{typ int}\\<close>"], ["", "instance char :: pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(char, pure_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p x. p \\<bullet> x = x", "qed (rule permute_char_def)"], ["", "instance nat :: pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, pure_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p x. p \\<bullet> x = x", "qed (rule permute_nat_def)"], ["", "instance int :: pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, pure_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p x. p \\<bullet> x = x", "qed (rule permute_int_def)"], ["", "section \\<open>Infrastructure for Equivariance and \\<open>Perm_simp\\<close>\\<close>"], ["", "subsection \\<open>Basic functions about permutations\\<close>"], ["", "ML_file \\<open>nominal_basics.ML\\<close>"], ["", "subsection \\<open>Eqvt infrastructure\\<close>"], ["", "text \\<open>Setup of the theorem attributes \\<open>eqvt\\<close> and \\<open>eqvt_raw\\<close>.\\<close>"], ["", "ML_file \\<open>nominal_thmdecls.ML\\<close>"], ["", "lemmas [eqvt] =\n  (* pt types *)\n  permute_prod.simps\n  permute_list.simps\n  permute_option.simps\n  permute_sum.simps\n\n  (* sets *)\n  empty_eqvt insert_eqvt set_eqvt\n\n  (* fsets *)\n  permute_fset fset_eqvt\n\n  (* multisets *)\n  permute_multiset"], ["", "subsection \\<open>\\<open>perm_simp\\<close> infrastructure\\<close>"], ["", "definition\n  \"unpermute p = permute (- p)\""], ["", "lemma eqvt_apply:\n  fixes f :: \"'a::pt \\<Rightarrow> 'b::pt\"\n  and x :: \"'a::pt\"\n  shows \"p \\<bullet> (f x) \\<equiv> (p \\<bullet> f) (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f x \\<equiv> (p \\<bullet> f) (p \\<bullet> x)", "unfolding permute_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f x \\<equiv> p \\<bullet> f (- p \\<bullet> p \\<bullet> x)", "by simp"], ["", "lemma eqvt_lambda:\n  fixes f :: \"'a::pt \\<Rightarrow> 'b::pt\"\n  shows \"p \\<bullet> f \\<equiv> (\\<lambda>x. p \\<bullet> (f (unpermute p x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f \\<equiv> \\<lambda>x. p \\<bullet> f (unpermute p x)", "unfolding permute_fun_def unpermute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>x. p \\<bullet> f (- p \\<bullet> x) \\<equiv>\n    \\<lambda>x. p \\<bullet> f (- p \\<bullet> x)", "by simp"], ["", "lemma eqvt_bound:\n  shows \"p \\<bullet> unpermute p x \\<equiv> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> unpermute p x \\<equiv> x", "unfolding unpermute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> - p \\<bullet> x \\<equiv> x", "by simp"], ["", "text \\<open>provides \\<open>perm_simp\\<close> methods\\<close>"], ["", "ML_file \\<open>nominal_permeq.ML\\<close>"], ["", "method_setup perm_simp =\n \\<open>Nominal_Permeq.args_parser >> Nominal_Permeq.perm_simp_meth\\<close>\n \\<open>pushes permutations inside.\\<close>"], ["", "method_setup perm_strict_simp =\n \\<open>Nominal_Permeq.args_parser >> Nominal_Permeq.perm_strict_simp_meth\\<close>\n \\<open>pushes permutations inside, raises an error if it cannot solve all permutations.\\<close>"], ["", "simproc_setup perm_simproc (\"p \\<bullet> t\") = \\<open>fn _ => fn ctxt => fn ctrm =>\n  case Thm.term_of (Thm.dest_arg ctrm) of\n    Free _ => NONE\n  | Var _ => NONE\n  | Const (@{const_name permute}, _) $ _ $ _ => NONE\n  | _ =>\n      let\n        val thm = Nominal_Permeq.eqvt_conv ctxt Nominal_Permeq.eqvt_strict_config ctrm\n          handle ERROR _ => Thm.reflexive ctrm\n      in\n        if Thm.is_reflexive thm then NONE else SOME(thm)\n      end\n\\<close>"], ["", "subsubsection \\<open>Equivariance for permutations and swapping\\<close>"], ["", "lemma permute_eqvt:\n  shows \"p \\<bullet> (q \\<bullet> x) = (p \\<bullet> q) \\<bullet> (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> x = (p \\<bullet> q) \\<bullet> p \\<bullet> x", "unfolding permute_perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> x = (p + q - p) \\<bullet> p \\<bullet> x", "by simp"], ["", "(* the normal version of this lemma would cause loops *)"], ["", "lemma permute_eqvt_raw [eqvt_raw]:\n  shows \"p \\<bullet> permute \\<equiv> permute\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> permute \\<equiv> permute", "apply(simp add: fun_eq_iff permute_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>x xa.\n       p \\<bullet> (- p \\<bullet> x) \\<bullet> - p \\<bullet> xa \\<equiv>\n    permute", "apply(subst permute_eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>x xa.\n       (p \\<bullet> - p \\<bullet> x) \\<bullet> p \\<bullet> - p \\<bullet> xa \\<equiv>\n    permute", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma zero_perm_eqvt [eqvt]:\n  shows \"p \\<bullet> (0::perm) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> 0 = 0", "unfolding permute_perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p + 0 - p = 0", "by simp"], ["", "lemma add_perm_eqvt [eqvt]:\n  fixes p p1 p2 :: perm\n  shows \"p \\<bullet> (p1 + p2) = p \\<bullet> p1 + p \\<bullet> p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (p1 + p2) = p \\<bullet> p1 + p \\<bullet> p2", "unfolding permute_perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p + (p1 + p2) - p = p + p1 - p + (p + p2 - p)", "by (simp add: perm_eq_iff)"], ["", "lemma swap_eqvt [eqvt]:\n  shows \"p \\<bullet> (a \\<rightleftharpoons> b) = (p \\<bullet> a \\<rightleftharpoons> p \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (a \\<rightleftharpoons> b) =\n    (p \\<bullet> a \\<rightleftharpoons> p \\<bullet> b)", "unfolding permute_perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p + (a \\<rightleftharpoons> b) - p =\n    (p \\<bullet> a \\<rightleftharpoons> p \\<bullet> b)", "by (auto simp: swap_atom perm_eq_iff)"], ["", "lemma uminus_eqvt [eqvt]:\n  fixes p q::\"perm\"\n  shows \"p \\<bullet> (- q) = - (p \\<bullet> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> - q = - (p \\<bullet> q)", "unfolding permute_perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p + - q - p = - (p + q - p)", "by (simp add: diff_add_eq_diff_diff_swap)"], ["", "subsubsection \\<open>Equivariance of Logical Operators\\<close>"], ["", "lemma eq_eqvt [eqvt]:\n  shows \"p \\<bullet> (x = y) \\<longleftrightarrow> (p \\<bullet> x) = (p \\<bullet> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (x = y) = (p \\<bullet> x = p \\<bullet> y)", "unfolding permute_eq_iff permute_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = (x = y)", ".."], ["", "lemma Not_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<not> A) \\<longleftrightarrow> \\<not> (p \\<bullet> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<not> A) = (\\<not> p \\<bullet> A)", "by (simp add: permute_bool_def)"], ["", "lemma conj_eqvt [eqvt]:\n  shows \"p \\<bullet> (A \\<and> B) \\<longleftrightarrow> (p \\<bullet> A) \\<and> (p \\<bullet> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (A \\<and> B) = (p \\<bullet> A \\<and> p \\<bullet> B)", "by (simp add: permute_bool_def)"], ["", "lemma imp_eqvt [eqvt]:\n  shows \"p \\<bullet> (A \\<longrightarrow> B) \\<longleftrightarrow> (p \\<bullet> A) \\<longrightarrow> (p \\<bullet> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (A \\<longrightarrow> B) =\n    (p \\<bullet> A \\<longrightarrow> p \\<bullet> B)", "by (simp add: permute_bool_def)"], ["", "declare imp_eqvt[folded HOL.induct_implies_def, eqvt]"], ["", "lemma all_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<forall>x. P x) = (\\<forall>x. (p \\<bullet> P) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<forall>x. P x) = (\\<forall>x. (p \\<bullet> P) x)", "unfolding All_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (P = (\\<lambda>x. True)) =\n    (p \\<bullet> P = (\\<lambda>x. True))", "by (perm_simp) (rule refl)"], ["", "declare all_eqvt[folded HOL.induct_forall_def, eqvt]"], ["", "lemma ex_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<exists>x. P x) = (\\<exists>x. (p \\<bullet> P) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<exists>x. P x) = (\\<exists>x. (p \\<bullet> P) x)", "unfolding Ex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<forall>Q.\n                    (\\<forall>x. P x \\<longrightarrow> Q) \\<longrightarrow>\n                    Q) =\n    (\\<forall>Q.\n        (\\<forall>x.\n            (p \\<bullet> P) x \\<longrightarrow> Q) \\<longrightarrow>\n        Q)", "by (perm_simp) (rule refl)"], ["", "lemma ex1_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<exists>!x. P x) = (\\<exists>!x. (p \\<bullet> P) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<exists>!x. P x) = (\\<exists>!x. (p \\<bullet> P) x)", "unfolding Ex1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<exists>x.\n                    P x \\<and> (\\<forall>y. P y \\<longrightarrow> y = x)) =\n    (\\<exists>x.\n        (p \\<bullet> P) x \\<and>\n        (\\<forall>y. (p \\<bullet> P) y \\<longrightarrow> y = x))", "by (perm_simp) (rule refl)"], ["", "lemma if_eqvt [eqvt]:\n  shows \"p \\<bullet> (if b then x else y) = (if p \\<bullet> b then p \\<bullet> x else p \\<bullet> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (if b then x else y) =\n    (if p \\<bullet> b then p \\<bullet> x else p \\<bullet> y)", "by (simp add: permute_fun_def permute_bool_def)"], ["", "lemma True_eqvt [eqvt]:\n  shows \"p \\<bullet> True = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> True = True", "unfolding permute_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. True = True", ".."], ["", "lemma False_eqvt [eqvt]:\n  shows \"p \\<bullet> False = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> False = False", "unfolding permute_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. False = False", ".."], ["", "lemma disj_eqvt [eqvt]:\n  shows \"p \\<bullet> (A \\<or> B) \\<longleftrightarrow> (p \\<bullet> A) \\<or> (p \\<bullet> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (A \\<or> B) = (p \\<bullet> A \\<or> p \\<bullet> B)", "by (simp add: permute_bool_def)"], ["", "lemma all_eqvt2:\n  shows \"p \\<bullet> (\\<forall>x. P x) = (\\<forall>x. p \\<bullet> P (- p \\<bullet> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<forall>x. P x) =\n    (\\<forall>x. p \\<bullet> P (- p \\<bullet> x))", "by (perm_simp add: permute_minus_cancel) (rule refl)"], ["", "lemma ex_eqvt2:\n  shows \"p \\<bullet> (\\<exists>x. P x) = (\\<exists>x. p \\<bullet> P (- p \\<bullet> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<exists>x. P x) =\n    (\\<exists>x. p \\<bullet> P (- p \\<bullet> x))", "by (perm_simp add: permute_minus_cancel) (rule refl)"], ["", "lemma ex1_eqvt2:\n  shows \"p \\<bullet> (\\<exists>!x. P x) = (\\<exists>!x. p \\<bullet> P (- p \\<bullet> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<exists>!x. P x) =\n    (\\<exists>!x. p \\<bullet> P (- p \\<bullet> x))", "by (perm_simp add: permute_minus_cancel) (rule refl)"], ["", "lemma the_eqvt:\n  assumes unique: \"\\<exists>!x. P x\"\n  shows \"(p \\<bullet> (THE x. P x)) = (THE x. (p \\<bullet> P) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (THE x. P x) = (THE x. (p \\<bullet> P) x)", "apply(rule the1_equality [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>!x. (p \\<bullet> P) x\n 2. (p \\<bullet> P) (p \\<bullet> (THE x. P x))", "apply(rule_tac p=\"-p\" in permute_boolE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - p \\<bullet> (\\<exists>!x. (p \\<bullet> P) x)\n 2. (p \\<bullet> P) (p \\<bullet> (THE x. P x))", "apply(perm_simp add: permute_minus_cancel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ex1 P\n 2. (p \\<bullet> P) (p \\<bullet> (THE x. P x))", "apply(rule unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> P) (p \\<bullet> (THE x. P x))", "apply(rule_tac p=\"-p\" in permute_boolE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<bullet> (p \\<bullet> P) (p \\<bullet> (THE x. P x))", "apply(perm_simp add: permute_minus_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (The P)", "apply(rule theI'[OF unique])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma the_eqvt2:\n  assumes unique: \"\\<exists>!x. P x\"\n  shows \"(p \\<bullet> (THE x. P x)) = (THE x. p \\<bullet> P (- p \\<bullet> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (THE x. P x) = (THE x. p \\<bullet> P (- p \\<bullet> x))", "apply(rule the1_equality [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>!x. p \\<bullet> P (- p \\<bullet> x)\n 2. p \\<bullet> P (- p \\<bullet> p \\<bullet> (THE x. P x))", "apply(simp only: ex1_eqvt2[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<bullet> (\\<exists>!x. P x)\n 2. p \\<bullet> P (- p \\<bullet> p \\<bullet> (THE x. P x))", "apply(simp add: permute_bool_def unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> P (- p \\<bullet> p \\<bullet> (THE x. P x))", "apply(simp add: permute_bool_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (The P)", "apply(rule theI'[OF unique])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Equivariance of Set operators\\<close>"], ["", "lemma mem_eqvt [eqvt]:\n  shows \"p \\<bullet> (x \\<in> A) \\<longleftrightarrow> (p \\<bullet> x) \\<in> (p \\<bullet> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (x \\<in> A) = (p \\<bullet> x \\<in> p \\<bullet> A)", "unfolding permute_bool_def permute_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> A) = (p \\<bullet> x \\<in> {p \\<bullet> x |x. x \\<in> A})", "by (auto)"], ["", "lemma Collect_eqvt [eqvt]:\n  shows \"p \\<bullet> {x. P x} = {x. (p \\<bullet> P) x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {x. P x} = {x. (p \\<bullet> P) x}", "unfolding permute_set_eq permute_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. - p \\<bullet> x \\<in> Collect P} =\n    {x. p \\<bullet> P (- p \\<bullet> x)}", "by (auto simp: permute_bool_def)"], ["", "lemma Bex_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<exists>x \\<in> S. P x) = (\\<exists>x \\<in> (p \\<bullet> S). (p \\<bullet> P) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<exists>x\\<in>S. P x) =\n    (\\<exists>x\\<in>p \\<bullet> S. (p \\<bullet> P) x)", "unfolding Bex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<exists>x. x \\<in> S \\<and> P x) =\n    (\\<exists>x. x \\<in> p \\<bullet> S \\<and> (p \\<bullet> P) x)", "by simp"], ["", "lemma Ball_eqvt [eqvt]:\n  shows \"p \\<bullet> (\\<forall>x \\<in> S. P x) = (\\<forall>x \\<in> (p \\<bullet> S). (p \\<bullet> P) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<forall>x\\<in>S. P x) =\n    (\\<forall>x\\<in>p \\<bullet> S. (p \\<bullet> P) x)", "unfolding Ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<forall>x. x \\<in> S \\<longrightarrow> P x) =\n    (\\<forall>x. x \\<in> p \\<bullet> S \\<longrightarrow> (p \\<bullet> P) x)", "by simp"], ["", "lemma image_eqvt [eqvt]:\n  shows \"p \\<bullet> (f ` A) = (p \\<bullet> f) ` (p \\<bullet> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f ` A = (p \\<bullet> f) ` (p \\<bullet> A)", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {y. \\<exists>x\\<in>A. y = f x} =\n    {y. \\<exists>x\\<in>p \\<bullet> A. y = (p \\<bullet> f) x}", "by simp"], ["", "lemma Image_eqvt [eqvt]:\n  shows \"p \\<bullet> (R `` A) = (p \\<bullet> R) `` (p \\<bullet> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> R `` A = (p \\<bullet> R) `` (p \\<bullet> A)", "unfolding Image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {y. \\<exists>x\\<in>A. (x, y) \\<in> R} =\n    {y. \\<exists>x\\<in>p \\<bullet> A. (x, y) \\<in> p \\<bullet> R}", "by simp"], ["", "lemma UNIV_eqvt [eqvt]:\n  shows \"p \\<bullet> UNIV = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> UNIV = UNIV", "unfolding UNIV_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {x. True} = {x. True}", "by (perm_simp) (rule refl)"], ["", "lemma inter_eqvt [eqvt]:\n  shows \"p \\<bullet> (A \\<inter> B) = (p \\<bullet> A) \\<inter> (p \\<bullet> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (A \\<inter> B) = p \\<bullet> A \\<inter> p \\<bullet> B", "unfolding Int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {x \\<in> A. x \\<in> B} =\n    {x \\<in> p \\<bullet> A. x \\<in> p \\<bullet> B}", "by simp"], ["", "lemma Inter_eqvt [eqvt]:\n  shows \"p \\<bullet> \\<Inter>S = \\<Inter>(p \\<bullet> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> \\<Inter> S = \\<Inter> (p \\<bullet> S)", "unfolding Inter_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {x. Ball S ((\\<in>) x)} =\n    {x. Ball (p \\<bullet> S) ((\\<in>) x)}", "by simp"], ["", "lemma union_eqvt [eqvt]:\n  shows \"p \\<bullet> (A \\<union> B) = (p \\<bullet> A) \\<union> (p \\<bullet> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (A \\<union> B) = p \\<bullet> A \\<union> p \\<bullet> B", "unfolding Un_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {x. x \\<in> A \\<or> x \\<in> B} =\n    {x. x \\<in> p \\<bullet> A \\<or> x \\<in> p \\<bullet> B}", "by simp"], ["", "lemma Union_eqvt [eqvt]:\n  shows \"p \\<bullet> \\<Union>A = \\<Union>(p \\<bullet> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> \\<Union> A = \\<Union> (p \\<bullet> A)", "unfolding Union_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {x. Bex A ((\\<in>) x)} =\n    {x. Bex (p \\<bullet> A) ((\\<in>) x)}", "by perm_simp rule"], ["", "lemma Diff_eqvt [eqvt]:\n  fixes A B :: \"'a::pt set\"\n  shows \"p \\<bullet> (A - B) = (p \\<bullet> A) - (p \\<bullet> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (A - B) = p \\<bullet> A - p \\<bullet> B", "unfolding set_diff_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {x \\<in> A. x \\<notin> B} =\n    {x \\<in> p \\<bullet> A. x \\<notin> p \\<bullet> B}", "by simp"], ["", "lemma Compl_eqvt [eqvt]:\n  fixes A :: \"'a::pt set\"\n  shows \"p \\<bullet> (- A) = - (p \\<bullet> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> - A = - (p \\<bullet> A)", "unfolding Compl_eq_Diff_UNIV"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (UNIV - A) = UNIV - p \\<bullet> A", "by simp"], ["", "lemma subset_eqvt [eqvt]:\n  shows \"p \\<bullet> (S \\<subseteq> T) \\<longleftrightarrow> (p \\<bullet> S) \\<subseteq> (p \\<bullet> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (S \\<subseteq> T) =\n    (p \\<bullet> S \\<subseteq> p \\<bullet> T)", "unfolding subset_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<forall>x\\<in>S. x \\<in> T) =\n    (\\<forall>x\\<in>p \\<bullet> S. x \\<in> p \\<bullet> T)", "by simp"], ["", "lemma psubset_eqvt [eqvt]:\n  shows \"p \\<bullet> (S \\<subset> T) \\<longleftrightarrow> (p \\<bullet> S) \\<subset> (p \\<bullet> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (S \\<subset> T) = (p \\<bullet> S \\<subset> p \\<bullet> T)", "unfolding psubset_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (S \\<subseteq> T \\<and> S \\<noteq> T) =\n    (p \\<bullet> S \\<subseteq> p \\<bullet> T \\<and>\n     p \\<bullet> S \\<noteq> p \\<bullet> T)", "by simp"], ["", "lemma vimage_eqvt [eqvt]:\n  shows \"p \\<bullet> (f -` A) = (p \\<bullet> f) -` (p \\<bullet> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f -` A = (p \\<bullet> f) -` (p \\<bullet> A)", "unfolding vimage_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {x. f x \\<in> A} =\n    {x. (p \\<bullet> f) x \\<in> p \\<bullet> A}", "by simp"], ["", "lemma foldr_eqvt[eqvt]:\n  \"p \\<bullet> foldr f xs = foldr (p \\<bullet> f) (p \\<bullet> xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> foldr f xs = foldr (p \\<bullet> f) (p \\<bullet> xs)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<bullet> foldr f [] = foldr (p \\<bullet> f) (p \\<bullet> [])\n 2. \\<And>a xs.\n       p \\<bullet> foldr f xs =\n       foldr (p \\<bullet> f) (p \\<bullet> xs) \\<Longrightarrow>\n       p \\<bullet> foldr f (a # xs) =\n       foldr (p \\<bullet> f) (p \\<bullet> (a # xs))", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       p \\<bullet> foldr f xs =\n       foldr (p \\<bullet> f) (p \\<bullet> xs) \\<Longrightarrow>\n       p \\<bullet> (\\<lambda>b. f a (foldr f xs b)) =\n       (\\<lambda>b.\n           (p \\<bullet> f) (p \\<bullet> a)\n            (foldr (p \\<bullet> f) (p \\<bullet> xs) b))", "apply(perm_simp exclude: foldr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       (p \\<bullet> foldr) (p \\<bullet> f) (p \\<bullet> xs) =\n       foldr (p \\<bullet> f) (p \\<bullet> xs) \\<Longrightarrow>\n       (\\<lambda>x.\n           (p \\<bullet> f) (p \\<bullet> a)\n            ((p \\<bullet> foldr) (p \\<bullet> f) (p \\<bullet> xs) x)) =\n       (\\<lambda>b.\n           (p \\<bullet> f) (p \\<bullet> a)\n            (foldr (p \\<bullet> f) (p \\<bullet> xs) b))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* FIXME: eqvt attribute *)"], ["", "lemma Sigma_eqvt:\n  shows \"(p \\<bullet> (X \\<times> Y)) = (p \\<bullet> X) \\<times> (p \\<bullet> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> X \\<times> Y = (p \\<bullet> X) \\<times> (p \\<bullet> Y)", "unfolding Sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<Union>x\\<in>X. \\<Union>y\\<in>Y. {(x, y)}) =\n    (\\<Union>x\\<in>p \\<bullet> X. \\<Union>y\\<in>p \\<bullet> Y. {(x, y)})", "by (perm_simp) (rule refl)"], ["", "text \\<open>\n  In order to prove that lfp is equivariant we need two\n  auxiliary classes which specify that (<=) and\n  Inf are equivariant. Instances for bool and fun are\n  given.\n\\<close>"], ["", "class le_eqvt = order +\n  assumes le_eqvt [eqvt]: \"p \\<bullet> (x \\<le> y) = ((p \\<bullet> x) \\<le> (p \\<bullet> (y::('a::{pt, order}))))\""], ["", "class inf_eqvt = Inf +\n  assumes inf_eqvt [eqvt]: \"p \\<bullet> (Inf X) = Inf (p \\<bullet> (X::('a::{pt, complete_lattice}) set))\""], ["", "instantiation bool :: le_eqvt\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, le_eqvt_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x y.\n       p \\<bullet> (x \\<le> y) = (p \\<bullet> x \\<le> p \\<bullet> y)", "unfolding le_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x y.\n       p \\<bullet> (x \\<longrightarrow> y) =\n       (p \\<bullet> x \\<longrightarrow> p \\<bullet> y)", "apply(perm_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x y. (x \\<longrightarrow> y) = (x \\<longrightarrow> y)", "apply(rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation \"fun\" :: (pt, le_eqvt) le_eqvt\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, le_eqvt_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x y.\n       p \\<bullet> (x \\<le> y) = (p \\<bullet> x \\<le> p \\<bullet> y)", "unfolding le_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x y.\n       p \\<bullet> (\\<forall>xa. x xa \\<le> y xa) =\n       (\\<forall>xa. (p \\<bullet> x) xa \\<le> (p \\<bullet> y) xa)", "apply(perm_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x y.\n       (\\<forall>xa. (p \\<bullet> x) xa \\<le> (p \\<bullet> y) xa) =\n       (\\<forall>xa. (p \\<bullet> x) xa \\<le> (p \\<bullet> y) xa)", "apply(rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation bool :: inf_eqvt\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, inf_eqvt_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p X. p \\<bullet> Inf X = Inf (p \\<bullet> X)", "unfolding Inf_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p X.\n       p \\<bullet> (False \\<notin> X) = (False \\<notin> p \\<bullet> X)", "apply(perm_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p X. (False \\<notin> X) = (False \\<notin> X)", "apply(rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation \"fun\" :: (pt, inf_eqvt) inf_eqvt\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, inf_eqvt_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p X. p \\<bullet> Inf X = Inf (p \\<bullet> X)", "unfolding Inf_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p X.\n       p \\<bullet> (\\<lambda>x. INF f\\<in>X. f x) =\n       (\\<lambda>x. INF f\\<in>p \\<bullet> X. f x)", "apply(perm_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p X.\n       (\\<lambda>x. INF xa\\<in>p \\<bullet> X. xa x) =\n       (\\<lambda>x. INF f\\<in>p \\<bullet> X. f x)", "apply(rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma lfp_eqvt [eqvt]:\n  fixes F::\"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a::pt \\<Rightarrow> 'b::{inf_eqvt, le_eqvt})\"\n  shows \"p \\<bullet> (lfp F) = lfp (p \\<bullet> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> lfp F = lfp (p \\<bullet> F)", "unfolding lfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> Inf {u. F u \\<le> u} = Inf {u. (p \\<bullet> F) u \\<le> u}", "by simp"], ["", "lemma finite_eqvt [eqvt]:\n  shows \"p \\<bullet> finite A = finite (p \\<bullet> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> finite A = finite (p \\<bullet> A)", "unfolding finite_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> lfp (\\<lambda>p x.\n                        x = {} \\<or>\n                        (\\<exists>A a. x = insert a A \\<and> p A))\n                 A =\n    lfp (\\<lambda>p x.\n            x = {} \\<or> (\\<exists>A a. x = insert a A \\<and> p A))\n     (p \\<bullet> A)", "by simp"], ["", "lemma fun_upd_eqvt[eqvt]:\n  shows \"p \\<bullet> (f(x := y)) = (p \\<bullet> f)((p \\<bullet> x) := (p \\<bullet> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f(x := y) = (p \\<bullet> f)(p \\<bullet> x := p \\<bullet> y)", "unfolding fun_upd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<lambda>xa. if xa = x then y else f xa) =\n    (\\<lambda>xa.\n        if xa = p \\<bullet> x then p \\<bullet> y else (p \\<bullet> f) xa)", "by simp"], ["", "lemma comp_eqvt [eqvt]:\n  shows \"p \\<bullet> (f \\<circ> g) = (p \\<bullet> f) \\<circ> (p \\<bullet> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (f \\<circ> g) = p \\<bullet> f \\<circ> p \\<bullet> g", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<lambda>x. f (g x)) =\n    (\\<lambda>x. (p \\<bullet> f) ((p \\<bullet> g) x))", "by simp"], ["", "subsubsection \\<open>Equivariance for product operations\\<close>"], ["", "lemma fst_eqvt [eqvt]:\n  shows \"p \\<bullet> (fst x) = fst (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> fst x = fst (p \\<bullet> x)", "by (cases x) simp"], ["", "lemma snd_eqvt [eqvt]:\n  shows \"p \\<bullet> (snd x) = snd (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> snd x = snd (p \\<bullet> x)", "by (cases x) simp"], ["", "lemma split_eqvt [eqvt]:\n  shows \"p \\<bullet> (case_prod P x) = case_prod (p \\<bullet> P) (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (case x of (x, xa) \\<Rightarrow> P x xa) =\n    (case p \\<bullet> x of (x, xa) \\<Rightarrow> (p \\<bullet> P) x xa)", "unfolding split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> P (fst x) (snd x) =\n    (p \\<bullet> P) (fst (p \\<bullet> x)) (snd (p \\<bullet> x))", "by simp"], ["", "subsubsection \\<open>Equivariance for list operations\\<close>"], ["", "lemma append_eqvt [eqvt]:\n  shows \"p \\<bullet> (xs @ ys) = (p \\<bullet> xs) @ (p \\<bullet> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (xs @ ys) = p \\<bullet> xs @ p \\<bullet> ys", "by (induct xs) auto"], ["", "lemma rev_eqvt [eqvt]:\n  shows \"p \\<bullet> (rev xs) = rev (p \\<bullet> xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> rev xs = rev (p \\<bullet> xs)", "by (induct xs) (simp_all add: append_eqvt)"], ["", "lemma map_eqvt [eqvt]:\n  shows \"p \\<bullet> (map f xs) = map (p \\<bullet> f) (p \\<bullet> xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> map f xs = map (p \\<bullet> f) (p \\<bullet> xs)", "by (induct xs) (simp_all)"], ["", "lemma removeAll_eqvt [eqvt]:\n  shows \"p \\<bullet> (removeAll x xs) = removeAll (p \\<bullet> x) (p \\<bullet> xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> removeAll x xs = removeAll (p \\<bullet> x) (p \\<bullet> xs)", "by (induct xs) (auto)"], ["", "lemma filter_eqvt [eqvt]:\n  shows \"p \\<bullet> (filter f xs) = filter (p \\<bullet> f) (p \\<bullet> xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> filter f xs = filter (p \\<bullet> f) (p \\<bullet> xs)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<bullet> filter f [] = filter (p \\<bullet> f) (p \\<bullet> [])\n 2. \\<And>a xs.\n       p \\<bullet> filter f xs =\n       filter (p \\<bullet> f) (p \\<bullet> xs) \\<Longrightarrow>\n       p \\<bullet> filter f (a # xs) =\n       filter (p \\<bullet> f) (p \\<bullet> (a # xs))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       p \\<bullet> filter f xs =\n       filter (p \\<bullet> f) (p \\<bullet> xs) \\<Longrightarrow>\n       p \\<bullet> filter f (a # xs) =\n       filter (p \\<bullet> f) (p \\<bullet> (a # xs))", "apply(simp only: filter.simps permute_list.simps if_eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       p \\<bullet> filter f xs =\n       filter (p \\<bullet> f) (p \\<bullet> xs) \\<Longrightarrow>\n       (if p \\<bullet> f a\n        then p \\<bullet> a # filter (p \\<bullet> f) (p \\<bullet> xs)\n        else filter (p \\<bullet> f) (p \\<bullet> xs)) =\n       (if (p \\<bullet> f) (p \\<bullet> a)\n        then p \\<bullet> a # filter (p \\<bullet> f) (p \\<bullet> xs)\n        else filter (p \\<bullet> f) (p \\<bullet> xs))", "apply(simp only: permute_fun_app_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_eqvt [eqvt]:\n  shows \"p \\<bullet> (distinct xs) = distinct (p \\<bullet> xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> distinct xs = distinct (p \\<bullet> xs)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<bullet> distinct [] = distinct (p \\<bullet> [])\n 2. \\<And>a xs.\n       p \\<bullet> distinct xs = distinct (p \\<bullet> xs) \\<Longrightarrow>\n       p \\<bullet> distinct (a # xs) = distinct (p \\<bullet> (a # xs))", "apply(simp add: permute_bool_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       p \\<bullet> distinct xs = distinct (p \\<bullet> xs) \\<Longrightarrow>\n       p \\<bullet> distinct (a # xs) = distinct (p \\<bullet> (a # xs))", "apply(simp add: conj_eqvt Not_eqvt mem_eqvt set_eqvt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_eqvt [eqvt]:\n  shows \"p \\<bullet> (length xs) = length (p \\<bullet> xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> length xs = length (p \\<bullet> xs)", "by (induct xs) (simp_all add: permute_pure)"], ["", "subsubsection \\<open>Equivariance for @{typ \"'a option\"}\\<close>"], ["", "lemma map_option_eqvt[eqvt]:\n  shows \"p \\<bullet> (map_option f x) = map_option (p \\<bullet> f) (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> map_option f x = map_option (p \\<bullet> f) (p \\<bullet> x)", "by (cases x) (simp_all)"], ["", "subsubsection \\<open>Equivariance for @{typ \"'a fset\"}\\<close>"], ["", "context includes fset.lifting begin"], ["", "lemma in_fset_eqvt [eqvt]:\n  shows \"(p \\<bullet> (x |\\<in>| S)) = ((p \\<bullet> x) |\\<in>| (p \\<bullet> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (x |\\<in>| S) = (p \\<bullet> x |\\<in>| p \\<bullet> S)", "by transfer simp"], ["", "lemma union_fset_eqvt [eqvt]:\n  shows \"(p \\<bullet> (S |\\<union>| T)) = ((p \\<bullet> S) |\\<union>| (p \\<bullet> T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (S |\\<union>| T) = p \\<bullet> S |\\<union>| p \\<bullet> T", "by (induct S) (simp_all)"], ["", "lemma inter_fset_eqvt [eqvt]:\n  shows \"(p \\<bullet> (S |\\<inter>| T)) = ((p \\<bullet> S) |\\<inter>| (p \\<bullet> T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (S |\\<inter>| T) = p \\<bullet> S |\\<inter>| p \\<bullet> T", "by transfer simp"], ["", "lemma subset_fset_eqvt [eqvt]:\n  shows \"(p \\<bullet> (S |\\<subseteq>| T)) = ((p \\<bullet> S) |\\<subseteq>| (p \\<bullet> T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (S |\\<subseteq>| T) =\n    (p \\<bullet> S |\\<subseteq>| p \\<bullet> T)", "by transfer simp"], ["", "lemma map_fset_eqvt [eqvt]:\n  shows \"p \\<bullet> (f |`| S) = (p \\<bullet> f) |`| (p \\<bullet> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f |`| S = (p \\<bullet> f) |`| (p \\<bullet> S)", "by transfer simp"], ["", "end"], ["", "subsubsection \\<open>Equivariance for @{typ \"('a, 'b) finfun\"}\\<close>"], ["", "lemma finfun_update_eqvt [eqvt]:\n  shows \"(p \\<bullet> (finfun_update f a b)) = finfun_update (p \\<bullet> f) (p \\<bullet> a) (p \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> finfun_update f a b =\n    finfun_update (p \\<bullet> f) (p \\<bullet> a) (p \\<bullet> b)", "by (transfer) (simp)"], ["", "lemma finfun_const_eqvt [eqvt]:\n  shows \"(p \\<bullet> (finfun_const b)) = finfun_const (p \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> finfun_const b = finfun_const (p \\<bullet> b)", "by (transfer) (simp)"], ["", "lemma finfun_apply_eqvt [eqvt]:\n  shows \"(p \\<bullet> (finfun_apply f b)) = finfun_apply (p \\<bullet> f) (p \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> finfun_apply f b =\n    finfun_apply (p \\<bullet> f) (p \\<bullet> b)", "by (transfer) (simp)"], ["", "section \\<open>Supp, Freshness and Supports\\<close>"], ["", "context pt\nbegin"], ["", "definition\n  supp :: \"'a \\<Rightarrow> atom set\"\nwhere\n  \"supp x = {a. infinite {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x}}\""], ["", "definition\n  fresh :: \"atom \\<Rightarrow> 'a \\<Rightarrow> bool\" (\"_ \\<sharp> _\" [55, 55] 55)\nwhere\n  \"a \\<sharp> x \\<equiv> a \\<notin> supp x\""], ["", "end"], ["", "lemma supp_conv_fresh:\n  shows \"supp x = {a. \\<not> a \\<sharp> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x = {a. \\<not> a \\<sharp> x}", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x = {a. \\<not> a \\<notin> supp x}", "by simp"], ["", "lemma swap_rel_trans:\n  assumes \"sort_of a = sort_of b\"\n  assumes \"sort_of b = sort_of c\"\n  assumes \"(a \\<rightleftharpoons> c) \\<bullet> x = x\"\n  assumes \"(b \\<rightleftharpoons> c) \\<bullet> x = x\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<not> ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x", "assume \"a = b \\<or> c = b\""], ["proof (state)\nthis:\n  a = b \\<or> c = b\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<not> ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x", "with assms"], ["proof (chain)\npicking this:\n  sort_of a = sort_of b\n  sort_of b = sort_of c\n  (a \\<rightleftharpoons> c) \\<bullet> x = x\n  (b \\<rightleftharpoons> c) \\<bullet> x = x\n  a = b \\<or> c = b", "show \"(a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  sort_of a = sort_of b\n  sort_of b = sort_of c\n  (a \\<rightleftharpoons> c) \\<bullet> x = x\n  (b \\<rightleftharpoons> c) \\<bullet> x = x\n  a = b \\<or> c = b\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "by auto"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<not> (a = b \\<or> c = b) \\<Longrightarrow>\n    (a \\<rightleftharpoons> b) \\<bullet> x = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a = b \\<or> c = b) \\<Longrightarrow>\n    (a \\<rightleftharpoons> b) \\<bullet> x = x", "assume *: \"\\<not> (a = b \\<or> c = b)\""], ["proof (state)\nthis:\n  \\<not> (a = b \\<or> c = b)\n\ngoal (1 subgoal):\n 1. \\<not> (a = b \\<or> c = b) \\<Longrightarrow>\n    (a \\<rightleftharpoons> b) \\<bullet> x = x", "have \"((a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) + (a \\<rightleftharpoons> c)) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) +\n     (a \\<rightleftharpoons> c)) \\<bullet> x =\n    x", "using assms"], ["proof (prove)\nusing this:\n  sort_of a = sort_of b\n  sort_of b = sort_of c\n  (a \\<rightleftharpoons> c) \\<bullet> x = x\n  (b \\<rightleftharpoons> c) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. ((a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) +\n     (a \\<rightleftharpoons> c)) \\<bullet> x =\n    x", "by simp"], ["proof (state)\nthis:\n  ((a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) +\n   (a \\<rightleftharpoons> c)) \\<bullet> x =\n  x\n\ngoal (1 subgoal):\n 1. \\<not> (a = b \\<or> c = b) \\<Longrightarrow>\n    (a \\<rightleftharpoons> b) \\<bullet> x = x", "also"], ["proof (state)\nthis:\n  ((a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) +\n   (a \\<rightleftharpoons> c)) \\<bullet> x =\n  x\n\ngoal (1 subgoal):\n 1. \\<not> (a = b \\<or> c = b) \\<Longrightarrow>\n    (a \\<rightleftharpoons> b) \\<bullet> x = x", "have \"(a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) + (a \\<rightleftharpoons> c) = (a \\<rightleftharpoons> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) +\n    (a \\<rightleftharpoons> c) =\n    (a \\<rightleftharpoons> b)", "using assms *"], ["proof (prove)\nusing this:\n  sort_of a = sort_of b\n  sort_of b = sort_of c\n  (a \\<rightleftharpoons> c) \\<bullet> x = x\n  (b \\<rightleftharpoons> c) \\<bullet> x = x\n  \\<not> (a = b \\<or> c = b)\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) +\n    (a \\<rightleftharpoons> c) =\n    (a \\<rightleftharpoons> b)", "by (simp add: swap_triple)"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> c) + (b \\<rightleftharpoons> c) +\n  (a \\<rightleftharpoons> c) =\n  (a \\<rightleftharpoons> b)\n\ngoal (1 subgoal):\n 1. \\<not> (a = b \\<or> c = b) \\<Longrightarrow>\n    (a \\<rightleftharpoons> b) \\<bullet> x = x", "finally"], ["proof (chain)\npicking this:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x", "show \"(a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "."], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_fresh_fresh:\n  assumes a: \"a \\<sharp> x\"\n  and     b: \"b \\<sharp> x\"\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<not> ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x", "assume asm: \"sort_of a = sort_of b\""], ["proof (state)\nthis:\n  sort_of a = sort_of b\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<not> ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x", "have \"finite {c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x}\" \"finite {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x} &&&\n    finite {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x}", "using a b"], ["proof (prove)\nusing this:\n  a \\<sharp> x\n  b \\<sharp> x\n\ngoal (1 subgoal):\n 1. finite {c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x} &&&\n    finite {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x}", "unfolding fresh_def supp_def"], ["proof (prove)\nusing this:\n  a \\<notin> {a. infinite\n                  {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x}}\n  b \\<notin> {a. infinite\n                  {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x}}\n\ngoal (1 subgoal):\n 1. finite {c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x} &&&\n    finite {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x}", "by simp_all"], ["proof (state)\nthis:\n  finite {c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x}\n  finite {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<not> ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  finite {c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x}\n  finite {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x}", "have \"finite ({c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x} \\<union> {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x})\""], ["proof (prove)\nusing this:\n  finite {c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x}\n  finite {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x}\n\ngoal (1 subgoal):\n 1. finite\n     ({c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x} \\<union>\n      {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x})", "by simp"], ["proof (state)\nthis:\n  finite\n   ({c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x} \\<union>\n    {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x})\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<not> ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  finite\n   ({c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x} \\<union>\n    {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x})", "obtain c\n    where \"(a \\<rightleftharpoons> c) \\<bullet> x = x\" \"(b \\<rightleftharpoons> c) \\<bullet> x = x\" \"sort_of c = sort_of b\""], ["proof (prove)\nusing this:\n  finite\n   ({c. (a \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x} \\<union>\n    {c. (b \\<rightleftharpoons> c) \\<bullet> x \\<noteq> x})\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>(a \\<rightleftharpoons> c) \\<bullet> x = x;\n         (b \\<rightleftharpoons> c) \\<bullet> x = x;\n         sort_of c = sort_of b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_atom) (auto)"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> c) \\<bullet> x = x\n  (b \\<rightleftharpoons> c) \\<bullet> x = x\n  sort_of c = sort_of b\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<not> ?P \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  (a \\<rightleftharpoons> c) \\<bullet> x = x\n  (b \\<rightleftharpoons> c) \\<bullet> x = x\n  sort_of c = sort_of b", "show \"(a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  (a \\<rightleftharpoons> c) \\<bullet> x = x\n  (b \\<rightleftharpoons> c) \\<bullet> x = x\n  sort_of c = sort_of b\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "using asm"], ["proof (prove)\nusing this:\n  (a \\<rightleftharpoons> c) \\<bullet> x = x\n  (b \\<rightleftharpoons> c) \\<bullet> x = x\n  sort_of c = sort_of b\n  sort_of a = sort_of b\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "by (rule_tac swap_rel_trans) (simp_all)"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. sort_of a \\<noteq> sort_of b \\<Longrightarrow>\n    (a \\<rightleftharpoons> b) \\<bullet> x = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sort_of a \\<noteq> sort_of b \\<Longrightarrow>\n    (a \\<rightleftharpoons> b) \\<bullet> x = x", "assume \"sort_of a \\<noteq> sort_of b\""], ["proof (state)\nthis:\n  sort_of a \\<noteq> sort_of b\n\ngoal (1 subgoal):\n 1. sort_of a \\<noteq> sort_of b \\<Longrightarrow>\n    (a \\<rightleftharpoons> b) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  sort_of a \\<noteq> sort_of b", "show \"(a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  sort_of a \\<noteq> sort_of b\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "by simp"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>supp and fresh are equivariant\\<close>"], ["", "lemma supp_eqvt [eqvt]:\n  shows \"p \\<bullet> (supp x) = supp (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> supp x = supp (p \\<bullet> x)", "unfolding supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> {a. infinite\n                     {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq>\n                         x}} =\n    {a. infinite\n         {b. (a \\<rightleftharpoons> b) \\<bullet> p \\<bullet> x \\<noteq>\n             p \\<bullet> x}}", "by simp"], ["", "lemma fresh_eqvt [eqvt]:\n  shows \"p \\<bullet> (a \\<sharp> x) = (p \\<bullet> a) \\<sharp> (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (a \\<sharp> x) = p \\<bullet> a \\<sharp> p \\<bullet> x", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (a \\<notin> supp x) =\n    (p \\<bullet> a \\<notin> supp (p \\<bullet> x))", "by simp"], ["", "lemma fresh_permute_iff:\n  shows \"(p \\<bullet> a) \\<sharp> (p \\<bullet> x) \\<longleftrightarrow> a \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> a \\<sharp> p \\<bullet> x = a \\<sharp> x", "by (simp only: fresh_eqvt[symmetric] permute_bool_def)"], ["", "lemma fresh_permute_left:\n  shows \"a \\<sharp> p \\<bullet> x \\<longleftrightarrow> - p \\<bullet> a \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> p \\<bullet> x = - p \\<bullet> a \\<sharp> x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<sharp> p \\<bullet> x \\<Longrightarrow> - p \\<bullet> a \\<sharp> x\n 2. - p \\<bullet> a \\<sharp> x \\<Longrightarrow> a \\<sharp> p \\<bullet> x", "assume \"a \\<sharp> p \\<bullet> x\""], ["proof (state)\nthis:\n  a \\<sharp> p \\<bullet> x\n\ngoal (2 subgoals):\n 1. a \\<sharp> p \\<bullet> x \\<Longrightarrow> - p \\<bullet> a \\<sharp> x\n 2. - p \\<bullet> a \\<sharp> x \\<Longrightarrow> a \\<sharp> p \\<bullet> x", "then"], ["proof (chain)\npicking this:\n  a \\<sharp> p \\<bullet> x", "have \"- p \\<bullet> a \\<sharp> - p \\<bullet> p \\<bullet> x\""], ["proof (prove)\nusing this:\n  a \\<sharp> p \\<bullet> x\n\ngoal (1 subgoal):\n 1. - p \\<bullet> a \\<sharp> - p \\<bullet> p \\<bullet> x", "by (simp only: fresh_permute_iff)"], ["proof (state)\nthis:\n  - p \\<bullet> a \\<sharp> - p \\<bullet> p \\<bullet> x\n\ngoal (2 subgoals):\n 1. a \\<sharp> p \\<bullet> x \\<Longrightarrow> - p \\<bullet> a \\<sharp> x\n 2. - p \\<bullet> a \\<sharp> x \\<Longrightarrow> a \\<sharp> p \\<bullet> x", "then"], ["proof (chain)\npicking this:\n  - p \\<bullet> a \\<sharp> - p \\<bullet> p \\<bullet> x", "show \"- p \\<bullet> a \\<sharp> x\""], ["proof (prove)\nusing this:\n  - p \\<bullet> a \\<sharp> - p \\<bullet> p \\<bullet> x\n\ngoal (1 subgoal):\n 1. - p \\<bullet> a \\<sharp> x", "by simp"], ["proof (state)\nthis:\n  - p \\<bullet> a \\<sharp> x\n\ngoal (1 subgoal):\n 1. - p \\<bullet> a \\<sharp> x \\<Longrightarrow> a \\<sharp> p \\<bullet> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. - p \\<bullet> a \\<sharp> x \\<Longrightarrow> a \\<sharp> p \\<bullet> x", "assume \"- p \\<bullet> a \\<sharp> x\""], ["proof (state)\nthis:\n  - p \\<bullet> a \\<sharp> x\n\ngoal (1 subgoal):\n 1. - p \\<bullet> a \\<sharp> x \\<Longrightarrow> a \\<sharp> p \\<bullet> x", "then"], ["proof (chain)\npicking this:\n  - p \\<bullet> a \\<sharp> x", "have \"p \\<bullet> - p \\<bullet> a \\<sharp> p \\<bullet> x\""], ["proof (prove)\nusing this:\n  - p \\<bullet> a \\<sharp> x\n\ngoal (1 subgoal):\n 1. p \\<bullet> - p \\<bullet> a \\<sharp> p \\<bullet> x", "by (simp only: fresh_permute_iff)"], ["proof (state)\nthis:\n  p \\<bullet> - p \\<bullet> a \\<sharp> p \\<bullet> x\n\ngoal (1 subgoal):\n 1. - p \\<bullet> a \\<sharp> x \\<Longrightarrow> a \\<sharp> p \\<bullet> x", "then"], ["proof (chain)\npicking this:\n  p \\<bullet> - p \\<bullet> a \\<sharp> p \\<bullet> x", "show \"a \\<sharp> p \\<bullet> x\""], ["proof (prove)\nusing this:\n  p \\<bullet> - p \\<bullet> a \\<sharp> p \\<bullet> x\n\ngoal (1 subgoal):\n 1. a \\<sharp> p \\<bullet> x", "by simp"], ["proof (state)\nthis:\n  a \\<sharp> p \\<bullet> x\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>supports\\<close>"], ["", "definition\n  supports :: \"atom set \\<Rightarrow> 'a::pt \\<Rightarrow> bool\" (infixl \"supports\" 80)\nwhere\n  \"S supports x \\<equiv> \\<forall>a b. (a \\<notin> S \\<and> b \\<notin> S \\<longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x)\""], ["", "lemma supp_is_subset:\n  fixes S :: \"atom set\"\n  and   x :: \"'a::pt\"\n  assumes a1: \"S supports x\"\n  and     a2: \"finite S\"\n  shows \"(supp x) \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x \\<subseteq> S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> supp x \\<subseteq> S \\<Longrightarrow> False", "assume \"\\<not> (supp x \\<subseteq> S)\""], ["proof (state)\nthis:\n  \\<not> supp x \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<not> supp x \\<subseteq> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> supp x \\<subseteq> S", "obtain a where b1: \"a \\<in> supp x\" and b2: \"a \\<notin> S\""], ["proof (prove)\nusing this:\n  \\<not> supp x \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> supp x; a \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> supp x\n  a \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<not> supp x \\<subseteq> S \\<Longrightarrow> False", "from a1 b2"], ["proof (chain)\npicking this:\n  S supports x\n  a \\<notin> S", "have \"\\<forall>b. b \\<notin> S \\<longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  S supports x\n  a \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<notin> S \\<longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> x = x", "unfolding supports_def"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     a \\<notin> S \\<and> b \\<notin> S \\<longrightarrow>\n     (a \\<rightleftharpoons> b) \\<bullet> x = x\n  a \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<notin> S \\<longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> x = x", "by auto"], ["proof (state)\nthis:\n  \\<forall>b.\n     b \\<notin> S \\<longrightarrow>\n     (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<not> supp x \\<subseteq> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>b.\n     b \\<notin> S \\<longrightarrow>\n     (a \\<rightleftharpoons> b) \\<bullet> x = x", "have \"{b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x} \\<subseteq> S\""], ["proof (prove)\nusing this:\n  \\<forall>b.\n     b \\<notin> S \\<longrightarrow>\n     (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x} \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<not> supp x \\<subseteq> S \\<Longrightarrow> False", "with a2"], ["proof (chain)\npicking this:\n  finite S\n  {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x} \\<subseteq> S", "have \"finite {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x}\""], ["proof (prove)\nusing this:\n  finite S\n  {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x}", "by (simp add: finite_subset)"], ["proof (state)\nthis:\n  finite {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x}\n\ngoal (1 subgoal):\n 1. \\<not> supp x \\<subseteq> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  finite {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x}", "have \"a \\<notin> (supp x)\""], ["proof (prove)\nusing this:\n  finite {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x}\n\ngoal (1 subgoal):\n 1. a \\<notin> supp x", "unfolding supp_def"], ["proof (prove)\nusing this:\n  finite {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x}\n\ngoal (1 subgoal):\n 1. a \\<notin> {a. infinite\n                    {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x}}", "by simp"], ["proof (state)\nthis:\n  a \\<notin> supp x\n\ngoal (1 subgoal):\n 1. \\<not> supp x \\<subseteq> S \\<Longrightarrow> False", "with b1"], ["proof (chain)\npicking this:\n  a \\<in> supp x\n  a \\<notin> supp x", "show False"], ["proof (prove)\nusing this:\n  a \\<in> supp x\n  a \\<notin> supp x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supports_finite:\n  fixes S :: \"atom set\"\n  and   x :: \"'a::pt\"\n  assumes a1: \"S supports x\"\n  and     a2: \"finite S\"\n  shows \"finite (supp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (supp x)", "have \"(supp x) \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x \\<subseteq> S", "using a1 a2"], ["proof (prove)\nusing this:\n  S supports x\n  finite S\n\ngoal (1 subgoal):\n 1. supp x \\<subseteq> S", "by (rule supp_is_subset)"], ["proof (state)\nthis:\n  supp x \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite (supp x)", "then"], ["proof (chain)\npicking this:\n  supp x \\<subseteq> S", "show \"finite (supp x)\""], ["proof (prove)\nusing this:\n  supp x \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite (supp x)", "using a2"], ["proof (prove)\nusing this:\n  supp x \\<subseteq> S\n  finite S\n\ngoal (1 subgoal):\n 1. finite (supp x)", "by (simp add: finite_subset)"], ["proof (state)\nthis:\n  finite (supp x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_supports:\n  fixes x :: \"'a::pt\"\n  shows \"(supp x) supports x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x supports x", "unfolding supports_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       a \\<notin> supp x \\<and> b \\<notin> supp x \\<longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> x = x", "proof (intro strip)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       a \\<notin> supp x \\<and> b \\<notin> supp x \\<Longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> x = x", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       a \\<notin> supp x \\<and> b \\<notin> supp x \\<Longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> x = x", "assume \"a \\<notin> (supp x) \\<and> b \\<notin> (supp x)\""], ["proof (state)\nthis:\n  a \\<notin> supp x \\<and> b \\<notin> supp x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       a \\<notin> supp x \\<and> b \\<notin> supp x \\<Longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  a \\<notin> supp x \\<and> b \\<notin> supp x", "have \"a \\<sharp> x\" and \"b \\<sharp> x\""], ["proof (prove)\nusing this:\n  a \\<notin> supp x \\<and> b \\<notin> supp x\n\ngoal (1 subgoal):\n 1. a \\<sharp> x &&& b \\<sharp> x", "by (simp_all add: fresh_def)"], ["proof (state)\nthis:\n  a \\<sharp> x\n  b \\<sharp> x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       a \\<notin> supp x \\<and> b \\<notin> supp x \\<Longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  a \\<sharp> x\n  b \\<sharp> x", "show \"(a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  a \\<sharp> x\n  b \\<sharp> x\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "by (simp add: swap_fresh_fresh)"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supports_fresh:\n  fixes x :: \"'a::pt\"\n  assumes a1: \"S supports x\"\n  and     a2: \"finite S\"\n  and     a3: \"a \\<notin> S\"\n  shows \"a \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> x", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> supp x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> supp x", "have \"(supp x) \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x \\<subseteq> S", "using a1 a2"], ["proof (prove)\nusing this:\n  S supports x\n  finite S\n\ngoal (1 subgoal):\n 1. supp x \\<subseteq> S", "by (rule supp_is_subset)"], ["proof (state)\nthis:\n  supp x \\<subseteq> S\n\ngoal (1 subgoal):\n 1. a \\<notin> supp x", "then"], ["proof (chain)\npicking this:\n  supp x \\<subseteq> S", "show \"a \\<notin> (supp x)\""], ["proof (prove)\nusing this:\n  supp x \\<subseteq> S\n\ngoal (1 subgoal):\n 1. a \\<notin> supp x", "using a3"], ["proof (prove)\nusing this:\n  supp x \\<subseteq> S\n  a \\<notin> S\n\ngoal (1 subgoal):\n 1. a \\<notin> supp x", "by auto"], ["proof (state)\nthis:\n  a \\<notin> supp x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_is_least_supports:\n  fixes S :: \"atom set\"\n  and   x :: \"'a::pt\"\n  assumes  a1: \"S supports x\"\n  and      a2: \"finite S\"\n  and      a3: \"\\<And>S'. finite S' \\<Longrightarrow> (S' supports x) \\<Longrightarrow> S \\<subseteq> S'\"\n  shows \"(supp x) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x = S", "proof (rule equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. supp x \\<subseteq> S\n 2. S \\<subseteq> supp x", "show \"(supp x) \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x \\<subseteq> S", "using a1 a2"], ["proof (prove)\nusing this:\n  S supports x\n  finite S\n\ngoal (1 subgoal):\n 1. supp x \\<subseteq> S", "by (rule supp_is_subset)"], ["proof (state)\nthis:\n  supp x \\<subseteq> S\n\ngoal (1 subgoal):\n 1. S \\<subseteq> supp x", "with a2"], ["proof (chain)\npicking this:\n  finite S\n  supp x \\<subseteq> S", "have fin: \"finite (supp x)\""], ["proof (prove)\nusing this:\n  finite S\n  supp x \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite (supp x)", "by (rule rev_finite_subset)"], ["proof (state)\nthis:\n  finite (supp x)\n\ngoal (1 subgoal):\n 1. S \\<subseteq> supp x", "have \"(supp x) supports x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x supports x", "by (rule supp_supports)"], ["proof (state)\nthis:\n  supp x supports x\n\ngoal (1 subgoal):\n 1. S \\<subseteq> supp x", "with fin a3"], ["proof (chain)\npicking this:\n  finite (supp x)\n  \\<lbrakk>finite ?S'; ?S' supports x\\<rbrakk>\n  \\<Longrightarrow> S \\<subseteq> ?S'\n  supp x supports x", "show \"S \\<subseteq> supp x\""], ["proof (prove)\nusing this:\n  finite (supp x)\n  \\<lbrakk>finite ?S'; ?S' supports x\\<rbrakk>\n  \\<Longrightarrow> S \\<subseteq> ?S'\n  supp x supports x\n\ngoal (1 subgoal):\n 1. S \\<subseteq> supp x", "by blast"], ["proof (state)\nthis:\n  S \\<subseteq> supp x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subsetCI:\n  shows \"(\\<And>x. x \\<in> A \\<Longrightarrow> x \\<notin> B \\<Longrightarrow> False) \\<Longrightarrow> A \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> A; x \\<notin> B\\<rbrakk>\n        \\<Longrightarrow> False) \\<Longrightarrow>\n    A \\<subseteq> B", "by auto"], ["", "lemma finite_supp_unique:\n  assumes a1: \"S supports x\"\n  assumes a2: \"finite S\"\n  assumes a3: \"\\<And>a b. \\<lbrakk>a \\<in> S; b \\<notin> S; sort_of a = sort_of b\\<rbrakk> \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x\"\n  shows \"(supp x) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x = S", "using a1 a2"], ["proof (prove)\nusing this:\n  S supports x\n  finite S\n\ngoal (1 subgoal):\n 1. supp x = S", "proof (rule supp_is_least_supports)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>finite S'; S' supports x\\<rbrakk>\n       \\<Longrightarrow> S \\<subseteq> S'", "fix S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>finite S'; S' supports x\\<rbrakk>\n       \\<Longrightarrow> S \\<subseteq> S'", "assume \"finite S'\" and \"S' supports x\""], ["proof (state)\nthis:\n  finite S'\n  S' supports x\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>finite S'; S' supports x\\<rbrakk>\n       \\<Longrightarrow> S \\<subseteq> S'", "show \"S \\<subseteq> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> S'", "proof (rule subsetCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> S; x \\<notin> S'\\<rbrakk> \\<Longrightarrow> False", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> S; x \\<notin> S'\\<rbrakk> \\<Longrightarrow> False", "assume \"a \\<in> S\" and \"a \\<notin> S'\""], ["proof (state)\nthis:\n  a \\<in> S\n  a \\<notin> S'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> S; x \\<notin> S'\\<rbrakk> \\<Longrightarrow> False", "have \"finite (S \\<union> S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S \\<union> S')", "using \\<open>finite S\\<close> \\<open>finite S'\\<close>"], ["proof (prove)\nusing this:\n  finite S\n  finite S'\n\ngoal (1 subgoal):\n 1. finite (S \\<union> S')", "by simp"], ["proof (state)\nthis:\n  finite (S \\<union> S')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> S; x \\<notin> S'\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  finite (S \\<union> S')", "obtain b where \"b \\<notin> S \\<union> S'\" and \"sort_of b = sort_of a\""], ["proof (prove)\nusing this:\n  finite (S \\<union> S')\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<notin> S \\<union> S'; sort_of b = sort_of a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_atom)"], ["proof (state)\nthis:\n  b \\<notin> S \\<union> S'\n  sort_of b = sort_of a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> S; x \\<notin> S'\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  b \\<notin> S \\<union> S'\n  sort_of b = sort_of a", "have \"b \\<notin> S\" and \"b \\<notin> S'\"  and \"sort_of a = sort_of b\""], ["proof (prove)\nusing this:\n  b \\<notin> S \\<union> S'\n  sort_of b = sort_of a\n\ngoal (1 subgoal):\n 1. b \\<notin> S &&& b \\<notin> S' &&& sort_of a = sort_of b", "by simp_all"], ["proof (state)\nthis:\n  b \\<notin> S\n  b \\<notin> S'\n  sort_of a = sort_of b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> S; x \\<notin> S'\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  b \\<notin> S\n  b \\<notin> S'\n  sort_of a = sort_of b", "have \"(a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  b \\<notin> S\n  b \\<notin> S'\n  sort_of a = sort_of b\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "using \\<open>a \\<notin> S'\\<close> \\<open>S' supports x\\<close>"], ["proof (prove)\nusing this:\n  b \\<notin> S\n  b \\<notin> S'\n  sort_of a = sort_of b\n  a \\<notin> S'\n  S' supports x\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "by (simp add: supports_def)"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> S; x \\<notin> S'\\<rbrakk> \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> S; x \\<notin> S'\\<rbrakk> \\<Longrightarrow> False", "have \"(a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x", "using \\<open>a \\<in> S\\<close> \\<open>b \\<notin> S\\<close> \\<open>sort_of a = sort_of b\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> S\n  b \\<notin> S\n  sort_of a = sort_of b\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x", "by (rule a3)"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> S; x \\<notin> S'\\<rbrakk> \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n  (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x", "show \"False\""], ["proof (prove)\nusing this:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n  (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<subseteq> S'\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Support w.r.t. relations\\<close>"], ["", "text \\<open>\n  This definition is used for unquotient types, where\n  alpha-equivalence does not coincide with equality.\n\\<close>"], ["", "definition\n  \"supp_rel R x = {a. infinite {b. \\<not>(R ((a \\<rightleftharpoons> b) \\<bullet> x) x)}}\""], ["", "section \\<open>Finitely-supported types\\<close>"], ["", "class fs = pt +\n  assumes finite_supp: \"finite (supp x)\""], ["", "lemma pure_supp:\n  fixes x::\"'a::pure\"\n  shows \"supp x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x = {}", "unfolding supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. infinite {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq> x}} =\n    {}", "by (simp add: permute_pure)"], ["", "lemma pure_fresh:\n  fixes x::\"'a::pure\"\n  shows \"a \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> x", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> supp x", "by (simp add: pure_supp)"], ["", "instance pure < fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, fs_class)", "by standard (simp add: pure_supp)"], ["", "subsection  \\<open>Type @{typ atom} is finitely-supported.\\<close>"], ["", "lemma supp_atom:\n  shows \"supp a = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp a = {a}", "apply (rule finite_supp_unique)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {a} supports a\n 2. finite {a}\n 3. \\<And>aa b.\n       \\<lbrakk>aa \\<in> {a}; b \\<notin> {a};\n        sort_of aa = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (aa \\<rightleftharpoons> b) \\<bullet> a \\<noteq> a", "apply (clarsimp simp add: supports_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {a}\n 2. \\<And>aa b.\n       \\<lbrakk>aa \\<in> {a}; b \\<notin> {a};\n        sort_of aa = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (aa \\<rightleftharpoons> b) \\<bullet> a \\<noteq> a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>aa \\<in> {a}; b \\<notin> {a};\n        sort_of aa = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (aa \\<rightleftharpoons> b) \\<bullet> a \\<noteq> a", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fresh_atom:\n  shows \"a \\<sharp> b \\<longleftrightarrow> a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> b = (a \\<noteq> b)", "unfolding fresh_def supp_atom"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> {b}) = (a \\<noteq> b)", "by simp"], ["", "instance atom :: fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(atom, fs_class)", "by standard (simp add: supp_atom)"], ["", "section \\<open>Type @{typ perm} is finitely-supported.\\<close>"], ["", "lemma perm_swap_eq:\n  shows \"(a \\<rightleftharpoons> b) \\<bullet> p = p \\<longleftrightarrow> (p \\<bullet> (a \\<rightleftharpoons> b)) = (a \\<rightleftharpoons> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a \\<rightleftharpoons> b) \\<bullet> p = p) =\n    (p \\<bullet> (a \\<rightleftharpoons> b) = (a \\<rightleftharpoons> b))", "unfolding permute_perm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a \\<rightleftharpoons> b) + p - (a \\<rightleftharpoons> b) = p) =\n    (p + (a \\<rightleftharpoons> b) - p = (a \\<rightleftharpoons> b))", "by (metis add_diff_cancel minus_perm_def)"], ["", "lemma supports_perm:\n  shows \"{a. p \\<bullet> a \\<noteq> a} supports p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. p \\<bullet> a \\<noteq> a} supports p", "unfolding supports_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       a \\<notin> {a. p \\<bullet> a \\<noteq> a} \\<and>\n       b \\<notin> {a. p \\<bullet> a \\<noteq> a} \\<longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> p = p", "unfolding perm_swap_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       a \\<notin> {a. p \\<bullet> a \\<noteq> a} \\<and>\n       b \\<notin> {a. p \\<bullet> a \\<noteq> a} \\<longrightarrow>\n       p \\<bullet> (a \\<rightleftharpoons> b) = (a \\<rightleftharpoons> b)", "by (simp add: swap_eqvt)"], ["", "lemma finite_perm_lemma:\n  shows \"finite {a::atom. p \\<bullet> a \\<noteq> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a. p \\<bullet> a \\<noteq> a}", "using finite_Rep_perm [of p]"], ["proof (prove)\nusing this:\n  finite {a. Rep_perm p a \\<noteq> a}\n\ngoal (1 subgoal):\n 1. finite {a. p \\<bullet> a \\<noteq> a}", "unfolding permute_atom_def"], ["proof (prove)\nusing this:\n  finite {a. Rep_perm p a \\<noteq> a}\n\ngoal (1 subgoal):\n 1. finite {a. Rep_perm p a \\<noteq> a}", "."], ["", "lemma supp_perm:\n  shows \"supp p = {a. p \\<bullet> a \\<noteq> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp p = {a. p \\<bullet> a \\<noteq> a}", "apply (rule finite_supp_unique)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {a. p \\<bullet> a \\<noteq> a} supports p\n 2. finite {a. p \\<bullet> a \\<noteq> a}\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> {a. p \\<bullet> a \\<noteq> a};\n        b \\<notin> {a. p \\<bullet> a \\<noteq> a};\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> p \\<noteq> p", "apply (rule supports_perm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {a. p \\<bullet> a \\<noteq> a}\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> {a. p \\<bullet> a \\<noteq> a};\n        b \\<notin> {a. p \\<bullet> a \\<noteq> a};\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> p \\<noteq> p", "apply (rule finite_perm_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {a. p \\<bullet> a \\<noteq> a};\n        b \\<notin> {a. p \\<bullet> a \\<noteq> a};\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> p \\<noteq> p", "apply (simp add: perm_swap_eq swap_eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>p \\<bullet> a \\<noteq> a; p \\<bullet> b = b;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (p \\<bullet> a \\<rightleftharpoons> b) \\<noteq>\n                         (a \\<rightleftharpoons> b)", "apply (auto simp: perm_eq_iff swap_atom)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fresh_perm:\n  shows \"a \\<sharp> p \\<longleftrightarrow> p \\<bullet> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> p = (p \\<bullet> a = a)", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp p) = (p \\<bullet> a = a)", "by (simp add: supp_perm)"], ["", "lemma supp_swap:\n  shows \"supp (a \\<rightleftharpoons> b) = (if a = b \\<or> sort_of a \\<noteq> sort_of b then {} else {a, b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (a \\<rightleftharpoons> b) =\n    (if a = b \\<or> sort_of a \\<noteq> sort_of b then {} else {a, b})", "by (auto simp: supp_perm swap_atom)"], ["", "lemma fresh_swap:\n  shows \"a \\<sharp> (b \\<rightleftharpoons> c) \\<longleftrightarrow> (sort_of b \\<noteq> sort_of c) \\<or> b = c \\<or> (a \\<sharp> b \\<and> a \\<sharp> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> (b \\<rightleftharpoons> c) =\n    (sort_of b \\<noteq> sort_of c \\<or>\n     b = c \\<or> a \\<sharp> b \\<and> a \\<sharp> c)", "by (simp add: fresh_def supp_swap supp_atom)"], ["", "lemma fresh_zero_perm:\n  shows \"a \\<sharp> (0::perm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> 0", "unfolding fresh_perm"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<bullet> a = a", "by simp"], ["", "lemma supp_zero_perm:\n  shows \"supp (0::perm) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp 0 = {}", "unfolding supp_perm"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. 0 \\<bullet> a \\<noteq> a} = {}", "by simp"], ["", "lemma fresh_plus_perm:\n  fixes p q::perm\n  assumes \"a \\<sharp> p\" \"a \\<sharp> q\"\n  shows \"a \\<sharp> (p + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> p + q", "using assms"], ["proof (prove)\nusing this:\n  a \\<sharp> p\n  a \\<sharp> q\n\ngoal (1 subgoal):\n 1. a \\<sharp> p + q", "unfolding fresh_def"], ["proof (prove)\nusing this:\n  a \\<notin> supp p\n  a \\<notin> supp q\n\ngoal (1 subgoal):\n 1. a \\<notin> supp (p + q)", "by (auto simp: supp_perm)"], ["", "lemma supp_plus_perm:\n  fixes p q::perm\n  shows \"supp (p + q) \\<subseteq> supp p \\<union> supp q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (p + q) \\<subseteq> supp p \\<union> supp q", "by (auto simp: supp_perm)"], ["", "lemma fresh_minus_perm:\n  fixes p::perm\n  shows \"a \\<sharp> (- p) \\<longleftrightarrow> a \\<sharp> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> - p = a \\<sharp> p", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp (- p)) = (a \\<notin> supp p)", "unfolding supp_perm"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> {a. - p \\<bullet> a \\<noteq> a}) =\n    (a \\<notin> {a. p \\<bullet> a \\<noteq> a})", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<bullet> a = a) = (p \\<bullet> a = a)", "apply(metis permute_minus_cancel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma supp_minus_perm:\n  fixes p::perm\n  shows \"supp (- p) = supp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (- p) = supp p", "unfolding supp_conv_fresh"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. \\<not> a \\<sharp> - p} = {a. \\<not> a \\<sharp> p}", "by (simp add: fresh_minus_perm)"], ["", "lemma plus_perm_eq:\n  fixes p q::\"perm\"\n  assumes asm: \"supp p \\<inter> supp q = {}\"\n  shows \"p + q = q + p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p + q = q + p", "unfolding perm_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "fix a::\"atom\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "show \"(p + q) \\<bullet> a = (q + p) \\<bullet> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "assume \"a \\<notin> supp p\" \"a \\<notin> supp q\""], ["proof (state)\nthis:\n  a \\<notin> supp p\n  a \\<notin> supp q\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "then"], ["proof (chain)\npicking this:\n  a \\<notin> supp p\n  a \\<notin> supp q", "have \"(p + q) \\<bullet> a = (q + p) \\<bullet> a\""], ["proof (prove)\nusing this:\n  a \\<notin> supp p\n  a \\<notin> supp q\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "by (simp add: supp_perm)"], ["proof (state)\nthis:\n  (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "assume a: \"a \\<in> supp p\" \"a \\<notin> supp q\""], ["proof (state)\nthis:\n  a \\<in> supp p\n  a \\<notin> supp q\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "then"], ["proof (chain)\npicking this:\n  a \\<in> supp p\n  a \\<notin> supp q", "have \"p \\<bullet> a \\<in> supp p\""], ["proof (prove)\nusing this:\n  a \\<in> supp p\n  a \\<notin> supp q\n\ngoal (1 subgoal):\n 1. p \\<bullet> a \\<in> supp p", "by (simp add: supp_perm)"], ["proof (state)\nthis:\n  p \\<bullet> a \\<in> supp p\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "then"], ["proof (chain)\npicking this:\n  p \\<bullet> a \\<in> supp p", "have \"p \\<bullet> a \\<notin> supp q\""], ["proof (prove)\nusing this:\n  p \\<bullet> a \\<in> supp p\n\ngoal (1 subgoal):\n 1. p \\<bullet> a \\<notin> supp q", "using asm"], ["proof (prove)\nusing this:\n  p \\<bullet> a \\<in> supp p\n  supp p \\<inter> supp q = {}\n\ngoal (1 subgoal):\n 1. p \\<bullet> a \\<notin> supp q", "by auto"], ["proof (state)\nthis:\n  p \\<bullet> a \\<notin> supp q\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "with a"], ["proof (chain)\npicking this:\n  a \\<in> supp p\n  a \\<notin> supp q\n  p \\<bullet> a \\<notin> supp q", "have \"(p + q) \\<bullet> a = (q + p) \\<bullet> a\""], ["proof (prove)\nusing this:\n  a \\<in> supp p\n  a \\<notin> supp q\n  p \\<bullet> a \\<notin> supp q\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "by (simp add: supp_perm)"], ["proof (state)\nthis:\n  (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "assume a: \"a \\<notin> supp p\" \"a \\<in> supp q\""], ["proof (state)\nthis:\n  a \\<notin> supp p\n  a \\<in> supp q\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "then"], ["proof (chain)\npicking this:\n  a \\<notin> supp p\n  a \\<in> supp q", "have \"q \\<bullet> a \\<in> supp q\""], ["proof (prove)\nusing this:\n  a \\<notin> supp p\n  a \\<in> supp q\n\ngoal (1 subgoal):\n 1. q \\<bullet> a \\<in> supp q", "by (simp add: supp_perm)"], ["proof (state)\nthis:\n  q \\<bullet> a \\<in> supp q\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "then"], ["proof (chain)\npicking this:\n  q \\<bullet> a \\<in> supp q", "have \"q \\<bullet> a \\<notin> supp p\""], ["proof (prove)\nusing this:\n  q \\<bullet> a \\<in> supp q\n\ngoal (1 subgoal):\n 1. q \\<bullet> a \\<notin> supp p", "using asm"], ["proof (prove)\nusing this:\n  q \\<bullet> a \\<in> supp q\n  supp p \\<inter> supp q = {}\n\ngoal (1 subgoal):\n 1. q \\<bullet> a \\<notin> supp p", "by auto"], ["proof (state)\nthis:\n  q \\<bullet> a \\<notin> supp p\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "with a"], ["proof (chain)\npicking this:\n  a \\<notin> supp p\n  a \\<in> supp q\n  q \\<bullet> a \\<notin> supp p", "have \"(p + q) \\<bullet> a = (q + p) \\<bullet> a\""], ["proof (prove)\nusing this:\n  a \\<notin> supp p\n  a \\<in> supp q\n  q \\<bullet> a \\<notin> supp p\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "by (simp add: supp_perm)"], ["proof (state)\nthis:\n  (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin> supp p; a \\<in> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<notin> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n  \\<lbrakk>a \\<in> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n  \\<lbrakk>a \\<notin> supp p; a \\<in> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a", "show \"(p + q) \\<bullet> a = (q + p) \\<bullet> a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<notin> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n  \\<lbrakk>a \\<in> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n  \\<lbrakk>a \\<notin> supp p; a \\<in> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "using asm"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<notin> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n  \\<lbrakk>a \\<in> supp p; a \\<notin> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n  \\<lbrakk>a \\<notin> supp p; a \\<in> supp q\\<rbrakk>\n  \\<Longrightarrow> (p + q) \\<bullet> a = (q + p) \\<bullet> a\n  supp p \\<inter> supp q = {}\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> a = (q + p) \\<bullet> a", "by blast"], ["proof (state)\nthis:\n  (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (p + q) \\<bullet> a = (q + p) \\<bullet> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_plus_perm_eq:\n  fixes p q::perm\n  assumes asm: \"supp p \\<inter> supp q = {}\"\n  shows \"supp (p + q) = supp p \\<union> supp q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "fix a::\"atom\""], ["proof (state)\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "assume \"a \\<in> supp p\""], ["proof (state)\nthis:\n  a \\<in> supp p\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "then"], ["proof (chain)\npicking this:\n  a \\<in> supp p", "have \"a \\<notin> supp q\""], ["proof (prove)\nusing this:\n  a \\<in> supp p\n\ngoal (1 subgoal):\n 1. a \\<notin> supp q", "using asm"], ["proof (prove)\nusing this:\n  a \\<in> supp p\n  supp p \\<inter> supp q = {}\n\ngoal (1 subgoal):\n 1. a \\<notin> supp q", "by auto"], ["proof (state)\nthis:\n  a \\<notin> supp q\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "then"], ["proof (chain)\npicking this:\n  a \\<notin> supp q", "have \"a \\<in> supp (p + q)\""], ["proof (prove)\nusing this:\n  a \\<notin> supp q\n\ngoal (1 subgoal):\n 1. a \\<in> supp (p + q)", "using \\<open>a \\<in> supp p\\<close>"], ["proof (prove)\nusing this:\n  a \\<notin> supp q\n  a \\<in> supp p\n\ngoal (1 subgoal):\n 1. a \\<in> supp (p + q)", "by (simp add: supp_perm)"], ["proof (state)\nthis:\n  a \\<in> supp (p + q)\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "}"], ["proof (state)\nthis:\n  ?a2 \\<in> supp p \\<Longrightarrow> ?a2 \\<in> supp (p + q)\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "moreover"], ["proof (state)\nthis:\n  ?a2 \\<in> supp p \\<Longrightarrow> ?a2 \\<in> supp (p + q)\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "{"], ["proof (state)\nthis:\n  ?a2 \\<in> supp p \\<Longrightarrow> ?a2 \\<in> supp (p + q)\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "fix a::\"atom\""], ["proof (state)\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "assume \"a \\<in> supp q\""], ["proof (state)\nthis:\n  a \\<in> supp q\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "then"], ["proof (chain)\npicking this:\n  a \\<in> supp q", "have \"a \\<notin> supp p\""], ["proof (prove)\nusing this:\n  a \\<in> supp q\n\ngoal (1 subgoal):\n 1. a \\<notin> supp p", "using asm"], ["proof (prove)\nusing this:\n  a \\<in> supp q\n  supp p \\<inter> supp q = {}\n\ngoal (1 subgoal):\n 1. a \\<notin> supp p", "by auto"], ["proof (state)\nthis:\n  a \\<notin> supp p\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "then"], ["proof (chain)\npicking this:\n  a \\<notin> supp p", "have \"a \\<in> supp (q + p)\""], ["proof (prove)\nusing this:\n  a \\<notin> supp p\n\ngoal (1 subgoal):\n 1. a \\<in> supp (q + p)", "using \\<open>a \\<in> supp q\\<close>"], ["proof (prove)\nusing this:\n  a \\<notin> supp p\n  a \\<in> supp q\n\ngoal (1 subgoal):\n 1. a \\<in> supp (q + p)", "by (simp add: supp_perm)"], ["proof (state)\nthis:\n  a \\<in> supp (q + p)\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "then"], ["proof (chain)\npicking this:\n  a \\<in> supp (q + p)", "have \"a \\<in> supp (p + q)\""], ["proof (prove)\nusing this:\n  a \\<in> supp (q + p)\n\ngoal (1 subgoal):\n 1. a \\<in> supp (p + q)", "using asm plus_perm_eq"], ["proof (prove)\nusing this:\n  a \\<in> supp (q + p)\n  supp p \\<inter> supp q = {}\n  supp ?p \\<inter> supp ?q = {} \\<Longrightarrow> ?p + ?q = ?q + ?p\n\ngoal (1 subgoal):\n 1. a \\<in> supp (p + q)", "by metis"], ["proof (state)\nthis:\n  a \\<in> supp (p + q)\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "}"], ["proof (state)\nthis:\n  ?a2 \\<in> supp q \\<Longrightarrow> ?a2 \\<in> supp (p + q)\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "ultimately"], ["proof (chain)\npicking this:\n  ?a2 \\<in> supp p \\<Longrightarrow> ?a2 \\<in> supp (p + q)\n  ?a2 \\<in> supp q \\<Longrightarrow> ?a2 \\<in> supp (p + q)", "have \"supp p \\<union> supp q \\<subseteq> supp (p + q)\""], ["proof (prove)\nusing this:\n  ?a2 \\<in> supp p \\<Longrightarrow> ?a2 \\<in> supp (p + q)\n  ?a2 \\<in> supp q \\<Longrightarrow> ?a2 \\<in> supp (p + q)\n\ngoal (1 subgoal):\n 1. supp p \\<union> supp q \\<subseteq> supp (p + q)", "by blast"], ["proof (state)\nthis:\n  supp p \\<union> supp q \\<subseteq> supp (p + q)\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "then"], ["proof (chain)\npicking this:\n  supp p \\<union> supp q \\<subseteq> supp (p + q)", "show \"supp (p + q) = supp p \\<union> supp q\""], ["proof (prove)\nusing this:\n  supp p \\<union> supp q \\<subseteq> supp (p + q)\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "using supp_plus_perm"], ["proof (prove)\nusing this:\n  supp p \\<union> supp q \\<subseteq> supp (p + q)\n  supp (?p + ?q) \\<subseteq> supp ?p \\<union> supp ?q\n\ngoal (1 subgoal):\n 1. supp (p + q) = supp p \\<union> supp q", "by blast"], ["proof (state)\nthis:\n  supp (p + q) = supp p \\<union> supp q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_eq_iff2:\n  fixes p q :: \"perm\"\n  shows \"p = q \\<longleftrightarrow> (\\<forall>a::atom \\<in> supp p \\<union> supp q. p \\<bullet> a = q \\<bullet> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = q) =\n    (\\<forall>a\\<in>supp p \\<union> supp q. p \\<bullet> a = q \\<bullet> a)", "unfolding perm_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a. p \\<bullet> a = q \\<bullet> a) =\n    (\\<forall>a\\<in>supp p \\<union> supp q. p \\<bullet> a = q \\<bullet> a)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<forall>a\\<in>supp p \\<union> supp q.\n          p \\<bullet> a = q \\<bullet> a \\<Longrightarrow>\n       p \\<bullet> a = q \\<bullet> a", "apply(case_tac \"a \\<sharp> p \\<and> a \\<sharp> q\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>a\\<in>supp p \\<union> supp q.\n                   p \\<bullet> a = q \\<bullet> a;\n        a \\<sharp> p \\<and> a \\<sharp> q\\<rbrakk>\n       \\<Longrightarrow> p \\<bullet> a = q \\<bullet> a\n 2. \\<And>a.\n       \\<lbrakk>\\<forall>a\\<in>supp p \\<union> supp q.\n                   p \\<bullet> a = q \\<bullet> a;\n        \\<not> (a \\<sharp> p \\<and> a \\<sharp> q)\\<rbrakk>\n       \\<Longrightarrow> p \\<bullet> a = q \\<bullet> a", "apply(simp add: fresh_perm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>a\\<in>supp p \\<union> supp q.\n                   p \\<bullet> a = q \\<bullet> a;\n        \\<not> (a \\<sharp> p \\<and> a \\<sharp> q)\\<rbrakk>\n       \\<Longrightarrow> p \\<bullet> a = q \\<bullet> a", "apply(simp add: fresh_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instance perm :: fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(perm, fs_class)", "by standard (simp add: supp_perm finite_perm_lemma)"], ["", "section \\<open>Finite Support instances for other types\\<close>"], ["", "subsection \\<open>Type @{typ \"'a \\<times> 'b\"} is finitely-supported.\\<close>"], ["", "lemma supp_Pair:\n  shows \"supp (x, y) = supp x \\<union> supp y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (x, y) = supp x \\<union> supp y", "by (simp add: supp_def Collect_imp_eq Collect_neg_eq)"], ["", "lemma fresh_Pair:\n  shows \"a \\<sharp> (x, y) \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> (x, y) = (a \\<sharp> x \\<and> a \\<sharp> y)", "by (simp add: fresh_def supp_Pair)"], ["", "lemma supp_Unit:\n  shows \"supp () = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp () = {}", "by (simp add: supp_def)"], ["", "lemma fresh_Unit:\n  shows \"a \\<sharp> ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> ()", "by (simp add: fresh_def supp_Unit)"], ["", "instance prod :: (fs, fs) fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, fs_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. finite (supp x)", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b. x = (a, b) \\<Longrightarrow> finite (supp x)", "apply (simp add: supp_Pair finite_supp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Type @{typ \"'a + 'b\"} is finitely supported\\<close>"], ["", "lemma supp_Inl:\n  shows \"supp (Inl x) = supp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Inl x) = supp x", "by (simp add: supp_def)"], ["", "lemma supp_Inr:\n  shows \"supp (Inr x) = supp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Inr x) = supp x", "by (simp add: supp_def)"], ["", "lemma fresh_Inl:\n  shows \"a \\<sharp> Inl x \\<longleftrightarrow> a \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> Inl x = a \\<sharp> x", "by (simp add: fresh_def supp_Inl)"], ["", "lemma fresh_Inr:\n  shows \"a \\<sharp> Inr y \\<longleftrightarrow> a \\<sharp> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> Inr y = a \\<sharp> y", "by (simp add: fresh_def supp_Inr)"], ["", "instance sum :: (fs, fs) fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, fs_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. finite (supp x)", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a. x = Inl a \\<Longrightarrow> finite (supp x)\n 2. \\<And>x b. x = Inr b \\<Longrightarrow> finite (supp x)", "apply (simp_all add: supp_Inl supp_Inr finite_supp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Type @{typ \"'a option\"} is finitely supported\\<close>"], ["", "lemma supp_None:\n  shows \"supp None = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp None = {}", "by (simp add: supp_def)"], ["", "lemma supp_Some:\n  shows \"supp (Some x) = supp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Some x) = supp x", "by (simp add: supp_def)"], ["", "lemma fresh_None:\n  shows \"a \\<sharp> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> None", "by (simp add: fresh_def supp_None)"], ["", "lemma fresh_Some:\n  shows \"a \\<sharp> Some x \\<longleftrightarrow> a \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> Some x = a \\<sharp> x", "by (simp add: fresh_def supp_Some)"], ["", "instance option :: (fs) fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, fs_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. finite (supp x)", "apply (induct_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. finite (supp None)\n 2. \\<And>x option. finite (supp (Some option))", "apply (simp_all add: supp_None supp_Some finite_supp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Type @{typ \"'a list\"} is finitely supported\\<close>"], ["", "lemma supp_Nil:\n  shows \"supp [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp [] = {}", "by (simp add: supp_def)"], ["", "lemma fresh_Nil:\n  shows \"a \\<sharp> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> []", "by (simp add: fresh_def supp_Nil)"], ["", "lemma supp_Cons:\n  shows \"supp (x # xs) = supp x \\<union> supp xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (x # xs) = supp x \\<union> supp xs", "by (simp add: supp_def Collect_imp_eq Collect_neg_eq)"], ["", "lemma fresh_Cons:\n  shows \"a \\<sharp> (x # xs) \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> x # xs = (a \\<sharp> x \\<and> a \\<sharp> xs)", "by (simp add: fresh_def supp_Cons)"], ["", "lemma supp_append:\n  shows \"supp (xs @ ys) = supp xs \\<union> supp ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (xs @ ys) = supp xs \\<union> supp ys", "by (induct xs) (auto simp: supp_Nil supp_Cons)"], ["", "lemma fresh_append:\n  shows \"a \\<sharp> (xs @ ys) \\<longleftrightarrow> a \\<sharp> xs \\<and> a \\<sharp> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> xs @ ys = (a \\<sharp> xs \\<and> a \\<sharp> ys)", "by (induct xs) (simp_all add: fresh_Nil fresh_Cons)"], ["", "lemma supp_rev:\n  shows \"supp (rev xs) = supp xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (rev xs) = supp xs", "by (induct xs) (auto simp: supp_append supp_Cons supp_Nil)"], ["", "lemma fresh_rev:\n  shows \"a \\<sharp> rev xs \\<longleftrightarrow> a \\<sharp> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> rev xs = a \\<sharp> xs", "by (induct xs) (auto simp: fresh_append fresh_Cons fresh_Nil)"], ["", "lemma supp_removeAll:\n  fixes x::\"atom\"\n  shows \"supp (removeAll x xs) = supp xs - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (removeAll x xs) = supp xs - {x}", "by (induct xs)\n     (auto simp: supp_Nil supp_Cons supp_atom)"], ["", "lemma supp_of_atom_list:\n  fixes as::\"atom list\"\n  shows \"supp as = set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp as = set as", "by (induct as)\n   (simp_all add: supp_Nil supp_Cons supp_atom)"], ["", "instance list :: (fs) fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, fs_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. finite (supp x)", "apply (induct_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. finite (supp [])\n 2. \\<And>x a list.\n       finite (supp list) \\<Longrightarrow> finite (supp (a # list))", "apply (simp_all add: supp_Nil supp_Cons finite_supp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>Support and Freshness for Applications\\<close>"], ["", "lemma fresh_conv_MOST:\n  shows \"a \\<sharp> x \\<longleftrightarrow> (MOST b. (a \\<rightleftharpoons> b) \\<bullet> x = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> x =\n    (\\<forall>\\<^sub>\\<infinity>b.\n        (a \\<rightleftharpoons> b) \\<bullet> x = x)", "unfolding fresh_def supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> {a. infinite\n                     {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq>\n                         x}}) =\n    (\\<forall>\\<^sub>\\<infinity>b.\n        (a \\<rightleftharpoons> b) \\<bullet> x = x)", "unfolding MOST_iff_cofinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> {a. infinite\n                     {b. (a \\<rightleftharpoons> b) \\<bullet> x \\<noteq>\n                         x}}) =\n    finite {xa. (a \\<rightleftharpoons> xa) \\<bullet> x \\<noteq> x}", "by simp"], ["", "lemma fresh_fun_app:\n  assumes \"a \\<sharp> f\" and \"a \\<sharp> x\"\n  shows \"a \\<sharp> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> f x", "using assms"], ["proof (prove)\nusing this:\n  a \\<sharp> f\n  a \\<sharp> x\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x", "unfolding fresh_conv_MOST"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>\\<infinity>b. (a \\<rightleftharpoons> b) \\<bullet> f = f\n  \\<forall>\\<^sub>\\<infinity>b. (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>b.\n       (a \\<rightleftharpoons> b) \\<bullet> f x = f x", "unfolding permute_fun_app_eq"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>\\<infinity>b. (a \\<rightleftharpoons> b) \\<bullet> f = f\n  \\<forall>\\<^sub>\\<infinity>b. (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>b.\n       ((a \\<rightleftharpoons> b) \\<bullet> f)\n        ((a \\<rightleftharpoons> b) \\<bullet> x) =\n       f x", "by (elim MOST_rev_mp) (simp)"], ["", "lemma supp_fun_app:\n  shows \"supp (f x) \\<subseteq> (supp f) \\<union> (supp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (f x) \\<subseteq> supp f \\<union> supp x", "using fresh_fun_app"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<sharp> ?f; ?a \\<sharp> ?x\\<rbrakk>\n  \\<Longrightarrow> ?a \\<sharp> ?f ?x\n\ngoal (1 subgoal):\n 1. supp (f x) \\<subseteq> supp f \\<union> supp x", "unfolding fresh_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<notin> supp ?f; ?a \\<notin> supp ?x\\<rbrakk>\n  \\<Longrightarrow> ?a \\<notin> supp (?f ?x)\n\ngoal (1 subgoal):\n 1. supp (f x) \\<subseteq> supp f \\<union> supp x", "by auto"], ["", "subsection \\<open>Equivariance Predicate \\<open>eqvt\\<close> and \\<open>eqvt_at\\<close>\\<close>"], ["", "definition\n  \"eqvt f \\<equiv> \\<forall>p. p \\<bullet> f = f\""], ["", "lemma eqvt_boolI:\n  fixes f::\"bool\"\n  shows \"eqvt f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt f", "unfolding eqvt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. p \\<bullet> f = f", "by (simp add: permute_bool_def)"], ["", "text \\<open>equivariance of a function at a given argument\\<close>"], ["", "definition\n \"eqvt_at f x \\<equiv> \\<forall>p. p \\<bullet> (f x) = f (p \\<bullet> x)\""], ["", "lemma eqvtI:\n  shows \"(\\<And>p. p \\<bullet> f \\<equiv> f) \\<Longrightarrow> eqvt f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p. p \\<bullet> f \\<equiv> f) \\<Longrightarrow> eqvt f", "unfolding eqvt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p. p \\<bullet> f \\<equiv> f) \\<Longrightarrow>\n    \\<forall>p. p \\<bullet> f = f", "by simp"], ["", "lemma eqvt_at_perm:\n  assumes \"eqvt_at f x\"\n  shows \"eqvt_at f (q \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "fix p::\"perm\""], ["proof (state)\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "have \"p \\<bullet> (f (q \\<bullet> x)) = p \\<bullet> q \\<bullet> (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f (q \\<bullet> x) = p \\<bullet> q \\<bullet> f x", "using assms"], ["proof (prove)\nusing this:\n  eqvt_at f x\n\ngoal (1 subgoal):\n 1. p \\<bullet> f (q \\<bullet> x) = p \\<bullet> q \\<bullet> f x", "by (simp add: eqvt_at_def)"], ["proof (state)\nthis:\n  p \\<bullet> f (q \\<bullet> x) = p \\<bullet> q \\<bullet> f x\n\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "also"], ["proof (state)\nthis:\n  p \\<bullet> f (q \\<bullet> x) = p \\<bullet> q \\<bullet> f x\n\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "have \"\\<dots> = (p + q) \\<bullet> (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> q \\<bullet> f x = (p + q) \\<bullet> f x", "by simp"], ["proof (state)\nthis:\n  p \\<bullet> q \\<bullet> f x = (p + q) \\<bullet> f x\n\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "also"], ["proof (state)\nthis:\n  p \\<bullet> q \\<bullet> f x = (p + q) \\<bullet> f x\n\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "have \"\\<dots> = f ((p + q) \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> f x = f ((p + q) \\<bullet> x)", "using assms"], ["proof (prove)\nusing this:\n  eqvt_at f x\n\ngoal (1 subgoal):\n 1. (p + q) \\<bullet> f x = f ((p + q) \\<bullet> x)", "by (simp only: eqvt_at_def)"], ["proof (state)\nthis:\n  (p + q) \\<bullet> f x = f ((p + q) \\<bullet> x)\n\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "finally"], ["proof (chain)\npicking this:\n  p \\<bullet> f (q \\<bullet> x) = f ((p + q) \\<bullet> x)", "have \"p \\<bullet> (f (q \\<bullet> x)) = f (p \\<bullet> q \\<bullet> x)\""], ["proof (prove)\nusing this:\n  p \\<bullet> f (q \\<bullet> x) = f ((p + q) \\<bullet> x)\n\ngoal (1 subgoal):\n 1. p \\<bullet> f (q \\<bullet> x) = f (p \\<bullet> q \\<bullet> x)", "by simp"], ["proof (state)\nthis:\n  p \\<bullet> f (q \\<bullet> x) = f (p \\<bullet> q \\<bullet> x)\n\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "}"], ["proof (state)\nthis:\n  ?p2 \\<bullet> f (q \\<bullet> x) = f (?p2 \\<bullet> q \\<bullet> x)\n\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "then"], ["proof (chain)\npicking this:\n  ?p2 \\<bullet> f (q \\<bullet> x) = f (?p2 \\<bullet> q \\<bullet> x)", "show \"eqvt_at f (q \\<bullet> x)\""], ["proof (prove)\nusing this:\n  ?p2 \\<bullet> f (q \\<bullet> x) = f (?p2 \\<bullet> q \\<bullet> x)\n\ngoal (1 subgoal):\n 1. eqvt_at f (q \\<bullet> x)", "unfolding eqvt_at_def"], ["proof (prove)\nusing this:\n  ?p2 \\<bullet> f (q \\<bullet> x) = f (?p2 \\<bullet> q \\<bullet> x)\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       p \\<bullet> f (q \\<bullet> x) = f (p \\<bullet> q \\<bullet> x)", "by simp"], ["proof (state)\nthis:\n  eqvt_at f (q \\<bullet> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_fun_eqvt:\n  assumes a: \"eqvt f\"\n  shows \"supp f = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp f = {}", "using a"], ["proof (prove)\nusing this:\n  eqvt f\n\ngoal (1 subgoal):\n 1. supp f = {}", "unfolding eqvt_def"], ["proof (prove)\nusing this:\n  \\<forall>p. p \\<bullet> f = f\n\ngoal (1 subgoal):\n 1. supp f = {}", "unfolding supp_def"], ["proof (prove)\nusing this:\n  \\<forall>p. p \\<bullet> f = f\n\ngoal (1 subgoal):\n 1. {a. infinite {b. (a \\<rightleftharpoons> b) \\<bullet> f \\<noteq> f}} =\n    {}", "by simp"], ["", "lemma fresh_fun_eqvt:\n  assumes a: \"eqvt f\"\n  shows \"a \\<sharp> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> f", "using a"], ["proof (prove)\nusing this:\n  eqvt f\n\ngoal (1 subgoal):\n 1. a \\<sharp> f", "unfolding fresh_def"], ["proof (prove)\nusing this:\n  eqvt f\n\ngoal (1 subgoal):\n 1. a \\<notin> supp f", "by (simp add: supp_fun_eqvt)"], ["", "lemma fresh_fun_eqvt_app:\n  assumes a: \"eqvt f\"\n  shows \"a \\<sharp> x \\<Longrightarrow> a \\<sharp> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> x \\<Longrightarrow> a \\<sharp> f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<sharp> x \\<Longrightarrow> a \\<sharp> f x", "from a"], ["proof (chain)\npicking this:\n  eqvt f", "have \"supp f = {}\""], ["proof (prove)\nusing this:\n  eqvt f\n\ngoal (1 subgoal):\n 1. supp f = {}", "by (simp add: supp_fun_eqvt)"], ["proof (state)\nthis:\n  supp f = {}\n\ngoal (1 subgoal):\n 1. a \\<sharp> x \\<Longrightarrow> a \\<sharp> f x", "then"], ["proof (chain)\npicking this:\n  supp f = {}", "show \"a \\<sharp> x \\<Longrightarrow> a \\<sharp> f x\""], ["proof (prove)\nusing this:\n  supp f = {}\n\ngoal (1 subgoal):\n 1. a \\<sharp> x \\<Longrightarrow> a \\<sharp> f x", "unfolding fresh_def"], ["proof (prove)\nusing this:\n  supp f = {}\n\ngoal (1 subgoal):\n 1. a \\<notin> supp x \\<Longrightarrow> a \\<notin> supp (f x)", "using supp_fun_app"], ["proof (prove)\nusing this:\n  supp f = {}\n  supp (?f ?x) \\<subseteq> supp ?f \\<union> supp ?x\n\ngoal (1 subgoal):\n 1. a \\<notin> supp x \\<Longrightarrow> a \\<notin> supp (f x)", "by auto"], ["proof (state)\nthis:\n  a \\<sharp> x \\<Longrightarrow> a \\<sharp> f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_fun_app_eqvt:\n  assumes a: \"eqvt f\"\n  shows \"supp (f x) \\<subseteq> supp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (f x) \\<subseteq> supp x", "using fresh_fun_eqvt_app[OF a]"], ["proof (prove)\nusing this:\n  ?a \\<sharp> ?x \\<Longrightarrow> ?a \\<sharp> f ?x\n\ngoal (1 subgoal):\n 1. supp (f x) \\<subseteq> supp x", "unfolding fresh_def"], ["proof (prove)\nusing this:\n  ?a \\<notin> supp ?x \\<Longrightarrow> ?a \\<notin> supp (f ?x)\n\ngoal (1 subgoal):\n 1. supp (f x) \\<subseteq> supp x", "by auto"], ["", "lemma supp_eqvt_at:\n  assumes asm: \"eqvt_at f x\"\n  and     fin: \"finite (supp x)\"\n  shows \"supp (f x) \\<subseteq> supp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (f x) \\<subseteq> supp x", "apply(rule supp_is_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. supp x supports f x\n 2. finite (supp x)", "unfolding supports_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>a b.\n       a \\<notin> supp x \\<and> b \\<notin> supp x \\<longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> f x = f x\n 2. finite (supp x)", "unfolding fresh_def[symmetric]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>a b.\n       a \\<sharp> x \\<and> b \\<sharp> x \\<longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> f x = f x\n 2. finite (supp x)", "using asm"], ["proof (prove)\nusing this:\n  eqvt_at f x\n\ngoal (2 subgoals):\n 1. \\<forall>a b.\n       a \\<sharp> x \\<and> b \\<sharp> x \\<longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> f x = f x\n 2. finite (supp x)", "apply(simp add: eqvt_at_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>p.\n       (p \\<bullet> f) (p \\<bullet> x) = f (p \\<bullet> x) \\<Longrightarrow>\n    \\<forall>a b.\n       a \\<sharp> x \\<and> b \\<sharp> x \\<longrightarrow>\n       f ((a \\<rightleftharpoons> b) \\<bullet> x) = f x\n 2. finite (supp x)", "apply(simp add: swap_fresh_fresh)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp x)", "apply(rule fin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_supp_eqvt_at:\n  assumes asm: \"eqvt_at f x\"\n  and     fin: \"finite (supp x)\"\n  shows \"finite (supp (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp (f x))", "apply(rule finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. supp (f x) \\<subseteq> ?B\n 2. finite ?B", "apply(rule supp_eqvt_at[OF asm fin])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp x)", "apply(rule fin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fresh_eqvt_at:\n  assumes asm: \"eqvt_at f x\"\n  and     fin: \"finite (supp x)\"\n  and     fresh: \"a \\<sharp> x\"\n  shows \"a \\<sharp> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> f x", "using fresh"], ["proof (prove)\nusing this:\n  a \\<sharp> x\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x", "unfolding fresh_def"], ["proof (prove)\nusing this:\n  a \\<notin> supp x\n\ngoal (1 subgoal):\n 1. a \\<notin> supp (f x)", "using supp_eqvt_at[OF asm fin]"], ["proof (prove)\nusing this:\n  a \\<notin> supp x\n  supp (f x) \\<subseteq> supp x\n\ngoal (1 subgoal):\n 1. a \\<notin> supp (f x)", "by auto"], ["", "text \\<open>for handling of freshness of functions\\<close>"], ["", "simproc_setup fresh_fun_simproc (\"a \\<sharp> (f::'a::pt \\<Rightarrow>'b::pt)\") = \\<open>fn _ => fn ctxt => fn ctrm =>\n  let\n    val _ $ _ $ f = Thm.term_of ctrm\n  in\n    case (Term.add_frees f [], Term.add_vars f []) of\n      ([], []) => SOME(@{thm fresh_fun_eqvt[simplified eqvt_def, THEN Eq_TrueI]})\n    | (x::_, []) =>\n      let\n        val argx = Free x\n        val absf = absfree x f\n        val cty_inst =\n          [SOME (Thm.ctyp_of ctxt (fastype_of argx)), SOME (Thm.ctyp_of ctxt (fastype_of f))]\n        val ctrm_inst = [NONE, SOME (Thm.cterm_of ctxt absf), SOME (Thm.cterm_of ctxt argx)]\n        val thm = Thm.instantiate' cty_inst ctrm_inst @{thm fresh_fun_app}\n      in\n        SOME(thm RS @{thm Eq_TrueI})\n      end\n    | (_, _) => NONE\n  end\n\\<close>"], ["", "subsection \\<open>helper functions for \\<open>nominal_functions\\<close>\\<close>"], ["", "lemma THE_defaultI2:\n  assumes \"\\<exists>!x. P x\" \"\\<And>x. P x \\<Longrightarrow> Q x\"\n  shows \"Q (THE_default d P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (THE_default d P)", "by (iprover intro: assms THE_defaultI')"], ["", "lemma the_default_eqvt:\n  assumes unique: \"\\<exists>!x. P x\"\n  shows \"(p \\<bullet> (THE_default d P)) = (THE_default (p \\<bullet> d) (p \\<bullet> P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> THE_default d P =\n    THE_default (p \\<bullet> d) (p \\<bullet> P)", "apply(rule THE_default1_equality [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>!x. (p \\<bullet> P) x\n 2. (p \\<bullet> P) (p \\<bullet> THE_default d P)", "apply(rule_tac p=\"-p\" in permute_boolE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - p \\<bullet> (\\<exists>!x. (p \\<bullet> P) x)\n 2. (p \\<bullet> P) (p \\<bullet> THE_default d P)", "apply(simp add: ex1_eqvt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>!x. P x\n 2. (p \\<bullet> P) (p \\<bullet> THE_default d P)", "apply(rule unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> P) (p \\<bullet> THE_default d P)", "apply(rule_tac p=\"-p\" in permute_boolE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<bullet> (p \\<bullet> P) (p \\<bullet> THE_default d P)", "apply(rule subst[OF permute_fun_app_eq])"], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<bullet> p \\<bullet> P (THE_default d P)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (THE_default d P)", "apply(rule THE_defaultI'[OF unique])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fundef_ex1_eqvt:\n  fixes x::\"'a::pt\"\n  assumes f_def: \"f == (\\<lambda>x::'a. THE_default (d x) (G x))\"\n  assumes eqvt: \"eqvt G\"\n  assumes ex1: \"\\<exists>!y. G x y\"\n  shows \"(p \\<bullet> (f x)) = f (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f x = f (p \\<bullet> x)", "apply(simp only: f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> THE_default (d x) (G x) =\n    THE_default (d (p \\<bullet> x)) (G (p \\<bullet> x))", "apply(subst the_default_eqvt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ex1 (G x)\n 2. THE_default (p \\<bullet> d x) (p \\<bullet> G x) =\n    THE_default (d (p \\<bullet> x)) (G (p \\<bullet> x))", "apply(rule ex1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. THE_default (p \\<bullet> d x) (p \\<bullet> G x) =\n    THE_default (d (p \\<bullet> x)) (G (p \\<bullet> x))", "apply(rule THE_default1_equality [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>!xa. G (p \\<bullet> x) xa\n 2. G (p \\<bullet> x) (THE_default (p \\<bullet> d x) (p \\<bullet> G x))", "apply(rule_tac p=\"-p\" in permute_boolE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - p \\<bullet> (\\<exists>!xa. G (p \\<bullet> x) xa)\n 2. G (p \\<bullet> x) (THE_default (p \\<bullet> d x) (p \\<bullet> G x))", "apply(perm_simp add: permute_minus_cancel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ex1 ((- p \\<bullet> G) x)\n 2. G (p \\<bullet> x) (THE_default (p \\<bullet> d x) (p \\<bullet> G x))", "using eqvt[simplified eqvt_def]"], ["proof (prove)\nusing this:\n  \\<forall>p. p \\<bullet> G = G\n\ngoal (2 subgoals):\n 1. Ex1 ((- p \\<bullet> G) x)\n 2. G (p \\<bullet> x) (THE_default (p \\<bullet> d x) (p \\<bullet> G x))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>p. p \\<bullet> G = G \\<Longrightarrow> Ex1 (G x)\n 2. G (p \\<bullet> x) (THE_default (p \\<bullet> d x) (p \\<bullet> G x))", "apply(rule ex1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G (p \\<bullet> x) (THE_default (p \\<bullet> d x) (p \\<bullet> G x))", "apply(rule THE_defaultI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>!xa. (p \\<bullet> G x) xa\n 2. \\<And>xa. (p \\<bullet> G x) xa \\<Longrightarrow> G (p \\<bullet> x) xa", "apply(rule_tac p=\"-p\" in permute_boolE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - p \\<bullet> (\\<exists>!xa. (p \\<bullet> G x) xa)\n 2. \\<And>xa. (p \\<bullet> G x) xa \\<Longrightarrow> G (p \\<bullet> x) xa", "apply(perm_simp add: permute_minus_cancel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ex1 (G x)\n 2. \\<And>xa. (p \\<bullet> G x) xa \\<Longrightarrow> G (p \\<bullet> x) xa", "apply(rule ex1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. (p \\<bullet> G x) xa \\<Longrightarrow> G (p \\<bullet> x) xa", "apply(perm_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (p \\<bullet> G) (p \\<bullet> x) xa \\<Longrightarrow>\n       G (p \\<bullet> x) xa", "using eqvt[simplified eqvt_def]"], ["proof (prove)\nusing this:\n  \\<forall>p. p \\<bullet> G = G\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (p \\<bullet> G) (p \\<bullet> x) xa \\<Longrightarrow>\n       G (p \\<bullet> x) xa", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fundef_ex1_eqvt_at:\n  fixes x::\"'a::pt\"\n  assumes f_def: \"f == (\\<lambda>x::'a. THE_default (d x) (G x))\"\n  assumes eqvt: \"eqvt G\"\n  assumes ex1: \"\\<exists>!y. G x y\"\n  shows \"eqvt_at f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt_at f x", "unfolding eqvt_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. p \\<bullet> f x = f (p \\<bullet> x)", "using assms"], ["proof (prove)\nusing this:\n  f \\<equiv> \\<lambda>x. THE_default (d x) (G x)\n  eqvt G\n  \\<exists>!y. G x y\n\ngoal (1 subgoal):\n 1. \\<forall>p. p \\<bullet> f x = f (p \\<bullet> x)", "by (auto intro: fundef_ex1_eqvt)"], ["", "lemma fundef_ex1_prop:\n  fixes x::\"'a::pt\"\n  assumes f_def: \"f == (\\<lambda>x::'a. THE_default (d x) (G x))\"\n  assumes P_all: \"\\<And>x y. G x y \\<Longrightarrow> P x y\"\n  assumes ex1: \"\\<exists>!y. G x y\"\n  shows \"P x (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x (f x)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P x (THE_default (d x) (G x))", "using ex1"], ["proof (prove)\nusing this:\n  \\<exists>!y. G x y\n\ngoal (1 subgoal):\n 1. P x (THE_default (d x) (G x))", "apply(erule_tac ex1E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>G x y; \\<forall>ya. G x ya \\<longrightarrow> ya = y\\<rbrakk>\n       \\<Longrightarrow> P x (THE_default (d x) (G x))", "apply(rule THE_defaultI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>G x y; \\<forall>ya. G x ya \\<longrightarrow> ya = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!xa. G x xa\n 2. \\<And>y xa.\n       \\<lbrakk>G x y; \\<forall>ya. G x ya \\<longrightarrow> ya = y;\n        G x xa\\<rbrakk>\n       \\<Longrightarrow> P x xa", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y xa.\n       \\<lbrakk>G x y; \\<forall>ya. G x ya \\<longrightarrow> ya = y;\n        G x xa\\<rbrakk>\n       \\<Longrightarrow> P x xa", "apply(rule P_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y xa.\n       \\<lbrakk>G x y; \\<forall>ya. G x ya \\<longrightarrow> ya = y;\n        G x xa\\<rbrakk>\n       \\<Longrightarrow> G x xa", "apply(assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>Support of Finite Sets of Finitely Supported Elements\\<close>"], ["", "text \\<open>support and freshness for atom sets\\<close>"], ["", "lemma supp_finite_atom_set:\n  fixes S::\"atom set\"\n  assumes \"finite S\"\n  shows \"supp S = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp S = S", "apply(rule finite_supp_unique)"], ["proof (prove)\ngoal (3 subgoals):\n 1. S supports S\n 2. finite S\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> S; b \\<notin> S; sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S", "apply(simp add: supports_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>a b.\n       a \\<notin> S \\<and> b \\<notin> S \\<longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> S = S\n 2. finite S\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> S; b \\<notin> S; sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S", "apply(simp add: swap_set_not_in)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite S\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> S; b \\<notin> S; sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S", "apply(rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> S; b \\<notin> S; sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S", "apply(simp add: swap_set_in)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma supp_cofinite_atom_set:\n  fixes S::\"atom set\"\n  assumes \"finite (UNIV - S)\"\n  shows \"supp S = (UNIV - S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp S = UNIV - S", "apply(rule finite_supp_unique)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (UNIV - S) supports S\n 2. finite (UNIV - S)\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> UNIV - S; b \\<notin> UNIV - S;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S", "apply(simp add: supports_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>a b.\n       a \\<in> S \\<and> b \\<in> S \\<longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> S = S\n 2. finite (UNIV - S)\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> UNIV - S; b \\<notin> UNIV - S;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S", "apply(simp add: swap_set_both_in)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (UNIV - S)\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> UNIV - S; b \\<notin> UNIV - S;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S", "apply(rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> UNIV - S; b \\<notin> UNIV - S;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S", "apply(subst swap_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> UNIV - S; b \\<notin> UNIV - S;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> (b \\<rightleftharpoons> a) \\<bullet> S \\<noteq> S", "apply(simp add: swap_set_in)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fresh_finite_atom_set:\n  fixes S::\"atom set\"\n  assumes \"finite S\"\n  shows \"a \\<sharp> S \\<longleftrightarrow> a \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> S = (a \\<notin> S)", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp S) = (a \\<notin> S)", "by (simp add: supp_finite_atom_set[OF assms])"], ["", "lemma fresh_minus_atom_set:\n  fixes S::\"atom set\"\n  assumes \"finite S\"\n  shows \"a \\<sharp> S - T \\<longleftrightarrow> (a \\<notin> T \\<longrightarrow> a \\<sharp> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> S - T = (a \\<notin> T \\<longrightarrow> a \\<sharp> S)", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp (S - T)) =\n    (a \\<notin> T \\<longrightarrow> a \\<notin> supp S)", "by (auto simp: supp_finite_atom_set assms)"], ["", "lemma Union_supports_set:\n  shows \"(\\<Union>x \\<in> S. supp x) supports S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) supports S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) supports S", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) supports S", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) supports S", "have \"\\<forall>x \\<in> S. (a \\<rightleftharpoons> b) \\<bullet> x = x \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> S = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S.\n       (a \\<rightleftharpoons> b) \\<bullet> x = x \\<Longrightarrow>\n    (a \\<rightleftharpoons> b) \\<bullet> S = S", "unfolding permute_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S.\n       (a \\<rightleftharpoons> b) \\<bullet> x = x \\<Longrightarrow>\n    {(a \\<rightleftharpoons> b) \\<bullet> x |x. x \\<in> S} = S", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S.\n     (a \\<rightleftharpoons> b) \\<bullet> x = x \\<Longrightarrow>\n  (a \\<rightleftharpoons> b) \\<bullet> S = S\n\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) supports S", "}"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S.\n     (?a2 \\<rightleftharpoons> ?b2) \\<bullet> x = x \\<Longrightarrow>\n  (?a2 \\<rightleftharpoons> ?b2) \\<bullet> S = S\n\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) supports S", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S.\n     (?a2 \\<rightleftharpoons> ?b2) \\<bullet> x = x \\<Longrightarrow>\n  (?a2 \\<rightleftharpoons> ?b2) \\<bullet> S = S", "show \"(\\<Union>x \\<in> S. supp x) supports S\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S.\n     (?a2 \\<rightleftharpoons> ?b2) \\<bullet> x = x \\<Longrightarrow>\n  (?a2 \\<rightleftharpoons> ?b2) \\<bullet> S = S\n\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) supports S", "unfolding supports_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S.\n     (?a2 \\<rightleftharpoons> ?b2) \\<bullet> x = x \\<Longrightarrow>\n  (?a2 \\<rightleftharpoons> ?b2) \\<bullet> S = S\n\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       a \\<notin> \\<Union> (supp ` S) \\<and>\n       b \\<notin> \\<Union> (supp ` S) \\<longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> S = S", "by (simp add: fresh_def[symmetric] swap_fresh_fresh)"], ["proof (state)\nthis:\n  \\<Union> (supp ` S) supports S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Union_of_finite_supp_sets:\n  fixes S::\"('a::fs set)\"\n  assumes fin: \"finite S\"\n  shows \"finite (\\<Union>x\\<in>S. supp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (supp ` S))", "using fin"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (supp ` S))", "by (induct) (auto simp: finite_supp)"], ["", "lemma Union_included_in_supp:\n  fixes S::\"('a::fs set)\"\n  assumes fin: \"finite S\"\n  shows \"(\\<Union>x\\<in>S. supp x) \\<subseteq> supp S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) \\<subseteq> supp S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) \\<subseteq> supp S", "have eqvt: \"eqvt (\\<lambda>S. \\<Union>x \\<in> S. supp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt (\\<lambda>S. \\<Union> (supp ` S))", "unfolding eqvt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       p \\<bullet> (\\<lambda>S. \\<Union> (supp ` S)) =\n       (\\<lambda>S. \\<Union> (supp ` S))", "by simp"], ["proof (state)\nthis:\n  eqvt (\\<lambda>S. \\<Union> (supp ` S))\n\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) \\<subseteq> supp S", "have \"(\\<Union>x\\<in>S. supp x) = supp (\\<Union>x\\<in>S. supp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) = supp (\\<Union> (supp ` S))", "by (rule supp_finite_atom_set[symmetric]) (rule Union_of_finite_supp_sets[OF fin])"], ["proof (state)\nthis:\n  \\<Union> (supp ` S) = supp (\\<Union> (supp ` S))\n\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) \\<subseteq> supp S", "also"], ["proof (state)\nthis:\n  \\<Union> (supp ` S) = supp (\\<Union> (supp ` S))\n\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) \\<subseteq> supp S", "have \"\\<dots> \\<subseteq> supp S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (\\<Union> (supp ` S)) \\<subseteq> supp S", "using eqvt"], ["proof (prove)\nusing this:\n  eqvt (\\<lambda>S. \\<Union> (supp ` S))\n\ngoal (1 subgoal):\n 1. supp (\\<Union> (supp ` S)) \\<subseteq> supp S", "by (rule supp_fun_app_eqvt)"], ["proof (state)\nthis:\n  supp (\\<Union> (supp ` S)) \\<subseteq> supp S\n\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) \\<subseteq> supp S", "finally"], ["proof (chain)\npicking this:\n  \\<Union> (supp ` S) \\<subseteq> supp S", "show \"(\\<Union>x\\<in>S. supp x) \\<subseteq> supp S\""], ["proof (prove)\nusing this:\n  \\<Union> (supp ` S) \\<subseteq> supp S\n\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) \\<subseteq> supp S", "."], ["proof (state)\nthis:\n  \\<Union> (supp ` S) \\<subseteq> supp S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_of_finite_sets:\n  fixes S::\"('a::fs set)\"\n  assumes fin: \"finite S\"\n  shows \"(supp S) = (\\<Union>x\\<in>S. supp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp S = \\<Union> (supp ` S)", "apply(rule subset_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. supp S \\<subseteq> \\<Union> (supp ` S)\n 2. \\<Union> (supp ` S) \\<subseteq> supp S", "apply(rule supp_is_subset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<Union> (supp ` S) supports S\n 2. finite (\\<Union> (supp ` S))\n 3. \\<Union> (supp ` S) \\<subseteq> supp S", "apply(rule Union_supports_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (\\<Union> (supp ` S))\n 2. \\<Union> (supp ` S) \\<subseteq> supp S", "apply(rule Union_of_finite_supp_sets[OF fin])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) \\<subseteq> supp S", "apply(rule Union_included_in_supp[OF fin])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_sets_supp:\n  fixes S::\"('a::fs set)\"\n  assumes \"finite S\"\n  shows \"finite (supp S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp S)", "using assms"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. finite (supp S)", "by (simp only: supp_of_finite_sets Union_of_finite_supp_sets)"], ["", "lemma supp_of_finite_union:\n  fixes S T::\"('a::fs) set\"\n  assumes fin1: \"finite S\"\n  and     fin2: \"finite T\"\n  shows \"supp (S \\<union> T) = supp S \\<union> supp T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (S \\<union> T) = supp S \\<union> supp T", "using fin1 fin2"], ["proof (prove)\nusing this:\n  finite S\n  finite T\n\ngoal (1 subgoal):\n 1. supp (S \\<union> T) = supp S \\<union> supp T", "by (simp add: supp_of_finite_sets)"], ["", "lemma fresh_finite_union:\n  fixes S T::\"('a::fs) set\"\n  assumes fin1: \"finite S\"\n  and     fin2: \"finite T\"\n  shows \"a \\<sharp> (S \\<union> T) \\<longleftrightarrow> a \\<sharp> S \\<and> a \\<sharp> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> S \\<union> T = (a \\<sharp> S \\<and> a \\<sharp> T)", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp (S \\<union> T)) =\n    (a \\<notin> supp S \\<and> a \\<notin> supp T)", "by (simp add: supp_of_finite_union[OF fin1 fin2])"], ["", "lemma supp_of_finite_insert:\n  fixes S::\"('a::fs) set\"\n  assumes fin:  \"finite S\"\n  shows \"supp (insert x S) = supp x \\<union> supp S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (insert x S) = supp x \\<union> supp S", "using fin"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. supp (insert x S) = supp x \\<union> supp S", "by (simp add: supp_of_finite_sets)"], ["", "lemma fresh_finite_insert:\n  fixes S::\"('a::fs) set\"\n  assumes fin:  \"finite S\"\n  shows \"a \\<sharp> (insert x S) \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> insert x S = (a \\<sharp> x \\<and> a \\<sharp> S)", "using fin"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. a \\<sharp> insert x S = (a \\<sharp> x \\<and> a \\<sharp> S)", "unfolding fresh_def"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. (a \\<notin> supp (insert x S)) =\n    (a \\<notin> supp x \\<and> a \\<notin> supp S)", "by (simp add: supp_of_finite_insert)"], ["", "lemma supp_set_empty:\n  shows \"supp {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp {} = {}", "unfolding supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. infinite {b. (a \\<rightleftharpoons> b) \\<bullet> {} \\<noteq> {}}} =\n    {}", "by (simp add: empty_eqvt)"], ["", "lemma fresh_set_empty:\n  shows \"a \\<sharp> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> {}", "by (simp add: fresh_def supp_set_empty)"], ["", "lemma supp_set:\n  fixes xs :: \"('a::fs) list\"\n  shows \"supp (set xs) = supp xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (set xs) = supp xs", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. supp (set []) = supp []\n 2. \\<And>a xs.\n       supp (set xs) = supp xs \\<Longrightarrow>\n       supp (set (a # xs)) = supp (a # xs)", "apply(simp add: supp_set_empty supp_Nil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       supp (set xs) = supp xs \\<Longrightarrow>\n       supp (set (a # xs)) = supp (a # xs)", "apply(simp add: supp_Cons supp_of_finite_insert)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fresh_set:\n  fixes xs :: \"('a::fs) list\"\n  shows \"a \\<sharp> (set xs) \\<longleftrightarrow> a \\<sharp> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> set xs = a \\<sharp> xs", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp (set xs)) = (a \\<notin> supp xs)", "by (simp add: supp_set)"], ["", "subsection \\<open>Type @{typ \"'a multiset\"} is finitely supported\\<close>"], ["", "lemma set_mset_eqvt [eqvt]:\n  shows \"p \\<bullet> (set_mset M) = set_mset (p \\<bullet> M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> set_mset M = set_mset (p \\<bullet> M)", "by (induct M) (simp_all add: insert_eqvt empty_eqvt)"], ["", "lemma supp_set_mset:\n  shows \"supp (set_mset M) \\<subseteq> supp M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (set_mset M) \\<subseteq> supp M", "apply (rule supp_fun_app_eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt set_mset", "unfolding eqvt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. p \\<bullet> set_mset = set_mset", "apply(perm_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. set_mset = set_mset", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Union_finite_multiset:\n  fixes M::\"'a::fs multiset\"\n  shows \"finite (\\<Union>{supp x | x. x \\<in># M})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> {supp x |x. x \\<in># M})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (\\<Union> {supp x |x. x \\<in># M})", "have \"finite (\\<Union>(supp ` {x. x \\<in># M}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (supp ` {x. x \\<in># M}))", "by (induct M) (simp_all add: Collect_imp_eq Collect_neg_eq finite_supp)"], ["proof (state)\nthis:\n  finite (\\<Union> (supp ` {x. x \\<in># M}))\n\ngoal (1 subgoal):\n 1. finite (\\<Union> {supp x |x. x \\<in># M})", "then"], ["proof (chain)\npicking this:\n  finite (\\<Union> (supp ` {x. x \\<in># M}))", "show \"finite (\\<Union>{supp x | x. x \\<in># M})\""], ["proof (prove)\nusing this:\n  finite (\\<Union> (supp ` {x. x \\<in># M}))\n\ngoal (1 subgoal):\n 1. finite (\\<Union> {supp x |x. x \\<in># M})", "by (simp only: image_Collect)"], ["proof (state)\nthis:\n  finite (\\<Union> {supp x |x. x \\<in># M})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Union_supports_multiset:\n  shows \"\\<Union>{supp x | x. x \\<in># M} supports M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} supports M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} supports M", "have sw: \"\\<And>a b. ((\\<And>x. x \\<in># M \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x) \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> M = M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (\\<And>x.\n           x \\<in># M \\<Longrightarrow>\n           (a \\<rightleftharpoons> b) \\<bullet> x = x) \\<Longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> M = M", "unfolding permute_multiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (\\<And>x.\n           x \\<in># M \\<Longrightarrow>\n           (a \\<rightleftharpoons> b) \\<bullet> x = x) \\<Longrightarrow>\n       image_mset (permute (a \\<rightleftharpoons> b)) M = M", "by (induct M) simp_all"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in># M \\<Longrightarrow>\n      (?a \\<rightleftharpoons> ?b) \\<bullet> x = x) \\<Longrightarrow>\n  (?a \\<rightleftharpoons> ?b) \\<bullet> M = M\n\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} supports M", "have \"(\\<Union>x\\<in>set_mset M. supp x) supports M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` set_mset M) supports M", "by (auto intro!: sw swap_fresh_fresh simp add: fresh_def supports_def)"], ["proof (state)\nthis:\n  \\<Union> (supp ` set_mset M) supports M\n\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} supports M", "also"], ["proof (state)\nthis:\n  \\<Union> (supp ` set_mset M) supports M\n\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} supports M", "have \"(\\<Union>x\\<in>set_mset M. supp x) = (\\<Union>{supp x | x. x \\<in># M})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` set_mset M) = \\<Union> {supp x |x. x \\<in># M}", "by auto"], ["proof (state)\nthis:\n  \\<Union> (supp ` set_mset M) = \\<Union> {supp x |x. x \\<in># M}\n\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} supports M", "finally"], ["proof (chain)\npicking this:\n  \\<Union> {supp x |x. x \\<in># M} supports M", "show \"(\\<Union>{supp x | x. x \\<in># M}) supports M\""], ["proof (prove)\nusing this:\n  \\<Union> {supp x |x. x \\<in># M} supports M\n\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} supports M", "."], ["proof (state)\nthis:\n  \\<Union> {supp x |x. x \\<in># M} supports M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Union_included_multiset:\n  fixes M::\"('a::fs multiset)\"\n  shows \"(\\<Union>{supp x | x. x \\<in># M}) \\<subseteq> supp M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "have \"(\\<Union>{supp x | x. x \\<in># M}) = (\\<Union>x \\<in> set_mset M. supp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} = \\<Union> (supp ` set_mset M)", "by auto"], ["proof (state)\nthis:\n  \\<Union> {supp x |x. x \\<in># M} = \\<Union> (supp ` set_mset M)\n\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "also"], ["proof (state)\nthis:\n  \\<Union> {supp x |x. x \\<in># M} = \\<Union> (supp ` set_mset M)\n\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "have \"... = supp (set_mset M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` set_mset M) = supp (set_mset M)", "by (simp add: supp_of_finite_sets)"], ["proof (state)\nthis:\n  \\<Union> (supp ` set_mset M) = supp (set_mset M)\n\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "also"], ["proof (state)\nthis:\n  \\<Union> (supp ` set_mset M) = supp (set_mset M)\n\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "have \" ... \\<subseteq> supp M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (set_mset M) \\<subseteq> supp M", "by (rule supp_set_mset)"], ["proof (state)\nthis:\n  supp (set_mset M) \\<subseteq> supp M\n\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "finally"], ["proof (chain)\npicking this:\n  \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "show \"(\\<Union>{supp x | x. x \\<in># M}) \\<subseteq> supp M\""], ["proof (prove)\nusing this:\n  \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M\n\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "."], ["proof (state)\nthis:\n  \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_of_multisets:\n  fixes M::\"('a::fs multiset)\"\n  shows \"(supp M) = (\\<Union>{supp x | x. x \\<in># M})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp M = \\<Union> {supp x |x. x \\<in># M}", "apply(rule subset_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. supp M \\<subseteq> \\<Union> {supp x |x. x \\<in># M}\n 2. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "apply(rule supp_is_subset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<Union> {supp x |x. x \\<in># M} supports M\n 2. finite (\\<Union> {supp x |x. x \\<in># M})\n 3. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "apply(rule Union_supports_multiset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (\\<Union> {supp x |x. x \\<in># M})\n 2. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "apply(rule Union_finite_multiset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {supp x |x. x \\<in># M} \\<subseteq> supp M", "apply(rule Union_included_multiset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma multisets_supp_finite:\n  fixes M::\"('a::fs multiset)\"\n  shows \"finite (supp M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp M)", "by (simp only: supp_of_multisets Union_finite_multiset)"], ["", "lemma supp_of_multiset_union:\n  fixes M N::\"('a::fs) multiset\"\n  shows \"supp (M + N) = supp M \\<union> supp N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (M + N) = supp M \\<union> supp N", "by (auto simp: supp_of_multisets)"], ["", "lemma supp_empty_mset [simp]:\n  shows \"supp {#} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp {#} = {}", "unfolding supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. infinite\n         {b. (a \\<rightleftharpoons> b) \\<bullet> {#} \\<noteq> {#}}} =\n    {}", "by simp"], ["", "instance multiset :: (fs) fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a multiset, fs_class)", "by standard (rule multisets_supp_finite)"], ["", "subsection \\<open>Type @{typ \"'a fset\"} is finitely supported\\<close>"], ["", "lemma supp_fset [simp]:\n  shows \"supp (fset S) = supp S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (fset S) = supp S", "unfolding supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. infinite\n         {b. (a \\<rightleftharpoons> b) \\<bullet> fset S \\<noteq> fset S}} =\n    {a. infinite {b. (a \\<rightleftharpoons> b) \\<bullet> S \\<noteq> S}}", "by (simp add: fset_eqvt fset_cong)"], ["", "lemma supp_empty_fset [simp]:\n  shows \"supp {||} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp {||} = {}", "unfolding supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. infinite\n         {b. (a \\<rightleftharpoons> b) \\<bullet> {||} \\<noteq> {||}}} =\n    {}", "by simp"], ["", "lemma fresh_empty_fset:\n  shows \"a \\<sharp> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> {||}", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> supp {||}", "by (simp)"], ["", "lemma supp_finsert [simp]:\n  fixes x::\"'a::fs\"\n  and   S::\"'a fset\"\n  shows \"supp (finsert x S) = supp x \\<union> supp S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (finsert x S) = supp x \\<union> supp S", "apply(subst supp_fset[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (fset (finsert x S)) = supp x \\<union> supp S", "apply(simp add: supp_of_finite_insert)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fresh_finsert:\n  fixes x::\"'a::fs\"\n  and   S::\"'a fset\"\n  shows \"a \\<sharp> finsert x S \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> finsert x S = (a \\<sharp> x \\<and> a \\<sharp> S)", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp (finsert x S)) =\n    (a \\<notin> supp x \\<and> a \\<notin> supp S)", "by simp"], ["", "lemma fset_finite_supp:\n  fixes S::\"('a::fs) fset\"\n  shows \"finite (supp S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp S)", "by (induct S) (simp_all add: finite_supp)"], ["", "lemma supp_union_fset:\n  fixes S T::\"'a::fs fset\"\n  shows \"supp (S |\\<union>| T) = supp S \\<union> supp T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (S |\\<union>| T) = supp S \\<union> supp T", "by (induct S) (auto)"], ["", "lemma fresh_union_fset:\n  fixes S T::\"'a::fs fset\"\n  shows \"a \\<sharp> S |\\<union>| T \\<longleftrightarrow> a \\<sharp> S \\<and> a \\<sharp> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> S |\\<union>| T = (a \\<sharp> S \\<and> a \\<sharp> T)", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp (S |\\<union>| T)) =\n    (a \\<notin> supp S \\<and> a \\<notin> supp T)", "by (simp add: supp_union_fset)"], ["", "instance fset :: (fs) fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a fset, fs_class)", "by standard (rule fset_finite_supp)"], ["", "subsection \\<open>Type @{typ \"('a, 'b) finfun\"} is finitely supported\\<close>"], ["", "lemma fresh_finfun_const:\n  shows \"a \\<sharp> (finfun_const b) \\<longleftrightarrow> a \\<sharp> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> finfun_const b = a \\<sharp> b", "by (simp add: fresh_def supp_def)"], ["", "lemma fresh_finfun_update:\n  shows \"\\<lbrakk>a \\<sharp> f; a \\<sharp> x; a \\<sharp> y\\<rbrakk> \\<Longrightarrow> a \\<sharp> finfun_update f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<sharp> f; a \\<sharp> x; a \\<sharp> y\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> finfun_update f x y", "unfolding fresh_conv_MOST"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<^sub>\\<infinity>b.\n                (a \\<rightleftharpoons> b) \\<bullet> f = f;\n     \\<forall>\\<^sub>\\<infinity>b.\n        (a \\<rightleftharpoons> b) \\<bullet> x = x;\n     \\<forall>\\<^sub>\\<infinity>b.\n        (a \\<rightleftharpoons> b) \\<bullet> y = y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>\\<infinity>b.\n                         (a \\<rightleftharpoons> b) \\<bullet> finfun_update\n                         f x y =\n                         finfun_update f x y", "unfolding finfun_update_eqvt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<^sub>\\<infinity>b.\n                (a \\<rightleftharpoons> b) \\<bullet> f = f;\n     \\<forall>\\<^sub>\\<infinity>b.\n        (a \\<rightleftharpoons> b) \\<bullet> x = x;\n     \\<forall>\\<^sub>\\<infinity>b.\n        (a \\<rightleftharpoons> b) \\<bullet> y = y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>\\<infinity>b.\n                         finfun_update\n                          ((a \\<rightleftharpoons> b) \\<bullet> f)\n                          ((a \\<rightleftharpoons> b) \\<bullet> x)\n                          ((a \\<rightleftharpoons> b) \\<bullet> y) =\n                         finfun_update f x y", "by (elim MOST_rev_mp) (simp)"], ["", "lemma supp_finfun_const:\n  shows \"supp (finfun_const b) = supp(b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (finfun_const b) = supp b", "by (simp add: supp_def)"], ["", "lemma supp_finfun_update:\n  shows \"supp (finfun_update f x y) \\<subseteq> supp(f, x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (finfun_update f x y) \\<subseteq> supp (f, x, y)", "using fresh_finfun_update"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<sharp> ?f; ?a \\<sharp> ?x; ?a \\<sharp> ?y\\<rbrakk>\n  \\<Longrightarrow> ?a \\<sharp> finfun_update ?f ?x ?y\n\ngoal (1 subgoal):\n 1. supp (finfun_update f x y) \\<subseteq> supp (f, x, y)", "by (auto simp: fresh_def supp_Pair)"], ["", "instance finfun :: (fs, fs) fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) finfun, fs_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. finite (supp x)", "apply(induct_tac x rule: finfun_weak_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x b. finite (supp (finfun_const b))\n 2. \\<And>x f a b.\n       finite (supp f) \\<Longrightarrow> finite (supp (finfun_update f a b))", "apply(simp add: supp_finfun_const finite_supp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x f a b.\n       finite (supp f) \\<Longrightarrow> finite (supp (finfun_update f a b))", "apply(rule finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x f a b.\n       finite (supp f) \\<Longrightarrow>\n       supp (finfun_update f a b) \\<subseteq> ?B4 x f a b\n 2. \\<And>x f a b. finite (supp f) \\<Longrightarrow> finite (?B4 x f a b)", "apply(rule supp_finfun_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x f a b. finite (supp f) \\<Longrightarrow> finite (supp (f, a, b))", "apply(simp add: supp_Pair finite_supp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>Freshness and Fresh-Star\\<close>"], ["", "lemma fresh_Unit_elim:\n  shows \"(a \\<sharp> () \\<Longrightarrow> PROP C) \\<equiv> PROP C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sharp> () \\<Longrightarrow> PROP C) \\<equiv> PROP C", "by (simp add: fresh_Unit)"], ["", "lemma fresh_Pair_elim:\n  shows \"(a \\<sharp> (x, y) \\<Longrightarrow> PROP C) \\<equiv> (a \\<sharp> x \\<Longrightarrow> a \\<sharp> y \\<Longrightarrow> PROP C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sharp> (x, y) \\<Longrightarrow> PROP C) \\<equiv>\n    (\\<lbrakk>a \\<sharp> x; a \\<sharp> y\\<rbrakk> \\<Longrightarrow> PROP C)", "by rule (simp_all add: fresh_Pair)"], ["", "(* this rule needs to be added before the fresh_prodD is *)\n(* added to the simplifier with mksimps                  *)"], ["", "lemma [simp]:\n  shows \"a \\<sharp> x1 \\<Longrightarrow> a \\<sharp> x2 \\<Longrightarrow> a \\<sharp> (x1, x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<sharp> x1; a \\<sharp> x2\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> (x1, x2)", "by (simp add: fresh_Pair)"], ["", "lemma fresh_PairD:\n  shows \"a \\<sharp> (x, y) \\<Longrightarrow> a \\<sharp> x\"\n  and   \"a \\<sharp> (x, y) \\<Longrightarrow> a \\<sharp> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sharp> (x, y) \\<Longrightarrow> a \\<sharp> x) &&&\n    (a \\<sharp> (x, y) \\<Longrightarrow> a \\<sharp> y)", "by (simp_all add: fresh_Pair)"], ["", "declaration \\<open>fn _ =>\nlet\n  val mksimps_pairs = (@{const_name Nominal2_Base.fresh}, @{thms fresh_PairD}) :: mksimps_pairs\nin\n  Simplifier.map_ss (fn ss => Simplifier.set_mksimps (mksimps mksimps_pairs) ss)\nend\n\\<close>"], ["", "text \\<open>The fresh-star generalisation of fresh is used in strong\n  induction principles.\\<close>"], ["", "definition\n  fresh_star :: \"atom set \\<Rightarrow> 'a::pt \\<Rightarrow> bool\" (\"_ \\<sharp>* _\" [80,80] 80)\nwhere\n  \"as \\<sharp>* x \\<equiv> \\<forall>a \\<in> as. a \\<sharp> x\""], ["", "lemma fresh_star_supp_conv:\n  shows \"supp x \\<sharp>* y \\<Longrightarrow> supp y \\<sharp>* x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp x \\<sharp>* y \\<Longrightarrow> supp y \\<sharp>* x", "by (auto simp: fresh_star_def fresh_def)"], ["", "lemma fresh_star_perm_set_conv:\n  fixes p::\"perm\"\n  assumes fresh: \"as \\<sharp>* p\"\n  and     fin: \"finite as\"\n  shows \"supp p \\<sharp>* as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp p \\<sharp>* as", "apply(rule fresh_star_supp_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. supp as \\<sharp>* p", "apply(simp add: supp_finite_atom_set fin fresh)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fresh_star_atom_set_conv:\n  assumes fresh: \"as \\<sharp>* bs\"\n  and     fin: \"finite as\" \"finite bs\"\n  shows \"bs \\<sharp>* as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs \\<sharp>* as", "using fresh"], ["proof (prove)\nusing this:\n  as \\<sharp>* bs\n\ngoal (1 subgoal):\n 1. bs \\<sharp>* as", "unfolding fresh_star_def fresh_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>as. a \\<notin> supp bs\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>bs. a \\<notin> supp as", "by (auto simp: supp_finite_atom_set fin)"], ["", "lemma atom_fresh_star_disjoint:\n  assumes fin: \"finite bs\"\n  shows \"as \\<sharp>* bs \\<longleftrightarrow> (as \\<inter> bs = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<sharp>* bs = (as \\<inter> bs = {})", "unfolding fresh_star_def fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>as. a \\<notin> supp bs) = (as \\<inter> bs = {})", "by (auto simp: supp_finite_atom_set fin)"], ["", "lemma fresh_star_Pair:\n  shows \"as \\<sharp>* (x, y) = (as \\<sharp>* x \\<and> as \\<sharp>* y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<sharp>* (x, y) = (as \\<sharp>* x \\<and> as \\<sharp>* y)", "by (auto simp: fresh_star_def fresh_Pair)"], ["", "lemma fresh_star_list:\n  shows \"as \\<sharp>* (xs @ ys) \\<longleftrightarrow> as \\<sharp>* xs \\<and> as \\<sharp>* ys\"\n  and   \"as \\<sharp>* (x # xs) \\<longleftrightarrow> as \\<sharp>* x \\<and> as \\<sharp>* xs\"\n  and   \"as \\<sharp>* []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<sharp>* (xs @ ys) = (as \\<sharp>* xs \\<and> as \\<sharp>* ys) &&&\n    as \\<sharp>* (x # xs) = (as \\<sharp>* x \\<and> as \\<sharp>* xs) &&&\n    as \\<sharp>* []", "by (auto simp: fresh_star_def fresh_Nil fresh_Cons fresh_append)"], ["", "lemma fresh_star_set:\n  fixes xs::\"('a::fs) list\"\n  shows \"as \\<sharp>* set xs \\<longleftrightarrow> as \\<sharp>* xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<sharp>* set xs = as \\<sharp>* xs", "unfolding fresh_star_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>as. a \\<sharp> set xs) =\n    (\\<forall>a\\<in>as. a \\<sharp> xs)", "by (simp add: fresh_set)"], ["", "lemma fresh_star_singleton:\n  fixes a::\"atom\"\n  shows \"as \\<sharp>* {a} \\<longleftrightarrow> as \\<sharp>* a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<sharp>* {a} = as \\<sharp>* a", "by (simp add: fresh_star_def fresh_finite_insert fresh_set_empty)"], ["", "lemma fresh_star_fset:\n  fixes xs::\"('a::fs) list\"\n  shows \"as \\<sharp>* fset S \\<longleftrightarrow> as \\<sharp>* S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<sharp>* fset S = as \\<sharp>* S", "by (simp add: fresh_star_def fresh_def)"], ["", "lemma fresh_star_Un:\n  shows \"(as \\<union> bs) \\<sharp>* x = (as \\<sharp>* x \\<and> bs \\<sharp>* x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (as \\<union> bs) \\<sharp>* x = (as \\<sharp>* x \\<and> bs \\<sharp>* x)", "by (auto simp: fresh_star_def)"], ["", "lemma fresh_star_insert:\n  shows \"(insert a as) \\<sharp>* x = (a \\<sharp> x \\<and> as \\<sharp>* x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert a as \\<sharp>* x = (a \\<sharp> x \\<and> as \\<sharp>* x)", "by (auto simp: fresh_star_def)"], ["", "lemma fresh_star_Un_elim:\n  \"((as \\<union> bs) \\<sharp>* x \\<Longrightarrow> PROP C) \\<equiv> (as \\<sharp>* x \\<Longrightarrow> bs \\<sharp>* x \\<Longrightarrow> PROP C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((as \\<union> bs) \\<sharp>* x \\<Longrightarrow> PROP C) \\<equiv>\n    (\\<lbrakk>as \\<sharp>* x; bs \\<sharp>* x\\<rbrakk>\n     \\<Longrightarrow> PROP C)", "unfolding fresh_star_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>as \\<union> bs. a \\<sharp> x \\<Longrightarrow>\n     PROP C) \\<equiv>\n    (\\<lbrakk>\\<forall>a\\<in>as. a \\<sharp> x;\n      \\<forall>a\\<in>bs. a \\<sharp> x\\<rbrakk>\n     \\<Longrightarrow> PROP C)", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>as \\<union> bs. a \\<sharp> x \\<Longrightarrow>\n             PROP C;\n     \\<forall>a\\<in>as. a \\<sharp> x;\n     \\<forall>a\\<in>bs. a \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> PROP C\n 2. \\<lbrakk>\\<lbrakk>\\<forall>a\\<in>as. a \\<sharp> x;\n              \\<forall>a\\<in>bs. a \\<sharp> x\\<rbrakk>\n             \\<Longrightarrow> PROP C;\n     \\<forall>a\\<in>as \\<union> bs. a \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> PROP C", "apply(erule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>as. a \\<sharp> x;\n     \\<forall>a\\<in>bs. a \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>as \\<union> bs. a \\<sharp> x\n 2. \\<lbrakk>\\<lbrakk>\\<forall>a\\<in>as. a \\<sharp> x;\n              \\<forall>a\\<in>bs. a \\<sharp> x\\<rbrakk>\n             \\<Longrightarrow> PROP C;\n     \\<forall>a\\<in>as \\<union> bs. a \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> PROP C", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fresh_star_insert_elim:\n  \"(insert a as \\<sharp>* x \\<Longrightarrow> PROP C) \\<equiv> (a \\<sharp> x \\<Longrightarrow> as \\<sharp>* x \\<Longrightarrow> PROP C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (insert a as \\<sharp>* x \\<Longrightarrow> PROP C) \\<equiv>\n    (\\<lbrakk>a \\<sharp> x; as \\<sharp>* x\\<rbrakk>\n     \\<Longrightarrow> PROP C)", "unfolding fresh_star_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>insert a as. a \\<sharp> x \\<Longrightarrow>\n     PROP C) \\<equiv>\n    (\\<lbrakk>a \\<sharp> x; \\<forall>a\\<in>as. a \\<sharp> x\\<rbrakk>\n     \\<Longrightarrow> PROP C)", "by rule (simp_all add: fresh_star_def)"], ["", "lemma fresh_star_empty_elim:\n  \"({} \\<sharp>* x \\<Longrightarrow> PROP C) \\<equiv> PROP C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({} \\<sharp>* x \\<Longrightarrow> PROP C) \\<equiv> PROP C", "by (simp add: fresh_star_def)"], ["", "lemma fresh_star_Unit_elim:\n  shows \"(a \\<sharp>* () \\<Longrightarrow> PROP C) \\<equiv> PROP C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sharp>* () \\<Longrightarrow> PROP C) \\<equiv> PROP C", "by (simp add: fresh_star_def fresh_Unit)"], ["", "lemma fresh_star_Pair_elim:\n  shows \"(a \\<sharp>* (x, y) \\<Longrightarrow> PROP C) \\<equiv> (a \\<sharp>* x \\<Longrightarrow> a \\<sharp>* y \\<Longrightarrow> PROP C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sharp>* (x, y) \\<Longrightarrow> PROP C) \\<equiv>\n    (\\<lbrakk>a \\<sharp>* x; a \\<sharp>* y\\<rbrakk>\n     \\<Longrightarrow> PROP C)", "by (rule, simp_all add: fresh_star_Pair)"], ["", "lemma fresh_star_zero:\n  shows \"as \\<sharp>* (0::perm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<sharp>* 0", "unfolding fresh_star_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>as. a \\<sharp> 0", "by (simp add: fresh_zero_perm)"], ["", "lemma fresh_star_plus:\n  fixes p q::perm\n  shows \"\\<lbrakk>a \\<sharp>* p;  a \\<sharp>* q\\<rbrakk> \\<Longrightarrow> a \\<sharp>* (p + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<sharp>* p; a \\<sharp>* q\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp>* (p + q)", "unfolding fresh_star_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>a. a \\<sharp> p;\n     \\<forall>a\\<in>a. a \\<sharp> q\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>a. a \\<sharp> p + q", "by (simp add: fresh_plus_perm)"], ["", "lemma fresh_star_permute_iff:\n  shows \"(p \\<bullet> a) \\<sharp>* (p \\<bullet> x) \\<longleftrightarrow> a \\<sharp>* x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> a) \\<sharp>* (p \\<bullet> x) = a \\<sharp>* x", "unfolding fresh_star_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>p \\<bullet> a. a \\<sharp> p \\<bullet> x) =\n    (\\<forall>a\\<in>a. a \\<sharp> x)", "by (metis mem_permute_iff permute_minus_cancel(1) fresh_permute_iff)"], ["", "lemma fresh_star_eqvt [eqvt]:\n  shows \"p \\<bullet> (as \\<sharp>* x) \\<longleftrightarrow> (p \\<bullet> as) \\<sharp>* (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> as \\<sharp>* x = (p \\<bullet> as) \\<sharp>* (p \\<bullet> x)", "unfolding fresh_star_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (\\<forall>a\\<in>as. a \\<sharp> x) =\n    (\\<forall>a\\<in>p \\<bullet> as. a \\<sharp> p \\<bullet> x)", "by simp"], ["", "section \\<open>Induction principle for permutations\\<close>"], ["", "lemma smaller_supp:\n  assumes a: \"a \\<in> supp p\"\n  shows \"supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p", "have \"supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> supp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> supp p", "unfolding supp_perm"], ["proof (prove)\ngoal (1 subgoal):\n 1. {aa.\n     ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<bullet> aa \\<noteq> aa}\n    \\<subseteq> {a. p \\<bullet> a \\<noteq> a}", "by (auto simp: swap_atom)"], ["proof (state)\nthis:\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> supp p\n\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p", "moreover"], ["proof (state)\nthis:\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> supp p\n\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p", "have \"a \\<notin> supp ((p \\<bullet> a \\<rightleftharpoons> a) + p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> supp ((p \\<bullet> a \\<rightleftharpoons> a) + p)", "by (simp add: supp_perm)"], ["proof (state)\nthis:\n  a \\<notin> supp ((p \\<bullet> a \\<rightleftharpoons> a) + p)\n\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p", "then"], ["proof (chain)\npicking this:\n  a \\<notin> supp ((p \\<bullet> a \\<rightleftharpoons> a) + p)", "have \"supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<noteq> supp p\""], ["proof (prove)\nusing this:\n  a \\<notin> supp ((p \\<bullet> a \\<rightleftharpoons> a) + p)\n\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<noteq> supp p", "using a"], ["proof (prove)\nusing this:\n  a \\<notin> supp ((p \\<bullet> a \\<rightleftharpoons> a) + p)\n  a \\<in> supp p\n\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<noteq> supp p", "by auto"], ["proof (state)\nthis:\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<noteq> supp p\n\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p", "ultimately"], ["proof (chain)\npicking this:\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> supp p\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<noteq> supp p", "show \"supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p\""], ["proof (prove)\nusing this:\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> supp p\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<noteq> supp p\n\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p", "by auto"], ["proof (state)\nthis:\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_struct_induct[consumes 1, case_names zero swap]:\n  assumes S: \"supp p \\<subseteq> S\"\n  and zero: \"P 0\"\n  and swap: \"\\<And>p a b. \\<lbrakk>P p; supp p \\<subseteq> S; a \\<in> S; b \\<in> S; a \\<noteq> b; sort_of a = sort_of b\\<rbrakk> \\<Longrightarrow> P ((a \\<rightleftharpoons> b) + p)\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P p", "have \"finite (supp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp p)", "by (simp add: finite_supp)"], ["proof (state)\nthis:\n  finite (supp p)\n\ngoal (1 subgoal):\n 1. P p", "then"], ["proof (chain)\npicking this:\n  finite (supp p)", "show \"P p\""], ["proof (prove)\nusing this:\n  finite (supp p)\n\ngoal (1 subgoal):\n 1. P p", "using S"], ["proof (prove)\nusing this:\n  finite (supp p)\n  supp p \\<subseteq> S\n\ngoal (1 subgoal):\n 1. P p", "proof(induct A\\<equiv>\"supp p\" arbitrary: p rule: finite_psubset_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "case (psubset p)"], ["proof (state)\nthis:\n  finite (supp p)\n  \\<lbrakk>supp ?p \\<subset> supp p; supp ?p \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> P ?p\n  supp p \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  finite (supp p)\n  \\<lbrakk>supp ?p \\<subset> supp p; supp ?p \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> P ?p\n  supp p \\<subseteq> S", "have ih: \"\\<And>q. supp q \\<subset> supp p \\<Longrightarrow> P q\""], ["proof (prove)\nusing this:\n  finite (supp p)\n  \\<lbrakk>supp ?p \\<subset> supp p; supp ?p \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> P ?p\n  supp p \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>q. supp q \\<subset> supp p \\<Longrightarrow> P q", "by auto"], ["proof (state)\nthis:\n  supp ?q \\<subset> supp p \\<Longrightarrow> P ?q\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "have as: \"supp p \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp p \\<subseteq> S", "by fact"], ["proof (state)\nthis:\n  supp p \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "{"], ["proof (state)\nthis:\n  supp p \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "assume \"supp p = {}\""], ["proof (state)\nthis:\n  supp p = {}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  supp p = {}", "have \"p = 0\""], ["proof (prove)\nusing this:\n  supp p = {}\n\ngoal (1 subgoal):\n 1. p = 0", "by (simp add: supp_perm perm_eq_iff)"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  p = 0", "have \"P p\""], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. P p", "using zero"], ["proof (prove)\nusing this:\n  p = 0\n  P 0\n\ngoal (1 subgoal):\n 1. P p", "by simp"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "}"], ["proof (state)\nthis:\n  supp p = {} \\<Longrightarrow> P p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "moreover"], ["proof (state)\nthis:\n  supp p = {} \\<Longrightarrow> P p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "{"], ["proof (state)\nthis:\n  supp p = {} \\<Longrightarrow> P p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "assume \"supp p \\<noteq> {}\""], ["proof (state)\nthis:\n  supp p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  supp p \\<noteq> {}", "obtain a where a0: \"a \\<in> supp p\""], ["proof (prove)\nusing this:\n  supp p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> supp p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> supp p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  a \\<in> supp p", "have a1: \"p \\<bullet> a \\<in> S\" \"a \\<in> S\" \"sort_of (p \\<bullet> a) = sort_of a\" \"p \\<bullet> a \\<noteq> a\""], ["proof (prove)\nusing this:\n  a \\<in> supp p\n\ngoal (1 subgoal):\n 1. (p \\<bullet> a \\<in> S &&& a \\<in> S) &&&\n    sort_of (p \\<bullet> a) = sort_of a &&& p \\<bullet> a \\<noteq> a", "using as"], ["proof (prove)\nusing this:\n  a \\<in> supp p\n  supp p \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (p \\<bullet> a \\<in> S &&& a \\<in> S) &&&\n    sort_of (p \\<bullet> a) = sort_of a &&& p \\<bullet> a \\<noteq> a", "by (auto simp: supp_atom supp_perm swap_atom)"], ["proof (state)\nthis:\n  p \\<bullet> a \\<in> S\n  a \\<in> S\n  sort_of (p \\<bullet> a) = sort_of a\n  p \\<bullet> a \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "let ?q = \"(p \\<bullet> a \\<rightleftharpoons> a) + p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "have a2: \"supp ?q \\<subset> supp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p", "using a0 smaller_supp"], ["proof (prove)\nusing this:\n  a \\<in> supp p\n  ?a \\<in> supp ?p \\<Longrightarrow>\n  supp ((?p \\<bullet> ?a \\<rightleftharpoons> ?a) + ?p) \\<subset> supp ?p\n\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p", "by simp"], ["proof (state)\nthis:\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p", "have \"P ?q\""], ["proof (prove)\nusing this:\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p\n\ngoal (1 subgoal):\n 1. P ((p \\<bullet> a \\<rightleftharpoons> a) + p)", "using ih"], ["proof (prove)\nusing this:\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p\n  supp ?q \\<subset> supp p \\<Longrightarrow> P ?q\n\ngoal (1 subgoal):\n 1. P ((p \\<bullet> a \\<rightleftharpoons> a) + p)", "by simp"], ["proof (state)\nthis:\n  P ((p \\<bullet> a \\<rightleftharpoons> a) + p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "moreover"], ["proof (state)\nthis:\n  P ((p \\<bullet> a \\<rightleftharpoons> a) + p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "have \"supp ?q \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> S", "using as a2"], ["proof (prove)\nusing this:\n  supp p \\<subseteq> S\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subset> supp p\n\ngoal (1 subgoal):\n 1. supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> S", "by simp"], ["proof (state)\nthis:\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "ultimately"], ["proof (chain)\npicking this:\n  P ((p \\<bullet> a \\<rightleftharpoons> a) + p)\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> S", "have \"P ((p \\<bullet> a \\<rightleftharpoons> a) + ?q)\""], ["proof (prove)\nusing this:\n  P ((p \\<bullet> a \\<rightleftharpoons> a) + p)\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. P ((p \\<bullet> a \\<rightleftharpoons> a) +\n       ((p \\<bullet> a \\<rightleftharpoons> a) + p))", "using as a1 swap"], ["proof (prove)\nusing this:\n  P ((p \\<bullet> a \\<rightleftharpoons> a) + p)\n  supp ((p \\<bullet> a \\<rightleftharpoons> a) + p) \\<subseteq> S\n  supp p \\<subseteq> S\n  p \\<bullet> a \\<in> S\n  a \\<in> S\n  sort_of (p \\<bullet> a) = sort_of a\n  p \\<bullet> a \\<noteq> a\n  \\<lbrakk>P ?p; supp ?p \\<subseteq> S; ?a \\<in> S; ?b \\<in> S;\n   ?a \\<noteq> ?b; sort_of ?a = sort_of ?b\\<rbrakk>\n  \\<Longrightarrow> P ((?a \\<rightleftharpoons> ?b) + ?p)\n\ngoal (1 subgoal):\n 1. P ((p \\<bullet> a \\<rightleftharpoons> a) +\n       ((p \\<bullet> a \\<rightleftharpoons> a) + p))", "by simp"], ["proof (state)\nthis:\n  P ((p \\<bullet> a \\<rightleftharpoons> a) +\n     ((p \\<bullet> a \\<rightleftharpoons> a) + p))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "moreover"], ["proof (state)\nthis:\n  P ((p \\<bullet> a \\<rightleftharpoons> a) +\n     ((p \\<bullet> a \\<rightleftharpoons> a) + p))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "have \"p = (p \\<bullet> a \\<rightleftharpoons> a) + ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (p \\<bullet> a \\<rightleftharpoons> a) +\n    ((p \\<bullet> a \\<rightleftharpoons> a) + p)", "by (simp add: perm_eq_iff)"], ["proof (state)\nthis:\n  p =\n  (p \\<bullet> a \\<rightleftharpoons> a) +\n  ((p \\<bullet> a \\<rightleftharpoons> a) + p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "ultimately"], ["proof (chain)\npicking this:\n  P ((p \\<bullet> a \\<rightleftharpoons> a) +\n     ((p \\<bullet> a \\<rightleftharpoons> a) + p))\n  p =\n  (p \\<bullet> a \\<rightleftharpoons> a) +\n  ((p \\<bullet> a \\<rightleftharpoons> a) + p)", "have \"P p\""], ["proof (prove)\nusing this:\n  P ((p \\<bullet> a \\<rightleftharpoons> a) +\n     ((p \\<bullet> a \\<rightleftharpoons> a) + p))\n  p =\n  (p \\<bullet> a \\<rightleftharpoons> a) +\n  ((p \\<bullet> a \\<rightleftharpoons> a) + p)\n\ngoal (1 subgoal):\n 1. P p", "by simp"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "}"], ["proof (state)\nthis:\n  supp p \\<noteq> {} \\<Longrightarrow> P p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp p);\n        \\<And>pa.\n           \\<lbrakk>supp pa \\<subset> supp p; supp pa \\<subseteq> S\\<rbrakk>\n           \\<Longrightarrow> P pa;\n        supp p \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P p", "ultimately"], ["proof (chain)\npicking this:\n  supp p = {} \\<Longrightarrow> P p\n  supp p \\<noteq> {} \\<Longrightarrow> P p", "show \"P p\""], ["proof (prove)\nusing this:\n  supp p = {} \\<Longrightarrow> P p\n  supp p \\<noteq> {} \\<Longrightarrow> P p\n\ngoal (1 subgoal):\n 1. P p", "by blast"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_simple_struct_induct[case_names zero swap]:\n  assumes zero: \"P 0\"\n  and     swap: \"\\<And>p a b. \\<lbrakk>P p; a \\<noteq> b; sort_of a = sort_of b\\<rbrakk> \\<Longrightarrow> P ((a \\<rightleftharpoons> b) + p)\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "by (rule_tac S=\"supp p\" in perm_struct_induct)\n   (auto intro: zero swap)"], ["", "lemma perm_struct_induct2[consumes 1, case_names zero swap plus]:\n  assumes S: \"supp p \\<subseteq> S\"\n  assumes zero: \"P 0\"\n  assumes swap: \"\\<And>a b. \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b; a \\<in> S; b \\<in> S\\<rbrakk> \\<Longrightarrow> P (a \\<rightleftharpoons> b)\"\n  assumes plus: \"\\<And>p1 p2. \\<lbrakk>P p1; P p2; supp p1 \\<subseteq> S; supp p2 \\<subseteq> S\\<rbrakk> \\<Longrightarrow> P (p1 + p2)\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "using S"], ["proof (prove)\nusing this:\n  supp p \\<subseteq> S\n\ngoal (1 subgoal):\n 1. P p", "by (induct p rule: perm_struct_induct)\n   (auto intro: zero plus swap simp add: supp_swap)"], ["", "lemma perm_simple_struct_induct2[case_names zero swap plus]:\n  assumes zero: \"P 0\"\n  assumes swap: \"\\<And>a b. \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b\\<rbrakk> \\<Longrightarrow> P (a \\<rightleftharpoons> b)\"\n  assumes plus: \"\\<And>p1 p2. \\<lbrakk>P p1; P p2\\<rbrakk> \\<Longrightarrow> P (p1 + p2)\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "by (rule_tac S=\"supp p\" in perm_struct_induct2)\n   (auto intro: zero swap plus)"], ["", "lemma supp_perm_singleton:\n  fixes p::\"perm\"\n  shows \"supp p \\<subseteq> {b} \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {b}) = (p = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {b}) = (p = 0)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {b}) = (p = 0)", "assume \"supp p \\<subseteq> {b}\""], ["proof (state)\nthis:\n  supp p \\<subseteq> {b}\n\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {b}) = (p = 0)", "then"], ["proof (chain)\npicking this:\n  supp p \\<subseteq> {b}", "have \"p = 0\""], ["proof (prove)\nusing this:\n  supp p \\<subseteq> {b}\n\ngoal (1 subgoal):\n 1. p = 0", "by (induct p rule: perm_struct_induct) (simp_all)"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {b}) = (p = 0)", "}"], ["proof (state)\nthis:\n  supp p \\<subseteq> {b} \\<Longrightarrow> p = 0\n\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {b}) = (p = 0)", "then"], ["proof (chain)\npicking this:\n  supp p \\<subseteq> {b} \\<Longrightarrow> p = 0", "show \"supp p \\<subseteq> {b} \\<longleftrightarrow> p = 0\""], ["proof (prove)\nusing this:\n  supp p \\<subseteq> {b} \\<Longrightarrow> p = 0\n\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {b}) = (p = 0)", "by (auto simp: supp_zero_perm)"], ["proof (state)\nthis:\n  (supp p \\<subseteq> {b}) = (p = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_perm_pair:\n  fixes p::\"perm\"\n  shows \"supp p \\<subseteq> {a, b} \\<longleftrightarrow> p = 0 \\<or> p = (b \\<rightleftharpoons> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {a, b}) =\n    (p = 0 \\<or> p = (b \\<rightleftharpoons> a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {a, b}) =\n    (p = 0 \\<or> p = (b \\<rightleftharpoons> a))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {a, b}) =\n    (p = 0 \\<or> p = (b \\<rightleftharpoons> a))", "assume \"supp p \\<subseteq> {a, b}\""], ["proof (state)\nthis:\n  supp p \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {a, b}) =\n    (p = 0 \\<or> p = (b \\<rightleftharpoons> a))", "then"], ["proof (chain)\npicking this:\n  supp p \\<subseteq> {a, b}", "have \"p = 0 \\<or> p = (b \\<rightleftharpoons> a)\""], ["proof (prove)\nusing this:\n  supp p \\<subseteq> {a, b}\n\ngoal (1 subgoal):\n 1. p = 0 \\<or> p = (b \\<rightleftharpoons> a)", "apply (induct p rule: perm_struct_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 = 0 \\<or> 0 = (b \\<rightleftharpoons> a)\n 2. \\<And>p aa ba.\n       \\<lbrakk>p = 0 \\<or> p = (b \\<rightleftharpoons> a);\n        supp p \\<subseteq> {a, b}; aa \\<in> {a, b}; ba \\<in> {a, b};\n        aa \\<noteq> ba; sort_of aa = sort_of ba\\<rbrakk>\n       \\<Longrightarrow> (aa \\<rightleftharpoons> ba) + p = 0 \\<or>\n                         (aa \\<rightleftharpoons> ba) + p =\n                         (b \\<rightleftharpoons> a)", "apply (auto simp: swap_cancel supp_zero_perm supp_swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; sort_of a = sort_of b;\n     (a \\<rightleftharpoons> b) \\<noteq> (b \\<rightleftharpoons> a)\\<rbrakk>\n    \\<Longrightarrow> (a \\<rightleftharpoons> b) = 0", "apply (simp add: swap_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  p = 0 \\<or> p = (b \\<rightleftharpoons> a)\n\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {a, b}) =\n    (p = 0 \\<or> p = (b \\<rightleftharpoons> a))", "}"], ["proof (state)\nthis:\n  supp p \\<subseteq> {a, b} \\<Longrightarrow>\n  p = 0 \\<or> p = (b \\<rightleftharpoons> a)\n\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {a, b}) =\n    (p = 0 \\<or> p = (b \\<rightleftharpoons> a))", "then"], ["proof (chain)\npicking this:\n  supp p \\<subseteq> {a, b} \\<Longrightarrow>\n  p = 0 \\<or> p = (b \\<rightleftharpoons> a)", "show \"supp p \\<subseteq> {a, b} \\<longleftrightarrow> p = 0 \\<or> p = (b \\<rightleftharpoons> a)\""], ["proof (prove)\nusing this:\n  supp p \\<subseteq> {a, b} \\<Longrightarrow>\n  p = 0 \\<or> p = (b \\<rightleftharpoons> a)\n\ngoal (1 subgoal):\n 1. (supp p \\<subseteq> {a, b}) =\n    (p = 0 \\<or> p = (b \\<rightleftharpoons> a))", "by (auto simp: supp_zero_perm supp_swap split: if_splits)"], ["proof (state)\nthis:\n  (supp p \\<subseteq> {a, b}) = (p = 0 \\<or> p = (b \\<rightleftharpoons> a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_perm_eq:\n  assumes \"(supp x) \\<sharp>* p\"\n  shows \"p \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "from assms"], ["proof (chain)\npicking this:\n  supp x \\<sharp>* p", "have \"supp p \\<subseteq> {a. a \\<sharp> x}\""], ["proof (prove)\nusing this:\n  supp x \\<sharp>* p\n\ngoal (1 subgoal):\n 1. supp p \\<subseteq> {a. a \\<sharp> x}", "unfolding supp_perm fresh_star_def fresh_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>supp x. a \\<notin> {a. p \\<bullet> a \\<noteq> a}\n\ngoal (1 subgoal):\n 1. {a. p \\<bullet> a \\<noteq> a} \\<subseteq> {a. a \\<notin> supp x}", "by auto"], ["proof (state)\nthis:\n  supp p \\<subseteq> {a. a \\<sharp> x}\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  supp p \\<subseteq> {a. a \\<sharp> x}", "show \"p \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  supp p \\<subseteq> {a. a \\<sharp> x}\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "proof (induct p rule: perm_struct_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<bullet> x = x\n 2. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> x = x; supp p \\<subseteq> {a. a \\<sharp> x};\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}; a \\<noteq> b;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> x = x", "case zero"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 \\<bullet> x = x\n 2. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> x = x; supp p \\<subseteq> {a. a \\<sharp> x};\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}; a \\<noteq> b;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> x = x", "show \"0 \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<bullet> x = x", "by simp"], ["proof (state)\nthis:\n  0 \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> x = x; supp p \\<subseteq> {a. a \\<sharp> x};\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}; a \\<noteq> b;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> x = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> x = x; supp p \\<subseteq> {a. a \\<sharp> x};\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}; a \\<noteq> b;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> x = x", "case (swap p a b)"], ["proof (state)\nthis:\n  p \\<bullet> x = x\n  supp p \\<subseteq> {a. a \\<sharp> x}\n  a \\<in> {a. a \\<sharp> x}\n  b \\<in> {a. a \\<sharp> x}\n  a \\<noteq> b\n  sort_of a = sort_of b\n\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> x = x; supp p \\<subseteq> {a. a \\<sharp> x};\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}; a \\<noteq> b;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  p \\<bullet> x = x\n  supp p \\<subseteq> {a. a \\<sharp> x}\n  a \\<in> {a. a \\<sharp> x}\n  b \\<in> {a. a \\<sharp> x}\n  a \\<noteq> b\n  sort_of a = sort_of b", "have \"a \\<sharp> x\" \"b \\<sharp> x\" \"p \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  p \\<bullet> x = x\n  supp p \\<subseteq> {a. a \\<sharp> x}\n  a \\<in> {a. a \\<sharp> x}\n  b \\<in> {a. a \\<sharp> x}\n  a \\<noteq> b\n  sort_of a = sort_of b\n\ngoal (1 subgoal):\n 1. a \\<sharp> x &&& b \\<sharp> x &&& p \\<bullet> x = x", "by simp_all"], ["proof (state)\nthis:\n  a \\<sharp> x\n  b \\<sharp> x\n  p \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> x = x; supp p \\<subseteq> {a. a \\<sharp> x};\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}; a \\<noteq> b;\n        sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  a \\<sharp> x\n  b \\<sharp> x\n  p \\<bullet> x = x", "show \"((a \\<rightleftharpoons> b) + p) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  a \\<sharp> x\n  b \\<sharp> x\n  p \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. ((a \\<rightleftharpoons> b) + p) \\<bullet> x = x", "by (simp add: swap_fresh_fresh)"], ["proof (state)\nthis:\n  ((a \\<rightleftharpoons> b) + p) \\<bullet> x = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<bullet> x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>same lemma as above, but proved with a different induction principle\\<close>"], ["", "lemma supp_perm_eq_test:\n  assumes \"(supp x) \\<sharp>* p\"\n  shows \"p \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "from assms"], ["proof (chain)\npicking this:\n  supp x \\<sharp>* p", "have \"supp p \\<subseteq> {a. a \\<sharp> x}\""], ["proof (prove)\nusing this:\n  supp x \\<sharp>* p\n\ngoal (1 subgoal):\n 1. supp p \\<subseteq> {a. a \\<sharp> x}", "unfolding supp_perm fresh_star_def fresh_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>supp x. a \\<notin> {a. p \\<bullet> a \\<noteq> a}\n\ngoal (1 subgoal):\n 1. {a. p \\<bullet> a \\<noteq> a} \\<subseteq> {a. a \\<notin> supp x}", "by auto"], ["proof (state)\nthis:\n  supp p \\<subseteq> {a. a \\<sharp> x}\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  supp p \\<subseteq> {a. a \\<sharp> x}", "show \"p \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  supp p \\<subseteq> {a. a \\<sharp> x}\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "proof (induct p rule: perm_struct_induct2)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<bullet> x = x\n 2. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 3. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "case zero"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. 0 \\<bullet> x = x\n 2. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 3. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "show \"0 \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<bullet> x = x", "by simp"], ["proof (state)\nthis:\n  0 \\<bullet> x = x\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "case (swap a b)"], ["proof (state)\nthis:\n  sort_of a = sort_of b\n  a \\<noteq> b\n  a \\<in> {a. a \\<sharp> x}\n  b \\<in> {a. a \\<sharp> x}\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  sort_of a = sort_of b\n  a \\<noteq> b\n  a \\<in> {a. a \\<sharp> x}\n  b \\<in> {a. a \\<sharp> x}", "have \"a \\<sharp> x\" \"b \\<sharp> x\""], ["proof (prove)\nusing this:\n  sort_of a = sort_of b\n  a \\<noteq> b\n  a \\<in> {a. a \\<sharp> x}\n  b \\<in> {a. a \\<sharp> x}\n\ngoal (1 subgoal):\n 1. a \\<sharp> x &&& b \\<sharp> x", "by simp_all"], ["proof (state)\nthis:\n  a \\<sharp> x\n  b \\<sharp> x\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  a \\<sharp> x\n  b \\<sharp> x", "show \"(a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  a \\<sharp> x\n  b \\<sharp> x\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "by (simp add: swap_fresh_fresh)"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "case (plus p1 p2)"], ["proof (state)\nthis:\n  p1 \\<bullet> x = x\n  p2 \\<bullet> x = x\n  supp p1 \\<subseteq> {a. a \\<sharp> x}\n  supp p2 \\<subseteq> {a. a \\<sharp> x}\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "have \"p1 \\<bullet> x = x\" \"p2 \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<bullet> x = x &&& p2 \\<bullet> x = x", "by fact+"], ["proof (state)\nthis:\n  p1 \\<bullet> x = x\n  p2 \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  p1 \\<bullet> x = x\n  p2 \\<bullet> x = x", "show \"(p1 + p2) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  p1 \\<bullet> x = x\n  p2 \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. (p1 + p2) \\<bullet> x = x", "by simp"], ["proof (state)\nthis:\n  (p1 + p2) \\<bullet> x = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<bullet> x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_supp_eq:\n  assumes a: \"(supp p) \\<sharp>* x\"\n  shows \"p \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "from assms"], ["proof (chain)\npicking this:\n  supp p \\<sharp>* x", "have \"supp p \\<subseteq> {a. a \\<sharp> x}\""], ["proof (prove)\nusing this:\n  supp p \\<sharp>* x\n\ngoal (1 subgoal):\n 1. supp p \\<subseteq> {a. a \\<sharp> x}", "unfolding supp_perm fresh_star_def fresh_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>{a. p \\<bullet> a \\<noteq> a}. a \\<notin> supp x\n\ngoal (1 subgoal):\n 1. {a. p \\<bullet> a \\<noteq> a} \\<subseteq> {a. a \\<notin> supp x}", "by auto"], ["proof (state)\nthis:\n  supp p \\<subseteq> {a. a \\<sharp> x}\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  supp p \\<subseteq> {a. a \\<sharp> x}", "show \"p \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  supp p \\<subseteq> {a. a \\<sharp> x}\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "proof (induct p rule: perm_struct_induct2)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<bullet> x = x\n 2. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 3. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "case zero"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. 0 \\<bullet> x = x\n 2. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 3. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "show \"0 \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<bullet> x = x", "by simp"], ["proof (state)\nthis:\n  0 \\<bullet> x = x\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "case (swap a b)"], ["proof (state)\nthis:\n  sort_of a = sort_of b\n  a \\<noteq> b\n  a \\<in> {a. a \\<sharp> x}\n  b \\<in> {a. a \\<sharp> x}\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  sort_of a = sort_of b\n  a \\<noteq> b\n  a \\<in> {a. a \\<sharp> x}\n  b \\<in> {a. a \\<sharp> x}", "have \"a \\<sharp> x\" \"b \\<sharp> x\""], ["proof (prove)\nusing this:\n  sort_of a = sort_of b\n  a \\<noteq> b\n  a \\<in> {a. a \\<sharp> x}\n  b \\<in> {a. a \\<sharp> x}\n\ngoal (1 subgoal):\n 1. a \\<sharp> x &&& b \\<sharp> x", "by simp_all"], ["proof (state)\nthis:\n  a \\<sharp> x\n  b \\<sharp> x\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>sort_of a = sort_of b; a \\<noteq> b;\n        a \\<in> {a. a \\<sharp> x}; b \\<in> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  a \\<sharp> x\n  b \\<sharp> x", "show \"(a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  a \\<sharp> x\n  b \\<sharp> x\n\ngoal (1 subgoal):\n 1. (a \\<rightleftharpoons> b) \\<bullet> x = x", "by (simp add: swap_fresh_fresh)"], ["proof (state)\nthis:\n  (a \\<rightleftharpoons> b) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "case (plus p1 p2)"], ["proof (state)\nthis:\n  p1 \\<bullet> x = x\n  p2 \\<bullet> x = x\n  supp p1 \\<subseteq> {a. a \\<sharp> x}\n  supp p2 \\<subseteq> {a. a \\<sharp> x}\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "have \"p1 \\<bullet> x = x\" \"p2 \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<bullet> x = x &&& p2 \\<bullet> x = x", "by fact+"], ["proof (state)\nthis:\n  p1 \\<bullet> x = x\n  p2 \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<bullet> x = x; p2 \\<bullet> x = x;\n        supp p1 \\<subseteq> {a. a \\<sharp> x};\n        supp p2 \\<subseteq> {a. a \\<sharp> x}\\<rbrakk>\n       \\<Longrightarrow> (p1 + p2) \\<bullet> x = x", "then"], ["proof (chain)\npicking this:\n  p1 \\<bullet> x = x\n  p2 \\<bullet> x = x", "show \"(p1 + p2) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  p1 \\<bullet> x = x\n  p2 \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. (p1 + p2) \\<bullet> x = x", "by simp"], ["proof (state)\nthis:\n  (p1 + p2) \\<bullet> x = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<bullet> x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_perm_perm_eq:\n  assumes a: \"\\<forall>a \\<in> supp x. p \\<bullet> a = q \\<bullet> a\"\n  shows \"p \\<bullet> x = q \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> x = q \\<bullet> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bullet> x = q \\<bullet> x", "from a"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>supp x. p \\<bullet> a = q \\<bullet> a", "have \"\\<forall>a \\<in> supp x. (-q + p) \\<bullet> a = a\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>supp x. p \\<bullet> a = q \\<bullet> a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>supp x. (- q + p) \\<bullet> a = a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>supp x. (- q + p) \\<bullet> a = a\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = q \\<bullet> x", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>supp x. (- q + p) \\<bullet> a = a", "have \"\\<forall>a \\<in> supp x. a \\<notin> supp (-q + p)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>supp x. (- q + p) \\<bullet> a = a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>supp x. a \\<notin> supp (- q + p)", "unfolding supp_perm"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>supp x. (- q + p) \\<bullet> a = a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>supp x. a \\<notin> {a. (- q + p) \\<bullet> a \\<noteq> a}", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>supp x. a \\<notin> supp (- q + p)\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = q \\<bullet> x", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>supp x. a \\<notin> supp (- q + p)", "have \"supp x \\<sharp>* (-q + p)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>supp x. a \\<notin> supp (- q + p)\n\ngoal (1 subgoal):\n 1. supp x \\<sharp>* (- q + p)", "unfolding fresh_star_def fresh_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>supp x. a \\<notin> supp (- q + p)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>supp x. a \\<notin> supp (- q + p)", "by simp"], ["proof (state)\nthis:\n  supp x \\<sharp>* (- q + p)\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = q \\<bullet> x", "then"], ["proof (chain)\npicking this:\n  supp x \\<sharp>* (- q + p)", "have \"(-q + p) \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  supp x \\<sharp>* (- q + p)\n\ngoal (1 subgoal):\n 1. (- q + p) \\<bullet> x = x", "by (simp only: supp_perm_eq)"], ["proof (state)\nthis:\n  (- q + p) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = q \\<bullet> x", "then"], ["proof (chain)\npicking this:\n  (- q + p) \\<bullet> x = x", "show \"p \\<bullet> x = q \\<bullet> x\""], ["proof (prove)\nusing this:\n  (- q + p) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = q \\<bullet> x", "by (metis permute_minus_cancel permute_plus)"], ["proof (state)\nthis:\n  p \\<bullet> x = q \\<bullet> x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>disagreement set\\<close>"], ["", "definition\n  dset :: \"perm \\<Rightarrow> perm \\<Rightarrow> atom set\"\nwhere\n  \"dset p q = {a::atom. p \\<bullet> a \\<noteq> q \\<bullet> a}\""], ["", "lemma ds_fresh:\n  assumes \"dset p q \\<sharp>* x\"\n  shows \"p \\<bullet> x = q \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> x = q \\<bullet> x", "using assms"], ["proof (prove)\nusing this:\n  dset p q \\<sharp>* x\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = q \\<bullet> x", "unfolding dset_def fresh_star_def fresh_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>{a. p \\<bullet> a \\<noteq> q \\<bullet> a}.\n     a \\<notin> supp x\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = q \\<bullet> x", "by (auto intro: supp_perm_perm_eq)"], ["", "lemma atom_set_perm_eq:\n  assumes a: \"as \\<sharp>* p\"\n  shows \"p \\<bullet> as = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> as = as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bullet> as = as", "from a"], ["proof (chain)\npicking this:\n  as \\<sharp>* p", "have \"supp p \\<subseteq> {a. a \\<notin> as}\""], ["proof (prove)\nusing this:\n  as \\<sharp>* p\n\ngoal (1 subgoal):\n 1. supp p \\<subseteq> {a. a \\<notin> as}", "unfolding supp_perm fresh_star_def fresh_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>as. a \\<notin> {a. p \\<bullet> a \\<noteq> a}\n\ngoal (1 subgoal):\n 1. {a. p \\<bullet> a \\<noteq> a} \\<subseteq> {a. a \\<notin> as}", "by auto"], ["proof (state)\nthis:\n  supp p \\<subseteq> {a. a \\<notin> as}\n\ngoal (1 subgoal):\n 1. p \\<bullet> as = as", "then"], ["proof (chain)\npicking this:\n  supp p \\<subseteq> {a. a \\<notin> as}", "show \"p \\<bullet> as = as\""], ["proof (prove)\nusing this:\n  supp p \\<subseteq> {a. a \\<notin> as}\n\ngoal (1 subgoal):\n 1. p \\<bullet> as = as", "proof (induct p rule: perm_struct_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<bullet> as = as\n 2. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> as = as; supp p \\<subseteq> {a. a \\<notin> as};\n        a \\<in> {a. a \\<notin> as}; b \\<in> {a. a \\<notin> as};\n        a \\<noteq> b; sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> as = as", "case zero"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 \\<bullet> as = as\n 2. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> as = as; supp p \\<subseteq> {a. a \\<notin> as};\n        a \\<in> {a. a \\<notin> as}; b \\<in> {a. a \\<notin> as};\n        a \\<noteq> b; sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> as = as", "show \"0 \\<bullet> as = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<bullet> as = as", "by simp"], ["proof (state)\nthis:\n  0 \\<bullet> as = as\n\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> as = as; supp p \\<subseteq> {a. a \\<notin> as};\n        a \\<in> {a. a \\<notin> as}; b \\<in> {a. a \\<notin> as};\n        a \\<noteq> b; sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> as = as", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> as = as; supp p \\<subseteq> {a. a \\<notin> as};\n        a \\<in> {a. a \\<notin> as}; b \\<in> {a. a \\<notin> as};\n        a \\<noteq> b; sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> as = as", "case (swap p a b)"], ["proof (state)\nthis:\n  p \\<bullet> as = as\n  supp p \\<subseteq> {a. a \\<notin> as}\n  a \\<in> {a. a \\<notin> as}\n  b \\<in> {a. a \\<notin> as}\n  a \\<noteq> b\n  sort_of a = sort_of b\n\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> as = as; supp p \\<subseteq> {a. a \\<notin> as};\n        a \\<in> {a. a \\<notin> as}; b \\<in> {a. a \\<notin> as};\n        a \\<noteq> b; sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> as = as", "then"], ["proof (chain)\npicking this:\n  p \\<bullet> as = as\n  supp p \\<subseteq> {a. a \\<notin> as}\n  a \\<in> {a. a \\<notin> as}\n  b \\<in> {a. a \\<notin> as}\n  a \\<noteq> b\n  sort_of a = sort_of b", "have \"a \\<notin> as\" \"b \\<notin> as\" \"p \\<bullet> as = as\""], ["proof (prove)\nusing this:\n  p \\<bullet> as = as\n  supp p \\<subseteq> {a. a \\<notin> as}\n  a \\<in> {a. a \\<notin> as}\n  b \\<in> {a. a \\<notin> as}\n  a \\<noteq> b\n  sort_of a = sort_of b\n\ngoal (1 subgoal):\n 1. a \\<notin> as &&& b \\<notin> as &&& p \\<bullet> as = as", "by simp_all"], ["proof (state)\nthis:\n  a \\<notin> as\n  b \\<notin> as\n  p \\<bullet> as = as\n\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       \\<lbrakk>p \\<bullet> as = as; supp p \\<subseteq> {a. a \\<notin> as};\n        a \\<in> {a. a \\<notin> as}; b \\<in> {a. a \\<notin> as};\n        a \\<noteq> b; sort_of a = sort_of b\\<rbrakk>\n       \\<Longrightarrow> ((a \\<rightleftharpoons> b) + p) \\<bullet> as = as", "then"], ["proof (chain)\npicking this:\n  a \\<notin> as\n  b \\<notin> as\n  p \\<bullet> as = as", "show \"((a \\<rightleftharpoons> b) + p) \\<bullet> as = as\""], ["proof (prove)\nusing this:\n  a \\<notin> as\n  b \\<notin> as\n  p \\<bullet> as = as\n\ngoal (1 subgoal):\n 1. ((a \\<rightleftharpoons> b) + p) \\<bullet> as = as", "by (simp add: swap_set_not_in)"], ["proof (state)\nthis:\n  ((a \\<rightleftharpoons> b) + p) \\<bullet> as = as\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<bullet> as = as\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Avoiding of atom sets\\<close>"], ["", "text \\<open>\n  For every set of atoms, there is another set of atoms\n  avoiding a finitely supported c and there is a permutation\n  which 'translates' between both sets.\n\\<close>"], ["", "lemma at_set_avoiding_aux:\n  fixes Xs::\"atom set\"\n  and   As::\"atom set\"\n  assumes b: \"Xs \\<subseteq> As\"\n  and     c: \"finite As\"\n  shows \"\\<exists>p. (p \\<bullet> Xs) \\<inter> As = {} \\<and> (supp p) = (Xs \\<union> (p \\<bullet> Xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p \\<bullet> Xs \\<inter> As = {} \\<and>\n       supp p = Xs \\<union> p \\<bullet> Xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p \\<bullet> Xs \\<inter> As = {} \\<and>\n       supp p = Xs \\<union> p \\<bullet> Xs", "from b c"], ["proof (chain)\npicking this:\n  Xs \\<subseteq> As\n  finite As", "have \"finite Xs\""], ["proof (prove)\nusing this:\n  Xs \\<subseteq> As\n  finite As\n\ngoal (1 subgoal):\n 1. finite Xs", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite Xs\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p \\<bullet> Xs \\<inter> As = {} \\<and>\n       supp p = Xs \\<union> p \\<bullet> Xs", "then"], ["proof (chain)\npicking this:\n  finite Xs", "show ?thesis"], ["proof (prove)\nusing this:\n  finite Xs\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p \\<bullet> Xs \\<inter> As = {} \\<and>\n       supp p = Xs \\<union> p \\<bullet> Xs", "using b"], ["proof (prove)\nusing this:\n  finite Xs\n  Xs \\<subseteq> As\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p \\<bullet> Xs \\<inter> As = {} \\<and>\n       supp p = Xs \\<union> p \\<bullet> Xs", "proof (induct rule: finite_subset_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<bullet> {} \\<inter> As = {} \\<and>\n       supp p = {} \\<union> p \\<bullet> {}\n 2. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<bullet> {} \\<inter> As = {} \\<and>\n       supp p = {} \\<union> p \\<bullet> {}\n 2. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "have \"0 \\<bullet> {} \\<inter> As = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<bullet> {} \\<inter> As = {}", "by simp"], ["proof (state)\nthis:\n  0 \\<bullet> {} \\<inter> As = {}\n\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<bullet> {} \\<inter> As = {} \\<and>\n       supp p = {} \\<union> p \\<bullet> {}\n 2. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "moreover"], ["proof (state)\nthis:\n  0 \\<bullet> {} \\<inter> As = {}\n\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<bullet> {} \\<inter> As = {} \\<and>\n       supp p = {} \\<union> p \\<bullet> {}\n 2. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "have \"supp (0::perm) = {} \\<union> 0 \\<bullet> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp 0 = {} \\<union> 0 \\<bullet> {}", "by (simp add: supp_zero_perm)"], ["proof (state)\nthis:\n  supp 0 = {} \\<union> 0 \\<bullet> {}\n\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<bullet> {} \\<inter> As = {} \\<and>\n       supp p = {} \\<union> p \\<bullet> {}\n 2. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<bullet> {} \\<inter> As = {}\n  supp 0 = {} \\<union> 0 \\<bullet> {}", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<bullet> {} \\<inter> As = {}\n  supp 0 = {} \\<union> 0 \\<bullet> {}\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p \\<bullet> {} \\<inter> As = {} \\<and>\n       supp p = {} \\<union> p \\<bullet> {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>p.\n     p \\<bullet> {} \\<inter> As = {} \\<and>\n     supp p = {} \\<union> p \\<bullet> {}\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "case (insert x Xs)"], ["proof (state)\nthis:\n  finite Xs\n  x \\<in> As\n  x \\<notin> Xs\n  \\<exists>p.\n     p \\<bullet> Xs \\<inter> As = {} \\<and>\n     supp p = Xs \\<union> p \\<bullet> Xs\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "then"], ["proof (chain)\npicking this:\n  finite Xs\n  x \\<in> As\n  x \\<notin> Xs\n  \\<exists>p.\n     p \\<bullet> Xs \\<inter> As = {} \\<and>\n     supp p = Xs \\<union> p \\<bullet> Xs", "obtain p where\n      p1: \"(p \\<bullet> Xs) \\<inter> As = {}\" and\n      p2: \"supp p = (Xs \\<union> (p \\<bullet> Xs))\""], ["proof (prove)\nusing this:\n  finite Xs\n  x \\<in> As\n  x \\<notin> Xs\n  \\<exists>p.\n     p \\<bullet> Xs \\<inter> As = {} \\<and>\n     supp p = Xs \\<union> p \\<bullet> Xs\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<bullet> Xs \\<inter> As = {};\n         supp p = Xs \\<union> p \\<bullet> Xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<bullet> Xs \\<inter> As = {}\n  supp p = Xs \\<union> p \\<bullet> Xs\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "from \\<open>x \\<in> As\\<close> p1"], ["proof (chain)\npicking this:\n  x \\<in> As\n  p \\<bullet> Xs \\<inter> As = {}", "have \"x \\<notin> p \\<bullet> Xs\""], ["proof (prove)\nusing this:\n  x \\<in> As\n  p \\<bullet> Xs \\<inter> As = {}\n\ngoal (1 subgoal):\n 1. x \\<notin> p \\<bullet> Xs", "by fast"], ["proof (state)\nthis:\n  x \\<notin> p \\<bullet> Xs\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "with \\<open>x \\<notin> Xs\\<close> p2"], ["proof (chain)\npicking this:\n  x \\<notin> Xs\n  supp p = Xs \\<union> p \\<bullet> Xs\n  x \\<notin> p \\<bullet> Xs", "have \"x \\<notin> supp p\""], ["proof (prove)\nusing this:\n  x \\<notin> Xs\n  supp p = Xs \\<union> p \\<bullet> Xs\n  x \\<notin> p \\<bullet> Xs\n\ngoal (1 subgoal):\n 1. x \\<notin> supp p", "by fast"], ["proof (state)\nthis:\n  x \\<notin> supp p\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "hence px: \"p \\<bullet> x = x\""], ["proof (prove)\nusing this:\n  x \\<notin> supp p\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "unfolding supp_perm"], ["proof (prove)\nusing this:\n  x \\<notin> {a. p \\<bullet> a \\<noteq> a}\n\ngoal (1 subgoal):\n 1. p \\<bullet> x = x", "by simp"], ["proof (state)\nthis:\n  p \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "have \"finite (As \\<union> p \\<bullet> Xs \\<union> supp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (As \\<union> p \\<bullet> Xs \\<union> supp p)", "using \\<open>finite As\\<close> \\<open>finite Xs\\<close>"], ["proof (prove)\nusing this:\n  finite As\n  finite Xs\n\ngoal (1 subgoal):\n 1. finite (As \\<union> p \\<bullet> Xs \\<union> supp p)", "by (simp add: permute_set_eq_image finite_supp)"], ["proof (state)\nthis:\n  finite (As \\<union> p \\<bullet> Xs \\<union> supp p)\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "then"], ["proof (chain)\npicking this:\n  finite (As \\<union> p \\<bullet> Xs \\<union> supp p)", "obtain y where \"y \\<notin> (As \\<union> p \\<bullet> Xs \\<union> supp p)\" \"sort_of y = sort_of x\""], ["proof (prove)\nusing this:\n  finite (As \\<union> p \\<bullet> Xs \\<union> supp p)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<notin> As \\<union> p \\<bullet> Xs \\<union> supp p;\n         sort_of y = sort_of x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_atom)"], ["proof (state)\nthis:\n  y \\<notin> As \\<union> p \\<bullet> Xs \\<union> supp p\n  sort_of y = sort_of x\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "hence y: \"y \\<notin> As\" \"y \\<notin> p \\<bullet> Xs\" \"y \\<notin> supp p\" \"sort_of y = sort_of x\""], ["proof (prove)\nusing this:\n  y \\<notin> As \\<union> p \\<bullet> Xs \\<union> supp p\n  sort_of y = sort_of x\n\ngoal (1 subgoal):\n 1. (y \\<notin> As &&& y \\<notin> p \\<bullet> Xs) &&&\n    y \\<notin> supp p &&& sort_of y = sort_of x", "by simp_all"], ["proof (state)\nthis:\n  y \\<notin> As\n  y \\<notin> p \\<bullet> Xs\n  y \\<notin> supp p\n  sort_of y = sort_of x\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "hence py: \"p \\<bullet> y = y\" \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  y \\<notin> As\n  y \\<notin> p \\<bullet> Xs\n  y \\<notin> supp p\n  sort_of y = sort_of x\n\ngoal (1 subgoal):\n 1. p \\<bullet> y = y &&& x \\<noteq> y", "using \\<open>x \\<in> As\\<close>"], ["proof (prove)\nusing this:\n  y \\<notin> As\n  y \\<notin> p \\<bullet> Xs\n  y \\<notin> supp p\n  sort_of y = sort_of x\n  x \\<in> As\n\ngoal (1 subgoal):\n 1. p \\<bullet> y = y &&& x \\<noteq> y", "by (auto simp: supp_perm)"], ["proof (state)\nthis:\n  p \\<bullet> y = y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "let ?q = \"(x \\<rightleftharpoons> y) + p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "have q: \"?q \\<bullet> insert x Xs = insert y (p \\<bullet> Xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs =\n    insert y (p \\<bullet> Xs)", "unfolding insert_eqvt"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (((x \\<rightleftharpoons> y) + p) \\<bullet> x)\n     (((x \\<rightleftharpoons> y) + p) \\<bullet> Xs) =\n    insert y (p \\<bullet> Xs)", "using \\<open>p \\<bullet> x = x\\<close> \\<open>sort_of y = sort_of x\\<close>"], ["proof (prove)\nusing this:\n  p \\<bullet> x = x\n  sort_of y = sort_of x\n\ngoal (1 subgoal):\n 1. insert (((x \\<rightleftharpoons> y) + p) \\<bullet> x)\n     (((x \\<rightleftharpoons> y) + p) \\<bullet> Xs) =\n    insert y (p \\<bullet> Xs)", "using \\<open>x \\<notin> p \\<bullet> Xs\\<close> \\<open>y \\<notin> p \\<bullet> Xs\\<close>"], ["proof (prove)\nusing this:\n  p \\<bullet> x = x\n  sort_of y = sort_of x\n  x \\<notin> p \\<bullet> Xs\n  y \\<notin> p \\<bullet> Xs\n\ngoal (1 subgoal):\n 1. insert (((x \\<rightleftharpoons> y) + p) \\<bullet> x)\n     (((x \\<rightleftharpoons> y) + p) \\<bullet> Xs) =\n    insert y (p \\<bullet> Xs)", "by (simp add: swap_atom swap_set_not_in)"], ["proof (state)\nthis:\n  ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs =\n  insert y (p \\<bullet> Xs)\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "have \"?q \\<bullet> insert x Xs \\<inter> As = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs \\<inter> As = {}", "using \\<open>y \\<notin> As\\<close> \\<open>p \\<bullet> Xs \\<inter> As = {}\\<close>"], ["proof (prove)\nusing this:\n  y \\<notin> As\n  p \\<bullet> Xs \\<inter> As = {}\n\ngoal (1 subgoal):\n 1. ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs \\<inter> As = {}", "unfolding q"], ["proof (prove)\nusing this:\n  y \\<notin> As\n  p \\<bullet> Xs \\<inter> As = {}\n\ngoal (1 subgoal):\n 1. insert y (p \\<bullet> Xs) \\<inter> As = {}", "by simp"], ["proof (state)\nthis:\n  ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs \\<inter> As = {}\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "moreover"], ["proof (state)\nthis:\n  ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs \\<inter> As = {}\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "have \"supp (x \\<rightleftharpoons> y) \\<inter> supp p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (x \\<rightleftharpoons> y) \\<inter> supp p = {}", "using px py \\<open>sort_of y = sort_of x\\<close>"], ["proof (prove)\nusing this:\n  p \\<bullet> x = x\n  p \\<bullet> y = y\n  x \\<noteq> y\n  sort_of y = sort_of x\n\ngoal (1 subgoal):\n 1. supp (x \\<rightleftharpoons> y) \\<inter> supp p = {}", "unfolding supp_swap"], ["proof (prove)\nusing this:\n  p \\<bullet> x = x\n  p \\<bullet> y = y\n  x \\<noteq> y\n  sort_of y = sort_of x\n\ngoal (1 subgoal):\n 1. (if x = y \\<or> sort_of x \\<noteq> sort_of y then {}\n     else {x, y}) \\<inter>\n    supp p =\n    {}", "by (simp add: supp_perm)"], ["proof (state)\nthis:\n  supp (x \\<rightleftharpoons> y) \\<inter> supp p = {}\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "then"], ["proof (chain)\npicking this:\n  supp (x \\<rightleftharpoons> y) \\<inter> supp p = {}", "have \"supp ?q = (supp (x \\<rightleftharpoons> y) \\<union> supp p)\""], ["proof (prove)\nusing this:\n  supp (x \\<rightleftharpoons> y) \\<inter> supp p = {}\n\ngoal (1 subgoal):\n 1. supp ((x \\<rightleftharpoons> y) + p) =\n    supp (x \\<rightleftharpoons> y) \\<union> supp p", "by (simp add: supp_plus_perm_eq)"], ["proof (state)\nthis:\n  supp ((x \\<rightleftharpoons> y) + p) =\n  supp (x \\<rightleftharpoons> y) \\<union> supp p\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "then"], ["proof (chain)\npicking this:\n  supp ((x \\<rightleftharpoons> y) + p) =\n  supp (x \\<rightleftharpoons> y) \\<union> supp p", "have \"supp ?q = insert x Xs \\<union> ?q \\<bullet> insert x Xs\""], ["proof (prove)\nusing this:\n  supp ((x \\<rightleftharpoons> y) + p) =\n  supp (x \\<rightleftharpoons> y) \\<union> supp p\n\ngoal (1 subgoal):\n 1. supp ((x \\<rightleftharpoons> y) + p) =\n    insert x Xs \\<union>\n    ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs", "using p2 \\<open>sort_of y = sort_of x\\<close> \\<open>x \\<noteq> y\\<close>"], ["proof (prove)\nusing this:\n  supp ((x \\<rightleftharpoons> y) + p) =\n  supp (x \\<rightleftharpoons> y) \\<union> supp p\n  supp p = Xs \\<union> p \\<bullet> Xs\n  sort_of y = sort_of x\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. supp ((x \\<rightleftharpoons> y) + p) =\n    insert x Xs \\<union>\n    ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs", "unfolding q supp_swap"], ["proof (prove)\nusing this:\n  supp ((x \\<rightleftharpoons> y) + p) =\n  (if x = y \\<or> sort_of x \\<noteq> sort_of y then {} else {x, y}) \\<union>\n  supp p\n  supp p = Xs \\<union> p \\<bullet> Xs\n  sort_of y = sort_of x\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. supp ((x \\<rightleftharpoons> y) + p) =\n    insert x Xs \\<union> insert y (p \\<bullet> Xs)", "by auto"], ["proof (state)\nthis:\n  supp ((x \\<rightleftharpoons> y) + p) =\n  insert x Xs \\<union>\n  ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> As; a \\<notin> F;\n        \\<exists>p.\n           p \\<bullet> F \\<inter> As = {} \\<and>\n           supp p = F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            p \\<bullet> insert a F \\<inter> As = {} \\<and>\n                            supp p =\n                            insert a F \\<union> p \\<bullet> insert a F", "ultimately"], ["proof (chain)\npicking this:\n  ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs \\<inter> As = {}\n  supp ((x \\<rightleftharpoons> y) + p) =\n  insert x Xs \\<union>\n  ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs", "show ?case"], ["proof (prove)\nusing this:\n  ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs \\<inter> As = {}\n  supp ((x \\<rightleftharpoons> y) + p) =\n  insert x Xs \\<union>\n  ((x \\<rightleftharpoons> y) + p) \\<bullet> insert x Xs\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p \\<bullet> insert x Xs \\<inter> As = {} \\<and>\n       supp p = insert x Xs \\<union> p \\<bullet> insert x Xs", "by blast"], ["proof (state)\nthis:\n  \\<exists>p.\n     p \\<bullet> insert x Xs \\<inter> As = {} \\<and>\n     supp p = insert x Xs \\<union> p \\<bullet> insert x Xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     p \\<bullet> Xs \\<inter> As = {} \\<and>\n     supp p = Xs \\<union> p \\<bullet> Xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma at_set_avoiding:\n  assumes a: \"finite Xs\"\n  and     b: \"finite (supp c)\"\n  obtains p::\"perm\" where \"(p \\<bullet> Xs)\\<sharp>*c\" and \"(supp p) = (Xs \\<union> (p \\<bullet> Xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(p \\<bullet> Xs) \\<sharp>* c;\n         supp p = Xs \\<union> p \\<bullet> Xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a b at_set_avoiding_aux [where Xs=\"Xs\" and As=\"Xs \\<union> supp c\"]"], ["proof (prove)\nusing this:\n  finite Xs\n  finite (supp c)\n  \\<lbrakk>Xs \\<subseteq> Xs \\<union> supp c;\n   finite (Xs \\<union> supp c)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       p \\<bullet> Xs \\<inter> (Xs \\<union> supp c) =\n                       {} \\<and>\n                       supp p = Xs \\<union> p \\<bullet> Xs\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(p \\<bullet> Xs) \\<sharp>* c;\n         supp p = Xs \\<union> p \\<bullet> Xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fresh_star_def fresh_def"], ["proof (prove)\nusing this:\n  finite Xs\n  finite (supp c)\n  \\<lbrakk>Xs \\<subseteq> Xs \\<union> supp c;\n   finite (Xs \\<union> supp c)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       p \\<bullet> Xs \\<inter> (Xs \\<union> supp c) =\n                       {} \\<and>\n                       supp p = Xs \\<union> p \\<bullet> Xs\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>\\<forall>a\\<in>p \\<bullet> Xs. a \\<notin> supp c;\n         supp p = Xs \\<union> p \\<bullet> Xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma at_set_avoiding1:\n  assumes \"finite xs\"\n  and     \"finite (supp c)\"\n  shows \"\\<exists>p. (p \\<bullet> xs) \\<sharp>* c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. (p \\<bullet> xs) \\<sharp>* c", "using assms"], ["proof (prove)\nusing this:\n  finite xs\n  finite (supp c)\n\ngoal (1 subgoal):\n 1. \\<exists>p. (p \\<bullet> xs) \\<sharp>* c", "apply(erule_tac c=\"c\" in at_set_avoiding)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (supp c) \\<Longrightarrow> finite (supp c)\n 2. \\<And>p.\n       \\<lbrakk>finite (supp c); (p \\<bullet> xs) \\<sharp>* c;\n        supp p = xs \\<union> p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. (p \\<bullet> xs) \\<sharp>* c", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma at_set_avoiding2:\n  assumes \"finite xs\"\n  and     \"finite (supp c)\" \"finite (supp x)\"\n  and     \"xs \\<sharp>* x\"\n  shows \"\\<exists>p. (p \\<bullet> xs) \\<sharp>* c \\<and> supp x \\<sharp>* p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. (p \\<bullet> xs) \\<sharp>* c \\<and> supp x \\<sharp>* p", "using assms"], ["proof (prove)\nusing this:\n  finite xs\n  finite (supp c)\n  finite (supp x)\n  xs \\<sharp>* x\n\ngoal (1 subgoal):\n 1. \\<exists>p. (p \\<bullet> xs) \\<sharp>* c \\<and> supp x \\<sharp>* p", "apply(erule_tac c=\"(c, x)\" in at_set_avoiding)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x\\<rbrakk>\n    \\<Longrightarrow> finite (supp (c, x))\n 2. \\<And>p.\n       \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x;\n        (p \\<bullet> xs) \\<sharp>* (c, x);\n        supp p = xs \\<union> p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (p \\<bullet> xs) \\<sharp>* c \\<and>\n                            supp x \\<sharp>* p", "apply(simp add: supp_Pair)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x;\n        (p \\<bullet> xs) \\<sharp>* (c, x);\n        supp p = xs \\<union> p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (p \\<bullet> xs) \\<sharp>* c \\<and>\n                            supp x \\<sharp>* p", "apply(rule_tac x=\"p\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x;\n        (p \\<bullet> xs) \\<sharp>* (c, x);\n        supp p = xs \\<union> p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> (p \\<bullet> xs) \\<sharp>* c \\<and>\n                         supp x \\<sharp>* p", "apply(simp add: fresh_star_Pair)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x;\n        (p \\<bullet> xs) \\<sharp>* c \\<and> (p \\<bullet> xs) \\<sharp>* x;\n        supp p = xs \\<union> p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> supp x \\<sharp>* p", "apply(rule fresh_star_supp_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x;\n        (p \\<bullet> xs) \\<sharp>* c \\<and> (p \\<bullet> xs) \\<sharp>* x;\n        supp p = xs \\<union> p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> supp p \\<sharp>* x", "apply(auto simp: fresh_star_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma at_set_avoiding3:\n  assumes \"finite xs\"\n  and     \"finite (supp c)\" \"finite (supp x)\"\n  and     \"xs \\<sharp>* x\"\n  shows \"\\<exists>p. (p \\<bullet> xs) \\<sharp>* c \\<and> supp x \\<sharp>* p \\<and> supp p = xs \\<union> (p \\<bullet> xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       (p \\<bullet> xs) \\<sharp>* c \\<and>\n       supp x \\<sharp>* p \\<and> supp p = xs \\<union> p \\<bullet> xs", "using assms"], ["proof (prove)\nusing this:\n  finite xs\n  finite (supp c)\n  finite (supp x)\n  xs \\<sharp>* x\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       (p \\<bullet> xs) \\<sharp>* c \\<and>\n       supp x \\<sharp>* p \\<and> supp p = xs \\<union> p \\<bullet> xs", "apply(erule_tac c=\"(c, x)\" in at_set_avoiding)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x\\<rbrakk>\n    \\<Longrightarrow> finite (supp (c, x))\n 2. \\<And>p.\n       \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x;\n        (p \\<bullet> xs) \\<sharp>* (c, x);\n        supp p = xs \\<union> p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (p \\<bullet> xs) \\<sharp>* c \\<and>\n                            supp x \\<sharp>* p \\<and>\n                            supp p = xs \\<union> p \\<bullet> xs", "apply(simp add: supp_Pair)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x;\n        (p \\<bullet> xs) \\<sharp>* (c, x);\n        supp p = xs \\<union> p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (p \\<bullet> xs) \\<sharp>* c \\<and>\n                            supp x \\<sharp>* p \\<and>\n                            supp p = xs \\<union> p \\<bullet> xs", "apply(rule_tac x=\"p\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x;\n        (p \\<bullet> xs) \\<sharp>* (c, x);\n        supp p = xs \\<union> p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> (p \\<bullet> xs) \\<sharp>* c \\<and>\n                         supp x \\<sharp>* p \\<and>\n                         supp p = xs \\<union> p \\<bullet> xs", "apply(simp add: fresh_star_Pair)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x;\n        (p \\<bullet> xs) \\<sharp>* c \\<and> (p \\<bullet> xs) \\<sharp>* x;\n        supp p = xs \\<union> p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> supp x \\<sharp>* p", "apply(rule fresh_star_supp_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>finite (supp c); finite (supp x); xs \\<sharp>* x;\n        (p \\<bullet> xs) \\<sharp>* c \\<and> (p \\<bullet> xs) \\<sharp>* x;\n        supp p = xs \\<union> p \\<bullet> xs\\<rbrakk>\n       \\<Longrightarrow> supp p \\<sharp>* x", "apply(auto simp: fresh_star_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma at_set_avoiding2_atom:\n  assumes \"finite (supp c)\" \"finite (supp x)\"\n  and     b: \"a \\<sharp> x\"\n  shows \"\\<exists>p. (p \\<bullet> a) \\<sharp> c \\<and> supp x \\<sharp>* p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p", "have a: \"{a} \\<sharp>* x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<sharp>* x", "unfolding fresh_star_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{a}. a \\<sharp> x", "by (simp add: b)"], ["proof (state)\nthis:\n  {a} \\<sharp>* x\n\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p", "obtain p where p1: \"(p \\<bullet> {a}) \\<sharp>* c\" and p2: \"supp x \\<sharp>* p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(p \\<bullet> {a}) \\<sharp>* c; supp x \\<sharp>* p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using at_set_avoiding2[of \"{a}\" \"c\" \"x\"] assms a"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {a}; finite (supp c); finite (supp x);\n   {a} \\<sharp>* x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       (p \\<bullet> {a}) \\<sharp>* c \\<and>\n                       supp x \\<sharp>* p\n  finite (supp c)\n  finite (supp x)\n  a \\<sharp> x\n  {a} \\<sharp>* x\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(p \\<bullet> {a}) \\<sharp>* c; supp x \\<sharp>* p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (p \\<bullet> {a}) \\<sharp>* c\n  supp x \\<sharp>* p\n\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p", "have c: \"(p \\<bullet> a) \\<sharp> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> a \\<sharp> c", "using p1"], ["proof (prove)\nusing this:\n  (p \\<bullet> {a}) \\<sharp>* c\n\ngoal (1 subgoal):\n 1. p \\<bullet> a \\<sharp> c", "unfolding fresh_star_def Ball_def"], ["proof (prove)\nusing this:\n  \\<forall>x. x \\<in> p \\<bullet> {a} \\<longrightarrow> x \\<sharp> c\n\ngoal (1 subgoal):\n 1. p \\<bullet> a \\<sharp> c", "by(erule_tac x=\"p \\<bullet> a\" in allE) (simp add: permute_set_def)"], ["proof (state)\nthis:\n  p \\<bullet> a \\<sharp> c\n\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p", "hence \"p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p\""], ["proof (prove)\nusing this:\n  p \\<bullet> a \\<sharp> c\n\ngoal (1 subgoal):\n 1. p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p", "using p2"], ["proof (prove)\nusing this:\n  p \\<bullet> a \\<sharp> c\n  supp x \\<sharp>* p\n\ngoal (1 subgoal):\n 1. p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p", "by blast"], ["proof (state)\nthis:\n  p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p\n\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p", "then"], ["proof (chain)\npicking this:\n  p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p", "show \"\\<exists>p. (p \\<bullet> a) \\<sharp> c \\<and> supp x \\<sharp>* p\""], ["proof (prove)\nusing this:\n  p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p\n\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p", "by blast"], ["proof (state)\nthis:\n  \\<exists>p. p \\<bullet> a \\<sharp> c \\<and> supp x \\<sharp>* p\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Renaming permutations\\<close>"], ["", "lemma set_renaming_perm:\n  assumes b: \"finite bs\"\n  shows \"\\<exists>q. (\\<forall>b \\<in> bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> bs \\<union> (p \\<bullet> bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "using b"], ["proof (prove)\nusing this:\n  finite bs\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>{}. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> {} \\<union> p \\<bullet> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>{}. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> {} \\<union> p \\<bullet> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "have \"(\\<forall>b \\<in> {}. 0 \\<bullet> b = p \\<bullet> b) \\<and> supp (0::perm) \\<subseteq> {} \\<union> p \\<bullet> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>b\\<in>{}. 0 \\<bullet> b = p \\<bullet> b) \\<and>\n    supp 0 \\<subseteq> {} \\<union> p \\<bullet> {}", "by (simp add: permute_set_def supp_perm)"], ["proof (state)\nthis:\n  (\\<forall>b\\<in>{}. 0 \\<bullet> b = p \\<bullet> b) \\<and>\n  supp 0 \\<subseteq> {} \\<union> p \\<bullet> {}\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>{}. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> {} \\<union> p \\<bullet> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "then"], ["proof (chain)\npicking this:\n  (\\<forall>b\\<in>{}. 0 \\<bullet> b = p \\<bullet> b) \\<and>\n  supp 0 \\<subseteq> {} \\<union> p \\<bullet> {}", "show \"\\<exists>q. (\\<forall>b \\<in> {}. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> {} \\<union> p \\<bullet> {}\""], ["proof (prove)\nusing this:\n  (\\<forall>b\\<in>{}. 0 \\<bullet> b = p \\<bullet> b) \\<and>\n  supp 0 \\<subseteq> {} \\<union> p \\<bullet> {}\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>{}. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> {} \\<union> p \\<bullet> {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>{}. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> {} \\<union> p \\<bullet> {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "case (insert a bs)"], ["proof (state)\nthis:\n  finite bs\n  a \\<notin> bs\n  \\<exists>q.\n     (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "then"], ["proof (chain)\npicking this:\n  finite bs\n  a \\<notin> bs\n  \\<exists>q.\n     (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "have \" \\<exists>q. (\\<forall>b \\<in> bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> bs \\<union> p \\<bullet> bs\""], ["proof (prove)\nusing this:\n  finite bs\n  a \\<notin> bs\n  \\<exists>q.\n     (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "by simp"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "then"], ["proof (chain)\npicking this:\n  \\<exists>q.\n     (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "obtain q where *: \"\\<forall>b \\<in> bs. q \\<bullet> b = p \\<bullet> b\" and **: \"supp q \\<subseteq> bs \\<union> p \\<bullet> bs\""], ["proof (prove)\nusing this:\n  \\<exists>q.\n     (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b;\n         supp q \\<subseteq> bs \\<union> p \\<bullet> bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis empty_subsetI insert(3) supp_swap)"], ["proof (state)\nthis:\n  \\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "{"], ["proof (state)\nthis:\n  \\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "assume 1: \"q \\<bullet> a = p \\<bullet> a\""], ["proof (state)\nthis:\n  q \\<bullet> a = p \\<bullet> a\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "have \"\\<forall>b \\<in> (insert a bs). q \\<bullet> b = p \\<bullet> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b", "using 1 *"], ["proof (prove)\nusing this:\n  q \\<bullet> a = p \\<bullet> a\n  \\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b", "by simp"], ["proof (state)\nthis:\n  \\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "moreover"], ["proof (state)\nthis:\n  \\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "have \"supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "using **"], ["proof (prove)\nusing this:\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "by (auto simp: insert_eqvt)"], ["proof (state)\nthis:\n  supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b\n  supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "have \"\\<exists>q. (\\<forall>b \\<in> insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\""], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b\n  supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "by blast"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "}"], ["proof (state)\nthis:\n  q \\<bullet> a = p \\<bullet> a \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "moreover"], ["proof (state)\nthis:\n  q \\<bullet> a = p \\<bullet> a \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "{"], ["proof (state)\nthis:\n  q \\<bullet> a = p \\<bullet> a \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "assume 2: \"q \\<bullet> a \\<noteq> p \\<bullet> a\""], ["proof (state)\nthis:\n  q \\<bullet> a \\<noteq> p \\<bullet> a\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "define q' where \"q' = ((q \\<bullet> a) \\<rightleftharpoons> (p \\<bullet> a)) + q\""], ["proof (state)\nthis:\n  q' = (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a) + q\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "have \"\\<forall>b \\<in> insert a bs. q' \\<bullet> b = p \\<bullet> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>insert a bs. q' \\<bullet> b = p \\<bullet> b", "using 2 * \\<open>a \\<notin> bs\\<close>"], ["proof (prove)\nusing this:\n  q \\<bullet> a \\<noteq> p \\<bullet> a\n  \\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b\n  a \\<notin> bs\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>insert a bs. q' \\<bullet> b = p \\<bullet> b", "unfolding q'_def"], ["proof (prove)\nusing this:\n  q \\<bullet> a \\<noteq> p \\<bullet> a\n  \\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b\n  a \\<notin> bs\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>insert a bs.\n       ((q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a) +\n        q) \\<bullet> b =\n       p \\<bullet> b", "by (auto simp: swap_atom)"], ["proof (state)\nthis:\n  \\<forall>b\\<in>insert a bs. q' \\<bullet> b = p \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "moreover"], ["proof (state)\nthis:\n  \\<forall>b\\<in>insert a bs. q' \\<bullet> b = p \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "{"], ["proof (state)\nthis:\n  \\<forall>b\\<in>insert a bs. q' \\<bullet> b = p \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "have \"{q \\<bullet> a, p \\<bullet> a} \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q \\<bullet> a, p \\<bullet> a}\n    \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "using **"], ["proof (prove)\nusing this:\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. {q \\<bullet> a, p \\<bullet> a}\n    \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "apply (auto simp: supp_perm insert_eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> bs \\<union> p \\<bullet> bs;\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> p \\<bullet> bs\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> bs", "apply (subgoal_tac \"q \\<bullet> a \\<in> bs \\<union> p \\<bullet> bs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> bs \\<union> p \\<bullet> bs;\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> p \\<bullet> bs;\n     q \\<bullet> a \\<in> bs \\<union> p \\<bullet> bs\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> bs\n 2. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> bs \\<union> p \\<bullet> bs;\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> p \\<bullet> bs\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> bs \\<union> p \\<bullet> bs", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> bs \\<union> p \\<bullet> bs;\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> p \\<bullet> bs\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> bs \\<union> p \\<bullet> bs", "apply(subgoal_tac \"q \\<bullet> a \\<in> {a. q \\<bullet> a \\<noteq> a}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> bs \\<union> p \\<bullet> bs;\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> p \\<bullet> bs;\n     q \\<bullet> a \\<in> {a. q \\<bullet> a \\<noteq> a}\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> bs \\<union> p \\<bullet> bs\n 2. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> bs \\<union> p \\<bullet> bs;\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> p \\<bullet> bs\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> {a. q \\<bullet> a \\<noteq> a}", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> bs \\<union> p \\<bullet> bs;\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> p \\<bullet> bs\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> {a. q \\<bullet> a \\<noteq> a}", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {q \\<bullet> a, p \\<bullet> a}\n  \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "then"], ["proof (chain)\npicking this:\n  {q \\<bullet> a, p \\<bullet> a}\n  \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "have \"supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a) \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\""], ["proof (prove)\nusing this:\n  {q \\<bullet> a, p \\<bullet> a}\n  \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n    \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "unfolding supp_swap"], ["proof (prove)\nusing this:\n  {q \\<bullet> a, p \\<bullet> a}\n  \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. (if q \\<bullet> a = p \\<bullet> a \\<or>\n        sort_of (q \\<bullet> a) \\<noteq> sort_of (p \\<bullet> a)\n     then {} else {q \\<bullet> a, p \\<bullet> a})\n    \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "by auto"], ["proof (state)\nthis:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "moreover"], ["proof (state)\nthis:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "have \"supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "using **"], ["proof (prove)\nusing this:\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "by (auto simp: insert_eqvt)"], ["proof (state)\nthis:\n  supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "ultimately"], ["proof (chain)\npicking this:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n  supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "have \"supp q' \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\""], ["proof (prove)\nusing this:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n  supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. supp q' \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "unfolding q'_def"], ["proof (prove)\nusing this:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n  supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. supp ((q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a) + q)\n    \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "using supp_plus_perm"], ["proof (prove)\nusing this:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n  supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n  supp (?p + ?q) \\<subseteq> supp ?p \\<union> supp ?q\n\ngoal (1 subgoal):\n 1. supp ((q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a) + q)\n    \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "by blast"], ["proof (state)\nthis:\n  supp q' \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "}"], ["proof (state)\nthis:\n  supp q' \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>b\\<in>insert a bs. q' \\<bullet> b = p \\<bullet> b\n  supp q' \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "have \"\\<exists>q. (\\<forall>b \\<in> insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\""], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>insert a bs. q' \\<bullet> b = p \\<bullet> b\n  supp q' \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "by blast"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "}"], ["proof (state)\nthis:\n  q \\<bullet> a \\<noteq> p \\<bullet> a \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>q.\n           (\\<forall>b\\<in>F. q \\<bullet> b = p \\<bullet> b) \\<and>\n           supp q \\<subseteq> F \\<union> p \\<bullet> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            (\\<forall>b\\<in>insert x F.\n                                q \\<bullet> b = p \\<bullet> b) \\<and>\n                            supp q\n                            \\<subseteq> insert x F \\<union>\n  p \\<bullet> insert x F", "ultimately"], ["proof (chain)\npicking this:\n  q \\<bullet> a = p \\<bullet> a \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n  q \\<bullet> a \\<noteq> p \\<bullet> a \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "show \"\\<exists>q. (\\<forall>b \\<in> insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\""], ["proof (prove)\nusing this:\n  q \\<bullet> a = p \\<bullet> a \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n  q \\<bullet> a \\<noteq> p \\<bullet> a \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs", "by blast"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>insert a bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> insert a bs \\<union> p \\<bullet> insert a bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_renaming_perm2:\n  shows \"\\<exists>q. (\\<forall>b \\<in> bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> bs \\<union> (p \\<bullet> bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "have \"finite (bs \\<inter> supp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (bs \\<inter> supp p)", "by (simp add: finite_supp)"], ["proof (state)\nthis:\n  finite (bs \\<inter> supp p)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "then"], ["proof (chain)\npicking this:\n  finite (bs \\<inter> supp p)", "obtain q\n    where *: \"\\<forall>b \\<in> bs \\<inter> supp p. q \\<bullet> b = p \\<bullet> b\" and **: \"supp q \\<subseteq> (bs \\<inter> supp p) \\<union> (p \\<bullet> (bs \\<inter> supp p))\""], ["proof (prove)\nusing this:\n  finite (bs \\<inter> supp p)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<forall>b\\<in>bs \\<inter> supp p.\n                    q \\<bullet> b = p \\<bullet> b;\n         supp q\n         \\<subseteq> bs \\<inter> supp p \\<union>\n                     p \\<bullet> (bs \\<inter> supp p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using set_renaming_perm"], ["proof (prove)\nusing this:\n  finite (bs \\<inter> supp p)\n  finite ?bs \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>?bs. q \\<bullet> b = ?p \\<bullet> b) \\<and>\n     supp q \\<subseteq> ?bs \\<union> ?p \\<bullet> ?bs\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<forall>b\\<in>bs \\<inter> supp p.\n                    q \\<bullet> b = p \\<bullet> b;\n         supp q\n         \\<subseteq> bs \\<inter> supp p \\<union>\n                     p \\<bullet> (bs \\<inter> supp p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>b\\<in>bs \\<inter> supp p. q \\<bullet> b = p \\<bullet> b\n  supp q\n  \\<subseteq> bs \\<inter> supp p \\<union> p \\<bullet> (bs \\<inter> supp p)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "from **"], ["proof (chain)\npicking this:\n  supp q\n  \\<subseteq> bs \\<inter> supp p \\<union> p \\<bullet> (bs \\<inter> supp p)", "have \"supp q \\<subseteq> bs \\<union> (p \\<bullet> bs)\""], ["proof (prove)\nusing this:\n  supp q\n  \\<subseteq> bs \\<inter> supp p \\<union> p \\<bullet> (bs \\<inter> supp p)\n\ngoal (1 subgoal):\n 1. supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "by (auto simp: inter_eqvt)"], ["proof (state)\nthis:\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "moreover"], ["proof (state)\nthis:\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "have \"\\<forall>b \\<in> bs - supp p. q \\<bullet> b = p \\<bullet> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>bs - supp p. q \\<bullet> b = p \\<bullet> b", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> bs; b \\<notin> supp p\\<rbrakk>\n       \\<Longrightarrow> q \\<bullet> b = p \\<bullet> b", "apply(subgoal_tac \"b \\<notin> supp q\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> bs; b \\<notin> supp p; b \\<notin> supp q\\<rbrakk>\n       \\<Longrightarrow> q \\<bullet> b = p \\<bullet> b\n 2. \\<And>b.\n       \\<lbrakk>b \\<in> bs; b \\<notin> supp p\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> supp q", "apply(simp add: fresh_def[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> bs; b \\<sharp> p; b \\<sharp> q\\<rbrakk>\n       \\<Longrightarrow> q \\<bullet> b = p \\<bullet> b\n 2. \\<And>b.\n       \\<lbrakk>b \\<in> bs; b \\<notin> supp p\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> supp q", "apply(simp add: fresh_perm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> bs; b \\<notin> supp p\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> supp q", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> bs; b \\<notin> supp p; b \\<in> supp q\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rotate_tac 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> supp q; b \\<in> bs; b \\<notin> supp p\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule subsetD[OF **])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> bs; b \\<notin> supp p;\n        b \\<in> bs \\<inter> supp p \\<union>\n                p \\<bullet> (bs \\<inter> supp p)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp add: inter_eqvt supp_eqvt permute_self)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>b\\<in>bs - supp p. q \\<bullet> b = p \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "ultimately"], ["proof (chain)\npicking this:\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n  \\<forall>b\\<in>bs - supp p. q \\<bullet> b = p \\<bullet> b", "have \"(\\<forall>b \\<in> bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> bs \\<union> (p \\<bullet> bs)\""], ["proof (prove)\nusing this:\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n  \\<forall>b\\<in>bs - supp p. q \\<bullet> b = p \\<bullet> b\n\ngoal (1 subgoal):\n 1. (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n    supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "using *"], ["proof (prove)\nusing this:\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n  \\<forall>b\\<in>bs - supp p. q \\<bullet> b = p \\<bullet> b\n  \\<forall>b\\<in>bs \\<inter> supp p. q \\<bullet> b = p \\<bullet> b\n\ngoal (1 subgoal):\n 1. (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n    supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "by auto"], ["proof (state)\nthis:\n  (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "then"], ["proof (chain)\npicking this:\n  (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "show \"\\<exists>q. (\\<forall>b \\<in> bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> bs \\<union> (p \\<bullet> bs)\""], ["proof (prove)\nusing this:\n  (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n  supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> bs \\<union> p \\<bullet> bs", "by blast"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> bs \\<union> p \\<bullet> bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_renaming_perm:\n  shows \"\\<exists>q. (\\<forall>b \\<in> set bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> set bs \\<union> (p \\<bullet> set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs", "proof (induct bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "case (Cons a bs)"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>q.\n     (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs", "have \" \\<exists>q. (\\<forall>b \\<in> set bs. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> set bs \\<union> p \\<bullet> (set bs)\""], ["proof (prove)\nusing this:\n  \\<exists>q.\n     (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs", "by simp"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>q.\n     (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs", "obtain q where *: \"\\<forall>b \\<in> set bs. q \\<bullet> b = p \\<bullet> b\" and **: \"supp q \\<subseteq> set bs \\<union> p \\<bullet> (set bs)\""], ["proof (prove)\nusing this:\n  \\<exists>q.\n     (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b;\n         supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast)"], ["proof (state)\nthis:\n  \\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b\n  supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "{"], ["proof (state)\nthis:\n  \\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b\n  supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "assume 1: \"a \\<in> set bs\""], ["proof (state)\nthis:\n  a \\<in> set bs\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "have \"q \\<bullet> a = p \\<bullet> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<bullet> a = p \\<bullet> a", "using * 1"], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b\n  a \\<in> set bs\n\ngoal (1 subgoal):\n 1. q \\<bullet> a = p \\<bullet> a", "by (induct bs) (auto)"], ["proof (state)\nthis:\n  q \\<bullet> a = p \\<bullet> a\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "then"], ["proof (chain)\npicking this:\n  q \\<bullet> a = p \\<bullet> a", "have \"\\<forall>b \\<in> set (a # bs). q \\<bullet> b = p \\<bullet> b\""], ["proof (prove)\nusing this:\n  q \\<bullet> a = p \\<bullet> a\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b", "using *"], ["proof (prove)\nusing this:\n  q \\<bullet> a = p \\<bullet> a\n  \\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b", "by simp"], ["proof (state)\nthis:\n  \\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "moreover"], ["proof (state)\nthis:\n  \\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "have \"supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> (set (a # bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "using **"], ["proof (prove)\nusing this:\n  supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs\n\ngoal (1 subgoal):\n 1. supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "by (auto simp: insert_eqvt)"], ["proof (state)\nthis:\n  supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b\n  supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "have \"\\<exists>q. (\\<forall>b \\<in> set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> (set (a # bs))\""], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b\n  supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "}"], ["proof (state)\nthis:\n  a \\<in> set bs \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "moreover"], ["proof (state)\nthis:\n  a \\<in> set bs \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "{"], ["proof (state)\nthis:\n  a \\<in> set bs \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "assume 2: \"a \\<notin> set bs\""], ["proof (state)\nthis:\n  a \\<notin> set bs\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "define q' where \"q' = ((q \\<bullet> a) \\<rightleftharpoons> (p \\<bullet> a)) + q\""], ["proof (state)\nthis:\n  q' = (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a) + q\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "have \"\\<forall>b \\<in> set (a # bs). q' \\<bullet> b = p \\<bullet> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (a # bs). q' \\<bullet> b = p \\<bullet> b", "unfolding q'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (a # bs).\n       ((q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a) +\n        q) \\<bullet> b =\n       p \\<bullet> b", "using 2 * \\<open>a \\<notin> set bs\\<close>"], ["proof (prove)\nusing this:\n  a \\<notin> set bs\n  \\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b\n  a \\<notin> set bs\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (a # bs).\n       ((q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a) +\n        q) \\<bullet> b =\n       p \\<bullet> b", "by (auto simp: swap_atom)"], ["proof (state)\nthis:\n  \\<forall>b\\<in>set (a # bs). q' \\<bullet> b = p \\<bullet> b\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "moreover"], ["proof (state)\nthis:\n  \\<forall>b\\<in>set (a # bs). q' \\<bullet> b = p \\<bullet> b\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "{"], ["proof (state)\nthis:\n  \\<forall>b\\<in>set (a # bs). q' \\<bullet> b = p \\<bullet> b\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "have \"{q \\<bullet> a, p \\<bullet> a} \\<subseteq> set (a # bs) \\<union> p \\<bullet> (set (a # bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q \\<bullet> a, p \\<bullet> a}\n    \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "using **"], ["proof (prove)\nusing this:\n  supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs\n\ngoal (1 subgoal):\n 1. {q \\<bullet> a, p \\<bullet> a}\n    \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "apply (auto simp: supp_perm insert_eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> set bs \\<union> set (p \\<bullet> bs);\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> set (p \\<bullet> bs)\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> set bs", "apply (subgoal_tac \"q \\<bullet> a \\<in> set bs \\<union> p \\<bullet> set bs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> set bs \\<union> set (p \\<bullet> bs);\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> set (p \\<bullet> bs);\n     q \\<bullet> a \\<in> set bs \\<union> p \\<bullet> set bs\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> set bs\n 2. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> set bs \\<union> set (p \\<bullet> bs);\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> set (p \\<bullet> bs)\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> set bs \\<union> p \\<bullet> set bs", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> set bs \\<union> set (p \\<bullet> bs);\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> set (p \\<bullet> bs)\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> set bs \\<union> p \\<bullet> set bs", "apply(subgoal_tac \"q \\<bullet> a \\<in> {a. q \\<bullet> a \\<noteq> a}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> set bs \\<union> set (p \\<bullet> bs);\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> set (p \\<bullet> bs);\n     q \\<bullet> a \\<in> {a. q \\<bullet> a \\<noteq> a}\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> set bs \\<union> p \\<bullet> set bs\n 2. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> set bs \\<union> set (p \\<bullet> bs);\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> set (p \\<bullet> bs)\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> {a. q \\<bullet> a \\<noteq> a}", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a. q \\<bullet> a \\<noteq> a}\n             \\<subseteq> set bs \\<union> set (p \\<bullet> bs);\n     q \\<bullet> a \\<noteq> p \\<bullet> a; q \\<bullet> a \\<noteq> a;\n     q \\<bullet> a \\<notin> set (p \\<bullet> bs)\\<rbrakk>\n    \\<Longrightarrow> q \\<bullet> a \\<in> {a. q \\<bullet> a \\<noteq> a}", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {q \\<bullet> a, p \\<bullet> a}\n  \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "then"], ["proof (chain)\npicking this:\n  {q \\<bullet> a, p \\<bullet> a}\n  \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "have \"supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a) \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\""], ["proof (prove)\nusing this:\n  {q \\<bullet> a, p \\<bullet> a}\n  \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (1 subgoal):\n 1. supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n    \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "unfolding supp_swap"], ["proof (prove)\nusing this:\n  {q \\<bullet> a, p \\<bullet> a}\n  \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (1 subgoal):\n 1. (if q \\<bullet> a = p \\<bullet> a \\<or>\n        sort_of (q \\<bullet> a) \\<noteq> sort_of (p \\<bullet> a)\n     then {} else {q \\<bullet> a, p \\<bullet> a})\n    \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "by auto"], ["proof (state)\nthis:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "moreover"], ["proof (state)\nthis:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "have \"supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> (set (a # bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "using **"], ["proof (prove)\nusing this:\n  supp q \\<subseteq> set bs \\<union> p \\<bullet> set bs\n\ngoal (1 subgoal):\n 1. supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "by (auto simp: insert_eqvt)"], ["proof (state)\nthis:\n  supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "ultimately"], ["proof (chain)\npicking this:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n  supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "have \"supp q' \\<subseteq> set (a # bs) \\<union> p \\<bullet> (set (a # bs))\""], ["proof (prove)\nusing this:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n  supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (1 subgoal):\n 1. supp q' \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "unfolding q'_def"], ["proof (prove)\nusing this:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n  supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (1 subgoal):\n 1. supp ((q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a) + q)\n    \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "using supp_plus_perm"], ["proof (prove)\nusing this:\n  supp (q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a)\n  \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n  supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n  supp (?p + ?q) \\<subseteq> supp ?p \\<union> supp ?q\n\ngoal (1 subgoal):\n 1. supp ((q \\<bullet> a \\<rightleftharpoons> p \\<bullet> a) + q)\n    \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "by blast"], ["proof (state)\nthis:\n  supp q' \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "}"], ["proof (state)\nthis:\n  supp q' \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>b\\<in>set (a # bs). q' \\<bullet> b = p \\<bullet> b\n  supp q' \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "have \"\\<exists>q. (\\<forall>b \\<in> set (a # bs).  q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> (set (a # bs))\""], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>set (a # bs). q' \\<bullet> b = p \\<bullet> b\n  supp q' \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "}"], ["proof (state)\nthis:\n  a \\<notin> set bs \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (2 subgoals):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n 2. \\<And>a bs.\n       \\<exists>q.\n          (\\<forall>b\\<in>set bs. q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q\n          \\<subseteq> set bs \\<union> p \\<bullet> set bs \\<Longrightarrow>\n       \\<exists>q.\n          (\\<forall>b\\<in>set (a # bs).\n              q \\<bullet> b = p \\<bullet> b) \\<and>\n          supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> set bs \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n  a \\<notin> set bs \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "show \"\\<exists>q. (\\<forall>b \\<in> set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> (set (a # bs))\""], ["proof (prove)\nusing this:\n  a \\<in> set bs \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n  a \\<notin> set bs \\<Longrightarrow>\n  \\<exists>q.\n     (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>set (a # bs). q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set (a # bs) \\<union> p \\<bullet> set (a # bs)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []", "have \"(\\<forall>b \\<in> set []. 0 \\<bullet> b = p \\<bullet> b) \\<and> supp (0::perm) \\<subseteq> set [] \\<union> p \\<bullet> set []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>b\\<in>set []. 0 \\<bullet> b = p \\<bullet> b) \\<and>\n    supp 0 \\<subseteq> set [] \\<union> p \\<bullet> set []", "by (simp add: supp_zero_perm)"], ["proof (state)\nthis:\n  (\\<forall>b\\<in>set []. 0 \\<bullet> b = p \\<bullet> b) \\<and>\n  supp 0 \\<subseteq> set [] \\<union> p \\<bullet> set []\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []", "then"], ["proof (chain)\npicking this:\n  (\\<forall>b\\<in>set []. 0 \\<bullet> b = p \\<bullet> b) \\<and>\n  supp 0 \\<subseteq> set [] \\<union> p \\<bullet> set []", "show \"\\<exists>q. (\\<forall>b \\<in> set []. q \\<bullet> b = p \\<bullet> b) \\<and> supp q \\<subseteq> set [] \\<union> p \\<bullet> (set [])\""], ["proof (prove)\nusing this:\n  (\\<forall>b\\<in>set []. 0 \\<bullet> b = p \\<bullet> b) \\<and>\n  supp 0 \\<subseteq> set [] \\<union> p \\<bullet> set []\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n       supp q \\<subseteq> set [] \\<union> p \\<bullet> set []", "by blast"], ["proof (state)\nthis:\n  \\<exists>q.\n     (\\<forall>b\\<in>set []. q \\<bullet> b = p \\<bullet> b) \\<and>\n     supp q \\<subseteq> set [] \\<union> p \\<bullet> set []\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Concrete Atoms Types\\<close>"], ["", "text \\<open>\n  Class \\<open>at_base\\<close> allows types containing multiple sorts of atoms.\n  Class \\<open>at\\<close> only allows types with a single sort.\n\\<close>"], ["", "class at_base = pt +\n  fixes atom :: \"'a \\<Rightarrow> atom\"\n  assumes atom_eq_iff [simp]: \"atom a = atom b \\<longleftrightarrow> a = b\"\n  assumes atom_eqvt: \"p \\<bullet> (atom a) = atom (p \\<bullet> a)\""], ["", "declare atom_eqvt [eqvt]"], ["", "class at = at_base +\n  assumes sort_of_atom_eq [simp]: \"sort_of (atom a) = sort_of (atom b)\""], ["", "lemma sort_ineq [simp]:\n  assumes \"sort_of (atom a) \\<noteq> sort_of (atom b)\"\n  shows \"atom a \\<noteq> atom b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom a \\<noteq> atom b", "using assms"], ["proof (prove)\nusing this:\n  sort_of (atom a) \\<noteq> sort_of (atom b)\n\ngoal (1 subgoal):\n 1. atom a \\<noteq> atom b", "by metis"], ["", "lemma supp_at_base:\n  fixes a::\"'a::at_base\"\n  shows \"supp a = {atom a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp a = {atom a}", "by (simp add: supp_atom [symmetric] supp_def atom_eqvt)"], ["", "lemma fresh_at_base:\n  shows  \"sort_of a \\<noteq> sort_of (atom b) \\<Longrightarrow> a \\<sharp> b\"\n  and \"a \\<sharp> b \\<longleftrightarrow> a \\<noteq> atom b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sort_of a \\<noteq> sort_of (atom b) \\<Longrightarrow> a \\<sharp> b) &&&\n    a \\<sharp> b = (a \\<noteq> atom b)", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sort_of a \\<noteq> sort_of (atom b) \\<Longrightarrow>\n     a \\<notin> supp b) &&&\n    (a \\<notin> supp b) = (a \\<noteq> atom b)", "apply(simp_all add: supp_at_base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of a \\<noteq> sort_of (atom b) \\<Longrightarrow> a \\<noteq> atom b", "apply(metis)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* solves the freshness only if the inequality can be shown by the\n   simproc below *)"], ["", "lemma fresh_ineq_at_base [simp]:\n  shows \"a \\<noteq> atom b \\<Longrightarrow> a \\<sharp> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> atom b \\<Longrightarrow> a \\<sharp> b", "by (simp add: fresh_at_base)"], ["", "lemma fresh_atom_at_base [simp]:\n  fixes b::\"'a::at_base\"\n  shows \"a \\<sharp> atom b \\<longleftrightarrow> a \\<sharp> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> atom b = a \\<sharp> b", "by (simp add: fresh_def supp_at_base supp_atom)"], ["", "lemma fresh_star_atom_at_base:\n  fixes b::\"'a::at_base\"\n  shows \"as \\<sharp>* atom b \\<longleftrightarrow> as \\<sharp>* b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<sharp>* atom b = as \\<sharp>* b", "by (simp add: fresh_star_def fresh_atom_at_base)"], ["", "lemma if_fresh_at_base [simp]:\n  shows \"atom a \\<sharp> x \\<Longrightarrow> P (if a = x then t else s) = P s\"\n  and   \"atom a \\<sharp> x \\<Longrightarrow> P (if x = a then t else s) = P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom a \\<sharp> x \\<Longrightarrow>\n     P (if a = x then t else s) = P s) &&&\n    (atom a \\<sharp> x \\<Longrightarrow> P (if x = a then t else s) = P s)", "by (simp_all add: fresh_at_base)"], ["", "simproc_setup fresh_ineq (\"x \\<noteq> (y::'a::at_base)\") = \\<open>fn _ => fn ctxt => fn ctrm =>\n  case Thm.term_of ctrm of @{term \"HOL.Not\"} $ (Const (@{const_name HOL.eq}, _) $ lhs $ rhs) =>\n    let\n      fun first_is_neg lhs rhs [] = NONE\n        | first_is_neg lhs rhs (thm::thms) =\n          (case Thm.prop_of thm of\n             _ $ (@{term \"HOL.Not\"} $ (Const (@{const_name HOL.eq}, _) $ l $ r)) =>\n               (if l = lhs andalso r = rhs then SOME(thm)\n                else if r = lhs andalso l = rhs then SOME(thm RS @{thm not_sym})\n                else first_is_neg lhs rhs thms)\n        | _ => first_is_neg lhs rhs thms)\n\n      val simp_thms = @{thms fresh_Pair fresh_at_base atom_eq_iff}\n      val prems = Simplifier.prems_of ctxt\n         |> filter (fn thm => case Thm.prop_of thm of\n            _ $ (Const (@{const_name fresh}, ty) $ (_ $ a) $ b) =>\n            (let\n               val atms = a :: HOLogic.strip_tuple b\n             in\n               member ((=)) atms lhs andalso member ((=)) atms rhs\n             end)\n            | _ => false)\n         |> map (simplify (put_simpset HOL_basic_ss ctxt addsimps simp_thms))\n         |> map (HOLogic.conj_elims ctxt)\n         |> flat\n    in\n      case first_is_neg lhs rhs prems of\n        SOME(thm) => SOME(thm RS @{thm Eq_TrueI})\n      | NONE => NONE\n    end\n  | _ => NONE\n\\<close>"], ["", "instance at_base < fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, fs_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. finite (supp x)", "qed (simp add: supp_at_base)"], ["", "lemma at_base_infinite [simp]:\n  shows \"infinite (UNIV :: 'a::at_base set)\" (is \"infinite ?U\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "obtain a :: 'a where \"True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (True \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  True\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "assume \"finite ?U\""], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "hence \"finite (atom ` ?U)\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite (range atom)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite (range atom)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  finite (range atom)", "obtain b where b: \"b \\<notin> atom ` ?U\" \"sort_of b = sort_of (atom a)\""], ["proof (prove)\nusing this:\n  finite (range atom)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<notin> range atom;\n         sort_of b = sort_of (atom a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_atom)"], ["proof (state)\nthis:\n  b \\<notin> range atom\n  sort_of b = sort_of (atom a)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "from b(2)"], ["proof (chain)\npicking this:\n  sort_of b = sort_of (atom a)", "have \"b = atom ((atom a \\<rightleftharpoons> b) \\<bullet> a)\""], ["proof (prove)\nusing this:\n  sort_of b = sort_of (atom a)\n\ngoal (1 subgoal):\n 1. b = atom ((atom a \\<rightleftharpoons> b) \\<bullet> a)", "unfolding atom_eqvt [symmetric]"], ["proof (prove)\nusing this:\n  sort_of b = sort_of (atom a)\n\ngoal (1 subgoal):\n 1. b = (atom a \\<rightleftharpoons> b) \\<bullet> atom a", "by (simp add: swap_atom)"], ["proof (state)\nthis:\n  b = atom ((atom a \\<rightleftharpoons> b) \\<bullet> a)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "hence \"b \\<in> atom ` ?U\""], ["proof (prove)\nusing this:\n  b = atom ((atom a \\<rightleftharpoons> b) \\<bullet> a)\n\ngoal (1 subgoal):\n 1. b \\<in> range atom", "by simp"], ["proof (state)\nthis:\n  b \\<in> range atom\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "with b(1)"], ["proof (chain)\npicking this:\n  b \\<notin> range atom\n  b \\<in> range atom", "show \"False\""], ["proof (prove)\nusing this:\n  b \\<notin> range atom\n  b \\<in> range atom\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_at_base_simps [simp]:\n  fixes x y::\"'a::at_base\"\n  shows \"sort_of (atom x) = sort_of (atom y) \\<Longrightarrow> (atom x \\<rightleftharpoons> atom y) \\<bullet> x = y\"\n  and   \"sort_of (atom x) = sort_of (atom y) \\<Longrightarrow> (atom x \\<rightleftharpoons> atom y) \\<bullet> y = x\"\n  and   \"atom x \\<noteq> a \\<Longrightarrow> atom x \\<noteq> b \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sort_of (atom x) = sort_of (atom y) \\<Longrightarrow>\n     (atom x \\<rightleftharpoons> atom y) \\<bullet> x = y) &&&\n    (sort_of (atom x) = sort_of (atom y) \\<Longrightarrow>\n     (atom x \\<rightleftharpoons> atom y) \\<bullet> y = x) &&&\n    (\\<lbrakk>atom x \\<noteq> a; atom x \\<noteq> b\\<rbrakk>\n     \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> x = x)", "unfolding atom_eq_iff [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sort_of (atom x) = sort_of (atom y) \\<Longrightarrow>\n     atom ((atom x \\<rightleftharpoons> atom y) \\<bullet> x) = atom y) &&&\n    (sort_of (atom x) = sort_of (atom y) \\<Longrightarrow>\n     atom ((atom x \\<rightleftharpoons> atom y) \\<bullet> y) = atom x) &&&\n    (\\<lbrakk>atom x \\<noteq> a; atom x \\<noteq> b\\<rbrakk>\n     \\<Longrightarrow> atom ((a \\<rightleftharpoons> b) \\<bullet> x) =\n                       atom x)", "unfolding atom_eqvt [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sort_of (atom x) = sort_of (atom y) \\<Longrightarrow>\n     (atom x \\<rightleftharpoons> atom y) \\<bullet> atom x = atom y) &&&\n    (sort_of (atom x) = sort_of (atom y) \\<Longrightarrow>\n     (atom x \\<rightleftharpoons> atom y) \\<bullet> atom y = atom x) &&&\n    (\\<lbrakk>atom x \\<noteq> a; atom x \\<noteq> b\\<rbrakk>\n     \\<Longrightarrow> (a \\<rightleftharpoons> b) \\<bullet> atom x = atom x)", "by simp_all"], ["", "lemma obtain_at_base:\n  assumes X: \"finite X\"\n  obtains a::\"'a::at_base\" where \"atom a \\<notin> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<notin> X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<notin> X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"inj (atom :: 'a \\<Rightarrow> atom)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj atom", "by (simp add: inj_on_def)"], ["proof (state)\nthis:\n  inj atom\n\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<notin> X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with X"], ["proof (chain)\npicking this:\n  finite X\n  inj atom", "have \"finite (atom -` X :: 'a set)\""], ["proof (prove)\nusing this:\n  finite X\n  inj atom\n\ngoal (1 subgoal):\n 1. finite (atom -` X)", "by (rule finite_vimageI)"], ["proof (state)\nthis:\n  finite (atom -` X)\n\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<notin> X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with at_base_infinite"], ["proof (chain)\npicking this:\n  infinite UNIV\n  finite (atom -` X)", "have \"atom -` X \\<noteq> (UNIV :: 'a set)\""], ["proof (prove)\nusing this:\n  infinite UNIV\n  finite (atom -` X)\n\ngoal (1 subgoal):\n 1. atom -` X \\<noteq> UNIV", "by auto"], ["proof (state)\nthis:\n  atom -` X \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<notin> X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  atom -` X \\<noteq> UNIV", "obtain a :: 'a where \"atom a \\<notin> X\""], ["proof (prove)\nusing this:\n  atom -` X \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<notin> X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  atom a \\<notin> X\n\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<notin> X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom a \\<notin> X\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obtain_fresh':\n  assumes fin: \"finite (supp x)\"\n  obtains a::\"'a::at_base\" where \"atom a \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<sharp> x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using obtain_at_base[where X=\"supp x\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (supp x);\n   \\<And>a. atom a \\<notin> supp x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<sharp> x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: fresh_def fin)"], ["", "lemma obtain_fresh:\n  fixes x::\"'b::fs\"\n  obtains a::\"'a::at_base\" where \"atom a \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<sharp> x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh') (auto simp: finite_supp)"], ["", "lemma supp_finite_set_at_base:\n  assumes a: \"finite S\"\n  shows \"supp S = atom ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp S = atom ` S", "apply(simp add: supp_of_finite_sets[OF a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (supp ` S) = atom ` S", "apply(simp add: supp_at_base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>S. {atom x}) = atom ` S", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* FIXME\nlemma supp_cofinite_set_at_base:\n  assumes a: \"finite (UNIV - S)\"\n  shows \"supp S = atom ` (UNIV - S)\"\napply(rule finite_supp_unique)\n*)"], ["", "lemma fresh_finite_set_at_base:\n  fixes a::\"'a::at_base\"\n  assumes a: \"finite S\"\n  shows \"atom a \\<sharp> S \\<longleftrightarrow> a \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom a \\<sharp> S = (a \\<notin> S)", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom a \\<notin> supp S) = (a \\<notin> S)", "apply(simp add: supp_finite_set_at_base[OF a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom a \\<in> atom ` S) = (a \\<in> S)", "apply(subst inj_image_mem_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj atom\n 2. (a \\<in> S) = (a \\<in> S)", "apply(simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> S) = (a \\<in> S)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fresh_at_base_permute_iff [simp]:\n  fixes a::\"'a::at_base\"\n  shows \"atom (p \\<bullet> a) \\<sharp> p \\<bullet> x \\<longleftrightarrow> atom a \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom (p \\<bullet> a) \\<sharp> p \\<bullet> x = atom a \\<sharp> x", "unfolding atom_eqvt[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> atom a \\<sharp> p \\<bullet> x = atom a \\<sharp> x", "by (simp only: fresh_permute_iff)"], ["", "lemma fresh_at_base_permI:\n  shows \"atom a \\<sharp> p \\<Longrightarrow> p \\<bullet> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom a \\<sharp> p \\<Longrightarrow> p \\<bullet> a = a", "by (simp add: fresh_def supp_perm)"], ["", "section \\<open>Infrastructure for concrete atom types\\<close>"], ["", "definition\n  flip :: \"'a::at_base \\<Rightarrow> 'a \\<Rightarrow> perm\" (\"'(_ \\<leftrightarrow> _')\")\nwhere\n  \"(a \\<leftrightarrow> b) = (atom a \\<rightleftharpoons> atom b)\""], ["", "lemma flip_fresh_fresh:\n  assumes \"atom a \\<sharp> x\" \"atom b \\<sharp> x\"\n  shows \"(a \\<leftrightarrow> b) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<leftrightarrow> b) \\<bullet> x = x", "using assms"], ["proof (prove)\nusing this:\n  atom a \\<sharp> x\n  atom b \\<sharp> x\n\ngoal (1 subgoal):\n 1. (a \\<leftrightarrow> b) \\<bullet> x = x", "by (simp add: flip_def swap_fresh_fresh)"], ["", "lemma flip_self [simp]: \"(a \\<leftrightarrow> a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<leftrightarrow> a) = 0", "unfolding flip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom a \\<rightleftharpoons> atom a) = 0", "by (rule swap_self)"], ["", "lemma flip_commute: \"(a \\<leftrightarrow> b) = (b \\<leftrightarrow> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<leftrightarrow> b) = (b \\<leftrightarrow> a)", "unfolding flip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom a \\<rightleftharpoons> atom b) =\n    (atom b \\<rightleftharpoons> atom a)", "by (rule swap_commute)"], ["", "lemma minus_flip [simp]: \"- (a \\<leftrightarrow> b) = (a \\<leftrightarrow> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (a \\<leftrightarrow> b) = (a \\<leftrightarrow> b)", "unfolding flip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (atom a \\<rightleftharpoons> atom b) =\n    (atom a \\<rightleftharpoons> atom b)", "by (rule minus_swap)"], ["", "lemma add_flip_cancel: \"(a \\<leftrightarrow> b) + (a \\<leftrightarrow> b) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<leftrightarrow> b) + (a \\<leftrightarrow> b) = 0", "unfolding flip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom a \\<rightleftharpoons> atom b) +\n    (atom a \\<rightleftharpoons> atom b) =\n    0", "by (rule swap_cancel)"], ["", "lemma permute_flip_cancel [simp]: \"(a \\<leftrightarrow> b) \\<bullet> (a \\<leftrightarrow> b) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<leftrightarrow> b) \\<bullet> (a \\<leftrightarrow> b) \\<bullet> x =\n    x", "unfolding permute_plus [symmetric] add_flip_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<bullet> x = x", "by simp"], ["", "lemma permute_flip_cancel2 [simp]: \"(a \\<leftrightarrow> b) \\<bullet> (b \\<leftrightarrow> a) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<leftrightarrow> b) \\<bullet> (b \\<leftrightarrow> a) \\<bullet> x =\n    x", "by (simp add: flip_commute)"], ["", "lemma flip_eqvt [eqvt]:\n  shows \"p \\<bullet> (a \\<leftrightarrow> b) = (p \\<bullet> a \\<leftrightarrow> p \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (a \\<leftrightarrow> b) =\n    (p \\<bullet> a \\<leftrightarrow> p \\<bullet> b)", "unfolding flip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> (atom a \\<rightleftharpoons> atom b) =\n    (atom (p \\<bullet> a) \\<rightleftharpoons> atom (p \\<bullet> b))", "by (simp add: swap_eqvt atom_eqvt)"], ["", "lemma flip_at_base_simps [simp]:\n  shows \"sort_of (atom a) = sort_of (atom b) \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> a = b\"\n  and   \"sort_of (atom a) = sort_of (atom b) \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> b = a\"\n  and   \"\\<lbrakk>a \\<noteq> c; b \\<noteq> c\\<rbrakk> \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> c = c\"\n  and   \"sort_of (atom a) \\<noteq> sort_of (atom b) \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sort_of (atom a) = sort_of (atom b) \\<Longrightarrow>\n      (a \\<leftrightarrow> b) \\<bullet> a = b) &&&\n     (sort_of (atom a) = sort_of (atom b) \\<Longrightarrow>\n      (a \\<leftrightarrow> b) \\<bullet> b = a)) &&&\n    (\\<lbrakk>a \\<noteq> c; b \\<noteq> c\\<rbrakk>\n     \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> c = c) &&&\n    (sort_of (atom a) \\<noteq> sort_of (atom b) \\<Longrightarrow>\n     (a \\<leftrightarrow> b) \\<bullet> x = x)", "unfolding flip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sort_of (atom a) = sort_of (atom b) \\<Longrightarrow>\n      (atom a \\<rightleftharpoons> atom b) \\<bullet> a = b) &&&\n     (sort_of (atom a) = sort_of (atom b) \\<Longrightarrow>\n      (atom a \\<rightleftharpoons> atom b) \\<bullet> b = a)) &&&\n    (\\<lbrakk>a \\<noteq> c; b \\<noteq> c\\<rbrakk>\n     \\<Longrightarrow> (atom a \\<rightleftharpoons> atom b) \\<bullet> c =\n                       c) &&&\n    (sort_of (atom a) \\<noteq> sort_of (atom b) \\<Longrightarrow>\n     (atom a \\<rightleftharpoons> atom b) \\<bullet> x = x)", "unfolding atom_eq_iff [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sort_of (atom a) = sort_of (atom b) \\<Longrightarrow>\n      atom ((atom a \\<rightleftharpoons> atom b) \\<bullet> a) = atom b) &&&\n     (sort_of (atom a) = sort_of (atom b) \\<Longrightarrow>\n      atom ((atom a \\<rightleftharpoons> atom b) \\<bullet> b) = atom a)) &&&\n    (\\<lbrakk>atom a \\<noteq> atom c; atom b \\<noteq> atom c\\<rbrakk>\n     \\<Longrightarrow> atom\n                        ((atom a \\<rightleftharpoons> atom b) \\<bullet> c) =\n                       atom c) &&&\n    (sort_of (atom a) \\<noteq> sort_of (atom b) \\<Longrightarrow>\n     (atom a \\<rightleftharpoons> atom b) \\<bullet> x = x)", "unfolding atom_eqvt [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sort_of (atom a) = sort_of (atom b) \\<Longrightarrow>\n      (atom a \\<rightleftharpoons> atom b) \\<bullet> atom a = atom b) &&&\n     (sort_of (atom a) = sort_of (atom b) \\<Longrightarrow>\n      (atom a \\<rightleftharpoons> atom b) \\<bullet> atom b = atom a)) &&&\n    (\\<lbrakk>atom a \\<noteq> atom c; atom b \\<noteq> atom c\\<rbrakk>\n     \\<Longrightarrow> (atom\n                         a \\<rightleftharpoons> atom b) \\<bullet> atom c =\n                       atom c) &&&\n    (sort_of (atom a) \\<noteq> sort_of (atom b) \\<Longrightarrow>\n     (atom a \\<rightleftharpoons> atom b) \\<bullet> x = x)", "by simp_all"], ["", "text \\<open>the following two lemmas do not hold for \\<open>at_base\\<close>,\n  only for single sort atoms from at\\<close>"], ["", "lemma flip_triple:\n  fixes a b c::\"'a::at\"\n  assumes \"a \\<noteq> b\" and \"c \\<noteq> b\"\n  shows \"(a \\<leftrightarrow> c) + (b \\<leftrightarrow> c) + (a \\<leftrightarrow> c) = (a \\<leftrightarrow> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<leftrightarrow> c) + (b \\<leftrightarrow> c) +\n    (a \\<leftrightarrow> c) =\n    (a \\<leftrightarrow> b)", "unfolding flip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom a \\<rightleftharpoons> atom c) +\n    (atom b \\<rightleftharpoons> atom c) +\n    (atom a \\<rightleftharpoons> atom c) =\n    (atom a \\<rightleftharpoons> atom b)", "by (rule swap_triple) (simp_all add: assms)"], ["", "lemma permute_flip_at:\n  fixes a b c::\"'a::at\"\n  shows \"(a \\<leftrightarrow> b) \\<bullet> c = (if c = a then b else if c = b then a else c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<leftrightarrow> b) \\<bullet> c =\n    (if c = a then b else if c = b then a else c)", "unfolding flip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom a \\<rightleftharpoons> atom b) \\<bullet> c =\n    (if c = a then b else if c = b then a else c)", "apply (rule atom_eq_iff [THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ((atom a \\<rightleftharpoons> atom b) \\<bullet> c) =\n    atom (if c = a then b else if c = b then a else c)", "apply (subst atom_eqvt [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom a \\<rightleftharpoons> atom b) \\<bullet> atom c =\n    atom (if c = a then b else if c = b then a else c)", "apply (simp add: swap_atom)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flip_at_simps [simp]:\n  fixes a b::\"'a::at\"\n  shows \"(a \\<leftrightarrow> b) \\<bullet> a = b\"\n  and   \"(a \\<leftrightarrow> b) \\<bullet> b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<leftrightarrow> b) \\<bullet> a = b &&&\n    (a \\<leftrightarrow> b) \\<bullet> b = a", "unfolding permute_flip_at"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = a then b else if a = b then a else a) = b &&&\n    (if b = a then b else if b = b then a else b) = a", "by simp_all"], ["", "subsection \\<open>Syntax for coercing at-elements to the atom-type\\<close>"], ["", "syntax\n  \"_atom_constrain\" :: \"logic \\<Rightarrow> type \\<Rightarrow> logic\" (\"_:::_\" [4, 0] 3)"], ["", "translations\n  \"_atom_constrain a t\" => \"CONST atom (_constrain a t)\""], ["", "subsection \\<open>A lemma for proving instances of class \\<open>at\\<close>.\\<close>"], ["", "setup \\<open>Sign.add_const_constraint (@{const_name \"permute\"}, NONE)\\<close>"], ["", "setup \\<open>Sign.add_const_constraint (@{const_name \"atom\"}, NONE)\\<close>"], ["", "text \\<open>\n  New atom types are defined as subtypes of @{typ atom}.\n\\<close>"], ["", "lemma exists_eq_simple_sort:\n  shows \"\\<exists>a. a \\<in> {a. sort_of a = s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<in> {a. sort_of a = s}", "by (rule_tac x=\"Atom s 0\" in exI, simp)"], ["", "lemma exists_eq_sort:\n  shows \"\\<exists>a. a \\<in> {a. sort_of a \\<in> range sort_fun}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<in> {a. sort_of a \\<in> range sort_fun}", "by (rule_tac x=\"Atom (sort_fun x) y\" in exI, simp)"], ["", "lemma at_base_class:\n  fixes sort_fun :: \"'b \\<Rightarrow> atom_sort\"\n  fixes Rep :: \"'a \\<Rightarrow> atom\" and Abs :: \"atom \\<Rightarrow> 'a\"\n  assumes type: \"type_definition Rep Abs {a. sort_of a \\<in> range sort_fun}\"\n  assumes atom_def: \"\\<And>a. atom a = Rep a\"\n  assumes permute_def: \"\\<And>p a. p \\<bullet> a = Abs (p \\<bullet> Rep a)\"\n  shows \"OFCLASS('a, at_base_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, at_base_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\n 3. \\<And>a b. (atom a = atom b) = (a = b)\n 4. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)", "interpret type_definition Rep Abs \"{a. sort_of a \\<in> range sort_fun}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition Rep Abs {a. sort_of a \\<in> range sort_fun}", "by (rule type)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\n 3. \\<And>a b. (atom a = atom b) = (a = b)\n 4. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)", "have sort_of_Rep: \"\\<And>a. sort_of (Rep a) \\<in> range sort_fun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. sort_of (Rep a) \\<in> range sort_fun", "using Rep"], ["proof (prove)\nusing this:\n  Rep ?x \\<in> {a. sort_of a \\<in> range sort_fun}\n\ngoal (1 subgoal):\n 1. \\<And>a. sort_of (Rep a) \\<in> range sort_fun", "by simp"], ["proof (state)\nthis:\n  sort_of (Rep ?a) \\<in> range sort_fun\n\ngoal (4 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\n 3. \\<And>a b. (atom a = atom b) = (a = b)\n 4. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)", "fix a b :: 'a and p p1 p2 :: perm"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\n 3. \\<And>a b. (atom a = atom b) = (a = b)\n 4. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)", "show \"0 \\<bullet> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<bullet> a = a", "unfolding permute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs (0 \\<bullet> Rep a) = a", "by (simp add: Rep_inverse)"], ["proof (state)\nthis:\n  0 \\<bullet> a = a\n\ngoal (3 subgoals):\n 1. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\n 2. \\<And>a b. (atom a = atom b) = (a = b)\n 3. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)", "show \"(p1 + p2) \\<bullet> a = p1 \\<bullet> p2 \\<bullet> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p1 + p2) \\<bullet> a = p1 \\<bullet> p2 \\<bullet> a", "unfolding permute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs ((p1 + p2) \\<bullet> Rep a) =\n    Abs (p1 \\<bullet> Rep (Abs (p2 \\<bullet> Rep a)))", "by (simp add: Abs_inverse sort_of_Rep)"], ["proof (state)\nthis:\n  (p1 + p2) \\<bullet> a = p1 \\<bullet> p2 \\<bullet> a\n\ngoal (2 subgoals):\n 1. \\<And>a b. (atom a = atom b) = (a = b)\n 2. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)", "show \"atom a = atom b \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom a = atom b) = (a = b)", "unfolding atom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Rep a = Rep b) = (a = b)", "by (simp add: Rep_inject)"], ["proof (state)\nthis:\n  (atom a = atom b) = (a = b)\n\ngoal (1 subgoal):\n 1. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)", "show \"p \\<bullet> atom a = atom (p \\<bullet> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> atom a = atom (p \\<bullet> a)", "unfolding permute_def atom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> Rep a = Rep (Abs (p \\<bullet> Rep a))", "by (simp add: Abs_inverse sort_of_Rep)"], ["proof (state)\nthis:\n  p \\<bullet> atom a = atom (p \\<bullet> a)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma at_class:\n  fixes s :: atom_sort\n  fixes Rep :: \"'a \\<Rightarrow> atom\" and Abs :: \"atom \\<Rightarrow> 'a\"\n  assumes type: \"type_definition Rep Abs {a. sort_of a \\<in> range (\\<lambda>x::unit. s)}\"\n  assumes atom_def: \"\\<And>a. atom a = Rep a\"\n  assumes permute_def: \"\\<And>p a. p \\<bullet> a = Abs (p \\<bullet> Rep a)\"\n  shows \"OFCLASS('a, at_class)\"\nproof\n  interpret type_definition Rep Abs \"{a. sort_of a \\<in> range (\\<lambda>x::unit. s)}\" by (rule type)\n  have sort_of_Rep: \"\\<And>a. sort_of (Rep a) = s\" using Rep by (simp add: image_def)\n  fix a b :: 'a and p p1 p2 :: perm\n  show \"0 \\<bullet> a = a\"\n    unfolding permute_def by (simp add: Rep_inverse)\n  show \"(p1 + p2) \\<bullet> a = p1 \\<bullet> p2 \\<bullet> a\"\n    unfolding permute_def by (simp add: Abs_inverse sort_of_Rep)\n  show \"sort_of (atom a) = sort_of (atom b)\"\n    unfolding atom_def by (simp add: sort_of_Rep)\n  show \"atom a = atom b \\<longleftrightarrow> a = b\"\n    unfolding atom_def by (simp add: Rep_inject)\n  show \"p \\<bullet> atom a = atom (p \\<bullet> a)\"\n    unfolding permute_def atom_def by (simp add: Abs_inverse sort_of_Rep)\nqed\n*)"], ["", "lemma at_class:\n  fixes s :: atom_sort\n  fixes Rep :: \"'a \\<Rightarrow> atom\" and Abs :: \"atom \\<Rightarrow> 'a\"\n  assumes type: \"type_definition Rep Abs {a. sort_of a = s}\"\n  assumes atom_def: \"\\<And>a. atom a = Rep a\"\n  assumes permute_def: \"\\<And>p a. p \\<bullet> a = Abs (p \\<bullet> Rep a)\"\n  shows \"OFCLASS('a, at_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, at_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\n 3. \\<And>a b. (atom a = atom b) = (a = b)\n 4. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)\n 5. \\<And>a b. sort_of (atom a) = sort_of (atom b)", "interpret type_definition Rep Abs \"{a. sort_of a = s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition Rep Abs {a. sort_of a = s}", "by (rule type)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\n 3. \\<And>a b. (atom a = atom b) = (a = b)\n 4. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)\n 5. \\<And>a b. sort_of (atom a) = sort_of (atom b)", "have sort_of_Rep: \"\\<And>a. sort_of (Rep a) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. sort_of (Rep a) = s", "using Rep"], ["proof (prove)\nusing this:\n  Rep ?x \\<in> {a. sort_of a = s}\n\ngoal (1 subgoal):\n 1. \\<And>a. sort_of (Rep a) = s", "by (simp add: image_def)"], ["proof (state)\nthis:\n  sort_of (Rep ?a) = s\n\ngoal (5 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\n 3. \\<And>a b. (atom a = atom b) = (a = b)\n 4. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)\n 5. \\<And>a b. sort_of (atom a) = sort_of (atom b)", "fix a b :: 'a and p p1 p2 :: perm"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\n 3. \\<And>a b. (atom a = atom b) = (a = b)\n 4. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)\n 5. \\<And>a b. sort_of (atom a) = sort_of (atom b)", "show \"0 \\<bullet> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<bullet> a = a", "unfolding permute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs (0 \\<bullet> Rep a) = a", "by (simp add: Rep_inverse)"], ["proof (state)\nthis:\n  0 \\<bullet> a = a\n\ngoal (4 subgoals):\n 1. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x\n 2. \\<And>a b. (atom a = atom b) = (a = b)\n 3. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)\n 4. \\<And>a b. sort_of (atom a) = sort_of (atom b)", "show \"(p1 + p2) \\<bullet> a = p1 \\<bullet> p2 \\<bullet> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p1 + p2) \\<bullet> a = p1 \\<bullet> p2 \\<bullet> a", "unfolding permute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs ((p1 + p2) \\<bullet> Rep a) =\n    Abs (p1 \\<bullet> Rep (Abs (p2 \\<bullet> Rep a)))", "by (simp add: Abs_inverse sort_of_Rep)"], ["proof (state)\nthis:\n  (p1 + p2) \\<bullet> a = p1 \\<bullet> p2 \\<bullet> a\n\ngoal (3 subgoals):\n 1. \\<And>a b. (atom a = atom b) = (a = b)\n 2. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)\n 3. \\<And>a b. sort_of (atom a) = sort_of (atom b)", "show \"sort_of (atom a) = sort_of (atom b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of (atom a) = sort_of (atom b)", "unfolding atom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of (Rep a) = sort_of (Rep b)", "by (simp add: sort_of_Rep)"], ["proof (state)\nthis:\n  sort_of (atom a) = sort_of (atom b)\n\ngoal (2 subgoals):\n 1. \\<And>a b. (atom a = atom b) = (a = b)\n 2. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)", "show \"atom a = atom b \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom a = atom b) = (a = b)", "unfolding atom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Rep a = Rep b) = (a = b)", "by (simp add: Rep_inject)"], ["proof (state)\nthis:\n  (atom a = atom b) = (a = b)\n\ngoal (1 subgoal):\n 1. \\<And>p a. p \\<bullet> atom a = atom (p \\<bullet> a)", "show \"p \\<bullet> atom a = atom (p \\<bullet> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> atom a = atom (p \\<bullet> a)", "unfolding permute_def atom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> Rep a = Rep (Abs (p \\<bullet> Rep a))", "by (simp add: Abs_inverse sort_of_Rep)"], ["proof (state)\nthis:\n  p \\<bullet> atom a = atom (p \\<bullet> a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma at_class_sort:\n  fixes s :: atom_sort\n  fixes Rep :: \"'a \\<Rightarrow> atom\" and Abs :: \"atom \\<Rightarrow> 'a\"\n  fixes a::\"'a\"\n  assumes type: \"type_definition Rep Abs {a. sort_of a = s}\"\n  assumes atom_def: \"\\<And>a. atom a = Rep a\"\n  shows \"sort_of (atom a) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_of (atom a) = s", "using atom_def type"], ["proof (prove)\nusing this:\n  atom ?a = Rep ?a\n  type_definition Rep Abs {a. sort_of a = s}\n\ngoal (1 subgoal):\n 1. sort_of (atom a) = s", "unfolding type_definition_def"], ["proof (prove)\nusing this:\n  atom ?a = Rep ?a\n  (\\<forall>x. Rep x \\<in> {a. sort_of a = s}) \\<and>\n  (\\<forall>x. Abs (Rep x) = x) \\<and>\n  (\\<forall>y. y \\<in> {a. sort_of a = s} \\<longrightarrow> Rep (Abs y) = y)\n\ngoal (1 subgoal):\n 1. sort_of (atom a) = s", "by simp"], ["", "setup \\<open>Sign.add_const_constraint\n  (@{const_name \"permute\"}, SOME @{typ \"perm \\<Rightarrow> 'a::pt \\<Rightarrow> 'a\"})\\<close>"], ["", "setup \\<open>Sign.add_const_constraint\n  (@{const_name \"atom\"}, SOME @{typ \"'a::at_base \\<Rightarrow> atom\"})\\<close>"], ["", "section \\<open>Library functions for the nominal infrastructure\\<close>"], ["", "ML_file \\<open>nominal_library.ML\\<close>"], ["", "section \\<open>The freshness lemma according to Andy Pitts\\<close>"], ["", "lemma freshness_lemma:\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"\\<exists>a. atom a \\<sharp> (h, h a)\"\n  shows  \"\\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x", "from a"], ["proof (chain)\npicking this:\n  \\<exists>a. atom a \\<sharp> (h, h a)", "obtain b where a1: \"atom b \\<sharp> h\" and a2: \"atom b \\<sharp> h b\""], ["proof (prove)\nusing this:\n  \\<exists>a. atom a \\<sharp> (h, h a)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>atom b \\<sharp> h; atom b \\<sharp> h b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: fresh_Pair)"], ["proof (state)\nthis:\n  atom b \\<sharp> h\n  atom b \\<sharp> h b\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x", "show \"\\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x", "proof (intro exI allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. atom a \\<sharp> h \\<Longrightarrow> h a = ?x", "fix a :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. atom a \\<sharp> h \\<Longrightarrow> h a = ?x", "assume a3: \"atom a \\<sharp> h\""], ["proof (state)\nthis:\n  atom a \\<sharp> h\n\ngoal (1 subgoal):\n 1. \\<And>a. atom a \\<sharp> h \\<Longrightarrow> h a = ?x", "show \"h a = h b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = h b", "proof (cases \"a = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> h a = h b\n 2. a \\<noteq> b \\<Longrightarrow> h a = h b", "assume \"a = b\""], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> h a = h b\n 2. a \\<noteq> b \\<Longrightarrow> h a = h b", "thus \"h a = h b\""], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. h a = h b", "by simp"], ["proof (state)\nthis:\n  h a = h b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "assume \"a \\<noteq> b\""], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "hence \"atom a \\<sharp> b\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. atom a \\<sharp> b", "by (simp add: fresh_at_base)"], ["proof (state)\nthis:\n  atom a \\<sharp> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "with a3"], ["proof (chain)\npicking this:\n  atom a \\<sharp> h\n  atom a \\<sharp> b", "have \"atom a \\<sharp> h b\""], ["proof (prove)\nusing this:\n  atom a \\<sharp> h\n  atom a \\<sharp> b\n\ngoal (1 subgoal):\n 1. atom a \\<sharp> h b", "by (rule fresh_fun_app)"], ["proof (state)\nthis:\n  atom a \\<sharp> h b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "with a2"], ["proof (chain)\npicking this:\n  atom b \\<sharp> h b\n  atom a \\<sharp> h b", "have d1: \"(atom b \\<rightleftharpoons> atom a) \\<bullet> (h b) = (h b)\""], ["proof (prove)\nusing this:\n  atom b \\<sharp> h b\n  atom a \\<sharp> h b\n\ngoal (1 subgoal):\n 1. (atom b \\<rightleftharpoons> atom a) \\<bullet> h b = h b", "by (rule swap_fresh_fresh)"], ["proof (state)\nthis:\n  (atom b \\<rightleftharpoons> atom a) \\<bullet> h b = h b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "from a1 a3"], ["proof (chain)\npicking this:\n  atom b \\<sharp> h\n  atom a \\<sharp> h", "have d2: \"(atom b \\<rightleftharpoons> atom a) \\<bullet> h = h\""], ["proof (prove)\nusing this:\n  atom b \\<sharp> h\n  atom a \\<sharp> h\n\ngoal (1 subgoal):\n 1. (atom b \\<rightleftharpoons> atom a) \\<bullet> h = h", "by (rule swap_fresh_fresh)"], ["proof (state)\nthis:\n  (atom b \\<rightleftharpoons> atom a) \\<bullet> h = h\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "from d1"], ["proof (chain)\npicking this:\n  (atom b \\<rightleftharpoons> atom a) \\<bullet> h b = h b", "have \"h b = (atom b \\<rightleftharpoons> atom a) \\<bullet> (h b)\""], ["proof (prove)\nusing this:\n  (atom b \\<rightleftharpoons> atom a) \\<bullet> h b = h b\n\ngoal (1 subgoal):\n 1. h b = (atom b \\<rightleftharpoons> atom a) \\<bullet> h b", "by simp"], ["proof (state)\nthis:\n  h b = (atom b \\<rightleftharpoons> atom a) \\<bullet> h b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "also"], ["proof (state)\nthis:\n  h b = (atom b \\<rightleftharpoons> atom a) \\<bullet> h b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "have \"\\<dots> = ((atom b \\<rightleftharpoons> atom a) \\<bullet> h) ((atom b \\<rightleftharpoons> atom a) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom b \\<rightleftharpoons> atom a) \\<bullet> h b =\n    ((atom b \\<rightleftharpoons> atom a) \\<bullet> h)\n     ((atom b \\<rightleftharpoons> atom a) \\<bullet> b)", "by (rule permute_fun_app_eq)"], ["proof (state)\nthis:\n  (atom b \\<rightleftharpoons> atom a) \\<bullet> h b =\n  ((atom b \\<rightleftharpoons> atom a) \\<bullet> h)\n   ((atom b \\<rightleftharpoons> atom a) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "also"], ["proof (state)\nthis:\n  (atom b \\<rightleftharpoons> atom a) \\<bullet> h b =\n  ((atom b \\<rightleftharpoons> atom a) \\<bullet> h)\n   ((atom b \\<rightleftharpoons> atom a) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "have \"\\<dots> = h a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((atom b \\<rightleftharpoons> atom a) \\<bullet> h)\n     ((atom b \\<rightleftharpoons> atom a) \\<bullet> b) =\n    h a", "using d2"], ["proof (prove)\nusing this:\n  (atom b \\<rightleftharpoons> atom a) \\<bullet> h = h\n\ngoal (1 subgoal):\n 1. ((atom b \\<rightleftharpoons> atom a) \\<bullet> h)\n     ((atom b \\<rightleftharpoons> atom a) \\<bullet> b) =\n    h a", "by simp"], ["proof (state)\nthis:\n  ((atom b \\<rightleftharpoons> atom a) \\<bullet> h)\n   ((atom b \\<rightleftharpoons> atom a) \\<bullet> b) =\n  h a\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> h a = h b", "finally"], ["proof (chain)\npicking this:\n  h b = h a", "show \"h a = h b\""], ["proof (prove)\nusing this:\n  h b = h a\n\ngoal (1 subgoal):\n 1. h a = h b", "by simp"], ["proof (state)\nthis:\n  h a = h b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h a = h b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freshness_lemma_unique:\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"\\<exists>a. atom a \\<sharp> (h, h a)\"\n  shows \"\\<exists>!x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x;\n        \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from a"], ["proof (chain)\npicking this:\n  \\<exists>a. atom a \\<sharp> (h, h a)", "show \"\\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\""], ["proof (prove)\nusing this:\n  \\<exists>a. atom a \\<sharp> (h, h a)\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x", "by (rule freshness_lemma)"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x;\n        \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = y\\<rbrakk>\n       \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x;\n        \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x;\n        \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume x: \"\\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\""], ["proof (state)\nthis:\n  \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x;\n        \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume y: \"\\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = y\""], ["proof (state)\nthis:\n  \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x;\n        \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from a x y"], ["proof (chain)\npicking this:\n  \\<exists>a. atom a \\<sharp> (h, h a)\n  \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\n  \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = y", "show \"x = y\""], ["proof (prove)\nusing this:\n  \\<exists>a. atom a \\<sharp> (h, h a)\n  \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\n  \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = y\n\ngoal (1 subgoal):\n 1. x = y", "by (auto simp: fresh_Pair)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>packaging the freshness lemma into a function\\<close>"], ["", "definition\n  Fresh :: \"('a::at \\<Rightarrow> 'b::pt) \\<Rightarrow> 'b\"\nwhere\n  \"Fresh h = (THE x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x)\""], ["", "lemma Fresh_apply:\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"\\<exists>a. atom a \\<sharp> (h, h a)\"\n  assumes b: \"atom a \\<sharp> h\"\n  shows \"Fresh h = h a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fresh h = h a", "unfolding Fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x) = h a", "proof (rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>aa. atom aa \\<sharp> h \\<longrightarrow> h aa = h a\n 2. \\<And>x.\n       \\<forall>a.\n          atom a \\<sharp> h \\<longrightarrow> h a = x \\<Longrightarrow>\n       x = h a", "show \"\\<forall>a'. atom a' \\<sharp> h \\<longrightarrow> h a' = h a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a'. atom a' \\<sharp> h \\<longrightarrow> h a' = h a", "proof (intro strip)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a'. atom a' \\<sharp> h \\<Longrightarrow> h a' = h a", "fix a':: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a'. atom a' \\<sharp> h \\<Longrightarrow> h a' = h a", "assume c: \"atom a' \\<sharp> h\""], ["proof (state)\nthis:\n  atom a' \\<sharp> h\n\ngoal (1 subgoal):\n 1. \\<And>a'. atom a' \\<sharp> h \\<Longrightarrow> h a' = h a", "from a"], ["proof (chain)\npicking this:\n  \\<exists>a. atom a \\<sharp> (h, h a)", "have \"\\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\""], ["proof (prove)\nusing this:\n  \\<exists>a. atom a \\<sharp> (h, h a)\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x", "by (rule freshness_lemma)"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\n\ngoal (1 subgoal):\n 1. \\<And>a'. atom a' \\<sharp> h \\<Longrightarrow> h a' = h a", "with b c"], ["proof (chain)\npicking this:\n  atom a \\<sharp> h\n  atom a' \\<sharp> h\n  \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x", "show \"h a' = h a\""], ["proof (prove)\nusing this:\n  atom a \\<sharp> h\n  atom a' \\<sharp> h\n  \\<exists>x. \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = x\n\ngoal (1 subgoal):\n 1. h a' = h a", "by auto"], ["proof (state)\nthis:\n  h a' = h a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a'. atom a' \\<sharp> h \\<longrightarrow> h a' = h a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a.\n          atom a \\<sharp> h \\<longrightarrow> h a = x \\<Longrightarrow>\n       x = h a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a.\n          atom a \\<sharp> h \\<longrightarrow> h a = x \\<Longrightarrow>\n       x = h a", "fix fr :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a.\n          atom a \\<sharp> h \\<longrightarrow> h a = x \\<Longrightarrow>\n       x = h a", "assume \"\\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = fr\""], ["proof (state)\nthis:\n  \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = fr\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a.\n          atom a \\<sharp> h \\<longrightarrow> h a = x \\<Longrightarrow>\n       x = h a", "with b"], ["proof (chain)\npicking this:\n  atom a \\<sharp> h\n  \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = fr", "show \"fr = h a\""], ["proof (prove)\nusing this:\n  atom a \\<sharp> h\n  \\<forall>a. atom a \\<sharp> h \\<longrightarrow> h a = fr\n\ngoal (1 subgoal):\n 1. fr = h a", "by auto"], ["proof (state)\nthis:\n  fr = h a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Fresh_apply':\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"atom a \\<sharp> h\" \"atom a \\<sharp> h a\"\n  shows \"Fresh h = h a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fresh h = h a", "apply (rule Fresh_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>a. atom a \\<sharp> (h, h a)\n 2. atom a \\<sharp> h", "apply (auto simp: fresh_Pair intro: a)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "simproc_setup Fresh_simproc (\"Fresh (h::'a::at \\<Rightarrow> 'b::pt)\") = \\<open>fn _ => fn ctxt => fn ctrm =>\n  let\n     val _ $ h = Thm.term_of ctrm\n\n     val cfresh = @{const_name fresh}\n     val catom  = @{const_name atom}\n\n     val atoms = Simplifier.prems_of ctxt\n      |> map_filter (fn thm => case Thm.prop_of thm of\n           _ $ (Const (cfresh, _) $ (Const (catom, _) $ atm) $ _) => SOME (atm) | _ => NONE)\n      |> distinct ((=))\n\n     fun get_thm atm =\n       let\n         val goal1 = HOLogic.mk_Trueprop (mk_fresh (mk_atom atm) h)\n         val goal2 = HOLogic.mk_Trueprop (mk_fresh (mk_atom atm) (h $ atm))\n\n         val thm1 = Goal.prove ctxt [] [] goal1 (K (asm_simp_tac ctxt 1))\n         val thm2 = Goal.prove ctxt [] [] goal2 (K (asm_simp_tac ctxt 1))\n       in\n         SOME (@{thm Fresh_apply'} OF [thm1, thm2] RS eq_reflection)\n       end handle ERROR _ => NONE\n  in\n    get_first get_thm atoms\n  end\n\\<close>"], ["", "lemma Fresh_eqvt:\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"\\<exists>a. atom a \\<sharp> (h, h a)\"\n  shows \"p \\<bullet> (Fresh h) = Fresh (p \\<bullet> h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = Fresh (p \\<bullet> h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = Fresh (p \\<bullet> h)", "from a"], ["proof (chain)\npicking this:\n  \\<exists>a. atom a \\<sharp> (h, h a)", "obtain a::\"'a::at\" where fr: \"atom a \\<sharp> h\" \"atom a \\<sharp> h a\""], ["proof (prove)\nusing this:\n  \\<exists>a. atom a \\<sharp> (h, h a)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>atom a \\<sharp> h; atom a \\<sharp> h a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis fresh_Pair)"], ["proof (state)\nthis:\n  atom a \\<sharp> h\n  atom a \\<sharp> h a\n\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = Fresh (p \\<bullet> h)", "then"], ["proof (chain)\npicking this:\n  atom a \\<sharp> h\n  atom a \\<sharp> h a", "have fr_p: \"atom (p \\<bullet> a) \\<sharp> (p \\<bullet> h)\" \"atom (p \\<bullet> a) \\<sharp> (p \\<bullet> h) (p \\<bullet> a)\""], ["proof (prove)\nusing this:\n  atom a \\<sharp> h\n  atom a \\<sharp> h a\n\ngoal (1 subgoal):\n 1. atom (p \\<bullet> a) \\<sharp> p \\<bullet> h &&&\n    atom (p \\<bullet> a) \\<sharp> (p \\<bullet> h) (p \\<bullet> a)", "by (metis atom_eqvt fresh_permute_iff eqvt_apply)+"], ["proof (state)\nthis:\n  atom (p \\<bullet> a) \\<sharp> p \\<bullet> h\n  atom (p \\<bullet> a) \\<sharp> (p \\<bullet> h) (p \\<bullet> a)\n\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = Fresh (p \\<bullet> h)", "have \"p \\<bullet> (Fresh h) = p \\<bullet> (h a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = p \\<bullet> h a", "using fr"], ["proof (prove)\nusing this:\n  atom a \\<sharp> h\n  atom a \\<sharp> h a\n\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = p \\<bullet> h a", "by simp"], ["proof (state)\nthis:\n  p \\<bullet> Fresh h = p \\<bullet> h a\n\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = Fresh (p \\<bullet> h)", "also"], ["proof (state)\nthis:\n  p \\<bullet> Fresh h = p \\<bullet> h a\n\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = Fresh (p \\<bullet> h)", "have \"... = (p \\<bullet> h) (p \\<bullet> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> h a = (p \\<bullet> h) (p \\<bullet> a)", "by simp"], ["proof (state)\nthis:\n  p \\<bullet> h a = (p \\<bullet> h) (p \\<bullet> a)\n\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = Fresh (p \\<bullet> h)", "also"], ["proof (state)\nthis:\n  p \\<bullet> h a = (p \\<bullet> h) (p \\<bullet> a)\n\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = Fresh (p \\<bullet> h)", "have \"... = Fresh (p \\<bullet> h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> h) (p \\<bullet> a) = Fresh (p \\<bullet> h)", "using fr_p"], ["proof (prove)\nusing this:\n  atom (p \\<bullet> a) \\<sharp> p \\<bullet> h\n  atom (p \\<bullet> a) \\<sharp> (p \\<bullet> h) (p \\<bullet> a)\n\ngoal (1 subgoal):\n 1. (p \\<bullet> h) (p \\<bullet> a) = Fresh (p \\<bullet> h)", "by simp"], ["proof (state)\nthis:\n  (p \\<bullet> h) (p \\<bullet> a) = Fresh (p \\<bullet> h)\n\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = Fresh (p \\<bullet> h)", "finally"], ["proof (chain)\npicking this:\n  p \\<bullet> Fresh h = Fresh (p \\<bullet> h)", "show \"p \\<bullet> (Fresh h) = Fresh (p \\<bullet> h)\""], ["proof (prove)\nusing this:\n  p \\<bullet> Fresh h = Fresh (p \\<bullet> h)\n\ngoal (1 subgoal):\n 1. p \\<bullet> Fresh h = Fresh (p \\<bullet> h)", "."], ["proof (state)\nthis:\n  p \\<bullet> Fresh h = Fresh (p \\<bullet> h)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Fresh_supports:\n  fixes h :: \"'a::at \\<Rightarrow> 'b::pt\"\n  assumes a: \"\\<exists>a. atom a \\<sharp> (h, h a)\"\n  shows \"(supp h) supports (Fresh h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp h supports Fresh h", "apply (simp add: supports_def fresh_def [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       a \\<sharp> h \\<and> b \\<sharp> h \\<longrightarrow>\n       (a \\<rightleftharpoons> b) \\<bullet> Fresh h = Fresh h", "apply (simp add: Fresh_eqvt [OF a] swap_fresh_fresh)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "notation Fresh (binder \"FRESH \" 10)"], ["", "lemma FRESH_f_iff:\n  fixes P :: \"'a::at \\<Rightarrow> 'b::pure\"\n  fixes f :: \"'b \\<Rightarrow> 'c::pure\"\n  assumes P: \"finite (supp P)\"\n  shows \"(FRESH x. f (P x)) = f (FRESH x. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FRESH x. f (P x)) = f (FRESH x. P x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (FRESH x. f (P x)) = f (FRESH x. P x)", "obtain a::'a where \"atom a \\<sharp> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<sharp> P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P"], ["proof (prove)\nusing this:\n  finite (supp P)\n\ngoal (1 subgoal):\n 1. (\\<And>a. atom a \\<sharp> P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh')"], ["proof (state)\nthis:\n  atom a \\<sharp> P\n\ngoal (1 subgoal):\n 1. (FRESH x. f (P x)) = f (FRESH x. P x)", "then"], ["proof (chain)\npicking this:\n  atom a \\<sharp> P", "show \"(FRESH x. f (P x)) = f (FRESH x. P x)\""], ["proof (prove)\nusing this:\n  atom a \\<sharp> P\n\ngoal (1 subgoal):\n 1. (FRESH x. f (P x)) = f (FRESH x. P x)", "by (simp add: pure_fresh)"], ["proof (state)\nthis:\n  (FRESH x. f (P x)) = f (FRESH x. P x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FRESH_binop_iff:\n  fixes P :: \"'a::at \\<Rightarrow> 'b::pure\"\n  fixes Q :: \"'a::at \\<Rightarrow> 'c::pure\"\n  fixes binop :: \"'b \\<Rightarrow> 'c \\<Rightarrow> 'd::pure\"\n  assumes P: \"finite (supp P)\"\n  and     Q: \"finite (supp Q)\"\n  shows \"(FRESH x. binop (P x) (Q x)) = binop (FRESH x. P x) (FRESH x. Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FRESH x. binop (P x) (Q x)) = binop (FRESH x. P x) (FRESH x. Q x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (FRESH x. binop (P x) (Q x)) = binop (FRESH x. P x) (FRESH x. Q x)", "from assms"], ["proof (chain)\npicking this:\n  finite (supp P)\n  finite (supp Q)", "have \"finite (supp (P, Q))\""], ["proof (prove)\nusing this:\n  finite (supp P)\n  finite (supp Q)\n\ngoal (1 subgoal):\n 1. finite (supp (P, Q))", "by (simp add: supp_Pair)"], ["proof (state)\nthis:\n  finite (supp (P, Q))\n\ngoal (1 subgoal):\n 1. (FRESH x. binop (P x) (Q x)) = binop (FRESH x. P x) (FRESH x. Q x)", "then"], ["proof (chain)\npicking this:\n  finite (supp (P, Q))", "obtain a::'a where \"atom a \\<sharp> (P, Q)\""], ["proof (prove)\nusing this:\n  finite (supp (P, Q))\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        atom a \\<sharp> (P, Q) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh')"], ["proof (state)\nthis:\n  atom a \\<sharp> (P, Q)\n\ngoal (1 subgoal):\n 1. (FRESH x. binop (P x) (Q x)) = binop (FRESH x. P x) (FRESH x. Q x)", "then"], ["proof (chain)\npicking this:\n  atom a \\<sharp> (P, Q)", "show ?thesis"], ["proof (prove)\nusing this:\n  atom a \\<sharp> (P, Q)\n\ngoal (1 subgoal):\n 1. (FRESH x. binop (P x) (Q x)) = binop (FRESH x. P x) (FRESH x. Q x)", "by (simp add: pure_fresh)"], ["proof (state)\nthis:\n  (FRESH x. binop (P x) (Q x)) = binop (FRESH x. P x) (FRESH x. Q x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FRESH_conj_iff:\n  fixes P Q :: \"'a::at \\<Rightarrow> bool\"\n  assumes P: \"finite (supp P)\" and Q: \"finite (supp Q)\"\n  shows \"(FRESH x. P x \\<and> Q x) \\<longleftrightarrow> (FRESH x. P x) \\<and> (FRESH x. Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FRESH x. P x \\<and> Q x) = ((FRESH x. P x) \\<and> (FRESH x. Q x))", "using P Q"], ["proof (prove)\nusing this:\n  finite (supp P)\n  finite (supp Q)\n\ngoal (1 subgoal):\n 1. (FRESH x. P x \\<and> Q x) = ((FRESH x. P x) \\<and> (FRESH x. Q x))", "by (rule FRESH_binop_iff)"], ["", "lemma FRESH_disj_iff:\n  fixes P Q :: \"'a::at \\<Rightarrow> bool\"\n  assumes P: \"finite (supp P)\" and Q: \"finite (supp Q)\"\n  shows \"(FRESH x. P x \\<or> Q x) \\<longleftrightarrow> (FRESH x. P x) \\<or> (FRESH x. Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FRESH x. P x \\<or> Q x) = ((FRESH x. P x) \\<or> (FRESH x. Q x))", "using P Q"], ["proof (prove)\nusing this:\n  finite (supp P)\n  finite (supp Q)\n\ngoal (1 subgoal):\n 1. (FRESH x. P x \\<or> Q x) = ((FRESH x. P x) \\<or> (FRESH x. Q x))", "by (rule FRESH_binop_iff)"], ["", "section \\<open>Automation for creating concrete atom types\\<close>"], ["", "text \\<open>At the moment only single-sort concrete atoms are supported.\\<close>"], ["", "ML_file \\<open>nominal_atoms.ML\\<close>"], ["", "section \\<open>Automatic equivariance procedure for inductive definitions\\<close>"], ["", "ML_file \\<open>nominal_eqvt.ML\\<close>"], ["", "end"]]}