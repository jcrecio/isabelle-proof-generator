{"file_name": "/home/qj213/afp-2021-10-22/thys/CRDT/Util.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CRDT", "problem_names": ["lemma kleisli_comm_cong:\n  assumes \"x \\<rhd> y = y \\<rhd> x\"\n  shows   \"z \\<rhd> x \\<rhd> y = z \\<rhd> y \\<rhd> x\"", "lemma kleisli_assoc:\n  shows \"(z \\<rhd> x) \\<rhd> y = z \\<rhd> (x \\<rhd> y)\"", "lemma distinct_set_notin [dest]:\n  assumes \"distinct (x#xs)\"\n  shows   \"x \\<notin> set xs\"", "lemma set_membership_equality_technicalD [dest]:\n  assumes \"{x} \\<union> (set xs) = {y} \\<union> (set ys)\"\n  shows \"x = y \\<or> y \\<in> set xs\"", "lemma set_equality_technical:\n  assumes \"{x} \\<union> (set xs) = {y} \\<union> (set ys)\"\n      and \"x \\<notin> set xs\"\n      and \"y \\<notin> set ys\"\n      and \"y \\<in> set xs\"\n    shows \"{x} \\<union> (set xs - {y}) = set ys\"", "lemma set_elem_nth:\n  assumes \"x \\<in> set xs\"\n  shows   \"\\<exists>m. m < length xs \\<and> xs ! m = x\"", "lemma list_nil_or_snoc:\n  shows \"xs = [] \\<or> (\\<exists>y ys. xs = ys@[y])\"", "lemma suffix_eq_distinct_list:\n  assumes \"distinct xs\"\n      and \"ys@suf1 = xs\"\n      and \"ys@suf2 = xs\"\n    shows \"suf1 = suf2\"", "lemma pre_suf_eq_distinct_list:\n  assumes \"distinct xs\"\n      and \"ys \\<noteq> []\"\n      and \"pre1@ys@suf1 = xs\"\n      and \"pre2@ys@suf2 = xs\"\n    shows \"pre1 = pre2 \\<and> suf1 = suf2\"", "lemma list_head_unaffected:\n  assumes \"hd (x @ [y, z]) = v\"\n    shows \"hd (x @ [y   ]) = v\"", "lemma list_head_butlast:\n  assumes \"hd xs = v\"\n  and \"length xs > 1\"\n  shows \"hd (butlast xs) = v\"", "lemma list_head_length_one:\n  assumes \"hd xs = x\"\n    and \"length xs = 1\"\n  shows \"xs = [x]\"", "lemma list_two_at_end:\n  assumes \"length xs > 1\"\n  shows \"\\<exists>xs' x y. xs = xs' @ [x, y]\"", "lemma list_nth_split_technical:\n  assumes \"m < length cs\"\n      and \"cs \\<noteq> []\"\n    shows \"\\<exists>xs ys. cs = xs@(cs!m)#ys\"", "lemma list_nth_split:\n  assumes \"m < length cs\"\n      and \"n < m\"\n      and \"1 < length cs\"\n    shows \"\\<exists>xs ys zs. cs = xs@(cs!n)#ys@(cs!m)#zs\"", "lemma list_split_two_elems:\n  assumes \"distinct cs\"\n      and \"x \\<in> set cs\"\n      and \"y \\<in> set cs\"\n      and \"x \\<noteq> y\"\n    shows \"\\<exists>pre mid suf. cs = pre @ x # mid @ y # suf \\<or> cs = pre @ y # mid @ x # suf\"", "lemma split_list_unique_prefix:\n  assumes \"x \\<in> set xs\"\n  shows \"\\<exists>pre suf. xs = pre @ x # suf \\<and> (\\<forall>y \\<in> set pre. x \\<noteq> y)\"", "lemma map_filter_append:\n  shows \"List.map_filter P (xs @ ys) = List.map_filter P xs @ List.map_filter P ys\""], "translations": [["", "lemma kleisli_comm_cong:\n  assumes \"x \\<rhd> y = y \\<rhd> x\"\n  shows   \"z \\<rhd> x \\<rhd> y = z \\<rhd> y \\<rhd> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<rhd> x \\<rhd> y = z \\<rhd> y \\<rhd> x", "using assms"], ["proof (prove)\nusing this:\n  x \\<rhd> y = y \\<rhd> x\n\ngoal (1 subgoal):\n 1. z \\<rhd> x \\<rhd> y = z \\<rhd> y \\<rhd> x", "by(clarsimp simp add: kleisli_def)"], ["", "lemma kleisli_assoc:\n  shows \"(z \\<rhd> x) \\<rhd> y = z \\<rhd> (x \\<rhd> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<rhd> x) \\<rhd> y = z \\<rhd> x \\<rhd> y", "by(auto simp add: kleisli_def)"], ["", "subsection\\<open>Lemmas about sets\\<close>"], ["", "lemma distinct_set_notin [dest]:\n  assumes \"distinct (x#xs)\"\n  shows   \"x \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs", "using assms"], ["proof (prove)\nusing this:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs", "by(induction xs, auto)"], ["", "lemma set_membership_equality_technicalD [dest]:\n  assumes \"{x} \\<union> (set xs) = {y} \\<union> (set ys)\"\n  shows \"x = y \\<or> y \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<or> y \\<in> set xs", "using assms"], ["proof (prove)\nusing this:\n  {x} \\<union> set xs = {y} \\<union> set ys\n\ngoal (1 subgoal):\n 1. x = y \\<or> y \\<in> set xs", "by(induction xs, auto)"], ["", "lemma set_equality_technical:\n  assumes \"{x} \\<union> (set xs) = {y} \\<union> (set ys)\"\n      and \"x \\<notin> set xs\"\n      and \"y \\<notin> set ys\"\n      and \"y \\<in> set xs\"\n    shows \"{x} \\<union> (set xs - {y}) = set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} \\<union> (set xs - {y}) = set ys", "using assms"], ["proof (prove)\nusing this:\n  {x} \\<union> set xs = {y} \\<union> set ys\n  x \\<notin> set xs\n  y \\<notin> set ys\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. {x} \\<union> (set xs - {y}) = set ys", "by (induction xs) auto"], ["", "lemma set_elem_nth:\n  assumes \"x \\<in> set xs\"\n  shows   \"\\<exists>m. m < length xs \\<and> xs ! m = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m<length xs. xs ! m = x", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>m<length xs. xs ! m = x", "by(induction xs, simp) (meson in_set_conv_nth)"], ["", "subsection\\<open>Lemmas about list\\<close>"], ["", "lemma list_nil_or_snoc:\n  shows \"xs = [] \\<or> (\\<exists>y ys. xs = ys@[y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [] \\<or> (\\<exists>y ys. xs = ys @ [y])", "by (induction xs, auto)"], ["", "lemma suffix_eq_distinct_list:\n  assumes \"distinct xs\"\n      and \"ys@suf1 = xs\"\n      and \"ys@suf2 = xs\"\n    shows \"suf1 = suf2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. suf1 = suf2", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  ys @ suf1 = xs\n  ys @ suf2 = xs\n\ngoal (1 subgoal):\n 1. suf1 = suf2", "by(induction xs arbitrary: suf1 suf2 rule: rev_induct, simp) (metis append_eq_append_conv)"], ["", "lemma pre_suf_eq_distinct_list:\n  assumes \"distinct xs\"\n      and \"ys \\<noteq> []\"\n      and \"pre1@ys@suf1 = xs\"\n      and \"pre2@ys@suf2 = xs\"\n    shows \"pre1 = pre2 \\<and> suf1 = suf2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre1 = pre2 \\<and> suf1 = suf2", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  ys \\<noteq> []\n  pre1 @ ys @ suf1 = xs\n  pre2 @ ys @ suf2 = xs\n\ngoal (1 subgoal):\n 1. pre1 = pre2 \\<and> suf1 = suf2", "apply(induction xs arbitrary: pre1 pre2 ys, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs pre1 pre2 ys.\n       \\<lbrakk>\\<And>pre1 pre2 ys.\n                   \\<lbrakk>distinct xs; ys \\<noteq> [];\n                    pre1 @ ys @ suf1 = xs; pre2 @ ys @ suf2 = xs\\<rbrakk>\n                   \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2;\n        distinct (a # xs); ys \\<noteq> []; pre1 @ ys @ suf1 = a # xs;\n        pre2 @ ys @ suf2 = a # xs\\<rbrakk>\n       \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2", "apply(case_tac \"pre1\"; case_tac \"pre2\"; clarify)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a xs pre1 pre2 ys.\n       \\<lbrakk>\\<And>pre1 pre2 ys.\n                   \\<lbrakk>distinct xs; ys \\<noteq> [];\n                    pre1 @ ys @ suf1 = xs;\n                    pre2 @ ys @ suf2 = pre1 @ ys @ suf1\\<rbrakk>\n                   \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2;\n        distinct (a # xs); ys \\<noteq> []; [] @ ys @ suf1 = a # xs;\n        [] @ ys @ suf2 = a # xs\\<rbrakk>\n       \\<Longrightarrow> [] = [] \\<and> suf1 = suf2\n 2. \\<And>a xs pre1 pre2 ys aa list.\n       \\<lbrakk>\\<And>pre1 pre2 ys.\n                   \\<lbrakk>distinct xs; ys \\<noteq> [];\n                    pre1 @ ys @ suf1 = xs;\n                    pre2 @ ys @ suf2 = pre1 @ ys @ suf1\\<rbrakk>\n                   \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2;\n        distinct (a # xs); ys \\<noteq> []; [] @ ys @ suf1 = a # xs;\n        (aa # list) @ ys @ suf2 = a # xs\\<rbrakk>\n       \\<Longrightarrow> [] = aa # list \\<and> suf1 = suf2\n 3. \\<And>a xs pre1 pre2 ys aa list.\n       \\<lbrakk>\\<And>pre1 pre2 ys.\n                   \\<lbrakk>distinct xs; ys \\<noteq> [];\n                    pre1 @ ys @ suf1 = xs;\n                    pre2 @ ys @ suf2 = pre1 @ ys @ suf1\\<rbrakk>\n                   \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2;\n        distinct (a # xs); ys \\<noteq> []; (aa # list) @ ys @ suf1 = a # xs;\n        [] @ ys @ suf2 = a # xs\\<rbrakk>\n       \\<Longrightarrow> aa # list = [] \\<and> suf1 = suf2\n 4. \\<And>a xs pre1 pre2 ys aa list ab lista.\n       \\<lbrakk>\\<And>pre1 pre2 ys.\n                   \\<lbrakk>distinct xs; ys \\<noteq> [];\n                    pre1 @ ys @ suf1 = xs;\n                    pre2 @ ys @ suf2 = pre1 @ ys @ suf1\\<rbrakk>\n                   \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2;\n        distinct (a # xs); ys \\<noteq> []; (aa # list) @ ys @ suf1 = a # xs;\n        (ab # lista) @ ys @ suf2 = a # xs\\<rbrakk>\n       \\<Longrightarrow> aa # list = ab # lista \\<and> suf1 = suf2", "apply(metis suffix_eq_distinct_list append_Nil)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a xs pre1 pre2 ys aa list.\n       \\<lbrakk>\\<And>pre1 pre2 ys.\n                   \\<lbrakk>distinct xs; ys \\<noteq> [];\n                    pre1 @ ys @ suf1 = xs;\n                    pre2 @ ys @ suf2 = pre1 @ ys @ suf1\\<rbrakk>\n                   \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2;\n        distinct (a # xs); ys \\<noteq> []; [] @ ys @ suf1 = a # xs;\n        (aa # list) @ ys @ suf2 = a # xs\\<rbrakk>\n       \\<Longrightarrow> [] = aa # list \\<and> suf1 = suf2\n 2. \\<And>a xs pre1 pre2 ys aa list.\n       \\<lbrakk>\\<And>pre1 pre2 ys.\n                   \\<lbrakk>distinct xs; ys \\<noteq> [];\n                    pre1 @ ys @ suf1 = xs;\n                    pre2 @ ys @ suf2 = pre1 @ ys @ suf1\\<rbrakk>\n                   \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2;\n        distinct (a # xs); ys \\<noteq> []; (aa # list) @ ys @ suf1 = a # xs;\n        [] @ ys @ suf2 = a # xs\\<rbrakk>\n       \\<Longrightarrow> aa # list = [] \\<and> suf1 = suf2\n 3. \\<And>a xs pre1 pre2 ys aa list ab lista.\n       \\<lbrakk>\\<And>pre1 pre2 ys.\n                   \\<lbrakk>distinct xs; ys \\<noteq> [];\n                    pre1 @ ys @ suf1 = xs;\n                    pre2 @ ys @ suf2 = pre1 @ ys @ suf1\\<rbrakk>\n                   \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2;\n        distinct (a # xs); ys \\<noteq> []; (aa # list) @ ys @ suf1 = a # xs;\n        (ab # lista) @ ys @ suf2 = a # xs\\<rbrakk>\n       \\<Longrightarrow> aa # list = ab # lista \\<and> suf1 = suf2", "apply(metis Un_iff append_eq_Cons_conv distinct.simps(2) list.set_intros(1) set_append suffix_eq_distinct_list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs pre1 pre2 ys aa list.\n       \\<lbrakk>\\<And>pre1 pre2 ys.\n                   \\<lbrakk>distinct xs; ys \\<noteq> [];\n                    pre1 @ ys @ suf1 = xs;\n                    pre2 @ ys @ suf2 = pre1 @ ys @ suf1\\<rbrakk>\n                   \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2;\n        distinct (a # xs); ys \\<noteq> []; (aa # list) @ ys @ suf1 = a # xs;\n        [] @ ys @ suf2 = a # xs\\<rbrakk>\n       \\<Longrightarrow> aa # list = [] \\<and> suf1 = suf2\n 2. \\<And>a xs pre1 pre2 ys aa list ab lista.\n       \\<lbrakk>\\<And>pre1 pre2 ys.\n                   \\<lbrakk>distinct xs; ys \\<noteq> [];\n                    pre1 @ ys @ suf1 = xs;\n                    pre2 @ ys @ suf2 = pre1 @ ys @ suf1\\<rbrakk>\n                   \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2;\n        distinct (a # xs); ys \\<noteq> []; (aa # list) @ ys @ suf1 = a # xs;\n        (ab # lista) @ ys @ suf2 = a # xs\\<rbrakk>\n       \\<Longrightarrow> aa # list = ab # lista \\<and> suf1 = suf2", "apply(metis Un_iff append_eq_Cons_conv distinct.simps(2) list.set_intros(1) set_append suffix_eq_distinct_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs pre1 pre2 ys aa list ab lista.\n       \\<lbrakk>\\<And>pre1 pre2 ys.\n                   \\<lbrakk>distinct xs; ys \\<noteq> [];\n                    pre1 @ ys @ suf1 = xs;\n                    pre2 @ ys @ suf2 = pre1 @ ys @ suf1\\<rbrakk>\n                   \\<Longrightarrow> pre1 = pre2 \\<and> suf1 = suf2;\n        distinct (a # xs); ys \\<noteq> []; (aa # list) @ ys @ suf1 = a # xs;\n        (ab # lista) @ ys @ suf2 = a # xs\\<rbrakk>\n       \\<Longrightarrow> aa # list = ab # lista \\<and> suf1 = suf2", "apply(metis distinct.simps(2) hd_append2 list.sel(1) list.sel(3) list.simps(3) tl_append2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_head_unaffected:\n  assumes \"hd (x @ [y, z]) = v\"\n    shows \"hd (x @ [y   ]) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (x @ [y]) = v", "using assms"], ["proof (prove)\nusing this:\n  hd (x @ [y, z]) = v\n\ngoal (1 subgoal):\n 1. hd (x @ [y]) = v", "by (metis hd_append list.sel(1))"], ["", "lemma list_head_butlast:\n  assumes \"hd xs = v\"\n  and \"length xs > 1\"\n  shows \"hd (butlast xs) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (butlast xs) = v", "using assms"], ["proof (prove)\nusing this:\n  hd xs = v\n  1 < length xs\n\ngoal (1 subgoal):\n 1. hd (butlast xs) = v", "by (metis hd_conv_nth length_butlast length_greater_0_conv less_trans nth_butlast zero_less_diff zero_less_one)"], ["", "lemma list_head_length_one:\n  assumes \"hd xs = x\"\n    and \"length xs = 1\"\n  shows \"xs = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [x]", "using assms"], ["proof (prove)\nusing this:\n  hd xs = x\n  length xs = 1\n\ngoal (1 subgoal):\n 1. xs = [x]", "by(metis One_nat_def Suc_length_conv hd_Cons_tl length_0_conv list.sel(3))"], ["", "lemma list_two_at_end:\n  assumes \"length xs > 1\"\n  shows \"\\<exists>xs' x y. xs = xs' @ [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs' x y. xs = xs' @ [x, y]", "using assms"], ["proof (prove)\nusing this:\n  1 < length xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs' x y. xs = xs' @ [x, y]", "apply(induction xs rule: rev_induct, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>1 < length xs \\<Longrightarrow>\n                \\<exists>xs' x y. xs = xs' @ [x, y];\n        1 < length (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs' xa y. xs @ [x] = xs' @ [xa, y]", "apply(case_tac \"length xs = 1\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       length xs = Suc 0 \\<Longrightarrow> \\<exists>xs' x. xs = xs' @ [x]\n 2. \\<And>x xs.\n       \\<lbrakk>1 < length xs \\<Longrightarrow>\n                \\<exists>xs' x y. xs = xs' @ [x, y];\n        1 < length (xs @ [x]); length xs \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs' xa y. xs @ [x] = xs' @ [xa, y]", "apply(metis append_self_conv2 length_0_conv length_Suc_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>1 < length xs \\<Longrightarrow>\n                \\<exists>xs' x y. xs = xs' @ [x, y];\n        1 < length (xs @ [x]); length xs \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs' xa y. xs @ [x] = xs' @ [xa, y]", "apply(rule_tac x=\"butlast xs\" in exI, rule_tac x=\"last xs\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_nth_split_technical:\n  assumes \"m < length cs\"\n      and \"cs \\<noteq> []\"\n    shows \"\\<exists>xs ys. cs = xs@(cs!m)#ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys. cs = xs @ cs ! m # ys", "using assms"], ["proof (prove)\nusing this:\n  m < length cs\n  cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys. cs = xs @ cs ! m # ys", "apply(induction m arbitrary: cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>0 < length cs; cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys. cs = xs @ cs ! 0 # ys\n 2. \\<And>m cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>m < length cs; cs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys. cs = xs @ cs ! m # ys;\n        Suc m < length cs; cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys. cs = xs @ cs ! Suc m # ys", "apply(meson in_set_conv_decomp nth_mem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>m < length cs; cs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys. cs = xs @ cs ! m # ys;\n        Suc m < length cs; cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys. cs = xs @ cs ! Suc m # ys", "apply(metis in_set_conv_decomp length_list_update set_swap set_update_memI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_nth_split:\n  assumes \"m < length cs\"\n      and \"n < m\"\n      and \"1 < length cs\"\n    shows \"\\<exists>xs ys zs. cs = xs@(cs!n)#ys@(cs!m)#zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs. cs = xs @ cs ! n # ys @ cs ! m # zs", "using assms"], ["proof (prove)\nusing this:\n  m < length cs\n  n < m\n  1 < length cs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs. cs = xs @ cs ! n # ys @ cs ! m # zs", "proof(induction n arbitrary: cs m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs m.\n       \\<lbrakk>m < length cs; 0 < m; 1 < length cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! 0 # ys @ cs ! m # zs\n 2. \\<And>n cs m.\n       \\<lbrakk>\\<And>cs m.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "case 0"], ["proof (state)\nthis:\n  m < length cs\n  0 < m\n  1 < length cs\n\ngoal (2 subgoals):\n 1. \\<And>cs m.\n       \\<lbrakk>m < length cs; 0 < m; 1 < length cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! 0 # ys @ cs ! m # zs\n 2. \\<And>n cs m.\n       \\<lbrakk>\\<And>cs m.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "thus ?case"], ["proof (prove)\nusing this:\n  m < length cs\n  0 < m\n  1 < length cs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs. cs = xs @ cs ! 0 # ys @ cs ! m # zs", "apply(case_tac cs; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>m < Suc (length list); list \\<noteq> []; cs = a # list;\n        0 < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            a # list = xs @ a # ys @ list ! (m - Suc 0) # zs", "apply(rule_tac x=\"[]\" in exI, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>m < Suc (length list); list \\<noteq> []; cs = a # list;\n        0 < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs. list = ys @ list ! (m - Suc 0) # zs", "apply(rule list_nth_split_technical, simp, force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>xs ys zs. cs = xs @ cs ! 0 # ys @ cs ! m # zs\n\ngoal (1 subgoal):\n 1. \\<And>n cs m.\n       \\<lbrakk>\\<And>cs m.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n cs m.\n       \\<lbrakk>\\<And>cs m.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>?m < length ?cs; n < ?m; 1 < length ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys zs.\n                       ?cs = xs @ ?cs ! n # ys @ ?cs ! ?m # zs\n  m < length cs\n  Suc n < m\n  1 < length cs\n\ngoal (1 subgoal):\n 1. \\<And>n cs m.\n       \\<lbrakk>\\<And>cs m.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m < length ?cs; n < ?m; 1 < length ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys zs.\n                       ?cs = xs @ ?cs ! n # ys @ ?cs ! ?m # zs\n  m < length cs\n  Suc n < m\n  1 < length cs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs. cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "proof (cases cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m cs.\n                \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs ys zs.\n                                     cs = xs @ cs ! n # ys @ cs ! m # zs;\n     m < length cs; Suc n < m; 1 < length cs; cs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         cs = xs @ cs ! Suc n # ys @ cs ! m # zs\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>m cs.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs; cs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "case Nil"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m cs.\n                \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs ys zs.\n                                     cs = xs @ cs ! n # ys @ cs ! m # zs;\n     m < length cs; Suc n < m; 1 < length cs; cs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         cs = xs @ cs ! Suc n # ys @ cs ! m # zs\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>m cs.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs; cs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "then"], ["proof (chain)\npicking this:\n  cs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = []\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs. cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "using Suc.prems"], ["proof (prove)\nusing this:\n  cs = []\n  m < length cs\n  Suc n < m\n  1 < length cs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs. cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs ys zs. cs = xs @ cs ! Suc n # ys @ cs ! m # zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>m cs.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs; cs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>m cs.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs; cs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "case (Cons a as)"], ["proof (state)\nthis:\n  cs = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>m cs.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs; cs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "hence \"m-1 < length as\" \"n < m-1\""], ["proof (prove)\nusing this:\n  cs = a # as\n\ngoal (1 subgoal):\n 1. m - 1 < length as &&& n < m - 1", "using Suc"], ["proof (prove)\nusing this:\n  cs = a # as\n  \\<lbrakk>?m < length ?cs; n < ?m; 1 < length ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys zs.\n                       ?cs = xs @ ?cs ! n # ys @ ?cs ! ?m # zs\n  m < length cs\n  Suc n < m\n  1 < length cs\n\ngoal (1 subgoal):\n 1. m - 1 < length as &&& n < m - 1", "by force+"], ["proof (state)\nthis:\n  m - 1 < length as\n  n < m - 1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>m cs.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs; cs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "then"], ["proof (chain)\npicking this:\n  m - 1 < length as\n  n < m - 1", "obtain xs ys zs where \"as = xs @ as ! n # ys @ as ! (m-1) # zs\""], ["proof (prove)\nusing this:\n  m - 1 < length as\n  n < m - 1\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys zs.\n        as = xs @ as ! n # ys @ as ! (m - 1) # zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Suc"], ["proof (prove)\nusing this:\n  m - 1 < length as\n  n < m - 1\n  \\<lbrakk>?m < length ?cs; n < ?m; 1 < length ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys zs.\n                       ?cs = xs @ ?cs ! n # ys @ ?cs ! ?m # zs\n  m < length cs\n  Suc n < m\n  1 < length cs\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys zs.\n        as = xs @ as ! n # ys @ as ! (m - 1) # zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  as = xs @ as ! n # ys @ as ! (m - 1) # zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>m cs.\n                   \\<lbrakk>m < length cs; n < m; 1 < length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  cs = xs @ cs ! n # ys @ cs ! m # zs;\n        m < length cs; Suc n < m; 1 < length cs; cs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "thus ?thesis"], ["proof (prove)\nusing this:\n  as = xs @ as ! n # ys @ as ! (m - 1) # zs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs. cs = xs @ cs ! Suc n # ys @ cs ! m # zs", "apply(rule_tac x=\"a#xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. as = xs @ as ! n # ys @ as ! (m - 1) # zs \\<Longrightarrow>\n    \\<exists>ys zs. cs = (a # xs) @ cs ! Suc n # ys @ cs ! m # zs", "using Suc Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m < length ?cs; n < ?m; 1 < length ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys zs.\n                       ?cs = xs @ ?cs ! n # ys @ ?cs ! ?m # zs\n  m < length cs\n  Suc n < m\n  1 < length cs\n  cs = a # as\n\ngoal (1 subgoal):\n 1. as = xs @ as ! n # ys @ as ! (m - 1) # zs \\<Longrightarrow>\n    \\<exists>ys zs. cs = (a # xs) @ cs ! Suc n # ys @ cs ! m # zs", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>xs ys zs. cs = xs @ cs ! Suc n # ys @ cs ! m # zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs ys zs. cs = xs @ cs ! Suc n # ys @ cs ! m # zs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_split_two_elems:\n  assumes \"distinct cs\"\n      and \"x \\<in> set cs\"\n      and \"y \\<in> set cs\"\n      and \"x \\<noteq> y\"\n    shows \"\\<exists>pre mid suf. cs = pre @ x # mid @ y # suf \\<or> cs = pre @ y # mid @ x # suf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pre mid suf.\n       cs = pre @ x # mid @ y # suf \\<or> cs = pre @ y # mid @ x # suf", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>pre mid suf.\n       cs = pre @ x # mid @ y # suf \\<or> cs = pre @ y # mid @ x # suf", "obtain xi yi where *: \"xi < length cs \\<and> x = cs ! xi\" \"yi < length cs \\<and> y = cs ! yi\" \"xi \\<noteq> yi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xi yi.\n        \\<lbrakk>xi < length cs \\<and> x = cs ! xi;\n         yi < length cs \\<and> y = cs ! yi; xi \\<noteq> yi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using set_elem_nth linorder_neqE_nat assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set ?xs \\<Longrightarrow> \\<exists>m<length ?xs. ?xs ! m = ?x\n  \\<lbrakk>?x \\<noteq> ?y; ?x < ?y \\<Longrightarrow> ?R;\n   ?y < ?x \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  distinct cs\n  x \\<in> set cs\n  y \\<in> set cs\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (\\<And>xi yi.\n        \\<lbrakk>xi < length cs \\<and> x = cs ! xi;\n         yi < length cs \\<and> y = cs ! yi; xi \\<noteq> yi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xi < length cs \\<and> x = cs ! xi\n  yi < length cs \\<and> y = cs ! yi\n  xi \\<noteq> yi\n\ngoal (1 subgoal):\n 1. \\<exists>pre mid suf.\n       cs = pre @ x # mid @ y # suf \\<or> cs = pre @ y # mid @ x # suf", "thus ?thesis"], ["proof (prove)\nusing this:\n  xi < length cs \\<and> x = cs ! xi\n  yi < length cs \\<and> y = cs ! yi\n  xi \\<noteq> yi\n\ngoal (1 subgoal):\n 1. \\<exists>pre mid suf.\n       cs = pre @ x # mid @ y # suf \\<or> cs = pre @ y # mid @ x # suf", "by (metis list_nth_split One_nat_def less_Suc_eq linorder_neqE_nat not_less_zero)"], ["proof (state)\nthis:\n  \\<exists>pre mid suf.\n     cs = pre @ x # mid @ y # suf \\<or> cs = pre @ y # mid @ x # suf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_list_unique_prefix:\n  assumes \"x \\<in> set xs\"\n  shows \"\\<exists>pre suf. xs = pre @ x # suf \\<and> (\\<forall>y \\<in> set pre. x \\<noteq> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set [] \\<Longrightarrow>\n    \\<exists>pre suf.\n       [] = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                \\<exists>pre suf.\n                   xs = pre @ x # suf \\<and>\n                   (\\<forall>y\\<in>set pre. x \\<noteq> y);\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            a # xs = pre @ x # suf \\<and>\n                            (\\<forall>y\\<in>set pre. x \\<noteq> y)", "case Nil"], ["proof (state)\nthis:\n  x \\<in> set []\n\ngoal (2 subgoals):\n 1. x \\<in> set [] \\<Longrightarrow>\n    \\<exists>pre suf.\n       [] = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                \\<exists>pre suf.\n                   xs = pre @ x # suf \\<and>\n                   (\\<forall>y\\<in>set pre. x \\<noteq> y);\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            a # xs = pre @ x # suf \\<and>\n                            (\\<forall>y\\<in>set pre. x \\<noteq> y)", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       [] = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     [] = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                \\<exists>pre suf.\n                   xs = pre @ x # suf \\<and>\n                   (\\<forall>y\\<in>set pre. x \\<noteq> y);\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            a # xs = pre @ x # suf \\<and>\n                            (\\<forall>y\\<in>set pre. x \\<noteq> y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                \\<exists>pre suf.\n                   xs = pre @ x # suf \\<and>\n                   (\\<forall>y\\<in>set pre. x \\<noteq> y);\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            a # xs = pre @ x # suf \\<and>\n                            (\\<forall>y\\<in>set pre. x \\<noteq> y)", "case (Cons y ys)"], ["proof (state)\nthis:\n  x \\<in> set ys \\<Longrightarrow>\n  \\<exists>pre suf.\n     ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n  x \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow>\n                \\<exists>pre suf.\n                   xs = pre @ x # suf \\<and>\n                   (\\<forall>y\\<in>set pre. x \\<noteq> y);\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            a # xs = pre @ x # suf \\<and>\n                            (\\<forall>y\\<in>set pre. x \\<noteq> y)", "then"], ["proof (chain)\npicking this:\n  x \\<in> set ys \\<Longrightarrow>\n  \\<exists>pre suf.\n     ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n  x \\<in> set (y # ys)", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> set ys \\<Longrightarrow>\n  \\<exists>pre suf.\n     ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n  x \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       y # ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)", "proof (cases \"y=x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set ys \\<Longrightarrow>\n             \\<exists>pre suf.\n                ys = pre @ x # suf \\<and>\n                (\\<forall>y\\<in>set pre. x \\<noteq> y);\n     x \\<in> set (y # ys); y = x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         y # ys = pre @ x # suf \\<and>\n                         (\\<forall>y\\<in>set pre. x \\<noteq> y)\n 2. \\<lbrakk>x \\<in> set ys \\<Longrightarrow>\n             \\<exists>pre suf.\n                ys = pre @ x # suf \\<and>\n                (\\<forall>y\\<in>set pre. x \\<noteq> y);\n     x \\<in> set (y # ys); y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         y # ys = pre @ x # suf \\<and>\n                         (\\<forall>y\\<in>set pre. x \\<noteq> y)", "case True"], ["proof (state)\nthis:\n  y = x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set ys \\<Longrightarrow>\n             \\<exists>pre suf.\n                ys = pre @ x # suf \\<and>\n                (\\<forall>y\\<in>set pre. x \\<noteq> y);\n     x \\<in> set (y # ys); y = x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         y # ys = pre @ x # suf \\<and>\n                         (\\<forall>y\\<in>set pre. x \\<noteq> y)\n 2. \\<lbrakk>x \\<in> set ys \\<Longrightarrow>\n             \\<exists>pre suf.\n                ys = pre @ x # suf \\<and>\n                (\\<forall>y\\<in>set pre. x \\<noteq> y);\n     x \\<in> set (y # ys); y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         y # ys = pre @ x # suf \\<and>\n                         (\\<forall>y\\<in>set pre. x \\<noteq> y)", "then"], ["proof (chain)\npicking this:\n  y = x", "show ?thesis"], ["proof (prove)\nusing this:\n  y = x\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       y # ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)", "by force"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     y # ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys \\<Longrightarrow>\n             \\<exists>pre suf.\n                ys = pre @ x # suf \\<and>\n                (\\<forall>y\\<in>set pre. x \\<noteq> y);\n     x \\<in> set (y # ys); y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         y # ys = pre @ x # suf \\<and>\n                         (\\<forall>y\\<in>set pre. x \\<noteq> y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys \\<Longrightarrow>\n             \\<exists>pre suf.\n                ys = pre @ x # suf \\<and>\n                (\\<forall>y\\<in>set pre. x \\<noteq> y);\n     x \\<in> set (y # ys); y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         y # ys = pre @ x # suf \\<and>\n                         (\\<forall>y\\<in>set pre. x \\<noteq> y)", "case False"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys \\<Longrightarrow>\n             \\<exists>pre suf.\n                ys = pre @ x # suf \\<and>\n                (\\<forall>y\\<in>set pre. x \\<noteq> y);\n     x \\<in> set (y # ys); y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         y # ys = pre @ x # suf \\<and>\n                         (\\<forall>y\\<in>set pre. x \\<noteq> y)", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> x", "obtain pre suf where \"ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\""], ["proof (prove)\nusing this:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        ys = pre @ x # suf \\<and>\n        (\\<forall>y\\<in>set pre. x \\<noteq> y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms Cons"], ["proof (prove)\nusing this:\n  y \\<noteq> x\n  x \\<in> set xs\n  x \\<in> set ys \\<Longrightarrow>\n  \\<exists>pre suf.\n     ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n  x \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        ys = pre @ x # suf \\<and>\n        (\\<forall>y\\<in>set pre. x \\<noteq> y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys \\<Longrightarrow>\n             \\<exists>pre suf.\n                ys = pre @ x # suf \\<and>\n                (\\<forall>y\\<in>set pre. x \\<noteq> y);\n     x \\<in> set (y # ys); y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         y # ys = pre @ x # suf \\<and>\n                         (\\<forall>y\\<in>set pre. x \\<noteq> y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       y # ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)", "using split_list_first"], ["proof (prove)\nusing this:\n  ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n  ?x \\<in> set ?xs \\<Longrightarrow>\n  \\<exists>ys zs. ?xs = ys @ ?x # zs \\<and> ?x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       y # ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)", "by force"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     y # ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     y # ys = pre @ x # suf \\<and> (\\<forall>y\\<in>set pre. x \\<noteq> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_filter_append:\n  shows \"List.map_filter P (xs @ ys) = List.map_filter P xs @ List.map_filter P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter P (xs @ ys) =\n    List.map_filter P xs @ List.map_filter P ys", "by(auto simp add: List.map_filter_def)"], ["", "end"]]}