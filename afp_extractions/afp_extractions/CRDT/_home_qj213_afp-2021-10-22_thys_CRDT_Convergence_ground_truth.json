{"file_name": "/home/qj213/afp-2021-10-22/thys/CRDT/Convergence.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CRDT", "problem_names": ["lemma concurrentI [intro!]: \"\\<not> (s1 \\<prec> s2) \\<Longrightarrow> \\<not> (s2 \\<prec> s1) \\<Longrightarrow> s1 \\<parallel> s2\"", "lemma concurrentD1 [dest]: \"s1 \\<parallel> s2 \\<Longrightarrow> \\<not> (s1 \\<prec> s2)\"", "lemma concurrentD2 [dest]: \"s1 \\<parallel> s2 \\<Longrightarrow> \\<not> (s2 \\<prec> s1)\"", "lemma concurrent_refl [intro!, simp]: \"s \\<parallel> s\"", "lemma concurrent_comm: \"s1 \\<parallel> s2 \\<longleftrightarrow> s2 \\<parallel> s1\"", "lemma concurrent_set_empty [simp, intro!]:\n  \"concurrent_set x []\"", "lemma concurrent_set_ConsE [elim!]:\n  assumes \"concurrent_set a (x#xs)\"\n      and \"concurrent_set a xs \\<Longrightarrow> concurrent x a \\<Longrightarrow> G\"\n    shows \"G\"", "lemma concurrent_set_ConsI [intro!]:\n  \"concurrent_set a xs \\<Longrightarrow> concurrent a x \\<Longrightarrow> concurrent_set a (x#xs)\"", "lemma concurrent_set_appendI [intro!]:\n  \"concurrent_set a xs \\<Longrightarrow> concurrent_set a ys \\<Longrightarrow> concurrent_set a (xs@ys)\"", "lemma concurrent_set_Cons_Snoc [simp]:\n  \"concurrent_set a (xs@[x]) = concurrent_set a (x#xs)\"", "lemma \"(x \\<prec> y \\<or> concurrent x y) = (\\<not> y \\<prec> x)\"", "lemma consistentI [intro!]:\n  assumes \"hb_consistent (xs @ ys)\"\n  and     \"\\<forall>x \\<in> set (xs @ ys). \\<not> z \\<prec> x\"\n  shows   \"hb_consistent (xs @ ys @ [z])\"", "lemma hb_consistent_append_D1 [dest]:\n  assumes \"hb_consistent (xs @ ys)\"\n  shows   \"hb_consistent xs\"", "lemma hb_consistent_append_D2 [dest]:\n  assumes \"hb_consistent (xs @ ys)\"\n  shows   \"hb_consistent ys\"", "lemma hb_consistent_append_elim_ConsD [elim]:\n  assumes \"hb_consistent (y#ys)\"\n  shows   \"hb_consistent ys\"", "lemma hb_consistent_remove1 [intro]:\n  assumes \"hb_consistent xs\"\n  shows   \"hb_consistent (remove1 x xs)\"", "lemma hb_consistent_singleton [intro!]:\n  shows \"hb_consistent [x]\"", "lemma hb_consistent_prefix_suffix_exists:\n  assumes \"hb_consistent ys\"\n          \"hb_consistent (xs @ [x])\"\n          \"{x} \\<union> set xs = set ys\"\n          \"distinct (x#xs)\"\n          \"distinct ys\"\n  shows \"\\<exists>prefix suffix. ys = prefix @ x # suffix \\<and> concurrent_set x suffix\"", "lemma hb_consistent_append [intro!]:\n  assumes \"hb_consistent suffix\"\n          \"hb_consistent prefix\"\n          \"\\<And>s p. s \\<in> set suffix \\<Longrightarrow> p \\<in> set prefix \\<Longrightarrow> \\<not> s \\<prec> p\"\n  shows \"hb_consistent (prefix @ suffix)\"", "lemma hb_consistent_append_porder:\n  assumes \"hb_consistent (xs @ ys)\"\n          \"x \\<in> set xs\"\n          \"y \\<in> set ys\"\n  shows   \"\\<not> y \\<prec> x\"", "lemma apply_operations_empty [simp]: \"apply_operations [] s = Some s\"", "lemma apply_operations_Snoc [simp]:\n  \"apply_operations (xs@[x]) = (apply_operations xs) \\<rhd> \\<langle>x\\<rangle>\"", "lemma concurrent_ops_commute_empty [intro!]: \"concurrent_ops_commute []\"", "lemma concurrent_ops_commute_singleton [intro!]: \"concurrent_ops_commute [x]\"", "lemma concurrent_ops_commute_appendD [dest]:\n  assumes \"concurrent_ops_commute (xs@ys)\"\n    shows \"concurrent_ops_commute xs\"", "lemma concurrent_ops_commute_rearrange:\n  \"concurrent_ops_commute (xs@x#ys) = concurrent_ops_commute (xs@ys@[x])\"", "lemma concurrent_ops_commute_concurrent_set:\n  assumes \"concurrent_ops_commute (prefix@suffix@[x])\"\n          \"concurrent_set x suffix\"\n          \"distinct (prefix @ x # suffix)\"\n  shows   \"apply_operations (prefix @ suffix @ [x]) = apply_operations (prefix @ x # suffix)\"", "theorem  convergence:\n  assumes \"set xs = set ys\"\n          \"concurrent_ops_commute xs\"\n          \"concurrent_ops_commute ys\"\n          \"distinct xs\"\n          \"distinct ys\"\n          \"hb_consistent xs\"\n          \"hb_consistent ys\"\n  shows   \"apply_operations xs = apply_operations ys\"", "theorem sec_convergence:\n  assumes \"set xs = set ys\"\n          \"op_history xs\"\n          \"op_history ys\"\n  shows   \"apply_operations xs = apply_operations ys\"", "theorem sec_progress:\n  assumes \"op_history xs\"\n  shows   \"apply_operations xs initial_state \\<noteq> None\""], "translations": [["", "lemma concurrentI [intro!]: \"\\<not> (s1 \\<prec> s2) \\<Longrightarrow> \\<not> (s2 \\<prec> s1) \\<Longrightarrow> s1 \\<parallel> s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> s1 \\<prec> s2; \\<not> s2 \\<prec> s1\\<rbrakk>\n    \\<Longrightarrow> s1 \\<parallel> s2", "by (auto simp: concurrent_def)"], ["", "lemma concurrentD1 [dest]: \"s1 \\<parallel> s2 \\<Longrightarrow> \\<not> (s1 \\<prec> s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<parallel> s2 \\<Longrightarrow> \\<not> s1 \\<prec> s2", "by (auto simp: concurrent_def)"], ["", "lemma concurrentD2 [dest]: \"s1 \\<parallel> s2 \\<Longrightarrow> \\<not> (s2 \\<prec> s1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<parallel> s2 \\<Longrightarrow> \\<not> s2 \\<prec> s1", "by (auto simp: concurrent_def)"], ["", "lemma concurrent_refl [intro!, simp]: \"s \\<parallel> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<parallel> s", "by (auto simp: concurrent_def)"], ["", "lemma concurrent_comm: \"s1 \\<parallel> s2 \\<longleftrightarrow> s2 \\<parallel> s1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s1 \\<parallel> s2) = (s2 \\<parallel> s1)", "by (auto simp: concurrent_def)"], ["", "definition concurrent_set :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  \"concurrent_set x xs \\<equiv> \\<forall>y \\<in> set xs. x \\<parallel> y\""], ["", "lemma concurrent_set_empty [simp, intro!]:\n  \"concurrent_set x []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concurrent_set x []", "by (auto simp: concurrent_set_def)"], ["", "lemma concurrent_set_ConsE [elim!]:\n  assumes \"concurrent_set a (x#xs)\"\n      and \"concurrent_set a xs \\<Longrightarrow> concurrent x a \\<Longrightarrow> G\"\n    shows \"G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G", "using assms"], ["proof (prove)\nusing this:\n  concurrent_set a (x # xs)\n  \\<lbrakk>concurrent_set a xs; x \\<parallel> a\\<rbrakk> \\<Longrightarrow> G\n\ngoal (1 subgoal):\n 1. G", "by (auto simp: concurrent_set_def)"], ["", "lemma concurrent_set_ConsI [intro!]:\n  \"concurrent_set a xs \\<Longrightarrow> concurrent a x \\<Longrightarrow> concurrent_set a (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>concurrent_set a xs; a \\<parallel> x\\<rbrakk>\n    \\<Longrightarrow> concurrent_set a (x # xs)", "by (auto simp: concurrent_set_def)"], ["", "lemma concurrent_set_appendI [intro!]:\n  \"concurrent_set a xs \\<Longrightarrow> concurrent_set a ys \\<Longrightarrow> concurrent_set a (xs@ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>concurrent_set a xs; concurrent_set a ys\\<rbrakk>\n    \\<Longrightarrow> concurrent_set a (xs @ ys)", "by (auto simp: concurrent_set_def)"], ["", "lemma concurrent_set_Cons_Snoc [simp]:\n  \"concurrent_set a (xs@[x]) = concurrent_set a (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concurrent_set a (xs @ [x]) = concurrent_set a (x # xs)", "by (auto simp: concurrent_set_def)"], ["", "(*************************************************************************)"], ["", "subsection\\<open>Happens-before consistency\\<close>"], ["", "(*************************************************************************)"], ["", "text\\<open>The purpose of the happens-before relation is to require that some operations must be applied\n     in a particular order, while allowing concurrent operations to be reordered with respect to each other.\n     We assume that each node applies operations in some sequential order (a standard assumption\n     for distributed algorithms), and so we can model the execution history of a node as a list of operations.\\<close>"], ["", "inductive hb_consistent :: \"'a list \\<Rightarrow> bool\" where\n  [intro!]: \"hb_consistent []\" |\n  [intro!]: \"\\<lbrakk> hb_consistent xs; \\<forall>x \\<in> set xs. \\<not> y \\<prec> x \\<rbrakk> \\<Longrightarrow> hb_consistent (xs @ [y])\""], ["", "text\\<open>As a result, whenever two operations $\\isa{x}$ and $\\isa{y}$ appear in a hb-consistent list,\n     and $\\isa{x}\\prec\\isa{y}$, then $\\isa{x}$ must appear before $\\isa{y}$ in the list.\n     However, if $\\isa{x}\\mathbin{\\isasymparallel}\\isa{y}$, the operations can appear in the list\n     in either order.\\<close>"], ["", "lemma \"(x \\<prec> y \\<or> concurrent x y) = (\\<not> y \\<prec> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<prec> y \\<or> x \\<parallel> y) = (\\<not> y \\<prec> x)", "using less_asym"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<prec> ?y; \\<not> ?P \\<Longrightarrow> ?y \\<prec> ?x\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (x \\<prec> y \\<or> x \\<parallel> y) = (\\<not> y \\<prec> x)", "by blast"], ["", "lemma consistentI [intro!]:\n  assumes \"hb_consistent (xs @ ys)\"\n  and     \"\\<forall>x \\<in> set (xs @ ys). \\<not> z \\<prec> x\"\n  shows   \"hb_consistent (xs @ ys @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hb_consistent (xs @ ys @ [z])", "using assms hb_consistent.intros append_assoc"], ["proof (prove)\nusing this:\n  hb_consistent (xs @ ys)\n  \\<forall>x\\<in>set (xs @ ys). \\<not> z \\<prec> x\n  hb_consistent []\n  \\<lbrakk>hb_consistent ?xs;\n   \\<forall>x\\<in>set ?xs. \\<not> ?y \\<prec> x\\<rbrakk>\n  \\<Longrightarrow> hb_consistent (?xs @ [?y])\n  (?xs @ ?ys) @ ?zs = ?xs @ ?ys @ ?zs\n\ngoal (1 subgoal):\n 1. hb_consistent (xs @ ys @ [z])", "by metis"], ["", "inductive_cases  hb_consistent_elim [elim]:\n  \"hb_consistent []\"\n  \"hb_consistent (xs@[y])\"\n  \"hb_consistent (xs@ys)\"\n  \"hb_consistent (xs@ys@[z])\""], ["", "inductive_cases  hb_consistent_elim_gen:\n  \"hb_consistent zs\""], ["", "lemma hb_consistent_append_D1 [dest]:\n  assumes \"hb_consistent (xs @ ys)\"\n  shows   \"hb_consistent xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hb_consistent xs", "using assms"], ["proof (prove)\nusing this:\n  hb_consistent (xs @ ys)\n\ngoal (1 subgoal):\n 1. hb_consistent xs", "by(induction ys arbitrary: xs rule: List.rev_induct) auto"], ["", "lemma hb_consistent_append_D2 [dest]:\n  assumes \"hb_consistent (xs @ ys)\"\n  shows   \"hb_consistent ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hb_consistent ys", "using assms"], ["proof (prove)\nusing this:\n  hb_consistent (xs @ ys)\n\ngoal (1 subgoal):\n 1. hb_consistent ys", "by(induction ys arbitrary: xs rule: List.rev_induct) fastforce+"], ["", "lemma hb_consistent_append_elim_ConsD [elim]:\n  assumes \"hb_consistent (y#ys)\"\n  shows   \"hb_consistent ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hb_consistent ys", "using assms hb_consistent_append_D2"], ["proof (prove)\nusing this:\n  hb_consistent (y # ys)\n  hb_consistent (?xs @ ?ys) \\<Longrightarrow> hb_consistent ?ys\n\ngoal (1 subgoal):\n 1. hb_consistent ys", "by(metis append_Cons append_Nil)"], ["", "lemma hb_consistent_remove1 [intro]:\n  assumes \"hb_consistent xs\"\n  shows   \"hb_consistent (remove1 x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hb_consistent (remove1 x xs)", "using assms"], ["proof (prove)\nusing this:\n  hb_consistent xs\n\ngoal (1 subgoal):\n 1. hb_consistent (remove1 x xs)", "by (induction rule: hb_consistent.induct) (auto simp: remove1_append)"], ["", "lemma hb_consistent_singleton [intro!]:\n  shows \"hb_consistent [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hb_consistent [x]", "using hb_consistent.intros"], ["proof (prove)\nusing this:\n  hb_consistent []\n  \\<lbrakk>hb_consistent ?xs;\n   \\<forall>x\\<in>set ?xs. \\<not> ?y \\<prec> x\\<rbrakk>\n  \\<Longrightarrow> hb_consistent (?xs @ [?y])\n\ngoal (1 subgoal):\n 1. hb_consistent [x]", "by fastforce"], ["", "lemma hb_consistent_prefix_suffix_exists:\n  assumes \"hb_consistent ys\"\n          \"hb_consistent (xs @ [x])\"\n          \"{x} \\<union> set xs = set ys\"\n          \"distinct (x#xs)\"\n          \"distinct ys\"\n  shows \"\\<exists>prefix suffix. ys = prefix @ x # suffix \\<and> concurrent_set x suffix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>prefix suffix.\n       ys = prefix @ x # suffix \\<and> concurrent_set x suffix", "using assms"], ["proof (prove)\nusing this:\n  hb_consistent ys\n  hb_consistent (xs @ [x])\n  {x} \\<union> set xs = set ys\n  distinct (x # xs)\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<exists>prefix suffix.\n       ys = prefix @ x # suffix \\<and> concurrent_set x suffix", "proof (induction arbitrary: xs rule: hb_consistent.induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "fix xs y ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "assume IH: \"(\\<And>xs. hb_consistent (xs @ [x]) \\<Longrightarrow>\n               {x} \\<union> set xs = set ys \\<Longrightarrow>\n               distinct (x # xs) \\<Longrightarrow> distinct ys \\<Longrightarrow>\n             \\<exists>prefix suffix. ys = prefix @ x # suffix \\<and> concurrent_set x suffix) \""], ["proof (state)\nthis:\n  \\<lbrakk>hb_consistent (?xs1 @ [x]); {x} \\<union> set ?xs1 = set ys;\n   distinct (x # ?xs1); distinct ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>prefix suffix.\n                       ys = prefix @ x # suffix \\<and>\n                       concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "assume assms: \"hb_consistent ys\" \"\\<forall>x\\<in>set ys. \\<not> hb y x\"\n                \"hb_consistent (xs @ [x])\"\n                \"{x} \\<union> set xs = set (ys @ [y])\"\n                \"distinct (x # xs)\" \"distinct (ys @ [y])\""], ["proof (state)\nthis:\n  hb_consistent ys\n  \\<forall>x\\<in>set ys. \\<not> y \\<prec> x\n  hb_consistent (xs @ [x])\n  {x} \\<union> set xs = set (ys @ [y])\n  distinct (x # xs)\n  distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "hence \"x = y \\<or> y \\<in> set xs\""], ["proof (prove)\nusing this:\n  hb_consistent ys\n  \\<forall>x\\<in>set ys. \\<not> y \\<prec> x\n  hb_consistent (xs @ [x])\n  {x} \\<union> set xs = set (ys @ [y])\n  distinct (x # xs)\n  distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. x = y \\<or> y \\<in> set xs", "using assms"], ["proof (prove)\nusing this:\n  hb_consistent ys\n  \\<forall>x\\<in>set ys. \\<not> y \\<prec> x\n  hb_consistent (xs @ [x])\n  {x} \\<union> set xs = set (ys @ [y])\n  distinct (x # xs)\n  distinct (ys @ [y])\n  hb_consistent ys\n  \\<forall>x\\<in>set ys. \\<not> y \\<prec> x\n  hb_consistent (xs @ [x])\n  {x} \\<union> set xs = set (ys @ [y])\n  distinct (x # xs)\n  distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. x = y \\<or> y \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  x = y \\<or> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "moreover"], ["proof (state)\nthis:\n  x = y \\<or> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "{"], ["proof (state)\nthis:\n  x = y \\<or> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "hence \"\\<exists>prefix suffix. ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<exists>prefix suffix.\n       ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix", "by force"], ["proof (state)\nthis:\n  \\<exists>prefix suffix.\n     ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "}"], ["proof (state)\nthis:\n  x = y \\<Longrightarrow>\n  \\<exists>prefix suffix.\n     ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "moreover"], ["proof (state)\nthis:\n  x = y \\<Longrightarrow>\n  \\<exists>prefix suffix.\n     ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "{"], ["proof (state)\nthis:\n  x = y \\<Longrightarrow>\n  \\<exists>prefix suffix.\n     ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "assume y_in_xs: \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "hence \"{x} \\<union> (set xs - {y}) = set ys\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. {x} \\<union> (set xs - {y}) = set ys", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  hb_consistent ys\n  \\<forall>x\\<in>set ys. \\<not> y \\<prec> x\n  hb_consistent (xs @ [x])\n  {x} \\<union> set xs = set (ys @ [y])\n  distinct (x # xs)\n  distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. {x} \\<union> (set xs - {y}) = set ys", "by (auto intro: set_equality_technical)"], ["proof (state)\nthis:\n  {x} \\<union> (set xs - {y}) = set ys\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "hence remove_y_in_xs: \"{x} \\<union> set (remove1 y xs) = set ys\""], ["proof (prove)\nusing this:\n  {x} \\<union> (set xs - {y}) = set ys\n\ngoal (1 subgoal):\n 1. {x} \\<union> set (remove1 y xs) = set ys", "using assms"], ["proof (prove)\nusing this:\n  {x} \\<union> (set xs - {y}) = set ys\n  hb_consistent ys\n  \\<forall>x\\<in>set ys. \\<not> y \\<prec> x\n  hb_consistent (xs @ [x])\n  {x} \\<union> set xs = set (ys @ [y])\n  distinct (x # xs)\n  distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. {x} \\<union> set (remove1 y xs) = set ys", "by auto"], ["proof (state)\nthis:\n  {x} \\<union> set (remove1 y xs) = set ys\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "moreover"], ["proof (state)\nthis:\n  {x} \\<union> set (remove1 y xs) = set ys\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "have \"hb_consistent ((remove1 y xs) @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hb_consistent (remove1 y xs @ [x])", "using assms hb_consistent_remove1"], ["proof (prove)\nusing this:\n  hb_consistent ys\n  \\<forall>x\\<in>set ys. \\<not> y \\<prec> x\n  hb_consistent (xs @ [x])\n  {x} \\<union> set xs = set (ys @ [y])\n  distinct (x # xs)\n  distinct (ys @ [y])\n  hb_consistent ?xs \\<Longrightarrow> hb_consistent (remove1 ?x ?xs)\n\ngoal (1 subgoal):\n 1. hb_consistent (remove1 y xs @ [x])", "by force"], ["proof (state)\nthis:\n  hb_consistent (remove1 y xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "moreover"], ["proof (state)\nthis:\n  hb_consistent (remove1 y xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "have \"distinct (x # (remove1 y xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (x # remove1 y xs)", "using assms"], ["proof (prove)\nusing this:\n  hb_consistent ys\n  \\<forall>x\\<in>set ys. \\<not> y \\<prec> x\n  hb_consistent (xs @ [x])\n  {x} \\<union> set xs = set (ys @ [y])\n  distinct (x # xs)\n  distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. distinct (x # remove1 y xs)", "by simp"], ["proof (state)\nthis:\n  distinct (x # remove1 y xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "moreover"], ["proof (state)\nthis:\n  distinct (x # remove1 y xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "have \"distinct ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ys", "using assms"], ["proof (prove)\nusing this:\n  hb_consistent ys\n  \\<forall>x\\<in>set ys. \\<not> y \\<prec> x\n  hb_consistent (xs @ [x])\n  {x} \\<union> set xs = set (ys @ [y])\n  distinct (x # xs)\n  distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. distinct ys", "by simp"], ["proof (state)\nthis:\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "ultimately"], ["proof (chain)\npicking this:\n  {x} \\<union> set (remove1 y xs) = set ys\n  hb_consistent (remove1 y xs @ [x])\n  distinct (x # remove1 y xs)\n  distinct ys", "obtain prefix suffix where ys_split: \"ys = prefix @ x # suffix \\<and> concurrent_set x suffix\""], ["proof (prove)\nusing this:\n  {x} \\<union> set (remove1 y xs) = set ys\n  hb_consistent (remove1 y xs @ [x])\n  distinct (x # remove1 y xs)\n  distinct ys\n\ngoal (1 subgoal):\n 1. (\\<And>prefix suffix.\n        ys = prefix @ x # suffix \\<and>\n        concurrent_set x suffix \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using IH"], ["proof (prove)\nusing this:\n  {x} \\<union> set (remove1 y xs) = set ys\n  hb_consistent (remove1 y xs @ [x])\n  distinct (x # remove1 y xs)\n  distinct ys\n  \\<lbrakk>hb_consistent (?xs1 @ [x]); {x} \\<union> set ?xs1 = set ys;\n   distinct (x # ?xs1); distinct ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>prefix suffix.\n                       ys = prefix @ x # suffix \\<and>\n                       concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. (\\<And>prefix suffix.\n        ys = prefix @ x # suffix \\<and>\n        concurrent_set x suffix \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "moreover"], ["proof (state)\nthis:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "{"], ["proof (state)\nthis:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "have \"concurrent x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<parallel> y", "using assms y_in_xs remove_y_in_xs concurrent_def"], ["proof (prove)\nusing this:\n  hb_consistent ys\n  \\<forall>x\\<in>set ys. \\<not> y \\<prec> x\n  hb_consistent (xs @ [x])\n  {x} \\<union> set xs = set (ys @ [y])\n  distinct (x # xs)\n  distinct (ys @ [y])\n  y \\<in> set xs\n  {x} \\<union> set (remove1 y xs) = set ys\n  ?s1.0 \\<parallel> ?s2.0 \\<equiv>\n  \\<not> ?s1.0 \\<prec> ?s2.0 \\<and> \\<not> ?s2.0 \\<prec> ?s1.0\n\ngoal (1 subgoal):\n 1. x \\<parallel> y", "by blast"], ["proof (state)\nthis:\n  x \\<parallel> y\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "hence \"concurrent_set x (suffix@[y])\""], ["proof (prove)\nusing this:\n  x \\<parallel> y\n\ngoal (1 subgoal):\n 1. concurrent_set x (suffix @ [y])", "using ys_split"], ["proof (prove)\nusing this:\n  x \\<parallel> y\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. concurrent_set x (suffix @ [y])", "by clarsimp"], ["proof (state)\nthis:\n  concurrent_set x (suffix @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "}"], ["proof (state)\nthis:\n  concurrent_set x (suffix @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "ultimately"], ["proof (chain)\npicking this:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n  concurrent_set x (suffix @ [y])", "have \"\\<exists>prefix suffix. ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\""], ["proof (prove)\nusing this:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n  concurrent_set x (suffix @ [y])\n\ngoal (1 subgoal):\n 1. \\<exists>prefix suffix.\n       ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix", "by force"], ["proof (state)\nthis:\n  \\<exists>prefix suffix.\n     ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "}"], ["proof (state)\nthis:\n  y \\<in> set xs \\<Longrightarrow>\n  \\<exists>prefix suffix.\n     ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>xs y xsa.\n       \\<lbrakk>hb_consistent xs;\n        \\<And>xsa.\n           \\<lbrakk>hb_consistent (xsa @ [x]);\n            {x} \\<union> set xsa = set xs; distinct (x # xsa);\n            distinct xs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>prefix suffix.\n                                xs = prefix @ x # suffix \\<and>\n                                concurrent_set x suffix;\n        \\<forall>x\\<in>set xs. \\<not> y \\<prec> x;\n        hb_consistent (xsa @ [x]); {x} \\<union> set xsa = set (xs @ [y]);\n        distinct (x # xsa); distinct (xs @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prefix suffix.\n                            xs @ [y] = prefix @ x # suffix \\<and>\n                            concurrent_set x suffix", "ultimately"], ["proof (chain)\npicking this:\n  x = y \\<or> y \\<in> set xs\n  x = y \\<Longrightarrow>\n  \\<exists>prefix suffix.\n     ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\n  y \\<in> set xs \\<Longrightarrow>\n  \\<exists>prefix suffix.\n     ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix", "show \"\\<exists>prefix suffix. ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\""], ["proof (prove)\nusing this:\n  x = y \\<or> y \\<in> set xs\n  x = y \\<Longrightarrow>\n  \\<exists>prefix suffix.\n     ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\n  y \\<in> set xs \\<Longrightarrow>\n  \\<exists>prefix suffix.\n     ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<exists>prefix suffix.\n       ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix", "by auto"], ["proof (state)\nthis:\n  \\<exists>prefix suffix.\n     ys @ [y] = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hb_consistent_append [intro!]:\n  assumes \"hb_consistent suffix\"\n          \"hb_consistent prefix\"\n          \"\\<And>s p. s \\<in> set suffix \\<Longrightarrow> p \\<in> set prefix \\<Longrightarrow> \\<not> s \\<prec> p\"\n  shows \"hb_consistent (prefix @ suffix)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hb_consistent (prefix @ suffix)", "using assms"], ["proof (prove)\nusing this:\n  hb_consistent suffix\n  hb_consistent prefix\n  \\<lbrakk>?s1 \\<in> set suffix; ?p1 \\<in> set prefix\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?s1 \\<prec> ?p1\n\ngoal (1 subgoal):\n 1. hb_consistent (prefix @ suffix)", "by (induction rule: hb_consistent.induct) force+"], ["", "lemma hb_consistent_append_porder:\n  assumes \"hb_consistent (xs @ ys)\"\n          \"x \\<in> set xs\"\n          \"y \\<in> set ys\"\n  shows   \"\\<not> y \\<prec> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> y \\<prec> x", "using assms"], ["proof (prove)\nusing this:\n  hb_consistent (xs @ ys)\n  x \\<in> set xs\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<not> y \\<prec> x", "by (induction ys arbitrary: xs rule: rev_induct) force+"], ["", "(*************************************************************************)"], ["", "subsection\\<open>Apply operations\\<close>"], ["", "(*************************************************************************)"], ["", "text\\<open>We can now define a function \\isa{apply-operations} that composes an arbitrary list of operations\n     into a state transformer. We first map \\isa{interp} across the list to obtain a state transformer\n     for each operation, and then collectively compose them using the Kleisli arrow composition combinator.\\<close>"], ["", "definition apply_operations :: \"'a list \\<Rightarrow> 'b \\<rightharpoonup> 'b\" where\n  \"apply_operations es \\<equiv> foldl (\\<rhd>) Some (map interp es)\""], ["", "lemma apply_operations_empty [simp]: \"apply_operations [] s = Some s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations [] s = Some s", "by(auto simp: apply_operations_def)"], ["", "lemma apply_operations_Snoc [simp]:\n  \"apply_operations (xs@[x]) = (apply_operations xs) \\<rhd> \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations (xs @ [x]) =\n    apply_operations xs \\<rhd> \\<langle>x\\<rangle>", "by(auto simp add: apply_operations_def kleisli_def)"], ["", "(*************************************************************************)"], ["", "subsection\\<open>Concurrent operations commute\\<close>"], ["", "(*************************************************************************)"], ["", "text\\<open>We say that two operations $\\isa{x}$ and $\\isa{y}$ \\emph{commute} whenever\n     $\\langle\\isa{x}\\rangle \\mathbin{\\isasymrhd} \\langle\\isa{y}\\rangle = \\langle\\isa{y}\\rangle \\mathbin{\\isasymrhd} \\langle\\isa{x}\\rangle$,\n     i.e. when we can swap the order of the composition of their interpretations without changing\n     the resulting state transformer. For our purposes, requiring that this property holds for\n     \\emph{all} pairs of operations is too strong. Rather, the commutation property is only required\n     to hold for operations that are concurrent.\\<close>"], ["", "definition concurrent_ops_commute :: \"'a list \\<Rightarrow> bool\" where\n  \"concurrent_ops_commute xs \\<equiv>\n    \\<forall>x y. {x, y} \\<subseteq> set xs \\<longrightarrow> concurrent x y \\<longrightarrow> \\<langle>x\\<rangle>\\<rhd>\\<langle>y\\<rangle> = \\<langle>y\\<rangle>\\<rhd>\\<langle>x\\<rangle>\""], ["", "lemma concurrent_ops_commute_empty [intro!]: \"concurrent_ops_commute []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concurrent_ops_commute []", "by(auto simp: concurrent_ops_commute_def)"], ["", "lemma concurrent_ops_commute_singleton [intro!]: \"concurrent_ops_commute [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concurrent_ops_commute [x]", "by(auto simp: concurrent_ops_commute_def)"], ["", "lemma concurrent_ops_commute_appendD [dest]:\n  assumes \"concurrent_ops_commute (xs@ys)\"\n    shows \"concurrent_ops_commute xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concurrent_ops_commute xs", "using assms"], ["proof (prove)\nusing this:\n  concurrent_ops_commute (xs @ ys)\n\ngoal (1 subgoal):\n 1. concurrent_ops_commute xs", "by (auto simp: concurrent_ops_commute_def)"], ["", "lemma concurrent_ops_commute_rearrange:\n  \"concurrent_ops_commute (xs@x#ys) = concurrent_ops_commute (xs@ys@[x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concurrent_ops_commute (xs @ x # ys) =\n    concurrent_ops_commute (xs @ ys @ [x])", "by (clarsimp simp: concurrent_ops_commute_def)"], ["", "lemma concurrent_ops_commute_concurrent_set:\n  assumes \"concurrent_ops_commute (prefix@suffix@[x])\"\n          \"concurrent_set x suffix\"\n          \"distinct (prefix @ x # suffix)\"\n  shows   \"apply_operations (prefix @ suffix @ [x]) = apply_operations (prefix @ x # suffix)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations (prefix @ suffix @ [x]) =\n    apply_operations (prefix @ x # suffix)", "using assms"], ["proof (prove)\nusing this:\n  concurrent_ops_commute (prefix @ suffix @ [x])\n  concurrent_set x suffix\n  distinct (prefix @ x # suffix)\n\ngoal (1 subgoal):\n 1. apply_operations (prefix @ suffix @ [x]) =\n    apply_operations (prefix @ x # suffix)", "proof(induction suffix arbitrary: rule: rev_induct, force)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "fix a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "assume IH: \"concurrent_ops_commute (prefix @ xs @ [x]) \\<Longrightarrow>\n              concurrent_set x xs \\<Longrightarrow> distinct (prefix @ x # xs) \\<Longrightarrow> \n              apply_operations (prefix @ xs @ [x]) = apply_operations (prefix @ x # xs)\""], ["proof (state)\nthis:\n  \\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]); concurrent_set x xs;\n   distinct (prefix @ x # xs)\\<rbrakk>\n  \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                    apply_operations (prefix @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "assume assms: \"concurrent_ops_commute (prefix @ (xs @ [a]) @ [x])\"\n                \"concurrent_set x (xs @ [a])\" \"distinct (prefix @ x # xs @ [a])\""], ["proof (state)\nthis:\n  concurrent_ops_commute (prefix @ (xs @ [a]) @ [x])\n  concurrent_set x (xs @ [a])\n  distinct (prefix @ x # xs @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "hence ac_comm: \"\\<langle>a\\<rangle> \\<rhd> \\<langle>x\\<rangle> = \\<langle>x\\<rangle> \\<rhd> \\<langle>a\\<rangle>\""], ["proof (prove)\nusing this:\n  concurrent_ops_commute (prefix @ (xs @ [a]) @ [x])\n  concurrent_set x (xs @ [a])\n  distinct (prefix @ x # xs @ [a])\n\ngoal (1 subgoal):\n 1. \\<langle>a\\<rangle> \\<rhd> \\<langle>x\\<rangle> =\n    \\<langle>x\\<rangle> \\<rhd> \\<langle>a\\<rangle>", "by (clarsimp simp: concurrent_ops_commute_def) blast"], ["proof (state)\nthis:\n  \\<langle>a\\<rangle> \\<rhd> \\<langle>x\\<rangle> =\n  \\<langle>x\\<rangle> \\<rhd> \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "have copc: \"concurrent_ops_commute (prefix @ xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concurrent_ops_commute (prefix @ xs @ [x])", "using assms"], ["proof (prove)\nusing this:\n  concurrent_ops_commute (prefix @ (xs @ [a]) @ [x])\n  concurrent_set x (xs @ [a])\n  distinct (prefix @ x # xs @ [a])\n\ngoal (1 subgoal):\n 1. concurrent_ops_commute (prefix @ xs @ [x])", "by (clarsimp simp: concurrent_ops_commute_def) blast"], ["proof (state)\nthis:\n  concurrent_ops_commute (prefix @ xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "have \"apply_operations ((prefix @ x # xs) @ [a]) = (apply_operations (prefix @ x # xs)) \\<rhd> \\<langle>a\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations ((prefix @ x # xs) @ [a]) =\n    apply_operations (prefix @ x # xs) \\<rhd> \\<langle>a\\<rangle>", "by (simp del: append_assoc)"], ["proof (state)\nthis:\n  apply_operations ((prefix @ x # xs) @ [a]) =\n  apply_operations (prefix @ x # xs) \\<rhd> \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "also"], ["proof (state)\nthis:\n  apply_operations ((prefix @ x # xs) @ [a]) =\n  apply_operations (prefix @ x # xs) \\<rhd> \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "have \"... = (apply_operations (prefix @ xs @ [x])) \\<rhd> \\<langle>a\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations (prefix @ x # xs) \\<rhd> \\<langle>a\\<rangle> =\n    apply_operations (prefix @ xs @ [x]) \\<rhd> \\<langle>a\\<rangle>", "using IH assms copc"], ["proof (prove)\nusing this:\n  \\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]); concurrent_set x xs;\n   distinct (prefix @ x # xs)\\<rbrakk>\n  \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                    apply_operations (prefix @ x # xs)\n  concurrent_ops_commute (prefix @ (xs @ [a]) @ [x])\n  concurrent_set x (xs @ [a])\n  distinct (prefix @ x # xs @ [a])\n  concurrent_ops_commute (prefix @ xs @ [x])\n\ngoal (1 subgoal):\n 1. apply_operations (prefix @ x # xs) \\<rhd> \\<langle>a\\<rangle> =\n    apply_operations (prefix @ xs @ [x]) \\<rhd> \\<langle>a\\<rangle>", "by auto"], ["proof (state)\nthis:\n  apply_operations (prefix @ x # xs) \\<rhd> \\<langle>a\\<rangle> =\n  apply_operations (prefix @ xs @ [x]) \\<rhd> \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "also"], ["proof (state)\nthis:\n  apply_operations (prefix @ x # xs) \\<rhd> \\<langle>a\\<rangle> =\n  apply_operations (prefix @ xs @ [x]) \\<rhd> \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "have \"... = ((apply_operations (prefix @ xs)) \\<rhd> \\<langle>x\\<rangle>) \\<rhd> \\<langle>a\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations (prefix @ xs @ [x]) \\<rhd> \\<langle>a\\<rangle> =\n    (apply_operations (prefix @ xs) \\<rhd> \\<langle>x\\<rangle>) \\<rhd>\n    \\<langle>a\\<rangle>", "by (simp add: append_assoc[symmetric] del: append_assoc)"], ["proof (state)\nthis:\n  apply_operations (prefix @ xs @ [x]) \\<rhd> \\<langle>a\\<rangle> =\n  (apply_operations (prefix @ xs) \\<rhd> \\<langle>x\\<rangle>) \\<rhd>\n  \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "also"], ["proof (state)\nthis:\n  apply_operations (prefix @ xs @ [x]) \\<rhd> \\<langle>a\\<rangle> =\n  (apply_operations (prefix @ xs) \\<rhd> \\<langle>x\\<rangle>) \\<rhd>\n  \\<langle>a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "have \"... = (apply_operations (prefix @ xs)) \\<rhd> (\\<langle>a\\<rangle> \\<rhd> \\<langle>x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (apply_operations (prefix @ xs) \\<rhd> \\<langle>x\\<rangle>) \\<rhd>\n    \\<langle>a\\<rangle> =\n    apply_operations (prefix @ xs) \\<rhd>\n    \\<langle>a\\<rangle> \\<rhd> \\<langle>x\\<rangle>", "using ac_comm kleisli_comm_cong kleisli_assoc"], ["proof (prove)\nusing this:\n  \\<langle>a\\<rangle> \\<rhd> \\<langle>x\\<rangle> =\n  \\<langle>x\\<rangle> \\<rhd> \\<langle>a\\<rangle>\n  ?x \\<rhd> ?y = ?y \\<rhd> ?x \\<Longrightarrow>\n  ?z \\<rhd> ?x \\<rhd> ?y = ?z \\<rhd> ?y \\<rhd> ?x\n  (?z \\<rhd> ?x) \\<rhd> ?y = ?z \\<rhd> ?x \\<rhd> ?y\n\ngoal (1 subgoal):\n 1. (apply_operations (prefix @ xs) \\<rhd> \\<langle>x\\<rangle>) \\<rhd>\n    \\<langle>a\\<rangle> =\n    apply_operations (prefix @ xs) \\<rhd>\n    \\<langle>a\\<rangle> \\<rhd> \\<langle>x\\<rangle>", "by simp"], ["proof (state)\nthis:\n  (apply_operations (prefix @ xs) \\<rhd> \\<langle>x\\<rangle>) \\<rhd>\n  \\<langle>a\\<rangle> =\n  apply_operations (prefix @ xs) \\<rhd>\n  \\<langle>a\\<rangle> \\<rhd> \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>concurrent_ops_commute (prefix @ xs @ [x]);\n                 concurrent_set x xs; distinct (prefix @ x # xs)\\<rbrakk>\n                \\<Longrightarrow> apply_operations (prefix @ xs @ [x]) =\n                                  apply_operations (prefix @ x # xs);\n        concurrent_ops_commute (prefix @ (xs @ [xa]) @ [x]);\n        concurrent_set x (xs @ [xa]);\n        distinct (prefix @ x # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (prefix @ (xs @ [xa]) @ [x]) =\n                         apply_operations (prefix @ x # xs @ [xa])", "finally"], ["proof (chain)\npicking this:\n  apply_operations ((prefix @ x # xs) @ [a]) =\n  apply_operations (prefix @ xs) \\<rhd>\n  \\<langle>a\\<rangle> \\<rhd> \\<langle>x\\<rangle>", "show \"apply_operations (prefix @ (xs @ [a]) @ [x]) = apply_operations (prefix @ x # xs @ [a])\""], ["proof (prove)\nusing this:\n  apply_operations ((prefix @ x # xs) @ [a]) =\n  apply_operations (prefix @ xs) \\<rhd>\n  \\<langle>a\\<rangle> \\<rhd> \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. apply_operations (prefix @ (xs @ [a]) @ [x]) =\n    apply_operations (prefix @ x # xs @ [a])", "by (metis Cons_eq_appendI append_assoc apply_operations_Snoc kleisli_assoc)"], ["proof (state)\nthis:\n  apply_operations (prefix @ (xs @ [a]) @ [x]) =\n  apply_operations (prefix @ x # xs @ [a])\n\ngoal:\nNo subgoals!", "qed"], ["", "(*************************************************************************)"], ["", "subsection\\<open>Abstract convergence theorem\\<close>"], ["", "(*************************************************************************)"], ["", "text\\<open>We can now state and prove our main theorem, $\\isa{convergence}$.\n     This theorem states that two hb-consistent lists of distinct operations, which are permutations\n     of each other and in which concurrent operations commute, have the same interpretation.\\<close>"], ["", "theorem  convergence:\n  assumes \"set xs = set ys\"\n          \"concurrent_ops_commute xs\"\n          \"concurrent_ops_commute ys\"\n          \"distinct xs\"\n          \"distinct ys\"\n          \"hb_consistent xs\"\n          \"hb_consistent ys\"\n  shows   \"apply_operations xs = apply_operations ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations xs = apply_operations ys", "using assms"], ["proof (prove)\nusing this:\n  set xs = set ys\n  concurrent_ops_commute xs\n  concurrent_ops_commute ys\n  distinct xs\n  distinct ys\n  hb_consistent xs\n  hb_consistent ys\n\ngoal (1 subgoal):\n 1. apply_operations xs = apply_operations ys", "proof(induction xs arbitrary: ys rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "case assms: (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>set xs = set ?ys1; concurrent_ops_commute xs;\n   concurrent_ops_commute ?ys1; distinct xs; distinct ?ys1;\n   hb_consistent xs; hb_consistent ?ys1\\<rbrakk>\n  \\<Longrightarrow> apply_operations xs = apply_operations ?ys1\n  set (xs @ [x]) = set ys\n  concurrent_ops_commute (xs @ [x])\n  concurrent_ops_commute ys\n  distinct (xs @ [x])\n  distinct ys\n  hb_consistent (xs @ [x])\n  hb_consistent ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>set xs = set ?ys1; concurrent_ops_commute xs;\n   concurrent_ops_commute ?ys1; distinct xs; distinct ?ys1;\n   hb_consistent xs; hb_consistent ?ys1\\<rbrakk>\n  \\<Longrightarrow> apply_operations xs = apply_operations ?ys1\n  set (xs @ [x]) = set ys\n  concurrent_ops_commute (xs @ [x])\n  concurrent_ops_commute ys\n  distinct (xs @ [x])\n  distinct ys\n  hb_consistent (xs @ [x])\n  hb_consistent ys", "obtain prefix suffix where ys_split: \"ys = prefix @ x # suffix \\<and> concurrent_set x suffix\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs = set ?ys1; concurrent_ops_commute xs;\n   concurrent_ops_commute ?ys1; distinct xs; distinct ?ys1;\n   hb_consistent xs; hb_consistent ?ys1\\<rbrakk>\n  \\<Longrightarrow> apply_operations xs = apply_operations ?ys1\n  set (xs @ [x]) = set ys\n  concurrent_ops_commute (xs @ [x])\n  concurrent_ops_commute ys\n  distinct (xs @ [x])\n  distinct ys\n  hb_consistent (xs @ [x])\n  hb_consistent ys\n\ngoal (1 subgoal):\n 1. (\\<And>prefix suffix.\n        ys = prefix @ x # suffix \\<and>\n        concurrent_set x suffix \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using hb_consistent_prefix_suffix_exists"], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs = set ?ys1; concurrent_ops_commute xs;\n   concurrent_ops_commute ?ys1; distinct xs; distinct ?ys1;\n   hb_consistent xs; hb_consistent ?ys1\\<rbrakk>\n  \\<Longrightarrow> apply_operations xs = apply_operations ?ys1\n  set (xs @ [x]) = set ys\n  concurrent_ops_commute (xs @ [x])\n  concurrent_ops_commute ys\n  distinct (xs @ [x])\n  distinct ys\n  hb_consistent (xs @ [x])\n  hb_consistent ys\n  \\<lbrakk>hb_consistent ?ys; hb_consistent (?xs @ [?x]);\n   {?x} \\<union> set ?xs = set ?ys; distinct (?x # ?xs);\n   distinct ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>prefix suffix.\n                       ?ys = prefix @ ?x # suffix \\<and>\n                       concurrent_set ?x suffix\n\ngoal (1 subgoal):\n 1. (\\<And>prefix suffix.\n        ys = prefix @ x # suffix \\<and>\n        concurrent_set x suffix \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "moreover"], ["proof (state)\nthis:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "hence *: \"distinct (prefix @ suffix)\" \"hb_consistent xs\""], ["proof (prove)\nusing this:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. distinct (prefix @ suffix) &&& hb_consistent xs", "using assms"], ["proof (prove)\nusing this:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n  \\<lbrakk>set xs = set ?ys1; concurrent_ops_commute xs;\n   concurrent_ops_commute ?ys1; distinct xs; distinct ?ys1;\n   hb_consistent xs; hb_consistent ?ys1\\<rbrakk>\n  \\<Longrightarrow> apply_operations xs = apply_operations ?ys1\n  set (xs @ [x]) = set ys\n  concurrent_ops_commute (xs @ [x])\n  concurrent_ops_commute ys\n  distinct (xs @ [x])\n  distinct ys\n  hb_consistent (xs @ [x])\n  hb_consistent ys\n\ngoal (1 subgoal):\n 1. distinct (prefix @ suffix) &&& hb_consistent xs", "by auto"], ["proof (state)\nthis:\n  distinct (prefix @ suffix)\n  hb_consistent xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "moreover"], ["proof (state)\nthis:\n  distinct (prefix @ suffix)\n  hb_consistent xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "{"], ["proof (state)\nthis:\n  distinct (prefix @ suffix)\n  hb_consistent xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "have \"hb_consistent prefix\" \"hb_consistent suffix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hb_consistent prefix &&& hb_consistent suffix", "using ys_split assms hb_consistent_append_D2 hb_consistent_append_elim_ConsD"], ["proof (prove)\nusing this:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n  \\<lbrakk>set xs = set ?ys1; concurrent_ops_commute xs;\n   concurrent_ops_commute ?ys1; distinct xs; distinct ?ys1;\n   hb_consistent xs; hb_consistent ?ys1\\<rbrakk>\n  \\<Longrightarrow> apply_operations xs = apply_operations ?ys1\n  set (xs @ [x]) = set ys\n  concurrent_ops_commute (xs @ [x])\n  concurrent_ops_commute ys\n  distinct (xs @ [x])\n  distinct ys\n  hb_consistent (xs @ [x])\n  hb_consistent ys\n  hb_consistent (?xs @ ?ys) \\<Longrightarrow> hb_consistent ?ys\n  hb_consistent (?y # ?ys) \\<Longrightarrow> hb_consistent ?ys\n\ngoal (1 subgoal):\n 1. hb_consistent prefix &&& hb_consistent suffix", "by blast+"], ["proof (state)\nthis:\n  hb_consistent prefix\n  hb_consistent suffix\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "hence \"hb_consistent (prefix @ suffix)\""], ["proof (prove)\nusing this:\n  hb_consistent prefix\n  hb_consistent suffix\n\ngoal (1 subgoal):\n 1. hb_consistent (prefix @ suffix)", "by (metis assms(8) hb_consistent_append hb_consistent_append_porder list.set_intros(2) ys_split)"], ["proof (state)\nthis:\n  hb_consistent (prefix @ suffix)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "}"], ["proof (state)\nthis:\n  hb_consistent (prefix @ suffix)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "moreover"], ["proof (state)\nthis:\n  hb_consistent (prefix @ suffix)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "have **: \"concurrent_ops_commute (prefix @ suffix @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concurrent_ops_commute (prefix @ suffix @ [x])", "using assms ys_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs = set ?ys1; concurrent_ops_commute xs;\n   concurrent_ops_commute ?ys1; distinct xs; distinct ?ys1;\n   hb_consistent xs; hb_consistent ?ys1\\<rbrakk>\n  \\<Longrightarrow> apply_operations xs = apply_operations ?ys1\n  set (xs @ [x]) = set ys\n  concurrent_ops_commute (xs @ [x])\n  concurrent_ops_commute ys\n  distinct (xs @ [x])\n  distinct ys\n  hb_consistent (xs @ [x])\n  hb_consistent ys\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. concurrent_ops_commute (prefix @ suffix @ [x])", "by (clarsimp simp: concurrent_ops_commute_def)"], ["proof (state)\nthis:\n  concurrent_ops_commute (prefix @ suffix @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "moreover"], ["proof (state)\nthis:\n  concurrent_ops_commute (prefix @ suffix @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "hence \"concurrent_ops_commute (prefix @ suffix)\""], ["proof (prove)\nusing this:\n  concurrent_ops_commute (prefix @ suffix @ [x])\n\ngoal (1 subgoal):\n 1. concurrent_ops_commute (prefix @ suffix)", "by (force simp del: append_assoc simp add: append_assoc[symmetric])"], ["proof (state)\nthis:\n  concurrent_ops_commute (prefix @ suffix)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "ultimately"], ["proof (chain)\npicking this:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n  distinct (prefix @ suffix)\n  hb_consistent xs\n  hb_consistent (prefix @ suffix)\n  concurrent_ops_commute (prefix @ suffix @ [x])\n  concurrent_ops_commute (prefix @ suffix)", "have \"apply_operations xs = apply_operations (prefix@suffix)\""], ["proof (prove)\nusing this:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n  distinct (prefix @ suffix)\n  hb_consistent xs\n  hb_consistent (prefix @ suffix)\n  concurrent_ops_commute (prefix @ suffix @ [x])\n  concurrent_ops_commute (prefix @ suffix)\n\ngoal (1 subgoal):\n 1. apply_operations xs = apply_operations (prefix @ suffix)", "using assms"], ["proof (prove)\nusing this:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n  distinct (prefix @ suffix)\n  hb_consistent xs\n  hb_consistent (prefix @ suffix)\n  concurrent_ops_commute (prefix @ suffix @ [x])\n  concurrent_ops_commute (prefix @ suffix)\n  \\<lbrakk>set xs = set ?ys1; concurrent_ops_commute xs;\n   concurrent_ops_commute ?ys1; distinct xs; distinct ?ys1;\n   hb_consistent xs; hb_consistent ?ys1\\<rbrakk>\n  \\<Longrightarrow> apply_operations xs = apply_operations ?ys1\n  set (xs @ [x]) = set ys\n  concurrent_ops_commute (xs @ [x])\n  concurrent_ops_commute ys\n  distinct (xs @ [x])\n  distinct ys\n  hb_consistent (xs @ [x])\n  hb_consistent ys\n\ngoal (1 subgoal):\n 1. apply_operations xs = apply_operations (prefix @ suffix)", "by simp (metis Diff_insert_absorb Un_iff * concurrent_ops_commute_appendD set_append)"], ["proof (state)\nthis:\n  apply_operations xs = apply_operations (prefix @ suffix)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "moreover"], ["proof (state)\nthis:\n  apply_operations xs = apply_operations (prefix @ suffix)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "have \"apply_operations (prefix@suffix @ [x]) = apply_operations (prefix@x # suffix)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations (prefix @ suffix @ [x]) =\n    apply_operations (prefix @ x # suffix)", "using ys_split assms ** concurrent_ops_commute_concurrent_set"], ["proof (prove)\nusing this:\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n  \\<lbrakk>set xs = set ?ys1; concurrent_ops_commute xs;\n   concurrent_ops_commute ?ys1; distinct xs; distinct ?ys1;\n   hb_consistent xs; hb_consistent ?ys1\\<rbrakk>\n  \\<Longrightarrow> apply_operations xs = apply_operations ?ys1\n  set (xs @ [x]) = set ys\n  concurrent_ops_commute (xs @ [x])\n  concurrent_ops_commute ys\n  distinct (xs @ [x])\n  distinct ys\n  hb_consistent (xs @ [x])\n  hb_consistent ys\n  concurrent_ops_commute (prefix @ suffix @ [x])\n  \\<lbrakk>concurrent_ops_commute (?prefix @ ?suffix @ [?x]);\n   concurrent_set ?x ?suffix; distinct (?prefix @ ?x # ?suffix)\\<rbrakk>\n  \\<Longrightarrow> apply_operations (?prefix @ ?suffix @ [?x]) =\n                    apply_operations (?prefix @ ?x # ?suffix)\n\ngoal (1 subgoal):\n 1. apply_operations (prefix @ suffix @ [x]) =\n    apply_operations (prefix @ x # suffix)", "by force"], ["proof (state)\nthis:\n  apply_operations (prefix @ suffix @ [x]) =\n  apply_operations (prefix @ x # suffix)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>set xs = set ys; concurrent_ops_commute xs;\n                    concurrent_ops_commute ys; distinct xs; distinct ys;\n                    hb_consistent xs; hb_consistent ys\\<rbrakk>\n                   \\<Longrightarrow> apply_operations xs =\n                                     apply_operations ys;\n        set (xs @ [x]) = set ys; concurrent_ops_commute (xs @ [x]);\n        concurrent_ops_commute ys; distinct (xs @ [x]); distinct ys;\n        hb_consistent (xs @ [x]); hb_consistent ys\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) = apply_operations ys", "ultimately"], ["proof (chain)\npicking this:\n  apply_operations xs = apply_operations (prefix @ suffix)\n  apply_operations (prefix @ suffix @ [x]) =\n  apply_operations (prefix @ x # suffix)", "show ?case"], ["proof (prove)\nusing this:\n  apply_operations xs = apply_operations (prefix @ suffix)\n  apply_operations (prefix @ suffix @ [x]) =\n  apply_operations (prefix @ x # suffix)\n\ngoal (1 subgoal):\n 1. apply_operations (xs @ [x]) = apply_operations ys", "using ys_split"], ["proof (prove)\nusing this:\n  apply_operations xs = apply_operations (prefix @ suffix)\n  apply_operations (prefix @ suffix @ [x]) =\n  apply_operations (prefix @ x # suffix)\n  ys = prefix @ x # suffix \\<and> concurrent_set x suffix\n\ngoal (1 subgoal):\n 1. apply_operations (xs @ [x]) = apply_operations ys", "by (force simp: append_assoc[symmetric] simp del: append_assoc)"], ["proof (state)\nthis:\n  apply_operations (xs @ [x]) = apply_operations ys\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary convergence_ext:\n  assumes \"set xs = set ys\"\n          \"concurrent_ops_commute xs\"\n          \"concurrent_ops_commute ys\"\n          \"distinct xs\"\n          \"distinct ys\"\n          \"hb_consistent xs\"\n          \"hb_consistent ys\"\n  shows   \"apply_operations xs s = apply_operations ys s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations xs s = apply_operations ys s", "using convergence assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?xs = set ?ys; concurrent_ops_commute ?xs;\n   concurrent_ops_commute ?ys; distinct ?xs; distinct ?ys;\n   hb_consistent ?xs; hb_consistent ?ys\\<rbrakk>\n  \\<Longrightarrow> apply_operations ?xs = apply_operations ?ys\n  set xs = set ys\n  concurrent_ops_commute xs\n  concurrent_ops_commute ys\n  distinct xs\n  distinct ys\n  hb_consistent xs\n  hb_consistent ys\n\ngoal (1 subgoal):\n 1. apply_operations xs s = apply_operations ys s", "by metis"], ["", "end"], ["", "subsection\\<open>Convergence and progress\\<close>"], ["", "text\\<open>Besides convergence, another required property of SEC is \\emph{progress}: if a valid operation\n     was issued on one node, then applying that operation on other nodes must also succeed---that is,\n     the execution must not become stuck in an error state.\n     Although the type signature of the interpretation function allows operations to fail, we need to\n     prove that in all $\\isa{hb-consistent}$ network behaviours such failure never actually occurs.\n     We capture the combined requirements in the $\\isa{strong-eventual-consistency}$ locale,\n     which extends $\\isa{happens-before}$.\\<close>"], ["", "locale strong_eventual_consistency = happens_before +\n  fixes op_history :: \"'a list \\<Rightarrow> bool\"\n    and initial_state :: \"'b\"\n  assumes causality:     \"op_history xs \\<Longrightarrow> hb_consistent xs\"\n  assumes distinctness:  \"op_history xs \\<Longrightarrow> distinct xs\"\n  assumes commutativity: \"op_history xs \\<Longrightarrow> concurrent_ops_commute xs\"\n  assumes no_failure:    \"op_history(xs@[x]) \\<Longrightarrow> apply_operations xs initial_state = Some state \\<Longrightarrow> \\<langle>x\\<rangle> state \\<noteq> None\"\n  assumes trunc_history: \"op_history(xs@[x]) \\<Longrightarrow> op_history xs\"\nbegin"], ["", "theorem sec_convergence:\n  assumes \"set xs = set ys\"\n          \"op_history xs\"\n          \"op_history ys\"\n  shows   \"apply_operations xs = apply_operations ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations xs = apply_operations ys", "by (meson assms convergence causality commutativity distinctness)"], ["", "theorem sec_progress:\n  assumes \"op_history xs\"\n  shows   \"apply_operations xs initial_state \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations xs initial_state \\<noteq> None", "using assms"], ["proof (prove)\nusing this:\n  op_history xs\n\ngoal (1 subgoal):\n 1. apply_operations xs initial_state \\<noteq> None", "proof(induction xs rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>op_history xs \\<Longrightarrow>\n                apply_operations xs initial_state \\<noteq> None;\n        op_history (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) initial_state \\<noteq>\n                         None", "case (snoc x xs)"], ["proof (state)\nthis:\n  op_history xs \\<Longrightarrow>\n  apply_operations xs initial_state \\<noteq> None\n  op_history (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>op_history xs \\<Longrightarrow>\n                apply_operations xs initial_state \\<noteq> None;\n        op_history (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) initial_state \\<noteq>\n                         None", "have \"apply_operations xs initial_state \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations xs initial_state \\<noteq> None", "using snoc.IH snoc.prems trunc_history kleisli_def bind_def"], ["proof (prove)\nusing this:\n  op_history xs \\<Longrightarrow>\n  apply_operations xs initial_state \\<noteq> None\n  op_history (xs @ [x])\n  op_history (?xs @ [?x]) \\<Longrightarrow> op_history ?xs\n  ?f \\<rhd> ?g \\<equiv> \\<lambda>x. ?f x \\<bind> ?g\n  ?P \\<bind> ?f = Sup (?f ` {x. pred.eval ?P x})\n\ngoal (1 subgoal):\n 1. apply_operations xs initial_state \\<noteq> None", "by blast"], ["proof (state)\nthis:\n  apply_operations xs initial_state \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>op_history xs \\<Longrightarrow>\n                apply_operations xs initial_state \\<noteq> None;\n        op_history (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) initial_state \\<noteq>\n                         None", "moreover"], ["proof (state)\nthis:\n  apply_operations xs initial_state \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>op_history xs \\<Longrightarrow>\n                apply_operations xs initial_state \\<noteq> None;\n        op_history (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) initial_state \\<noteq>\n                         None", "have \"apply_operations (xs @ [x]) = apply_operations xs \\<rhd> \\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_operations (xs @ [x]) =\n    apply_operations xs \\<rhd> \\<langle>x\\<rangle>", "by simp"], ["proof (state)\nthis:\n  apply_operations (xs @ [x]) =\n  apply_operations xs \\<rhd> \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>op_history xs \\<Longrightarrow>\n                apply_operations xs initial_state \\<noteq> None;\n        op_history (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> apply_operations (xs @ [x]) initial_state \\<noteq>\n                         None", "ultimately"], ["proof (chain)\npicking this:\n  apply_operations xs initial_state \\<noteq> None\n  apply_operations (xs @ [x]) =\n  apply_operations xs \\<rhd> \\<langle>x\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  apply_operations xs initial_state \\<noteq> None\n  apply_operations (xs @ [x]) =\n  apply_operations xs \\<rhd> \\<langle>x\\<rangle>\n\ngoal (1 subgoal):\n 1. apply_operations (xs @ [x]) initial_state \\<noteq> None", "using no_failure snoc.prems"], ["proof (prove)\nusing this:\n  apply_operations xs initial_state \\<noteq> None\n  apply_operations (xs @ [x]) =\n  apply_operations xs \\<rhd> \\<langle>x\\<rangle>\n  \\<lbrakk>op_history (?xs @ [?x]);\n   apply_operations ?xs initial_state = Some ?state\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?x\\<rangle> ?state \\<noteq> None\n  op_history (xs @ [x])\n\ngoal (1 subgoal):\n 1. apply_operations (xs @ [x]) initial_state \\<noteq> None", "by (clarsimp simp add: kleisli_def split: bind_splits)"], ["proof (state)\nthis:\n  apply_operations (xs @ [x]) initial_state \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}