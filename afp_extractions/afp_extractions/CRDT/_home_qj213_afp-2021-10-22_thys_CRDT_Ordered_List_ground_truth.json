{"file_name": "/home/qj213/afp-2021-10-22/thys/CRDT/Ordered_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CRDT", "problem_names": ["lemma insert_no_failure:\n  assumes \"i = None \\<or> (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs)\"\n  shows   \"\\<exists>xs'. insert xs e i = Some xs'\"", "lemma insert_None_index_neq_None [dest]:\n  assumes \"insert xs e i = None\"\n  shows   \"i \\<noteq> None\"", "lemma insert_Some_None_index_not_in [dest]:\n  assumes \"insert xs e (Some i) = None\"\n  shows   \"i \\<notin> fst ` set xs\"", "lemma index_not_in_insert_Some_None [simp]:\n  assumes \"i \\<notin> fst ` set xs\"\n  shows   \"insert xs e (Some i) = None\"", "lemma delete_no_failure:\n  assumes \"i \\<in> fst ` set xs\"\n  shows   \"\\<exists>xs'. delete xs i = Some xs'\"", "lemma delete_None_index_not_in [dest]:\n  assumes \"delete xs i = None\"\n  shows  \"i \\<notin> fst ` set xs\"", "lemma index_not_in_delete_None [simp]:\n  assumes \"i \\<notin> fst ` set xs\"\n  shows   \"delete xs i = None\"", "lemma insert_body_preserve_indices [simp]:\n  shows  \"fst ` set (insert_body xs e) = fst ` set xs \\<union> {fst e}\"", "lemma insert_preserve_indices:\n  assumes \"\\<exists>ys. insert xs e i = Some ys\"\n  shows   \"fst ` set (the (insert xs e i)) = fst ` set xs \\<union> {fst e}\"", "lemma delete_preserve_indices:\n  assumes \"delete xs i = Some ys\"\n  shows   \"fst ` set xs = fst ` set ys\"", "lemma insert_body_commutes:\n  assumes \"fst e1 \\<noteq> fst e2\"\n  shows   \"insert_body (insert_body xs e1) e2 = insert_body (insert_body xs e2) e1\"", "lemma insert_insert_body:\n  assumes \"fst e1 \\<noteq> fst e2\"\n      and \"i2 \\<noteq> Some (fst e1)\"\n  shows   \"insert (insert_body xs e1) e2 i2 = insert xs e2 i2 \\<bind> (\\<lambda>ys. Some (insert_body ys e1))\"", "lemma insert_Nil_None:\n  assumes \"fst e1 \\<noteq> fst e2\"\n      and \"i \\<noteq> fst e2\"\n      and \"i2 \\<noteq> Some (fst e1)\"\n  shows   \"insert [] e2 i2 \\<bind> (\\<lambda>ys. insert ys e1 (Some i)) = None\"", "lemma insert_insert_body_commute:\n  assumes \"i \\<noteq> fst e1\"\n      and \"fst e1 \\<noteq> fst e2\"\n  shows   \"insert (insert_body xs e1) e2 (Some i) =\n             insert xs e2 (Some i) \\<bind> (\\<lambda>y. Some (insert_body y e1))\"", "lemma insert_commutes:\n  assumes \"fst e1 \\<noteq> fst e2\"\n          \"i1 = None \\<or> i1 \\<noteq> Some (fst e2)\"\n          \"i2 = None \\<or> i2 \\<noteq> Some (fst e1)\"\n  shows   \"insert xs e1 i1 \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n           insert xs e2 i2 \\<bind> (\\<lambda>ys. insert ys e1 i1)\"", "lemma delete_commutes:\n  shows \"delete xs i1 \\<bind> (\\<lambda>ys. delete ys i2) = delete xs i2 \\<bind> (\\<lambda>ys. delete ys i1)\"", "lemma insert_body_delete_commute:\n  assumes \"i2 \\<noteq> fst e\"\n  shows   \"delete (insert_body xs e) i2 \\<bind> (\\<lambda>t. Some (x#t)) =\n            delete xs i2 \\<bind> (\\<lambda>y. Some (x#insert_body y e))\"", "lemma insert_delete_commute:\n  assumes \"i2 \\<noteq> fst e\"\n  shows   \"insert xs e i1 \\<bind> (\\<lambda>ys. delete ys i2) = delete xs i2 \\<bind> (\\<lambda>ys. insert ys e i1)\"", "lemma [elim!, dest]:\n  assumes \"insert' xs e None = None\"\n  shows   \"False\"", "lemma insert_body_insert':\n  shows \"insert' xs e None = Some (insert_body xs e)\"", "lemma insert_insert':\n  shows \"insert xs e i = insert' xs e i\"", "lemma insert_body_stop_iteration:\n  assumes \"fst e > fst x\"\n  shows \"insert_body (x#xs) e = e#x#xs\"", "lemma insert_body_contains_new_elem:\n  shows \"\\<exists>p s. xs = p @ s \\<and> insert_body xs e = p @ e # s\"", "lemma insert_between_elements:\n  assumes \"xs = pre@ref#suf\"\n      and \"distinct (map fst xs)\"\n      and \"\\<And>i'. i' \\<in> fst ` set xs \\<Longrightarrow> i' < fst e\"\n    shows \"insert xs e (Some (fst ref)) = Some (pre @ ref # e # suf)\"", "lemma insert_position_element_technical:\n  assumes \"\\<forall>x\\<in>set as. a \\<noteq> fst x\"\n    and \"insert_body (cs @ ds) e = cs @ e # ds\"\n  shows \"insert (as @ (a, aa, b) # cs @ ds) e (Some a) = Some (as @ (a, aa, b) # cs @ e # ds)\"", "lemma split_tuple_list_by_id:\n  assumes \"(a,b,c) \\<in> set xs\"\n    and \"distinct (map fst xs)\"\n  shows \"\\<exists>pre suf. xs = pre @ (a,b,c) # suf \\<and> (\\<forall>y \\<in> set pre. fst y \\<noteq> a)\"", "lemma insert_preserves_order:\n  assumes \"i = None \\<or> (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs)\"\n      and \"distinct (map fst xs)\"\n    shows \"\\<exists>pre suf. xs = pre@suf \\<and> insert xs e i = Some (pre @ e # suf)\""], "translations": [["", "lemma insert_no_failure:\n  assumes \"i = None \\<or> (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs)\"\n  shows   \"\\<exists>xs'. insert xs e i = Some xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'. insert xs e i = Some xs'", "using assms"], ["proof (prove)\nusing this:\n  i = None \\<or> (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs'. insert xs e i = Some xs'", "by(induction rule: insert.induct; force)"], ["", "lemma insert_None_index_neq_None [dest]:\n  assumes \"insert xs e i = None\"\n  shows   \"i \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> None", "using assms"], ["proof (prove)\nusing this:\n  insert xs e i = None\n\ngoal (1 subgoal):\n 1. i \\<noteq> None", "by(cases i, auto)"], ["", "lemma insert_Some_None_index_not_in [dest]:\n  assumes \"insert xs e (Some i) = None\"\n  shows   \"i \\<notin> fst ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> fst ` set xs", "using assms"], ["proof (prove)\nusing this:\n  insert xs e (Some i) = None\n\ngoal (1 subgoal):\n 1. i \\<notin> fst ` set xs", "by(induction xs, auto split: if_split_asm bind_splits)"], ["", "lemma index_not_in_insert_Some_None [simp]:\n  assumes \"i \\<notin> fst ` set xs\"\n  shows   \"insert xs e (Some i) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert xs e (Some i) = None", "using assms"], ["proof (prove)\nusing this:\n  i \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. insert xs e (Some i) = None", "by(induction xs, auto)"], ["", "lemma delete_no_failure:\n  assumes \"i \\<in> fst ` set xs\"\n  shows   \"\\<exists>xs'. delete xs i = Some xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'. delete xs i = Some xs'", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs'. delete xs i = Some xs'", "by(induction xs; force)"], ["", "lemma delete_None_index_not_in [dest]:\n  assumes \"delete xs i = None\"\n  shows  \"i \\<notin> fst ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> fst ` set xs", "using assms"], ["proof (prove)\nusing this:\n  delete xs i = None\n\ngoal (1 subgoal):\n 1. i \\<notin> fst ` set xs", "by(induction xs, auto split: if_split_asm bind_splits simp add: fst_eq_Domain)"], ["", "lemma index_not_in_delete_None [simp]:\n  assumes \"i \\<notin> fst ` set xs\"\n  shows   \"delete xs i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete xs i = None", "using assms"], ["proof (prove)\nusing this:\n  i \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. delete xs i = None", "by(induction xs, auto)"], ["", "subsection\\<open>Preservation of element indices\\<close>"], ["", "lemma insert_body_preserve_indices [simp]:\n  shows  \"fst ` set (insert_body xs e) = fst ` set xs \\<union> {fst e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (insert_body xs e) = fst ` set xs \\<union> {fst e}", "by(induction xs, auto simp add: insert_commute)"], ["", "lemma insert_preserve_indices:\n  assumes \"\\<exists>ys. insert xs e i = Some ys\"\n  shows   \"fst ` set (the (insert xs e i)) = fst ` set xs \\<union> {fst e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (the (insert xs e i)) = fst ` set xs \\<union> {fst e}", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>ys. insert xs e i = Some ys\n\ngoal (1 subgoal):\n 1. fst ` set (the (insert xs e i)) = fst ` set xs \\<union> {fst e}", "by(induction xs; cases i; auto simp add: insert_commute split: bind_splits)"], ["", "corollary insert_preserve_indices':\n  assumes \"insert xs e i = Some ys\"\n  shows   \"fst ` set (the (insert xs e i)) = fst ` set xs \\<union> {fst e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (the (insert xs e i)) = fst ` set xs \\<union> {fst e}", "using assms insert_preserve_indices"], ["proof (prove)\nusing this:\n  insert xs e i = Some ys\n  \\<exists>ys. insert ?xs ?e ?i = Some ys \\<Longrightarrow>\n  fst ` set (the (insert ?xs ?e ?i)) = fst ` set ?xs \\<union> {fst ?e}\n\ngoal (1 subgoal):\n 1. fst ` set (the (insert xs e i)) = fst ` set xs \\<union> {fst e}", "by blast"], ["", "lemma delete_preserve_indices:\n  assumes \"delete xs i = Some ys\"\n  shows   \"fst ` set xs = fst ` set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set xs = fst ` set ys", "using assms"], ["proof (prove)\nusing this:\n  delete xs i = Some ys\n\ngoal (1 subgoal):\n 1. fst ` set xs = fst ` set ys", "by(induction xs arbitrary: ys, simp) (case_tac a; auto split: if_split_asm bind_splits)"], ["", "subsection\\<open>Commutativity of concurrent operations\\<close>"], ["", "lemma insert_body_commutes:\n  assumes \"fst e1 \\<noteq> fst e2\"\n  shows   \"insert_body (insert_body xs e1) e2 = insert_body (insert_body xs e2) e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_body (insert_body xs e1) e2 = insert_body (insert_body xs e2) e1", "using assms"], ["proof (prove)\nusing this:\n  fst e1 \\<noteq> fst e2\n\ngoal (1 subgoal):\n 1. insert_body (insert_body xs e1) e2 = insert_body (insert_body xs e2) e1", "by(induction xs, auto)"], ["", "lemma insert_insert_body:\n  assumes \"fst e1 \\<noteq> fst e2\"\n      and \"i2 \\<noteq> Some (fst e1)\"\n  shows   \"insert (insert_body xs e1) e2 i2 = insert xs e2 i2 \\<bind> (\\<lambda>ys. Some (insert_body ys e1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (insert_body xs e1) e2 i2 =\n    insert xs e2 i2 \\<bind> (\\<lambda>ys. Some (insert_body ys e1))", "using assms"], ["proof (prove)\nusing this:\n  fst e1 \\<noteq> fst e2\n  i2 \\<noteq> Some (fst e1)\n\ngoal (1 subgoal):\n 1. insert (insert_body xs e1) e2 i2 =\n    insert xs e2 i2 \\<bind> (\\<lambda>ys. Some (insert_body ys e1))", "by (induction xs; cases i2) (auto split: if_split_asm simp add: insert_body_commutes)"], ["", "lemma insert_Nil_None:\n  assumes \"fst e1 \\<noteq> fst e2\"\n      and \"i \\<noteq> fst e2\"\n      and \"i2 \\<noteq> Some (fst e1)\"\n  shows   \"insert [] e2 i2 \\<bind> (\\<lambda>ys. insert ys e1 (Some i)) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert [] e2 i2 \\<bind> (\\<lambda>ys. insert ys e1 (Some i)) = None", "using assms"], ["proof (prove)\nusing this:\n  fst e1 \\<noteq> fst e2\n  i \\<noteq> fst e2\n  i2 \\<noteq> Some (fst e1)\n\ngoal (1 subgoal):\n 1. insert [] e2 i2 \\<bind> (\\<lambda>ys. insert ys e1 (Some i)) = None", "by (cases \"i2\") clarsimp+"], ["", "lemma insert_insert_body_commute:\n  assumes \"i \\<noteq> fst e1\"\n      and \"fst e1 \\<noteq> fst e2\"\n  shows   \"insert (insert_body xs e1) e2 (Some i) =\n             insert xs e2 (Some i) \\<bind> (\\<lambda>y. Some (insert_body y e1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (insert_body xs e1) e2 (Some i) =\n    insert xs e2 (Some i) \\<bind> (\\<lambda>y. Some (insert_body y e1))", "using assms"], ["proof (prove)\nusing this:\n  i \\<noteq> fst e1\n  fst e1 \\<noteq> fst e2\n\ngoal (1 subgoal):\n 1. insert (insert_body xs e1) e2 (Some i) =\n    insert xs e2 (Some i) \\<bind> (\\<lambda>y. Some (insert_body y e1))", "by(induction xs, auto simp add: insert_body_commutes)"], ["", "lemma insert_commutes:\n  assumes \"fst e1 \\<noteq> fst e2\"\n          \"i1 = None \\<or> i1 \\<noteq> Some (fst e2)\"\n          \"i2 = None \\<or> i2 \\<noteq> Some (fst e1)\"\n  shows   \"insert xs e1 i1 \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n           insert xs e2 i2 \\<bind> (\\<lambda>ys. insert ys e1 i1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert xs e1 i1 \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n    insert xs e2 i2 \\<bind> (\\<lambda>ys. insert ys e1 i1)", "using assms"], ["proof (prove)\nusing this:\n  fst e1 \\<noteq> fst e2\n  i1 = None \\<or> i1 \\<noteq> Some (fst e2)\n  i2 = None \\<or> i2 \\<noteq> Some (fst e1)\n\ngoal (1 subgoal):\n 1. insert xs e1 i1 \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n    insert xs e2 i2 \\<bind> (\\<lambda>ys. insert ys e1 i1)", "proof(induction rule: insert.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs e.\n       \\<lbrakk>fst e \\<noteq> fst e2;\n        None = None \\<or> None \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert xs e None \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert xs e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e None)\n 2. \\<And>e i.\n       \\<lbrakk>fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert [] e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert [] e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))\n 3. \\<And>x xs e i.\n       \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n                 Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n                 i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n                \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                                  (\\<lambda>ys. insert ys e2 i2) =\n                                  insert xs e2 i2 \\<bind>\n                                  (\\<lambda>ys. insert ys e (Some i));\n        fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert (x # xs) e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))", "fix xs and e :: \"('a, 'b) elt\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs e.\n       \\<lbrakk>fst e \\<noteq> fst e2;\n        None = None \\<or> None \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert xs e None \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert xs e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e None)\n 2. \\<And>e i.\n       \\<lbrakk>fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert [] e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert [] e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))\n 3. \\<And>x xs e i.\n       \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n                 Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n                 i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n                \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                                  (\\<lambda>ys. insert ys e2 i2) =\n                                  insert xs e2 i2 \\<bind>\n                                  (\\<lambda>ys. insert ys e (Some i));\n        fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert (x # xs) e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))", "assume \"i2 = None \\<or> i2 \\<noteq> Some (fst e)\" and \"fst e \\<noteq> fst e2\""], ["proof (state)\nthis:\n  i2 = None \\<or> i2 \\<noteq> Some (fst e)\n  fst e \\<noteq> fst e2\n\ngoal (3 subgoals):\n 1. \\<And>xs e.\n       \\<lbrakk>fst e \\<noteq> fst e2;\n        None = None \\<or> None \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert xs e None \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert xs e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e None)\n 2. \\<And>e i.\n       \\<lbrakk>fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert [] e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert [] e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))\n 3. \\<And>x xs e i.\n       \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n                 Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n                 i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n                \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                                  (\\<lambda>ys. insert ys e2 i2) =\n                                  insert xs e2 i2 \\<bind>\n                                  (\\<lambda>ys. insert ys e (Some i));\n        fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert (x # xs) e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))", "thus \"insert xs e None \\<bind> (\\<lambda>ys. insert ys e2 i2) = insert xs e2 i2 \\<bind> (\\<lambda>ys. insert ys e None)\""], ["proof (prove)\nusing this:\n  i2 = None \\<or> i2 \\<noteq> Some (fst e)\n  fst e \\<noteq> fst e2\n\ngoal (1 subgoal):\n 1. insert xs e None \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n    insert xs e2 i2 \\<bind> (\\<lambda>ys. insert ys e None)", "by(auto simp add: insert_body_commutes intro: insert_insert_body)"], ["proof (state)\nthis:\n  insert xs e None \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n  insert xs e2 i2 \\<bind> (\\<lambda>ys. insert ys e None)\n\ngoal (2 subgoals):\n 1. \\<And>e i.\n       \\<lbrakk>fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert [] e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert [] e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))\n 2. \\<And>x xs e i.\n       \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n                 Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n                 i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n                \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                                  (\\<lambda>ys. insert ys e2 i2) =\n                                  insert xs e2 i2 \\<bind>\n                                  (\\<lambda>ys. insert ys e (Some i));\n        fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert (x # xs) e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e i.\n       \\<lbrakk>fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert [] e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert [] e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))\n 2. \\<And>x xs e i.\n       \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n                 Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n                 i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n                \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                                  (\\<lambda>ys. insert ys e2 i2) =\n                                  insert xs e2 i2 \\<bind>\n                                  (\\<lambda>ys. insert ys e (Some i));\n        fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert (x # xs) e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))", "fix i and e :: \"('a, 'b) elt\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e i.\n       \\<lbrakk>fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert [] e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert [] e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))\n 2. \\<And>x xs e i.\n       \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n                 Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n                 i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n                \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                                  (\\<lambda>ys. insert ys e2 i2) =\n                                  insert xs e2 i2 \\<bind>\n                                  (\\<lambda>ys. insert ys e (Some i));\n        fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert (x # xs) e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))", "assume \"fst e \\<noteq> fst e2\" and \"i2 = None \\<or> i2 \\<noteq> Some (fst e)\" and \"Some i = None \\<or> Some i \\<noteq> Some (fst e2)\""], ["proof (state)\nthis:\n  fst e \\<noteq> fst e2\n  i2 = None \\<or> i2 \\<noteq> Some (fst e)\n  Some i = None \\<or> Some i \\<noteq> Some (fst e2)\n\ngoal (2 subgoals):\n 1. \\<And>e i.\n       \\<lbrakk>fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert [] e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert [] e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))\n 2. \\<And>x xs e i.\n       \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n                 Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n                 i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n                \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                                  (\\<lambda>ys. insert ys e2 i2) =\n                                  insert xs e2 i2 \\<bind>\n                                  (\\<lambda>ys. insert ys e (Some i));\n        fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert (x # xs) e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))", "thus \"insert [] e (Some i) \\<bind> (\\<lambda>ys. insert ys e2 i2) = insert [] e2 i2 \\<bind> (\\<lambda>ys. insert ys e (Some i))\""], ["proof (prove)\nusing this:\n  fst e \\<noteq> fst e2\n  i2 = None \\<or> i2 \\<noteq> Some (fst e)\n  Some i = None \\<or> Some i \\<noteq> Some (fst e2)\n\ngoal (1 subgoal):\n 1. insert [] e (Some i) \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n    insert [] e2 i2 \\<bind> (\\<lambda>ys. insert ys e (Some i))", "by (auto intro: insert_Nil_None[symmetric])"], ["proof (state)\nthis:\n  insert [] e (Some i) \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n  insert [] e2 i2 \\<bind> (\\<lambda>ys. insert ys e (Some i))\n\ngoal (1 subgoal):\n 1. \\<And>x xs e i.\n       \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n                 Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n                 i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n                \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                                  (\\<lambda>ys. insert ys e2 i2) =\n                                  insert xs e2 i2 \\<bind>\n                                  (\\<lambda>ys. insert ys e (Some i));\n        fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert (x # xs) e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e i.\n       \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n                 Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n                 i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n                \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                                  (\\<lambda>ys. insert ys e2 i2) =\n                                  insert xs e2 i2 \\<bind>\n                                  (\\<lambda>ys. insert ys e (Some i));\n        fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert (x # xs) e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))", "fix xs i and x e :: \"('a, 'b) elt\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs e i.\n       \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n                 Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n                 i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n                \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                                  (\\<lambda>ys. insert ys e2 i2) =\n                                  insert xs e2 i2 \\<bind>\n                                  (\\<lambda>ys. insert ys e (Some i));\n        fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert (x # xs) e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))", "assume IH: \"(fst x \\<noteq> i \\<Longrightarrow>\n               fst e \\<noteq> fst e2 \\<Longrightarrow>\n               Some i = None \\<or> Some i \\<noteq> Some (fst e2) \\<Longrightarrow>\n               i2 = None \\<or> i2 \\<noteq> Some (fst e) \\<Longrightarrow>\n               insert xs e (Some i) \\<bind> (\\<lambda>ys. insert ys e2 i2) = insert xs e2 i2 \\<bind> (\\<lambda>ys. insert ys e (Some i)))\"\n     and \"fst e \\<noteq> fst e2\"\n     and \"Some i = None \\<or> Some i \\<noteq> Some (fst e2)\"\n     and \"i2 = None \\<or> i2 \\<noteq> Some (fst e)\""], ["proof (state)\nthis:\n  \\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n   Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n   i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n  \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                    (\\<lambda>ys. insert ys e2 i2) =\n                    insert xs e2 i2 \\<bind>\n                    (\\<lambda>ys. insert ys e (Some i))\n  fst e \\<noteq> fst e2\n  Some i = None \\<or> Some i \\<noteq> Some (fst e2)\n  i2 = None \\<or> i2 \\<noteq> Some (fst e)\n\ngoal (1 subgoal):\n 1. \\<And>x xs e i.\n       \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n                 Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n                 i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n                \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                                  (\\<lambda>ys. insert ys e2 i2) =\n                                  insert xs e2 i2 \\<bind>\n                                  (\\<lambda>ys. insert ys e (Some i));\n        fst e \\<noteq> fst e2;\n        Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n        i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n       \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                         (\\<lambda>ys. insert ys e2 i2) =\n                         insert (x # xs) e2 i2 \\<bind>\n                         (\\<lambda>ys. insert ys e (Some i))", "thus \"insert (x # xs) e (Some i) \\<bind> (\\<lambda>ys. insert ys e2 i2) = insert (x # xs) e2 i2 \\<bind> (\\<lambda>ys. insert ys e (Some i))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n   Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n   i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n  \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                    (\\<lambda>ys. insert ys e2 i2) =\n                    insert xs e2 i2 \\<bind>\n                    (\\<lambda>ys. insert ys e (Some i))\n  fst e \\<noteq> fst e2\n  Some i = None \\<or> Some i \\<noteq> Some (fst e2)\n  i2 = None \\<or> i2 \\<noteq> Some (fst e)\n\ngoal (1 subgoal):\n 1. insert (x # xs) e (Some i) \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n    insert (x # xs) e2 i2 \\<bind> (\\<lambda>ys. insert ys e (Some i))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>fst x \\<noteq> i; fst e \\<noteq> fst e2;\n              Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n              i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n             \\<Longrightarrow> insert xs e (Some i) \\<bind>\n                               (\\<lambda>ys. insert ys e2 i2) =\n                               insert xs e2 i2 \\<bind>\n                               (\\<lambda>ys. insert ys e (Some i));\n     fst e \\<noteq> fst e2;\n     Some i = None \\<or> Some i \\<noteq> Some (fst e2);\n     i2 = None \\<or> i2 \\<noteq> Some (fst e)\\<rbrakk>\n    \\<Longrightarrow> insert (x # xs) e (Some i) \\<bind>\n                      (\\<lambda>ys. insert ys e2 i2) =\n                      insert (x # xs) e2 i2 \\<bind>\n                      (\\<lambda>ys. insert ys e (Some i))", "apply(erule disjE, clarsimp, simp, rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fst x \\<noteq> i \\<Longrightarrow>\n             insert xs e (Some i) \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n             insert xs e2 i2 \\<bind> (\\<lambda>ys. insert ys e (Some i));\n     fst e \\<noteq> fst e2; i2 = None \\<or> i2 \\<noteq> Some (fst e);\n     i \\<noteq> fst e2\\<rbrakk>\n    \\<Longrightarrow> fst x = i \\<longrightarrow>\n                      insert (x # insert_body xs e) e2 i2 =\n                      insert (x # xs) e2 i2 \\<bind>\n                      (\\<lambda>ys. insert ys e (Some i))\n 2. \\<lbrakk>fst x \\<noteq> i \\<Longrightarrow>\n             insert xs e (Some i) \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n             insert xs e2 i2 \\<bind> (\\<lambda>ys. insert ys e (Some i));\n     fst e \\<noteq> fst e2; i2 = None \\<or> i2 \\<noteq> Some (fst e);\n     i \\<noteq> fst e2\\<rbrakk>\n    \\<Longrightarrow> fst x \\<noteq> i \\<longrightarrow>\n                      insert xs e (Some i) \\<bind>\n                      (\\<lambda>y. insert (x # y) e2 i2) =\n                      insert (x # xs) e2 i2 \\<bind>\n                      (\\<lambda>ys. insert ys e (Some i))", "apply(case_tac i2; force simp add: insert_body_commutes insert_insert_body_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst x \\<noteq> i \\<Longrightarrow>\n             insert xs e (Some i) \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n             insert xs e2 i2 \\<bind> (\\<lambda>ys. insert ys e (Some i));\n     fst e \\<noteq> fst e2; i2 = None \\<or> i2 \\<noteq> Some (fst e);\n     i \\<noteq> fst e2\\<rbrakk>\n    \\<Longrightarrow> fst x \\<noteq> i \\<longrightarrow>\n                      insert xs e (Some i) \\<bind>\n                      (\\<lambda>y. insert (x # y) e2 i2) =\n                      insert (x # xs) e2 i2 \\<bind>\n                      (\\<lambda>ys. insert ys e (Some i))", "apply(case_tac i2; clarsimp cong: Option.bind_cong simp add: insert_insert_body split: bind_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>fst x \\<noteq> i \\<Longrightarrow>\n                insert xs e (Some i) \\<bind>\n                (\\<lambda>aa. insert aa e2 (Some a)) =\n                insert xs e2 (Some a) \\<bind>\n                (\\<lambda>a. insert a e (Some i));\n        fst e \\<noteq> fst e2; a \\<noteq> fst e; i \\<noteq> fst e2;\n        i2 = Some a\\<rbrakk>\n       \\<Longrightarrow> (insert xs e (Some i) = None \\<longrightarrow>\n                          (\\<forall>v.\n                              (\\<exists>va.\n                                  insert v e (Some i) =\n                                  Some va) \\<longrightarrow>\n                              insert xs e2 (Some a) =\n                              Some v \\<longrightarrow>\n                              fst x \\<noteq> a \\<longrightarrow>\n                              fst x = i)) \\<and>\n                         (\\<forall>v.\n                             (insert v e2 (Some a) = None \\<longrightarrow>\n                              insert xs e (Some i) =\n                              Some v \\<longrightarrow>\n                              (\\<forall>v.\n                                  (\\<exists>va.\ninsert v e (Some i) = Some va) \\<longrightarrow>\n                                  insert xs e2 (Some a) =\n                                  Some v \\<longrightarrow>\n                                  fst x \\<noteq> a \\<longrightarrow>\n                                  fst x = i)) \\<and>\n                             (\\<forall>va.\n                                 insert v e2 (Some a) =\n                                 Some va \\<longrightarrow>\n                                 insert xs e (Some i) =\n                                 Some v \\<longrightarrow>\n                                 (insert xs e2 (Some a) =\n                                  None \\<longrightarrow>\n                                  fst x \\<noteq> a \\<longrightarrow>\n                                  fst x = i) \\<and>\n                                 (\\<forall>v.\n                                     (insert v e (Some i) =\nNone \\<longrightarrow>\ninsert xs e2 (Some a) = Some v \\<longrightarrow>\nfst x \\<noteq> a \\<longrightarrow> fst x = i) \\<and>\n                                     (\\<forall>vb.\n   insert v e (Some i) = Some vb \\<longrightarrow>\n   insert xs e2 (Some a) = Some v \\<longrightarrow>\n   fst x \\<noteq> a \\<longrightarrow>\n   fst x \\<noteq> i \\<longrightarrow> va = vb))))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  insert (x # xs) e (Some i) \\<bind> (\\<lambda>ys. insert ys e2 i2) =\n  insert (x # xs) e2 i2 \\<bind> (\\<lambda>ys. insert ys e (Some i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_commutes:\n  shows \"delete xs i1 \\<bind> (\\<lambda>ys. delete ys i2) = delete xs i2 \\<bind> (\\<lambda>ys. delete ys i1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete xs i1 \\<bind> (\\<lambda>ys. delete ys i2) =\n    delete xs i2 \\<bind> (\\<lambda>ys. delete ys i1)", "by(induction xs, auto split: bind_splits if_split_asm)"], ["", "lemma insert_body_delete_commute:\n  assumes \"i2 \\<noteq> fst e\"\n  shows   \"delete (insert_body xs e) i2 \\<bind> (\\<lambda>t. Some (x#t)) =\n            delete xs i2 \\<bind> (\\<lambda>y. Some (x#insert_body y e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete (insert_body xs e) i2 \\<bind> (\\<lambda>t. Some (x # t)) =\n    delete xs i2 \\<bind> (\\<lambda>y. Some (x # insert_body y e))", "using assms"], ["proof (prove)\nusing this:\n  i2 \\<noteq> fst e\n\ngoal (1 subgoal):\n 1. delete (insert_body xs e) i2 \\<bind> (\\<lambda>t. Some (x # t)) =\n    delete xs i2 \\<bind> (\\<lambda>y. Some (x # insert_body y e))", "by (induction xs arbitrary: x; cases e, auto split: bind_splits if_split_asm)"], ["", "lemma insert_delete_commute:\n  assumes \"i2 \\<noteq> fst e\"\n  shows   \"insert xs e i1 \\<bind> (\\<lambda>ys. delete ys i2) = delete xs i2 \\<bind> (\\<lambda>ys. insert ys e i1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert xs e i1 \\<bind> (\\<lambda>ys. delete ys i2) =\n    delete xs i2 \\<bind> (\\<lambda>ys. insert ys e i1)", "using assms"], ["proof (prove)\nusing this:\n  i2 \\<noteq> fst e\n\ngoal (1 subgoal):\n 1. insert xs e i1 \\<bind> (\\<lambda>ys. delete ys i2) =\n    delete xs i2 \\<bind> (\\<lambda>ys. insert ys e i1)", "by(induction xs; cases e; cases i1, auto split: bind_splits if_split_asm simp add: insert_body_delete_commute)"], ["", "subsection\\<open>Alternative definition of insert\\<close>"], ["", "fun insert' :: \"('id::{linorder}, 'v) elt list \\<Rightarrow> ('id, 'v) elt \\<Rightarrow> 'id option \\<rightharpoonup> ('id::{linorder}, 'v) elt list\" where\n  \"insert' [] e     None     = Some [e]\" |\n  \"insert' [] e     (Some i) = None\" |\n  \"insert' (x#xs) e None     =\n     (if fst x < fst e then\n        Some (e#x#xs)\n      else\n        case insert' xs e None of\n          None   \\<Rightarrow> None\n        | Some t \\<Rightarrow> Some (x#t))\" |\n  \"insert' (x#xs) e (Some i) =\n     (if fst x = i then\n        case insert' xs e None of\n          None   \\<Rightarrow> None\n        | Some t \\<Rightarrow> Some (x#t)\n      else\n        case insert' xs e (Some i) of\n          None   \\<Rightarrow> None\n        | Some t \\<Rightarrow> Some (x#t))\""], ["", "lemma [elim!, dest]:\n  assumes \"insert' xs e None = None\"\n  shows   \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  insert' xs e None = None\n\ngoal (1 subgoal):\n 1. False", "by(induction xs, auto split: if_split_asm option.split_asm)"], ["", "lemma insert_body_insert':\n  shows \"insert' xs e None = Some (insert_body xs e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert' xs e None = Some (insert_body xs e)", "by(induction xs, auto)"], ["", "lemma insert_insert':\n  shows \"insert xs e i = insert' xs e i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert xs e i = insert' xs e i", "by(induction xs; cases e; cases i, auto split: option.split simp add: insert_body_insert')"], ["", "lemma insert_body_stop_iteration:\n  assumes \"fst e > fst x\"\n  shows \"insert_body (x#xs) e = e#x#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_body (x # xs) e = e # x # xs", "using assms"], ["proof (prove)\nusing this:\n  fst x < fst e\n\ngoal (1 subgoal):\n 1. insert_body (x # xs) e = e # x # xs", "by simp"], ["", "lemma insert_body_contains_new_elem:\n  shows \"\\<exists>p s. xs = p @ s \\<and> insert_body xs e = p @ e # s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p s. xs = p @ s \\<and> insert_body xs e = p @ e # s", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>p s. [] = p @ s \\<and> insert_body [] e = p @ e # s\n 2. \\<And>a xs.\n       \\<exists>p s.\n          xs = p @ s \\<and> insert_body xs e = p @ e # s \\<Longrightarrow>\n       \\<exists>p s.\n          a # xs = p @ s \\<and> insert_body (a # xs) e = p @ e # s", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>p s. [] = p @ s \\<and> insert_body [] e = p @ e # s\n 2. \\<And>a xs.\n       \\<exists>p s.\n          xs = p @ s \\<and> insert_body xs e = p @ e # s \\<Longrightarrow>\n       \\<exists>p s.\n          a # xs = p @ s \\<and> insert_body (a # xs) e = p @ e # s", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p s. [] = p @ s \\<and> insert_body [] e = p @ e # s", "by force"], ["proof (state)\nthis:\n  \\<exists>p s. [] = p @ s \\<and> insert_body [] e = p @ e # s\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<exists>p s.\n          xs = p @ s \\<and> insert_body xs e = p @ e # s \\<Longrightarrow>\n       \\<exists>p s.\n          a # xs = p @ s \\<and> insert_body (a # xs) e = p @ e # s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<exists>p s.\n          xs = p @ s \\<and> insert_body xs e = p @ e # s \\<Longrightarrow>\n       \\<exists>p s.\n          a # xs = p @ s \\<and> insert_body (a # xs) e = p @ e # s", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<exists>p s. xs = p @ s \\<and> insert_body xs e = p @ e # s\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<exists>p s.\n          xs = p @ s \\<and> insert_body xs e = p @ e # s \\<Longrightarrow>\n       \\<exists>p s.\n          a # xs = p @ s \\<and> insert_body (a # xs) e = p @ e # s", "then"], ["proof (chain)\npicking this:\n  \\<exists>p s. xs = p @ s \\<and> insert_body xs e = p @ e # s", "obtain p s where \"xs = p @ s \\<and> insert_body xs e = p @ e # s\""], ["proof (prove)\nusing this:\n  \\<exists>p s. xs = p @ s \\<and> insert_body xs e = p @ e # s\n\ngoal (1 subgoal):\n 1. (\\<And>p s.\n        xs = p @ s \\<and> insert_body xs e = p @ e # s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  xs = p @ s \\<and> insert_body xs e = p @ e # s\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<exists>p s.\n          xs = p @ s \\<and> insert_body xs e = p @ e # s \\<Longrightarrow>\n       \\<exists>p s.\n          a # xs = p @ s \\<and> insert_body (a # xs) e = p @ e # s", "thus ?case"], ["proof (prove)\nusing this:\n  xs = p @ s \\<and> insert_body xs e = p @ e # s\n\ngoal (1 subgoal):\n 1. \\<exists>p s. a # xs = p @ s \\<and> insert_body (a # xs) e = p @ e # s", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insert_body (p @ s) e = p @ e # s; xs = p @ s\\<rbrakk>\n    \\<Longrightarrow> (fst a < fst e \\<longrightarrow>\n                       (\\<exists>pa sa.\n                           a # p @ s = pa @ sa \\<and>\n                           e # a # p @ s = pa @ e # sa)) \\<and>\n                      (\\<not> fst a < fst e \\<longrightarrow>\n                       (\\<exists>pa sa.\n                           a # p @ s = pa @ sa \\<and>\n                           a # p @ e # s = pa @ e # sa))", "apply (rule conjI; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>insert_body (p @ s) e = p @ e # s; xs = p @ s;\n     fst a < fst e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pa sa.\n                         a # p @ s = pa @ sa \\<and>\n                         e # a # p @ s = pa @ e # sa\n 2. \\<lbrakk>insert_body (p @ s) e = p @ e # s; xs = p @ s;\n     \\<not> fst a < fst e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pa sa.\n                         a # p @ s = pa @ sa \\<and>\n                         a # p @ e # s = pa @ e # sa", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insert_body (p @ s) e = p @ e # s; xs = p @ s;\n     \\<not> fst a < fst e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pa sa.\n                         a # p @ s = pa @ sa \\<and>\n                         a # p @ e # s = pa @ e # sa", "apply (rule_tac x=\"a # p\" in exI, force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>p s. a # xs = p @ s \\<and> insert_body (a # xs) e = p @ e # s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_between_elements:\n  assumes \"xs = pre@ref#suf\"\n      and \"distinct (map fst xs)\"\n      and \"\\<And>i'. i' \\<in> fst ` set xs \\<Longrightarrow> i' < fst e\"\n    shows \"insert xs e (Some (fst ref)) = Some (pre @ ref # e # suf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert xs e (Some (fst ref)) = Some (pre @ ref # e # suf)", "using assms"], ["proof (prove)\nusing this:\n  xs = pre @ ref # suf\n  distinct (map fst xs)\n  ?i' \\<in> fst ` set xs \\<Longrightarrow> ?i' < fst e\n\ngoal (1 subgoal):\n 1. insert xs e (Some (fst ref)) = Some (pre @ ref # e # suf)", "by(induction xs arbitrary: pre ref suf, force) (case_tac pre; case_tac suf; force)"], ["", "lemma insert_position_element_technical:\n  assumes \"\\<forall>x\\<in>set as. a \\<noteq> fst x\"\n    and \"insert_body (cs @ ds) e = cs @ e # ds\"\n  shows \"insert (as @ (a, aa, b) # cs @ ds) e (Some a) = Some (as @ (a, aa, b) # cs @ e # ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (as @ (a, aa, b) # cs @ ds) e (Some a) =\n    Some (as @ (a, aa, b) # cs @ e # ds)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set as. a \\<noteq> fst x\n  insert_body (cs @ ds) e = cs @ e # ds\n\ngoal (1 subgoal):\n 1. insert (as @ (a, aa, b) # cs @ ds) e (Some a) =\n    Some (as @ (a, aa, b) # cs @ e # ds)", "by (induction as arbitrary: cs ds; clarsimp)"], ["", "lemma split_tuple_list_by_id:\n  assumes \"(a,b,c) \\<in> set xs\"\n    and \"distinct (map fst xs)\"\n  shows \"\\<exists>pre suf. xs = pre @ (a,b,c) # suf \\<and> (\\<forall>y \\<in> set pre. fst y \\<noteq> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ (a, b, c) # suf \\<and>\n       (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "using assms"], ["proof (prove)\nusing this:\n  (a, b, c) \\<in> set xs\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ (a, b, c) # suf \\<and>\n       (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "proof(induction xs, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>(a, b, c) \\<in> set xs;\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ (a, b, c) # suf \\<and>\n                                     (\\<forall>y\\<in>set pre.\n   fst y \\<noteq> a);\n        (a, b, c) \\<in> set (aa # xs); distinct (map fst (aa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            aa # xs = pre @ (a, b, c) # suf \\<and>\n                            (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(a, b, c) \\<in> set xs; distinct (map fst xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       xs = pre @ (a, b, c) # suf \\<and>\n                       (\\<forall>y\\<in>set pre. fst y \\<noteq> a)\n  (a, b, c) \\<in> set (x # xs)\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>(a, b, c) \\<in> set xs;\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ (a, b, c) # suf \\<and>\n                                     (\\<forall>y\\<in>set pre.\n   fst y \\<noteq> a);\n        (a, b, c) \\<in> set (aa # xs); distinct (map fst (aa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            aa # xs = pre @ (a, b, c) # suf \\<and>\n                            (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(a, b, c) \\<in> set xs; distinct (map fst xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       xs = pre @ (a, b, c) # suf \\<and>\n                       (\\<forall>y\\<in>set pre. fst y \\<noteq> a)\n  (a, b, c) \\<in> set (x # xs)\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>(a, b, c) \\<in> set xs;\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ (a, b, c) # suf \\<and>\n                                     (\\<forall>y\\<in>set pre.\n   fst y \\<noteq> a);\n        (a, b, c) \\<in> set (aa # xs); distinct (map fst (aa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            aa # xs = pre @ (a, b, c) # suf \\<and>\n                            (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "assume \"x \\<noteq> (a, b, c)\""], ["proof (state)\nthis:\n  x \\<noteq> (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>(a, b, c) \\<in> set xs;\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ (a, b, c) # suf \\<and>\n                                     (\\<forall>y\\<in>set pre.\n   fst y \\<noteq> a);\n        (a, b, c) \\<in> set (aa # xs); distinct (map fst (aa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            aa # xs = pre @ (a, b, c) # suf \\<and>\n                            (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "hence \"(a, b, c) \\<in> set xs\" \"distinct (map fst xs)\""], ["proof (prove)\nusing this:\n  x \\<noteq> (a, b, c)\n\ngoal (1 subgoal):\n 1. (a, b, c) \\<in> set xs &&& distinct (map fst xs)", "using Cons.prems"], ["proof (prove)\nusing this:\n  x \\<noteq> (a, b, c)\n  (a, b, c) \\<in> set (x # xs)\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. (a, b, c) \\<in> set xs &&& distinct (map fst xs)", "by force+"], ["proof (state)\nthis:\n  (a, b, c) \\<in> set xs\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>(a, b, c) \\<in> set xs;\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ (a, b, c) # suf \\<and>\n                                     (\\<forall>y\\<in>set pre.\n   fst y \\<noteq> a);\n        (a, b, c) \\<in> set (aa # xs); distinct (map fst (aa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            aa # xs = pre @ (a, b, c) # suf \\<and>\n                            (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "then"], ["proof (chain)\npicking this:\n  (a, b, c) \\<in> set xs\n  distinct (map fst xs)", "obtain pre suf where \"xs = pre @ (a, b, c) # suf \\<and> (\\<forall>y\\<in>set pre. fst y \\<noteq> a)\""], ["proof (prove)\nusing this:\n  (a, b, c) \\<in> set xs\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        xs = pre @ (a, b, c) # suf \\<and>\n        (\\<forall>y\\<in>set pre. fst y \\<noteq> a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Cons.IH"], ["proof (prove)\nusing this:\n  (a, b, c) \\<in> set xs\n  distinct (map fst xs)\n  \\<lbrakk>(a, b, c) \\<in> set xs; distinct (map fst xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       xs = pre @ (a, b, c) # suf \\<and>\n                       (\\<forall>y\\<in>set pre. fst y \\<noteq> a)\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        xs = pre @ (a, b, c) # suf \\<and>\n        (\\<forall>y\\<in>set pre. fst y \\<noteq> a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  xs = pre @ (a, b, c) # suf \\<and>\n  (\\<forall>y\\<in>set pre. fst y \\<noteq> a)\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>(a, b, c) \\<in> set xs;\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ (a, b, c) # suf \\<and>\n                                     (\\<forall>y\\<in>set pre.\n   fst y \\<noteq> a);\n        (a, b, c) \\<in> set (aa # xs); distinct (map fst (aa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            aa # xs = pre @ (a, b, c) # suf \\<and>\n                            (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "hence ?case"], ["proof (prove)\nusing this:\n  xs = pre @ (a, b, c) # suf \\<and>\n  (\\<forall>y\\<in>set pre. fst y \\<noteq> a)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       x # xs = pre @ (a, b, c) # suf \\<and>\n       (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "apply(rule_tac x=\"x#pre\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = pre @ (a, b, c) # suf \\<and>\n    (\\<forall>y\\<in>set pre. fst y \\<noteq> a) \\<Longrightarrow>\n    \\<exists>suf.\n       x # xs = (x # pre) @ (a, b, c) # suf \\<and>\n       (\\<forall>y\\<in>set (x # pre). fst y \\<noteq> a)", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. xs = pre @ (a, b, c) # suf \\<and>\n    (\\<forall>y\\<in>set pre. fst y \\<noteq> a) \\<Longrightarrow>\n    \\<exists>suf.\n       x # xs = (x # pre) @ (a, b, c) # suf \\<and>\n       (\\<forall>y\\<in>set (x # pre). fst y \\<noteq> a)", "by auto"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     x # xs = pre @ (a, b, c) # suf \\<and>\n     (\\<forall>y\\<in>set pre. fst y \\<noteq> a)\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>(a, b, c) \\<in> set xs;\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ (a, b, c) # suf \\<and>\n                                     (\\<forall>y\\<in>set pre.\n   fst y \\<noteq> a);\n        (a, b, c) \\<in> set (aa # xs); distinct (map fst (aa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            aa # xs = pre @ (a, b, c) # suf \\<and>\n                            (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "}"], ["proof (state)\nthis:\n  x \\<noteq> (a, b, c) \\<Longrightarrow>\n  \\<exists>pre suf.\n     x # xs = pre @ (a, b, c) # suf \\<and>\n     (\\<forall>y\\<in>set pre. fst y \\<noteq> a)\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>(a, b, c) \\<in> set xs;\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ (a, b, c) # suf \\<and>\n                                     (\\<forall>y\\<in>set pre.\n   fst y \\<noteq> a);\n        (a, b, c) \\<in> set (aa # xs); distinct (map fst (aa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            aa # xs = pre @ (a, b, c) # suf \\<and>\n                            (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> (a, b, c) \\<Longrightarrow>\n  \\<exists>pre suf.\n     x # xs = pre @ (a, b, c) # suf \\<and>\n     (\\<forall>y\\<in>set pre. fst y \\<noteq> a)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       x # xs = pre @ (a, b, c) # suf \\<and>\n       (\\<forall>y\\<in>set pre. fst y \\<noteq> a)", "by force"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     x # xs = pre @ (a, b, c) # suf \\<and>\n     (\\<forall>y\\<in>set pre. fst y \\<noteq> a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_preserves_order:\n  assumes \"i = None \\<or> (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs)\"\n      and \"distinct (map fst xs)\"\n    shows \"\\<exists>pre suf. xs = pre@suf \\<and> insert xs e i = Some (pre @ e # suf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)", "using assms"], ["proof (prove)\nusing this:\n  i = None \\<or> (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs)\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "assume \"i = None\""], ["proof (state)\nthis:\n  i = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "hence ?thesis"], ["proof (prove)\nusing this:\n  i = None\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)", "by clarsimp (metis insert_body_contains_new_elem)"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "}"], ["proof (state)\nthis:\n  i = None \\<Longrightarrow>\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "moreover"], ["proof (state)\nthis:\n  i = None \\<Longrightarrow>\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "{"], ["proof (state)\nthis:\n  i = None \\<Longrightarrow>\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "assume \"\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  \\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs", "obtain j v b where \"i = Some j\" \"(j, v, b) \\<in> set xs\""], ["proof (prove)\nusing this:\n  \\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. (\\<And>j v b.\n        \\<lbrakk>i = Some j; (j, v, b) \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  i = Some j\n  (j, v, b) \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "moreover"], ["proof (state)\nthis:\n  i = Some j\n  (j, v, b) \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "then"], ["proof (chain)\npicking this:\n  i = Some j\n  (j, v, b) \\<in> set xs", "obtain as bs where \"xs = as@(j,v,b)#bs\" \"\\<forall>x \\<in> set as. fst x \\<noteq> j\""], ["proof (prove)\nusing this:\n  i = Some j\n  (j, v, b) \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        \\<lbrakk>xs = as @ (j, v, b) # bs;\n         \\<forall>x\\<in>set as. fst x \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  i = Some j\n  (j, v, b) \\<in> set xs\n  i = None \\<or> (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs)\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        \\<lbrakk>xs = as @ (j, v, b) # bs;\n         \\<forall>x\\<in>set as. fst x \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis split_tuple_list_by_id)"], ["proof (state)\nthis:\n  xs = as @ (j, v, b) # bs\n  \\<forall>x\\<in>set as. fst x \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "moreover"], ["proof (state)\nthis:\n  xs = as @ (j, v, b) # bs\n  \\<forall>x\\<in>set as. fst x \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "then"], ["proof (chain)\npicking this:\n  xs = as @ (j, v, b) # bs\n  \\<forall>x\\<in>set as. fst x \\<noteq> j", "obtain cs ds where \"insert_body bs e = cs@e#ds\" \"cs@ds = bs\""], ["proof (prove)\nusing this:\n  xs = as @ (j, v, b) # bs\n  \\<forall>x\\<in>set as. fst x \\<noteq> j\n\ngoal (1 subgoal):\n 1. (\\<And>cs ds.\n        \\<lbrakk>insert_body bs e = cs @ e # ds; cs @ ds = bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(metis insert_body_contains_new_elem)"], ["proof (state)\nthis:\n  insert_body bs e = cs @ e # ds\n  cs @ ds = bs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "ultimately"], ["proof (chain)\npicking this:\n  i = Some j\n  (j, v, b) \\<in> set xs\n  xs = as @ (j, v, b) # bs\n  \\<forall>x\\<in>set as. fst x \\<noteq> j\n  insert_body bs e = cs @ e # ds\n  cs @ ds = bs", "have ?thesis"], ["proof (prove)\nusing this:\n  i = Some j\n  (j, v, b) \\<in> set xs\n  xs = as @ (j, v, b) # bs\n  \\<forall>x\\<in>set as. fst x \\<noteq> j\n  insert_body bs e = cs @ e # ds\n  cs @ ds = bs\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)", "by(rule_tac x=\"as@(j,v,b)#cs\" in exI; clarsimp)(metis insert_position_element_technical)"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "}"], ["proof (state)\nthis:\n  \\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs \\<Longrightarrow>\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = None \\<or>\n             (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs);\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs = pre @ suf \\<and>\n                         insert xs e i = Some (pre @ e # suf)", "ultimately"], ["proof (chain)\npicking this:\n  i = None \\<Longrightarrow>\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n  \\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs \\<Longrightarrow>\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)", "show ?thesis"], ["proof (prove)\nusing this:\n  i = None \\<Longrightarrow>\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n  \\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs \\<Longrightarrow>\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)", "using assms"], ["proof (prove)\nusing this:\n  i = None \\<Longrightarrow>\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n  \\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs \\<Longrightarrow>\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n  i = None \\<or> (\\<exists>i'. i = Some i' \\<and> i' \\<in> fst ` set xs)\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)", "by force"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     xs = pre @ suf \\<and> insert xs e i = Some (pre @ e # suf)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}