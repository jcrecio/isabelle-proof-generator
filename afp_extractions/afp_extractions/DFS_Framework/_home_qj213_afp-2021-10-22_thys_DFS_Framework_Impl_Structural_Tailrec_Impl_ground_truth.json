{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Impl/Structural/Tailrec_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma gds_init_refine: \"gds_init gds \n      \\<le> SPEC (\\<lambda>s. gen_rwof s \\<and> gds_is_empty_stack gds s)\"", "lemma gds_new_root_refine:\n      assumes PNR: \"pre_new_root v0 s\"\n      shows \"gds_new_root gds v0 s \n        \\<le> SPEC (\\<lambda>s'. gen_rwof s' \n            \\<and> insert v0 (gen_discovered s) \\<subseteq> gen_discovered s' )\"", "lemma get_pending_nofail:\n      assumes A: \"pre_get_pending s\"  \n      shows \"nofail (gds_get_pending gds s)\"", "lemma gds_get_pending_refine: \n      assumes PRE: \"pre_get_pending s\"\n      shows \"gds_get_pending gds s \\<le> SPEC (\\<lambda>(u,Vs,s'). \n          post_get_pending u Vs s s' \n        \\<and> gen_discovered s \\<subseteq> gen_discovered s')\"", "lemma gds_finish_refine:\n      assumes PRE: \"pre_finish u s0 s\"\n      shows \"gds_finish gds u s \\<le> SPEC (\\<lambda>s'. gen_rwof s' \n            \\<and> gen_discovered s \\<subseteq> gen_discovered s')\"", "lemma gds_cross_edge_refine:\n      assumes PRE: \"pre_cross_edge u v s0 s\"\n      shows \"gds_cross_edge gds u v s \\<le> SPEC (\\<lambda>s'. gen_rwof s' \n            \\<and> gen_discovered s \\<subseteq> gen_discovered s')\"", "lemma gds_back_edge_refine:\n      assumes PRE: \"pre_back_edge u v s0 s\"\n      shows \"gds_back_edge gds u v s \\<le> SPEC (\\<lambda>s'. gen_rwof s' \n            \\<and> gen_discovered s \\<subseteq> gen_discovered s')\"", "lemma gds_discover_refine:\n      assumes PRE: \"pre_discover u v s0 s\"\n      shows \"gds_discover gds u v s \\<le> SPEC (\\<lambda>s'. gen_rwof s' \n            \\<and> gen_discovered s \\<subseteq> gen_discovered s')\"", "lemma gen_step_disc_incr:\n    assumes \"nofail gen_dfs\"\n    assumes \"gen_rwof s\" \"insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s\"\n    assumes \"\\<not>gds_is_break gds s\" \"\\<not>gds_is_empty_stack gds s\"\n    shows \"gen_step s \\<le> SPEC (\\<lambda>s. insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s)\"", "theorem tailrec_impl: \"tailrec_impl \\<le> gen_dfs\"", "lemma tr_impl_while_body_gen_step:\n    assumes [simp]: \"\\<not>gds_is_empty_stack gds s\"\n    shows \"tr_impl_while_body s \\<le> gen_step s\"", "lemma tailrecT_impl: \"tailrec_implT \\<le> gen_dfsT\""], "translations": [["", "lemma gds_init_refine: \"gds_init gds \n      \\<le> SPEC (\\<lambda>s. gen_rwof s \\<and> gds_is_empty_stack gds s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds\n    \\<le> SPEC (\\<lambda>s. gen_rwof s \\<and> gds_is_empty_stack gds s)", "apply (rule SPEC_rule_conj_leofI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gds_init gds \\<le> SPEC gen_rwof\n 2. gds_init gds \\<le>\\<^sub>n SPEC (gds_is_empty_stack gds)", "apply (rule rwof_init[OF nofail])"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<le>\\<^sub>n SPEC (gds_is_empty_stack gds)", "apply (rule init_empty_stack)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gds_new_root_refine:\n      assumes PNR: \"pre_new_root v0 s\"\n      shows \"gds_new_root gds v0 s \n        \\<le> SPEC (\\<lambda>s'. gen_rwof s' \n            \\<and> insert v0 (gen_discovered s) \\<subseteq> gen_discovered s' )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_new_root gds v0 s\n    \\<le> SPEC\n           (\\<lambda>s'.\n               gen_rwof s' \\<and>\n               insert v0 (gen_discovered s) \\<subseteq> gen_discovered s')", "apply (rule SPEC_rule_conj_leofI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gds_new_root gds v0 s \\<le> SPEC gen_rwof\n 2. gds_new_root gds v0 s \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>sa.\n         insert v0 (gen_discovered s) \\<subseteq> gen_discovered sa)", "apply (rule order_trans[OF _ rwof_step[OF nofail]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. gds_new_root gds v0 s \\<le> gen_step ?s4\n 2. gen_rwof ?s4\n 3. gen_cond ?s4\n 4. gds_new_root gds v0 s \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>sa.\n         insert v0 (gen_discovered s) \\<subseteq> gen_discovered sa)", "using PNR"], ["proof (prove)\nusing this:\n  pre_new_root v0 s\n\ngoal (4 subgoals):\n 1. gds_new_root gds v0 s \\<le> gen_step ?s4\n 2. gen_rwof ?s4\n 3. gen_cond ?s4\n 4. gds_new_root gds v0 s \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>sa.\n         insert v0 (gen_discovered s) \\<subseteq> gen_discovered sa)", "apply (unfold gen_step_def gen_cond_def pre_new_root_def) [3]"], ["proof (prove)\ngoal (4 subgoals):\n 1. rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     s \\<and>\n    gds_is_empty_stack gds s \\<and>\n    \\<not> gds_is_break gds s \\<and>\n    v0 \\<in> V0 - gen_discovered s \\<Longrightarrow>\n    gds_new_root gds v0 s\n    \\<le> (if gds_is_empty_stack gds ?s4\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 ?s4) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 ?s4)\n           else gds_get_pending gds ?s4 \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n 2. rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     s \\<and>\n    gds_is_empty_stack gds s \\<and>\n    \\<not> gds_is_break gds s \\<and>\n    v0 \\<in> V0 - gen_discovered s \\<Longrightarrow>\n    rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     ?s4\n 3. rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     s \\<and>\n    gds_is_empty_stack gds s \\<and>\n    \\<not> gds_is_break gds s \\<and>\n    v0 \\<in> V0 - gen_discovered s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered ?s4 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds ?s4) \\<and>\n    \\<not> gds_is_break gds ?s4\n 4. gds_new_root gds v0 s \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>sa.\n         insert v0 (gen_discovered s) \\<subseteq> gen_discovered sa)", "apply (simp add: pw_le_iff refine_pw_simps, blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     s \\<and>\n    gds_is_empty_stack gds s \\<and>\n    \\<not> gds_is_break gds s \\<and>\n    v0 \\<in> V0 - gen_discovered s \\<Longrightarrow>\n    rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     s\n 2. rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     s \\<and>\n    gds_is_empty_stack gds s \\<and>\n    \\<not> gds_is_break gds s \\<and>\n    v0 \\<in> V0 - gen_discovered s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds s) \\<and>\n    \\<not> gds_is_break gds s\n 3. gds_new_root gds v0 s \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>sa.\n         insert v0 (gen_discovered s) \\<subseteq> gen_discovered sa)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     s \\<and>\n    gds_is_empty_stack gds s \\<and>\n    \\<not> gds_is_break gds s \\<and>\n    v0 \\<in> V0 - gen_discovered s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds s) \\<and>\n    \\<not> gds_is_break gds s\n 2. gds_new_root gds v0 s \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>sa.\n         insert v0 (gen_discovered s) \\<subseteq> gen_discovered sa)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_new_root gds v0 s \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>sa.\n         insert v0 (gen_discovered s) \\<subseteq> gen_discovered sa)", "apply (rule new_root_discovered[OF PNR])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Establish state after get-pending *)"], ["", "lemma get_pending_nofail:\n      assumes A: \"pre_get_pending s\"  \n      shows \"nofail (gds_get_pending gds s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (gds_get_pending gds s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail (gds_get_pending gds s)", "(* Get-pending is executed as part of the next step. \n        As the next step does not fail, get_pending cannot fail, too. *)"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail (gds_get_pending gds s)", "from A[unfolded pre_get_pending_def]"], ["proof (chain)\npicking this:\n  gen_rwof s \\<and>\n  \\<not> gds_is_empty_stack gds s \\<and> \\<not> gds_is_break gds s", "have \n        RWOF: \"gen_rwof s\" and\n        C: \"\\<not> gds_is_empty_stack gds s\" \"\\<not> gds_is_break gds s\""], ["proof (prove)\nusing this:\n  gen_rwof s \\<and>\n  \\<not> gds_is_empty_stack gds s \\<and> \\<not> gds_is_break gds s\n\ngoal (1 subgoal):\n 1. gen_rwof s &&&\n    \\<not> gds_is_empty_stack gds s &&& \\<not> gds_is_break gds s", "by auto"], ["proof (state)\nthis:\n  gen_rwof s\n  \\<not> gds_is_empty_stack gds s\n  \\<not> gds_is_break gds s\n\ngoal (1 subgoal):\n 1. nofail (gds_get_pending gds s)", "from C"], ["proof (chain)\npicking this:\n  \\<not> gds_is_empty_stack gds s\n  \\<not> gds_is_break gds s", "have COND: \"gen_cond s\""], ["proof (prove)\nusing this:\n  \\<not> gds_is_empty_stack gds s\n  \\<not> gds_is_break gds s\n\ngoal (1 subgoal):\n 1. gen_cond s", "unfolding gen_cond_def"], ["proof (prove)\nusing this:\n  \\<not> gds_is_empty_stack gds s\n  \\<not> gds_is_break gds s\n\ngoal (1 subgoal):\n 1. (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds s) \\<and>\n    \\<not> gds_is_break gds s", "by auto"], ["proof (state)\nthis:\n  gen_cond s\n\ngoal (1 subgoal):\n 1. nofail (gds_get_pending gds s)", "from rwof_step[OF nofail RWOF COND]"], ["proof (chain)\npicking this:\n  gen_step s \\<le> SPEC gen_rwof", "have \"gen_step s \\<le> SPEC gen_rwof\""], ["proof (prove)\nusing this:\n  gen_step s \\<le> SPEC gen_rwof\n\ngoal (1 subgoal):\n 1. gen_step s \\<le> SPEC gen_rwof", "."], ["proof (state)\nthis:\n  gen_step s \\<le> SPEC gen_rwof\n\ngoal (1 subgoal):\n 1. nofail (gds_get_pending gds s)", "hence \"nofail (gen_step s)\""], ["proof (prove)\nusing this:\n  gen_step s \\<le> SPEC gen_rwof\n\ngoal (1 subgoal):\n 1. nofail (gen_step s)", "by (simp add: pw_le_iff)"], ["proof (state)\nthis:\n  nofail (gen_step s)\n\ngoal (1 subgoal):\n 1. nofail (gds_get_pending gds s)", "with C"], ["proof (chain)\npicking this:\n  \\<not> gds_is_empty_stack gds s\n  \\<not> gds_is_break gds s\n  nofail (gen_step s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> gds_is_empty_stack gds s\n  \\<not> gds_is_break gds s\n  nofail (gen_step s)\n\ngoal (1 subgoal):\n 1. nofail (gds_get_pending gds s)", "unfolding gen_step_def"], ["proof (prove)\nusing this:\n  \\<not> gds_is_empty_stack gds s\n  \\<not> gds_is_break gds s\n  nofail\n   (if gds_is_empty_stack gds s\n    then SPEC\n          (\\<lambda>v0.\n              v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n         (\\<lambda>v0. gds_new_root gds v0 s)\n    else gds_get_pending gds s \\<bind>\n         (\\<lambda>(u, Vs, s).\n             case Vs of None \\<Rightarrow> gds_finish gds u s\n             | Some v \\<Rightarrow>\n                 if gds_is_discovered gds v s\n                 then if gds_is_finished gds v s\n                      then gds_cross_edge gds u v s\n                      else gds_back_edge gds u v s\n                 else gds_discover gds u v s))\n\ngoal (1 subgoal):\n 1. nofail (gds_get_pending gds s)", "by (simp add: refine_pw_simps)"], ["proof (state)\nthis:\n  nofail (gds_get_pending gds s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gds_get_pending_refine: \n      assumes PRE: \"pre_get_pending s\"\n      shows \"gds_get_pending gds s \\<le> SPEC (\\<lambda>(u,Vs,s'). \n          post_get_pending u Vs s s' \n        \\<and> gen_discovered s \\<subseteq> gen_discovered s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_get_pending gds s\n    \\<le> SPEC\n           (\\<lambda>(u, Vs, s').\n               post_get_pending u Vs s s' \\<and>\n               gen_discovered s \\<subseteq> gen_discovered s')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gds_get_pending gds s\n    \\<le> SPEC\n           (\\<lambda>(u, Vs, s').\n               post_get_pending u Vs s s' \\<and>\n               gen_discovered s \\<subseteq> gen_discovered s')", "have \"gds_get_pending gds s \\<le> SPEC (\\<lambda>(u,Vs,s'). post_get_pending u Vs s s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_get_pending gds s\n    \\<le> SPEC (\\<lambda>(u, Vs, s'). post_get_pending u Vs s s')", "unfolding post_get_pending_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_get_pending gds s\n    \\<le> SPEC\n           (\\<lambda>(u, Vs, s').\n               pre_get_pending s \\<and>\n               inres (gds_get_pending gds s) (u, Vs, s'))", "apply (simp add: PRE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_get_pending gds s \\<le> SPEC (inres (gds_get_pending gds s))", "using get_pending_nofail[OF PRE]"], ["proof (prove)\nusing this:\n  nofail (gds_get_pending gds s)\n\ngoal (1 subgoal):\n 1. gds_get_pending gds s \\<le> SPEC (inres (gds_get_pending gds s))", "apply (simp add: pw_le_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gds_get_pending gds s\n  \\<le> SPEC (\\<lambda>(u, Vs, s'). post_get_pending u Vs s s')\n\ngoal (1 subgoal):\n 1. gds_get_pending gds s\n    \\<le> SPEC\n           (\\<lambda>(u, Vs, s').\n               post_get_pending u Vs s s' \\<and>\n               gen_discovered s \\<subseteq> gen_discovered s')", "moreover"], ["proof (state)\nthis:\n  gds_get_pending gds s\n  \\<le> SPEC (\\<lambda>(u, Vs, s'). post_get_pending u Vs s s')\n\ngoal (1 subgoal):\n 1. gds_get_pending gds s\n    \\<le> SPEC\n           (\\<lambda>(u, Vs, s').\n               post_get_pending u Vs s s' \\<and>\n               gen_discovered s \\<subseteq> gen_discovered s')", "note get_pending_incr[OF PRE]"], ["proof (state)\nthis:\n  gds_get_pending gds s \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>(uu_, uu_, s'). gen_discovered s \\<subseteq> gen_discovered s')\n\ngoal (1 subgoal):\n 1. gds_get_pending gds s\n    \\<le> SPEC\n           (\\<lambda>(u, Vs, s').\n               post_get_pending u Vs s s' \\<and>\n               gen_discovered s \\<subseteq> gen_discovered s')", "ultimately"], ["proof (chain)\npicking this:\n  gds_get_pending gds s\n  \\<le> SPEC (\\<lambda>(u, Vs, s'). post_get_pending u Vs s s')\n  gds_get_pending gds s \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>(uu_, uu_, s'). gen_discovered s \\<subseteq> gen_discovered s')", "show ?thesis"], ["proof (prove)\nusing this:\n  gds_get_pending gds s\n  \\<le> SPEC (\\<lambda>(u, Vs, s'). post_get_pending u Vs s s')\n  gds_get_pending gds s \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>(uu_, uu_, s'). gen_discovered s \\<subseteq> gen_discovered s')\n\ngoal (1 subgoal):\n 1. gds_get_pending gds s\n    \\<le> SPEC\n           (\\<lambda>(u, Vs, s').\n               post_get_pending u Vs s s' \\<and>\n               gen_discovered s \\<subseteq> gen_discovered s')", "by (simp add: pw_le_iff pw_leof_iff)"], ["proof (state)\nthis:\n  gds_get_pending gds s\n  \\<le> SPEC\n         (\\<lambda>(u, Vs, s').\n             post_get_pending u Vs s s' \\<and>\n             gen_discovered s \\<subseteq> gen_discovered s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gds_finish_refine:\n      assumes PRE: \"pre_finish u s0 s\"\n      shows \"gds_finish gds u s \\<le> SPEC (\\<lambda>s'. gen_rwof s' \n            \\<and> gen_discovered s \\<subseteq> gen_discovered s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_finish gds u s\n    \\<le> SPEC\n           (\\<lambda>s'.\n               gen_rwof s' \\<and>\n               gen_discovered s \\<subseteq> gen_discovered s')", "apply (rule SPEC_rule_conj_leofI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gds_finish gds u s \\<le> SPEC gen_rwof\n 2. gds_finish gds u s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (rule order_trans[OF _ rwof_step[OF nofail]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. gds_finish gds u s \\<le> gen_step ?s4\n 2. gen_rwof ?s4\n 3. gen_cond ?s4\n 4. gds_finish gds u s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "using PRE"], ["proof (prove)\nusing this:\n  pre_finish u s0 s\n\ngoal (4 subgoals):\n 1. gds_finish gds u s \\<le> gen_step ?s4\n 2. gen_rwof ?s4\n 3. gen_cond ?s4\n 4. gds_finish gds u s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (unfold gen_step_def gen_cond_def pre_finish_def \n            post_get_pending_def pre_get_pending_def) [3]"], ["proof (prove)\ngoal (4 subgoals):\n 1. (rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\n      s0 \\<and>\n     \\<not> gds_is_empty_stack gds s0 \\<and>\n     \\<not> gds_is_break gds s0) \\<and>\n    inres (gds_get_pending gds s0) (u, None, s) \\<Longrightarrow>\n    gds_finish gds u s\n    \\<le> (if gds_is_empty_stack gds ?s4\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 ?s4) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 ?s4)\n           else gds_get_pending gds ?s4 \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n 2. (rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\n      s0 \\<and>\n     \\<not> gds_is_empty_stack gds s0 \\<and>\n     \\<not> gds_is_break gds s0) \\<and>\n    inres (gds_get_pending gds s0) (u, None, s) \\<Longrightarrow>\n    rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     ?s4\n 3. (rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\n      s0 \\<and>\n     \\<not> gds_is_empty_stack gds s0 \\<and>\n     \\<not> gds_is_break gds s0) \\<and>\n    inres (gds_get_pending gds s0) (u, None, s) \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered ?s4 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds ?s4) \\<and>\n    \\<not> gds_is_break gds ?s4\n 4. gds_finish gds u s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (simp add: pw_le_iff refine_pw_simps split: option.split, blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\n      s0 \\<and>\n     \\<not> gds_is_empty_stack gds s0 \\<and>\n     \\<not> gds_is_break gds s0) \\<and>\n    inres (gds_get_pending gds s0) (u, None, s) \\<Longrightarrow>\n    rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     s0\n 2. (rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\n      s0 \\<and>\n     \\<not> gds_is_empty_stack gds s0 \\<and>\n     \\<not> gds_is_break gds s0) \\<and>\n    inres (gds_get_pending gds s0) (u, None, s) \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds s0) \\<and>\n    \\<not> gds_is_break gds s0\n 3. gds_finish gds u s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          if gds_is_empty_stack gds s\n          then SPEC\n                (\\<lambda>v0.\n                    v0 \\<in> V0 \\<and>\n                    \\<not> gds_is_discovered gds v0 s) \\<bind>\n               (\\<lambda>v0. gds_new_root gds v0 s)\n          else gds_get_pending gds s \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of None \\<Rightarrow> gds_finish gds u s\n                   | Some v \\<Rightarrow>\n                       if gds_is_discovered gds v s\n                       then if gds_is_finished gds v s\n                            then gds_cross_edge gds u v s\n                            else gds_back_edge gds u v s\n                       else gds_discover gds u v s))\n      s0 \\<and>\n     \\<not> gds_is_empty_stack gds s0 \\<and>\n     \\<not> gds_is_break gds s0) \\<and>\n    inres (gds_get_pending gds s0) (u, None, s) \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds s0) \\<and>\n    \\<not> gds_is_break gds s0\n 2. gds_finish gds u s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_finish gds u s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (rule finish_incr[OF PRE])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gds_cross_edge_refine:\n      assumes PRE: \"pre_cross_edge u v s0 s\"\n      shows \"gds_cross_edge gds u v s \\<le> SPEC (\\<lambda>s'. gen_rwof s' \n            \\<and> gen_discovered s \\<subseteq> gen_discovered s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_cross_edge gds u v s\n    \\<le> SPEC\n           (\\<lambda>s'.\n               gen_rwof s' \\<and>\n               gen_discovered s \\<subseteq> gen_discovered s')", "apply (rule SPEC_rule_conj_leofI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gds_cross_edge gds u v s \\<le> SPEC gen_rwof\n 2. gds_cross_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (rule order_trans[OF _ rwof_step[OF nofail]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. gds_cross_edge gds u v s \\<le> gen_step ?s4\n 2. gen_rwof ?s4\n 3. gen_cond ?s4\n 4. gds_cross_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "using PRE"], ["proof (prove)\nusing this:\n  pre_cross_edge u v s0 s\n\ngoal (4 subgoals):\n 1. gds_cross_edge gds u v s \\<le> gen_step ?s4\n 2. gen_rwof ?s4\n 3. gen_cond ?s4\n 4. gds_cross_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (unfold gen_step_def gen_cond_def pre_cross_edge_def \n            post_get_pending_def pre_get_pending_def) [3]"], ["proof (prove)\ngoal (4 subgoals):\n 1. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    gds_is_finished gds v s \\<Longrightarrow>\n    gds_cross_edge gds u v s\n    \\<le> (if gds_is_empty_stack gds ?s4\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 ?s4) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 ?s4)\n           else gds_get_pending gds ?s4 \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n 2. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    gds_is_finished gds v s \\<Longrightarrow>\n    rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     ?s4\n 3. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    gds_is_finished gds v s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered ?s4 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds ?s4) \\<and>\n    \\<not> gds_is_break gds ?s4\n 4. gds_cross_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (simp add: pw_le_iff refine_pw_simps split: option.split, blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    gds_is_finished gds v s \\<Longrightarrow>\n    rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     s0\n 2. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    gds_is_finished gds v s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds s0) \\<and>\n    \\<not> gds_is_break gds s0\n 3. gds_cross_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    gds_is_finished gds v s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds s0) \\<and>\n    \\<not> gds_is_break gds s0\n 2. gds_cross_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_cross_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (rule cross_edge_incr[OF PRE])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gds_back_edge_refine:\n      assumes PRE: \"pre_back_edge u v s0 s\"\n      shows \"gds_back_edge gds u v s \\<le> SPEC (\\<lambda>s'. gen_rwof s' \n            \\<and> gen_discovered s \\<subseteq> gen_discovered s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_back_edge gds u v s\n    \\<le> SPEC\n           (\\<lambda>s'.\n               gen_rwof s' \\<and>\n               gen_discovered s \\<subseteq> gen_discovered s')", "apply (rule SPEC_rule_conj_leofI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gds_back_edge gds u v s \\<le> SPEC gen_rwof\n 2. gds_back_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (rule order_trans[OF _ rwof_step[OF nofail]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. gds_back_edge gds u v s \\<le> gen_step ?s4\n 2. gen_rwof ?s4\n 3. gen_cond ?s4\n 4. gds_back_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "using PRE"], ["proof (prove)\nusing this:\n  pre_back_edge u v s0 s\n\ngoal (4 subgoals):\n 1. gds_back_edge gds u v s \\<le> gen_step ?s4\n 2. gen_rwof ?s4\n 3. gen_cond ?s4\n 4. gds_back_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (unfold gen_step_def gen_cond_def pre_back_edge_def \n            post_get_pending_def pre_get_pending_def) [3]"], ["proof (prove)\ngoal (4 subgoals):\n 1. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    \\<not> gds_is_finished gds v s \\<Longrightarrow>\n    gds_back_edge gds u v s\n    \\<le> (if gds_is_empty_stack gds ?s4\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 ?s4) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 ?s4)\n           else gds_get_pending gds ?s4 \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n 2. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    \\<not> gds_is_finished gds v s \\<Longrightarrow>\n    rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     ?s4\n 3. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    \\<not> gds_is_finished gds v s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered ?s4 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds ?s4) \\<and>\n    \\<not> gds_is_break gds ?s4\n 4. gds_back_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (simp add: pw_le_iff refine_pw_simps split: option.split, blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    \\<not> gds_is_finished gds v s \\<Longrightarrow>\n    rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     s0\n 2. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    \\<not> gds_is_finished gds v s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds s0) \\<and>\n    \\<not> gds_is_break gds s0\n 3. gds_back_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    gds_is_discovered gds v s \\<and>\n    \\<not> gds_is_finished gds v s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds s0) \\<and>\n    \\<not> gds_is_break gds s0\n 2. gds_back_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_back_edge gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (rule back_edge_incr[OF PRE])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gds_discover_refine:\n      assumes PRE: \"pre_discover u v s0 s\"\n      shows \"gds_discover gds u v s \\<le> SPEC (\\<lambda>s'. gen_rwof s' \n            \\<and> gen_discovered s \\<subseteq> gen_discovered s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_discover gds u v s\n    \\<le> SPEC\n           (\\<lambda>s'.\n               gen_rwof s' \\<and>\n               gen_discovered s \\<subseteq> gen_discovered s')", "apply (rule SPEC_rule_conj_leofI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gds_discover gds u v s \\<le> SPEC gen_rwof\n 2. gds_discover gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (rule order_trans[OF _ rwof_step[OF nofail]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. gds_discover gds u v s \\<le> gen_step ?s4\n 2. gen_rwof ?s4\n 3. gen_cond ?s4\n 4. gds_discover gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "using PRE"], ["proof (prove)\nusing this:\n  pre_discover u v s0 s\n\ngoal (4 subgoals):\n 1. gds_discover gds u v s \\<le> gen_step ?s4\n 2. gen_rwof ?s4\n 3. gen_cond ?s4\n 4. gds_discover gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (unfold gen_step_def gen_cond_def pre_discover_def \n            post_get_pending_def pre_get_pending_def) [3]"], ["proof (prove)\ngoal (4 subgoals):\n 1. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    \\<not> gds_is_discovered gds v s \\<Longrightarrow>\n    gds_discover gds u v s\n    \\<le> (if gds_is_empty_stack gds ?s4\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 ?s4) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 ?s4)\n           else gds_get_pending gds ?s4 \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n 2. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    \\<not> gds_is_discovered gds v s \\<Longrightarrow>\n    rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     ?s4\n 3. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    \\<not> gds_is_discovered gds v s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered ?s4 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds ?s4) \\<and>\n    \\<not> gds_is_break gds ?s4\n 4. gds_discover gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (simp add: pw_le_iff refine_pw_simps split: option.split, blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    \\<not> gds_is_discovered gds v s \\<Longrightarrow>\n    rwof (gds_init gds)\n     (\\<lambda>s.\n         (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n          \\<not> gds_is_empty_stack gds s) \\<and>\n         \\<not> gds_is_break gds s)\n     (\\<lambda>s.\n         if gds_is_empty_stack gds s\n         then SPEC\n               (\\<lambda>v0.\n                   v0 \\<in> V0 \\<and>\n                   \\<not> gds_is_discovered gds v0 s) \\<bind>\n              (\\<lambda>v0. gds_new_root gds v0 s)\n         else gds_get_pending gds s \\<bind>\n              (\\<lambda>(u, Vs, s).\n                  case Vs of None \\<Rightarrow> gds_finish gds u s\n                  | Some v \\<Rightarrow>\n                      if gds_is_discovered gds v s\n                      then if gds_is_finished gds v s\n                           then gds_cross_edge gds u v s\n                           else gds_back_edge gds u v s\n                      else gds_discover gds u v s))\n     s0\n 2. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    \\<not> gds_is_discovered gds v s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds s0) \\<and>\n    \\<not> gds_is_break gds s0\n 3. gds_discover gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       (\\<lambda>s.\n           if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))\n       s0 \\<and>\n      \\<not> gds_is_empty_stack gds s0 \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n    \\<not> gds_is_discovered gds v s \\<Longrightarrow>\n    (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n     \\<not> gds_is_empty_stack gds s0) \\<and>\n    \\<not> gds_is_break gds s0\n 2. gds_discover gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_discover gds u v s \\<le>\\<^sub>n\n    SPEC (\\<lambda>sa. gen_discovered s \\<subseteq> gen_discovered sa)", "apply (rule discover_incr[OF PRE])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma gen_step_disc_incr:\n    assumes \"nofail gen_dfs\"\n    assumes \"gen_rwof s\" \"insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s\"\n    assumes \"\\<not>gds_is_break gds s\" \"\\<not>gds_is_empty_stack gds s\"\n    shows \"gen_step s \\<le> SPEC (\\<lambda>s. insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_step s\n    \\<le> SPEC\n           (\\<lambda>s.\n               insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s)", "using assms"], ["proof (prove)\nusing this:\n  nofail gen_dfs\n  gen_rwof s\n  insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s\n  \\<not> gds_is_break gds s\n  \\<not> gds_is_empty_stack gds s\n\ngoal (1 subgoal):\n 1. gen_step s\n    \\<le> SPEC\n           (\\<lambda>s.\n               insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s)", "apply (simp only: gen_step_def gen_dfs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n     gen_rwof s; insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s;\n     \\<not> gds_is_break gds s; \\<not> gds_is_empty_stack gds s\\<rbrakk>\n    \\<Longrightarrow> (if False\n                       then SPEC\n                             (\\<lambda>v0.\n                                 v0 \\<in> V0 \\<and>\n                                 \\<not> gds_is_discovered gds v0 s) \\<bind>\n                            (\\<lambda>v0. gds_new_root gds v0 s)\n                       else gds_get_pending gds s \\<bind>\n                            (\\<lambda>(u, Vs, s).\n                                case Vs of\n                                None \\<Rightarrow> gds_finish gds u s\n                                | Some v \\<Rightarrow>\n                                    if gds_is_discovered gds v s\n                                    then if gds_is_finished gds v s\n   then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                    else gds_discover gds u v s))\n                      \\<le> SPEC\n                             (\\<lambda>s.\n                                 insert v0 (gen_discovered s0)\n                                 \\<subseteq> gen_discovered s)", "apply (refine_rcg refine_vcg \n      order_trans[OF gds_init_refine]\n      order_trans[OF gds_new_root_refine]\n      order_trans[OF gds_get_pending_refine]\n      order_trans[OF gds_finish_refine]\n      order_trans[OF gds_cross_edge_refine]\n      order_trans[OF gds_back_edge_refine]\n      order_trans[OF gds_discover_refine]\n      )"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof s;\n        insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s;\n        \\<not> gds_is_break gds s; \\<not> gds_is_empty_stack gds s; False;\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s\\<rbrakk>\n       \\<Longrightarrow> pre_new_root x s\n 2. \\<And>x xa.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof s;\n        insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s;\n        \\<not> gds_is_break gds s; \\<not> gds_is_empty_stack gds s; False;\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s;\n        gen_rwof xa \\<and>\n        insert x (gen_discovered s) \\<subseteq> gen_discovered xa\\<rbrakk>\n       \\<Longrightarrow> insert v0 (gen_discovered s0)\n                         \\<subseteq> gen_discovered xa\n 3. \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n     gen_rwof s; insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s;\n     \\<not> gds_is_break gds s; \\<not> gds_is_empty_stack gds s;\n     \\<not> False\\<rbrakk>\n    \\<Longrightarrow> pre_get_pending s\n 4. \\<And>x a b aa ba.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof s;\n        insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s;\n        \\<not> gds_is_break gds s; \\<not> gds_is_empty_stack gds s;\n        \\<not> False;\n        case x of\n        (u, Vs, s') \\<Rightarrow>\n          post_get_pending u Vs s s' \\<and>\n          gen_discovered s \\<subseteq> gen_discovered s';\n        x = (a, b); b = (aa, ba); aa = None\\<rbrakk>\n       \\<Longrightarrow> pre_finish a (?s0.19 x a b aa ba) ba\n 5. \\<And>x a b aa ba xa.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof s;\n        insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s;\n        \\<not> gds_is_break gds s; \\<not> gds_is_empty_stack gds s;\n        \\<not> False;\n        case x of\n        (u, Vs, s') \\<Rightarrow>\n          post_get_pending u Vs s s' \\<and>\n          gen_discovered s \\<subseteq> gen_discovered s';\n        x = (a, b); b = (aa, ba); aa = None;\n        gen_rwof xa \\<and>\n        gen_discovered ba \\<subseteq> gen_discovered xa\\<rbrakk>\n       \\<Longrightarrow> insert v0 (gen_discovered s0)\n                         \\<subseteq> gen_discovered xa\n 6. \\<And>x a b aa ba xa.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof s;\n        insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s;\n        \\<not> gds_is_break gds s; \\<not> gds_is_empty_stack gds s;\n        \\<not> False;\n        case x of\n        (u, Vs, s') \\<Rightarrow>\n          post_get_pending u Vs s s' \\<and>\n          gen_discovered s \\<subseteq> gen_discovered s';\n        x = (a, b); b = (aa, ba); aa = Some xa; gds_is_discovered gds xa ba;\n        gds_is_finished gds xa ba\\<rbrakk>\n       \\<Longrightarrow> pre_cross_edge a xa (?s0.24 x a b aa ba xa) ba\n 7. \\<And>x a b aa ba xa xb.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof s;\n        insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s;\n        \\<not> gds_is_break gds s; \\<not> gds_is_empty_stack gds s;\n        \\<not> False;\n        case x of\n        (u, Vs, s') \\<Rightarrow>\n          post_get_pending u Vs s s' \\<and>\n          gen_discovered s \\<subseteq> gen_discovered s';\n        x = (a, b); b = (aa, ba); aa = Some xa; gds_is_discovered gds xa ba;\n        gds_is_finished gds xa ba;\n        gen_rwof xb \\<and>\n        gen_discovered ba \\<subseteq> gen_discovered xb\\<rbrakk>\n       \\<Longrightarrow> insert v0 (gen_discovered s0)\n                         \\<subseteq> gen_discovered xb\n 8. \\<And>x a b aa ba xa.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof s;\n        insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s;\n        \\<not> gds_is_break gds s; \\<not> gds_is_empty_stack gds s;\n        \\<not> False;\n        case x of\n        (u, Vs, s') \\<Rightarrow>\n          post_get_pending u Vs s s' \\<and>\n          gen_discovered s \\<subseteq> gen_discovered s';\n        x = (a, b); b = (aa, ba); aa = Some xa; gds_is_discovered gds xa ba;\n        \\<not> gds_is_finished gds xa ba\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge a xa (?s0.27 x a b aa ba xa) ba\n 9. \\<And>x a b aa ba xa xb.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof s;\n        insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s;\n        \\<not> gds_is_break gds s; \\<not> gds_is_empty_stack gds s;\n        \\<not> False;\n        case x of\n        (u, Vs, s') \\<Rightarrow>\n          post_get_pending u Vs s s' \\<and>\n          gen_discovered s \\<subseteq> gen_discovered s';\n        x = (a, b); b = (aa, ba); aa = Some xa; gds_is_discovered gds xa ba;\n        \\<not> gds_is_finished gds xa ba;\n        gen_rwof xb \\<and>\n        gen_discovered ba \\<subseteq> gen_discovered xb\\<rbrakk>\n       \\<Longrightarrow> insert v0 (gen_discovered s0)\n                         \\<subseteq> gen_discovered xb\n 10. \\<And>x a b aa ba xa.\n        \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n         gen_rwof s;\n         insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s;\n         \\<not> gds_is_break gds s; \\<not> gds_is_empty_stack gds s;\n         \\<not> False;\n         case x of\n         (u, Vs, s') \\<Rightarrow>\n           post_get_pending u Vs s s' \\<and>\n           gen_discovered s \\<subseteq> gen_discovered s';\n         x = (a, b); b = (aa, ba); aa = Some xa;\n         \\<not> gds_is_discovered gds xa ba\\<rbrakk>\n        \\<Longrightarrow> pre_discover a xa (?s0.30 x a b aa ba xa) ba\nA total of 11 subgoals...", "apply (auto \n      simp: it_step_insert_iff gen_cond_def\n      pre_new_root_def pre_get_pending_def pre_finish_def \n      pre_cross_edge_def pre_back_edge_def pre_discover_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem tailrec_impl: \"tailrec_impl \\<le> gen_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tailrec_impl \\<le> gen_dfs", "unfolding gen_dfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tailrec_impl \\<le> gds_init gds \\<bind> WHILE gen_cond gen_step", "apply (rule WHILE_refine_rwof)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (gds_init gds \\<bind> WHILE gen_cond gen_step) \\<Longrightarrow>\n    local.tailrec_impl\n    \\<le> SPEC (\\<lambda>s. gen_rwof s \\<and> \\<not> gen_cond s)", "unfolding tailrec_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (gds_init gds \\<bind> WHILE gen_cond gen_step) \\<Longrightarrow>\n    gds_init gds \\<bind>\n    FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                              gen_rwof s \\<and>\n                              (\\<not> gds_is_break gds s \\<longrightarrow>\n                               gds_is_empty_stack gds s) \\<and>\n                              V0 - it \\<subseteq> gen_discovered s\\<^esup>\n     V0 ((Not \\<circ>\\<circ> gds_is_break) gds)\n     (\\<lambda>v0 s.\n         let s0 = s\n         in if gds_is_discovered gds v0 s then RETURN s\n            else gds_new_root gds v0 s \\<bind>\n                 WHILE\\<^bsup>\\<lambda>s.\n                                 gen_rwof s \\<and>\n                                 insert v0 (gen_discovered s0)\n                                 \\<subseteq> gen_discovered s\\<^esup>\n                  (\\<lambda>s.\n                      \\<not> gds_is_break gds s \\<and>\n                      \\<not> gds_is_empty_stack gds s)\n                  (\\<lambda>s.\n                      gds_get_pending gds s \\<bind>\n                      (\\<lambda>(u, Vs, s).\n                          case Vs of None \\<Rightarrow> gds_finish gds u s\n                          | Some v \\<Rightarrow>\n                              if gds_is_discovered gds v s\n                              then if gds_is_finished gds v s\n                                   then gds_cross_edge gds u v s\n                                   else gds_back_edge gds u v s\n                              else gds_discover gds u v s)))\n    \\<le> SPEC (\\<lambda>s. gen_rwof s \\<and> \\<not> gen_cond s)", "apply (refine_rcg refine_vcg \n      order_trans[OF gds_init_refine]\n      order_trans[OF gds_new_root_refine]\n      order_trans[OF gds_get_pending_refine]\n      order_trans[OF gds_finish_refine]\n      order_trans[OF gds_cross_edge_refine]\n      order_trans[OF gds_back_edge_refine]\n      order_trans[OF gds_discover_refine]\n      )"], ["proof (prove)\ngoal (30 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof x \\<and> gds_is_empty_stack gds x\\<rbrakk>\n       \\<Longrightarrow> finite V0\n 2. \\<And>x.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof x \\<and> gds_is_empty_stack gds x\\<rbrakk>\n       \\<Longrightarrow> gen_rwof x\n 3. \\<And>x.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof x \\<and> gds_is_empty_stack gds x;\n        \\<not> gds_is_break gds x\\<rbrakk>\n       \\<Longrightarrow> gds_is_empty_stack gds x\n 4. \\<And>x.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof x \\<and> gds_is_empty_stack gds x\\<rbrakk>\n       \\<Longrightarrow> V0 - V0 \\<subseteq> gen_discovered x\n 5. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof x \\<and> gds_is_empty_stack gds x; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        gds_is_discovered gds xa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> gen_rwof \\<sigma>\n 6. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof x \\<and> gds_is_empty_stack gds x; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        gds_is_discovered gds xa \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> gds_is_empty_stack gds \\<sigma>\n 7. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof x \\<and> gds_is_empty_stack gds x; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        gds_is_discovered gds xa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> V0 - (it - {xa})\n                         \\<subseteq> gen_discovered \\<sigma>\n 8. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof x \\<and> gds_is_empty_stack gds x; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> pre_new_root xa \\<sigma>\n 9. \\<And>x xa it \\<sigma> xb.\n       \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n        gen_rwof x \\<and> gds_is_empty_stack gds x; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof xb \\<and>\n        insert xa (gen_discovered \\<sigma>)\n        \\<subseteq> gen_discovered xb\\<rbrakk>\n       \\<Longrightarrow> gen_rwof xb\n 10. \\<And>x xa it \\<sigma> xb.\n        \\<lbrakk>nofail (gds_init gds \\<bind> WHILE gen_cond gen_step);\n         gen_rwof x \\<and> gds_is_empty_stack gds x; xa \\<in> it;\n         it \\<subseteq> V0;\n         gen_rwof \\<sigma> \\<and>\n         (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n          gds_is_empty_stack gds \\<sigma>) \\<and>\n         V0 - it \\<subseteq> gen_discovered \\<sigma>;\n         (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n         \\<not> gds_is_discovered gds xa \\<sigma>;\n         gen_rwof xb \\<and>\n         insert xa (gen_discovered \\<sigma>)\n         \\<subseteq> gen_discovered xb\\<rbrakk>\n        \\<Longrightarrow> insert xa (gen_discovered \\<sigma>)\n                          \\<subseteq> gen_discovered xb\nA total of 30 subgoals...", "apply (auto \n      simp: it_step_insert_iff gen_cond_def\n      pre_new_root_def pre_get_pending_def pre_finish_def \n      pre_cross_edge_def pre_back_edge_def pre_discover_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tr_impl_while_body_gen_step:\n    assumes [simp]: \"\\<not>gds_is_empty_stack gds s\"\n    shows \"tr_impl_while_body s \\<le> gen_step s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr_impl_while_body s \\<le> gen_step s", "unfolding tr_impl_while_body_def gen_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_get_pending gds s \\<bind>\n    (\\<lambda>(u, Vs, s).\n        case Vs of None \\<Rightarrow> gds_finish gds u s\n        | Some v \\<Rightarrow>\n            if gds_is_discovered gds v s\n            then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                 else gds_back_edge gds u v s\n            else gds_discover gds u v s)\n    \\<le> (if gds_is_empty_stack gds s\n           then SPEC\n                 (\\<lambda>v0.\n                     v0 \\<in> V0 \\<and>\n                     \\<not> gds_is_discovered gds v0 s) \\<bind>\n                (\\<lambda>v0. gds_new_root gds v0 s)\n           else gds_get_pending gds s \\<bind>\n                (\\<lambda>(u, Vs, s).\n                    case Vs of None \\<Rightarrow> gds_finish gds u s\n                    | Some v \\<Rightarrow>\n                        if gds_is_discovered gds v s\n                        then if gds_is_finished gds v s\n                             then gds_cross_edge gds u v s\n                             else gds_back_edge gds u v s\n                        else gds_discover gds u v s))", "by simp"], ["", "lemma tailrecT_impl: \"tailrec_implT \\<le> gen_dfsT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tailrec_implT \\<le> gen_dfsT", "proof (rule le_nofailI)"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail gen_dfsT \\<Longrightarrow> tailrec_implT \\<le> gen_dfsT", "let ?V = \"rwof_rel (gds_init gds) gen_cond gen_step\""], ["proof (state)\ngoal (1 subgoal):\n 1. nofail gen_dfsT \\<Longrightarrow> tailrec_implT \\<le> gen_dfsT", "assume NF: \"nofail gen_dfsT\""], ["proof (state)\nthis:\n  nofail gen_dfsT\n\ngoal (1 subgoal):\n 1. nofail gen_dfsT \\<Longrightarrow> tailrec_implT \\<le> gen_dfsT", "from nofail_WHILEIT_wf_rel[of \"gds_init gds\" \"\\<lambda>_. True\" gen_cond gen_step]\n      and this[unfolded gen_dfsT_def WHILET_def]"], ["proof (chain)\npicking this:\n  nofail\n   (gds_init gds \\<bind>\n    WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> gen_cond\n     gen_step) \\<Longrightarrow>\n  wf ((rwof_rel (gds_init gds) gen_cond gen_step)\\<inverse>)\n  nofail\n   (gds_init gds \\<bind>\n    WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> gen_cond gen_step)", "have WF: \"wf (?V\\<inverse>)\""], ["proof (prove)\nusing this:\n  nofail\n   (gds_init gds \\<bind>\n    WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> gen_cond\n     gen_step) \\<Longrightarrow>\n  wf ((rwof_rel (gds_init gds) gen_cond gen_step)\\<inverse>)\n  nofail\n   (gds_init gds \\<bind>\n    WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> gen_cond gen_step)\n\ngoal (1 subgoal):\n 1. wf ((rwof_rel (gds_init gds) gen_cond gen_step)\\<inverse>)", "by simp"], ["proof (state)\nthis:\n  wf ((rwof_rel (gds_init gds) gen_cond gen_step)\\<inverse>)\n\ngoal (1 subgoal):\n 1. nofail gen_dfsT \\<Longrightarrow> tailrec_implT \\<le> gen_dfsT", "from NF"], ["proof (chain)\npicking this:\n  nofail gen_dfsT", "have NF': \"nofail gen_dfs\""], ["proof (prove)\nusing this:\n  nofail gen_dfsT\n\ngoal (1 subgoal):\n 1. nofail gen_dfs", "using gen_dfs_le_gen_dfsT"], ["proof (prove)\nusing this:\n  nofail gen_dfsT\n  gen_dfs \\<le> gen_dfsT\n\ngoal (1 subgoal):\n 1. nofail gen_dfs", "by (auto simp: pw_le_iff)"], ["proof (state)\nthis:\n  nofail gen_dfs\n\ngoal (1 subgoal):\n 1. nofail gen_dfsT \\<Longrightarrow> tailrec_implT \\<le> gen_dfsT", "from rwof_rel_spec[of \"gds_init gds\" gen_cond gen_step]"], ["proof (chain)\npicking this:\n  \\<lbrakk>gen_rwof ?s; gen_cond ?s\\<rbrakk>\n  \\<Longrightarrow> gen_step ?s \\<le>\\<^sub>n\n                    SPEC\n                     (\\<lambda>s'.\n                         (?s, s')\n                         \\<in> rwof_rel (gds_init gds) gen_cond gen_step)", "have\n      \"\\<And>s. \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk> \\<Longrightarrow> gen_step s \\<le>\\<^sub>n SPEC (\\<lambda>s'. (s,s')\\<in>?V)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>gen_rwof ?s; gen_cond ?s\\<rbrakk>\n  \\<Longrightarrow> gen_step ?s \\<le>\\<^sub>n\n                    SPEC\n                     (\\<lambda>s'.\n                         (?s, s')\n                         \\<in> rwof_rel (gds_init gds) gen_cond gen_step)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> gen_step s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (s, s')\n                              \\<in> rwof_rel (gds_init gds) gen_cond\n                                     gen_step)", "."], ["proof (state)\nthis:\n  \\<lbrakk>gen_rwof ?s; gen_cond ?s\\<rbrakk>\n  \\<Longrightarrow> gen_step ?s \\<le>\\<^sub>n\n                    SPEC\n                     (\\<lambda>s'.\n                         (?s, s')\n                         \\<in> rwof_rel (gds_init gds) gen_cond gen_step)\n\ngoal (1 subgoal):\n 1. nofail gen_dfsT \\<Longrightarrow> tailrec_implT \\<le> gen_dfsT", "hence \n      aux: \"\\<And>s. \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk> \\<Longrightarrow> gen_step s \\<le> SPEC (\\<lambda>s'. (s,s')\\<in>?V)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>gen_rwof ?s; gen_cond ?s\\<rbrakk>\n  \\<Longrightarrow> gen_step ?s \\<le>\\<^sub>n\n                    SPEC\n                     (\\<lambda>s'.\n                         (?s, s')\n                         \\<in> rwof_rel (gds_init gds) gen_cond gen_step)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> gen_step s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (s, s')\n                                    \\<in> rwof_rel (gds_init gds) gen_cond\n     gen_step)", "apply (rule leofD[rotated])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk> \\<Longrightarrow> gen_rwof s\n 2. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk> \\<Longrightarrow> gen_cond s\n 3. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> nofail (gen_step s)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk> \\<Longrightarrow> gen_cond s\n 2. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> nofail (gen_step s)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> nofail (gen_step s)", "using NF[unfolded gen_dfsT_def]"], ["proof (prove)\nusing this:\n  nofail (gds_init gds \\<bind> WHILE\\<^sub>T gen_cond gen_step)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> nofail (gen_step s)", "by (drule (1) WHILET_nofail_imp_rwof_nofail)"], ["proof (state)\nthis:\n  \\<lbrakk>gen_rwof ?s; gen_cond ?s\\<rbrakk>\n  \\<Longrightarrow> gen_step ?s\n                    \\<le> SPEC\n                           (\\<lambda>s'.\n                               (?s, s')\n                               \\<in> rwof_rel (gds_init gds) gen_cond\ngen_step)\n\ngoal (1 subgoal):\n 1. nofail gen_dfsT \\<Longrightarrow> tailrec_implT \\<le> gen_dfsT", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. tailrec_implT \\<le> gen_dfsT", "apply (rule order_trans[OF _ gen_dfs_le_gen_dfsT])"], ["proof (prove)\ngoal (1 subgoal):\n 1. tailrec_implT \\<le> gen_dfs", "apply (rule order_trans[OF _ tailrec_impl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. tailrec_implT \\<le> local.tailrec_impl", "unfolding tailrec_implT_def tailrec_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind>\n    FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                              gen_rwof s \\<and>\n                              (\\<not> gds_is_break gds s \\<longrightarrow>\n                               gds_is_empty_stack gds s) \\<and>\n                              V0 - it \\<subseteq> gen_discovered s\\<^esup>\n     V0 ((Not \\<circ>\\<circ> gds_is_break) gds)\n     (\\<lambda>v0 s.\n         let s0 = s\n         in if gds_is_discovered gds v0 s then RETURN s\n            else gds_new_root gds v0 s \\<bind>\n                 WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n   gen_rwof s \\<and>\n   insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s\\<^esup>\n                  (\\<lambda>s.\n                      \\<not> gds_is_break gds s \\<and>\n                      \\<not> gds_is_empty_stack gds s)\n                  tr_impl_while_body)\n    \\<le> gds_init gds \\<bind>\n          FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                                    gen_rwof s \\<and>\n                                    (\\<not> gds_is_break gds\n       s \\<longrightarrow>\n                                     gds_is_empty_stack gds s) \\<and>\n                                    V0 - it\n                                    \\<subseteq> gen_discovered s\\<^esup>\n           V0 ((Not \\<circ>\\<circ> gds_is_break) gds)\n           (\\<lambda>v0 s.\n               let s0 = s\n               in if gds_is_discovered gds v0 s then RETURN s\n                  else gds_new_root gds v0 s \\<bind>\n                       WHILE\\<^bsup>\\<lambda>s.\n gen_rwof s \\<and>\n insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s\\<^esup>\n                        (\\<lambda>s.\n                            \\<not> gds_is_break gds s \\<and>\n                            \\<not> gds_is_empty_stack gds s)\n                        (\\<lambda>s.\n                            gds_get_pending gds s \\<bind>\n                            (\\<lambda>(u, Vs, s).\n                                case Vs of\n                                None \\<Rightarrow> gds_finish gds u s\n                                | Some v \\<Rightarrow>\n                                    if gds_is_discovered gds v s\n                                    then if gds_is_finished gds v s\n   then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                    else gds_discover gds u v s)))", "unfolding tr_impl_while_body_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind>\n    FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                              gen_rwof s \\<and>\n                              (\\<not> gds_is_break gds s \\<longrightarrow>\n                               gds_is_empty_stack gds s) \\<and>\n                              V0 - it \\<subseteq> gen_discovered s\\<^esup>\n     V0 ((Not \\<circ>\\<circ> gds_is_break) gds)\n     (\\<lambda>v0 s.\n         let s0 = s\n         in if gds_is_discovered gds v0 s then RETURN s\n            else gds_new_root gds v0 s \\<bind>\n                 WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n   gen_rwof s \\<and>\n   insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s\\<^esup>\n                  (\\<lambda>s.\n                      \\<not> gds_is_break gds s \\<and>\n                      \\<not> gds_is_empty_stack gds s)\n                  tr_impl_while_body)\n    \\<le> gds_init gds \\<bind>\n          FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                                    gen_rwof s \\<and>\n                                    (\\<not> gds_is_break gds\n       s \\<longrightarrow>\n                                     gds_is_empty_stack gds s) \\<and>\n                                    V0 - it\n                                    \\<subseteq> gen_discovered s\\<^esup>\n           V0 ((Not \\<circ>\\<circ> gds_is_break) gds)\n           (\\<lambda>v0 s.\n               let s0 = s\n               in if gds_is_discovered gds v0 s then RETURN s\n                  else gds_new_root gds v0 s \\<bind>\n                       WHILE\\<^bsup>\\<lambda>s.\n gen_rwof s \\<and>\n insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s\\<^esup>\n                        (\\<lambda>s.\n                            \\<not> gds_is_break gds s \\<and>\n                            \\<not> gds_is_empty_stack gds s)\n                        tr_impl_while_body)", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind>\n    FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                              gen_rwof s \\<and>\n                              (\\<not> gds_is_break gds s \\<longrightarrow>\n                               gds_is_empty_stack gds s) \\<and>\n                              V0 - it \\<subseteq> gen_discovered s\\<^esup>\n     V0 ((Not \\<circ>\\<circ> gds_is_break) gds)\n     (\\<lambda>v0 s.\n         let s0 = s\n         in if gds_is_discovered gds v0 s then RETURN s\n            else gds_new_root gds v0 s \\<bind>\n                 WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n   gen_rwof s \\<and>\n   insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s\\<^esup>\n                  (\\<lambda>s.\n                      \\<not> gds_is_break gds s \\<and>\n                      \\<not> gds_is_empty_stack gds s)\n                  tr_impl_while_body)\n    \\<le> \\<Down> Id\n           (gds_init gds \\<bind>\n            FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\ngen_rwof s \\<and>\n(\\<not> gds_is_break gds s \\<longrightarrow>\n gds_is_empty_stack gds s) \\<and>\nV0 - it \\<subseteq> gen_discovered s\\<^esup>\n             V0 ((Not \\<circ>\\<circ> gds_is_break) gds)\n             (\\<lambda>v0 s.\n                 let s0 = s\n                 in if gds_is_discovered gds v0 s then RETURN s\n                    else gds_new_root gds v0 s \\<bind>\n                         WHILE\\<^bsup>\\<lambda>s.\n   gen_rwof s \\<and>\n   insert v0 (gen_discovered s0) \\<subseteq> gen_discovered s\\<^esup>\n                          (\\<lambda>s.\n                              \\<not> gds_is_break gds s \\<and>\n                              \\<not> gds_is_empty_stack gds s)\n                          tr_impl_while_body))", "apply (refine_rcg bind_refine' inj_on_id)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>s sa.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds)\\<rbrakk>\n       \\<Longrightarrow> V0 = id ` V0\n 2. \\<And>s sa it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); it' = id ` it; it \\<subseteq> V0;\n        it' \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        (\\<sigma>, \\<sigma>') \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma> =\n                         (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>'\n 3. \\<And>s sa it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); it' = id ` it; it \\<subseteq> V0;\n        it' \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> gen_rwof \\<sigma>\n 4. \\<And>s sa it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); it' = id ` it; it \\<subseteq> V0;\n        it' \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id;\n        \\<not> gds_is_break gds \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> gds_is_empty_stack gds \\<sigma>\n 5. \\<And>s sa it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); it' = id ` it; it \\<subseteq> V0;\n        it' \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> V0 - it \\<subseteq> gen_discovered \\<sigma>\n 6. \\<And>s sa x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); x' = id x; x \\<in> it; x' \\<in> it';\n        it' = id ` it; it \\<subseteq> V0; it' \\<subseteq> V0;\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds x \\<sigma> =\n                         gds_is_discovered gds x' \\<sigma>'\n 7. \\<And>s sa x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); x' = id x; x \\<in> it; x' \\<in> it';\n        it' = id ` it; it \\<subseteq> V0; it' \\<subseteq> V0;\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id;\n        \\<not> gds_is_discovered gds x \\<sigma>;\n        \\<not> gds_is_discovered gds x' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> gds_new_root gds x \\<sigma>\n                         \\<le> \\<Down>\n                                (?R'18 s sa x it \\<sigma> x' it' \\<sigma>')\n                                (gds_new_root gds x' \\<sigma>')\n 8. \\<And>s sa x it \\<sigma> x' it' \\<sigma>' sb sc.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); x' = id x; x \\<in> it; x' \\<in> it';\n        it' = id ` it; it \\<subseteq> V0; it' \\<subseteq> V0;\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id;\n        \\<not> gds_is_discovered gds x \\<sigma>;\n        \\<not> gds_is_discovered gds x' \\<sigma>';\n        (sb, sc) \\<in> ?R'18 s sa x it \\<sigma> x' it' \\<sigma>';\n        inres (gds_new_root gds x \\<sigma>) sb;\n        inres (gds_new_root gds x' \\<sigma>') sc;\n        nofail (gds_new_root gds x \\<sigma>);\n        nofail (gds_new_root gds x' \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n           gen_rwof s \\<and>\n           insert x (gen_discovered \\<sigma>)\n           \\<subseteq> gen_discovered s\\<^esup>\n                          (\\<lambda>s.\n                              \\<not> gds_is_break gds s \\<and>\n                              \\<not> gds_is_empty_stack gds s)\n                          tr_impl_while_body sb\n                         \\<le> \\<Down> Id\n                                (WHILE\\<^bsup>\\<lambda>s.\n           gen_rwof s \\<and>\n           insert x' (gen_discovered \\<sigma>')\n           \\<subseteq> gen_discovered s\\<^esup>\n                                  (\\<lambda>s.\n\\<not> gds_is_break gds s \\<and> \\<not> gds_is_empty_stack gds s)\n                                  tr_impl_while_body sc)", "apply refine_dref_type"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>s sa.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds)\\<rbrakk>\n       \\<Longrightarrow> V0 = id ` V0\n 2. \\<And>s sa it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); it' = id ` it; it \\<subseteq> V0;\n        it' \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        (\\<sigma>, \\<sigma>') \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma> =\n                         (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>'\n 3. \\<And>s sa it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); it' = id ` it; it \\<subseteq> V0;\n        it' \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> gen_rwof \\<sigma>\n 4. \\<And>s sa it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); it' = id ` it; it \\<subseteq> V0;\n        it' \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id;\n        \\<not> gds_is_break gds \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> gds_is_empty_stack gds \\<sigma>\n 5. \\<And>s sa it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); it' = id ` it; it \\<subseteq> V0;\n        it' \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> V0 - it \\<subseteq> gen_discovered \\<sigma>\n 6. \\<And>s sa x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); x' = id x; x \\<in> it; x' \\<in> it';\n        it' = id ` it; it \\<subseteq> V0; it' \\<subseteq> V0;\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds x \\<sigma> =\n                         gds_is_discovered gds x' \\<sigma>'\n 7. \\<And>s sa x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); x' = id x; x \\<in> it; x' \\<in> it';\n        it' = id ` it; it \\<subseteq> V0; it' \\<subseteq> V0;\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id;\n        \\<not> gds_is_discovered gds x \\<sigma>;\n        \\<not> gds_is_discovered gds x' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> gds_new_root gds x \\<sigma>\n                         \\<le> \\<Down> Id (gds_new_root gds x' \\<sigma>')\n 8. \\<And>s sa x it \\<sigma> x' it' \\<sigma>' sb sc.\n       \\<lbrakk>(s, sa) \\<in> Id; inres (gds_init gds) s;\n        inres (gds_init gds) sa; nofail (gds_init gds);\n        nofail (gds_init gds); x' = id x; x \\<in> it; x' \\<in> it';\n        it' = id ` it; it \\<subseteq> V0; it' \\<subseteq> V0;\n        gen_rwof \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>) \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        gen_rwof \\<sigma>' \\<and>\n        (\\<not> gds_is_break gds \\<sigma>' \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma>') \\<and>\n        V0 - it' \\<subseteq> gen_discovered \\<sigma>';\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> Id;\n        \\<not> gds_is_discovered gds x \\<sigma>;\n        \\<not> gds_is_discovered gds x' \\<sigma>'; (sb, sc) \\<in> Id;\n        inres (gds_new_root gds x \\<sigma>) sb;\n        inres (gds_new_root gds x' \\<sigma>') sc;\n        nofail (gds_new_root gds x \\<sigma>);\n        nofail (gds_new_root gds x' \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n           gen_rwof s \\<and>\n           insert x (gen_discovered \\<sigma>)\n           \\<subseteq> gen_discovered s\\<^esup>\n                          (\\<lambda>s.\n                              \\<not> gds_is_break gds s \\<and>\n                              \\<not> gds_is_empty_stack gds s)\n                          tr_impl_while_body sb\n                         \\<le> \\<Down> Id\n                                (WHILE\\<^bsup>\\<lambda>s.\n           gen_rwof s \\<and>\n           insert x' (gen_discovered \\<sigma>')\n           \\<subseteq> gen_discovered s\\<^esup>\n                                  (\\<lambda>s.\n\\<not> gds_is_break gds s \\<and> \\<not> gds_is_empty_stack gds s)\n                                  tr_impl_while_body sc)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s sa x it \\<sigma> x' it' \\<sigma>' sb sc.\n       \\<lbrakk>s = sa; inres (gds_init gds) sa; nofail (gds_init gds);\n        x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        gds_is_empty_stack gds \\<sigma>' \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'; \\<sigma> = \\<sigma>';\n        \\<not> gds_is_discovered gds x \\<sigma>'; sb = sc;\n        inres (gds_new_root gds x \\<sigma>') sc;\n        nofail (gds_new_root gds x \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n           gen_rwof s \\<and>\n           gds_is_discovered gds x s \\<and>\n           gen_discovered \\<sigma>' \\<subseteq> gen_discovered s\\<^esup>\n                          (\\<lambda>s.\n                              \\<not> gds_is_break gds s \\<and>\n                              \\<not> gds_is_empty_stack gds s)\n                          tr_impl_while_body sc\n                         \\<le> WHILE\\<^bsup>\\<lambda>s.\n         gen_rwof s \\<and>\n         gds_is_discovered gds x s \\<and>\n         gen_discovered \\<sigma>' \\<subseteq> gen_discovered s\\<^esup>\n                                (\\<lambda>s.\n                                    \\<not> gds_is_break gds s \\<and>\n                                    \\<not> gds_is_empty_stack gds s)\n                                tr_impl_while_body sc", "apply (subst WHILEIT_eq_WHILEI_tproof[where V=\"?V\\<inverse>\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s sa x it \\<sigma> x' it' \\<sigma>' sb sc.\n       \\<lbrakk>s = sa; inres (gds_init gds) sa; nofail (gds_init gds);\n        x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        gds_is_empty_stack gds \\<sigma>' \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'; \\<sigma> = \\<sigma>';\n        \\<not> gds_is_discovered gds x \\<sigma>'; sb = sc;\n        inres (gds_new_root gds x \\<sigma>') sc;\n        nofail (gds_new_root gds x \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> wf ((rwof_rel (gds_init gds) gen_cond\n                               gen_step)\\<inverse>)\n 2. \\<And>s sa x it \\<sigma> x' it' \\<sigma>' sb sc sd.\n       \\<lbrakk>s = sa; inres (gds_init gds) sa; nofail (gds_init gds);\n        x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        gds_is_empty_stack gds \\<sigma>' \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'; \\<sigma> = \\<sigma>';\n        \\<not> gds_is_discovered gds x \\<sigma>'; sb = sc;\n        inres (gds_new_root gds x \\<sigma>') sc;\n        nofail (gds_new_root gds x \\<sigma>');\n        gen_rwof sd \\<and>\n        gds_is_discovered gds x sd \\<and>\n        gen_discovered \\<sigma>' \\<subseteq> gen_discovered sd;\n        \\<not> gds_is_break gds sd \\<and>\n        \\<not> gds_is_empty_stack gds sd\\<rbrakk>\n       \\<Longrightarrow> tr_impl_while_body sd\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (s', sd)\n                                    \\<in> (rwof_rel (gds_init gds) gen_cond\n      gen_step)\\<inverse>)\n 3. \\<And>s sa x it \\<sigma> x' it' \\<sigma>' sb sc.\n       \\<lbrakk>s = sa; inres (gds_init gds) sa; nofail (gds_init gds);\n        x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        gds_is_empty_stack gds \\<sigma>' \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'; \\<sigma> = \\<sigma>';\n        \\<not> gds_is_discovered gds x \\<sigma>'; sb = sc;\n        inres (gds_new_root gds x \\<sigma>') sc;\n        nofail (gds_new_root gds x \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> WHILE\\<^bsup>\\<lambda>s.\n   gen_rwof s \\<and>\n   gds_is_discovered gds x s \\<and>\n   gen_discovered \\<sigma>' \\<subseteq> gen_discovered s\\<^esup>\n                          (\\<lambda>s.\n                              \\<not> gds_is_break gds s \\<and>\n                              \\<not> gds_is_empty_stack gds s)\n                          tr_impl_while_body sc\n                         \\<le> WHILE\\<^bsup>\\<lambda>s.\n         gen_rwof s \\<and>\n         gds_is_discovered gds x s \\<and>\n         gen_discovered \\<sigma>' \\<subseteq> gen_discovered s\\<^esup>\n                                (\\<lambda>s.\n                                    \\<not> gds_is_break gds s \\<and>\n                                    \\<not> gds_is_empty_stack gds s)\n                                tr_impl_while_body sc", "apply (rule WF; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s sa x it \\<sigma> x' it' \\<sigma>' sb sc sd.\n       \\<lbrakk>s = sa; inres (gds_init gds) sa; nofail (gds_init gds);\n        x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        gds_is_empty_stack gds \\<sigma>' \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'; \\<sigma> = \\<sigma>';\n        \\<not> gds_is_discovered gds x \\<sigma>'; sb = sc;\n        inres (gds_new_root gds x \\<sigma>') sc;\n        nofail (gds_new_root gds x \\<sigma>');\n        gen_rwof sd \\<and>\n        gds_is_discovered gds x sd \\<and>\n        gen_discovered \\<sigma>' \\<subseteq> gen_discovered sd;\n        \\<not> gds_is_break gds sd \\<and>\n        \\<not> gds_is_empty_stack gds sd\\<rbrakk>\n       \\<Longrightarrow> tr_impl_while_body sd\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (s', sd)\n                                    \\<in> (rwof_rel (gds_init gds) gen_cond\n      gen_step)\\<inverse>)\n 2. \\<And>s sa x it \\<sigma> x' it' \\<sigma>' sb sc.\n       \\<lbrakk>s = sa; inres (gds_init gds) sa; nofail (gds_init gds);\n        x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        gds_is_empty_stack gds \\<sigma>' \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'; \\<sigma> = \\<sigma>';\n        \\<not> gds_is_discovered gds x \\<sigma>'; sb = sc;\n        inres (gds_new_root gds x \\<sigma>') sc;\n        nofail (gds_new_root gds x \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> WHILE\\<^bsup>\\<lambda>s.\n   gen_rwof s \\<and>\n   gds_is_discovered gds x s \\<and>\n   gen_discovered \\<sigma>' \\<subseteq> gen_discovered s\\<^esup>\n                          (\\<lambda>s.\n                              \\<not> gds_is_break gds s \\<and>\n                              \\<not> gds_is_empty_stack gds s)\n                          tr_impl_while_body sc\n                         \\<le> WHILE\\<^bsup>\\<lambda>s.\n         gen_rwof s \\<and>\n         gds_is_discovered gds x s \\<and>\n         gen_discovered \\<sigma>' \\<subseteq> gen_discovered s\\<^esup>\n                                (\\<lambda>s.\n                                    \\<not> gds_is_break gds s \\<and>\n                                    \\<not> gds_is_empty_stack gds s)\n                                tr_impl_while_body sc", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s_ = sa_; inres (gds_init gds) sa_; nofail (gds_init gds);\n     x'_ = x_; x_ \\<in> it_; it'_ = it_; it_ \\<subseteq> V0;\n     gen_rwof \\<sigma>'_ \\<and>\n     gds_is_empty_stack gds \\<sigma>'_ \\<and>\n     V0 - it_ \\<subseteq> gen_discovered \\<sigma>'_;\n     \\<not> gds_is_break gds \\<sigma>'_; \\<sigma>_ = \\<sigma>'_;\n     \\<not> gds_is_discovered gds x_ \\<sigma>'_; sb_ = sc_;\n     inres (gds_new_root gds x_ \\<sigma>'_) sc_;\n     nofail (gds_new_root gds x_ \\<sigma>'_);\n     gen_rwof sd_ \\<and>\n     gds_is_discovered gds x_ sd_ \\<and>\n     gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered sd_;\n     \\<not> gds_is_break gds sd_ \\<and>\n     \\<not> gds_is_empty_stack gds sd_\\<rbrakk>\n    \\<Longrightarrow> tr_impl_while_body sd_\n                      \\<le> SPEC\n                             (\\<lambda>s'.\n                                 (s', sd_)\n                                 \\<in> (rwof_rel (gds_init gds) gen_cond\n   gen_step)\\<inverse>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s_ = sa_; inres (gds_init gds) sa_; nofail (gds_init gds);\n     x'_ = x_; x_ \\<in> it_; it'_ = it_; it_ \\<subseteq> V0;\n     \\<not> gds_is_break gds \\<sigma>'_; \\<sigma>_ = \\<sigma>'_;\n     \\<not> gds_is_discovered gds x_ \\<sigma>'_; sb_ = sc_;\n     inres (gds_new_root gds x_ \\<sigma>'_) sc_;\n     nofail (gds_new_root gds x_ \\<sigma>'_); gen_rwof \\<sigma>'_;\n     gen_rwof sd_; \\<not> gds_is_break gds sd_;\n     \\<not> gds_is_empty_stack gds sd_; gds_is_empty_stack gds \\<sigma>'_;\n     V0 - it_ \\<subseteq> gen_discovered \\<sigma>'_;\n     gds_is_discovered gds x_ sd_;\n     gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered sd_\\<rbrakk>\n    \\<Longrightarrow> tr_impl_while_body sd_\n                      \\<le> SPEC\n                             (\\<lambda>s'.\n                                 (sd_, s')\n                                 \\<in> rwof_rel (gds_init gds) gen_cond\n  gen_step)", "apply (rule order_trans[OF tr_impl_while_body_gen_step], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s_ = sa_; inres (gds_init gds) sa_; nofail (gds_init gds);\n     x'_ = x_; x_ \\<in> it_; it'_ = it_; it_ \\<subseteq> V0;\n     \\<not> gds_is_break gds \\<sigma>'_; \\<sigma>_ = \\<sigma>'_;\n     \\<not> gds_is_discovered gds x_ \\<sigma>'_; sb_ = sc_;\n     inres (gds_new_root gds x_ \\<sigma>'_) sc_;\n     nofail (gds_new_root gds x_ \\<sigma>'_); gen_rwof \\<sigma>'_;\n     gen_rwof sd_; \\<not> gds_is_break gds sd_;\n     \\<not> gds_is_empty_stack gds sd_; gds_is_empty_stack gds \\<sigma>'_;\n     V0 - it_ \\<subseteq> gen_discovered \\<sigma>'_;\n     gds_is_discovered gds x_ sd_;\n     gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered sd_\\<rbrakk>\n    \\<Longrightarrow> gen_step sd_\n                      \\<le> SPEC\n                             (\\<lambda>s'.\n                                 (sd_, s')\n                                 \\<in> rwof_rel (gds_init gds) gen_cond\n  gen_step)", "apply (rule aux, assumption, (simp add: gen_cond_def; fail))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s sa x it \\<sigma> x' it' \\<sigma>' sb sc.\n       \\<lbrakk>s = sa; inres (gds_init gds) sa; nofail (gds_init gds);\n        x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        gen_rwof \\<sigma>' \\<and>\n        gds_is_empty_stack gds \\<sigma>' \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'; \\<sigma> = \\<sigma>';\n        \\<not> gds_is_discovered gds x \\<sigma>'; sb = sc;\n        inres (gds_new_root gds x \\<sigma>') sc;\n        nofail (gds_new_root gds x \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> WHILE\\<^bsup>\\<lambda>s.\n   gen_rwof s \\<and>\n   gds_is_discovered gds x s \\<and>\n   gen_discovered \\<sigma>' \\<subseteq> gen_discovered s\\<^esup>\n                          (\\<lambda>s.\n                              \\<not> gds_is_break gds s \\<and>\n                              \\<not> gds_is_empty_stack gds s)\n                          tr_impl_while_body sc\n                         \\<le> WHILE\\<^bsup>\\<lambda>s.\n         gen_rwof s \\<and>\n         gds_is_discovered gds x s \\<and>\n         gen_discovered \\<sigma>' \\<subseteq> gen_discovered s\\<^esup>\n                                (\\<lambda>s.\n                                    \\<not> gds_is_break gds s \\<and>\n                                    \\<not> gds_is_empty_stack gds s)\n                                tr_impl_while_body sc", "apply (simp; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  tailrec_implT \\<le> gen_dfsT\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}