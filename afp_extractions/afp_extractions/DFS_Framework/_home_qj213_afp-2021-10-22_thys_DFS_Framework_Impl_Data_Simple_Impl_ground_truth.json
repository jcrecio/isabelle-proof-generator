{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Impl/Data/Simple_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma simple_state_relI:\n  assumes \n  \"dom (finished s') = dom (discovered s') - set (stack s')\"\n  \"set (stack s') \\<subseteq> dom (discovered s')\"\n  \"(m', state.more s') \\<in> erel\"\n  shows \"(\\<lparr>\n    ss_stack = map (\\<lambda>u. (u,pending s' `` {u})) (stack s'),\n    on_stack = set (stack s'),\n    visited = dom (discovered s'),\n    \\<dots> = m'\n  \\<rparr>, s')\\<in>\\<langle>erel\\<rangle>simple_state_rel\"", "lemma simple_state_more_refine[param]: \n  \"(simple_state.more_update, state.more_update)\n    \\<in> (R \\<rightarrow> R) \\<rightarrow> \\<langle>R\\<rangle>simple_state_rel \\<rightarrow> \\<langle>R\\<rangle>simple_state_rel\"", "lemmas gbs_simps[simp, DFS_code_unfold] = gen_basic_dfs_struct.simps[mk_record_simp, OF gbs_def]", "lemmas impl_defs[DFS_code_unfold] \n  = init_impl_def is_empty_stack_impl_def new_root_impl_def\n    get_pending_impl_def finish_impl_def is_discovered_impl_def \n    is_finished_impl_def discover_impl_def", "lemma init_impl: \"(ei, e) \\<in> ES \\<Longrightarrow>\n    c.init_impl ei \\<le>\\<Down>(\\<langle>ES\\<rangle>simple_state_rel) (RETURN (a.empty_state e))\"", "lemma new_root_impl: \n    \"\\<lbrakk>a.gen_dfs.pre_new_root v0 s; \n      (v0i, v0)\\<in>Id; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n      \\<Longrightarrow> c.new_root_impl v0 si \\<le>\\<Down>(\\<langle>ES\\<rangle>simple_state_rel) (RETURN (a.new_root v0 s))\"", "lemma get_pending_impl: \"\n    \\<lbrakk>a.gen_dfs.pre_get_pending s; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n      \\<Longrightarrow> c.get_pending_impl si \n          \\<le> \\<Down> (Id \\<times>\\<^sub>r Id \\<times>\\<^sub>r \\<langle>ES\\<rangle>simple_state_rel) (a.get_pending s)\"", "lemma inres_get_pending_None_conv: \"inres (a.get_pending s0) (v, None, s) \n      \\<longleftrightarrow> s=s0 \\<and> v=hd (stack s0) \\<and> pending s0``{hd (stack s0)} = {}\"", "lemma inres_get_pending_Some_conv: \"inres (a.get_pending s0) (v,Some Vs,s) \n      \\<longleftrightarrow> v = hd (stack s) \\<and> s = s0\\<lparr>pending := pending s0 - {(hd (stack s0), Vs)}\\<rparr>\n       \\<and> (hd (stack s0), Vs) \\<in> pending s0\"", "lemma finish_impl:\n    \"\\<lbrakk>a.gen_dfs.pre_finish v s0 s; (vi, v)\\<in>Id; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n     \\<Longrightarrow> c.finish_impl v si \\<le>\\<Down>(\\<langle>ES\\<rangle>simple_state_rel) (RETURN (a.finish v s))\"", "lemma cross_edge_impl: \"\n    \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; \n      (ui, u)\\<in>Id; (vi, v)\\<in>Id; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n      \\<Longrightarrow> (si, a.cross_edge u v s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\"", "lemma back_edge_impl: \"\n    \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; \n      (ui, u)\\<in>Id; (vi, v)\\<in>Id; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n      \\<Longrightarrow> (si, a.back_edge u v s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\"", "lemma discover_impl:\n    \"\\<lbrakk>a.gen_dfs.pre_discover u v s0 s; (ui, u)\\<in>Id; (vi, v)\\<in>Id; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n     \\<Longrightarrow> c.discover_impl ui vi si \\<le>\\<Down>(\\<langle>ES\\<rangle>simple_state_rel) (RETURN (a.discover u v s))\"", "lemma simple_refine[refine]: \"c.gen_dfs \\<le> \\<Down>(\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\"", "lemma simple_refineT[refine]: \"c.gen_dfsT \\<le> \\<Down>(\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT\"", "lemma simple_tailrec_refine[refine]: \"tailrec_impl \\<le> \\<Down>(\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\"", "lemma simple_tailrecT_refine[refine]: \"tailrec_implT \\<le> \\<Down>(\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT\"", "lemma reachable_invar: \n    assumes \"c.gen_rwof s\" \n    shows \"set (map fst (ss_stack s)) \\<subseteq> visited s \n      \\<and> distinct (map fst (ss_stack s))\"", "lemma simple_rec_refine[refine]: \"rec_impl \\<le> \\<Down>(\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\"", "lemmas [autoref_rel_intf] = REL_INTFI[of ss_impl_rel i_simple_state]", "lemma [autoref_rules, param]:\n  fixes s_rel ps_rel vis_rel erel\n  defines \"R \\<equiv> \\<langle>s_rel,vis_rel,erel\\<rangle>ss_impl_rel\"\n  shows\n  \"(ss_stack_impl, ss_stack) \\<in>  R \\<rightarrow> s_rel\"\n  \"(ss_on_stack_impl, on_stack) \\<in>  R \\<rightarrow> vis_rel\"\n  \"(ss_visited_impl, visited) \\<in> R \\<rightarrow> vis_rel\"\n  \"(simple_state_impl.more, simple_state.more) \\<in> R \\<rightarrow> erel\"\n  \"(ss_stack_impl_update, ss_stack_update) \\<in> (s_rel \\<rightarrow> s_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(ss_on_stack_impl_update, on_stack_update) \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(ss_visited_impl_update, visited_update) \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(simple_state_impl.more_update, simple_state.more_update) \\<in> (erel \\<rightarrow> erel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(simple_state_impl_ext, simple_state_ext) \\<in> s_rel \\<rightarrow> vis_rel \\<rightarrow> vis_rel \\<rightarrow> erel \\<rightarrow> R\"", "lemmas [autoref_rel_intf] = REL_INTFI[of ssnos_impl_rel i_simple_state]", "lemma [autoref_op_pat_def]: \"op_nos_on_stack_update f s \n  \\<equiv> OP (op_nos_on_stack_update f)$s\"", "lemmas ssnos_unfolds \\<comment> \\<open>To be unfolded before autoref when using @{term ssnos_impl_rel}\\<close>\n  = op_nos_on_stack_update_def[symmetric]", "lemma [autoref_rules, param]:\n  fixes s_rel vis_rel erel\n  defines \"R \\<equiv> \\<langle>s_rel,vis_rel,erel\\<rangle>ssnos_impl_rel\"\n  shows\n  \"(ssnos_stack_impl, ss_stack) \\<in>  R \\<rightarrow> s_rel\"\n  \"(ssnos_visited_impl, visited) \\<in> R \\<rightarrow> vis_rel\"\n  \"(simple_state_nos_impl.more, simple_state.more) \\<in> R \\<rightarrow> erel\"\n  \"(ssnos_stack_impl_update, ss_stack_update) \\<in> (s_rel \\<rightarrow> s_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(\\<lambda>x. x, op_nos_on_stack_update f) \\<in> R \\<rightarrow> R\"\n  \"(ssnos_visited_impl_update, visited_update) \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(simple_state_nos_impl.more_update, simple_state.more_update) \\<in> (erel \\<rightarrow> erel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(\\<lambda>ns _ ps vs. simple_state_nos_impl_ext ns ps vs, simple_state_ext) \n    \\<in> s_rel \\<rightarrow> ANY_rel \\<rightarrow> vis_rel \\<rightarrow> erel \\<rightarrow> R\"", "lemmas [autoref_rel_intf] = REL_INTFI[of ssns_impl_rel i_simple_state]", "lemma [autoref_op_pat_def]: \"op_ns_on_stack_update f s \n  \\<equiv> OP (op_ns_on_stack_update f)$s\"", "lemma [autoref_op_pat_def]: \"op_ns_stack_update f s \n  \\<equiv> OP (op_ns_stack_update f)$s\"", "lemma choose_pending_ns_unfold: \"choose_pending u vo s = (\n    case vo of None \\<Rightarrow> RETURN s\n    | Some v \\<Rightarrow> do {\n          _ \\<leftarrow> ASSERT (ss_stack s \\<noteq> []);\n          RETURN\n           (op_ns_stack_update \n             ( let \n                 (u, Vs) = hd (ss_stack s) \n               in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s))\n             )\n             s\n           )\n        })\"", "lemmas ssns_unfolds \\<comment> \\<open>To be unfolded before autoref when using @{term ssns_impl_rel}.\n    Attention: This lemma conflicts with the standard unfolding lemma in \n    @{text DFS_code_unfold}, so has to be placed first in an unfold-statement!\\<close>\n  = op_ns_on_stack_update_def[symmetric] op_ns_stack_update_def[symmetric]\n    choose_pending_ns_unfold", "lemma [autoref_rules, param]:\n  fixes s_rel vis_rel erel ANY_rel\n  defines \"R \\<equiv> \\<langle>ANY_rel,vis_rel,erel\\<rangle>ssns_impl_rel\"\n  shows\n  \"(ssns_visited_impl, visited) \\<in> R \\<rightarrow> vis_rel\"\n  \"(simple_state_ns_impl.more, simple_state.more) \\<in> R \\<rightarrow> erel\"\n  \"\\<And>f. (\\<lambda>x. x, op_ns_stack_update f) \\<in> R \\<rightarrow> R\"\n  \"\\<And>f. (\\<lambda>x. x, op_ns_on_stack_update f) \\<in> R \\<rightarrow> R\"\n  \"(ssns_visited_impl_update, visited_update) \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(simple_state_ns_impl.more_update, simple_state.more_update) \\<in> (erel \\<rightarrow> erel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(\\<lambda>_ _ ps vs. simple_state_ns_impl_ext ps vs, simple_state_ext) \n    \\<in> ANY1_rel \\<rightarrow> ANY2_rel \\<rightarrow> vis_rel \\<rightarrow> erel \\<rightarrow> R\"", "lemma [refine_transfer_post_simp]:\n  \"\\<And>a m. a\\<lparr>simple_state_nos_impl.more := m::unit\\<rparr> = a\"\n  \"\\<And>a m. a\\<lparr>simple_state_impl.more := m::unit\\<rparr> = a\"\n  \"\\<And>a m. a\\<lparr>simple_state_ns_impl.more := m::unit\\<rparr> = a\""], "translations": [["", "lemma simple_state_relI:\n  assumes \n  \"dom (finished s') = dom (discovered s') - set (stack s')\"\n  \"set (stack s') \\<subseteq> dom (discovered s')\"\n  \"(m', state.more s') \\<in> erel\"\n  shows \"(\\<lparr>\n    ss_stack = map (\\<lambda>u. (u,pending s' `` {u})) (stack s'),\n    on_stack = set (stack s'),\n    visited = dom (discovered s'),\n    \\<dots> = m'\n  \\<rparr>, s')\\<in>\\<langle>erel\\<rangle>simple_state_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lparr>ss_stack = map (\\<lambda>u. (u, pending s' `` {u})) (stack s'),\n        on_stack = set (stack s'), visited = dom (discovered s'),\n        \\<dots> = m'\\<rparr>,\n     s')\n    \\<in> \\<langle>erel\\<rangle>simple_state_rel", "using assms"], ["proof (prove)\nusing this:\n  dom (finished s') = dom (discovered s') - set (stack s')\n  set (stack s') \\<subseteq> dom (discovered s')\n  (m', state.more s') \\<in> erel\n\ngoal (1 subgoal):\n 1. (\\<lparr>ss_stack = map (\\<lambda>u. (u, pending s' `` {u})) (stack s'),\n        on_stack = set (stack s'), visited = dom (discovered s'),\n        \\<dots> = m'\\<rparr>,\n     s')\n    \\<in> \\<langle>erel\\<rangle>simple_state_rel", "unfolding simple_state_rel_def"], ["proof (prove)\nusing this:\n  dom (finished s') = dom (discovered s') - set (stack s')\n  set (stack s') \\<subseteq> dom (discovered s')\n  (m', state.more s') \\<in> erel\n\ngoal (1 subgoal):\n 1. (\\<lparr>ss_stack = map (\\<lambda>u. (u, pending s' `` {u})) (stack s'),\n        on_stack = set (stack s'), visited = dom (discovered s'),\n        \\<dots> = m'\\<rparr>,\n     s')\n    \\<in> {(s, s').\n           ss_stack s =\n           map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n           on_stack s = set (stack s') \\<and>\n           visited s = dom (discovered s') \\<and>\n           dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n           set (stack s') \\<subseteq> dom (discovered s') \\<and>\n           (simple_state.more s, state.more s') \\<in> erel}", "by auto"], ["", "lemma simple_state_more_refine[param]: \n  \"(simple_state.more_update, state.more_update)\n    \\<in> (R \\<rightarrow> R) \\<rightarrow> \\<langle>R\\<rangle>simple_state_rel \\<rightarrow> \\<langle>R\\<rangle>simple_state_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (simple_state.more_update, state.more_update)\n    \\<in> (R \\<rightarrow> R) \\<rightarrow>\n          \\<langle>R\\<rangle>simple_state_rel \\<rightarrow>\n          \\<langle>R\\<rangle>simple_state_rel", "apply (clarsimp simp: simple_state_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> R \\<rightarrow> R;\n        ss_stack aa = map (\\<lambda>u. (u, pending a'a `` {u})) (stack a'a);\n        on_stack aa = set (stack a'a); visited aa = dom (discovered a'a);\n        dom (finished a'a) = dom (discovered a'a) - set (stack a'a);\n        set (stack a'a) \\<subseteq> dom (discovered a'a);\n        (simple_state.more aa, state.more a'a) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (a (simple_state.more aa), a' (state.more a'a))\n                         \\<in> R", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open> We outsource the definitions in a separate locale, as we want to re-use them\n  for similar implementations \\<close>"], ["", "locale pre_simple_impl = graph_defs\nbegin"], ["", "definition \"init_impl e \n    \\<equiv> RETURN \\<lparr> ss_stack = [], on_stack = {}, visited = {}, \\<dots> = e \\<rparr>\""], ["", "definition \"is_empty_stack_impl s \\<equiv> (ss_stack s = [])\""], ["", "definition \"is_discovered_impl u s \\<equiv> (u\\<in>visited s)\""], ["", "definition \"is_finished_impl u s \\<equiv> (u\\<in>visited s - (on_stack s))\""], ["", "definition \"finish_impl u s \\<equiv> do {\n    ASSERT (ss_stack s \\<noteq> [] \\<and> u\\<in>on_stack s);\n    let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>;\n    let s = s\\<lparr>on_stack := on_stack s - {u}\\<rparr>;\n    RETURN s\n    }\""], ["", "definition \"get_pending_impl s \\<equiv> do {\n      ASSERT (ss_stack s \\<noteq> []);\n      let (u,Vs) = hd (ss_stack s);\n      if Vs = {} then\n        RETURN (u,None,s)\n      else do {\n        v \\<leftarrow> SPEC (\\<lambda>v. v\\<in>Vs);\n        let Vs = Vs - {v};\n        let s = s\\<lparr> ss_stack := (u,Vs) # tl (ss_stack s) \\<rparr>;\n        RETURN (u, Some v, s)\n      }\n    }\""], ["", "definition \"discover_impl u v s \\<equiv> do {\n    ASSERT (v\\<notin>on_stack s \\<and> v\\<notin>visited s);\n    let s = s\\<lparr>ss_stack := (v,E``{v}) # ss_stack s\\<rparr>;\n    let s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>;\n    let s = s\\<lparr>visited := insert v (visited s)\\<rparr>;\n    RETURN s\n    }\""], ["", "definition \"new_root_impl v0 s \\<equiv> do {\n    ASSERT (v0\\<notin>visited s);\n    let s = s\\<lparr>ss_stack := [(v0,E``{v0})]\\<rparr>;\n    let s = s\\<lparr>on_stack := {v0}\\<rparr>;\n    let s = s\\<lparr>visited := insert v0 (visited s)\\<rparr>;\n    RETURN s\n    }\""], ["", "definition \"gbs \\<equiv> \\<lparr>\n    gbs_init = init_impl,\n    gbs_is_empty_stack = is_empty_stack_impl ,\n    gbs_new_root =  new_root_impl ,\n    gbs_get_pending = get_pending_impl ,\n    gbs_finish =  finish_impl ,\n    gbs_is_discovered = is_discovered_impl ,\n    gbs_is_finished = is_finished_impl ,\n    gbs_back_edge = (\\<lambda>u v s. RETURN s) ,\n    gbs_cross_edge = (\\<lambda>u v s. RETURN s) ,\n    gbs_discover = discover_impl\n  \\<rparr>\""], ["", "lemmas gbs_simps[simp, DFS_code_unfold] = gen_basic_dfs_struct.simps[mk_record_simp, OF gbs_def]"], ["", "lemmas impl_defs[DFS_code_unfold] \n  = init_impl_def is_empty_stack_impl_def new_root_impl_def\n    get_pending_impl_def finish_impl_def is_discovered_impl_def \n    is_finished_impl_def discover_impl_def"], ["", "end"], ["", "text \\<open>\n  Simple implementation of a DFS. This locale assumes a refinement of the\n  parameters, and provides an implementation via a stack and a visited set.\n\\<close>"], ["", "locale simple_impl_defs =\n  a: param_DFS_defs G param\n  + c: pre_simple_impl\n  + gen_param_dfs_refine_defs \n    where gbsi = c.gbs \n    and gbs = a.gbs\n    and upd_exti = simple_state.more_update\n    and upd_ext = state.more_update\n    and V0i = a.V0\n    and V0 = a.V0\nbegin"], ["", "sublocale tailrec_impl_defs G c.gds"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"get_pending s \\<equiv> \\<Union>(set (map (\\<lambda>(u,Vs). {u}\\<times>Vs) (ss_stack s)))\""], ["", "definition \"get_stack s \\<equiv> map fst (ss_stack s)\""], ["", "definition choose_pending \n    :: \"'v \\<Rightarrow> 'v option \\<Rightarrow> ('v,'d) simple_state_scheme \\<Rightarrow> ('v,'d) simple_state_scheme nres\"\n    where [DFS_code_unfold]: \n  \"choose_pending u vo s \\<equiv> \n    case vo of\n      None \\<Rightarrow> RETURN s\n    | Some v \\<Rightarrow> do {\n        ASSERT (ss_stack s \\<noteq> []);\n        let (u,Vs) = hd (ss_stack s);\n        RETURN (s\\<lparr> ss_stack := (u,Vs-{v})#tl (ss_stack s)\\<rparr>)\n      }\""], ["", "sublocale rec_impl_defs G c.gds get_pending get_stack choose_pending"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "locale simple_impl =\n  a: param_DFS\n  + simple_impl_defs\n  + param_refinement\n    where gbsi = c.gbs\n    and gbs = a.gbs\n    and upd_exti = simple_state.more_update\n    and upd_ext = state.more_update\n    and V0i = a.V0\n    and V0 = a.V0\n    and V=Id\n    and S = \"\\<langle>ES\\<rangle>simple_state_rel\"\nbegin"], ["", "lemma init_impl: \"(ei, e) \\<in> ES \\<Longrightarrow>\n    c.init_impl ei \\<le>\\<Down>(\\<langle>ES\\<rangle>simple_state_rel) (RETURN (a.empty_state e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ei, e) \\<in> ES \\<Longrightarrow>\n    c.init_impl ei\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n           (RETURN (a.empty_state e))", "unfolding c.init_impl_def a.empty_state_def simple_state_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ei, e) \\<in> ES \\<Longrightarrow>\n    RETURN\n     \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n        \\<dots> = ei\\<rparr>\n    \\<le> \\<Down>\n           {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES}\n           (RETURN\n             \\<lparr>counter = 0, discovered = Map.empty,\n                finished = Map.empty, pending = {}, stack = [],\n                tree_edges = {}, back_edges = {}, cross_edges = {},\n                \\<dots> = e\\<rparr>)", "by (auto)"], ["", "lemma new_root_impl: \n    \"\\<lbrakk>a.gen_dfs.pre_new_root v0 s; \n      (v0i, v0)\\<in>Id; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n      \\<Longrightarrow> c.new_root_impl v0 si \\<le>\\<Down>(\\<langle>ES\\<rangle>simple_state_rel) (RETURN (a.new_root v0 s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a.gen_dfs.pre_new_root v0 s; (v0i, v0) \\<in> Id;\n     (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n    \\<Longrightarrow> c.new_root_impl v0 si\n                      \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n                             (RETURN (a.new_root v0 s))", "unfolding simple_state_rel_def a.gen_dfs.pre_new_root_def c.new_root_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a.gen_dfs.gen_rwof s \\<and>\n             gds_is_empty_stack a.gen_dfs.gds s \\<and>\n             \\<not> gds_is_break a.gen_dfs.gds s \\<and>\n             v0 \\<in> a.V0 - a.gen_dfs.gen_discovered s;\n     (v0i, v0) \\<in> Id;\n     (si, s)\n     \\<in> {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES}\\<rbrakk>\n    \\<Longrightarrow> ASSERT (v0 \\<notin> visited si) \\<bind>\n                      (\\<lambda>_.\n                          let s = si\n                                \\<lparr>ss_stack :=\n    [(v0, a.E `` {v0})]\\<rparr>;\n                              s = s\\<lparr>on_stack := {v0}\\<rparr>\n                          in Let (s\\<lparr>visited :=\n       insert v0 (visited s)\\<rparr>)\n                              RETURN)\n                      \\<le> \\<Down>\n                             {(s, s').\n                              ss_stack s =\n                              map (\\<lambda>u. (u, pending s' `` {u}))\n                               (stack s') \\<and>\n                              on_stack s = set (stack s') \\<and>\n                              visited s = dom (discovered s') \\<and>\n                              dom (finished s') =\n                              dom (discovered s') - set (stack s') \\<and>\n                              set (stack s')\n                              \\<subseteq> dom (discovered s') \\<and>\n                              (simple_state.more s, state.more s') \\<in> ES}\n                             (RETURN (a.new_root v0 s))", "by (auto simp add: a.pred_defs)"], ["", "lemma get_pending_impl: \"\n    \\<lbrakk>a.gen_dfs.pre_get_pending s; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n      \\<Longrightarrow> c.get_pending_impl si \n          \\<le> \\<Down> (Id \\<times>\\<^sub>r Id \\<times>\\<^sub>r \\<langle>ES\\<rangle>simple_state_rel) (a.get_pending s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a.gen_dfs.pre_get_pending s;\n     (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n    \\<Longrightarrow> c.get_pending_impl si\n                      \\<le> \\<Down>\n                             (Id \\<times>\\<^sub>r\n                              Id \\<times>\\<^sub>r\n                              \\<langle>ES\\<rangle>simple_state_rel)\n                             (a.get_pending s)", "apply (unfold a.get_pending_def c.get_pending_impl_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a.gen_dfs.pre_get_pending s;\n     (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n    \\<Longrightarrow> ASSERT (ss_stack si \\<noteq> []) \\<bind>\n                      (\\<lambda>_.\n                          let (u, Vs) = hd (ss_stack si)\n                          in if Vs = {} then RETURN (u, None, si)\n                             else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                                  (\\<lambda>v.\nlet Vs = Vs - {v};\n    s = si\\<lparr>ss_stack := (u, Vs) # tl (ss_stack si)\\<rparr>\nin RETURN (u, Some v, s)))\n                      \\<le> \\<Down>\n                             (Id \\<times>\\<^sub>r\n                              Id \\<times>\\<^sub>r\n                              \\<langle>ES\\<rangle>simple_state_rel)\n                             (let u = hd (stack s); Vs = pending s `` {u}\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else RES Vs \\<bind>\n(\\<lambda>v.\n    let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n    in RETURN (u, Some v, s)))", "apply (refine_rcg bind_refine' Let_refine' IdI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>a.gen_dfs.pre_get_pending s;\n     (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n    \\<Longrightarrow> ss_stack si \\<noteq> []\n 2. \\<lbrakk>a.gen_dfs.pre_get_pending s;\n     (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n     ss_stack si \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (hd (ss_stack si), hd (stack s)) \\<in> ?R3\n 3. \\<And>x1 x2.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n        ss_stack si \\<noteq> []; (hd (ss_stack si), hd (stack s)) \\<in> ?R3;\n        hd (ss_stack si) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> (x2 = {}) = (pending s `` {hd (stack s)} = {})\n 4. \\<And>x1 x2.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n        ss_stack si \\<noteq> []; (hd (ss_stack si), hd (stack s)) \\<in> ?R3;\n        hd (ss_stack si) = (x1, x2); x2 = {};\n        pending s `` {hd (stack s)} = {}\\<rbrakk>\n       \\<Longrightarrow> ((x1, None, si), hd (stack s), None, s)\n                         \\<in> Id \\<times>\\<^sub>r\n                               Id \\<times>\\<^sub>r\n                               \\<langle>ES\\<rangle>simple_state_rel\n 5. \\<And>x1 x2.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n        ss_stack si \\<noteq> []; (hd (ss_stack si), hd (stack s)) \\<in> ?R3;\n        hd (ss_stack si) = (x1, x2); x2 \\<noteq> {};\n        pending s `` {hd (stack s)} \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>v. v \\<in> x2)\n                         \\<le> \\<Down> (?R'14 x1 x2)\n                                (RES (pending s `` {hd (stack s)}))\n 6. \\<And>x1 x2 v va.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n        ss_stack si \\<noteq> []; (hd (ss_stack si), hd (stack s)) \\<in> ?R3;\n        hd (ss_stack si) = (x1, x2); x2 \\<noteq> {};\n        pending s `` {hd (stack s)} \\<noteq> {}; (v, va) \\<in> ?R'14 x1 x2;\n        inres (SPEC (\\<lambda>v. v \\<in> x2)) v;\n        inres (RES (pending s `` {hd (stack s)})) va;\n        nofail (SPEC (\\<lambda>v. v \\<in> x2));\n        nofail (RES (pending s `` {hd (stack s)}))\\<rbrakk>\n       \\<Longrightarrow> (x2 - {v}, s\n                          \\<lparr>pending :=\n                                    pending s -\n                                    {(hd (stack s), va)}\\<rparr>)\n                         \\<in> ?R15 x1 x2 v va\n 7. \\<And>x1 x2 v va.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n        ss_stack si \\<noteq> []; (hd (ss_stack si), hd (stack s)) \\<in> ?R3;\n        hd (ss_stack si) = (x1, x2); x2 \\<noteq> {};\n        pending s `` {hd (stack s)} \\<noteq> {}; (v, va) \\<in> ?R'14 x1 x2;\n        inres (SPEC (\\<lambda>v. v \\<in> x2)) v;\n        inres (RES (pending s `` {hd (stack s)})) va;\n        nofail (SPEC (\\<lambda>v. v \\<in> x2));\n        nofail (RES (pending s `` {hd (stack s)}));\n        (x2 - {v}, s\n         \\<lparr>pending := pending s - {(hd (stack s), va)}\\<rparr>)\n        \\<in> ?R15 x1 x2 v va\\<rbrakk>\n       \\<Longrightarrow> (let s = si\n                                \\<lparr>ss_stack :=\n    (x1, x2 - {v}) # tl (ss_stack si)\\<rparr>\n                          in RETURN (x1, Some v, s))\n                         \\<le> SPEC\n                                (\\<lambda>c.\n                                    (c, hd (stack s), Some va, s\n                                     \\<lparr>pending :=\n         pending s - {(hd (stack s), va)}\\<rparr>)\n                                    \\<in> Id \\<times>\\<^sub>r\n    Id \\<times>\\<^sub>r \\<langle>ES\\<rangle>simple_state_rel)", "apply (refine_dref_type)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>a.gen_dfs.pre_get_pending s;\n     (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n    \\<Longrightarrow> ss_stack si \\<noteq> []\n 2. \\<lbrakk>a.gen_dfs.pre_get_pending s;\n     (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n     ss_stack si \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (hd (ss_stack si), hd (stack s)) \\<in> ?R3\n 3. \\<And>x1 x2.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n        ss_stack si \\<noteq> []; (hd (ss_stack si), hd (stack s)) \\<in> ?R3;\n        hd (ss_stack si) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> (x2 = {}) = (pending s `` {hd (stack s)} = {})\n 4. \\<And>x1 x2.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n        ss_stack si \\<noteq> []; (hd (ss_stack si), hd (stack s)) \\<in> ?R3;\n        hd (ss_stack si) = (x1, x2); x2 = {};\n        pending s `` {hd (stack s)} = {}\\<rbrakk>\n       \\<Longrightarrow> ((x1, None, si), hd (stack s), None, s)\n                         \\<in> Id \\<times>\\<^sub>r\n                               Id \\<times>\\<^sub>r\n                               \\<langle>ES\\<rangle>simple_state_rel\n 5. \\<And>x1 x2.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n        ss_stack si \\<noteq> []; (hd (ss_stack si), hd (stack s)) \\<in> ?R3;\n        hd (ss_stack si) = (x1, x2); x2 \\<noteq> {};\n        pending s `` {hd (stack s)} \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>v. v \\<in> x2)\n                         \\<le> \\<Down> Id\n                                (RES (pending s `` {hd (stack s)}))\n 6. \\<And>x1 x2 v va.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n        ss_stack si \\<noteq> []; (hd (ss_stack si), hd (stack s)) \\<in> ?R3;\n        hd (ss_stack si) = (x1, x2); x2 \\<noteq> {};\n        pending s `` {hd (stack s)} \\<noteq> {}; (v, va) \\<in> Id;\n        inres (SPEC (\\<lambda>v. v \\<in> x2)) v;\n        inres (RES (pending s `` {hd (stack s)})) va;\n        nofail (SPEC (\\<lambda>v. v \\<in> x2));\n        nofail (RES (pending s `` {hd (stack s)}))\\<rbrakk>\n       \\<Longrightarrow> (x2 - {v}, s\n                          \\<lparr>pending :=\n                                    pending s -\n                                    {(hd (stack s), va)}\\<rparr>)\n                         \\<in> ?R15 x1 x2 v va\n 7. \\<And>x1 x2 v va.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel;\n        ss_stack si \\<noteq> []; (hd (ss_stack si), hd (stack s)) \\<in> ?R3;\n        hd (ss_stack si) = (x1, x2); x2 \\<noteq> {};\n        pending s `` {hd (stack s)} \\<noteq> {}; (v, va) \\<in> Id;\n        inres (SPEC (\\<lambda>v. v \\<in> x2)) v;\n        inres (RES (pending s `` {hd (stack s)})) va;\n        nofail (SPEC (\\<lambda>v. v \\<in> x2));\n        nofail (RES (pending s `` {hd (stack s)}));\n        (x2 - {v}, s\n         \\<lparr>pending := pending s - {(hd (stack s), va)}\\<rparr>)\n        \\<in> ?R15 x1 x2 v va\\<rbrakk>\n       \\<Longrightarrow> (let s = si\n                                \\<lparr>ss_stack :=\n    (x1, x2 - {v}) # tl (ss_stack si)\\<rparr>\n                          in RETURN (x1, Some v, s))\n                         \\<le> SPEC\n                                (\\<lambda>c.\n                                    (c, hd (stack s), Some va, s\n                                     \\<lparr>pending :=\n         pending s - {(hd (stack s), va)}\\<rparr>)\n                                    \\<in> Id \\<times>\\<^sub>r\n    Id \\<times>\\<^sub>r \\<langle>ES\\<rangle>simple_state_rel)", "apply (auto \n        simp: simple_state_rel_def a.gen_dfs.pre_defs a.pred_defs neq_Nil_conv\n        dest: DFS_invar.stack_distinct\n      )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inres_get_pending_None_conv: \"inres (a.get_pending s0) (v, None, s) \n      \\<longleftrightarrow> s=s0 \\<and> v=hd (stack s0) \\<and> pending s0``{hd (stack s0)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (a.get_pending s0) (v, None, s) =\n    (s = s0 \\<and>\n     v = hd (stack s0) \\<and> pending s0 `` {hd (stack s0)} = {})", "unfolding a.get_pending_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inres\n     (let u = hd (stack s0); Vs = pending s0 `` {u}\n      in if Vs = {} then RETURN (u, None, s0)\n         else RES Vs \\<bind>\n              (\\<lambda>v.\n                  let s = s0\\<lparr>pending := pending s0 - {(u, v)}\\<rparr>\n                  in RETURN (u, Some v, s)))\n     (v, None, s) =\n    (s = s0 \\<and>\n     v = hd (stack s0) \\<and> pending s0 `` {hd (stack s0)} = {})", "by (auto simp add: refine_pw_simps)"], ["", "lemma inres_get_pending_Some_conv: \"inres (a.get_pending s0) (v,Some Vs,s) \n      \\<longleftrightarrow> v = hd (stack s) \\<and> s = s0\\<lparr>pending := pending s0 - {(hd (stack s0), Vs)}\\<rparr>\n       \\<and> (hd (stack s0), Vs) \\<in> pending s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (a.get_pending s0) (v, Some Vs, s) =\n    (v = hd (stack s) \\<and>\n     s = s0\n     \\<lparr>pending := pending s0 - {(hd (stack s0), Vs)}\\<rparr> \\<and>\n     (hd (stack s0), Vs) \\<in> pending s0)", "unfolding a.get_pending_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inres\n     (let u = hd (stack s0); Vs = pending s0 `` {u}\n      in if Vs = {} then RETURN (u, None, s0)\n         else RES Vs \\<bind>\n              (\\<lambda>v.\n                  let s = s0\\<lparr>pending := pending s0 - {(u, v)}\\<rparr>\n                  in RETURN (u, Some v, s)))\n     (v, Some Vs, s) =\n    (v = hd (stack s) \\<and>\n     s = s0\n     \\<lparr>pending := pending s0 - {(hd (stack s0), Vs)}\\<rparr> \\<and>\n     (hd (stack s0), Vs) \\<in> pending s0)", "by (auto simp add: refine_pw_simps)"], ["", "lemma finish_impl:\n    \"\\<lbrakk>a.gen_dfs.pre_finish v s0 s; (vi, v)\\<in>Id; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n     \\<Longrightarrow> c.finish_impl v si \\<le>\\<Down>(\\<langle>ES\\<rangle>simple_state_rel) (RETURN (a.finish v s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a.gen_dfs.pre_finish v s0 s; (vi, v) \\<in> Id;\n     (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n    \\<Longrightarrow> c.finish_impl v si\n                      \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n                             (RETURN (a.finish v s))", "unfolding simple_state_rel_def a.gen_dfs.pre_defs c.finish_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a.gen_dfs.gen_rwof s0 \\<and>\n              \\<not> gds_is_empty_stack a.gen_dfs.gds s0 \\<and>\n              \\<not> gds_is_break a.gen_dfs.gds s0) \\<and>\n             inres (gds_get_pending a.gen_dfs.gds s0) (v, None, s);\n     (vi, v) \\<in> Id;\n     (si, s)\n     \\<in> {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES}\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (ss_stack si \\<noteq> [] \\<and>\n                        v \\<in> on_stack si) \\<bind>\n                      (\\<lambda>_.\n                          let s = si\n                                \\<lparr>ss_stack := tl (ss_stack si)\\<rparr>\n                          in Let (s\\<lparr>on_stack :=\n       on_stack s - {v}\\<rparr>)\n                              RETURN)\n                      \\<le> \\<Down>\n                             {(s, s').\n                              ss_stack s =\n                              map (\\<lambda>u. (u, pending s' `` {u}))\n                               (stack s') \\<and>\n                              on_stack s = set (stack s') \\<and>\n                              visited s = dom (discovered s') \\<and>\n                              dom (finished s') =\n                              dom (discovered s') - set (stack s') \\<and>\n                              set (stack s')\n                              \\<subseteq> dom (discovered s') \\<and>\n                              (simple_state.more s, state.more s') \\<in> ES}\n                             (RETURN (a.finish v s))", "(* Proof is fine-tuned to optimize speed *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a.gen_dfs.gen_rwof s0 \\<and>\n              \\<not> gds_is_empty_stack a.gen_dfs.gds s0 \\<and>\n              \\<not> gds_is_break a.gen_dfs.gds s0) \\<and>\n             inres (gds_get_pending a.gen_dfs.gds s0) (v, None, s);\n     (vi, v) \\<in> Id;\n     (si, s)\n     \\<in> {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES}\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (ss_stack si \\<noteq> [] \\<and>\n                        v \\<in> on_stack si) \\<bind>\n                      (\\<lambda>_.\n                          let s = si\n                                \\<lparr>ss_stack := tl (ss_stack si)\\<rparr>\n                          in Let (s\\<lparr>on_stack :=\n       on_stack s - {v}\\<rparr>)\n                              RETURN)\n                      \\<le> \\<Down>\n                             {(s, s').\n                              ss_stack s =\n                              map (\\<lambda>u. (u, pending s' `` {u}))\n                               (stack s') \\<and>\n                              on_stack s = set (stack s') \\<and>\n                              visited s = dom (discovered s') \\<and>\n                              dom (finished s') =\n                              dom (discovered s') - set (stack s') \\<and>\n                              set (stack s')\n                              \\<subseteq> dom (discovered s') \\<and>\n                              (simple_state.more s, state.more s') \\<in> ES}\n                             (RETURN (a.finish v s))", "apply (clarsimp simp: inres_get_pending_None_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vi = hd (stack s0); DFS_invar G param s0;\n     ss_stack si = map (\\<lambda>u. (u, pending s0 `` {u})) (stack s0);\n     \\<not> a.is_empty_stack s0; on_stack si = set (stack s0);\n     \\<not> is_break param s0; visited si = dom (discovered s0); s = s0;\n     dom (finished s0) = dom (discovered s0) - set (stack s0);\n     v = hd (stack s0); pending s0 `` {hd (stack s0)} = {};\n     set (stack s0) \\<subseteq> dom (discovered s0);\n     (simple_state.more si, state.more s0) \\<in> ES\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (stack s0 \\<noteq> [] \\<and>\n                        hd (stack s0) \\<in> set (stack s0)) \\<bind>\n                      (\\<lambda>_.\n                          RETURN\n                           (si\\<lparr>ss_stack :=\n  tl (map (\\<lambda>u. (u, pending s0 `` {u})) (stack s0)),\n                                 on_stack :=\n                                   set (stack s0) -\n                                   {hd (stack s0)}\\<rparr>))\n                      \\<le> \\<Down>\n                             {(s, s').\n                              ss_stack s =\n                              map (\\<lambda>u. (u, pending s' `` {u}))\n                               (stack s') \\<and>\n                              on_stack s = set (stack s') \\<and>\n                              visited s = dom (discovered s') \\<and>\n                              dom (finished s') =\n                              dom (discovered s') - set (stack s') \\<and>\n                              set (stack s')\n                              \\<subseteq> dom (discovered s') \\<and>\n                              (simple_state.more s, state.more s') \\<in> ES}\n                             (RETURN (a.finish (hd (stack s0)) s0))", "apply (frule DFS_invar.stack_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vi = hd (stack s0); DFS_invar G param s0;\n     ss_stack si = map (\\<lambda>u. (u, pending s0 `` {u})) (stack s0);\n     \\<not> a.is_empty_stack s0; on_stack si = set (stack s0);\n     \\<not> is_break param s0; visited si = dom (discovered s0); s = s0;\n     dom (finished s0) = dom (discovered s0) - set (stack s0);\n     v = hd (stack s0); pending s0 `` {hd (stack s0)} = {};\n     set (stack s0) \\<subseteq> dom (discovered s0);\n     (simple_state.more si, state.more s0) \\<in> ES;\n     distinct (stack s0)\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (stack s0 \\<noteq> [] \\<and>\n                        hd (stack s0) \\<in> set (stack s0)) \\<bind>\n                      (\\<lambda>_.\n                          RETURN\n                           (si\\<lparr>ss_stack :=\n  tl (map (\\<lambda>u. (u, pending s0 `` {u})) (stack s0)),\n                                 on_stack :=\n                                   set (stack s0) -\n                                   {hd (stack s0)}\\<rparr>))\n                      \\<le> \\<Down>\n                             {(s, s').\n                              ss_stack s =\n                              map (\\<lambda>u. (u, pending s' `` {u}))\n                               (stack s') \\<and>\n                              on_stack s = set (stack s') \\<and>\n                              visited s = dom (discovered s') \\<and>\n                              dom (finished s') =\n                              dom (discovered s') - set (stack s') \\<and>\n                              set (stack s')\n                              \\<subseteq> dom (discovered s') \\<and>\n                              (simple_state.more s, state.more s') \\<in> ES}\n                             (RETURN (a.finish (hd (stack s0)) s0))", "apply (simp add: a.pred_defs map_tl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vi = hd (stack s0); DFS_invar G param s0;\n     ss_stack si = map (\\<lambda>u. (u, pending s0 `` {u})) (stack s0);\n     stack s0 \\<noteq> []; on_stack si = set (stack s0);\n     \\<not> is_break param s0; visited si = dom (discovered s0); s = s0;\n     dom (finished s0) = dom (discovered s0) - set (stack s0);\n     v = hd (stack s0); pending s0 `` {hd (stack s0)} = {};\n     set (stack s0) \\<subseteq> dom (discovered s0);\n     (simple_state.more si, state.more s0) \\<in> ES;\n     distinct (stack s0)\\<rbrakk>\n    \\<Longrightarrow> set (stack s0) - {hd (stack s0)} =\n                      set (tl (stack s0)) \\<and>\n                      insert (hd (stack s0))\n                       (dom (discovered s0) - set (stack s0)) =\n                      dom (discovered s0) - set (tl (stack s0)) \\<and>\n                      set (tl (stack s0)) \\<subseteq> dom (discovered s0)", "apply (clarsimp simp: neq_Nil_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys ya.\n       \\<lbrakk>DFS_invar G param s0;\n        ss_stack si =\n        (vi, {}) # map (\\<lambda>u. (u, pending s0 `` {u})) ys;\n        on_stack si = insert vi (set ys); \\<not> is_break param s0;\n        visited si = dom (discovered s0); s = s0;\n        dom (finished s0) = dom (discovered s0) - insert vi (set ys);\n        v = vi; pending s0 `` {vi} = {};\n        (simple_state.more si, state.more s0) \\<in> ES; stack s0 = vi # ys;\n        set ys \\<subseteq> dom (discovered s0); discovered s0 vi = Some ya;\n        vi \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> insert vi\n                          (dom (discovered s0) - insert vi (set ys)) =\n                         dom (discovered s0) - set ys", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cross_edge_impl: \"\n    \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; \n      (ui, u)\\<in>Id; (vi, v)\\<in>Id; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n      \\<Longrightarrow> (si, a.cross_edge u v s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; (ui, u) \\<in> Id;\n     (vi, v) \\<in> Id;\n     (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n    \\<Longrightarrow> (si, a.cross_edge u v s)\n                      \\<in> \\<langle>ES\\<rangle>simple_state_rel", "unfolding simple_state_rel_def a.gen_dfs.pre_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((a.gen_dfs.gen_rwof s0 \\<and>\n               \\<not> gds_is_empty_stack a.gen_dfs.gds s0 \\<and>\n               \\<not> gds_is_break a.gen_dfs.gds s0) \\<and>\n              inres (gds_get_pending a.gen_dfs.gds s0)\n               (u, Some v, s)) \\<and>\n             gds_is_discovered a.gen_dfs.gds v s \\<and>\n             gds_is_finished a.gen_dfs.gds v s;\n     (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s)\n     \\<in> {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES}\\<rbrakk>\n    \\<Longrightarrow> (si, a.cross_edge u v s)\n                      \\<in> {(s, s').\n                             ss_stack s =\n                             map (\\<lambda>u. (u, pending s' `` {u}))\n                              (stack s') \\<and>\n                             on_stack s = set (stack s') \\<and>\n                             visited s = dom (discovered s') \\<and>\n                             dom (finished s') =\n                             dom (discovered s') - set (stack s') \\<and>\n                             set (stack s')\n                             \\<subseteq> dom (discovered s') \\<and>\n                             (simple_state.more s, state.more s') \\<in> ES}", "by simp"], ["", "lemma back_edge_impl: \"\n    \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; \n      (ui, u)\\<in>Id; (vi, v)\\<in>Id; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n      \\<Longrightarrow> (si, a.back_edge u v s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; (ui, u) \\<in> Id;\n     (vi, v) \\<in> Id;\n     (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n    \\<Longrightarrow> (si, a.back_edge u v s)\n                      \\<in> \\<langle>ES\\<rangle>simple_state_rel", "unfolding simple_state_rel_def a.gen_dfs.pre_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((a.gen_dfs.gen_rwof s0 \\<and>\n               \\<not> gds_is_empty_stack a.gen_dfs.gds s0 \\<and>\n               \\<not> gds_is_break a.gen_dfs.gds s0) \\<and>\n              inres (gds_get_pending a.gen_dfs.gds s0)\n               (u, Some v, s)) \\<and>\n             gds_is_discovered a.gen_dfs.gds v s \\<and>\n             \\<not> gds_is_finished a.gen_dfs.gds v s;\n     (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s)\n     \\<in> {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES}\\<rbrakk>\n    \\<Longrightarrow> (si, a.back_edge u v s)\n                      \\<in> {(s, s').\n                             ss_stack s =\n                             map (\\<lambda>u. (u, pending s' `` {u}))\n                              (stack s') \\<and>\n                             on_stack s = set (stack s') \\<and>\n                             visited s = dom (discovered s') \\<and>\n                             dom (finished s') =\n                             dom (discovered s') - set (stack s') \\<and>\n                             set (stack s')\n                             \\<subseteq> dom (discovered s') \\<and>\n                             (simple_state.more s, state.more s') \\<in> ES}", "by simp"], ["", "lemma discover_impl:\n    \"\\<lbrakk>a.gen_dfs.pre_discover u v s0 s; (ui, u)\\<in>Id; (vi, v)\\<in>Id; (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n     \\<Longrightarrow> c.discover_impl ui vi si \\<le>\\<Down>(\\<langle>ES\\<rangle>simple_state_rel) (RETURN (a.discover u v s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; (ui, u) \\<in> Id;\n     (vi, v) \\<in> Id;\n     (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n    \\<Longrightarrow> c.discover_impl ui vi si\n                      \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n                             (RETURN (a.discover u v s))", "unfolding simple_state_rel_def a.gen_dfs.pre_defs c.discover_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((a.gen_dfs.gen_rwof s0 \\<and>\n               \\<not> gds_is_empty_stack a.gen_dfs.gds s0 \\<and>\n               \\<not> gds_is_break a.gen_dfs.gds s0) \\<and>\n              inres (gds_get_pending a.gen_dfs.gds s0)\n               (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered a.gen_dfs.gds v s;\n     (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s)\n     \\<in> {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES}\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (vi \\<notin> on_stack si \\<and>\n                        vi \\<notin> visited si) \\<bind>\n                      (\\<lambda>_.\n                          let s = si\n                                \\<lparr>ss_stack :=\n    (vi, a.E `` {vi}) # ss_stack si\\<rparr>;\n                              s = s\\<lparr>on_stack :=\n       insert vi (on_stack s)\\<rparr>\n                          in Let (s\\<lparr>visited :=\n       insert vi (visited s)\\<rparr>)\n                              RETURN)\n                      \\<le> \\<Down>\n                             {(s, s').\n                              ss_stack s =\n                              map (\\<lambda>u. (u, pending s' `` {u}))\n                               (stack s') \\<and>\n                              on_stack s = set (stack s') \\<and>\n                              visited s = dom (discovered s') \\<and>\n                              dom (finished s') =\n                              dom (discovered s') - set (stack s') \\<and>\n                              set (stack s')\n                              \\<subseteq> dom (discovered s') \\<and>\n                              (simple_state.more s, state.more s') \\<in> ES}\n                             (RETURN (a.discover u v s))", "apply (rule ASSERT_leI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>((a.gen_dfs.gen_rwof s0 \\<and>\n               \\<not> gds_is_empty_stack a.gen_dfs.gds s0 \\<and>\n               \\<not> gds_is_break a.gen_dfs.gds s0) \\<and>\n              inres (gds_get_pending a.gen_dfs.gds s0)\n               (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered a.gen_dfs.gds v s;\n     (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s)\n     \\<in> {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES}\\<rbrakk>\n    \\<Longrightarrow> vi \\<notin> on_stack si \\<and> vi \\<notin> visited si\n 2. \\<lbrakk>((a.gen_dfs.gen_rwof s0 \\<and>\n               \\<not> gds_is_empty_stack a.gen_dfs.gds s0 \\<and>\n               \\<not> gds_is_break a.gen_dfs.gds s0) \\<and>\n              inres (gds_get_pending a.gen_dfs.gds s0)\n               (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered a.gen_dfs.gds v s;\n     (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s)\n     \\<in> {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES};\n     vi \\<notin> on_stack si \\<and> vi \\<notin> visited si\\<rbrakk>\n    \\<Longrightarrow> (let s = si\n                             \\<lparr>ss_stack :=\n (vi, a.E `` {vi}) # ss_stack si\\<rparr>;\n                           s = s\\<lparr>on_stack :=\n    insert vi (on_stack s)\\<rparr>\n                       in Let (s\\<lparr>visited :=\n    insert vi (visited s)\\<rparr>)\n                           RETURN)\n                      \\<le> \\<Down>\n                             {(s, s').\n                              ss_stack s =\n                              map (\\<lambda>u. (u, pending s' `` {u}))\n                               (stack s') \\<and>\n                              on_stack s = set (stack s') \\<and>\n                              visited s = dom (discovered s') \\<and>\n                              dom (finished s') =\n                              dom (discovered s') - set (stack s') \\<and>\n                              set (stack s')\n                              \\<subseteq> dom (discovered s') \\<and>\n                              (simple_state.more s, state.more s') \\<in> ES}\n                             (RETURN (a.discover u v s))", "apply (clarsimp simp: inres_get_pending_Some_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ui = hd (stack s0); vi = v; DFS_invar G param s0;\n     ss_stack si =\n     map (\\<lambda>u. (u, (pending s0 - {(hd (stack s0), v)}) `` {u}))\n      (stack s0);\n     \\<not> a.is_empty_stack s0; on_stack si = set (stack s0);\n     \\<not> is_break param s0; visited si = dom (discovered s0);\n     u = hd (stack s0);\n     dom (finished s0) = dom (discovered s0) - set (stack s0);\n     s = s0\\<lparr>pending := pending s0 - {(hd (stack s0), v)}\\<rparr>;\n     set (stack s0) \\<subseteq> dom (discovered s0);\n     (simple_state.more si, state.more s0) \\<in> ES;\n     (hd (stack s0), v) \\<in> pending s0;\n     \\<not> a.is_discovered v\n             (s0\\<lparr>pending :=\n                          pending s0 -\n                          {(hd (stack s0), v)}\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> v \\<notin> set (stack s0) \\<and>\n                      v \\<notin> dom (discovered s0)\n 2. \\<lbrakk>((a.gen_dfs.gen_rwof s0 \\<and>\n               \\<not> gds_is_empty_stack a.gen_dfs.gds s0 \\<and>\n               \\<not> gds_is_break a.gen_dfs.gds s0) \\<and>\n              inres (gds_get_pending a.gen_dfs.gds s0)\n               (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered a.gen_dfs.gds v s;\n     (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s)\n     \\<in> {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES};\n     vi \\<notin> on_stack si \\<and> vi \\<notin> visited si\\<rbrakk>\n    \\<Longrightarrow> (let s = si\n                             \\<lparr>ss_stack :=\n (vi, a.E `` {vi}) # ss_stack si\\<rparr>;\n                           s = s\\<lparr>on_stack :=\n    insert vi (on_stack s)\\<rparr>\n                       in Let (s\\<lparr>visited :=\n    insert vi (visited s)\\<rparr>)\n                           RETURN)\n                      \\<le> \\<Down>\n                             {(s, s').\n                              ss_stack s =\n                              map (\\<lambda>u. (u, pending s' `` {u}))\n                               (stack s') \\<and>\n                              on_stack s = set (stack s') \\<and>\n                              visited s = dom (discovered s') \\<and>\n                              dom (finished s') =\n                              dom (discovered s') - set (stack s') \\<and>\n                              set (stack s')\n                              \\<subseteq> dom (discovered s') \\<and>\n                              (simple_state.more s, state.more s') \\<in> ES}\n                             (RETURN (a.discover u v s))", "apply (frule DFS_invar.stack_discovered)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ui = hd (stack s0); vi = v; DFS_invar G param s0;\n     ss_stack si =\n     map (\\<lambda>u. (u, (pending s0 - {(hd (stack s0), v)}) `` {u}))\n      (stack s0);\n     \\<not> a.is_empty_stack s0; on_stack si = set (stack s0);\n     \\<not> is_break param s0; visited si = dom (discovered s0);\n     u = hd (stack s0);\n     dom (finished s0) = dom (discovered s0) - set (stack s0);\n     s = s0\\<lparr>pending := pending s0 - {(hd (stack s0), v)}\\<rparr>;\n     set (stack s0) \\<subseteq> dom (discovered s0);\n     (simple_state.more si, state.more s0) \\<in> ES;\n     (hd (stack s0), v) \\<in> pending s0;\n     \\<not> a.is_discovered v\n             (s0\\<lparr>pending :=\n                          pending s0 - {(hd (stack s0), v)}\\<rparr>);\n     set (stack s0) \\<subseteq> dom (discovered s0)\\<rbrakk>\n    \\<Longrightarrow> v \\<notin> set (stack s0) \\<and>\n                      v \\<notin> dom (discovered s0)\n 2. \\<lbrakk>((a.gen_dfs.gen_rwof s0 \\<and>\n               \\<not> gds_is_empty_stack a.gen_dfs.gds s0 \\<and>\n               \\<not> gds_is_break a.gen_dfs.gds s0) \\<and>\n              inres (gds_get_pending a.gen_dfs.gds s0)\n               (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered a.gen_dfs.gds v s;\n     (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s)\n     \\<in> {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES};\n     vi \\<notin> on_stack si \\<and> vi \\<notin> visited si\\<rbrakk>\n    \\<Longrightarrow> (let s = si\n                             \\<lparr>ss_stack :=\n (vi, a.E `` {vi}) # ss_stack si\\<rparr>;\n                           s = s\\<lparr>on_stack :=\n    insert vi (on_stack s)\\<rparr>\n                       in Let (s\\<lparr>visited :=\n    insert vi (visited s)\\<rparr>)\n                           RETURN)\n                      \\<le> \\<Down>\n                             {(s, s').\n                              ss_stack s =\n                              map (\\<lambda>u. (u, pending s' `` {u}))\n                               (stack s') \\<and>\n                              on_stack s = set (stack s') \\<and>\n                              visited s = dom (discovered s') \\<and>\n                              dom (finished s') =\n                              dom (discovered s') - set (stack s') \\<and>\n                              set (stack s')\n                              \\<subseteq> dom (discovered s') \\<and>\n                              (simple_state.more s, state.more s') \\<in> ES}\n                             (RETURN (a.discover u v s))", "apply (auto simp: a.pred_defs) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((a.gen_dfs.gen_rwof s0 \\<and>\n               \\<not> gds_is_empty_stack a.gen_dfs.gds s0 \\<and>\n               \\<not> gds_is_break a.gen_dfs.gds s0) \\<and>\n              inres (gds_get_pending a.gen_dfs.gds s0)\n               (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered a.gen_dfs.gds v s;\n     (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n     (si, s)\n     \\<in> {(s, s').\n            ss_stack s =\n            map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n            on_stack s = set (stack s') \\<and>\n            visited s = dom (discovered s') \\<and>\n            dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n            set (stack s') \\<subseteq> dom (discovered s') \\<and>\n            (simple_state.more s, state.more s') \\<in> ES};\n     vi \\<notin> on_stack si \\<and> vi \\<notin> visited si\\<rbrakk>\n    \\<Longrightarrow> (let s = si\n                             \\<lparr>ss_stack :=\n (vi, a.E `` {vi}) # ss_stack si\\<rparr>;\n                           s = s\\<lparr>on_stack :=\n    insert vi (on_stack s)\\<rparr>\n                       in Let (s\\<lparr>visited :=\n    insert vi (visited s)\\<rparr>)\n                           RETURN)\n                      \\<le> \\<Down>\n                             {(s, s').\n                              ss_stack s =\n                              map (\\<lambda>u. (u, pending s' `` {u}))\n                               (stack s') \\<and>\n                              on_stack s = set (stack s') \\<and>\n                              visited s = dom (discovered s') \\<and>\n                              dom (finished s') =\n                              dom (discovered s') - set (stack s') \\<and>\n                              set (stack s')\n                              \\<subseteq> dom (discovered s') \\<and>\n                              (simple_state.more s, state.more s') \\<in> ES}\n                             (RETURN (a.discover u v s))", "apply (clarsimp simp: inres_get_pending_Some_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ui = hd (stack s0); vi = v; DFS_invar G param s0;\n     ss_stack si =\n     map (\\<lambda>u. (u, (pending s0 - {(hd (stack s0), v)}) `` {u}))\n      (stack s0);\n     v \\<notin> set (stack s0);\n     a.E `` {v} =\n     (pending s0 - {(hd (stack s0), v)} \\<union> {v} \\<times> a.E `` {v}) ``\n     {v} \\<longrightarrow>\n     (\\<exists>x\\<in>set (stack s0).\n         (pending s0 - {(hd (stack s0), v)}) `` {x} \\<noteq>\n         (pending s0 - {(hd (stack s0), v)} \\<union>\n          {v} \\<times> a.E `` {v}) ``\n         {x}) \\<or>\n     \\<not> set (stack s0) \\<subseteq> insert v (dom (discovered s0));\n     \\<not> a.is_empty_stack s0; on_stack si = set (stack s0);\n     \\<not> is_break param s0; visited si = dom (discovered s0);\n     u = hd (stack s0);\n     dom (finished s0) = dom (discovered s0) - set (stack s0);\n     s = s0\\<lparr>pending := pending s0 - {(hd (stack s0), v)}\\<rparr>;\n     set (stack s0) \\<subseteq> dom (discovered s0);\n     (simple_state.more si, state.more s0) \\<in> ES;\n     (hd (stack s0), v) \\<in> pending s0;\n     \\<not> a.is_discovered v\n             (s0\\<lparr>pending :=\n                          pending s0 -\n                          {(hd (stack s0), v)}\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. discovered s0 v = Some y", "apply (frule DFS_invar.stack_discovered)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ui = hd (stack s0); vi = v; DFS_invar G param s0;\n     ss_stack si =\n     map (\\<lambda>u. (u, (pending s0 - {(hd (stack s0), v)}) `` {u}))\n      (stack s0);\n     v \\<notin> set (stack s0);\n     a.E `` {v} =\n     (pending s0 - {(hd (stack s0), v)} \\<union> {v} \\<times> a.E `` {v}) ``\n     {v} \\<longrightarrow>\n     (\\<exists>x\\<in>set (stack s0).\n         (pending s0 - {(hd (stack s0), v)}) `` {x} \\<noteq>\n         (pending s0 - {(hd (stack s0), v)} \\<union>\n          {v} \\<times> a.E `` {v}) ``\n         {x}) \\<or>\n     \\<not> set (stack s0) \\<subseteq> insert v (dom (discovered s0));\n     \\<not> a.is_empty_stack s0; on_stack si = set (stack s0);\n     \\<not> is_break param s0; visited si = dom (discovered s0);\n     u = hd (stack s0);\n     dom (finished s0) = dom (discovered s0) - set (stack s0);\n     s = s0\\<lparr>pending := pending s0 - {(hd (stack s0), v)}\\<rparr>;\n     set (stack s0) \\<subseteq> dom (discovered s0);\n     (simple_state.more si, state.more s0) \\<in> ES;\n     (hd (stack s0), v) \\<in> pending s0;\n     \\<not> a.is_discovered v\n             (s0\\<lparr>pending :=\n                          pending s0 - {(hd (stack s0), v)}\\<rparr>);\n     set (stack s0) \\<subseteq> dom (discovered s0)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. discovered s0 v = Some y", "apply (frule DFS_invar.pending_ssE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ui = hd (stack s0); vi = v; DFS_invar G param s0;\n     ss_stack si =\n     map (\\<lambda>u. (u, (pending s0 - {(hd (stack s0), v)}) `` {u}))\n      (stack s0);\n     v \\<notin> set (stack s0);\n     a.E `` {v} =\n     (pending s0 - {(hd (stack s0), v)} \\<union> {v} \\<times> a.E `` {v}) ``\n     {v} \\<longrightarrow>\n     (\\<exists>x\\<in>set (stack s0).\n         (pending s0 - {(hd (stack s0), v)}) `` {x} \\<noteq>\n         (pending s0 - {(hd (stack s0), v)} \\<union>\n          {v} \\<times> a.E `` {v}) ``\n         {x}) \\<or>\n     \\<not> set (stack s0) \\<subseteq> insert v (dom (discovered s0));\n     \\<not> a.is_empty_stack s0; on_stack si = set (stack s0);\n     \\<not> is_break param s0; visited si = dom (discovered s0);\n     u = hd (stack s0);\n     dom (finished s0) = dom (discovered s0) - set (stack s0);\n     s = s0\\<lparr>pending := pending s0 - {(hd (stack s0), v)}\\<rparr>;\n     set (stack s0) \\<subseteq> dom (discovered s0);\n     (simple_state.more si, state.more s0) \\<in> ES;\n     (hd (stack s0), v) \\<in> pending s0;\n     \\<not> a.is_discovered v\n             (s0\\<lparr>pending :=\n                          pending s0 - {(hd (stack s0), v)}\\<rparr>);\n     set (stack s0) \\<subseteq> dom (discovered s0);\n     pending s0 \\<subseteq> a.E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. discovered s0 v = Some y", "apply (clarsimp simp: a.pred_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ui = hd (stack s0); vi = v; DFS_invar G param s0;\n     ss_stack si =\n     map (\\<lambda>u. (u, (pending s0 - {(hd (stack s0), v)}) `` {u}))\n      (stack s0);\n     v \\<notin> set (stack s0);\n     a.E `` {v} =\n     (pending s0 - {(hd (stack s0), v)} \\<union> {v} \\<times> a.E `` {v}) ``\n     {v} \\<longrightarrow>\n     (\\<exists>x\\<in>set (stack s0).\n         (pending s0 - {(hd (stack s0), v)}) `` {x} \\<noteq>\n         (pending s0 - {(hd (stack s0), v)} \\<union>\n          {v} \\<times> a.E `` {v}) ``\n         {x}) \\<or>\n     \\<not> set (stack s0) \\<subseteq> insert v (dom (discovered s0));\n     stack s0 \\<noteq> []; on_stack si = set (stack s0);\n     \\<not> is_break param s0; visited si = dom (discovered s0);\n     u = hd (stack s0);\n     dom (finished s0) = dom (discovered s0) - set (stack s0);\n     s = s0\\<lparr>pending := pending s0 - {(hd (stack s0), v)}\\<rparr>;\n     (simple_state.more si, state.more s0) \\<in> ES;\n     (hd (stack s0), v) \\<in> pending s0;\n     set (stack s0) \\<subseteq> dom (discovered s0);\n     pending s0 \\<subseteq> a.E; discovered s0 v = None\\<rbrakk>\n    \\<Longrightarrow> False", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sublocale gen_param_dfs_refine \n    where gbsi = c.gbs \n    and gbs = a.gbs\n    and upd_exti = simple_state.more_update\n    and upd_ext = state.more_update\n    and V0i = a.V0\n    and V0 = a.V0\n    and V = Id\n    and S = \"\\<langle>ES\\<rangle>simple_state_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_param_dfs_refine c.gbs parami simple_state.more_update a.V0 a.gbs\n     param state.more_update a.V0 Id (\\<langle>ES\\<rangle>simple_state_rel)\n     ES", "apply unfold_locales"], ["proof (prove)\ngoal (13 subgoals):\n 1. bijective Id\n 2. (a.V0, a.V0) \\<in> \\<langle>Id\\<rangle>set_rel\n 3. (gbs_is_discovered c.gbs, gbs_is_discovered a.gbs)\n    \\<in> Id \\<rightarrow>\n          \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 4. (gbs_is_finished c.gbs, gbs_is_finished a.gbs)\n    \\<in> Id \\<rightarrow>\n          \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 5. (gbs_is_empty_stack c.gbs, gbs_is_empty_stack a.gbs)\n    \\<in> \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 6. (is_break parami, is_break param)\n    \\<in> \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 7. \\<And>ei e.\n       (ei, e) \\<in> ES \\<Longrightarrow>\n       gbs_init c.gbs ei\n       \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n              (gbs_init a.gbs e)\n 8. \\<And>v0 s v0i si.\n       \\<lbrakk>a.gen_dfs.pre_new_root v0 s; (v0i, v0) \\<in> Id;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> gbs_new_root c.gbs v0i si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (gbs_new_root a.gbs v0 s)\n 9. \\<And>s si.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> gbs_get_pending c.gbs si\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                 \\<langle>ES\\<rangle>simple_state_rel)\n                                (gbs_get_pending a.gbs s)\n 10. \\<And>v s0 s vi si.\n        \\<lbrakk>a.gen_dfs.pre_finish v s0 s; (vi, v) \\<in> Id;\n         (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n        \\<Longrightarrow> gbs_finish c.gbs vi si\n                          \\<le> \\<Down>\n                                 (\\<langle>ES\\<rangle>simple_state_rel)\n                                 (gbs_finish a.gbs v s)\nA total of 13 subgoals...", "apply (simp_all add: is_break_param)"], ["proof (prove)\ngoal (10 subgoals):\n 1. (c.is_discovered_impl, a.is_discovered)\n    \\<in> Id \\<rightarrow>\n          \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 2. (c.is_finished_impl, a.is_finished)\n    \\<in> Id \\<rightarrow>\n          \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 3. (c.is_empty_stack_impl, a.is_empty_stack)\n    \\<in> \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 4. \\<And>ei e.\n       (ei, e) \\<in> ES \\<Longrightarrow>\n       c.init_impl ei\n       \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n              (RETURN (a.empty_state e))\n 5. \\<And>v0 s v0i si.\n       \\<lbrakk>a.gen_dfs.pre_new_root v0 s; v0i = v0;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.new_root_impl v0 si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.new_root v0 s))\n 6. \\<And>s si.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.get_pending_impl si\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 \\<langle>ES\\<rangle>simple_state_rel)\n                                (a.get_pending s)\n 7. \\<And>v s0 s vi si.\n       \\<lbrakk>a.gen_dfs.pre_finish v s0 s; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.finish_impl v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.finish v s))\n 8. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.cross_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 9. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.back_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 10. \\<And>u v s0 s ui vi si.\n        \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n         (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n        \\<Longrightarrow> c.discover_impl u v si\n                          \\<le> \\<Down>\n                                 (\\<langle>ES\\<rangle>simple_state_rel)\n                                 (RETURN (a.discover u v s))", "(* TODO: Strange effect,   \n      the is_break_param subgoal should not be visible at all!*)"], ["proof (prove)\ngoal (10 subgoals):\n 1. (c.is_discovered_impl, a.is_discovered)\n    \\<in> Id \\<rightarrow>\n          \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 2. (c.is_finished_impl, a.is_finished)\n    \\<in> Id \\<rightarrow>\n          \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 3. (c.is_empty_stack_impl, a.is_empty_stack)\n    \\<in> \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 4. \\<And>ei e.\n       (ei, e) \\<in> ES \\<Longrightarrow>\n       c.init_impl ei\n       \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n              (RETURN (a.empty_state e))\n 5. \\<And>v0 s v0i si.\n       \\<lbrakk>a.gen_dfs.pre_new_root v0 s; v0i = v0;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.new_root_impl v0 si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.new_root v0 s))\n 6. \\<And>s si.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.get_pending_impl si\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 \\<langle>ES\\<rangle>simple_state_rel)\n                                (a.get_pending s)\n 7. \\<And>v s0 s vi si.\n       \\<lbrakk>a.gen_dfs.pre_finish v s0 s; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.finish_impl v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.finish v s))\n 8. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.cross_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 9. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.back_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 10. \\<And>u v s0 s ui vi si.\n        \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n         (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n        \\<Longrightarrow> c.discover_impl u v si\n                          \\<le> \\<Down>\n                                 (\\<langle>ES\\<rangle>simple_state_rel)\n                                 (RETURN (a.discover u v s))", "apply (auto simp: a.is_discovered_def c.is_discovered_impl_def simple_state_rel_def) []"], ["proof (prove)\ngoal (9 subgoals):\n 1. (c.is_finished_impl, a.is_finished)\n    \\<in> Id \\<rightarrow>\n          \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 2. (c.is_empty_stack_impl, a.is_empty_stack)\n    \\<in> \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 3. \\<And>ei e.\n       (ei, e) \\<in> ES \\<Longrightarrow>\n       c.init_impl ei\n       \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n              (RETURN (a.empty_state e))\n 4. \\<And>v0 s v0i si.\n       \\<lbrakk>a.gen_dfs.pre_new_root v0 s; v0i = v0;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.new_root_impl v0 si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.new_root v0 s))\n 5. \\<And>s si.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.get_pending_impl si\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 \\<langle>ES\\<rangle>simple_state_rel)\n                                (a.get_pending s)\n 6. \\<And>v s0 s vi si.\n       \\<lbrakk>a.gen_dfs.pre_finish v s0 s; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.finish_impl v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.finish v s))\n 7. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.cross_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 8. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.back_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 9. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.discover_impl u v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.discover u v s))", "apply (auto simp: a.is_finished_def c.is_finished_impl_def simple_state_rel_def) []"], ["proof (prove)\ngoal (8 subgoals):\n 1. (c.is_empty_stack_impl, a.is_empty_stack)\n    \\<in> \\<langle>ES\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 2. \\<And>ei e.\n       (ei, e) \\<in> ES \\<Longrightarrow>\n       c.init_impl ei\n       \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n              (RETURN (a.empty_state e))\n 3. \\<And>v0 s v0i si.\n       \\<lbrakk>a.gen_dfs.pre_new_root v0 s; v0i = v0;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.new_root_impl v0 si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.new_root v0 s))\n 4. \\<And>s si.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.get_pending_impl si\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 \\<langle>ES\\<rangle>simple_state_rel)\n                                (a.get_pending s)\n 5. \\<And>v s0 s vi si.\n       \\<lbrakk>a.gen_dfs.pre_finish v s0 s; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.finish_impl v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.finish v s))\n 6. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.cross_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 7. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.back_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 8. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.discover_impl u v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.discover u v s))", "apply (auto simp: a.is_empty_stack_def c.is_empty_stack_impl_def simple_state_rel_def) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>ei e.\n       (ei, e) \\<in> ES \\<Longrightarrow>\n       c.init_impl ei\n       \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n              (RETURN (a.empty_state e))\n 2. \\<And>v0 s v0i si.\n       \\<lbrakk>a.gen_dfs.pre_new_root v0 s; v0i = v0;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.new_root_impl v0 si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.new_root v0 s))\n 3. \\<And>s si.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.get_pending_impl si\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 \\<langle>ES\\<rangle>simple_state_rel)\n                                (a.get_pending s)\n 4. \\<And>v s0 s vi si.\n       \\<lbrakk>a.gen_dfs.pre_finish v s0 s; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.finish_impl v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.finish v s))\n 5. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.cross_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 6. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.back_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 7. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.discover_impl u v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.discover u v s))", "apply (refine_rcg init_impl)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>v0 s v0i si.\n       \\<lbrakk>a.gen_dfs.pre_new_root v0 s; v0i = v0;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.new_root_impl v0 si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.new_root v0 s))\n 2. \\<And>s si.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.get_pending_impl si\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 \\<langle>ES\\<rangle>simple_state_rel)\n                                (a.get_pending s)\n 3. \\<And>v s0 s vi si.\n       \\<lbrakk>a.gen_dfs.pre_finish v s0 s; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.finish_impl v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.finish v s))\n 4. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.cross_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 5. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.back_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 6. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.discover_impl u v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.discover u v s))", "apply (refine_rcg new_root_impl, simp_all) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s si.\n       \\<lbrakk>a.gen_dfs.pre_get_pending s;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.get_pending_impl si\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 \\<langle>ES\\<rangle>simple_state_rel)\n                                (a.get_pending s)\n 2. \\<And>v s0 s vi si.\n       \\<lbrakk>a.gen_dfs.pre_finish v s0 s; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.finish_impl v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.finish v s))\n 3. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.cross_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 4. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.back_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 5. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.discover_impl u v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.discover u v s))", "apply (refine_rcg get_pending_impl) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v s0 s vi si.\n       \\<lbrakk>a.gen_dfs.pre_finish v s0 s; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.finish_impl v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.finish v s))\n 2. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.cross_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 3. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.back_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 4. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.discover_impl u v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.discover u v s))", "apply (refine_rcg finish_impl, simp_all) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_cross_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.cross_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 2. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.back_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 3. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.discover_impl u v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.discover u v s))", "apply (refine_rcg cross_edge_impl, simp_all) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_back_edge u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> (si, a.back_edge u v s)\n                         \\<in> \\<langle>ES\\<rangle>simple_state_rel\n 2. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.discover_impl u v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.discover u v s))", "apply (refine_rcg back_edge_impl, simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v s0 s ui vi si.\n       \\<lbrakk>a.gen_dfs.pre_discover u v s0 s; ui = u; vi = v;\n        (si, s) \\<in> \\<langle>ES\\<rangle>simple_state_rel\\<rbrakk>\n       \\<Longrightarrow> c.discover_impl u v si\n                         \\<le> \\<Down>\n                                (\\<langle>ES\\<rangle>simple_state_rel)\n                                (RETURN (a.discover u v s))", "apply (refine_rcg discover_impl, simp_all) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open> Main outcome of this locale: The simple DFS-Algorithm, which is\n    a general DFS scheme itself (and thus open to further refinements),\n    and a refinement theorem that states correct refinement of the original DFS \\<close>"], ["", "lemma simple_refine[refine]: \"c.gen_dfs \\<le> \\<Down>(\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.gen_dfs \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "using gen_dfs_refine"], ["proof (prove)\nusing this:\n  c.gen_dfs\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.gen_dfs.gen_dfs\n\ngoal (1 subgoal):\n 1. c.gen_dfs \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "by simp"], ["", "lemma simple_refineT[refine]: \"c.gen_dfsT \\<le> \\<Down>(\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.gen_dfsT\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT", "using gen_dfsT_refine"], ["proof (prove)\nusing this:\n  c.gen_dfsT\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.gen_dfs.gen_dfsT\n\ngoal (1 subgoal):\n 1. c.gen_dfsT\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT", "by simp"], ["", "text \\<open>Link with tail-recursive implementation\\<close>"], ["", "sublocale tailrec_impl G c.gds"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tailrec_Impl.tailrec_impl G c.gds", "apply unfold_locales"], ["proof (prove)\ngoal (7 subgoals):\n 1. gds_init c.gds \\<le>\\<^sub>n SPEC (gds_is_empty_stack c.gds)\n 2. \\<And>v0 s.\n       c.pre_new_root v0 s \\<Longrightarrow>\n       gds_new_root c.gds v0 s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            insert v0 (c.gen_discovered s) \\<subseteq> c.gen_discovered s')\n 3. \\<And>s.\n       c.pre_get_pending s \\<Longrightarrow>\n       gds_get_pending c.gds s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>(uu_, uu_, s').\n            c.gen_discovered s \\<subseteq> c.gen_discovered s')\n 4. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       gds_finish c.gds u s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'. c.gen_discovered s \\<subseteq> c.gen_discovered s')\n 5. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       gds_cross_edge c.gds u v s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'. c.gen_discovered s \\<subseteq> c.gen_discovered s')\n 6. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       gds_back_edge c.gds u v s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'. c.gen_discovered s \\<subseteq> c.gen_discovered s')\n 7. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       gds_discover c.gds u v s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'. c.gen_discovered s \\<subseteq> c.gen_discovered s')", "apply (simp_all add: c.do_action_defs c.impl_defs[abs_def])"], ["proof (prove)\ngoal (7 subgoals):\n 1. on_init parami \\<bind>\n    (\\<lambda>e.\n        RETURN\n         \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n            \\<dots> = e\\<rparr>) \\<le>\\<^sub>n\n    SPEC (\\<lambda>s. ss_stack s = [])\n 2. \\<And>v0 s.\n       c.pre_new_root v0 s \\<Longrightarrow>\n       ASSERT (v0 \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_new_root parami v0\n            (s\\<lparr>ss_stack := [(v0, a.E `` {v0})], on_stack := {v0},\n                 visited := insert v0 (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := [(v0, a.E `` {v0})], on_stack := {v0},\n                     visited := insert v0 (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            v0 \\<in> visited s' \\<and> visited s \\<subseteq> visited s')\n 3. \\<And>s.\n       c.pre_get_pending s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> []) \\<bind>\n       (\\<lambda>_.\n           case hd (ss_stack s) of\n           (u, Vs) \\<Rightarrow>\n             if Vs = {} then RETURN (u, None, s)\n             else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                  (\\<lambda>v.\n                      let Vs = Vs - {v};\n                          s = s\\<lparr>ss_stack :=\n   (u, Vs) # tl (ss_stack s)\\<rparr>\n                      in RETURN (u, Some v, s))) \\<le>\\<^sub>n\n       SPEC (\\<lambda>(uu_, uu_, s'). visited s \\<subseteq> visited s')\n 4. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC (\\<lambda>s'. visited s \\<subseteq> visited s')\n 5. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC (\\<lambda>s'. visited s \\<subseteq> visited s')\n 6. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC (\\<lambda>s'. visited s \\<subseteq> visited s')\n 7. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC (\\<lambda>s'. visited s \\<subseteq> visited s')", "apply (auto simp: pw_leof_iff refine_pw_simps split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma simple_tailrec_refine[refine]: \"tailrec_impl \\<le> \\<Down>(\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "note tailrec_impl"], ["proof (state)\nthis:\n  local.tailrec_impl \\<le> c.gen_dfs\n\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "also"], ["proof (state)\nthis:\n  local.tailrec_impl \\<le> c.gen_dfs\n\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "note simple_refine"], ["proof (state)\nthis:\n  c.gen_dfs \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\n\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "finally"], ["proof (chain)\npicking this:\n  local.tailrec_impl\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "show ?thesis"], ["proof (prove)\nusing this:\n  local.tailrec_impl\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\n\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "."], ["proof (state)\nthis:\n  local.tailrec_impl\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simple_tailrecT_refine[refine]: \"tailrec_implT \\<le> \\<Down>(\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tailrec_implT\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tailrec_implT\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT", "note tailrecT_impl"], ["proof (state)\nthis:\n  tailrec_implT \\<le> c.gen_dfsT\n\ngoal (1 subgoal):\n 1. tailrec_implT\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT", "also"], ["proof (state)\nthis:\n  tailrec_implT \\<le> c.gen_dfsT\n\ngoal (1 subgoal):\n 1. tailrec_implT\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT", "note simple_refineT"], ["proof (state)\nthis:\n  c.gen_dfsT \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT\n\ngoal (1 subgoal):\n 1. tailrec_implT\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT", "finally"], ["proof (chain)\npicking this:\n  tailrec_implT\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT", "show ?thesis"], ["proof (prove)\nusing this:\n  tailrec_implT\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT\n\ngoal (1 subgoal):\n 1. tailrec_implT\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT", "."], ["proof (state)\nthis:\n  tailrec_implT\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfsT\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Link to recursive implementation\\<close>"], ["", "(* TODO: Currently, we have to prove this invar at several places.\n    Maybe it's worth to share in a common locale!?\n  *)"], ["", "lemma reachable_invar: \n    assumes \"c.gen_rwof s\" \n    shows \"set (map fst (ss_stack s)) \\<subseteq> visited s \n      \\<and> distinct (map fst (ss_stack s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n    distinct (map fst (ss_stack s))", "using assms"], ["proof (prove)\nusing this:\n  c.gen_rwof s\n\ngoal (1 subgoal):\n 1. set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n    distinct (map fst (ss_stack s))", "apply (induct rule: establish_rwof_invar[rotated -1, consumes 1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. gds_init c.gds \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         set (map fst (ss_stack a)) \\<subseteq> visited a \\<and>\n         distinct (map fst (ss_stack a)))\n 2. \\<And>s.\n       \\<lbrakk>c.gen_rwof s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s\\<rbrakk>\n       \\<Longrightarrow> c.gen_step s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              set (map fst (ss_stack a))\n                              \\<subseteq> visited a \\<and>\n                              distinct (map fst (ss_stack a)))", "apply (simp add: c.do_action_defs c.impl_defs[abs_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. on_init parami \\<bind>\n    (\\<lambda>e.\n        RETURN\n         \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n            \\<dots> = e\\<rparr>) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         fst ` set (ss_stack a) \\<subseteq> visited a \\<and>\n         distinct (map fst (ss_stack a)))\n 2. \\<And>s.\n       \\<lbrakk>c.gen_rwof s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s\\<rbrakk>\n       \\<Longrightarrow> c.gen_step s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              set (map fst (ss_stack a))\n                              \\<subseteq> visited a \\<and>\n                              distinct (map fst (ss_stack a)))", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. on_init parami \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         RETURN\n          \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n             \\<dots> = x\\<rparr> \\<le>\\<^sub>n\n         SPEC\n          (\\<lambda>a.\n              fst ` set (ss_stack a) \\<subseteq> visited a \\<and>\n              distinct (map fst (ss_stack a))))\n 2. \\<And>s.\n       \\<lbrakk>c.gen_rwof s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s\\<rbrakk>\n       \\<Longrightarrow> c.gen_step s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              set (map fst (ss_stack a))\n                              \\<subseteq> visited a \\<and>\n                              distinct (map fst (ss_stack a)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>c.gen_rwof s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s\\<rbrakk>\n       \\<Longrightarrow> c.gen_step s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              set (map fst (ss_stack a))\n                              \\<subseteq> visited a \\<and>\n                              distinct (map fst (ss_stack a)))", "unfolding c.gen_step_def c.do_action_defs c.impl_defs[abs_def] c.gds_simps c.gbs_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s\\<rbrakk>\n       \\<Longrightarrow> (if ss_stack s = []\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> a.V0 \\<and>\n                                    v0 \\<notin> visited s) \\<bind>\n                               (\\<lambda>v0.\n                                   ASSERT (v0 \\<notin> visited s) \\<bind>\n                                   (\\<lambda>_.\n let s = s\\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\n     s = s\\<lparr>on_stack := {v0}\\<rparr>\n in Let (s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                                   (\\<lambda>s.\n on_new_root parami v0 s \\<bind>\n (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                          else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                               (\\<lambda>_.\n                                   let (u, Vs) = hd (ss_stack s)\n                                   in if Vs = {} then RETURN (u, None, s)\nelse SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n     (\\<lambda>v.\n         let Vs = Vs - {v};\n             s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n         in RETURN (u, Some v, s))) \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow>\n                                     ASSERT\n(ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n                                     (\\<lambda>_.\n   let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n   in Let (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                     (\\<lambda>s.\n   on_finish parami u s \\<bind>\n   (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                   | Some v \\<Rightarrow>\n if v \\<in> visited s\n then if v \\<in> visited s - on_stack s\n      then RETURN s \\<bind>\n           (\\<lambda>s.\n               on_cross_edge parami u v s \\<bind>\n               (\\<lambda>e.\n                   RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n      else RETURN s \\<bind>\n           (\\<lambda>s.\n               on_back_edge parami u v s \\<bind>\n               (\\<lambda>e.\n                   RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n      (\\<lambda>_.\n          let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n              s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n          in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n              RETURN) \\<bind>\n      (\\<lambda>s.\n          on_discover parami u v s \\<bind>\n          (\\<lambda>e.\n              RETURN\n               (s\\<lparr>simple_state.more := e\\<rparr>))))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              set (map fst (ss_stack a))\n                              \\<subseteq> visited a \\<and>\n                              distinct (map fst (ss_stack a)))", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s = [];\n        x \\<in> {v0 \\<in> a.V0. v0 \\<notin> visited s};\n        x \\<notin> visited s\\<rbrakk>\n       \\<Longrightarrow> on_new_root parami x\n                          (s\\<lparr>ss_stack := [(x, a.E `` {x})],\n                               on_stack := {x},\n                               visited :=\n                                 insert x\n                                  (visited\n                                    (s\\<lparr>ss_stack := [(x, a.E `` {x})],\n   on_stack := {x}\\<rparr>))\\<rparr>) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              RETURN\n                               (s\\<lparr>ss_stack := [(x, a.E `` {x})],\n                                    on_stack := {x},\n                                    visited :=\ninsert x\n (visited\n   (s\\<lparr>ss_stack := [(x, a.E `` {x})], on_stack := {x}\\<rparr>)),\n                                    simple_state.more :=\nxa\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>a.\n                                   set (map fst (ss_stack a))\n                                   \\<subseteq> visited a \\<and>\n                                   distinct (map fst (ss_stack a))))\n 2. \\<And>s x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; ss_stack s \\<noteq> [];\n        hd (ss_stack s) = (x1, x2); x2 = {}; x2a = (x1b, x2b);\n        (x1, None, s) = (x1a, x2a); x1b = None;\n        ss_stack x2b \\<noteq> [] \\<and> x1a \\<in> on_stack x2b\\<rbrakk>\n       \\<Longrightarrow> on_finish parami x1a\n                          (x2b\\<lparr>ss_stack := tl (ss_stack x2b),\n                                 on_stack :=\n                                   on_stack\n                                    (x2b\\<lparr>ss_stack :=\n            tl (ss_stack x2b)\\<rparr>) -\n                                   {x1a}\\<rparr>) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (x2b\\<lparr>ss_stack := tl (ss_stack x2b),\non_stack :=\n  on_stack (x2b\\<lparr>ss_stack := tl (ss_stack x2b)\\<rparr>) - {x1a},\nsimple_state.more := x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>a.\n                                   set (map fst (ss_stack a))\n                                   \\<subseteq> visited a \\<and>\n                                   distinct (map fst (ss_stack a))))\n 3. \\<And>s x1 x2 x1a x2a x1b x2b v.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; ss_stack s \\<noteq> [];\n        hd (ss_stack s) = (x1, x2); x2 = {}; x2a = (x1b, x2b);\n        (x1, None, s) = (x1a, x2a); x1b = Some v; v \\<in> visited x2b;\n        v \\<in> visited x2b - on_stack x2b\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge parami x1a v x2b \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (x2b\\<lparr>simple_state.more :=\n       x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>a.\n                                   set (map fst (ss_stack a))\n                                   \\<subseteq> visited a \\<and>\n                                   distinct (map fst (ss_stack a))))\n 4. \\<And>s x1 x2 x1a x2a x1b x2b v.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; ss_stack s \\<noteq> [];\n        hd (ss_stack s) = (x1, x2); x2 = {}; x2a = (x1b, x2b);\n        (x1, None, s) = (x1a, x2a); x1b = Some v; v \\<in> visited x2b;\n        v \\<notin> visited x2b - on_stack x2b\\<rbrakk>\n       \\<Longrightarrow> on_back_edge parami x1a v x2b \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (x2b\\<lparr>simple_state.more :=\n       x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>a.\n                                   set (map fst (ss_stack a))\n                                   \\<subseteq> visited a \\<and>\n                                   distinct (map fst (ss_stack a))))\n 5. \\<And>s x1 x2 x1a x2a x1b x2b v.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; ss_stack s \\<noteq> [];\n        hd (ss_stack s) = (x1, x2); x2 = {}; x2a = (x1b, x2b);\n        (x1, None, s) = (x1a, x2a); x1b = Some v; v \\<notin> visited x2b;\n        v \\<notin> on_stack x2b \\<and> v \\<notin> visited x2b\\<rbrakk>\n       \\<Longrightarrow> on_discover parami x1a v\n                          (x2b\\<lparr>ss_stack :=\n  (v, a.E `` {v}) # ss_stack x2b,\n                                 on_stack :=\n                                   insert v\n                                    (on_stack\n(x2b\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack x2b\\<rparr>)),\n                                 visited :=\n                                   insert v\n                                    (visited\n(x2b\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack x2b,\n       on_stack :=\n         insert v\n          (on_stack\n            (x2b\\<lparr>ss_stack :=\n                          (v, a.E `` {v}) #\n                          ss_stack\n                           x2b\\<rparr>))\\<rparr>))\\<rparr>) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (x2b\\<lparr>ss_stack :=\n       (v, a.E `` {v}) # ss_stack x2b,\non_stack :=\n  insert v\n   (on_stack\n     (x2b\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack x2b\\<rparr>)),\nvisited :=\n  insert v\n   (visited\n     (x2b\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack x2b,\n            on_stack :=\n              insert v\n               (on_stack\n                 (x2b\\<lparr>ss_stack :=\n                               (v, a.E `` {v}) #\n                               ss_stack x2b\\<rparr>))\\<rparr>)),\nsimple_state.more := x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>a.\n                                   set (map fst (ss_stack a))\n                                   \\<subseteq> visited a \\<and>\n                                   distinct (map fst (ss_stack a))))\n 6. \\<And>s x1 x2 x x1a x2a x1b x2b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; ss_stack s \\<noteq> [];\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; x \\<in> {v. v \\<in> x2};\n        x2a = (x1b, x2b);\n        (x1, Some x, s\n         \\<lparr>ss_stack := (x1, x2 - {x}) # tl (ss_stack s)\\<rparr>) =\n        (x1a, x2a);\n        x1b = None;\n        ss_stack x2b \\<noteq> [] \\<and> x1a \\<in> on_stack x2b\\<rbrakk>\n       \\<Longrightarrow> on_finish parami x1a\n                          (x2b\\<lparr>ss_stack := tl (ss_stack x2b),\n                                 on_stack :=\n                                   on_stack\n                                    (x2b\\<lparr>ss_stack :=\n            tl (ss_stack x2b)\\<rparr>) -\n                                   {x1a}\\<rparr>) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (x2b\\<lparr>ss_stack := tl (ss_stack x2b),\non_stack :=\n  on_stack (x2b\\<lparr>ss_stack := tl (ss_stack x2b)\\<rparr>) - {x1a},\nsimple_state.more := x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>a.\n                                   set (map fst (ss_stack a))\n                                   \\<subseteq> visited a \\<and>\n                                   distinct (map fst (ss_stack a))))\n 7. \\<And>s x1 x2 x x1a x2a x1b x2b v.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; ss_stack s \\<noteq> [];\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; x \\<in> {v. v \\<in> x2};\n        x2a = (x1b, x2b);\n        (x1, Some x, s\n         \\<lparr>ss_stack := (x1, x2 - {x}) # tl (ss_stack s)\\<rparr>) =\n        (x1a, x2a);\n        x1b = Some v; v \\<in> visited x2b;\n        v \\<in> visited x2b - on_stack x2b\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge parami x1a v x2b \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (x2b\\<lparr>simple_state.more :=\n       x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>a.\n                                   set (map fst (ss_stack a))\n                                   \\<subseteq> visited a \\<and>\n                                   distinct (map fst (ss_stack a))))\n 8. \\<And>s x1 x2 x x1a x2a x1b x2b v.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; ss_stack s \\<noteq> [];\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; x \\<in> {v. v \\<in> x2};\n        x2a = (x1b, x2b);\n        (x1, Some x, s\n         \\<lparr>ss_stack := (x1, x2 - {x}) # tl (ss_stack s)\\<rparr>) =\n        (x1a, x2a);\n        x1b = Some v; v \\<in> visited x2b;\n        v \\<notin> visited x2b - on_stack x2b\\<rbrakk>\n       \\<Longrightarrow> on_back_edge parami x1a v x2b \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (x2b\\<lparr>simple_state.more :=\n       x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>a.\n                                   set (map fst (ss_stack a))\n                                   \\<subseteq> visited a \\<and>\n                                   distinct (map fst (ss_stack a))))\n 9. \\<And>s x1 x2 x x1a x2a x1b x2b v.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; ss_stack s \\<noteq> [];\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; x \\<in> {v. v \\<in> x2};\n        x2a = (x1b, x2b);\n        (x1, Some x, s\n         \\<lparr>ss_stack := (x1, x2 - {x}) # tl (ss_stack s)\\<rparr>) =\n        (x1a, x2a);\n        x1b = Some v; v \\<notin> visited x2b;\n        v \\<notin> on_stack x2b \\<and> v \\<notin> visited x2b\\<rbrakk>\n       \\<Longrightarrow> on_discover parami x1a v\n                          (x2b\\<lparr>ss_stack :=\n  (v, a.E `` {v}) # ss_stack x2b,\n                                 on_stack :=\n                                   insert v\n                                    (on_stack\n(x2b\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack x2b\\<rparr>)),\n                                 visited :=\n                                   insert v\n                                    (visited\n(x2b\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack x2b,\n       on_stack :=\n         insert v\n          (on_stack\n            (x2b\\<lparr>ss_stack :=\n                          (v, a.E `` {v}) #\n                          ss_stack\n                           x2b\\<rparr>))\\<rparr>))\\<rparr>) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (x2b\\<lparr>ss_stack :=\n       (v, a.E `` {v}) # ss_stack x2b,\non_stack :=\n  insert v\n   (on_stack\n     (x2b\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack x2b\\<rparr>)),\nvisited :=\n  insert v\n   (visited\n     (x2b\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack x2b,\n            on_stack :=\n              insert v\n               (on_stack\n                 (x2b\\<lparr>ss_stack :=\n                               (v, a.E `` {v}) #\n                               ss_stack x2b\\<rparr>))\\<rparr>)),\nsimple_state.more := x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>a.\n                                   set (map fst (ss_stack a))\n                                   \\<subseteq> visited a \\<and>\n                                   distinct (map fst (ss_stack a))))", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s x1 x2 x1a x2a x1b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        fst ` set (ss_stack s) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; hd (ss_stack s) = (x1a, {}); x2 = {}; x2a = (None, s);\n        x1 = x1a; x1b = None;\n        ss_stack s \\<noteq> [] \\<and> x1a \\<in> on_stack s\\<rbrakk>\n       \\<Longrightarrow> (fst ` set (tl (ss_stack s))\n                          \\<subseteq> visited s \\<longrightarrow>\n                          \\<not> distinct\n                                  (map fst\n                                    (tl (ss_stack s)))) \\<longrightarrow>\n                         on_finish parami x1a\n                          (s\\<lparr>ss_stack := tl (ss_stack s),\n                               on_stack :=\n                                 on_stack s - {x1a}\\<rparr>) \\<le>\\<^sub>n\n                         SUCCEED\n 2. \\<And>s x1 x2 x x1a x2a x1b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        fst ` set (ss_stack s) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; hd (ss_stack s) = (x1a, x2);\n        x2 \\<noteq> {}; x \\<in> x2;\n        x2a =\n        (Some x, s\n         \\<lparr>ss_stack := (x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>);\n        x1 = x1a; x1b = Some x; x \\<in> visited s;\n        x \\<notin> on_stack s\\<rbrakk>\n       \\<Longrightarrow> (fst ` set (tl (ss_stack s))\n                          \\<subseteq> visited s \\<longrightarrow>\n                          x1a \\<in> visited s \\<longrightarrow>\n                          x1a \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          \\<not> distinct\n                                  (map fst\n                                    (tl (ss_stack s)))) \\<longrightarrow>\n                         on_cross_edge parami x1a x\n                          (s\\<lparr>ss_stack :=\n(x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>) \\<le>\\<^sub>n\n                         SUCCEED\n 3. \\<And>s x1 x2 x x1a x2a x1b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        fst ` set (ss_stack s) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; hd (ss_stack s) = (x1a, x2);\n        x2 \\<noteq> {}; x \\<in> x2;\n        x2a =\n        (Some x, s\n         \\<lparr>ss_stack := (x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>);\n        x1 = x1a; x1b = Some x; x \\<in> visited s;\n        x \\<in> on_stack s\\<rbrakk>\n       \\<Longrightarrow> (fst ` set (tl (ss_stack s))\n                          \\<subseteq> visited s \\<longrightarrow>\n                          x1a \\<in> visited s \\<longrightarrow>\n                          x1a \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          \\<not> distinct\n                                  (map fst\n                                    (tl (ss_stack s)))) \\<longrightarrow>\n                         on_back_edge parami x1a x\n                          (s\\<lparr>ss_stack :=\n(x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>) \\<le>\\<^sub>n\n                         SUCCEED\n 4. \\<And>s x1 x2 x x1a x2a x1b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        fst ` set (ss_stack s) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; hd (ss_stack s) = (x1a, x2);\n        x2 \\<noteq> {}; x \\<in> x2;\n        x2a =\n        (Some x, s\n         \\<lparr>ss_stack := (x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>);\n        x1 = x1a; x1b = Some x;\n        x \\<notin> on_stack s \\<and> x \\<notin> visited s\\<rbrakk>\n       \\<Longrightarrow> (fst ` set (tl (ss_stack s))\n                          \\<subseteq> insert x (visited s) \\<longrightarrow>\n                          x1a \\<noteq> x \\<and> x1a \\<notin> visited s \\<or>\n                          x = x1a \\<or>\n                          x \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          x1a \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          \\<not> distinct\n                                  (map fst\n                                    (tl (ss_stack s)))) \\<longrightarrow>\n                         on_discover parami x1a x\n                          (s\\<lparr>ss_stack :=\n(x, a.E `` {x}) # (x1a, x2 - {x}) # tl (ss_stack s),\n                               on_stack := insert x (on_stack s),\n                               visited :=\n                                 insert x (visited s)\\<rparr>) \\<le>\\<^sub>n\n                         SUCCEED", "apply (fastforce simp: neq_Nil_conv) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s x1 x2 x x1a x2a x1b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        fst ` set (ss_stack s) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; hd (ss_stack s) = (x1a, x2);\n        x2 \\<noteq> {}; x \\<in> x2;\n        x2a =\n        (Some x, s\n         \\<lparr>ss_stack := (x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>);\n        x1 = x1a; x1b = Some x; x \\<in> visited s;\n        x \\<notin> on_stack s\\<rbrakk>\n       \\<Longrightarrow> (fst ` set (tl (ss_stack s))\n                          \\<subseteq> visited s \\<longrightarrow>\n                          x1a \\<in> visited s \\<longrightarrow>\n                          x1a \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          \\<not> distinct\n                                  (map fst\n                                    (tl (ss_stack s)))) \\<longrightarrow>\n                         on_cross_edge parami x1a x\n                          (s\\<lparr>ss_stack :=\n(x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>) \\<le>\\<^sub>n\n                         SUCCEED\n 2. \\<And>s x1 x2 x x1a x2a x1b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        fst ` set (ss_stack s) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; hd (ss_stack s) = (x1a, x2);\n        x2 \\<noteq> {}; x \\<in> x2;\n        x2a =\n        (Some x, s\n         \\<lparr>ss_stack := (x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>);\n        x1 = x1a; x1b = Some x; x \\<in> visited s;\n        x \\<in> on_stack s\\<rbrakk>\n       \\<Longrightarrow> (fst ` set (tl (ss_stack s))\n                          \\<subseteq> visited s \\<longrightarrow>\n                          x1a \\<in> visited s \\<longrightarrow>\n                          x1a \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          \\<not> distinct\n                                  (map fst\n                                    (tl (ss_stack s)))) \\<longrightarrow>\n                         on_back_edge parami x1a x\n                          (s\\<lparr>ss_stack :=\n(x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>) \\<le>\\<^sub>n\n                         SUCCEED\n 3. \\<And>s x1 x2 x x1a x2a x1b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        fst ` set (ss_stack s) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; hd (ss_stack s) = (x1a, x2);\n        x2 \\<noteq> {}; x \\<in> x2;\n        x2a =\n        (Some x, s\n         \\<lparr>ss_stack := (x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>);\n        x1 = x1a; x1b = Some x;\n        x \\<notin> on_stack s \\<and> x \\<notin> visited s\\<rbrakk>\n       \\<Longrightarrow> (fst ` set (tl (ss_stack s))\n                          \\<subseteq> insert x (visited s) \\<longrightarrow>\n                          x1a \\<noteq> x \\<and> x1a \\<notin> visited s \\<or>\n                          x = x1a \\<or>\n                          x \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          x1a \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          \\<not> distinct\n                                  (map fst\n                                    (tl (ss_stack s)))) \\<longrightarrow>\n                         on_discover parami x1a x\n                          (s\\<lparr>ss_stack :=\n(x, a.E `` {x}) # (x1a, x2 - {x}) # tl (ss_stack s),\n                               on_stack := insert x (on_stack s),\n                               visited :=\n                                 insert x (visited s)\\<rparr>) \\<le>\\<^sub>n\n                         SUCCEED", "apply (fastforce simp: neq_Nil_conv) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x1 x2 x x1a x2a x1b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        fst ` set (ss_stack s) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; hd (ss_stack s) = (x1a, x2);\n        x2 \\<noteq> {}; x \\<in> x2;\n        x2a =\n        (Some x, s\n         \\<lparr>ss_stack := (x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>);\n        x1 = x1a; x1b = Some x; x \\<in> visited s;\n        x \\<in> on_stack s\\<rbrakk>\n       \\<Longrightarrow> (fst ` set (tl (ss_stack s))\n                          \\<subseteq> visited s \\<longrightarrow>\n                          x1a \\<in> visited s \\<longrightarrow>\n                          x1a \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          \\<not> distinct\n                                  (map fst\n                                    (tl (ss_stack s)))) \\<longrightarrow>\n                         on_back_edge parami x1a x\n                          (s\\<lparr>ss_stack :=\n(x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>) \\<le>\\<^sub>n\n                         SUCCEED\n 2. \\<And>s x1 x2 x x1a x2a x1b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        fst ` set (ss_stack s) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; hd (ss_stack s) = (x1a, x2);\n        x2 \\<noteq> {}; x \\<in> x2;\n        x2a =\n        (Some x, s\n         \\<lparr>ss_stack := (x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>);\n        x1 = x1a; x1b = Some x;\n        x \\<notin> on_stack s \\<and> x \\<notin> visited s\\<rbrakk>\n       \\<Longrightarrow> (fst ` set (tl (ss_stack s))\n                          \\<subseteq> insert x (visited s) \\<longrightarrow>\n                          x1a \\<noteq> x \\<and> x1a \\<notin> visited s \\<or>\n                          x = x1a \\<or>\n                          x \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          x1a \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          \\<not> distinct\n                                  (map fst\n                                    (tl (ss_stack s)))) \\<longrightarrow>\n                         on_discover parami x1a x\n                          (s\\<lparr>ss_stack :=\n(x, a.E `` {x}) # (x1a, x2 - {x}) # tl (ss_stack s),\n                               on_stack := insert x (on_stack s),\n                               visited :=\n                                 insert x (visited s)\\<rparr>) \\<le>\\<^sub>n\n                         SUCCEED", "apply (fastforce simp: neq_Nil_conv) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x1 x2 x x1a x2a x1b.\n       \\<lbrakk>rwof\n                 (on_init parami \\<bind>\n                  (\\<lambda>e.\n                      RETURN\n                       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                          \\<dots> = e\\<rparr>))\n                 c.gen_cond\n                 (\\<lambda>s.\n                     if ss_stack s = []\n                     then SPEC\n                           (\\<lambda>v0.\n                               v0 \\<in> a.V0 \\<and>\n                               v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>v0.\n                              ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = s\n  \\<lparr>ss_stack := [(v0, a.E `` {v0})]\\<rparr>;\ns = s\\<lparr>on_stack := {v0}\\<rparr>\n                                  in Let\n(s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))\n                     else ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              let (u, Vs) = hd (ss_stack s)\n                              in if Vs = {} then RETURN (u, None, s)\n                                 else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n(\\<lambda>v.\n    let Vs = Vs - {v};\n        s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n    in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                ASSERT\n                                 (ss_stack s \\<noteq> [] \\<and>\n                                  u \\<in> on_stack s) \\<bind>\n                                (\\<lambda>_.\n                                    let s = s\n    \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                    in Let\n  (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>) RETURN) \\<bind>\n                                (\\<lambda>s.\n                                    on_finish parami u s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                              | Some v \\<Rightarrow>\n                                  if v \\<in> visited s\n                                  then if v \\<in> visited s - on_stack s\n then RETURN s \\<bind>\n      (\\<lambda>s.\n          on_cross_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else RETURN s \\<bind>\n      (\\<lambda>s.\n          on_back_edge parami u v s \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                  else ASSERT\n  (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n (\\<lambda>_.\n     let s = s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s\\<rparr>;\n         s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n     in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n         RETURN) \\<bind>\n (\\<lambda>s.\n     on_discover parami u v s \\<bind>\n     (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))\n                 s;\n        fst ` set (ss_stack s) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s));\n        c.gen_cond s; ss_stack s \\<noteq> []; hd (ss_stack s) = (x1a, x2);\n        x2 \\<noteq> {}; x \\<in> x2;\n        x2a =\n        (Some x, s\n         \\<lparr>ss_stack := (x1a, x2 - {x}) # tl (ss_stack s)\\<rparr>);\n        x1 = x1a; x1b = Some x;\n        x \\<notin> on_stack s \\<and> x \\<notin> visited s\\<rbrakk>\n       \\<Longrightarrow> (fst ` set (tl (ss_stack s))\n                          \\<subseteq> insert x (visited s) \\<longrightarrow>\n                          x1a \\<noteq> x \\<and> x1a \\<notin> visited s \\<or>\n                          x = x1a \\<or>\n                          x \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          x1a \\<in> fst ` set (tl (ss_stack s)) \\<or>\n                          \\<not> distinct\n                                  (map fst\n                                    (tl (ss_stack s)))) \\<longrightarrow>\n                         on_discover parami x1a x\n                          (s\\<lparr>ss_stack :=\n(x, a.E `` {x}) # (x1a, x2 - {x}) # tl (ss_stack s),\n                               on_stack := insert x (on_stack s),\n                               visited :=\n                                 insert x (visited s)\\<rparr>) \\<le>\\<^sub>n\n                         SUCCEED", "apply (fastforce simp: neq_Nil_conv) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sublocale rec_impl G c.gds get_pending get_stack choose_pending"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rec_Impl.rec_impl G c.gds get_pending get_stack choose_pending", "apply unfold_locales"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>s. gds_is_empty_stack c.gds s = (get_stack s = [])\n 2. gds_init c.gds \\<le>\\<^sub>n\n    SPEC (\\<lambda>s. get_stack s = [] \\<and> get_pending s = {})\n 3. \\<And>v0 s.\n       c.pre_new_root v0 s \\<Longrightarrow>\n       gds_new_root c.gds v0 s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            get_stack s' = [v0] \\<and>\n            get_pending s' = {v0} \\<times> a.E `` {v0} \\<and>\n            c.gen_discovered s' = insert v0 (c.gen_discovered s))\n 4. \\<And>s.\n       c.pre_get_pending s \\<Longrightarrow>\n       (let u = hd (get_stack s)\n        in SELECT (\\<lambda>v. (u, v) \\<in> get_pending s) \\<bind>\n           (\\<lambda>vo.\n               choose_pending u vo s \\<bind>\n               (\\<lambda>s. RETURN (u, vo, s))))\n       \\<le> gds_get_pending c.gds s\n 5. \\<And>s u vo.\n       \\<lbrakk>c.pre_get_pending s; u = hd (get_stack s);\n        case vo of None \\<Rightarrow> get_pending s `` {u} = {}\n        | Some v \\<Rightarrow> v \\<in> get_pending s `` {u}\\<rbrakk>\n       \\<Longrightarrow> choose_pending u vo s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (case vo of\n                               None \\<Rightarrow>\n                                 get_pending s' = get_pending s\n                               | Some v \\<Rightarrow>\n                                   get_pending s' =\n                                   get_pending s - {(u, v)}) \\<and>\n                              get_stack s' = get_stack s \\<and>\n                              (\\<forall>x.\n                                  gds_is_discovered c.gds x s' =\n                                  gds_is_discovered c.gds x s))\n 6. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       gds_finish c.gds u s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            get_pending s' = get_pending s \\<and>\n            get_stack s' = tl (get_stack s) \\<and>\n            (\\<forall>x.\n                gds_is_discovered c.gds x s' = gds_is_discovered c.gds x s))\n 7. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       gds_cross_edge c.gds u v s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            get_pending s' = get_pending s \\<and>\n            get_stack s' = get_stack s \\<and>\n            (\\<forall>x.\n                gds_is_discovered c.gds x s' = gds_is_discovered c.gds x s))\n 8. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       gds_back_edge c.gds u v s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            get_pending s' = get_pending s \\<and>\n            get_stack s' = get_stack s \\<and>\n            (\\<forall>x.\n                gds_is_discovered c.gds x s' = gds_is_discovered c.gds x s))\n 9. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       gds_discover c.gds u v s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            get_pending s' =\n            get_pending s \\<union> {v} \\<times> a.E `` {v} \\<and>\n            get_stack s' = v # get_stack s \\<and>\n            c.gen_discovered s' = insert v (c.gen_discovered s))", "unfolding get_pending_def get_stack_def choose_pending_def"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>s. gds_is_empty_stack c.gds s = (map fst (ss_stack s) = [])\n 2. gds_init c.gds \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>s.\n         map fst (ss_stack s) = [] \\<and>\n         \\<Union>\n          (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) =\n         {})\n 3. \\<And>v0 s.\n       c.pre_new_root v0 s \\<Longrightarrow>\n       gds_new_root c.gds v0 s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            map fst (ss_stack s') = [v0] \\<and>\n            \\<Union>\n             (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n            {v0} \\<times> a.E `` {v0} \\<and>\n            c.gen_discovered s' = insert v0 (c.gen_discovered s))\n 4. \\<And>s.\n       c.pre_get_pending s \\<Longrightarrow>\n       (let u = hd (map fst (ss_stack s))\n        in SELECT\n            (\\<lambda>v.\n                (u, v)\n                \\<in> \\<Union>\n                       (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                              (ss_stack s)))) \\<bind>\n           (\\<lambda>vo.\n               (case vo of None \\<Rightarrow> RETURN s\n                | Some v \\<Rightarrow>\n                    ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                    (\\<lambda>_.\n                        let (u, Vs) = hd (ss_stack s)\n                        in RETURN\n                            (s\\<lparr>ss_stack :=\n  (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<bind>\n               (\\<lambda>s. RETURN (u, vo, s))))\n       \\<le> gds_get_pending c.gds s\n 5. \\<And>s u vo.\n       \\<lbrakk>c.pre_get_pending s; u = hd (map fst (ss_stack s));\n        case vo of\n        None \\<Rightarrow>\n          \\<Union>\n           (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) ``\n          {u} =\n          {}\n        | Some v \\<Rightarrow>\n            v \\<in> \\<Union>\n                     (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                            (ss_stack s))) ``\n                    {u}\\<rbrakk>\n       \\<Longrightarrow> (case vo of None \\<Rightarrow> RETURN s\n                          | Some v \\<Rightarrow>\n                              ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  let (u, Vs) = hd (ss_stack s)\n                                  in RETURN\n(s\\<lparr>ss_stack :=\n            (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (case vo of\n                               None \\<Rightarrow>\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s)))\n                               | Some v \\<Rightarrow>\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) -\n                                   {(u, v)}) \\<and>\n                              map fst (ss_stack s') =\n                              map fst (ss_stack s) \\<and>\n                              (\\<forall>x.\n                                  gds_is_discovered c.gds x s' =\n                                  gds_is_discovered c.gds x s))\n 6. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       gds_finish c.gds u s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            \\<Union>\n             (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n            \\<Union>\n             (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                    (ss_stack s))) \\<and>\n            map fst (ss_stack s') = tl (map fst (ss_stack s)) \\<and>\n            (\\<forall>x.\n                gds_is_discovered c.gds x s' = gds_is_discovered c.gds x s))\n 7. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       gds_cross_edge c.gds u v s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            \\<Union>\n             (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n            \\<Union>\n             (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                    (ss_stack s))) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x.\n                gds_is_discovered c.gds x s' = gds_is_discovered c.gds x s))\n 8. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       gds_back_edge c.gds u v s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            \\<Union>\n             (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n            \\<Union>\n             (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                    (ss_stack s))) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x.\n                gds_is_discovered c.gds x s' = gds_is_discovered c.gds x s))\n 9. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       gds_discover c.gds u v s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            \\<Union>\n             (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n            \\<Union>\n             (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                    (ss_stack s))) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            c.gen_discovered s' = insert v (c.gen_discovered s))", "apply (simp_all add: c.do_action_defs c.impl_defs[abs_def])"], ["proof (prove)\ngoal (8 subgoals):\n 1. on_init parami \\<bind>\n    (\\<lambda>e.\n        RETURN\n         \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n            \\<dots> = e\\<rparr>) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>s.\n         ss_stack s = [] \\<and>\n         (\\<forall>x\\<in>set (ss_stack s).\n             (case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) = {}))\n 2. \\<And>v0 s.\n       c.pre_new_root v0 s \\<Longrightarrow>\n       ASSERT (v0 \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_new_root parami v0\n            (s\\<lparr>ss_stack := [(v0, a.E `` {v0})], on_stack := {v0},\n                 visited := insert v0 (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := [(v0, a.E `` {v0})], on_stack := {v0},\n                     visited := insert v0 (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            map fst (ss_stack s') = [v0] \\<and>\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            {v0} \\<times> a.E `` {v0} \\<and>\n            visited s' = insert v0 (visited s))\n 3. \\<And>s.\n       c.pre_get_pending s \\<Longrightarrow>\n       SELECT\n        (\\<lambda>v.\n            \\<exists>x\\<in>set (ss_stack s).\n               (hd (map fst (ss_stack s)), v)\n               \\<in> (case x of\n                      (u, Vs) \\<Rightarrow> {u} \\<times> Vs)) \\<bind>\n       (\\<lambda>vo.\n           (case vo of None \\<Rightarrow> RETURN s\n            | Some v \\<Rightarrow>\n                ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                (\\<lambda>_.\n                    let (u, Vs) = hd (ss_stack s)\n                    in RETURN\n                        (s\\<lparr>ss_stack :=\n                                    (u, Vs - {v}) #\n                                    tl (ss_stack s)\\<rparr>))) \\<bind>\n           (\\<lambda>sa. RETURN (hd (map fst (ss_stack s)), vo, sa)))\n       \\<le> ASSERT (ss_stack s \\<noteq> []) \\<bind>\n             (\\<lambda>_.\n                 case hd (ss_stack s) of\n                 (u, Vs) \\<Rightarrow>\n                   if Vs = {} then RETURN (u, None, s)\n                   else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                        (\\<lambda>v.\n                            let Vs = Vs - {v};\n                                s = s\\<lparr>ss_stack :=\n         (u, Vs) # tl (ss_stack s)\\<rparr>\n                            in RETURN (u, Some v, s)))\n 4. \\<And>s u vo.\n       \\<lbrakk>c.pre_get_pending s; u = hd (map fst (ss_stack s));\n        case vo of\n        None \\<Rightarrow>\n          \\<Union>\n           (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) ``\n          {u} =\n          {}\n        | Some v \\<Rightarrow>\n            v \\<in> \\<Union>\n                     (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                            (ss_stack s))) ``\n                    {u}\\<rbrakk>\n       \\<Longrightarrow> (case vo of None \\<Rightarrow> RETURN s\n                          | Some v \\<Rightarrow>\n                              ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  let (u, Vs) = hd (ss_stack s)\n                                  in RETURN\n(s\\<lparr>ss_stack :=\n            (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (case vo of\n                               None \\<Rightarrow>\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s)))\n                               | Some v \\<Rightarrow>\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) -\n                                   {(u, v)}) \\<and>\n                              map fst (ss_stack s') =\n                              map fst (ss_stack s) \\<and>\n                              (\\<forall>x.\n                                  (x \\<in> visited s') =\n                                  (x \\<in> visited s)))\n 5. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = tl (map fst (ss_stack s)) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 6. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 7. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 8. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (auto simp: pw_leof_iff refine_pw_simps pw_le_iff select_def\n      split: prod.split) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>v0 s.\n       c.pre_new_root v0 s \\<Longrightarrow>\n       ASSERT (v0 \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_new_root parami v0\n            (s\\<lparr>ss_stack := [(v0, a.E `` {v0})], on_stack := {v0},\n                 visited := insert v0 (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := [(v0, a.E `` {v0})], on_stack := {v0},\n                     visited := insert v0 (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            map fst (ss_stack s') = [v0] \\<and>\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            {v0} \\<times> a.E `` {v0} \\<and>\n            visited s' = insert v0 (visited s))\n 2. \\<And>s.\n       c.pre_get_pending s \\<Longrightarrow>\n       SELECT\n        (\\<lambda>v.\n            \\<exists>x\\<in>set (ss_stack s).\n               (hd (map fst (ss_stack s)), v)\n               \\<in> (case x of\n                      (u, Vs) \\<Rightarrow> {u} \\<times> Vs)) \\<bind>\n       (\\<lambda>vo.\n           (case vo of None \\<Rightarrow> RETURN s\n            | Some v \\<Rightarrow>\n                ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                (\\<lambda>_.\n                    let (u, Vs) = hd (ss_stack s)\n                    in RETURN\n                        (s\\<lparr>ss_stack :=\n                                    (u, Vs - {v}) #\n                                    tl (ss_stack s)\\<rparr>))) \\<bind>\n           (\\<lambda>sa. RETURN (hd (map fst (ss_stack s)), vo, sa)))\n       \\<le> ASSERT (ss_stack s \\<noteq> []) \\<bind>\n             (\\<lambda>_.\n                 case hd (ss_stack s) of\n                 (u, Vs) \\<Rightarrow>\n                   if Vs = {} then RETURN (u, None, s)\n                   else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                        (\\<lambda>v.\n                            let Vs = Vs - {v};\n                                s = s\\<lparr>ss_stack :=\n         (u, Vs) # tl (ss_stack s)\\<rparr>\n                            in RETURN (u, Some v, s)))\n 3. \\<And>s u vo.\n       \\<lbrakk>c.pre_get_pending s; u = hd (map fst (ss_stack s));\n        case vo of\n        None \\<Rightarrow>\n          \\<Union>\n           (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) ``\n          {u} =\n          {}\n        | Some v \\<Rightarrow>\n            v \\<in> \\<Union>\n                     (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                            (ss_stack s))) ``\n                    {u}\\<rbrakk>\n       \\<Longrightarrow> (case vo of None \\<Rightarrow> RETURN s\n                          | Some v \\<Rightarrow>\n                              ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  let (u, Vs) = hd (ss_stack s)\n                                  in RETURN\n(s\\<lparr>ss_stack :=\n            (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (case vo of\n                               None \\<Rightarrow>\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s)))\n                               | Some v \\<Rightarrow>\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) -\n                                   {(u, v)}) \\<and>\n                              map fst (ss_stack s') =\n                              map fst (ss_stack s) \\<and>\n                              (\\<forall>x.\n                                  (x \\<in> visited s') =\n                                  (x \\<in> visited s)))\n 4. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = tl (map fst (ss_stack s)) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 5. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 6. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 7. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (auto simp: pw_leof_iff refine_pw_simps pw_le_iff select_def\n      split: prod.split) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s.\n       c.pre_get_pending s \\<Longrightarrow>\n       SELECT\n        (\\<lambda>v.\n            \\<exists>x\\<in>set (ss_stack s).\n               (hd (map fst (ss_stack s)), v)\n               \\<in> (case x of\n                      (u, Vs) \\<Rightarrow> {u} \\<times> Vs)) \\<bind>\n       (\\<lambda>vo.\n           (case vo of None \\<Rightarrow> RETURN s\n            | Some v \\<Rightarrow>\n                ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                (\\<lambda>_.\n                    let (u, Vs) = hd (ss_stack s)\n                    in RETURN\n                        (s\\<lparr>ss_stack :=\n                                    (u, Vs - {v}) #\n                                    tl (ss_stack s)\\<rparr>))) \\<bind>\n           (\\<lambda>sa. RETURN (hd (map fst (ss_stack s)), vo, sa)))\n       \\<le> ASSERT (ss_stack s \\<noteq> []) \\<bind>\n             (\\<lambda>_.\n                 case hd (ss_stack s) of\n                 (u, Vs) \\<Rightarrow>\n                   if Vs = {} then RETURN (u, None, s)\n                   else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                        (\\<lambda>v.\n                            let Vs = Vs - {v};\n                                s = s\\<lparr>ss_stack :=\n         (u, Vs) # tl (ss_stack s)\\<rparr>\n                            in RETURN (u, Some v, s)))\n 2. \\<And>s u vo.\n       \\<lbrakk>c.pre_get_pending s; u = hd (map fst (ss_stack s));\n        case vo of\n        None \\<Rightarrow>\n          \\<Union>\n           (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) ``\n          {u} =\n          {}\n        | Some v \\<Rightarrow>\n            v \\<in> \\<Union>\n                     (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                            (ss_stack s))) ``\n                    {u}\\<rbrakk>\n       \\<Longrightarrow> (case vo of None \\<Rightarrow> RETURN s\n                          | Some v \\<Rightarrow>\n                              ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  let (u, Vs) = hd (ss_stack s)\n                                  in RETURN\n(s\\<lparr>ss_stack :=\n            (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (case vo of\n                               None \\<Rightarrow>\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s)))\n                               | Some v \\<Rightarrow>\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) -\n                                   {(u, v)}) \\<and>\n                              map fst (ss_stack s') =\n                              map fst (ss_stack s) \\<and>\n                              (\\<forall>x.\n                                  (x \\<in> visited s') =\n                                  (x \\<in> visited s)))\n 3. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = tl (map fst (ss_stack s)) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 4. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 5. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 6. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (rule le_ASSERTI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>c.pre_get_pending s; ss_stack s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> SELECT\n                          (\\<lambda>v.\n                              \\<exists>x\\<in>set (ss_stack s).\n                                 (hd (map fst (ss_stack s)), v)\n                                 \\<in> (case x of\n  (u, Vs) \\<Rightarrow> {u} \\<times> Vs)) \\<bind>\n                         (\\<lambda>vo.\n                             (case vo of None \\<Rightarrow> RETURN s\n                              | Some v \\<Rightarrow>\n                                  ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                  (\\<lambda>_.\nlet (u, Vs) = hd (ss_stack s)\nin RETURN\n    (s\\<lparr>ss_stack := (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<bind>\n                             (\\<lambda>sa.\n                                 RETURN\n                                  (hd (map fst (ss_stack s)), vo, sa)))\n                         \\<le> (case hd (ss_stack s) of\n                                (u, Vs) \\<Rightarrow>\n                                  if Vs = {} then RETURN (u, None, s)\n                                  else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n (\\<lambda>v.\n     let Vs = Vs - {v};\n         s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n     in RETURN (u, Some v, s)))\n 2. \\<And>s u vo.\n       \\<lbrakk>c.pre_get_pending s; u = hd (map fst (ss_stack s));\n        case vo of\n        None \\<Rightarrow>\n          \\<Union>\n           (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) ``\n          {u} =\n          {}\n        | Some v \\<Rightarrow>\n            v \\<in> \\<Union>\n                     (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                            (ss_stack s))) ``\n                    {u}\\<rbrakk>\n       \\<Longrightarrow> (case vo of None \\<Rightarrow> RETURN s\n                          | Some v \\<Rightarrow>\n                              ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  let (u, Vs) = hd (ss_stack s)\n                                  in RETURN\n(s\\<lparr>ss_stack :=\n            (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (case vo of\n                               None \\<Rightarrow>\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s)))\n                               | Some v \\<Rightarrow>\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) -\n                                   {(u, v)}) \\<and>\n                              map fst (ss_stack s') =\n                              map fst (ss_stack s) \\<and>\n                              (\\<forall>x.\n                                  (x \\<in> visited s') =\n                                  (x \\<in> visited s)))\n 3. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = tl (map fst (ss_stack s)) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 4. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 5. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 6. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (unfold c.pre_defs, clarify) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>ss_stack s \\<noteq> []; c.gen_rwof s;\n        \\<not> gds_is_empty_stack c.gds s;\n        \\<not> gds_is_break c.gds s\\<rbrakk>\n       \\<Longrightarrow> SELECT\n                          (\\<lambda>v.\n                              \\<exists>x\\<in>set (ss_stack s).\n                                 (hd (map fst (ss_stack s)), v)\n                                 \\<in> (case x of\n  (u, Vs) \\<Rightarrow> {u} \\<times> Vs)) \\<bind>\n                         (\\<lambda>vo.\n                             (case vo of None \\<Rightarrow> RETURN s\n                              | Some v \\<Rightarrow>\n                                  ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                  (\\<lambda>_.\nlet (u, Vs) = hd (ss_stack s)\nin RETURN\n    (s\\<lparr>ss_stack := (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<bind>\n                             (\\<lambda>sa.\n                                 RETURN\n                                  (hd (map fst (ss_stack s)), vo, sa)))\n                         \\<le> (case hd (ss_stack s) of\n                                (u, Vs) \\<Rightarrow>\n                                  if Vs = {} then RETURN (u, None, s)\n                                  else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n (\\<lambda>v.\n     let Vs = Vs - {v};\n         s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n     in RETURN (u, Some v, s)))\n 2. \\<And>s u vo.\n       \\<lbrakk>c.pre_get_pending s; u = hd (map fst (ss_stack s));\n        case vo of\n        None \\<Rightarrow>\n          \\<Union>\n           (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) ``\n          {u} =\n          {}\n        | Some v \\<Rightarrow>\n            v \\<in> \\<Union>\n                     (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                            (ss_stack s))) ``\n                    {u}\\<rbrakk>\n       \\<Longrightarrow> (case vo of None \\<Rightarrow> RETURN s\n                          | Some v \\<Rightarrow>\n                              ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  let (u, Vs) = hd (ss_stack s)\n                                  in RETURN\n(s\\<lparr>ss_stack :=\n            (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (case vo of\n                               None \\<Rightarrow>\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s)))\n                               | Some v \\<Rightarrow>\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) -\n                                   {(u, v)}) \\<and>\n                              map fst (ss_stack s') =\n                              map fst (ss_stack s) \\<and>\n                              (\\<forall>x.\n                                  (x \\<in> visited s') =\n                                  (x \\<in> visited s)))\n 3. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = tl (map fst (ss_stack s)) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 4. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 5. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 6. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (frule reachable_invar)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>ss_stack s \\<noteq> []; c.gen_rwof s;\n        \\<not> gds_is_empty_stack c.gds s; \\<not> gds_is_break c.gds s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s))\\<rbrakk>\n       \\<Longrightarrow> SELECT\n                          (\\<lambda>v.\n                              \\<exists>x\\<in>set (ss_stack s).\n                                 (hd (map fst (ss_stack s)), v)\n                                 \\<in> (case x of\n  (u, Vs) \\<Rightarrow> {u} \\<times> Vs)) \\<bind>\n                         (\\<lambda>vo.\n                             (case vo of None \\<Rightarrow> RETURN s\n                              | Some v \\<Rightarrow>\n                                  ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                                  (\\<lambda>_.\nlet (u, Vs) = hd (ss_stack s)\nin RETURN\n    (s\\<lparr>ss_stack := (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<bind>\n                             (\\<lambda>sa.\n                                 RETURN\n                                  (hd (map fst (ss_stack s)), vo, sa)))\n                         \\<le> (case hd (ss_stack s) of\n                                (u, Vs) \\<Rightarrow>\n                                  if Vs = {} then RETURN (u, None, s)\n                                  else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n (\\<lambda>v.\n     let Vs = Vs - {v};\n         s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n     in RETURN (u, Some v, s)))\n 2. \\<And>s u vo.\n       \\<lbrakk>c.pre_get_pending s; u = hd (map fst (ss_stack s));\n        case vo of\n        None \\<Rightarrow>\n          \\<Union>\n           (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) ``\n          {u} =\n          {}\n        | Some v \\<Rightarrow>\n            v \\<in> \\<Union>\n                     (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                            (ss_stack s))) ``\n                    {u}\\<rbrakk>\n       \\<Longrightarrow> (case vo of None \\<Rightarrow> RETURN s\n                          | Some v \\<Rightarrow>\n                              ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  let (u, Vs) = hd (ss_stack s)\n                                  in RETURN\n(s\\<lparr>ss_stack :=\n            (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (case vo of\n                               None \\<Rightarrow>\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s)))\n                               | Some v \\<Rightarrow>\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) -\n                                   {(u, v)}) \\<and>\n                              map fst (ss_stack s') =\n                              map fst (ss_stack s) \\<and>\n                              (\\<forall>x.\n                                  (x \\<in> visited s') =\n                                  (x \\<in> visited s)))\n 3. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = tl (map fst (ss_stack s)) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 4. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 5. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 6. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (fastforce simp add: pw_leof_iff refine_pw_simps pw_le_iff neq_Nil_conv\n      split: prod.split option.split) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s u vo.\n       \\<lbrakk>c.pre_get_pending s; u = hd (map fst (ss_stack s));\n        case vo of\n        None \\<Rightarrow>\n          \\<Union>\n           (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) ``\n          {u} =\n          {}\n        | Some v \\<Rightarrow>\n            v \\<in> \\<Union>\n                     (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                            (ss_stack s))) ``\n                    {u}\\<rbrakk>\n       \\<Longrightarrow> (case vo of None \\<Rightarrow> RETURN s\n                          | Some v \\<Rightarrow>\n                              ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  let (u, Vs) = hd (ss_stack s)\n                                  in RETURN\n(s\\<lparr>ss_stack :=\n            (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (case vo of\n                               None \\<Rightarrow>\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s)))\n                               | Some v \\<Rightarrow>\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) -\n                                   {(u, v)}) \\<and>\n                              map fst (ss_stack s') =\n                              map fst (ss_stack s) \\<and>\n                              (\\<forall>x.\n                                  (x \\<in> visited s') =\n                                  (x \\<in> visited s)))\n 2. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = tl (map fst (ss_stack s)) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 3. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 4. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 5. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (unfold c.pre_defs, clarify) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s u vo.\n       \\<lbrakk>case vo of\n                None \\<Rightarrow>\n                  \\<Union>\n                   (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                          (ss_stack s))) ``\n                  {hd (map fst (ss_stack s))} =\n                  {}\n                | Some v \\<Rightarrow>\n                    v \\<in> \\<Union>\n                             (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                                    (ss_stack s))) ``\n                            {hd (map fst (ss_stack s))};\n        c.gen_rwof s; \\<not> gds_is_empty_stack c.gds s;\n        \\<not> gds_is_break c.gds s\\<rbrakk>\n       \\<Longrightarrow> (case vo of None \\<Rightarrow> RETURN s\n                          | Some v \\<Rightarrow>\n                              ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  let (u, Vs) = hd (ss_stack s)\n                                  in RETURN\n(s\\<lparr>ss_stack :=\n            (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (case vo of\n                               None \\<Rightarrow>\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s)))\n                               | Some v \\<Rightarrow>\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) -\n                                   {(hd (map fst (ss_stack s)), v)}) \\<and>\n                              map fst (ss_stack s') =\n                              map fst (ss_stack s) \\<and>\n                              (\\<forall>x.\n                                  (x \\<in> visited s') =\n                                  (x \\<in> visited s)))\n 2. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = tl (map fst (ss_stack s)) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 3. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 4. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 5. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (frule reachable_invar)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s u vo.\n       \\<lbrakk>case vo of\n                None \\<Rightarrow>\n                  \\<Union>\n                   (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                          (ss_stack s))) ``\n                  {hd (map fst (ss_stack s))} =\n                  {}\n                | Some v \\<Rightarrow>\n                    v \\<in> \\<Union>\n                             (set (map (\\<lambda>(u, Vs). {u} \\<times> Vs)\n                                    (ss_stack s))) ``\n                            {hd (map fst (ss_stack s))};\n        c.gen_rwof s; \\<not> gds_is_empty_stack c.gds s;\n        \\<not> gds_is_break c.gds s;\n        set (map fst (ss_stack s)) \\<subseteq> visited s \\<and>\n        distinct (map fst (ss_stack s))\\<rbrakk>\n       \\<Longrightarrow> (case vo of None \\<Rightarrow> RETURN s\n                          | Some v \\<Rightarrow>\n                              ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  let (u, Vs) = hd (ss_stack s)\n                                  in RETURN\n(s\\<lparr>ss_stack :=\n            (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>s'.\n                              (case vo of\n                               None \\<Rightarrow>\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                 \\<Union>\n                                  (set (map\n   (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s)))\n                               | Some v \\<Rightarrow>\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s'))) =\n                                   \\<Union>\n                                    (set\n(map (\\<lambda>(u, Vs). {u} \\<times> Vs) (ss_stack s))) -\n                                   {(hd (map fst (ss_stack s)), v)}) \\<and>\n                              map fst (ss_stack s') =\n                              map fst (ss_stack s) \\<and>\n                              (\\<forall>x.\n                                  (x \\<in> visited s') =\n                                  (x \\<in> visited s)))\n 2. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = tl (map fst (ss_stack s)) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 3. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 4. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 5. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (auto simp: pw_leof_iff refine_pw_simps pw_le_iff select_def c.impl_defs neq_Nil_conv\n      split: prod.split option.split) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u s0 s.\n       c.pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = tl (map fst (ss_stack s)) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 2. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 3. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 4. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (auto simp: pw_leof_iff refine_pw_simps pw_le_iff select_def neq_Nil_conv c.pre_defs c.impl_defs\n      split: prod.split if_split_asm) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u v s0 s.\n       c.pre_cross_edge u v s0 s \\<Longrightarrow>\n       on_cross_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 2. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 3. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (auto simp: pw_leof_iff refine_pw_simps pw_le_iff split: prod.split) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v s0 s.\n       c.pre_back_edge u v s0 s \\<Longrightarrow>\n       on_back_edge parami u v s \\<bind>\n       (\\<lambda>e.\n           RETURN (s\\<lparr>simple_state.more := e\\<rparr>)) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<and>\n            map fst (ss_stack s') = map fst (ss_stack s) \\<and>\n            (\\<forall>x. (x \\<in> visited s') = (x \\<in> visited s)))\n 2. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (auto simp: pw_leof_iff refine_pw_simps pw_le_iff split: prod.split) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v s0 s.\n       c.pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, a.E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            (\\<Union>x\\<in>set (ss_stack s').\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) =\n            (\\<Union>x\\<in>set (ss_stack s).\n                case x of (u, Vs) \\<Rightarrow> {u} \\<times> Vs) \\<union>\n            {v} \\<times> a.E `` {v} \\<and>\n            map fst (ss_stack s') = v # map fst (ss_stack s) \\<and>\n            visited s' = insert v (visited s))", "apply (auto simp: pw_leof_iff refine_pw_simps pw_le_iff split: prod.split) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma simple_rec_refine[refine]: \"rec_impl \\<le> \\<Down>(\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.rec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "note rec_impl"], ["proof (state)\nthis:\n  local.rec_impl \\<le> c.gen_dfs\n\ngoal (1 subgoal):\n 1. local.rec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "also"], ["proof (state)\nthis:\n  local.rec_impl \\<le> c.gen_dfs\n\ngoal (1 subgoal):\n 1. local.rec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "note simple_refine"], ["proof (state)\nthis:\n  c.gen_dfs \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\n\ngoal (1 subgoal):\n 1. local.rec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "finally"], ["proof (chain)\npicking this:\n  local.rec_impl\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "show ?thesis"], ["proof (prove)\nusing this:\n  local.rec_impl\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\n\ngoal (1 subgoal):\n 1. local.rec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs", "."], ["proof (state)\nthis:\n  local.rec_impl\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.it_dfs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open> Autoref Setup \\<close>"], ["", "record ('si,'nsi)simple_state_impl =\n  ss_stack_impl :: 'si\n  ss_on_stack_impl :: 'nsi\n  ss_visited_impl :: 'nsi"], ["", "definition [to_relAPP]: \"ss_impl_rel s_rel vis_rel erel \\<equiv> \n  {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi, ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n    \\<lparr>ss_stack = s, on_stack = os, visited = vis, \\<dots> = m\\<rparr>) |\n    si osi visi mi s os vis m.\n    (si, s) \\<in> s_rel \\<and>\n    (osi, os) \\<in> vis_rel \\<and>\n    (visi, vis) \\<in> vis_rel \\<and>\n    (mi, m) \\<in> erel\n  }\""], ["", "consts \n  i_simple_state :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of ss_impl_rel i_simple_state]"], ["", "term simple_state_ext"], ["", "lemma [autoref_rules, param]:\n  fixes s_rel ps_rel vis_rel erel\n  defines \"R \\<equiv> \\<langle>s_rel,vis_rel,erel\\<rangle>ss_impl_rel\"\n  shows\n  \"(ss_stack_impl, ss_stack) \\<in>  R \\<rightarrow> s_rel\"\n  \"(ss_on_stack_impl, on_stack) \\<in>  R \\<rightarrow> vis_rel\"\n  \"(ss_visited_impl, visited) \\<in> R \\<rightarrow> vis_rel\"\n  \"(simple_state_impl.more, simple_state.more) \\<in> R \\<rightarrow> erel\"\n  \"(ss_stack_impl_update, ss_stack_update) \\<in> (s_rel \\<rightarrow> s_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(ss_on_stack_impl_update, on_stack_update) \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(ss_visited_impl_update, visited_update) \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(simple_state_impl.more_update, simple_state.more_update) \\<in> (erel \\<rightarrow> erel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(simple_state_impl_ext, simple_state_ext) \\<in> s_rel \\<rightarrow> vis_rel \\<rightarrow> vis_rel \\<rightarrow> erel \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((ss_stack_impl, ss_stack) \\<in> R \\<rightarrow> s_rel &&&\n      (ss_on_stack_impl, on_stack) \\<in> R \\<rightarrow> vis_rel) &&&\n     (ss_visited_impl, visited) \\<in> R \\<rightarrow> vis_rel &&&\n     (simple_state_impl.more, simple_state.more)\n     \\<in> R \\<rightarrow> erel) &&&\n    ((ss_stack_impl_update, ss_stack_update)\n     \\<in> (s_rel \\<rightarrow> s_rel) \\<rightarrow> R \\<rightarrow> R &&&\n     (ss_on_stack_impl_update, on_stack_update)\n     \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow>\n           R \\<rightarrow> R) &&&\n    (ss_visited_impl_update, visited_update)\n    \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow>\n          R \\<rightarrow> R &&&\n    (simple_state_impl.more_update, simple_state.more_update)\n    \\<in> (erel \\<rightarrow> erel) \\<rightarrow> R \\<rightarrow> R &&&\n    (simple_state_impl_ext, simple_state_ext)\n    \\<in> s_rel \\<rightarrow>\n          vis_rel \\<rightarrow> vis_rel \\<rightarrow> erel \\<rightarrow> R", "unfolding ss_impl_rel_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((ss_stack_impl, ss_stack)\n      \\<in> {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n                 ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n              \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                 \\<dots> = m\\<rparr>) |\n             si osi visi mi s os vis m.\n             (si, s) \\<in> s_rel \\<and>\n             (osi, os) \\<in> vis_rel \\<and>\n             (visi, vis) \\<in> vis_rel \\<and>\n             (mi, m) \\<in> erel} \\<rightarrow>\n            s_rel &&&\n      (ss_on_stack_impl, on_stack)\n      \\<in> {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n                 ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n              \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                 \\<dots> = m\\<rparr>) |\n             si osi visi mi s os vis m.\n             (si, s) \\<in> s_rel \\<and>\n             (osi, os) \\<in> vis_rel \\<and>\n             (visi, vis) \\<in> vis_rel \\<and>\n             (mi, m) \\<in> erel} \\<rightarrow>\n            vis_rel) &&&\n     (ss_visited_impl, visited)\n     \\<in> {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n                ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si osi visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (osi, os) \\<in> vis_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and>\n            (mi, m) \\<in> erel} \\<rightarrow>\n           vis_rel &&&\n     (simple_state_impl.more, simple_state.more)\n     \\<in> {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n                ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si osi visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (osi, os) \\<in> vis_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and>\n            (mi, m) \\<in> erel} \\<rightarrow>\n           erel) &&&\n    ((ss_stack_impl_update, ss_stack_update)\n     \\<in> (s_rel \\<rightarrow> s_rel) \\<rightarrow>\n           {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n                ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si osi visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (osi, os) \\<in> vis_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and>\n            (mi, m) \\<in> erel} \\<rightarrow>\n           {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n                ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si osi visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (osi, os) \\<in> vis_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel} &&&\n     (ss_on_stack_impl_update, on_stack_update)\n     \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow>\n           {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n                ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si osi visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (osi, os) \\<in> vis_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and>\n            (mi, m) \\<in> erel} \\<rightarrow>\n           {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n                ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si osi visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (osi, os) \\<in> vis_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel}) &&&\n    (ss_visited_impl_update, visited_update)\n    \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow>\n          {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n               ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si osi visi mi s os vis m.\n           (si, s) \\<in> s_rel \\<and>\n           (osi, os) \\<in> vis_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and>\n           (mi, m) \\<in> erel} \\<rightarrow>\n          {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n               ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si osi visi mi s os vis m.\n           (si, s) \\<in> s_rel \\<and>\n           (osi, os) \\<in> vis_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel} &&&\n    (simple_state_impl.more_update, simple_state.more_update)\n    \\<in> (erel \\<rightarrow> erel) \\<rightarrow>\n          {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n               ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si osi visi mi s os vis m.\n           (si, s) \\<in> s_rel \\<and>\n           (osi, os) \\<in> vis_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and>\n           (mi, m) \\<in> erel} \\<rightarrow>\n          {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n               ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si osi visi mi s os vis m.\n           (si, s) \\<in> s_rel \\<and>\n           (osi, os) \\<in> vis_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel} &&&\n    (simple_state_impl_ext, simple_state_ext)\n    \\<in> s_rel \\<rightarrow>\n          vis_rel \\<rightarrow>\n          vis_rel \\<rightarrow>\n          erel \\<rightarrow>\n          {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n               ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si osi visi mi s os vis m.\n           (si, s) \\<in> s_rel \\<and>\n           (osi, os) \\<in> vis_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel}", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' si osi visi mi s os vis m.\n       \\<lbrakk>(a, a') \\<in> s_rel \\<rightarrow> s_rel;\n        (si, s) \\<in> s_rel; (osi, os) \\<in> vis_rel;\n        (visi, vis) \\<in> vis_rel; (mi, m) \\<in> erel\\<rbrakk>\n       \\<Longrightarrow> (a si, a' s) \\<in> s_rel\n 2. \\<And>a a' si osi visi mi s os vis m.\n       \\<lbrakk>(a, a') \\<in> vis_rel \\<rightarrow> vis_rel;\n        (si, s) \\<in> s_rel; (osi, os) \\<in> vis_rel;\n        (visi, vis) \\<in> vis_rel; (mi, m) \\<in> erel\\<rbrakk>\n       \\<Longrightarrow> (a osi, a' os) \\<in> vis_rel\n 3. \\<And>a a' si osi visi mi s os vis m.\n       \\<lbrakk>(a, a') \\<in> vis_rel \\<rightarrow> vis_rel;\n        (si, s) \\<in> s_rel; (osi, os) \\<in> vis_rel;\n        (visi, vis) \\<in> vis_rel; (mi, m) \\<in> erel\\<rbrakk>\n       \\<Longrightarrow> (a visi, a' vis) \\<in> vis_rel\n 4. \\<And>a a' si osi visi mi s os vis m.\n       \\<lbrakk>(a, a') \\<in> erel \\<rightarrow> erel; (si, s) \\<in> s_rel;\n        (osi, os) \\<in> vis_rel; (visi, vis) \\<in> vis_rel;\n        (mi, m) \\<in> erel\\<rbrakk>\n       \\<Longrightarrow> (a mi, a' m) \\<in> erel", "apply parametricity+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Simple state without on-stack \\<close>"], ["", "text \\<open> We can further refine the simple implementation and drop the on-stack set \\<close>"], ["", "record ('si,'nsi)simple_state_nos_impl =\n  ssnos_stack_impl :: 'si\n  ssnos_visited_impl :: 'nsi"], ["", "definition [to_relAPP]: \"ssnos_impl_rel s_rel vis_rel erel \\<equiv> \n  {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi, \\<dots> = mi\\<rparr>,\n    \\<lparr>ss_stack = s, on_stack = os, visited = vis, \\<dots> = m\\<rparr>) |\n    si visi mi s os vis m.\n    (si, s) \\<in> s_rel \\<and>\n    (visi, vis) \\<in> vis_rel \\<and>\n    (mi, m) \\<in> erel\n  }\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of ssnos_impl_rel i_simple_state]"], ["", "definition op_nos_on_stack_update \n  :: \"(_ set \\<Rightarrow> _ set) \\<Rightarrow> (_,_)simple_state_scheme \\<Rightarrow> _\"\n  where \"op_nos_on_stack_update \\<equiv> on_stack_update\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat_def]: \"op_nos_on_stack_update f s \n  \\<equiv> OP (op_nos_on_stack_update f)$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_nos_on_stack_update f s \\<equiv> OP (op_nos_on_stack_update f) $ s", "by simp"], ["", "end"], ["", "lemmas ssnos_unfolds \\<comment> \\<open>To be unfolded before autoref when using @{term ssnos_impl_rel}\\<close>\n  = op_nos_on_stack_update_def[symmetric]"], ["", "lemma [autoref_rules, param]:\n  fixes s_rel vis_rel erel\n  defines \"R \\<equiv> \\<langle>s_rel,vis_rel,erel\\<rangle>ssnos_impl_rel\"\n  shows\n  \"(ssnos_stack_impl, ss_stack) \\<in>  R \\<rightarrow> s_rel\"\n  \"(ssnos_visited_impl, visited) \\<in> R \\<rightarrow> vis_rel\"\n  \"(simple_state_nos_impl.more, simple_state.more) \\<in> R \\<rightarrow> erel\"\n  \"(ssnos_stack_impl_update, ss_stack_update) \\<in> (s_rel \\<rightarrow> s_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(\\<lambda>x. x, op_nos_on_stack_update f) \\<in> R \\<rightarrow> R\"\n  \"(ssnos_visited_impl_update, visited_update) \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(simple_state_nos_impl.more_update, simple_state.more_update) \\<in> (erel \\<rightarrow> erel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(\\<lambda>ns _ ps vs. simple_state_nos_impl_ext ns ps vs, simple_state_ext) \n    \\<in> s_rel \\<rightarrow> ANY_rel \\<rightarrow> vis_rel \\<rightarrow> erel \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((ssnos_stack_impl, ss_stack) \\<in> R \\<rightarrow> s_rel &&&\n      (ssnos_visited_impl, visited) \\<in> R \\<rightarrow> vis_rel) &&&\n     (simple_state_nos_impl.more, simple_state.more)\n     \\<in> R \\<rightarrow> erel &&&\n     (ssnos_stack_impl_update, ss_stack_update)\n     \\<in> (s_rel \\<rightarrow> s_rel) \\<rightarrow> R \\<rightarrow> R) &&&\n    ((\\<lambda>x. x, op_nos_on_stack_update f) \\<in> R \\<rightarrow> R &&&\n     (ssnos_visited_impl_update, visited_update)\n     \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow>\n           R \\<rightarrow> R) &&&\n    (simple_state_nos_impl.more_update, simple_state.more_update)\n    \\<in> (erel \\<rightarrow> erel) \\<rightarrow> R \\<rightarrow> R &&&\n    (\\<lambda>ns _. simple_state_nos_impl_ext ns, simple_state_ext)\n    \\<in> s_rel \\<rightarrow>\n          ANY_rel \\<rightarrow> vis_rel \\<rightarrow> erel \\<rightarrow> R", "unfolding ssnos_impl_rel_def R_def op_nos_on_stack_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((ssnos_stack_impl, ss_stack)\n      \\<in> {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n                 \\<dots> = mi\\<rparr>,\n              \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                 \\<dots> = m\\<rparr>) |\n             si visi mi s os vis m.\n             (si, s) \\<in> s_rel \\<and>\n             (visi, vis) \\<in> vis_rel \\<and>\n             (mi, m) \\<in> erel} \\<rightarrow>\n            s_rel &&&\n      (ssnos_visited_impl, visited)\n      \\<in> {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n                 \\<dots> = mi\\<rparr>,\n              \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                 \\<dots> = m\\<rparr>) |\n             si visi mi s os vis m.\n             (si, s) \\<in> s_rel \\<and>\n             (visi, vis) \\<in> vis_rel \\<and>\n             (mi, m) \\<in> erel} \\<rightarrow>\n            vis_rel) &&&\n     (simple_state_nos_impl.more, simple_state.more)\n     \\<in> {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n                \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and>\n            (mi, m) \\<in> erel} \\<rightarrow>\n           erel &&&\n     (ssnos_stack_impl_update, ss_stack_update)\n     \\<in> (s_rel \\<rightarrow> s_rel) \\<rightarrow>\n           {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n                \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and>\n            (mi, m) \\<in> erel} \\<rightarrow>\n           {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n                \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel}) &&&\n    ((\\<lambda>x. x, on_stack_update f)\n     \\<in> {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n                \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and>\n            (mi, m) \\<in> erel} \\<rightarrow>\n           {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n                \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel} &&&\n     (ssnos_visited_impl_update, visited_update)\n     \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow>\n           {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n                \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and>\n            (mi, m) \\<in> erel} \\<rightarrow>\n           {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n                \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            si visi mi s os vis m.\n            (si, s) \\<in> s_rel \\<and>\n            (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel}) &&&\n    (simple_state_nos_impl.more_update, simple_state.more_update)\n    \\<in> (erel \\<rightarrow> erel) \\<rightarrow>\n          {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n               \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si visi mi s os vis m.\n           (si, s) \\<in> s_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and>\n           (mi, m) \\<in> erel} \\<rightarrow>\n          {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n               \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si visi mi s os vis m.\n           (si, s) \\<in> s_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel} &&&\n    (\\<lambda>ns _. simple_state_nos_impl_ext ns, simple_state_ext)\n    \\<in> s_rel \\<rightarrow>\n          ANY_rel \\<rightarrow>\n          vis_rel \\<rightarrow>\n          erel \\<rightarrow>\n          {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n               \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si visi mi s os vis m.\n           (si, s) \\<in> s_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel}", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' si visi mi s vis m.\n       \\<lbrakk>(a, a') \\<in> s_rel \\<rightarrow> s_rel;\n        (si, s) \\<in> s_rel; (visi, vis) \\<in> vis_rel;\n        (mi, m) \\<in> erel\\<rbrakk>\n       \\<Longrightarrow> (a si, a' s) \\<in> s_rel\n 2. \\<And>a a' si visi mi s vis m.\n       \\<lbrakk>(a, a') \\<in> vis_rel \\<rightarrow> vis_rel;\n        (si, s) \\<in> s_rel; (visi, vis) \\<in> vis_rel;\n        (mi, m) \\<in> erel\\<rbrakk>\n       \\<Longrightarrow> (a visi, a' vis) \\<in> vis_rel\n 3. \\<And>a a' si visi mi s vis m.\n       \\<lbrakk>(a, a') \\<in> erel \\<rightarrow> erel; (si, s) \\<in> s_rel;\n        (visi, vis) \\<in> vis_rel; (mi, m) \\<in> erel\\<rbrakk>\n       \\<Longrightarrow> (a mi, a' m) \\<in> erel", "apply parametricity+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Simple state without stack and on-stack\\<close>"], ["", "text \\<open>Even further refinement yields an implementation without a stack.\n  Note that this only works for structural implementations that provide their own\n  stack (e.g., recursive)!\\<close>"], ["", "record ('si,'nsi)simple_state_ns_impl =\n  ssns_visited_impl :: 'nsi"], ["", "definition [to_relAPP]: \"ssns_impl_rel (R::('a\\<times>'b) set) vis_rel erel \\<equiv> \n  {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n    \\<lparr>ss_stack = s, on_stack = os, visited = vis, \\<dots> = m\\<rparr>) |\n    visi mi s os vis m.\n    (visi, vis) \\<in> vis_rel \\<and>\n    (mi, m) \\<in> erel\n  }\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of ssns_impl_rel i_simple_state]"], ["", "definition op_ns_on_stack_update \n  :: \"(_ set \\<Rightarrow> _ set) \\<Rightarrow> (_,_)simple_state_scheme \\<Rightarrow> _\"\n  where \"op_ns_on_stack_update \\<equiv> on_stack_update\""], ["", "definition op_ns_stack_update \n  :: \"(_ list \\<Rightarrow> _ list) \\<Rightarrow> (_,_)simple_state_scheme \\<Rightarrow> _\"\n  where \"op_ns_stack_update \\<equiv> ss_stack_update\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat_def]: \"op_ns_on_stack_update f s \n  \\<equiv> OP (op_ns_on_stack_update f)$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_ns_on_stack_update f s \\<equiv> OP (op_ns_on_stack_update f) $ s", "by simp"], ["", "lemma [autoref_op_pat_def]: \"op_ns_stack_update f s \n  \\<equiv> OP (op_ns_stack_update f)$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_ns_stack_update f s \\<equiv> OP (op_ns_stack_update f) $ s", "by simp"], ["", "end"], ["", "context simple_impl_defs begin"], ["", "thm choose_pending_def[unfolded op_ns_stack_update_def[symmetric], no_vars]"], ["", "lemma choose_pending_ns_unfold: \"choose_pending u vo s = (\n    case vo of None \\<Rightarrow> RETURN s\n    | Some v \\<Rightarrow> do {\n          _ \\<leftarrow> ASSERT (ss_stack s \\<noteq> []);\n          RETURN\n           (op_ns_stack_update \n             ( let \n                 (u, Vs) = hd (ss_stack s) \n               in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s))\n             )\n             s\n           )\n        })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_pending u vo s =\n    (case vo of None \\<Rightarrow> RETURN s\n     | Some v \\<Rightarrow>\n         ASSERT (ss_stack s \\<noteq> []) \\<bind>\n         (\\<lambda>_.\n             RETURN\n              (op_ns_stack_update\n                (let (u, Vs) = hd (ss_stack s)\n                 in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s)))\n                s)))", "unfolding choose_pending_def op_ns_stack_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case vo of None \\<Rightarrow> RETURN s\n     | Some v \\<Rightarrow>\n         ASSERT (ss_stack s \\<noteq> []) \\<bind>\n         (\\<lambda>_.\n             let (u, Vs) = hd (ss_stack s)\n             in RETURN\n                 (s\\<lparr>ss_stack :=\n                             (u, Vs - {v}) # tl (ss_stack s)\\<rparr>))) =\n    (case vo of None \\<Rightarrow> RETURN s\n     | Some v \\<Rightarrow>\n         ASSERT (ss_stack s \\<noteq> []) \\<bind>\n         (\\<lambda>_.\n             RETURN\n              (ss_stack_update\n                (let (u, Vs) = hd (ss_stack s)\n                 in (\\<lambda>_. (u, Vs - {v}) # tl (ss_stack s)))\n                s)))", "by (auto split: option.split prod.split)"], ["", "lemmas ssns_unfolds \\<comment> \\<open>To be unfolded before autoref when using @{term ssns_impl_rel}.\n    Attention: This lemma conflicts with the standard unfolding lemma in \n    @{text DFS_code_unfold}, so has to be placed first in an unfold-statement!\\<close>\n  = op_ns_on_stack_update_def[symmetric] op_ns_stack_update_def[symmetric]\n    choose_pending_ns_unfold"], ["", "end"], ["", "lemma [autoref_rules, param]:\n  fixes s_rel vis_rel erel ANY_rel\n  defines \"R \\<equiv> \\<langle>ANY_rel,vis_rel,erel\\<rangle>ssns_impl_rel\"\n  shows\n  \"(ssns_visited_impl, visited) \\<in> R \\<rightarrow> vis_rel\"\n  \"(simple_state_ns_impl.more, simple_state.more) \\<in> R \\<rightarrow> erel\"\n  \"\\<And>f. (\\<lambda>x. x, op_ns_stack_update f) \\<in> R \\<rightarrow> R\"\n  \"\\<And>f. (\\<lambda>x. x, op_ns_on_stack_update f) \\<in> R \\<rightarrow> R\"\n  \"(ssns_visited_impl_update, visited_update) \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(simple_state_ns_impl.more_update, simple_state.more_update) \\<in> (erel \\<rightarrow> erel) \\<rightarrow> R \\<rightarrow> R\"\n  \"(\\<lambda>_ _ ps vs. simple_state_ns_impl_ext ps vs, simple_state_ext) \n    \\<in> ANY1_rel \\<rightarrow> ANY2_rel \\<rightarrow> vis_rel \\<rightarrow> erel \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ssns_visited_impl, visited) \\<in> R \\<rightarrow> vis_rel &&&\n     (simple_state_ns_impl.more, simple_state.more)\n     \\<in> R \\<rightarrow> erel &&&\n     (\\<And>f.\n         (\\<lambda>x. x, op_ns_stack_update f) \\<in> R \\<rightarrow> R)) &&&\n    ((\\<And>f.\n         (\\<lambda>x. x, op_ns_on_stack_update f)\n         \\<in> R \\<rightarrow> R) &&&\n     (ssns_visited_impl_update, visited_update)\n     \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow>\n           R \\<rightarrow> R) &&&\n    (simple_state_ns_impl.more_update, simple_state.more_update)\n    \\<in> (erel \\<rightarrow> erel) \\<rightarrow> R \\<rightarrow> R &&&\n    (\\<lambda>_ _. simple_state_ns_impl_ext, simple_state_ext)\n    \\<in> ANY1_rel \\<rightarrow>\n          ANY2_rel \\<rightarrow> vis_rel \\<rightarrow> erel \\<rightarrow> R", "unfolding ssns_impl_rel_def R_def op_ns_on_stack_update_def op_ns_stack_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ssns_visited_impl, visited)\n     \\<in> {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            visi mi s os vis m.\n            (visi, vis) \\<in> vis_rel \\<and>\n            (mi, m) \\<in> erel} \\<rightarrow>\n           vis_rel &&&\n     (simple_state_ns_impl.more, simple_state.more)\n     \\<in> {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            visi mi s os vis m.\n            (visi, vis) \\<in> vis_rel \\<and>\n            (mi, m) \\<in> erel} \\<rightarrow>\n           erel &&&\n     (\\<And>f.\n         (\\<lambda>x. x, ss_stack_update f)\n         \\<in> {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n                 \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                    \\<dots> = m\\<rparr>) |\n                visi mi s os vis m.\n                (visi, vis) \\<in> vis_rel \\<and>\n                (mi, m) \\<in> erel} \\<rightarrow>\n               {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n                 \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                    \\<dots> = m\\<rparr>) |\n                visi mi s os vis m.\n                (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel})) &&&\n    ((\\<And>f.\n         (\\<lambda>x. x, on_stack_update f)\n         \\<in> {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n                 \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                    \\<dots> = m\\<rparr>) |\n                visi mi s os vis m.\n                (visi, vis) \\<in> vis_rel \\<and>\n                (mi, m) \\<in> erel} \\<rightarrow>\n               {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n                 \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                    \\<dots> = m\\<rparr>) |\n                visi mi s os vis m.\n                (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel}) &&&\n     (ssns_visited_impl_update, visited_update)\n     \\<in> (vis_rel \\<rightarrow> vis_rel) \\<rightarrow>\n           {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            visi mi s os vis m.\n            (visi, vis) \\<in> vis_rel \\<and>\n            (mi, m) \\<in> erel} \\<rightarrow>\n           {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n             \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n                \\<dots> = m\\<rparr>) |\n            visi mi s os vis m.\n            (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel}) &&&\n    (simple_state_ns_impl.more_update, simple_state.more_update)\n    \\<in> (erel \\<rightarrow> erel) \\<rightarrow>\n          {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           visi mi s os vis m.\n           (visi, vis) \\<in> vis_rel \\<and>\n           (mi, m) \\<in> erel} \\<rightarrow>\n          {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           visi mi s os vis m.\n           (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel} &&&\n    (\\<lambda>_ _. simple_state_ns_impl_ext, simple_state_ext)\n    \\<in> ANY1_rel \\<rightarrow>\n          ANY2_rel \\<rightarrow>\n          vis_rel \\<rightarrow>\n          erel \\<rightarrow>\n          {(\\<lparr>ssns_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           visi mi s os vis m.\n           (visi, vis) \\<in> vis_rel \\<and> (mi, m) \\<in> erel}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' visi mi vis m.\n       \\<lbrakk>(a, a') \\<in> vis_rel \\<rightarrow> vis_rel;\n        (visi, vis) \\<in> vis_rel; (mi, m) \\<in> erel\\<rbrakk>\n       \\<Longrightarrow> (a visi, a' vis) \\<in> vis_rel\n 2. \\<And>a a' visi mi vis m.\n       \\<lbrakk>(a, a') \\<in> erel \\<rightarrow> erel;\n        (visi, vis) \\<in> vis_rel; (mi, m) \\<in> erel\\<rbrakk>\n       \\<Longrightarrow> (a mi, a' m) \\<in> erel", "apply parametricity+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [refine_transfer_post_simp]:\n  \"\\<And>a m. a\\<lparr>simple_state_nos_impl.more := m::unit\\<rparr> = a\"\n  \"\\<And>a m. a\\<lparr>simple_state_impl.more := m::unit\\<rparr> = a\"\n  \"\\<And>a m. a\\<lparr>simple_state_ns_impl.more := m::unit\\<rparr> = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a m. a\\<lparr>simple_state_nos_impl.more := m\\<rparr> = a) &&&\n    (\\<And>a m. a\\<lparr>simple_state_impl.more := m\\<rparr> = a) &&&\n    (\\<And>a m. a\\<lparr>simple_state_ns_impl.more := m\\<rparr> = a)", "by auto"], ["", "end"]]}