{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Examples/Tarjan.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma tjs_union:\n  fixes tjs u\n  defines \"dw \\<equiv> dropWhile ((\\<noteq>) u) tjs\"\n  defines \"tw \\<equiv> takeWhile ((\\<noteq>) u) tjs\"\n  assumes \"u \\<in> set tjs\"\n  shows \"set tjs = set (tl dw) \\<union> insert u (set tw)\"", "lemma tj_stack_pop_set:\n    \"tj_stack_pop tjs u \\<le> SPEC (\\<lambda>(tjs',scc). u \\<in> set tjs \\<longrightarrow> set tjs = set tjs' \\<union> scc \\<and> u \\<in> scc)\"", "lemmas tj_stack_pop_set_leof_rule = weaken_SPEC[OF tj_stack_pop_set, THEN leof_lift]", "lemma [simp]: \n    \"sccs (empty_state \\<lparr>sccs = s, lowlink = l, tj_stack = t\\<rparr>) = s\"\n    \"lowlink (empty_state \\<lparr>sccs = s, lowlink = l, tj_stack = t\\<rparr>) = l\"\n    \"tj_stack (empty_state \\<lparr>sccs = s, lowlink = l, tj_stack = t\\<rparr>) = t\"", "lemma sccs_more_cong[cong]:\"state.more s = state.more s' \\<Longrightarrow> sccs s = sccs s'\"", "lemma lowlink_more_cong[cong]:\"state.more s = state.more s' \\<Longrightarrow> lowlink s = lowlink s'\"", "lemma tj_stack_more_cong[cong]:\"state.more s = state.more s' \\<Longrightarrow> tj_stack s = tj_stack s'\"", "lemma [simp]: \n     \"s\\<lparr> state.more := \\<lparr>sccs = sc, lowlink = l, tj_stack = t\\<rparr>\\<rparr>\n      = s\\<lparr> sccs := sc, lowlink := l, tj_stack := t\\<rparr>\"", "lemma Tarjan_invar_eq[simp]:\n    \"DFS_invar G tarjan_params s \\<longleftrightarrow> Tarjan_invar G s\" (is \"?D \\<longleftrightarrow> ?T\")", "lemma i_tj_stack_discovered:\n    \"is_invar (\\<lambda>s. set (tj_stack s) \\<subseteq> dom (discovered s))\"", "lemmas (in Tarjan_invar) tj_stack_discovered =\n    i_tj_stack_discovered[THEN make_invar_thm]", "lemma i_tj_stack_distinct:\n    \"is_invar (\\<lambda>s. distinct (tj_stack s))\"", "lemmas (in Tarjan_invar) tj_stack_distinct =\n    i_tj_stack_distinct[THEN make_invar_thm]", "lemma i_tj_stack_incr_disc:\n    \"is_invar (\\<lambda>s. \\<forall>k<length (tj_stack s). \\<forall>j<k. \\<delta> s (tj_stack s ! j) > \\<delta> s (tj_stack s ! k))\"", "lemma tj_stack_incr_disc:\n    assumes \"k < length (tj_stack s)\"\n    and \"j < k\"\n    shows \"\\<delta> s (tj_stack s ! j) > \\<delta> s (tj_stack s ! k)\"", "lemma tjs_disc_dw_tw:\n    fixes u\n    defines \"dw \\<equiv> dropWhile ((\\<noteq>) u) (tj_stack s)\"\n    defines \"tw \\<equiv> takeWhile ((\\<noteq>) u) (tj_stack s)\"\n    assumes \"x \\<in> set dw\" \"y \\<in> set tw\"\n    shows \"\\<delta> s x < \\<delta> s y\"", "lemma i_sccs_finished_stack_ss_tj_stack:\n    \"is_invar (\\<lambda>s. \\<Union>(sccs s) \\<subseteq> dom (finished s) \\<and> set (stack s) \\<subseteq> set (tj_stack s))\"", "lemma i_tj_stack_ss_stack_finished:\n    \"is_invar (\\<lambda>s. set (tj_stack s) \\<subseteq> set (stack s) \\<union> dom (finished s))\"", "lemma i_finished_ss_sccs_tj_stack:\n    \"is_invar (\\<lambda>s. dom (finished s) \\<subseteq> \\<Union>(sccs s) \\<union> set (tj_stack s))\"", "lemmas finished_ss_sccs_tj_stack =\n    i_finished_ss_sccs_tj_stack[THEN make_invar_thm]", "lemmas tj_stack_ss_stack_finished =\n    i_tj_stack_ss_stack_finished[THEN make_invar_thm]", "lemma sccs_finished:\n    \"\\<Union>(sccs s) \\<subseteq> dom (finished s)\"", "lemma stack_ss_tj_stack:\n    \"set (stack s) \\<subseteq> set (tj_stack s)\"", "lemma hd_stack_in_tj_stack:\n    \"stack s \\<noteq> [] \\<Longrightarrow> hd (stack s) \\<in> set (tj_stack s)\"", "lemma i_no_finished_root:\n    \"is_invar (\\<lambda>s. scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow> (\\<forall>x \\<in> scc. x \\<notin> set (tj_stack s)))\"", "lemma no_finished_root:\n    assumes \"scc_root s r scc\"\n    and \"r \\<in> dom (finished s)\"\n    and \"x \\<in> scc\"\n    shows \"x \\<notin> set (tj_stack s)\"", "lemma tj_stack_reach_stack:\n    assumes \"u \\<in> set (tj_stack s)\"\n    shows \"\\<exists>v \\<in> set (stack s). (u,v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u\"", "lemma tj_stack_reach_hd_stack:\n    assumes \"v \\<in> set (tj_stack s)\"\n    shows \"(v, hd (stack s)) \\<in> E\\<^sup>*\"", "lemma empty_stack_imp_empty_tj_stack: \n    assumes \"stack s = []\"\n    shows \"tj_stack s = []\"", "lemma stacks_eq_iff: \"stack s = [] \\<longleftrightarrow> tj_stack s = []\"", "lemma i_sccs_are_sccs:\n    \"is_invar (\\<lambda>s. \\<forall>scc \\<in> sccs s. is_scc E scc)\"", "lemmas (in Tarjan_invar) sccs_are_sccs =\n    i_sccs_are_sccs[THEN make_invar_thm]", "lemma i_lowlink_eq_LowLink:\n    \"is_invar (\\<lambda>s. \\<forall>x \\<in> dom (discovered s). \\<zeta> s x = LowLink s x)\"", "lemmas lowlink_eq_LowLink =\n    i_lowlink_eq_LowLink[THEN make_invar_thm, rule_format]", "lemma lowlink_eq_disc_iff_scc_root:\n    assumes \"v \\<in> dom (finished s) \\<or> (stack s \\<noteq> [] \\<and> v = hd (stack s) \\<and> pending s `` {v} = {})\"\n    shows \"\\<zeta> s v = \\<delta> s v \\<longleftrightarrow> scc_root s v (scc_of E v)\"", "lemma nc_sccs_eq_reachable:\n    assumes NC: \"\\<not> cond s\"\n    shows \"reachable = \\<Union>(sccs s)\"", "lemma tarjan_fin_nofail:\n    assumes \"pre_on_finish u s'\"\n    shows \"nofail (tarjan_fin u s')\"", "lemma tarjan_correct:\n  \"tarjan G \\<le> tarjan_spec G\""], "translations": [["", "lemma tjs_union:\n  fixes tjs u\n  defines \"dw \\<equiv> dropWhile ((\\<noteq>) u) tjs\"\n  defines \"tw \\<equiv> takeWhile ((\\<noteq>) u) tjs\"\n  assumes \"u \\<in> set tjs\"\n  shows \"set tjs = set (tl dw) \\<union> insert u (set tw)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set tjs = set (tl dw) \\<union> insert u (set tw)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set tjs = set (tl dw) \\<union> insert u (set tw)", "from takeWhile_dropWhile_id"], ["proof (chain)\npicking this:\n  takeWhile ?P ?xs @ dropWhile ?P ?xs = ?xs", "have \"set tjs = set (tw@dw)\""], ["proof (prove)\nusing this:\n  takeWhile ?P ?xs @ dropWhile ?P ?xs = ?xs\n\ngoal (1 subgoal):\n 1. set tjs = set (tw @ dw)", "by (auto simp: dw_def tw_def)"], ["proof (state)\nthis:\n  set tjs = set (tw @ dw)\n\ngoal (1 subgoal):\n 1. set tjs = set (tl dw) \\<union> insert u (set tw)", "hence \"set tjs = set tw \\<union> set dw\""], ["proof (prove)\nusing this:\n  set tjs = set (tw @ dw)\n\ngoal (1 subgoal):\n 1. set tjs = set tw \\<union> set dw", "by (metis set_append)"], ["proof (state)\nthis:\n  set tjs = set tw \\<union> set dw\n\ngoal (1 subgoal):\n 1. set tjs = set (tl dw) \\<union> insert u (set tw)", "moreover"], ["proof (state)\nthis:\n  set tjs = set tw \\<union> set dw\n\ngoal (1 subgoal):\n 1. set tjs = set (tl dw) \\<union> insert u (set tw)", "from \\<open>u \\<in> set tjs\\<close> dropWhile_eq_Nil_conv"], ["proof (chain)\npicking this:\n  u \\<in> set tjs\n  (dropWhile ?P ?xs = []) = (\\<forall>x\\<in>set ?xs. ?P x)", "have \"dw \\<noteq> []\""], ["proof (prove)\nusing this:\n  u \\<in> set tjs\n  (dropWhile ?P ?xs = []) = (\\<forall>x\\<in>set ?xs. ?P x)\n\ngoal (1 subgoal):\n 1. dw \\<noteq> []", "by (auto simp: dw_def)"], ["proof (state)\nthis:\n  dw \\<noteq> []\n\ngoal (1 subgoal):\n 1. set tjs = set (tl dw) \\<union> insert u (set tw)", "from hd_dropWhile[OF this[unfolded dw_def]]"], ["proof (chain)\npicking this:\n  \\<not> u \\<noteq> hd (dropWhile ((\\<noteq>) u) tjs)", "have \"hd dw = u\""], ["proof (prove)\nusing this:\n  \\<not> u \\<noteq> hd (dropWhile ((\\<noteq>) u) tjs)\n\ngoal (1 subgoal):\n 1. hd dw = u", "by (simp add: dw_def)"], ["proof (state)\nthis:\n  hd dw = u\n\ngoal (1 subgoal):\n 1. set tjs = set (tl dw) \\<union> insert u (set tw)", "with \\<open>dw \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  dw \\<noteq> []\n  hd dw = u", "have \"set dw = insert u (set (tl dw))\""], ["proof (prove)\nusing this:\n  dw \\<noteq> []\n  hd dw = u\n\ngoal (1 subgoal):\n 1. set dw = insert u (set (tl dw))", "by (cases \"dw\") auto"], ["proof (state)\nthis:\n  set dw = insert u (set (tl dw))\n\ngoal (1 subgoal):\n 1. set tjs = set (tl dw) \\<union> insert u (set tw)", "ultimately"], ["proof (chain)\npicking this:\n  set tjs = set tw \\<union> set dw\n  set dw = insert u (set (tl dw))", "show ?thesis"], ["proof (prove)\nusing this:\n  set tjs = set tw \\<union> set dw\n  set dw = insert u (set (tl dw))\n\ngoal (1 subgoal):\n 1. set tjs = set (tl dw) \\<union> insert u (set tw)", "by blast"], ["proof (state)\nthis:\n  set tjs = set (tl dw) \\<union> insert u (set tw)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Instantiation of the DFS-Framework\\<close>"], ["", "record 'v tarjan_state = \"'v state\" +\n  sccs :: \"'v set set\"\n  lowlink :: \"'v \\<rightharpoonup> nat\"\n  tj_stack :: \"'v list\""], ["", "type_synonym 'v tarjan_param = \"('v, ('v,unit) tarjan_state_ext) parameterization\""], ["", "abbreviation \"the_lowlink s v \\<equiv> the (lowlink s v)\""], ["", "context timing_syntax\nbegin"], ["", "notation the_lowlink (\"\\<zeta>\")"], ["", "end"], ["", "locale Tarjan_def = graph_defs G\n  for G :: \"('v, 'more) graph_rec_scheme\"\nbegin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition tarjan_disc :: \"'v \\<Rightarrow> 'v tarjan_state \\<Rightarrow> ('v,unit) tarjan_state_ext nres\" where\n    \"tarjan_disc v s = RETURN \\<lparr> sccs = sccs s, \n                                 lowlink = (lowlink s)(v \\<mapsto> \\<delta> s v),\n                                 tj_stack = v#tj_stack s\\<rparr>\""], ["", "definition tj_stack_pop :: \"'v list \\<Rightarrow> 'v \\<Rightarrow> ('v list \\<times> 'v set) nres\" where\n    \"tj_stack_pop tjs u = RETURN (tl (dropWhile ((\\<noteq>) u) tjs), insert u (set (takeWhile ((\\<noteq>) u) tjs)))\""], ["", "lemma tj_stack_pop_set:\n    \"tj_stack_pop tjs u \\<le> SPEC (\\<lambda>(tjs',scc). u \\<in> set tjs \\<longrightarrow> set tjs = set tjs' \\<union> scc \\<and> u \\<in> scc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tj_stack_pop tjs u\n    \\<le> SPEC\n           (\\<lambda>(tjs', scc).\n               u \\<in> set tjs \\<longrightarrow>\n               set tjs = set tjs' \\<union> scc \\<and> u \\<in> scc)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tj_stack_pop tjs u\n    \\<le> SPEC\n           (\\<lambda>(tjs', scc).\n               u \\<in> set tjs \\<longrightarrow>\n               set tjs = set tjs' \\<union> scc \\<and> u \\<in> scc)", "from tjs_union[of u tjs]"], ["proof (chain)\npicking this:\n  u \\<in> set tjs \\<Longrightarrow>\n  set tjs =\n  set (tl (dropWhile ((\\<noteq>) u) tjs)) \\<union>\n  insert u (set (takeWhile ((\\<noteq>) u) tjs))", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> set tjs \\<Longrightarrow>\n  set tjs =\n  set (tl (dropWhile ((\\<noteq>) u) tjs)) \\<union>\n  insert u (set (takeWhile ((\\<noteq>) u) tjs))\n\ngoal (1 subgoal):\n 1. tj_stack_pop tjs u\n    \\<le> SPEC\n           (\\<lambda>(tjs', scc).\n               u \\<in> set tjs \\<longrightarrow>\n               set tjs = set tjs' \\<union> scc \\<and> u \\<in> scc)", "unfolding tj_stack_pop_def"], ["proof (prove)\nusing this:\n  u \\<in> set tjs \\<Longrightarrow>\n  set tjs =\n  set (tl (dropWhile ((\\<noteq>) u) tjs)) \\<union>\n  insert u (set (takeWhile ((\\<noteq>) u) tjs))\n\ngoal (1 subgoal):\n 1. RETURN\n     (tl (dropWhile ((\\<noteq>) u) tjs),\n      insert u (set (takeWhile ((\\<noteq>) u) tjs)))\n    \\<le> SPEC\n           (\\<lambda>(tjs', scc).\n               u \\<in> set tjs \\<longrightarrow>\n               set tjs = set tjs' \\<union> scc \\<and> u \\<in> scc)", "by (refine_vcg) auto"], ["proof (state)\nthis:\n  tj_stack_pop tjs u\n  \\<le> SPEC\n         (\\<lambda>(tjs', scc).\n             u \\<in> set tjs \\<longrightarrow>\n             set tjs = set tjs' \\<union> scc \\<and> u \\<in> scc)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas tj_stack_pop_set_leof_rule = weaken_SPEC[OF tj_stack_pop_set, THEN leof_lift]"], ["", "definition tarjan_fin :: \"'v \\<Rightarrow> 'v tarjan_state \\<Rightarrow> ('v,unit) tarjan_state_ext nres\" where\n    \"tarjan_fin v s = do {\n           let ll = (if stack s = [] then lowlink s \n                     else let u = hd (stack s) in\n                          (lowlink s)(u \\<mapsto> min (\\<zeta> s u) (\\<zeta> s v)));\n           let s' = s\\<lparr> lowlink := ll \\<rparr>;\n\n           ASSERT (v \\<in> set (tj_stack s));\n           ASSERT (distinct (tj_stack s));\n           if \\<zeta> s v = \\<delta> s v then do {\n                ASSERT (scc_root' E s v (scc_of E v));\n                (tjs,scc) \\<leftarrow> tj_stack_pop (tj_stack s) v;\n                RETURN (state.more (s'\\<lparr> tj_stack := tjs, sccs := insert scc (sccs s)\\<rparr>))\n           } else do {\n                ASSERT (\\<not> scc_root' E s v (scc_of E v));\n                RETURN (state.more s')\n           }}\""], ["", "definition tarjan_back :: \"'v \\<Rightarrow> 'v \\<Rightarrow> 'v tarjan_state \\<Rightarrow> ('v,unit) tarjan_state_ext nres\" where\n    \"tarjan_back u v s = (\n       if \\<delta> s v < \\<delta> s u \\<and> v \\<in> set (tj_stack s) then\n         let ul' = min (\\<zeta> s u) (\\<delta> s v)\n         in RETURN (state.more (s\\<lparr> lowlink := (lowlink s)(u\\<mapsto>ul') \\<rparr>))\n       else NOOP s)\""], ["", "end"], ["", "(* end timing syntax *)"], ["", "definition tarjan_params :: \"'v tarjan_param\" where\n    \"tarjan_params = \\<lparr>\n      on_init = RETURN \\<lparr> sccs = {}, lowlink = Map.empty, tj_stack = [] \\<rparr>,\n      on_new_root = tarjan_disc,\n      on_discover = \\<lambda>u. tarjan_disc,\n      on_finish = tarjan_fin,\n      on_back_edge = tarjan_back,\n      on_cross_edge = tarjan_back,\n      is_break = \\<lambda>s. False \\<rparr>\""], ["", "schematic_goal tarjan_params_simps[simp]:\n    \"on_init tarjan_params = ?OI\"\n    \"on_new_root tarjan_params = ?ONR\"\n    \"on_discover tarjan_params = ?OD\"\n    \"on_finish tarjan_params = ?OF\"\n    \"on_back_edge tarjan_params = ?OBE\"\n    \"on_cross_edge tarjan_params = ?OCE\"\n    \"is_break tarjan_params = ?IB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (on_init tarjan_params = ?OI &&&\n     on_new_root tarjan_params = ?ONR &&&\n     on_discover tarjan_params = ?OD) &&&\n    (on_finish tarjan_params = ?OF &&&\n     on_back_edge tarjan_params = ?OBE) &&&\n    on_cross_edge tarjan_params = ?OCE &&& is_break tarjan_params = ?IB", "unfolding tarjan_params_def gen_parameterization.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<lparr>sccs = {}, lowlink = Map.empty, tj_stack = []\\<rparr> =\n     ?OI &&&\n     tarjan_disc = ?ONR &&& (\\<lambda>u. tarjan_disc) = ?OD) &&&\n    (tarjan_fin = ?OF &&& tarjan_back = ?OBE) &&&\n    tarjan_back = ?OCE &&& (\\<lambda>s. False) = ?IB", "by (rule refl)+"], ["", "sublocale param_DFS_defs G tarjan_params"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "locale Tarjan = Tarjan_def G +\n                param_DFS G tarjan_params\n  for G :: \"('v, 'more) graph_rec_scheme\"\nbegin"], ["", "lemma [simp]: \n    \"sccs (empty_state \\<lparr>sccs = s, lowlink = l, tj_stack = t\\<rparr>) = s\"\n    \"lowlink (empty_state \\<lparr>sccs = s, lowlink = l, tj_stack = t\\<rparr>) = l\"\n    \"tj_stack (empty_state \\<lparr>sccs = s, lowlink = l, tj_stack = t\\<rparr>) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sccs (empty_state \\<lparr>sccs = s, lowlink = l, tj_stack = t\\<rparr>) =\n    s &&&\n    lowlink\n     (empty_state \\<lparr>sccs = s, lowlink = l, tj_stack = t\\<rparr>) =\n    l &&&\n    tj_stack\n     (empty_state \\<lparr>sccs = s, lowlink = l, tj_stack = t\\<rparr>) =\n    t", "by (simp_all add: empty_state_def)"], ["", "lemma sccs_more_cong[cong]:\"state.more s = state.more s' \\<Longrightarrow> sccs s = sccs s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state.more s = state.more s' \\<Longrightarrow> sccs s = sccs s'", "by (cases s, cases s') simp"], ["", "lemma lowlink_more_cong[cong]:\"state.more s = state.more s' \\<Longrightarrow> lowlink s = lowlink s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state.more s = state.more s' \\<Longrightarrow> lowlink s = lowlink s'", "by (cases s, cases s') simp"], ["", "lemma tj_stack_more_cong[cong]:\"state.more s = state.more s' \\<Longrightarrow> tj_stack s = tj_stack s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state.more s = state.more s' \\<Longrightarrow> tj_stack s = tj_stack s'", "by (cases s, cases s') simp"], ["", "lemma [simp]: \n     \"s\\<lparr> state.more := \\<lparr>sccs = sc, lowlink = l, tj_stack = t\\<rparr>\\<rparr>\n      = s\\<lparr> sccs := sc, lowlink := l, tj_stack := t\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<lparr>state.more :=\n               \\<lparr>sccs = sc, lowlink = l,\n                  tj_stack = t\\<rparr>\\<rparr> =\n    s\\<lparr>sccs := sc, lowlink := l, tj_stack := t\\<rparr>", "by (cases s) simp"], ["", "end"], ["", "locale Tarjan_invar = Tarjan +\n  DFS_invar where param = tarjan_params"], ["", "context Tarjan_def begin"], ["", "lemma Tarjan_invar_eq[simp]:\n    \"DFS_invar G tarjan_params s \\<longleftrightarrow> Tarjan_invar G s\" (is \"?D \\<longleftrightarrow> ?T\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G tarjan_params s = Tarjan_invar G s", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. DFS_invar G tarjan_params s \\<Longrightarrow> Tarjan_invar G s\n 2. Tarjan_invar G s \\<Longrightarrow> DFS_invar G tarjan_params s", "assume ?D"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n\ngoal (2 subgoals):\n 1. DFS_invar G tarjan_params s \\<Longrightarrow> Tarjan_invar G s\n 2. Tarjan_invar G s \\<Longrightarrow> DFS_invar G tarjan_params s", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s", "interpret DFS_invar where param=tarjan_params"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n\ngoal (1 subgoal):\n 1. DFS_invar G tarjan_params s", "."], ["proof (state)\ngoal (2 subgoals):\n 1. DFS_invar G tarjan_params s \\<Longrightarrow> Tarjan_invar G s\n 2. Tarjan_invar G s \\<Longrightarrow> DFS_invar G tarjan_params s", "show ?T"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tarjan_invar G s", ".."], ["proof (state)\nthis:\n  Tarjan_invar G s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s \\<Longrightarrow> DFS_invar G tarjan_params s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Tarjan_invar G s \\<Longrightarrow> DFS_invar G tarjan_params s", "assume ?T"], ["proof (state)\nthis:\n  Tarjan_invar G s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s \\<Longrightarrow> DFS_invar G tarjan_params s", "then"], ["proof (chain)\npicking this:\n  Tarjan_invar G s", "interpret Tarjan_invar"], ["proof (prove)\nusing this:\n  Tarjan_invar G s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "."], ["proof (state)\ngoal (1 subgoal):\n 1. Tarjan_invar G s \\<Longrightarrow> DFS_invar G tarjan_params s", "show ?D"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G tarjan_params s", ".."], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Correctness Proof\\<close>"], ["", "context Tarjan begin"], ["", "lemma i_tj_stack_discovered:\n    \"is_invar (\\<lambda>s. set (tj_stack s) \\<subseteq> dom (discovered s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar (\\<lambda>s. set (tj_stack s) \\<subseteq> dom (discovered s))", "proof (induct rule: establish_invarI)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         set (tj_stack (empty_state x))\n         \\<subseteq> dom (discovered (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))", "case (finish s)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         set (tj_stack (empty_state x))\n         \\<subseteq> dom (discovered (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s\n\ngoal (1 subgoal):\n 1. on_finish tarjan_params u_ s'_ \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         set (tj_stack (s'_\\<lparr>state.more := x\\<rparr>))\n         \\<subseteq> dom (discovered (s'_\\<lparr>state.more := x\\<rparr>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s;\n     set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n     stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {};\n     s'_ = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> tarjan_fin (hd (stack s))\n                       (finish (hd (stack s)) s) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           set (tj_stack\n                                 (s'_\\<lparr>state.more := x\\<rparr>))\n                           \\<subseteq> dom (discovered s))", "unfolding tarjan_fin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s;\n     set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n     stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {};\n     s'_ = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> (let ll = if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (the_lowlink (finish (hd (stack s)) s) u)\n   (the_lowlink (finish (hd (stack s)) s) (hd (stack s))));\n                           s' = finish (hd (stack s)) s\n                             \\<lparr>lowlink := ll\\<rparr>\n                       in ASSERT\n                           (hd (stack s)\n                            \\<in> set (tj_stack\n  (finish (hd (stack s)) s))) \\<bind>\n                          (\\<lambda>_.\n                              ASSERT\n                               (distinct\n                                 (tj_stack\n                                   (finish (hd (stack s)) s))) \\<bind>\n                              (\\<lambda>_.\n                                  if the_lowlink (finish (hd (stack s)) s)\n(hd (stack s)) =\n                                     the_discovered\n(finish (hd (stack s)) s) (hd (stack s))\n                                  then ASSERT\n  (scc_root (finish (hd (stack s)) s) (hd (stack s))\n    (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_.\n     tj_stack_pop (tj_stack (finish (hd (stack s)) s))\n      (hd (stack s)) \\<bind>\n     (\\<lambda>(tjs, scc).\n         NOOP\n          (s'\\<lparr>tj_stack := tjs,\n                sccs :=\n                  insert scc (sccs (finish (hd (stack s)) s))\\<rparr>)))\n                                  else ASSERT\n  (\\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n           (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_. NOOP s')))) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           set (tj_stack\n                                 (s'_\\<lparr>state.more := x\\<rparr>))\n                           \\<subseteq> dom (discovered s))", "apply (refine_vcg tj_stack_pop_set_leof_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>Tarjan_invar G s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        stack s \\<noteq> []; u_ = hd (stack s);\n        pending s `` {hd (stack s)} = {}; s'_ = finish (hd (stack s)) s;\n        hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n        distinct (tj_stack (finish (hd (stack s)) s));\n        the_lowlink (finish (hd (stack s)) s) (hd (stack s)) =\n        the_discovered (finish (hd (stack s)) s) (hd (stack s));\n        scc_root (finish (hd (stack s)) s) (hd (stack s))\n         (scc_of E (hd (stack s)));\n        case x of\n        (tjs', scc) \\<Rightarrow>\n          hd (stack s)\n          \\<in> set (tj_stack (finish (hd (stack s)) s)) \\<longrightarrow>\n          set (tj_stack (finish (hd (stack s)) s)) =\n          set tjs' \\<union> scc \\<and>\n          hd (stack s) \\<in> scc;\n        x = (x1, x2);\n        Tarjan_invar G\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    state.more\n                     (finish (hd (stack s)) s\n                      \\<lparr>lowlink :=\n                                if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (the_lowlink (finish (hd (stack s)) s) u)\n   (the_lowlink (finish (hd (stack s)) s) (hd (stack s)))),\n                         tj_stack := x1,\n                         sccs :=\n                           insert x2\n                            (sccs\n                              (finish (hd (stack s))\n                                s))\\<rparr>)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> set (tj_stack\n                               (s'_\\<lparr>state.more :=\n       state.more\n        (finish (hd (stack s)) s\n         \\<lparr>lowlink :=\n                   if stack (finish (hd (stack s)) s) = []\n                   then lowlink (finish (hd (stack s)) s)\n                   else let u = hd (stack (finish (hd (stack s)) s))\n                        in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                           min (the_lowlink (finish (hd (stack s)) s) u)\n                            (the_lowlink (finish (hd (stack s)) s)\n                              (hd (stack s)))),\n            tj_stack := x1,\n            sccs :=\n              insert x2 (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>))\n                         \\<subseteq> dom (discovered s)\n 2. \\<lbrakk>Tarjan_invar G s;\n     set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n     stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s'_ = finish (hd (stack s)) s;\n     hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n     distinct (tj_stack (finish (hd (stack s)) s));\n     the_lowlink (finish (hd (stack s)) s) (hd (stack s)) \\<noteq>\n     the_discovered (finish (hd (stack s)) s) (hd (stack s));\n     \\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n             (scc_of E (hd (stack s)));\n     Tarjan_invar G\n      (finish (hd (stack s)) s\n       \\<lparr>state.more :=\n                 state.more\n                  (finish (hd (stack s)) s\n                   \\<lparr>lowlink :=\n                             if stack (finish (hd (stack s)) s) = []\n                             then lowlink (finish (hd (stack s)) s)\n                             else let u =\n  hd (stack (finish (hd (stack s)) s))\n                                  in lowlink (finish (hd (stack s)) s)(u \n                                     \\<mapsto>\n                                     min\n(the_lowlink (finish (hd (stack s)) s) u)\n(the_lowlink (finish (hd (stack s)) s)\n  (hd (stack s))))\\<rparr>)\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> set (tj_stack\n                            (s'_\\<lparr>state.more :=\n    state.more\n     (finish (hd (stack s)) s\n      \\<lparr>lowlink :=\n                if stack (finish (hd (stack s)) s) = []\n                then lowlink (finish (hd (stack s)) s)\n                else let u = hd (stack (finish (hd (stack s)) s))\n                     in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                        min (the_lowlink (finish (hd (stack s)) s) u)\n                         (the_lowlink (finish (hd (stack s)) s)\n                           (hd (stack s))))\\<rparr>)\\<rparr>))\n                      \\<subseteq> dom (discovered s)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  on_finish tarjan_params u_ s'_ \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       set (tj_stack (s'_\\<lparr>state.more := x\\<rparr>))\n       \\<subseteq> dom (discovered (s'_\\<lparr>state.more := x\\<rparr>)))\n\ngoal (5 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         set (tj_stack (empty_state x))\n         \\<subseteq> dom (discovered (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s) \\<subseteq> dom (discovered s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (discovered (s'\\<lparr>state.more := x\\<rparr>)))", "qed (auto simp add: tarjan_disc_def tarjan_back_def)"], ["", "lemmas (in Tarjan_invar) tj_stack_discovered =\n    i_tj_stack_discovered[THEN make_invar_thm]"], ["", "lemma i_tj_stack_distinct:\n    \"is_invar (\\<lambda>s. distinct (tj_stack s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar (\\<lambda>s. distinct (tj_stack s))", "proof (induct rule: establish_invarI_ND)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. distinct (tj_stack (empty_state x)))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))", "case (new_discover s s' v)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  distinct (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. distinct (tj_stack (empty_state x)))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  distinct (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  distinct (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. distinct (tj_stack (empty_state x)))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))", "from new_discover tj_stack_discovered"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  distinct (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  set (tj_stack s) \\<subseteq> dom (discovered s)", "have \"v \\<notin> set (tj_stack s)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  distinct (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (tj_stack s)", "by auto"], ["proof (state)\nthis:\n  v \\<notin> set (tj_stack s)\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. distinct (tj_stack (empty_state x)))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))", "with new_discover"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  distinct (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  v \\<notin> set (tj_stack s)", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  distinct (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  v \\<notin> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. on_new_root tarjan_params v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         distinct (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "by (simp add: tarjan_disc_def)"], ["proof (state)\nthis:\n  on_new_root tarjan_params v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       distinct (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. distinct (tj_stack (empty_state x)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. distinct (tj_stack (empty_state x)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))", "case (finish s)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  distinct (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. distinct (tj_stack (empty_state x)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))", "thus ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  distinct (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s\n\ngoal (1 subgoal):\n 1. on_finish tarjan_params u_ s'_ \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         distinct (tj_stack (s'_\\<lparr>state.more := x\\<rparr>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s; distinct (tj_stack s); cond s;\n     stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {};\n     s'_ = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> tarjan_fin (hd (stack s))\n                       (finish (hd (stack s)) s) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           distinct\n                            (tj_stack (s'_\\<lparr>state.more := x\\<rparr>)))", "unfolding tarjan_fin_def tj_stack_pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s; distinct (tj_stack s); cond s;\n     stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {};\n     s'_ = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> (let ll = if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (the_lowlink (finish (hd (stack s)) s) u)\n   (the_lowlink (finish (hd (stack s)) s) (hd (stack s))));\n                           s' = finish (hd (stack s)) s\n                             \\<lparr>lowlink := ll\\<rparr>\n                       in ASSERT\n                           (hd (stack s)\n                            \\<in> set (tj_stack\n  (finish (hd (stack s)) s))) \\<bind>\n                          (\\<lambda>_.\n                              ASSERT\n                               (distinct\n                                 (tj_stack\n                                   (finish (hd (stack s)) s))) \\<bind>\n                              (\\<lambda>_.\n                                  if the_lowlink (finish (hd (stack s)) s)\n(hd (stack s)) =\n                                     the_discovered\n(finish (hd (stack s)) s) (hd (stack s))\n                                  then ASSERT\n  (scc_root (finish (hd (stack s)) s) (hd (stack s))\n    (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_.\n     RETURN\n      (tl (dropWhile ((\\<noteq>) (hd (stack s)))\n            (tj_stack (finish (hd (stack s)) s))),\n       insert (hd (stack s))\n        (set (takeWhile ((\\<noteq>) (hd (stack s)))\n               (tj_stack (finish (hd (stack s)) s))))) \\<bind>\n     (\\<lambda>(tjs, scc).\n         NOOP\n          (s'\\<lparr>tj_stack := tjs,\n                sccs :=\n                  insert scc (sccs (finish (hd (stack s)) s))\\<rparr>)))\n                                  else ASSERT\n  (\\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n           (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_. NOOP s')))) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           distinct\n                            (tj_stack (s'_\\<lparr>state.more := x\\<rparr>)))", "apply (refine_vcg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>Tarjan_invar G s; distinct (tj_stack s); cond s;\n        stack s \\<noteq> []; u_ = hd (stack s);\n        pending s `` {hd (stack s)} = {}; s'_ = finish (hd (stack s)) s;\n        hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n        distinct (tj_stack (finish (hd (stack s)) s));\n        the_lowlink (finish (hd (stack s)) s) (hd (stack s)) =\n        the_discovered (finish (hd (stack s)) s) (hd (stack s));\n        scc_root (finish (hd (stack s)) s) (hd (stack s))\n         (scc_of E (hd (stack s)));\n        (tl (dropWhile ((\\<noteq>) (hd (stack s)))\n              (tj_stack (finish (hd (stack s)) s))),\n         insert (hd (stack s))\n          (set (takeWhile ((\\<noteq>) (hd (stack s)))\n                 (tj_stack (finish (hd (stack s)) s))))) =\n        (x1, x2);\n        Tarjan_invar G\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    state.more\n                     (finish (hd (stack s)) s\n                      \\<lparr>lowlink :=\n                                if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (the_lowlink (finish (hd (stack s)) s) u)\n   (the_lowlink (finish (hd (stack s)) s) (hd (stack s)))),\n                         tj_stack := x1,\n                         sccs :=\n                           insert x2\n                            (sccs\n                              (finish (hd (stack s))\n                                s))\\<rparr>)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (tj_stack\n                            (s'_\\<lparr>state.more :=\n    state.more\n     (finish (hd (stack s)) s\n      \\<lparr>lowlink :=\n                if stack (finish (hd (stack s)) s) = []\n                then lowlink (finish (hd (stack s)) s)\n                else let u = hd (stack (finish (hd (stack s)) s))\n                     in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                        min (the_lowlink (finish (hd (stack s)) s) u)\n                         (the_lowlink (finish (hd (stack s)) s)\n                           (hd (stack s)))),\n         tj_stack := x1,\n         sccs :=\n           insert x2 (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>))\n 2. \\<lbrakk>Tarjan_invar G s; distinct (tj_stack s); cond s;\n     stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s'_ = finish (hd (stack s)) s;\n     hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n     distinct (tj_stack (finish (hd (stack s)) s));\n     the_lowlink (finish (hd (stack s)) s) (hd (stack s)) \\<noteq>\n     the_discovered (finish (hd (stack s)) s) (hd (stack s));\n     \\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n             (scc_of E (hd (stack s)));\n     Tarjan_invar G\n      (finish (hd (stack s)) s\n       \\<lparr>state.more :=\n                 state.more\n                  (finish (hd (stack s)) s\n                   \\<lparr>lowlink :=\n                             if stack (finish (hd (stack s)) s) = []\n                             then lowlink (finish (hd (stack s)) s)\n                             else let u =\n  hd (stack (finish (hd (stack s)) s))\n                                  in lowlink (finish (hd (stack s)) s)(u \n                                     \\<mapsto>\n                                     min\n(the_lowlink (finish (hd (stack s)) s) u)\n(the_lowlink (finish (hd (stack s)) s)\n  (hd (stack s))))\\<rparr>)\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (tj_stack\n                         (s'_\\<lparr>state.more :=\n state.more\n  (finish (hd (stack s)) s\n   \\<lparr>lowlink :=\n             if stack (finish (hd (stack s)) s) = []\n             then lowlink (finish (hd (stack s)) s)\n             else let u = hd (stack (finish (hd (stack s)) s))\n                  in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                     min (the_lowlink (finish (hd (stack s)) s) u)\n                      (the_lowlink (finish (hd (stack s)) s)\n                        (hd (stack s))))\\<rparr>)\\<rparr>))", "apply (auto intro: distinct_tl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  on_finish tarjan_params u_ s'_ \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       distinct (tj_stack (s'_\\<lparr>state.more := x\\<rparr>)))\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. distinct (tj_stack (empty_state x)))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s; distinct (tj_stack s); cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              distinct\n                               (tj_stack\n                                 (s'\\<lparr>state.more := x\\<rparr>)))", "qed (simp_all add: tarjan_back_def)"], ["", "lemmas (in Tarjan_invar) tj_stack_distinct =\n    i_tj_stack_distinct[THEN make_invar_thm]"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma i_tj_stack_incr_disc:\n    \"is_invar (\\<lambda>s. \\<forall>k<length (tj_stack s). \\<forall>j<k. \\<delta> s (tj_stack s ! j) > \\<delta> s (tj_stack s ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>k<length (tj_stack s).\n            \\<forall>j<k.\n               \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j))", "proof (induct rule: establish_invarI_ND)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "case (new_discover s s' v)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "from new_discover tj_stack_discovered"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  set (tj_stack s) \\<subseteq> dom (discovered s)", "have \"v \\<notin> set (tj_stack s)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (tj_stack s)", "by auto"], ["proof (state)\nthis:\n  v \\<notin> set (tj_stack s)\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "moreover"], ["proof (state)\nthis:\n  v \\<notin> set (tj_stack s)\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "{"], ["proof (state)\nthis:\n  v \\<notin> set (tj_stack s)\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "fix k j"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "assume \"k < Suc (length (tj_stack s))\" \"j < k\""], ["proof (state)\nthis:\n  k < Suc (length (tj_stack s))\n  j < k\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "hence \"k - Suc 0 < length (tj_stack s)\""], ["proof (prove)\nusing this:\n  k < Suc (length (tj_stack s))\n  j < k\n\ngoal (1 subgoal):\n 1. k - Suc 0 < length (tj_stack s)", "by simp"], ["proof (state)\nthis:\n  k - Suc 0 < length (tj_stack s)\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "hence \"tj_stack s ! (k - Suc 0) \\<in> set (tj_stack s)\""], ["proof (prove)\nusing this:\n  k - Suc 0 < length (tj_stack s)\n\ngoal (1 subgoal):\n 1. tj_stack s ! (k - Suc 0) \\<in> set (tj_stack s)", "using nth_mem"], ["proof (prove)\nusing this:\n  k - Suc 0 < length (tj_stack s)\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. tj_stack s ! (k - Suc 0) \\<in> set (tj_stack s)", "by metis"], ["proof (state)\nthis:\n  tj_stack s ! (k - Suc 0) \\<in> set (tj_stack s)\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "with tj_stack_discovered timing_less_counter"], ["proof (chain)\npicking this:\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  tj_stack s ! (k - Suc 0) \\<in> set (tj_stack s)", "have \"\\<delta> s (tj_stack s ! (k - Suc 0)) < counter s\""], ["proof (prove)\nusing this:\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  tj_stack s ! (k - Suc 0) \\<in> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. \\<delta> s (tj_stack s ! (k - Suc 0)) < counter s", "by blast"], ["proof (state)\nthis:\n  \\<delta> s (tj_stack s ! (k - Suc 0)) < counter s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?k9 < Suc (length (tj_stack s)); ?j9 < ?k9\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (tj_stack s ! (?k9 - Suc 0)) < counter s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?k9 < Suc (length (tj_stack s)); ?j9 < ?k9\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (tj_stack s ! (?k9 - Suc 0)) < counter s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?k9 < Suc (length (tj_stack s)); ?j9 < ?k9\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (tj_stack s ! (?k9 - Suc 0)) < counter s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "fix k j"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "define k' where \"k' = k - Suc 0\""], ["proof (state)\nthis:\n  k' = k - Suc 0\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "define j' where \"j' = j - Suc 0\""], ["proof (state)\nthis:\n  j' = j - Suc 0\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "assume A: \"k < Suc (length (tj_stack s))\" \"j < k\" \"(v#tj_stack s) ! j \\<noteq> v\""], ["proof (state)\nthis:\n  k < Suc (length (tj_stack s))\n  j < k\n  (v # tj_stack s) ! j \\<noteq> v\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "hence gt_0: \"j > 0 \\<and> k>0\""], ["proof (prove)\nusing this:\n  k < Suc (length (tj_stack s))\n  j < k\n  (v # tj_stack s) ! j \\<noteq> v\n\ngoal (1 subgoal):\n 1. 0 < j \\<and> 0 < k", "by (cases \"j=0\") simp_all"], ["proof (state)\nthis:\n  0 < j \\<and> 0 < k\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "moreover"], ["proof (state)\nthis:\n  0 < j \\<and> 0 < k\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "with \\<open>j < k\\<close>"], ["proof (chain)\npicking this:\n  j < k\n  0 < j \\<and> 0 < k", "have \"j' < k'\""], ["proof (prove)\nusing this:\n  j < k\n  0 < j \\<and> 0 < k\n\ngoal (1 subgoal):\n 1. j' < k'", "by (simp add: j'_def k'_def)"], ["proof (state)\nthis:\n  j' < k'\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "moreover"], ["proof (state)\nthis:\n  j' < k'\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "from A"], ["proof (chain)\npicking this:\n  k < Suc (length (tj_stack s))\n  j < k\n  (v # tj_stack s) ! j \\<noteq> v", "have \"k' < length (tj_stack s)\""], ["proof (prove)\nusing this:\n  k < Suc (length (tj_stack s))\n  j < k\n  (v # tj_stack s) ! j \\<noteq> v\n\ngoal (1 subgoal):\n 1. k' < length (tj_stack s)", "by (simp add: k'_def)"], ["proof (state)\nthis:\n  k' < length (tj_stack s)\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "ultimately"], ["proof (chain)\npicking this:\n  0 < j \\<and> 0 < k\n  j' < k'\n  k' < length (tj_stack s)", "have \"\\<delta> s (tj_stack s ! j') > \\<delta> s (tj_stack s ! k')\""], ["proof (prove)\nusing this:\n  0 < j \\<and> 0 < k\n  j' < k'\n  k' < length (tj_stack s)\n\ngoal (1 subgoal):\n 1. \\<delta> s (tj_stack s ! k') < \\<delta> s (tj_stack s ! j')", "using new_discover"], ["proof (prove)\nusing this:\n  0 < j \\<and> 0 < k\n  j' < k'\n  k' < length (tj_stack s)\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n\ngoal (1 subgoal):\n 1. \\<delta> s (tj_stack s ! k') < \\<delta> s (tj_stack s ! j')", "by blast"], ["proof (state)\nthis:\n  \\<delta> s (tj_stack s ! k') < \\<delta> s (tj_stack s ! j')\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "with gt_0"], ["proof (chain)\npicking this:\n  0 < j \\<and> 0 < k\n  \\<delta> s (tj_stack s ! k') < \\<delta> s (tj_stack s ! j')", "have \"\\<delta> s ((v#tj_stack s) ! j) > \\<delta> s (tj_stack s ! k')\""], ["proof (prove)\nusing this:\n  0 < j \\<and> 0 < k\n  \\<delta> s (tj_stack s ! k') < \\<delta> s (tj_stack s ! j')\n\ngoal (1 subgoal):\n 1. \\<delta> s (tj_stack s ! k') < \\<delta> s ((v # tj_stack s) ! j)", "unfolding j'_def"], ["proof (prove)\nusing this:\n  0 < j \\<and> 0 < k\n  \\<delta> s (tj_stack s ! k') < \\<delta> s (tj_stack s ! (j - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<delta> s (tj_stack s ! k') < \\<delta> s ((v # tj_stack s) ! j)", "by (simp add: nth_Cons')"], ["proof (state)\nthis:\n  \\<delta> s (tj_stack s ! k') < \\<delta> s ((v # tj_stack s) ! j)\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?k9 < Suc (length (tj_stack s)); ?j9 < ?k9;\n   (v # tj_stack s) ! ?j9 \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (tj_stack s ! (?k9 - Suc 0))\n                    < \\<delta> s ((v # tj_stack s) ! ?j9)\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "ultimately"], ["proof (chain)\npicking this:\n  v \\<notin> set (tj_stack s)\n  \\<lbrakk>?k9 < Suc (length (tj_stack s)); ?j9 < ?k9\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (tj_stack s ! (?k9 - Suc 0)) < counter s\n  \\<lbrakk>?k9 < Suc (length (tj_stack s)); ?j9 < ?k9;\n   (v # tj_stack s) ! ?j9 \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (tj_stack s ! (?k9 - Suc 0))\n                    < \\<delta> s ((v # tj_stack s) ! ?j9)", "show ?case"], ["proof (prove)\nusing this:\n  v \\<notin> set (tj_stack s)\n  \\<lbrakk>?k9 < Suc (length (tj_stack s)); ?j9 < ?k9\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (tj_stack s ! (?k9 - Suc 0)) < counter s\n  \\<lbrakk>?k9 < Suc (length (tj_stack s)); ?j9 < ?k9;\n   (v # tj_stack s) ! ?j9 \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (tj_stack s ! (?k9 - Suc 0))\n                    < \\<delta> s ((v # tj_stack s) ! ?j9)\n\ngoal (1 subgoal):\n 1. on_new_root tarjan_params v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         (\\<forall>k<length (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n             \\<forall>j<k.\n                \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                 (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                < \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                   (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "using new_discover"], ["proof (prove)\nusing this:\n  v \\<notin> set (tj_stack s)\n  \\<lbrakk>?k9 < Suc (length (tj_stack s)); ?j9 < ?k9\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (tj_stack s ! (?k9 - Suc 0)) < counter s\n  \\<lbrakk>?k9 < Suc (length (tj_stack s)); ?j9 < ?k9;\n   (v # tj_stack s) ! ?j9 \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (tj_stack s ! (?k9 - Suc 0))\n                    < \\<delta> s ((v # tj_stack s) ! ?j9)\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n\ngoal (1 subgoal):\n 1. on_new_root tarjan_params v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         (\\<forall>k<length (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n             \\<forall>j<k.\n                \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                 (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                < \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                   (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "by (auto simp add: tarjan_disc_def)"], ["proof (state)\nthis:\n  on_new_root tarjan_params v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       (\\<forall>k<length (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n           \\<forall>j<k.\n              \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n               (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n              < \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                 (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "case (finish s s' u)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "{"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "let ?dw = \"dropWhile ((\\<noteq>) u) (tj_stack s)\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "let ?tw = \"takeWhile ((\\<noteq>) u) (tj_stack s)\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "fix a k j"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "assume A: \"a = tl ?dw\" \"k < length a\" \"j < k\"\n      and \"u \\<in> set (tj_stack s)\""], ["proof (state)\nthis:\n  a = tl (dropWhile ((\\<noteq>) u) (tj_stack s))\n  k < length a\n  j < k\n  u \\<in> set (tj_stack s)\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "hence \"?dw \\<noteq> []\""], ["proof (prove)\nusing this:\n  a = tl (dropWhile ((\\<noteq>) u) (tj_stack s))\n  k < length a\n  j < k\n  u \\<in> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "define j' k' where \"j' = Suc j + length ?tw\" and \"k' = Suc k + length ?tw\""], ["proof (state)\nthis:\n  j' = Suc j + length (takeWhile ((\\<noteq>) u) (tj_stack s))\n  k' = Suc k + length (takeWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "with \\<open>j < k\\<close>"], ["proof (chain)\npicking this:\n  j < k\n  j' = Suc j + length (takeWhile ((\\<noteq>) u) (tj_stack s))\n  k' = Suc k + length (takeWhile ((\\<noteq>) u) (tj_stack s))", "have \"j' < k'\""], ["proof (prove)\nusing this:\n  j < k\n  j' = Suc j + length (takeWhile ((\\<noteq>) u) (tj_stack s))\n  k' = Suc k + length (takeWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. j' < k'", "by simp"], ["proof (state)\nthis:\n  j' < k'\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "have \"length (tj_stack s) = length ?tw + length ?dw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (tj_stack s) =\n    length (takeWhile ((\\<noteq>) u) (tj_stack s)) +\n    length (dropWhile ((\\<noteq>) u) (tj_stack s))", "by (simp add: length_append[symmetric])"], ["proof (state)\nthis:\n  length (tj_stack s) =\n  length (takeWhile ((\\<noteq>) u) (tj_stack s)) +\n  length (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "moreover"], ["proof (state)\nthis:\n  length (tj_stack s) =\n  length (takeWhile ((\\<noteq>) u) (tj_stack s)) +\n  length (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "from A"], ["proof (chain)\npicking this:\n  a = tl (dropWhile ((\\<noteq>) u) (tj_stack s))\n  k < length a\n  j < k", "have *: \"Suc k < length ?dw\" and **: \"Suc j < length ?dw\""], ["proof (prove)\nusing this:\n  a = tl (dropWhile ((\\<noteq>) u) (tj_stack s))\n  k < length a\n  j < k\n\ngoal (1 subgoal):\n 1. Suc k < length (dropWhile ((\\<noteq>) u) (tj_stack s)) &&&\n    Suc j < length (dropWhile ((\\<noteq>) u) (tj_stack s))", "by auto"], ["proof (state)\nthis:\n  Suc k < length (dropWhile ((\\<noteq>) u) (tj_stack s))\n  Suc j < length (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "ultimately"], ["proof (chain)\npicking this:\n  length (tj_stack s) =\n  length (takeWhile ((\\<noteq>) u) (tj_stack s)) +\n  length (dropWhile ((\\<noteq>) u) (tj_stack s))\n  Suc k < length (dropWhile ((\\<noteq>) u) (tj_stack s))\n  Suc j < length (dropWhile ((\\<noteq>) u) (tj_stack s))", "have \"k' < length (tj_stack s)\""], ["proof (prove)\nusing this:\n  length (tj_stack s) =\n  length (takeWhile ((\\<noteq>) u) (tj_stack s)) +\n  length (dropWhile ((\\<noteq>) u) (tj_stack s))\n  Suc k < length (dropWhile ((\\<noteq>) u) (tj_stack s))\n  Suc j < length (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. k' < length (tj_stack s)", "by (simp add: k'_def)"], ["proof (state)\nthis:\n  k' < length (tj_stack s)\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "with finish \\<open>j'<k'\\<close>"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  j' < k'\n  k' < length (tj_stack s)", "have \"\\<delta> s (tj_stack s ! k') < \\<delta> s (tj_stack s ! j')\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  j' < k'\n  k' < length (tj_stack s)\n\ngoal (1 subgoal):\n 1. \\<delta> s (tj_stack s ! k') < \\<delta> s (tj_stack s ! j')", "by simp"], ["proof (state)\nthis:\n  \\<delta> s (tj_stack s ! k') < \\<delta> s (tj_stack s ! j')\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "also"], ["proof (state)\nthis:\n  \\<delta> s (tj_stack s ! k') < \\<delta> s (tj_stack s ! j')\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "from dropWhile_nth[OF *]"], ["proof (chain)\npicking this:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc k =\n  tj_stack s ! (Suc k + length (takeWhile ((\\<noteq>) u) (tj_stack s)))", "have \"tj_stack s ! k' = ?dw ! Suc k\""], ["proof (prove)\nusing this:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc k =\n  tj_stack s ! (Suc k + length (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (1 subgoal):\n 1. tj_stack s ! k' = dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc k", "by (simp add: k'_def)"], ["proof (state)\nthis:\n  tj_stack s ! k' = dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc k\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "also"], ["proof (state)\nthis:\n  tj_stack s ! k' = dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc k\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "from dropWhile_nth[OF **]"], ["proof (chain)\npicking this:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc j =\n  tj_stack s ! (Suc j + length (takeWhile ((\\<noteq>) u) (tj_stack s)))", "have \"tj_stack s ! j' = ?dw ! Suc j\""], ["proof (prove)\nusing this:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc j =\n  tj_stack s ! (Suc j + length (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (1 subgoal):\n 1. tj_stack s ! j' = dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc j", "by (simp add: j'_def)"], ["proof (state)\nthis:\n  tj_stack s ! j' = dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc j\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "also"], ["proof (state)\nthis:\n  tj_stack s ! j' = dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc j\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "from nth_tl[OF \\<open>?dw \\<noteq> []\\<close>]"], ["proof (chain)\npicking this:\n  tl (dropWhile ((\\<noteq>) u) (tj_stack s)) ! ?n =\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc ?n", "have \"?dw ! Suc k = a ! k\""], ["proof (prove)\nusing this:\n  tl (dropWhile ((\\<noteq>) u) (tj_stack s)) ! ?n =\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc ?n\n\ngoal (1 subgoal):\n 1. dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc k = a ! k", "by (simp add: A)"], ["proof (state)\nthis:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc k = a ! k\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "also"], ["proof (state)\nthis:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc k = a ! k\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "from nth_tl[OF \\<open>?dw \\<noteq> []\\<close>]"], ["proof (chain)\npicking this:\n  tl (dropWhile ((\\<noteq>) u) (tj_stack s)) ! ?n =\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc ?n", "have \"?dw ! Suc j = a ! j\""], ["proof (prove)\nusing this:\n  tl (dropWhile ((\\<noteq>) u) (tj_stack s)) ! ?n =\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc ?n\n\ngoal (1 subgoal):\n 1. dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc j = a ! j", "by (simp add: A)"], ["proof (state)\nthis:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc j = a ! j\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "finally"], ["proof (chain)\npicking this:\n  \\<delta> s (a ! k) < \\<delta> s (a ! j)", "have \"\\<delta> s (a ! k) < \\<delta> s (a ! j)\""], ["proof (prove)\nusing this:\n  \\<delta> s (a ! k) < \\<delta> s (a ! j)\n\ngoal (1 subgoal):\n 1. \\<delta> s (a ! k) < \\<delta> s (a ! j)", "."], ["proof (state)\nthis:\n  \\<delta> s (a ! k) < \\<delta> s (a ! j)\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?a9 = tl (dropWhile ((\\<noteq>) u) (tj_stack s));\n   ?k9 < length ?a9; ?j9 < ?k9; u \\<in> set (tj_stack s)\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (?a9 ! ?k9) < \\<delta> s (?a9 ! ?j9)\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "note aux = this"], ["proof (state)\nthis:\n  \\<lbrakk>?a9 = tl (dropWhile ((\\<noteq>) u) (tj_stack s));\n   ?k9 < length ?a9; ?j9 < ?k9; u \\<in> set (tj_stack s)\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s (?a9 ! ?k9) < \\<delta> s (?a9 ! ?j9)\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. on_finish tarjan_params u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         (\\<forall>k<length (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n             \\<forall>j<k.\n                \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                 (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                < \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                   (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s;\n     \\<forall>k<length (tj_stack s).\n        \\<forall>j<k.\n           \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> tarjan_fin (hd (stack s))\n                       (finish (hd (stack s)) s) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           (\\<forall>k<length\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                               \\<forall>j<k.\n                                  \\<delta> s\n                                   (tj_stack\n                                     (s'\\<lparr>state.more := x\\<rparr>) !\n                                    k)\n                                  < \\<delta> s\n                                     (tj_stack\n (s'\\<lparr>state.more := x\\<rparr>) !\nj)))", "unfolding tarjan_fin_def tj_stack_pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s;\n     \\<forall>k<length (tj_stack s).\n        \\<forall>j<k.\n           \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> (let ll = if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s))));\n                           s' = finish (hd (stack s)) s\n                             \\<lparr>lowlink := ll\\<rparr>\n                       in ASSERT\n                           (hd (stack s)\n                            \\<in> set (tj_stack\n  (finish (hd (stack s)) s))) \\<bind>\n                          (\\<lambda>_.\n                              ASSERT\n                               (distinct\n                                 (tj_stack\n                                   (finish (hd (stack s)) s))) \\<bind>\n                              (\\<lambda>_.\n                                  if \\<zeta> (finish (hd (stack s)) s)\n(hd (stack s)) =\n                                     \\<delta> (finish (hd (stack s)) s)\n(hd (stack s))\n                                  then ASSERT\n  (scc_root (finish (hd (stack s)) s) (hd (stack s))\n    (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_.\n     RETURN\n      (tl (dropWhile ((\\<noteq>) (hd (stack s)))\n            (tj_stack (finish (hd (stack s)) s))),\n       insert (hd (stack s))\n        (set (takeWhile ((\\<noteq>) (hd (stack s)))\n               (tj_stack (finish (hd (stack s)) s))))) \\<bind>\n     (\\<lambda>(tjs, scc).\n         NOOP\n          (s'\\<lparr>tj_stack := tjs,\n                sccs :=\n                  insert scc (sccs (finish (hd (stack s)) s))\\<rparr>)))\n                                  else ASSERT\n  (\\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n           (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_. NOOP s')))) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           (\\<forall>k<length\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                               \\<forall>j<k.\n                                  \\<delta> s\n                                   (tj_stack\n                                     (s'\\<lparr>state.more := x\\<rparr>) !\n                                    k)\n                                  < \\<delta> s\n                                     (tj_stack\n (s'\\<lparr>state.more := x\\<rparr>) !\nj)))", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 k j.\n       \\<lbrakk>Tarjan_invar G s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; stack s \\<noteq> []; u = hd (stack s);\n        pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n        hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n        distinct (tj_stack (finish (hd (stack s)) s));\n        \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) =\n        \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n        scc_root (finish (hd (stack s)) s) (hd (stack s))\n         (scc_of E (hd (stack s)));\n        (tl (dropWhile ((\\<noteq>) (hd (stack s)))\n              (tj_stack (finish (hd (stack s)) s))),\n         insert (hd (stack s))\n          (set (takeWhile ((\\<noteq>) (hd (stack s)))\n                 (tj_stack (finish (hd (stack s)) s))))) =\n        (x1, x2);\n        Tarjan_invar G\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    state.more\n                     (finish (hd (stack s)) s\n                      \\<lparr>lowlink :=\n                                if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n                         tj_stack := x1,\n                         sccs :=\n                           insert x2\n                            (sccs\n                              (finish (hd (stack s)) s))\\<rparr>)\\<rparr>);\n        k < length\n             (tj_stack\n               (s'\\<lparr>state.more :=\n                            state.more\n                             (finish (hd (stack s)) s\n                              \\<lparr>lowlink :=\n  if stack (finish (hd (stack s)) s) = []\n  then lowlink (finish (hd (stack s)) s)\n  else let u = hd (stack (finish (hd (stack s)) s))\n       in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n          min (\\<zeta> (finish (hd (stack s)) s) u)\n           (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n                                 tj_stack := x1,\n                                 sccs :=\n                                   insert x2\n                                    (sccs\n(finish (hd (stack s)) s))\\<rparr>)\\<rparr>));\n        j < k\\<rbrakk>\n       \\<Longrightarrow> \\<delta> s\n                          (tj_stack\n                            (s'\\<lparr>state.more :=\n   state.more\n    (finish (hd (stack s)) s\n     \\<lparr>lowlink :=\n               if stack (finish (hd (stack s)) s) = []\n               then lowlink (finish (hd (stack s)) s)\n               else let u = hd (stack (finish (hd (stack s)) s))\n                    in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                       min (\\<zeta> (finish (hd (stack s)) s) u)\n                        (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n        tj_stack := x1,\n        sccs :=\n          insert x2 (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>) !\n                           k)\n                         < \\<delta> s\n                            (tj_stack\n                              (s'\\<lparr>state.more :=\n     state.more\n      (finish (hd (stack s)) s\n       \\<lparr>lowlink :=\n                 if stack (finish (hd (stack s)) s) = []\n                 then lowlink (finish (hd (stack s)) s)\n                 else let u = hd (stack (finish (hd (stack s)) s))\n                      in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                         min (\\<zeta> (finish (hd (stack s)) s) u)\n                          (\\<zeta> (finish (hd (stack s)) s)\n                            (hd (stack s)))),\n          tj_stack := x1,\n          sccs :=\n            insert x2 (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>) !\n                             j)\n 2. \\<And>k j.\n       \\<lbrakk>Tarjan_invar G s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; stack s \\<noteq> []; u = hd (stack s);\n        pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n        hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n        distinct (tj_stack (finish (hd (stack s)) s));\n        \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) \\<noteq>\n        \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n        \\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n                (scc_of E (hd (stack s)));\n        Tarjan_invar G\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    state.more\n                     (finish (hd (stack s)) s\n                      \\<lparr>lowlink :=\n                                if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s))))\\<rparr>)\\<rparr>);\n        k < length\n             (tj_stack\n               (s'\\<lparr>state.more :=\n                            state.more\n                             (finish (hd (stack s)) s\n                              \\<lparr>lowlink :=\n  if stack (finish (hd (stack s)) s) = []\n  then lowlink (finish (hd (stack s)) s)\n  else let u = hd (stack (finish (hd (stack s)) s))\n       in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n          min (\\<zeta> (finish (hd (stack s)) s) u)\n           (\\<zeta> (finish (hd (stack s)) s)\n             (hd (stack s))))\\<rparr>)\\<rparr>));\n        j < k\\<rbrakk>\n       \\<Longrightarrow> \\<delta> s\n                          (tj_stack\n                            (s'\\<lparr>state.more :=\n   state.more\n    (finish (hd (stack s)) s\n     \\<lparr>lowlink :=\n               if stack (finish (hd (stack s)) s) = []\n               then lowlink (finish (hd (stack s)) s)\n               else let u = hd (stack (finish (hd (stack s)) s))\n                    in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                       min (\\<zeta> (finish (hd (stack s)) s) u)\n                        (\\<zeta> (finish (hd (stack s)) s)\n                          (hd (stack s))))\\<rparr>)\\<rparr>) !\n                           k)\n                         < \\<delta> s\n                            (tj_stack\n                              (s'\\<lparr>state.more :=\n     state.more\n      (finish (hd (stack s)) s\n       \\<lparr>lowlink :=\n                 if stack (finish (hd (stack s)) s) = []\n                 then lowlink (finish (hd (stack s)) s)\n                 else let u = hd (stack (finish (hd (stack s)) s))\n                      in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                         min (\\<zeta> (finish (hd (stack s)) s) u)\n                          (\\<zeta> (finish (hd (stack s)) s)\n                            (hd (stack s))))\\<rparr>)\\<rparr>) !\n                             j)", "apply (auto intro!: aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  on_finish tarjan_params u s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       (\\<forall>k<length (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n           \\<forall>j<k.\n              \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n               (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n              < \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                 (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>k<length (tj_stack (empty_state x)).\n            \\<forall>j<k.\n               \\<delta> (empty_state x) (tj_stack (empty_state x) ! k)\n               < \\<delta> (empty_state x) (tj_stack (empty_state x) ! j))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>k<length (tj_stack s).\n           \\<forall>j<k.\n              \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>k<length\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<forall>j<k.\n                                     \\<delta>\n(s'\\<lparr>state.more := x\\<rparr>)\n(tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! k)\n                                     < \\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>)\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>) ! j)))", "qed (simp_all add: tarjan_back_def)"], ["", "end"], ["", "end"], ["", "context Tarjan_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma tj_stack_incr_disc:\n    assumes \"k < length (tj_stack s)\"\n    and \"j < k\"\n    shows \"\\<delta> s (tj_stack s ! j) > \\<delta> s (tj_stack s ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)", "using assms i_tj_stack_incr_disc[THEN make_invar_thm]"], ["proof (prove)\nusing this:\n  k < length (tj_stack s)\n  j < k\n  \\<forall>k<length (tj_stack s).\n     \\<forall>j<k. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)\n\ngoal (1 subgoal):\n 1. \\<delta> s (tj_stack s ! k) < \\<delta> s (tj_stack s ! j)", "by blast"], ["", "lemma tjs_disc_dw_tw:\n    fixes u\n    defines \"dw \\<equiv> dropWhile ((\\<noteq>) u) (tj_stack s)\"\n    defines \"tw \\<equiv> takeWhile ((\\<noteq>) u) (tj_stack s)\"\n    assumes \"x \\<in> set dw\" \"y \\<in> set tw\"\n    shows \"\\<delta> s x < \\<delta> s y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y", "from assms"], ["proof (chain)\npicking this:\n  dw \\<equiv> dropWhile ((\\<noteq>) u) (tj_stack s)\n  tw \\<equiv> takeWhile ((\\<noteq>) u) (tj_stack s)\n  x \\<in> set dw\n  y \\<in> set tw", "obtain k where k: \"dw ! k = x\" \"k < length dw\""], ["proof (prove)\nusing this:\n  dw \\<equiv> dropWhile ((\\<noteq>) u) (tj_stack s)\n  tw \\<equiv> takeWhile ((\\<noteq>) u) (tj_stack s)\n  x \\<in> set dw\n  y \\<in> set tw\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>dw ! k = x; k < length dw\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  dw ! k = x\n  k < length dw\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y", "from assms"], ["proof (chain)\npicking this:\n  dw \\<equiv> dropWhile ((\\<noteq>) u) (tj_stack s)\n  tw \\<equiv> takeWhile ((\\<noteq>) u) (tj_stack s)\n  x \\<in> set dw\n  y \\<in> set tw", "obtain j where j: \"tw ! j = y\" \"j < length tw\""], ["proof (prove)\nusing this:\n  dw \\<equiv> dropWhile ((\\<noteq>) u) (tj_stack s)\n  tw \\<equiv> takeWhile ((\\<noteq>) u) (tj_stack s)\n  x \\<in> set dw\n  y \\<in> set tw\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>tw ! j = y; j < length tw\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  tw ! j = y\n  j < length tw\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y", "have \"length (tj_stack s) = length tw + length dw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (tj_stack s) = length tw + length dw", "by (simp add: length_append[symmetric] tw_def dw_def)"], ["proof (state)\nthis:\n  length (tj_stack s) = length tw + length dw\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y", "with k j"], ["proof (chain)\npicking this:\n  dw ! k = x\n  k < length dw\n  tw ! j = y\n  j < length tw\n  length (tj_stack s) = length tw + length dw", "have \"\\<delta> s (tj_stack s ! (k + length tw)) < \\<delta> s (tj_stack s ! j)\""], ["proof (prove)\nusing this:\n  dw ! k = x\n  k < length dw\n  tw ! j = y\n  j < length tw\n  length (tj_stack s) = length tw + length dw\n\ngoal (1 subgoal):\n 1. \\<delta> s (tj_stack s ! (k + length tw)) < \\<delta> s (tj_stack s ! j)", "by (simp add: tj_stack_incr_disc)"], ["proof (state)\nthis:\n  \\<delta> s (tj_stack s ! (k + length tw)) < \\<delta> s (tj_stack s ! j)\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y", "also"], ["proof (state)\nthis:\n  \\<delta> s (tj_stack s ! (k + length tw)) < \\<delta> s (tj_stack s ! j)\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y", "from j takeWhile_nth"], ["proof (chain)\npicking this:\n  tw ! j = y\n  j < length tw\n  ?j < length (takeWhile ?P ?xs) \\<Longrightarrow>\n  takeWhile ?P ?xs ! ?j = ?xs ! ?j", "have \"tj_stack s ! j = y\""], ["proof (prove)\nusing this:\n  tw ! j = y\n  j < length tw\n  ?j < length (takeWhile ?P ?xs) \\<Longrightarrow>\n  takeWhile ?P ?xs ! ?j = ?xs ! ?j\n\ngoal (1 subgoal):\n 1. tj_stack s ! j = y", "by (metis tw_def)"], ["proof (state)\nthis:\n  tj_stack s ! j = y\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y", "also"], ["proof (state)\nthis:\n  tj_stack s ! j = y\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y", "from dropWhile_nth k"], ["proof (chain)\npicking this:\n  ?j < length (dropWhile ?P ?xs) \\<Longrightarrow>\n  dropWhile ?P ?xs ! ?j = ?xs ! (?j + length (takeWhile ?P ?xs))\n  dw ! k = x\n  k < length dw", "have \"tj_stack s ! (k + length tw) = x\""], ["proof (prove)\nusing this:\n  ?j < length (dropWhile ?P ?xs) \\<Longrightarrow>\n  dropWhile ?P ?xs ! ?j = ?xs ! (?j + length (takeWhile ?P ?xs))\n  dw ! k = x\n  k < length dw\n\ngoal (1 subgoal):\n 1. tj_stack s ! (k + length tw) = x", "by (metis tw_def dw_def)"], ["proof (state)\nthis:\n  tj_stack s ! (k + length tw) = x\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y", "finally"], ["proof (chain)\npicking this:\n  \\<delta> s x < \\<delta> s y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<delta> s x < \\<delta> s y\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s y", "."], ["proof (state)\nthis:\n  \\<delta> s x < \\<delta> s y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "context Tarjan begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma i_sccs_finished_stack_ss_tj_stack:\n    \"is_invar (\\<lambda>s. \\<Union>(sccs s) \\<subseteq> dom (finished s) \\<and> set (stack s) \\<subseteq> set (tj_stack s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n         set (stack s) \\<subseteq> set (tj_stack s))", "proof (induct rule: establish_invarI)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "case (finish s s' u)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "let ?tw = \"takeWhile ((\\<noteq>) u) (tj_stack s)\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "let ?dw = \"dropWhile ((\\<noteq>) u) (tj_stack s)\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "{"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "fix x"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "assume A: \"x \\<noteq> u\" \"x \\<in> set ?tw\" \"u \\<in> set (tj_stack s)\""], ["proof (state)\nthis:\n  x \\<noteq> u\n  x \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n  u \\<in> set (tj_stack s)\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "hence x_tj: \"x \\<in> set (tj_stack s)\""], ["proof (prove)\nusing this:\n  x \\<noteq> u\n  x \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n  u \\<in> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. x \\<in> set (tj_stack s)", "by (auto dest: set_takeWhileD)"], ["proof (state)\nthis:\n  x \\<in> set (tj_stack s)\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "have \"x \\<in> dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (finished s)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> dom (finished s) \\<Longrightarrow> False", "assume \"x \\<notin> dom (finished s)\""], ["proof (state)\nthis:\n  x \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (finished s) \\<Longrightarrow> False", "with x_tj tj_stack_discovered discovered_eq_finished_un_stack"], ["proof (chain)\npicking this:\n  x \\<in> set (tj_stack s)\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n  dom (discovered s) = dom (finished s) \\<union> set (stack s)\n  x \\<notin> dom (finished s)", "have \"x \\<in> set (stack s)\""], ["proof (prove)\nusing this:\n  x \\<in> set (tj_stack s)\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n  dom (discovered s) = dom (finished s) \\<union> set (stack s)\n  x \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. x \\<in> set (stack s)", "by blast"], ["proof (state)\nthis:\n  x \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (finished s) \\<Longrightarrow> False", "with \\<open>x\\<noteq>u\\<close> finish"], ["proof (chain)\npicking this:\n  x \\<noteq> u\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  x \\<in> set (stack s)", "have \"x \\<in> set (tl (stack s))\""], ["proof (prove)\nusing this:\n  x \\<noteq> u\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  x \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. x \\<in> set (tl (stack s))", "by (cases \"stack s\") auto"], ["proof (state)\nthis:\n  x \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (finished s) \\<Longrightarrow> False", "with tl_lt_stack_hd_discover finish"], ["proof (chain)\npicking this:\n  \\<lbrakk>stack s \\<noteq> []; ?x \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?x < \\<delta> s (hd (stack s))\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  x \\<in> set (tl (stack s))", "have *: \"\\<delta> s x < \\<delta> s u\""], ["proof (prove)\nusing this:\n  \\<lbrakk>stack s \\<noteq> []; ?x \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?x < \\<delta> s (hd (stack s))\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  x \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<delta> s u", "by simp"], ["proof (state)\nthis:\n  \\<delta> s x < \\<delta> s u\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (finished s) \\<Longrightarrow> False", "from A"], ["proof (chain)\npicking this:\n  x \\<noteq> u\n  x \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n  u \\<in> set (tj_stack s)", "have \"?dw \\<noteq> []\""], ["proof (prove)\nusing this:\n  x \\<noteq> u\n  x \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n  u \\<in> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> []\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (finished s) \\<Longrightarrow> False", "with hd_dropWhile[OF this] hd_in_set"], ["proof (chain)\npicking this:\n  \\<not> u \\<noteq> hd (dropWhile ((\\<noteq>) u) (tj_stack s))\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> []", "have \"u \\<in> set ?dw\""], ["proof (prove)\nusing this:\n  \\<not> u \\<noteq> hd (dropWhile ((\\<noteq>) u) (tj_stack s))\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> []\n\ngoal (1 subgoal):\n 1. u \\<in> set (dropWhile ((\\<noteq>) u) (tj_stack s))", "by metis"], ["proof (state)\nthis:\n  u \\<in> set (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (finished s) \\<Longrightarrow> False", "with tjs_disc_dw_tw \\<open>x \\<in> set ?tw\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set (dropWhile ((\\<noteq>) ?u) (tj_stack s));\n   ?y \\<in> set (takeWhile ((\\<noteq>) ?u) (tj_stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?x < \\<delta> s ?y\n  x \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n  u \\<in> set (dropWhile ((\\<noteq>) u) (tj_stack s))", "have \"\\<delta> s u < \\<delta> s x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (dropWhile ((\\<noteq>) ?u) (tj_stack s));\n   ?y \\<in> set (takeWhile ((\\<noteq>) ?u) (tj_stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?x < \\<delta> s ?y\n  x \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n  u \\<in> set (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<delta> s x", "by simp"], ["proof (state)\nthis:\n  \\<delta> s u < \\<delta> s x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (finished s) \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  \\<delta> s x < \\<delta> s u\n  \\<delta> s u < \\<delta> s x", "show False"], ["proof (prove)\nusing this:\n  \\<delta> s x < \\<delta> s u\n  \\<delta> s u < \\<delta> s x\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> dom (finished s)\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "hence \"\\<exists>y. finished s x = Some y\""], ["proof (prove)\nusing this:\n  x \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<exists>y. finished s x = Some y", "by blast"], ["proof (state)\nthis:\n  \\<exists>y. finished s x = Some y\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x9 \\<noteq> u;\n   ?x9 \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s));\n   u \\<in> set (tj_stack s)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y. finished s ?x9 = Some y\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "note aux_scc = this"], ["proof (state)\nthis:\n  \\<lbrakk>?x9 \\<noteq> u;\n   ?x9 \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s));\n   u \\<in> set (tj_stack s)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y. finished s ?x9 = Some y\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?x9 \\<noteq> u;\n   ?x9 \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s));\n   u \\<in> set (tj_stack s)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y. finished s ?x9 = Some y\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "fix  x"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "assume A: \"x \\<in> set (tl (stack s))\" \"u \\<in> set (tj_stack s)\""], ["proof (state)\nthis:\n  x \\<in> set (tl (stack s))\n  u \\<in> set (tj_stack s)\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "with finish stack_distinct"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  distinct (stack s)\n  x \\<in> set (tl (stack s))\n  u \\<in> set (tj_stack s)", "have \"x \\<noteq> u\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  distinct (stack s)\n  x \\<in> set (tl (stack s))\n  u \\<in> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. x \\<noteq> u", "by (cases \"stack s\") auto"], ["proof (state)\nthis:\n  x \\<noteq> u\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "moreover"], ["proof (state)\nthis:\n  x \\<noteq> u\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "from A"], ["proof (chain)\npicking this:\n  x \\<in> set (tl (stack s))\n  u \\<in> set (tj_stack s)", "have \"x \\<in> set (stack s)\""], ["proof (prove)\nusing this:\n  x \\<in> set (tl (stack s))\n  u \\<in> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. x \\<in> set (stack s)", "by (metis in_set_tlD)"], ["proof (state)\nthis:\n  x \\<in> set (stack s)\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "with stack_not_finished"], ["proof (chain)\npicking this:\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n  x \\<in> set (stack s)", "have \"x \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n  x \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (finished s)", "by simp"], ["proof (state)\nthis:\n  x \\<notin> dom (finished s)\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "with A aux_scc[OF \\<open>x \\<noteq> u\\<close>]"], ["proof (chain)\npicking this:\n  x \\<in> set (tl (stack s))\n  u \\<in> set (tj_stack s)\n  \\<lbrakk>x \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s));\n   u \\<in> set (tj_stack s)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y. finished s x = Some y\n  x \\<notin> dom (finished s)", "have \"x \\<notin> set ?tw\""], ["proof (prove)\nusing this:\n  x \\<in> set (tl (stack s))\n  u \\<in> set (tj_stack s)\n  \\<lbrakk>x \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s));\n   u \\<in> set (tj_stack s)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y. finished s x = Some y\n  x \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. x \\<notin> set (takeWhile ((\\<noteq>) u) (tj_stack s))", "by blast"], ["proof (state)\nthis:\n  x \\<notin> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "moreover"], ["proof (state)\nthis:\n  x \\<notin> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "from finish \\<open>x \\<in> set (stack s)\\<close>"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  x \\<in> set (stack s)", "have \"x \\<in> set (tj_stack s)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  x \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. x \\<in> set (tj_stack s)", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (tj_stack s)\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "moreover"], ["proof (state)\nthis:\n  x \\<in> set (tj_stack s)\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "note tjs_union[OF \\<open>u \\<in> set (tj_stack s)\\<close>]"], ["proof (state)\nthis:\n  set (tj_stack s) =\n  set (tl (dropWhile ((\\<noteq>) u) (tj_stack s))) \\<union>\n  insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "ultimately"], ["proof (chain)\npicking this:\n  x \\<noteq> u\n  x \\<notin> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n  x \\<in> set (tj_stack s)\n  set (tj_stack s) =\n  set (tl (dropWhile ((\\<noteq>) u) (tj_stack s))) \\<union>\n  insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "have \"x \\<in> set (tl ?dw)\""], ["proof (prove)\nusing this:\n  x \\<noteq> u\n  x \\<notin> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n  x \\<in> set (tj_stack s)\n  set (tj_stack s) =\n  set (tl (dropWhile ((\\<noteq>) u) (tj_stack s))) \\<union>\n  insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (1 subgoal):\n 1. x \\<in> set (tl (dropWhile ((\\<noteq>) u) (tj_stack s)))", "by blast"], ["proof (state)\nthis:\n  x \\<in> set (tl (dropWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x9 \\<in> set (tl (stack s)); u \\<in> set (tj_stack s)\\<rbrakk>\n  \\<Longrightarrow> ?x9\n                    \\<in> set (tl (dropWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "note aux_tj = this"], ["proof (state)\nthis:\n  \\<lbrakk>?x9 \\<in> set (tl (stack s)); u \\<in> set (tj_stack s)\\<rbrakk>\n  \\<Longrightarrow> ?x9\n                    \\<in> set (tl (dropWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. on_finish tarjan_params u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         \\<Union> (sccs (s'\\<lparr>state.more := x\\<rparr>))\n         \\<subseteq> dom (finished\n                           (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n         set (stack (s'\\<lparr>state.more := x\\<rparr>))\n         \\<subseteq> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s;\n     \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n     set (stack s) \\<subseteq> set (tj_stack s);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> tarjan_fin (hd (stack s))\n                       (finish (hd (stack s)) s) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           \\<Union>\n                            (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                           \\<subseteq> insert (hd (stack s))\n  (dom (finished s)) \\<and>\n                           set (tl (stack s))\n                           \\<subseteq> set\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "unfolding tarjan_fin_def tj_stack_pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s;\n     \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n     set (stack s) \\<subseteq> set (tj_stack s);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> (let ll = if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s))));\n                           s' = finish (hd (stack s)) s\n                             \\<lparr>lowlink := ll\\<rparr>\n                       in ASSERT\n                           (hd (stack s)\n                            \\<in> set (tj_stack\n  (finish (hd (stack s)) s))) \\<bind>\n                          (\\<lambda>_.\n                              ASSERT\n                               (distinct\n                                 (tj_stack\n                                   (finish (hd (stack s)) s))) \\<bind>\n                              (\\<lambda>_.\n                                  if \\<zeta> (finish (hd (stack s)) s)\n(hd (stack s)) =\n                                     \\<delta> (finish (hd (stack s)) s)\n(hd (stack s))\n                                  then ASSERT\n  (scc_root (finish (hd (stack s)) s) (hd (stack s))\n    (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_.\n     RETURN\n      (tl (dropWhile ((\\<noteq>) (hd (stack s)))\n            (tj_stack (finish (hd (stack s)) s))),\n       insert (hd (stack s))\n        (set (takeWhile ((\\<noteq>) (hd (stack s)))\n               (tj_stack (finish (hd (stack s)) s))))) \\<bind>\n     (\\<lambda>(tjs, scc).\n         NOOP\n          (s'\\<lparr>tj_stack := tjs,\n                sccs :=\n                  insert scc (sccs (finish (hd (stack s)) s))\\<rparr>)))\n                                  else ASSERT\n  (\\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n           (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_. NOOP s')))) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           \\<Union>\n                            (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                           \\<subseteq> insert (hd (stack s))\n  (dom (finished s)) \\<and>\n                           set (tl (stack s))\n                           \\<subseteq> set\n  (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "apply (refine_vcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>Tarjan_invar G s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; stack s \\<noteq> []; u = hd (stack s);\n        pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n        hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n        distinct (tj_stack (finish (hd (stack s)) s));\n        \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) =\n        \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n        scc_root (finish (hd (stack s)) s) (hd (stack s))\n         (scc_of E (hd (stack s)));\n        (tl (dropWhile ((\\<noteq>) (hd (stack s)))\n              (tj_stack (finish (hd (stack s)) s))),\n         insert (hd (stack s))\n          (set (takeWhile ((\\<noteq>) (hd (stack s)))\n                 (tj_stack (finish (hd (stack s)) s))))) =\n        (x1, x2);\n        Tarjan_invar G\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    state.more\n                     (finish (hd (stack s)) s\n                      \\<lparr>lowlink :=\n                                if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n                         tj_stack := x1,\n                         sccs :=\n                           insert x2\n                            (sccs\n                              (finish (hd (stack s))\n                                s))\\<rparr>)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (sccs\n                            (s'\\<lparr>state.more :=\n   state.more\n    (finish (hd (stack s)) s\n     \\<lparr>lowlink :=\n               if stack (finish (hd (stack s)) s) = []\n               then lowlink (finish (hd (stack s)) s)\n               else let u = hd (stack (finish (hd (stack s)) s))\n                    in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                       min (\\<zeta> (finish (hd (stack s)) s) u)\n                        (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n        tj_stack := x1,\n        sccs :=\n          insert x2 (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>))\n                         \\<subseteq> insert (hd (stack s))\n(dom (finished s))\n 2. \\<And>x1 x2.\n       \\<lbrakk>Tarjan_invar G s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; stack s \\<noteq> []; u = hd (stack s);\n        pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n        hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n        distinct (tj_stack (finish (hd (stack s)) s));\n        \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) =\n        \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n        scc_root (finish (hd (stack s)) s) (hd (stack s))\n         (scc_of E (hd (stack s)));\n        (tl (dropWhile ((\\<noteq>) (hd (stack s)))\n              (tj_stack (finish (hd (stack s)) s))),\n         insert (hd (stack s))\n          (set (takeWhile ((\\<noteq>) (hd (stack s)))\n                 (tj_stack (finish (hd (stack s)) s))))) =\n        (x1, x2);\n        Tarjan_invar G\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    state.more\n                     (finish (hd (stack s)) s\n                      \\<lparr>lowlink :=\n                                if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n                         tj_stack := x1,\n                         sccs :=\n                           insert x2\n                            (sccs\n                              (finish (hd (stack s))\n                                s))\\<rparr>)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s))\n                         \\<subseteq> set\n(tj_stack\n  (s'\\<lparr>state.more :=\n               state.more\n                (finish (hd (stack s)) s\n                 \\<lparr>lowlink :=\n                           if stack (finish (hd (stack s)) s) = []\n                           then lowlink (finish (hd (stack s)) s)\n                           else let u = hd (stack (finish (hd (stack s)) s))\n                                in lowlink (finish (hd (stack s)) s)(u \n                                   \\<mapsto>\n                                   min (\\<zeta> (finish (hd (stack s)) s) u)\n                                    (\\<zeta> (finish (hd (stack s)) s)\n(hd (stack s)))),\n                    tj_stack := x1,\n                    sccs :=\n                      insert x2\n                       (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>))\n 3. \\<lbrakk>Tarjan_invar G s;\n     \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n     set (stack s) \\<subseteq> set (tj_stack s);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n     hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n     distinct (tj_stack (finish (hd (stack s)) s));\n     \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) \\<noteq>\n     \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n     \\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n             (scc_of E (hd (stack s)));\n     Tarjan_invar G\n      (finish (hd (stack s)) s\n       \\<lparr>state.more :=\n                 state.more\n                  (finish (hd (stack s)) s\n                   \\<lparr>lowlink :=\n                             if stack (finish (hd (stack s)) s) = []\n                             then lowlink (finish (hd (stack s)) s)\n                             else let u =\n  hd (stack (finish (hd (stack s)) s))\n                                  in lowlink (finish (hd (stack s)) s)(u \n                                     \\<mapsto>\n                                     min\n(\\<zeta> (finish (hd (stack s)) s) u)\n(\\<zeta> (finish (hd (stack s)) s)\n  (hd (stack s))))\\<rparr>)\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (sccs\n                         (s'\\<lparr>state.more :=\nstate.more\n (finish (hd (stack s)) s\n  \\<lparr>lowlink :=\n            if stack (finish (hd (stack s)) s) = []\n            then lowlink (finish (hd (stack s)) s)\n            else let u = hd (stack (finish (hd (stack s)) s))\n                 in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                    min (\\<zeta> (finish (hd (stack s)) s) u)\n                     (\\<zeta> (finish (hd (stack s)) s)\n                       (hd (stack s))))\\<rparr>)\\<rparr>))\n                      \\<subseteq> insert (hd (stack s)) (dom (finished s))\n 4. \\<lbrakk>Tarjan_invar G s;\n     \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n     set (stack s) \\<subseteq> set (tj_stack s);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n     hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n     distinct (tj_stack (finish (hd (stack s)) s));\n     \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) \\<noteq>\n     \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n     \\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n             (scc_of E (hd (stack s)));\n     Tarjan_invar G\n      (finish (hd (stack s)) s\n       \\<lparr>state.more :=\n                 state.more\n                  (finish (hd (stack s)) s\n                   \\<lparr>lowlink :=\n                             if stack (finish (hd (stack s)) s) = []\n                             then lowlink (finish (hd (stack s)) s)\n                             else let u =\n  hd (stack (finish (hd (stack s)) s))\n                                  in lowlink (finish (hd (stack s)) s)(u \n                                     \\<mapsto>\n                                     min\n(\\<zeta> (finish (hd (stack s)) s) u)\n(\\<zeta> (finish (hd (stack s)) s)\n  (hd (stack s))))\\<rparr>)\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> set (tl (stack s))\n                      \\<subseteq> set (tj_stack\n  (s'\\<lparr>state.more :=\n               state.more\n                (finish (hd (stack s)) s\n                 \\<lparr>lowlink :=\n                           if stack (finish (hd (stack s)) s) = []\n                           then lowlink (finish (hd (stack s)) s)\n                           else let u = hd (stack (finish (hd (stack s)) s))\n                                in lowlink (finish (hd (stack s)) s)(u \n                                   \\<mapsto>\n                                   min (\\<zeta> (finish (hd (stack s)) s) u)\n                                    (\\<zeta> (finish (hd (stack s)) s)\n(hd (stack s))))\\<rparr>)\\<rparr>))", "using aux_scc aux_tj"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x9 \\<noteq> u;\n   ?x9 \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s));\n   u \\<in> set (tj_stack s)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y. finished s ?x9 = Some y\n  \\<lbrakk>?x9 \\<in> set (tl (stack s)); u \\<in> set (tj_stack s)\\<rbrakk>\n  \\<Longrightarrow> ?x9\n                    \\<in> set (tl (dropWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>Tarjan_invar G s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; stack s \\<noteq> []; u = hd (stack s);\n        pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n        hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n        distinct (tj_stack (finish (hd (stack s)) s));\n        \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) =\n        \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n        scc_root (finish (hd (stack s)) s) (hd (stack s))\n         (scc_of E (hd (stack s)));\n        (tl (dropWhile ((\\<noteq>) (hd (stack s)))\n              (tj_stack (finish (hd (stack s)) s))),\n         insert (hd (stack s))\n          (set (takeWhile ((\\<noteq>) (hd (stack s)))\n                 (tj_stack (finish (hd (stack s)) s))))) =\n        (x1, x2);\n        Tarjan_invar G\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    state.more\n                     (finish (hd (stack s)) s\n                      \\<lparr>lowlink :=\n                                if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n                         tj_stack := x1,\n                         sccs :=\n                           insert x2\n                            (sccs\n                              (finish (hd (stack s))\n                                s))\\<rparr>)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (sccs\n                            (s'\\<lparr>state.more :=\n   state.more\n    (finish (hd (stack s)) s\n     \\<lparr>lowlink :=\n               if stack (finish (hd (stack s)) s) = []\n               then lowlink (finish (hd (stack s)) s)\n               else let u = hd (stack (finish (hd (stack s)) s))\n                    in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                       min (\\<zeta> (finish (hd (stack s)) s) u)\n                        (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n        tj_stack := x1,\n        sccs :=\n          insert x2 (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>))\n                         \\<subseteq> insert (hd (stack s))\n(dom (finished s))\n 2. \\<And>x1 x2.\n       \\<lbrakk>Tarjan_invar G s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; stack s \\<noteq> []; u = hd (stack s);\n        pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n        hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n        distinct (tj_stack (finish (hd (stack s)) s));\n        \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) =\n        \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n        scc_root (finish (hd (stack s)) s) (hd (stack s))\n         (scc_of E (hd (stack s)));\n        (tl (dropWhile ((\\<noteq>) (hd (stack s)))\n              (tj_stack (finish (hd (stack s)) s))),\n         insert (hd (stack s))\n          (set (takeWhile ((\\<noteq>) (hd (stack s)))\n                 (tj_stack (finish (hd (stack s)) s))))) =\n        (x1, x2);\n        Tarjan_invar G\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    state.more\n                     (finish (hd (stack s)) s\n                      \\<lparr>lowlink :=\n                                if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n                         tj_stack := x1,\n                         sccs :=\n                           insert x2\n                            (sccs\n                              (finish (hd (stack s))\n                                s))\\<rparr>)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s))\n                         \\<subseteq> set\n(tj_stack\n  (s'\\<lparr>state.more :=\n               state.more\n                (finish (hd (stack s)) s\n                 \\<lparr>lowlink :=\n                           if stack (finish (hd (stack s)) s) = []\n                           then lowlink (finish (hd (stack s)) s)\n                           else let u = hd (stack (finish (hd (stack s)) s))\n                                in lowlink (finish (hd (stack s)) s)(u \n                                   \\<mapsto>\n                                   min (\\<zeta> (finish (hd (stack s)) s) u)\n                                    (\\<zeta> (finish (hd (stack s)) s)\n(hd (stack s)))),\n                    tj_stack := x1,\n                    sccs :=\n                      insert x2\n                       (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>))\n 3. \\<lbrakk>Tarjan_invar G s;\n     \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n     set (stack s) \\<subseteq> set (tj_stack s);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n     hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n     distinct (tj_stack (finish (hd (stack s)) s));\n     \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) \\<noteq>\n     \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n     \\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n             (scc_of E (hd (stack s)));\n     Tarjan_invar G\n      (finish (hd (stack s)) s\n       \\<lparr>state.more :=\n                 state.more\n                  (finish (hd (stack s)) s\n                   \\<lparr>lowlink :=\n                             if stack (finish (hd (stack s)) s) = []\n                             then lowlink (finish (hd (stack s)) s)\n                             else let u =\n  hd (stack (finish (hd (stack s)) s))\n                                  in lowlink (finish (hd (stack s)) s)(u \n                                     \\<mapsto>\n                                     min\n(\\<zeta> (finish (hd (stack s)) s) u)\n(\\<zeta> (finish (hd (stack s)) s)\n  (hd (stack s))))\\<rparr>)\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (sccs\n                         (s'\\<lparr>state.more :=\nstate.more\n (finish (hd (stack s)) s\n  \\<lparr>lowlink :=\n            if stack (finish (hd (stack s)) s) = []\n            then lowlink (finish (hd (stack s)) s)\n            else let u = hd (stack (finish (hd (stack s)) s))\n                 in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                    min (\\<zeta> (finish (hd (stack s)) s) u)\n                     (\\<zeta> (finish (hd (stack s)) s)\n                       (hd (stack s))))\\<rparr>)\\<rparr>))\n                      \\<subseteq> insert (hd (stack s)) (dom (finished s))\n 4. \\<lbrakk>Tarjan_invar G s;\n     \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n     set (stack s) \\<subseteq> set (tj_stack s);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n     hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n     distinct (tj_stack (finish (hd (stack s)) s));\n     \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) \\<noteq>\n     \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n     \\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n             (scc_of E (hd (stack s)));\n     Tarjan_invar G\n      (finish (hd (stack s)) s\n       \\<lparr>state.more :=\n                 state.more\n                  (finish (hd (stack s)) s\n                   \\<lparr>lowlink :=\n                             if stack (finish (hd (stack s)) s) = []\n                             then lowlink (finish (hd (stack s)) s)\n                             else let u =\n  hd (stack (finish (hd (stack s)) s))\n                                  in lowlink (finish (hd (stack s)) s)(u \n                                     \\<mapsto>\n                                     min\n(\\<zeta> (finish (hd (stack s)) s) u)\n(\\<zeta> (finish (hd (stack s)) s)\n  (hd (stack s))))\\<rparr>)\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> set (tl (stack s))\n                      \\<subseteq> set (tj_stack\n  (s'\\<lparr>state.more :=\n               state.more\n                (finish (hd (stack s)) s\n                 \\<lparr>lowlink :=\n                           if stack (finish (hd (stack s)) s) = []\n                           then lowlink (finish (hd (stack s)) s)\n                           else let u = hd (stack (finish (hd (stack s)) s))\n                                in lowlink (finish (hd (stack s)) s)(u \n                                   \\<mapsto>\n                                   min (\\<zeta> (finish (hd (stack s)) s) u)\n                                    (\\<zeta> (finish (hd (stack s)) s)\n(hd (stack s))))\\<rparr>)\\<rparr>))", "apply (auto dest: in_set_tlD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  on_finish tarjan_params u s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       \\<Union> (sccs (s'\\<lparr>state.more := x\\<rparr>))\n       \\<subseteq> dom (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n       set (stack (s'\\<lparr>state.more := x\\<rparr>))\n       \\<subseteq> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n\ngoal (5 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<Union> (sccs (empty_state x))\n         \\<subseteq> dom (finished (empty_state x)) \\<and>\n         set (stack (empty_state x))\n         \\<subseteq> set (tj_stack (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n        set (stack s) \\<subseteq> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              \\<Union>\n                               (sccs (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> dom\n     (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n                              set (stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "qed (auto simp add: tarjan_disc_def tarjan_back_def)"], ["", "lemma i_tj_stack_ss_stack_finished:\n    \"is_invar (\\<lambda>s. set (tj_stack s) \\<subseteq> set (stack s) \\<union> dom (finished s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         set (tj_stack s)\n         \\<subseteq> set (stack s) \\<union> dom (finished s))", "proof (induct rule: establish_invarI)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         set (tj_stack (empty_state x))\n         \\<subseteq> set (stack (empty_state x)) \\<union>\n                     dom (finished (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))", "case (finish s)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  set (tj_stack s) \\<subseteq> set (stack s) \\<union> dom (finished s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         set (tj_stack (empty_state x))\n         \\<subseteq> set (stack (empty_state x)) \\<union>\n                     dom (finished (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))", "thus ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  set (tj_stack s) \\<subseteq> set (stack s) \\<union> dom (finished s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u_ = hd (stack s)\n  pending s `` {u_} = {}\n  s'_ = finish u_ s\n\ngoal (1 subgoal):\n 1. on_finish tarjan_params u_ s'_ \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         set (tj_stack (s'_\\<lparr>state.more := x\\<rparr>))\n         \\<subseteq> set (stack\n                           (s'_\\<lparr>state.more := x\\<rparr>)) \\<union>\n                     dom (finished (s'_\\<lparr>state.more := x\\<rparr>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s;\n     set (tj_stack s) \\<subseteq> set (stack s) \\<union> dom (finished s);\n     cond s; stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {};\n     s'_ = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> tarjan_fin (hd (stack s))\n                       (finish (hd (stack s)) s) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           set (tj_stack\n                                 (s'_\\<lparr>state.more := x\\<rparr>))\n                           \\<subseteq> insert (hd (stack s))\n  (set (tl (stack s)) \\<union> dom (finished s)))", "unfolding tarjan_fin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s;\n     set (tj_stack s) \\<subseteq> set (stack s) \\<union> dom (finished s);\n     cond s; stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {};\n     s'_ = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> (let ll = if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s))));\n                           s' = finish (hd (stack s)) s\n                             \\<lparr>lowlink := ll\\<rparr>\n                       in ASSERT\n                           (hd (stack s)\n                            \\<in> set (tj_stack\n  (finish (hd (stack s)) s))) \\<bind>\n                          (\\<lambda>_.\n                              ASSERT\n                               (distinct\n                                 (tj_stack\n                                   (finish (hd (stack s)) s))) \\<bind>\n                              (\\<lambda>_.\n                                  if \\<zeta> (finish (hd (stack s)) s)\n(hd (stack s)) =\n                                     \\<delta> (finish (hd (stack s)) s)\n(hd (stack s))\n                                  then ASSERT\n  (scc_root (finish (hd (stack s)) s) (hd (stack s))\n    (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_.\n     tj_stack_pop (tj_stack (finish (hd (stack s)) s))\n      (hd (stack s)) \\<bind>\n     (\\<lambda>(tjs, scc).\n         NOOP\n          (s'\\<lparr>tj_stack := tjs,\n                sccs :=\n                  insert scc (sccs (finish (hd (stack s)) s))\\<rparr>)))\n                                  else ASSERT\n  (\\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n           (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_. NOOP s')))) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           set (tj_stack\n                                 (s'_\\<lparr>state.more := x\\<rparr>))\n                           \\<subseteq> insert (hd (stack s))\n  (set (tl (stack s)) \\<union> dom (finished s)))", "apply (refine_vcg tj_stack_pop_set_leof_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>Tarjan_invar G s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; stack s \\<noteq> []; u_ = hd (stack s);\n        pending s `` {hd (stack s)} = {}; s'_ = finish (hd (stack s)) s;\n        hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n        distinct (tj_stack (finish (hd (stack s)) s));\n        \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) =\n        \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n        scc_root (finish (hd (stack s)) s) (hd (stack s))\n         (scc_of E (hd (stack s)));\n        case x of\n        (tjs', scc) \\<Rightarrow>\n          hd (stack s)\n          \\<in> set (tj_stack (finish (hd (stack s)) s)) \\<longrightarrow>\n          set (tj_stack (finish (hd (stack s)) s)) =\n          set tjs' \\<union> scc \\<and>\n          hd (stack s) \\<in> scc;\n        x = (x1, x2);\n        Tarjan_invar G\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    state.more\n                     (finish (hd (stack s)) s\n                      \\<lparr>lowlink :=\n                                if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n                         tj_stack := x1,\n                         sccs :=\n                           insert x2\n                            (sccs\n                              (finish (hd (stack s))\n                                s))\\<rparr>)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> set (tj_stack\n                               (s'_\\<lparr>state.more :=\n       state.more\n        (finish (hd (stack s)) s\n         \\<lparr>lowlink :=\n                   if stack (finish (hd (stack s)) s) = []\n                   then lowlink (finish (hd (stack s)) s)\n                   else let u = hd (stack (finish (hd (stack s)) s))\n                        in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                           min (\\<zeta> (finish (hd (stack s)) s) u)\n                            (\\<zeta> (finish (hd (stack s)) s)\n                              (hd (stack s)))),\n            tj_stack := x1,\n            sccs :=\n              insert x2 (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>))\n                         \\<subseteq> insert (hd (stack s))\n(set (tl (stack s)) \\<union> dom (finished s))\n 2. \\<lbrakk>Tarjan_invar G s;\n     set (tj_stack s) \\<subseteq> set (stack s) \\<union> dom (finished s);\n     cond s; stack s \\<noteq> []; u_ = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s'_ = finish (hd (stack s)) s;\n     hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n     distinct (tj_stack (finish (hd (stack s)) s));\n     \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) \\<noteq>\n     \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n     \\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n             (scc_of E (hd (stack s)));\n     Tarjan_invar G\n      (finish (hd (stack s)) s\n       \\<lparr>state.more :=\n                 state.more\n                  (finish (hd (stack s)) s\n                   \\<lparr>lowlink :=\n                             if stack (finish (hd (stack s)) s) = []\n                             then lowlink (finish (hd (stack s)) s)\n                             else let u =\n  hd (stack (finish (hd (stack s)) s))\n                                  in lowlink (finish (hd (stack s)) s)(u \n                                     \\<mapsto>\n                                     min\n(\\<zeta> (finish (hd (stack s)) s) u)\n(\\<zeta> (finish (hd (stack s)) s)\n  (hd (stack s))))\\<rparr>)\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> set (tj_stack\n                            (s'_\\<lparr>state.more :=\n    state.more\n     (finish (hd (stack s)) s\n      \\<lparr>lowlink :=\n                if stack (finish (hd (stack s)) s) = []\n                then lowlink (finish (hd (stack s)) s)\n                else let u = hd (stack (finish (hd (stack s)) s))\n                     in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                        min (\\<zeta> (finish (hd (stack s)) s) u)\n                         (\\<zeta> (finish (hd (stack s)) s)\n                           (hd (stack s))))\\<rparr>)\\<rparr>))\n                      \\<subseteq> insert (hd (stack s))\n                                   (set (tl (stack s)) \\<union>\n                                    dom (finished s))", "apply ((simp, cases \"stack s\", simp_all)[])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  on_finish tarjan_params u_ s'_ \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       set (tj_stack (s'_\\<lparr>state.more := x\\<rparr>))\n       \\<subseteq> set (stack (s'_\\<lparr>state.more := x\\<rparr>)) \\<union>\n                   dom (finished (s'_\\<lparr>state.more := x\\<rparr>)))\n\ngoal (5 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         set (tj_stack (empty_state x))\n         \\<subseteq> set (stack (empty_state x)) \\<union>\n                     dom (finished (empty_state x)))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        set (tj_stack s)\n        \\<subseteq> set (stack s) \\<union> dom (finished s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              set (tj_stack\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> set\n     (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    dom (finished (s'\\<lparr>state.more := x\\<rparr>)))", "qed (auto simp add: tarjan_disc_def tarjan_back_def)"], ["", "lemma i_finished_ss_sccs_tj_stack:\n    \"is_invar (\\<lambda>s. dom (finished s) \\<subseteq> \\<Union>(sccs s) \\<union> set (tj_stack s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         dom (finished s)\n         \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s))", "proof (induction rule: establish_invarI_ND)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         dom (finished (empty_state x))\n         \\<subseteq> \\<Union> (sccs (empty_state x)) \\<union>\n                     set (tj_stack (empty_state x)))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "case (new_discover s s' v)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         dom (finished (empty_state x))\n         \\<subseteq> \\<Union> (sccs (empty_state x)) \\<union>\n                     set (tj_stack (empty_state x)))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         dom (finished (empty_state x))\n         \\<subseteq> \\<Union> (sccs (empty_state x)) \\<union>\n                     set (tj_stack (empty_state x)))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "from new_discover finished_discovered"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  dom (finished s) \\<subseteq> dom (discovered s)", "have \"v \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  v \\<notin> dom (finished s)\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         dom (finished (empty_state x))\n         \\<subseteq> \\<Union> (sccs (empty_state x)) \\<union>\n                     set (tj_stack (empty_state x)))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "with new_discover"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  v \\<notin> dom (finished s)", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  v \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. on_new_root tarjan_params v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n         \\<subseteq> \\<Union>\n                      (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n                     set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "by (auto simp add: tarjan_disc_def)"], ["proof (state)\nthis:\n  on_new_root tarjan_params v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n       \\<subseteq> \\<Union>\n                    (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n                   set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         dom (finished (empty_state x))\n         \\<subseteq> \\<Union> (sccs (empty_state x)) \\<union>\n                     set (tj_stack (empty_state x)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         dom (finished (empty_state x))\n         \\<subseteq> \\<Union> (sccs (empty_state x)) \\<union>\n                     set (tj_stack (empty_state x)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "case (finish s s' u)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         dom (finished (empty_state x))\n         \\<subseteq> \\<Union> (sccs (empty_state x)) \\<union>\n                     set (tj_stack (empty_state x)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         dom (finished (empty_state x))\n         \\<subseteq> \\<Union> (sccs (empty_state x)) \\<union>\n                     set (tj_stack (empty_state x)))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. on_finish tarjan_params u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n         \\<subseteq> \\<Union>\n                      (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n                     set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s;\n     dom (finished s)\n     \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> tarjan_fin (hd (stack s))\n                       (finish (hd (stack s)) s) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           ((\\<exists>x\n\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                hd (stack s) \\<in> x) \\<or>\n                            hd (stack s)\n                            \\<in> set (tj_stack\n  (s'\\<lparr>state.more := x\\<rparr>))) \\<and>\n                           dom (finished s)\n                           \\<subseteq> \\<Union>\n  (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "unfolding tarjan_fin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tarjan_invar G s;\n     dom (finished s)\n     \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s\\<rbrakk>\n    \\<Longrightarrow> (let ll = if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s))));\n                           s' = finish (hd (stack s)) s\n                             \\<lparr>lowlink := ll\\<rparr>\n                       in ASSERT\n                           (hd (stack s)\n                            \\<in> set (tj_stack\n  (finish (hd (stack s)) s))) \\<bind>\n                          (\\<lambda>_.\n                              ASSERT\n                               (distinct\n                                 (tj_stack\n                                   (finish (hd (stack s)) s))) \\<bind>\n                              (\\<lambda>_.\n                                  if \\<zeta> (finish (hd (stack s)) s)\n(hd (stack s)) =\n                                     \\<delta> (finish (hd (stack s)) s)\n(hd (stack s))\n                                  then ASSERT\n  (scc_root (finish (hd (stack s)) s) (hd (stack s))\n    (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_.\n     tj_stack_pop (tj_stack (finish (hd (stack s)) s))\n      (hd (stack s)) \\<bind>\n     (\\<lambda>(tjs, scc).\n         NOOP\n          (s'\\<lparr>tj_stack := tjs,\n                sccs :=\n                  insert scc (sccs (finish (hd (stack s)) s))\\<rparr>)))\n                                  else ASSERT\n  (\\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n           (scc_of E (hd (stack s)))) \\<bind>\n (\\<lambda>_. NOOP s')))) \\<le>\\<^sub>n\n                      SPEC\n                       (\\<lambda>x.\n                           Tarjan_invar G\n                            (finish (hd (stack s)) s\n                             \\<lparr>state.more :=\n x\\<rparr>) \\<longrightarrow>\n                           ((\\<exists>x\n\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                hd (stack s) \\<in> x) \\<or>\n                            hd (stack s)\n                            \\<in> set (tj_stack\n  (s'\\<lparr>state.more := x\\<rparr>))) \\<and>\n                           dom (finished s)\n                           \\<subseteq> \\<Union>\n  (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "apply (refine_vcg tj_stack_pop_set_leof_rule)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>Tarjan_invar G s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; stack s \\<noteq> []; u = hd (stack s);\n        pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n        hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n        distinct (tj_stack (finish (hd (stack s)) s));\n        \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) =\n        \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n        scc_root (finish (hd (stack s)) s) (hd (stack s))\n         (scc_of E (hd (stack s)));\n        case x of\n        (tjs', scc) \\<Rightarrow>\n          hd (stack s)\n          \\<in> set (tj_stack (finish (hd (stack s)) s)) \\<longrightarrow>\n          set (tj_stack (finish (hd (stack s)) s)) =\n          set tjs' \\<union> scc \\<and>\n          hd (stack s) \\<in> scc;\n        x = (x1, x2);\n        Tarjan_invar G\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    state.more\n                     (finish (hd (stack s)) s\n                      \\<lparr>lowlink :=\n                                if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n                         tj_stack := x1,\n                         sccs :=\n                           insert x2\n                            (sccs\n                              (finish (hd (stack s))\n                                s))\\<rparr>)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>sccs\n    (s'\\<lparr>state.more :=\n                 state.more\n                  (finish (hd (stack s)) s\n                   \\<lparr>lowlink :=\n                             if stack (finish (hd (stack s)) s) = []\n                             then lowlink (finish (hd (stack s)) s)\n                             else let u =\n  hd (stack (finish (hd (stack s)) s))\n                                  in lowlink (finish (hd (stack s)) s)(u \n                                     \\<mapsto>\n                                     min\n(\\<zeta> (finish (hd (stack s)) s) u)\n(\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n                      tj_stack := x1,\n                      sccs :=\n                        insert x2\n                         (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>).\n                             hd (stack s) \\<in> x) \\<or>\n                         hd (stack s)\n                         \\<in> set (tj_stack\n                                     (s'\n\\<lparr>state.more :=\n          state.more\n           (finish (hd (stack s)) s\n            \\<lparr>lowlink :=\n                      if stack (finish (hd (stack s)) s) = []\n                      then lowlink (finish (hd (stack s)) s)\n                      else let u = hd (stack (finish (hd (stack s)) s))\n                           in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                              min (\\<zeta> (finish (hd (stack s)) s) u)\n                               (\\<zeta> (finish (hd (stack s)) s)\n                                 (hd (stack s)))),\n               tj_stack := x1,\n               sccs :=\n                 insert x2\n                  (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>))\n 2. \\<And>x x1 x2.\n       \\<lbrakk>Tarjan_invar G s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; stack s \\<noteq> []; u = hd (stack s);\n        pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n        hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n        distinct (tj_stack (finish (hd (stack s)) s));\n        \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) =\n        \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n        scc_root (finish (hd (stack s)) s) (hd (stack s))\n         (scc_of E (hd (stack s)));\n        case x of\n        (tjs', scc) \\<Rightarrow>\n          hd (stack s)\n          \\<in> set (tj_stack (finish (hd (stack s)) s)) \\<longrightarrow>\n          set (tj_stack (finish (hd (stack s)) s)) =\n          set tjs' \\<union> scc \\<and>\n          hd (stack s) \\<in> scc;\n        x = (x1, x2);\n        Tarjan_invar G\n         (finish (hd (stack s)) s\n          \\<lparr>state.more :=\n                    state.more\n                     (finish (hd (stack s)) s\n                      \\<lparr>lowlink :=\n                                if stack (finish (hd (stack s)) s) = []\n                                then lowlink (finish (hd (stack s)) s)\n                                else let u =\n     hd (stack (finish (hd (stack s)) s))\n                                     in lowlink (finish (hd (stack s)) s)(u \n  \\<mapsto>\n  min (\\<zeta> (finish (hd (stack s)) s) u)\n   (\\<zeta> (finish (hd (stack s)) s) (hd (stack s)))),\n                         tj_stack := x1,\n                         sccs :=\n                           insert x2\n                            (sccs\n                              (finish (hd (stack s))\n                                s))\\<rparr>)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> dom (finished s)\n                         \\<subseteq> \\<Union>\n(sccs\n  (s'\\<lparr>state.more :=\n               state.more\n                (finish (hd (stack s)) s\n                 \\<lparr>lowlink :=\n                           if stack (finish (hd (stack s)) s) = []\n                           then lowlink (finish (hd (stack s)) s)\n                           else let u = hd (stack (finish (hd (stack s)) s))\n                                in lowlink (finish (hd (stack s)) s)(u \n                                   \\<mapsto>\n                                   min (\\<zeta> (finish (hd (stack s)) s) u)\n                                    (\\<zeta> (finish (hd (stack s)) s)\n(hd (stack s)))),\n                    tj_stack := x1,\n                    sccs :=\n                      insert x2\n                       (sccs\n                         (finish (hd (stack s))\n                           s))\\<rparr>)\\<rparr>)) \\<union>\n                                     set\n(tj_stack\n  (s'\\<lparr>state.more :=\n               state.more\n                (finish (hd (stack s)) s\n                 \\<lparr>lowlink :=\n                           if stack (finish (hd (stack s)) s) = []\n                           then lowlink (finish (hd (stack s)) s)\n                           else let u = hd (stack (finish (hd (stack s)) s))\n                                in lowlink (finish (hd (stack s)) s)(u \n                                   \\<mapsto>\n                                   min (\\<zeta> (finish (hd (stack s)) s) u)\n                                    (\\<zeta> (finish (hd (stack s)) s)\n(hd (stack s)))),\n                    tj_stack := x1,\n                    sccs :=\n                      insert x2\n                       (sccs (finish (hd (stack s)) s))\\<rparr>)\\<rparr>))\n 3. \\<lbrakk>Tarjan_invar G s;\n     dom (finished s)\n     \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n     hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n     distinct (tj_stack (finish (hd (stack s)) s));\n     \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) \\<noteq>\n     \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n     \\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n             (scc_of E (hd (stack s)));\n     Tarjan_invar G\n      (finish (hd (stack s)) s\n       \\<lparr>state.more :=\n                 state.more\n                  (finish (hd (stack s)) s\n                   \\<lparr>lowlink :=\n                             if stack (finish (hd (stack s)) s) = []\n                             then lowlink (finish (hd (stack s)) s)\n                             else let u =\n  hd (stack (finish (hd (stack s)) s))\n                                  in lowlink (finish (hd (stack s)) s)(u \n                                     \\<mapsto>\n                                     min\n(\\<zeta> (finish (hd (stack s)) s) u)\n(\\<zeta> (finish (hd (stack s)) s)\n  (hd (stack s))))\\<rparr>)\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x\\<in>sccs\n (s'\\<lparr>state.more :=\n              state.more\n               (finish (hd (stack s)) s\n                \\<lparr>lowlink :=\n                          if stack (finish (hd (stack s)) s) = []\n                          then lowlink (finish (hd (stack s)) s)\n                          else let u = hd (stack (finish (hd (stack s)) s))\n                               in lowlink (finish (hd (stack s)) s)(u \n                                  \\<mapsto>\n                                  min (\\<zeta> (finish (hd (stack s)) s) u)\n                                   (\\<zeta> (finish (hd (stack s)) s)\n                                     (hd (stack s))))\\<rparr>)\\<rparr>).\n                          hd (stack s) \\<in> x) \\<or>\n                      hd (stack s)\n                      \\<in> set (tj_stack\n                                  (s'\\<lparr>state.more :=\n         state.more\n          (finish (hd (stack s)) s\n           \\<lparr>lowlink :=\n                     if stack (finish (hd (stack s)) s) = []\n                     then lowlink (finish (hd (stack s)) s)\n                     else let u = hd (stack (finish (hd (stack s)) s))\n                          in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                             min (\\<zeta> (finish (hd (stack s)) s) u)\n                              (\\<zeta> (finish (hd (stack s)) s)\n                                (hd (stack s))))\\<rparr>)\\<rparr>))\n 4. \\<lbrakk>Tarjan_invar G s;\n     dom (finished s)\n     \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n     cond s; stack s \\<noteq> []; u = hd (stack s);\n     pending s `` {hd (stack s)} = {}; s' = finish (hd (stack s)) s;\n     hd (stack s) \\<in> set (tj_stack (finish (hd (stack s)) s));\n     distinct (tj_stack (finish (hd (stack s)) s));\n     \\<zeta> (finish (hd (stack s)) s) (hd (stack s)) \\<noteq>\n     \\<delta> (finish (hd (stack s)) s) (hd (stack s));\n     \\<not> scc_root (finish (hd (stack s)) s) (hd (stack s))\n             (scc_of E (hd (stack s)));\n     Tarjan_invar G\n      (finish (hd (stack s)) s\n       \\<lparr>state.more :=\n                 state.more\n                  (finish (hd (stack s)) s\n                   \\<lparr>lowlink :=\n                             if stack (finish (hd (stack s)) s) = []\n                             then lowlink (finish (hd (stack s)) s)\n                             else let u =\n  hd (stack (finish (hd (stack s)) s))\n                                  in lowlink (finish (hd (stack s)) s)(u \n                                     \\<mapsto>\n                                     min\n(\\<zeta> (finish (hd (stack s)) s) u)\n(\\<zeta> (finish (hd (stack s)) s)\n  (hd (stack s))))\\<rparr>)\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> dom (finished s)\n                      \\<subseteq> \\<Union>\n                                   (sccs\n                                     (s'\n\\<lparr>state.more :=\n          state.more\n           (finish (hd (stack s)) s\n            \\<lparr>lowlink :=\n                      if stack (finish (hd (stack s)) s) = []\n                      then lowlink (finish (hd (stack s)) s)\n                      else let u = hd (stack (finish (hd (stack s)) s))\n                           in lowlink (finish (hd (stack s)) s)(u \\<mapsto>\n                              min (\\<zeta> (finish (hd (stack s)) s) u)\n                               (\\<zeta> (finish (hd (stack s)) s)\n                                 (hd (stack\n s))))\\<rparr>)\\<rparr>)) \\<union>\n                                  set (tj_stack\n  (s'\\<lparr>state.more :=\n               state.more\n                (finish (hd (stack s)) s\n                 \\<lparr>lowlink :=\n                           if stack (finish (hd (stack s)) s) = []\n                           then lowlink (finish (hd (stack s)) s)\n                           else let u = hd (stack (finish (hd (stack s)) s))\n                                in lowlink (finish (hd (stack s)) s)(u \n                                   \\<mapsto>\n                                   min (\\<zeta> (finish (hd (stack s)) s) u)\n                                    (\\<zeta> (finish (hd (stack s)) s)\n(hd (stack s))))\\<rparr>)\\<rparr>))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  on_finish tarjan_params u s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n       \\<subseteq> \\<Union>\n                    (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n                   set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         dom (finished (empty_state x))\n         \\<subseteq> \\<Union> (sccs (empty_state x)) \\<union>\n                     set (tj_stack (empty_state x)))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        dom (finished s)\n        \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              dom (finished\n                                    (s'\\<lparr>state.more := x\\<rparr>))\n                              \\<subseteq> \\<Union>\n     (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n    set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)))", "qed (simp_all add: tarjan_back_def)"], ["", "end"], ["", "end"], ["", "context Tarjan_invar begin"], ["", "lemmas finished_ss_sccs_tj_stack =\n    i_finished_ss_sccs_tj_stack[THEN make_invar_thm]"], ["", "lemmas tj_stack_ss_stack_finished =\n    i_tj_stack_ss_stack_finished[THEN make_invar_thm]"], ["", "lemma sccs_finished:\n    \"\\<Union>(sccs s) \\<subseteq> dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (sccs s) \\<subseteq> dom (finished s)", "using i_sccs_finished_stack_ss_tj_stack[THEN make_invar_thm]"], ["proof (prove)\nusing this:\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. \\<Union> (sccs s) \\<subseteq> dom (finished s)", "by blast"], ["", "lemma stack_ss_tj_stack:\n    \"set (stack s) \\<subseteq> set (tj_stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (stack s) \\<subseteq> set (tj_stack s)", "using i_sccs_finished_stack_ss_tj_stack[THEN make_invar_thm]"], ["proof (prove)\nusing this:\n  \\<Union> (sccs s) \\<subseteq> dom (finished s) \\<and>\n  set (stack s) \\<subseteq> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. set (stack s) \\<subseteq> set (tj_stack s)", "by blast"], ["", "lemma hd_stack_in_tj_stack:\n    \"stack s \\<noteq> [] \\<Longrightarrow> hd (stack s) \\<in> set (tj_stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stack s \\<noteq> [] \\<Longrightarrow>\n    hd (stack s) \\<in> set (tj_stack s)", "using stack_ss_tj_stack hd_in_set"], ["proof (prove)\nusing this:\n  set (stack s) \\<subseteq> set (tj_stack s)\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> [] \\<Longrightarrow>\n    hd (stack s) \\<in> set (tj_stack s)", "by auto"], ["", "end"], ["", "context Tarjan begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma i_no_finished_root:\n    \"is_invar (\\<lambda>s. scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow> (\\<forall>x \\<in> scc. x \\<notin> set (tj_stack s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n         (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s)))", "proof (induct rule: establish_invarI_ND_CB)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "case (new_discover s s' v)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "{"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "fix x"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "let ?s = \"s'\\<lparr>state.more := x\\<rparr>\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "assume TRANS: \"\\<And>\\<Psi>. tarjan_disc v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow> \\<Psi> x\"\n      and inv': \"DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\"\n      and r: \"scc_root ?s r scc\" \"r \\<in> dom (finished s')\""], ["proof (state)\nthis:\n  tarjan_disc v s' \\<le>\\<^sub>n SPEC ?\\<Psi>7 \\<Longrightarrow> ?\\<Psi>7 x\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "from inv'"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)", "interpret s': Tarjan_invar where s=\"?s\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (1 subgoal):\n 1. Tarjan_invar G (s'\\<lparr>state.more := x\\<rparr>)", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "have \"tj_stack ?s = v#tj_stack s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tj_stack (s'\\<lparr>state.more := x\\<rparr>) = v # tj_stack s", "by (rule TRANS) (simp add: new_discover tarjan_disc_def)"], ["proof (state)\nthis:\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = v # tj_stack s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "moreover"], ["proof (state)\nthis:\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = v # tj_stack s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "from r s'.scc_root_finished_impl_scc_finished"], ["proof (chain)\npicking this:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  \\<lbrakk>?v \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>));\n   scc_root (s'\\<lparr>state.more := x\\<rparr>) ?v ?scc\\<rbrakk>\n  \\<Longrightarrow> ?scc\n                    \\<subseteq> dom (finished\n(s'\\<lparr>state.more := x\\<rparr>))", "have \"scc \\<subseteq> dom (finished ?s)\""], ["proof (prove)\nusing this:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  \\<lbrakk>?v \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>));\n   scc_root (s'\\<lparr>state.more := x\\<rparr>) ?v ?scc\\<rbrakk>\n  \\<Longrightarrow> ?scc\n                    \\<subseteq> dom (finished\n(s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. scc \\<subseteq> dom (finished (s'\\<lparr>state.more := x\\<rparr>))", "by auto"], ["proof (state)\nthis:\n  scc \\<subseteq> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "with new_discover finished_discovered"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  dom (finished s) \\<subseteq> dom (discovered s)\n  scc \\<subseteq> dom (finished (s'\\<lparr>state.more := x\\<rparr>))", "have \"v \\<notin> scc\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  dom (finished s) \\<subseteq> dom (discovered s)\n  scc \\<subseteq> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. v \\<notin> scc", "by force"], ["proof (state)\nthis:\n  v \\<notin> scc\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "moreover"], ["proof (state)\nthis:\n  v \\<notin> scc\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "from r finished_discovered new_discover"], ["proof (chain)\npicking this:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  dom (finished s) \\<subseteq> dom (discovered s)\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s", "have \"r \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  dom (finished s) \\<subseteq> dom (discovered s)\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n\ngoal (1 subgoal):\n 1. r \\<in> dom (discovered s)", "by auto"], ["proof (state)\nthis:\n  r \\<in> dom (discovered s)\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "with r inv' new_discover"], ["proof (chain)\npicking this:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  r \\<in> dom (discovered s)", "have \"scc_root s r scc\""], ["proof (prove)\nusing this:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  r \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. scc_root s r scc", "apply (intro scc_root_transfer[where s'=\"?s\", THEN iffD2])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc;\n     r \\<in> dom (finished s');\n     DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>);\n     DFS_invar G tarjan_params s;\n     scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n     (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n     cond s; \\<not> is_break tarjan_params s; v \\<notin> dom (discovered s);\n     discovered s' = discovered s(v \\<mapsto> counter s);\n     finished s' = finished s; counter s' = Suc (counter s);\n     stack s' = v # stack s; back_edges s' = back_edges s;\n     cross_edges s' = cross_edges s; tree_edges s \\<subseteq> tree_edges s';\n     state.more s' = state.more s; r \\<in> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> DFS_invar G tarjan_params\n                       (s'\\<lparr>state.more := x\\<rparr>)\n 2. \\<lbrakk>scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc;\n     r \\<in> dom (finished s');\n     DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>);\n     DFS_invar G tarjan_params s;\n     scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n     (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n     cond s; \\<not> is_break tarjan_params s; v \\<notin> dom (discovered s);\n     discovered s' = discovered s(v \\<mapsto> counter s);\n     finished s' = finished s; counter s' = Suc (counter s);\n     stack s' = v # stack s; back_edges s' = back_edges s;\n     cross_edges s' = cross_edges s; tree_edges s \\<subseteq> tree_edges s';\n     state.more s' = state.more s; r \\<in> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> r \\<in> dom (discovered s)\n 3. \\<lbrakk>scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc;\n     r \\<in> dom (finished s');\n     DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>);\n     DFS_invar G tarjan_params s;\n     scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n     (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n     cond s; \\<not> is_break tarjan_params s; v \\<notin> dom (discovered s);\n     discovered s' = discovered s(v \\<mapsto> counter s);\n     finished s' = finished s; counter s' = Suc (counter s);\n     stack s' = v # stack s; back_edges s' = back_edges s;\n     cross_edges s' = cross_edges s; tree_edges s \\<subseteq> tree_edges s';\n     state.more s' = state.more s; r \\<in> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> dom (discovered s)\n                      \\<subseteq> dom (discovered\n  (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<lbrakk>scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc;\n     r \\<in> dom (finished s');\n     DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>);\n     DFS_invar G tarjan_params s;\n     scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n     (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n     cond s; \\<not> is_break tarjan_params s; v \\<notin> dom (discovered s);\n     discovered s' = discovered s(v \\<mapsto> counter s);\n     finished s' = finished s; counter s' = Suc (counter s);\n     stack s' = v # stack s; back_edges s' = back_edges s;\n     cross_edges s' = cross_edges s; tree_edges s \\<subseteq> tree_edges s';\n     state.more s' = state.more s; r \\<in> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa\\<in>dom (discovered s).\n                         \\<delta> s xa =\n                         \\<delta> (s'\\<lparr>state.more := x\\<rparr>) xa\n 5. \\<lbrakk>scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc;\n     r \\<in> dom (finished s');\n     DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>);\n     DFS_invar G tarjan_params s;\n     scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n     (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n     cond s; \\<not> is_break tarjan_params s; v \\<notin> dom (discovered s);\n     discovered s' = discovered s(v \\<mapsto> counter s);\n     finished s' = finished s; counter s' = Suc (counter s);\n     stack s' = v # stack s; back_edges s' = back_edges s;\n     cross_edges s' = cross_edges s; tree_edges s \\<subseteq> tree_edges s';\n     state.more s' = state.more s; r \\<in> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa\\<in>dom\n (discovered (s'\\<lparr>state.more := x\\<rparr>)) -\ndom (discovered s).\n                         counter s\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa\n 6. \\<lbrakk>scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc;\n     r \\<in> dom (finished s');\n     DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>);\n     DFS_invar G tarjan_params s;\n     scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n     (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n     cond s; \\<not> is_break tarjan_params s; v \\<notin> dom (discovered s);\n     discovered s' = discovered s(v \\<mapsto> counter s);\n     finished s' = finished s; counter s' = Suc (counter s);\n     stack s' = v # stack s; back_edges s' = back_edges s;\n     cross_edges s' = cross_edges s; tree_edges s \\<subseteq> tree_edges s';\n     state.more s' = state.more s; r \\<in> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> tree_edges s\n                      \\<subseteq> tree_edges\n                                   (s'\\<lparr>state.more := x\\<rparr>)\n 7. \\<lbrakk>scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc;\n     r \\<in> dom (finished s');\n     DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>);\n     DFS_invar G tarjan_params s;\n     scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n     (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n     cond s; \\<not> is_break tarjan_params s; v \\<notin> dom (discovered s);\n     discovered s' = discovered s(v \\<mapsto> counter s);\n     finished s' = finished s; counter s' = Suc (counter s);\n     stack s' = v # stack s; back_edges s' = back_edges s;\n     cross_edges s' = cross_edges s; tree_edges s \\<subseteq> tree_edges s';\n     state.more s' = state.more s; r \\<in> dom (discovered s)\\<rbrakk>\n    \\<Longrightarrow> scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc", "apply clarsimp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  scc_root s r scc\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "with new_discover r"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  scc_root s r scc", "have \"\\<forall>x \\<in> scc. x \\<notin> set (tj_stack s')\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  scc_root s r scc\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>scc. x \\<notin> set (tj_stack s')", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>scc. x \\<notin> set (tj_stack s')\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "ultimately"], ["proof (chain)\npicking this:\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = v # tj_stack s\n  v \\<notin> scc\n  \\<forall>x\\<in>scc. x \\<notin> set (tj_stack s')", "have \"\\<forall>x\\<in>scc. x \\<notin> set (tj_stack ?s)\""], ["proof (prove)\nusing this:\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = v # tj_stack s\n  v \\<notin> scc\n  \\<forall>x\\<in>scc. x \\<notin> set (tj_stack s')\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "by (auto simp: new_discover)"], ["proof (state)\nthis:\n  \\<forall>xa\\<in>scc.\n     xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_disc v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   scc_root (s'\\<lparr>state.more := ?x9\\<rparr>) r scc;\n   r \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>scc.\n                       x \\<notin> set (tj_stack\n  (s'\\<lparr>state.more := ?x9\\<rparr>))\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "with new_discover"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_disc v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   scc_root (s'\\<lparr>state.more := ?x9\\<rparr>) r scc;\n   r \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>scc.\n                       x \\<notin> set (tj_stack\n  (s'\\<lparr>state.more := ?x9\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  v \\<notin> dom (discovered s)\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  counter s' = Suc (counter s)\n  stack s' = v # stack s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  tree_edges s \\<subseteq> tree_edges s'\n  state.more s' = state.more s\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_disc v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   scc_root (s'\\<lparr>state.more := ?x9\\<rparr>) r scc;\n   r \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>scc.\n                       x \\<notin> set (tj_stack\n  (s'\\<lparr>state.more := ?x9\\<rparr>))\n\ngoal (1 subgoal):\n 1. on_new_root tarjan_params v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc \\<and>\n         r \\<in> dom (finished\n                       (s'\\<lparr>state.more :=\n                                    x\\<rparr>)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc.\n             xa \\<notin> set (tj_stack\n                               (s'\\<lparr>state.more := x\\<rparr>))))", "by (simp add: pw_leof_iff)"], ["proof (state)\nthis:\n  on_new_root tarjan_params v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc \\<and>\n       r \\<in> dom (finished\n                     (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n       (\\<forall>xa\\<in>scc.\n           xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "case (cross_back_edge s s' u v)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "{"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "fix x"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "let ?s = \"s'\\<lparr>state.more := x\\<rparr>\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "assume TRANS: \"\\<And>\\<Psi>. tarjan_back u v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow> \\<Psi> x\"\n      and r: \"scc_root ?s r scc\" \"r \\<in> dom (finished s')\""], ["proof (state)\nthis:\n  tarjan_back u v s' \\<le>\\<^sub>n SPEC ?\\<Psi>7 \\<Longrightarrow>\n  ?\\<Psi>7 x\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "with cross_back_edge"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  tarjan_back u v s' \\<le>\\<^sub>n SPEC ?\\<Psi>7 \\<Longrightarrow>\n  ?\\<Psi>7 x\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')", "have \"scc_root s r scc\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  tarjan_back u v s' \\<le>\\<^sub>n SPEC ?\\<Psi>7 \\<Longrightarrow>\n  ?\\<Psi>7 x\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n\ngoal (1 subgoal):\n 1. scc_root s r scc", "by (simp add: scc_root_transfer'[where s'=\"?s\"])"], ["proof (state)\nthis:\n  scc_root s r scc\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "moreover"], ["proof (state)\nthis:\n  scc_root s r scc\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "have \"tj_stack ?s = tj_stack s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s", "by (rule TRANS) (simp add: cross_back_edge tarjan_back_def)"], ["proof (state)\nthis:\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "ultimately"], ["proof (chain)\npicking this:\n  scc_root s r scc\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s", "have \"\\<forall>x\\<in>scc. x \\<notin> set (tj_stack ?s)\""], ["proof (prove)\nusing this:\n  scc_root s r scc\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "using cross_back_edge r"], ["proof (prove)\nusing this:\n  scc_root s r scc\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  \\<forall>xa\\<in>scc.\n     xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_back u v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   scc_root (s'\\<lparr>state.more := ?x9\\<rparr>) r scc;\n   r \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>scc.\n                       x \\<notin> set (tj_stack\n  (s'\\<lparr>state.more := ?x9\\<rparr>))\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "with cross_back_edge"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_back u v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   scc_root (s'\\<lparr>state.more := ?x9\\<rparr>) r scc;\n   r \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>scc.\n                       x \\<notin> set (tj_stack\n  (s'\\<lparr>state.more := ?x9\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_back u v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   scc_root (s'\\<lparr>state.more := ?x9\\<rparr>) r scc;\n   r \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>scc.\n                       x \\<notin> set (tj_stack\n  (s'\\<lparr>state.more := ?x9\\<rparr>))\n\ngoal (1 subgoal):\n 1. on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc \\<and>\n         r \\<in> dom (finished\n                       (s'\\<lparr>state.more :=\n                                    x\\<rparr>)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc.\n             xa \\<notin> set (tj_stack\n                               (s'\\<lparr>state.more := x\\<rparr>))))", "by (simp add: pw_leof_iff)"], ["proof (state)\nthis:\n  on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc \\<and>\n       r \\<in> dom (finished\n                     (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n       (\\<forall>xa\\<in>scc.\n           xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "case (finish s s' u)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "let ?s = \"s'\\<lparr>state.more := x\\<rparr>\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "assume TRANS:  \"\\<And>\\<Psi>. tarjan_fin u s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow> \\<Psi> x\"\n      and inv': \"DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\"\n      and r: \"scc_root ?s r scc\" \"r \\<in> dom (finished s')\""], ["proof (state)\nthis:\n  tarjan_fin u s' \\<le>\\<^sub>n SPEC ?\\<Psi>7 \\<Longrightarrow> ?\\<Psi>7 x\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "from inv'"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)", "interpret s': Tarjan_invar where s=\"?s\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (1 subgoal):\n 1. Tarjan_invar G (s'\\<lparr>state.more := x\\<rparr>)", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "have \"\\<forall>x\\<in>scc. x \\<notin> set (tj_stack ?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "proof (cases \"r = u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n 2. r \\<noteq> u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "case False"], ["proof (state)\nthis:\n  r \\<noteq> u\n\ngoal (2 subgoals):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n 2. r \\<noteq> u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "with finish r"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  r \\<noteq> u", "have \"\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  r \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>scc. x \\<notin> set (tj_stack s)", "using scc_root_transfer'[where s'=\"?s\"]"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  r \\<noteq> u\n  \\<lbrakk>discovered s = discovered (s'\\<lparr>state.more := x\\<rparr>);\n   tree_edges s = tree_edges (s'\\<lparr>state.more := x\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> scc_root s ?r ?scc =\n                    scc_root (s'\\<lparr>state.more := x\\<rparr>) ?r ?scc\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>scc. x \\<notin> set (tj_stack s)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>scc. x \\<notin> set (tj_stack s)\n\ngoal (2 subgoals):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n 2. r \\<noteq> u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>scc. x \\<notin> set (tj_stack s)\n\ngoal (2 subgoals):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n 2. r \\<noteq> u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "have \"set (tj_stack ?s) \\<subseteq> set (tj_stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n    \\<subseteq> set (tj_stack s)", "apply (rule TRANS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tarjan_fin u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         set (tj_stack (s'\\<lparr>state.more := a\\<rparr>))\n         \\<subseteq> set (tj_stack s))", "unfolding tarjan_fin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ll = if stack s' = [] then lowlink s'\n              else let ua = hd (stack s')\n                   in lowlink s'(ua \\<mapsto>\n                      min (\\<zeta> s' ua) (\\<zeta> s' u));\n         s'a = s'\\<lparr>lowlink := ll\\<rparr>\n     in ASSERT (u \\<in> set (tj_stack s')) \\<bind>\n        (\\<lambda>_.\n            ASSERT (distinct (tj_stack s')) \\<bind>\n            (\\<lambda>_.\n                if \\<zeta> s' u = \\<delta> s' u\n                then ASSERT (scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_.\n                         tj_stack_pop (tj_stack s') u \\<bind>\n                         (\\<lambda>(tjs, scc).\n                             NOOP\n                              (s'a\\<lparr>tj_stack := tjs,\n                                     sccs := insert scc (sccs s')\\<rparr>)))\n                else ASSERT (\\<not> scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_. NOOP s'a)))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         set (tj_stack (s'\\<lparr>state.more := a\\<rparr>))\n         \\<subseteq> set (tj_stack s))", "apply (refine_vcg tj_stack_pop_set_leof_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>u \\<in> set (tj_stack s'); distinct (tj_stack s');\n        \\<zeta> s' u = \\<delta> s' u; scc_root s' u (scc_of E u);\n        case x of\n        (tjs', scc) \\<Rightarrow>\n          u \\<in> set (tj_stack s') \\<longrightarrow>\n          set (tj_stack s') = set tjs' \\<union> scc \\<and> u \\<in> scc;\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> set (tj_stack\n                               (s'\\<lparr>state.more :=\n      state.more\n       (s'\\<lparr>lowlink :=\n                    if stack s' = [] then lowlink s'\n                    else let ua = hd (stack s')\n                         in lowlink s'(ua \\<mapsto>\n                            min (\\<zeta> s' ua) (\\<zeta> s' u)),\n             tj_stack := x1, sccs := insert x2 (sccs s')\\<rparr>)\\<rparr>))\n                         \\<subseteq> set (tj_stack s)\n 2. \\<lbrakk>u \\<in> set (tj_stack s'); distinct (tj_stack s');\n     \\<zeta> s' u \\<noteq> \\<delta> s' u;\n     \\<not> scc_root s' u (scc_of E u)\\<rbrakk>\n    \\<Longrightarrow> set (tj_stack\n                            (s'\\<lparr>state.more :=\n   state.more\n    (s'\\<lparr>lowlink :=\n                 if stack s' = [] then lowlink s'\n                 else let ua = hd (stack s')\n                      in lowlink s'(ua \\<mapsto>\n                         min (\\<zeta> s' ua)\n                          (\\<zeta> s' u))\\<rparr>)\\<rparr>))\n                      \\<subseteq> set (tj_stack s)", "apply (simp_all add: finish)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n  \\<subseteq> set (tj_stack s)\n\ngoal (2 subgoals):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n 2. r \\<noteq> u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>scc. x \\<notin> set (tj_stack s)\n  set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n  \\<subseteq> set (tj_stack s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>scc. x \\<notin> set (tj_stack s)\n  set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n  \\<subseteq> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "by blast"], ["proof (state)\nthis:\n  \\<forall>xa\\<in>scc.\n     xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "case True"], ["proof (state)\nthis:\n  r = u\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "with r s'.scc_root_unique_is_scc"], ["proof (chain)\npicking this:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) ?v ?scc \\<Longrightarrow>\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) ?v (scc_of E ?v)\n  r = u", "have \"scc_root ?s u (scc_of E u)\""], ["proof (prove)\nusing this:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) ?v ?scc \\<Longrightarrow>\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) ?v (scc_of E ?v)\n  r = u\n\ngoal (1 subgoal):\n 1. scc_root (s'\\<lparr>state.more := x\\<rparr>) u (scc_of E u)", "by simp"], ["proof (state)\nthis:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) u (scc_of E u)\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "with s'.scc_root_transfer'[where s'=s'] finish"], ["proof (chain)\npicking this:\n  \\<lbrakk>discovered (s'\\<lparr>state.more := x\\<rparr>) = discovered s';\n   tree_edges (s'\\<lparr>state.more := x\\<rparr>) = tree_edges s'\\<rbrakk>\n  \\<Longrightarrow> scc_root (s'\\<lparr>state.more := x\\<rparr>) ?r ?scc =\n                    scc_root s' ?r ?scc\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) u (scc_of E u)", "have \"scc_root s' u (scc_of E u)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>discovered (s'\\<lparr>state.more := x\\<rparr>) = discovered s';\n   tree_edges (s'\\<lparr>state.more := x\\<rparr>) = tree_edges s'\\<rbrakk>\n  \\<Longrightarrow> scc_root (s'\\<lparr>state.more := x\\<rparr>) ?r ?scc =\n                    scc_root s' ?r ?scc\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) u (scc_of E u)\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u)", "by simp"], ["proof (state)\nthis:\n  scc_root s' u (scc_of E u)\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  scc_root s' u (scc_of E u)\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "hence [simp]: \"tj_stack ?s = tl (dropWhile ((\\<noteq>) u) (tj_stack s))\""], ["proof (prove)\nusing this:\n  scc_root s' u (scc_of E u)\n\ngoal (1 subgoal):\n 1. tj_stack (s'\\<lparr>state.more := x\\<rparr>) =\n    tl (dropWhile ((\\<noteq>) u) (tj_stack s))", "apply (rule_tac TRANS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    tarjan_fin u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         tj_stack (s'\\<lparr>state.more := a\\<rparr>) =\n         tl (dropWhile ((\\<noteq>) u) (tj_stack s)))", "unfolding tarjan_fin_def tj_stack_pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    (let ll = if stack s' = [] then lowlink s'\n              else let ua = hd (stack s')\n                   in lowlink s'(ua \\<mapsto>\n                      min (\\<zeta> s' ua) (\\<zeta> s' u));\n         s'a = s'\\<lparr>lowlink := ll\\<rparr>\n     in ASSERT (u \\<in> set (tj_stack s')) \\<bind>\n        (\\<lambda>_.\n            ASSERT (distinct (tj_stack s')) \\<bind>\n            (\\<lambda>_.\n                if \\<zeta> s' u = \\<delta> s' u\n                then ASSERT (scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_.\n                         RETURN\n                          (tl (dropWhile ((\\<noteq>) u) (tj_stack s')),\n                           insert u\n                            (set (takeWhile ((\\<noteq>) u)\n                                   (tj_stack s')))) \\<bind>\n                         (\\<lambda>(tjs, scc).\n                             NOOP\n                              (s'a\\<lparr>tj_stack := tjs,\n                                     sccs := insert scc (sccs s')\\<rparr>)))\n                else ASSERT (\\<not> scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_. NOOP s'a)))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         tj_stack (s'\\<lparr>state.more := a\\<rparr>) =\n         tl (dropWhile ((\\<noteq>) u) (tj_stack s)))", "apply (refine_vcg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>scc_root s' u (scc_of E u); u \\<in> set (tj_stack s');\n        distinct (tj_stack s'); \\<zeta> s' u = \\<delta> s' u;\n        scc_root s' u (scc_of E u);\n        (tl (dropWhile ((\\<noteq>) u) (tj_stack s')),\n         insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s')))) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> tj_stack\n                          (s'\\<lparr>state.more :=\n state.more\n  (s'\\<lparr>lowlink :=\n               if stack s' = [] then lowlink s'\n               else let ua = hd (stack s')\n                    in lowlink s'(ua \\<mapsto>\n                       min (\\<zeta> s' ua) (\\<zeta> s' u)),\n        tj_stack := x1, sccs := insert x2 (sccs s')\\<rparr>)\\<rparr>) =\n                         tl (dropWhile ((\\<noteq>) u) (tj_stack s))\n 2. \\<lbrakk>scc_root s' u (scc_of E u); u \\<in> set (tj_stack s');\n     distinct (tj_stack s'); \\<zeta> s' u \\<noteq> \\<delta> s' u;\n     \\<not> scc_root s' u (scc_of E u)\\<rbrakk>\n    \\<Longrightarrow> tj_stack\n                       (s'\\<lparr>state.more :=\n                                    state.more\n                                     (s'\n\\<lparr>lowlink :=\n          if stack s' = [] then lowlink s'\n          else let ua = hd (stack s')\n               in lowlink s'(ua \\<mapsto>\n                  min (\\<zeta> s' ua) (\\<zeta> s' u))\\<rparr>)\\<rparr>) =\n                      tl (dropWhile ((\\<noteq>) u) (tj_stack s))", "apply (simp_all add: finish)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) =\n  tl (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "{"], ["proof (state)\nthis:\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) =\n  tl (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "let ?dw = \"dropWhile ((\\<noteq>) u) (tj_stack s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "let ?tw = \"takeWhile ((\\<noteq>) u) (tj_stack s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "define j::nat where \"j = 0\""], ["proof (state)\nthis:\n  j = 0\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "assume x: \"x \\<in> set (tj_stack ?s)\""], ["proof (state)\nthis:\n  x \\<in> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "obtain i where i: \"i < length (tj_stack ?s)\" \"tj_stack ?s ! i = x\""], ["proof (prove)\nusing this:\n  x \\<in> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length\n                      (tj_stack (s'\\<lparr>state.more := x__\\<rparr>));\n         tj_stack (s'\\<lparr>state.more := x__\\<rparr>) ! i = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))\n  tj_stack (s'\\<lparr>state.more := x__\\<rparr>) ! i = x\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "have \"length (tj_stack s) = length ?tw + length ?dw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (tj_stack s) =\n    length (takeWhile ((\\<noteq>) u) (tj_stack s)) +\n    length (dropWhile ((\\<noteq>) u) (tj_stack s))", "by (simp add: length_append[symmetric])"], ["proof (state)\nthis:\n  length (tj_stack s) =\n  length (takeWhile ((\\<noteq>) u) (tj_stack s)) +\n  length (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "with i"], ["proof (chain)\npicking this:\n  i < length (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))\n  tj_stack (s'\\<lparr>state.more := x__\\<rparr>) ! i = x\n  length (tj_stack s) =\n  length (takeWhile ((\\<noteq>) u) (tj_stack s)) +\n  length (dropWhile ((\\<noteq>) u) (tj_stack s))", "have \"\\<delta> s (tj_stack s ! (Suc i + length ?tw)) < \\<delta> s (tj_stack s ! length ?tw)\""], ["proof (prove)\nusing this:\n  i < length (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))\n  tj_stack (s'\\<lparr>state.more := x__\\<rparr>) ! i = x\n  length (tj_stack s) =\n  length (takeWhile ((\\<noteq>) u) (tj_stack s)) +\n  length (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s\n     (tj_stack s ! (Suc i + length (takeWhile ((\\<noteq>) u) (tj_stack s))))\n    < \\<delta> s\n       (tj_stack s ! length (takeWhile ((\\<noteq>) u) (tj_stack s)))", "by (simp add: tj_stack_incr_disc)"], ["proof (state)\nthis:\n  \\<delta> s\n   (tj_stack s ! (Suc i + length (takeWhile ((\\<noteq>) u) (tj_stack s))))\n  < \\<delta> s (tj_stack s ! length (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "also"], ["proof (state)\nthis:\n  \\<delta> s\n   (tj_stack s ! (Suc i + length (takeWhile ((\\<noteq>) u) (tj_stack s))))\n  < \\<delta> s (tj_stack s ! length (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "from hd_stack_in_tj_stack finish"], ["proof (chain)\npicking this:\n  stack s \\<noteq> [] \\<Longrightarrow> hd (stack s) \\<in> set (tj_stack s)\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "have ne: \"?dw \\<noteq> []\" and \"length ?dw > 0\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> [] \\<Longrightarrow> hd (stack s) \\<in> set (tj_stack s)\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> [] &&&\n    0 < length (dropWhile ((\\<noteq>) u) (tj_stack s))", "by simp_all"], ["proof (state)\nthis:\n  dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> []\n  0 < length (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "from hd_dropWhile[OF ne] hd_conv_nth[OF ne]"], ["proof (chain)\npicking this:\n  \\<not> u \\<noteq> hd (dropWhile ((\\<noteq>) u) (tj_stack s))\n  hd (dropWhile ((\\<noteq>) u) (tj_stack s)) =\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! 0", "have \"?dw ! 0 = u\""], ["proof (prove)\nusing this:\n  \\<not> u \\<noteq> hd (dropWhile ((\\<noteq>) u) (tj_stack s))\n  hd (dropWhile ((\\<noteq>) u) (tj_stack s)) =\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! 0\n\ngoal (1 subgoal):\n 1. dropWhile ((\\<noteq>) u) (tj_stack s) ! 0 = u", "by simp"], ["proof (state)\nthis:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! 0 = u\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "with dropWhile_nth[OF \\<open>length ?dw > 0\\<close>]"], ["proof (chain)\npicking this:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! 0 =\n  tj_stack s ! (0 + length (takeWhile ((\\<noteq>) u) (tj_stack s)))\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! 0 = u", "have \"tj_stack s ! length ?tw = u\""], ["proof (prove)\nusing this:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! 0 =\n  tj_stack s ! (0 + length (takeWhile ((\\<noteq>) u) (tj_stack s)))\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! 0 = u\n\ngoal (1 subgoal):\n 1. tj_stack s ! length (takeWhile ((\\<noteq>) u) (tj_stack s)) = u", "by simp"], ["proof (state)\nthis:\n  tj_stack s ! length (takeWhile ((\\<noteq>) u) (tj_stack s)) = u\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "also"], ["proof (state)\nthis:\n  tj_stack s ! length (takeWhile ((\\<noteq>) u) (tj_stack s)) = u\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "from i"], ["proof (chain)\npicking this:\n  i < length (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))\n  tj_stack (s'\\<lparr>state.more := x__\\<rparr>) ! i = x", "have \"?dw ! Suc i = x\" \"Suc i < length ?dw\""], ["proof (prove)\nusing this:\n  i < length (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))\n  tj_stack (s'\\<lparr>state.more := x__\\<rparr>) ! i = x\n\ngoal (1 subgoal):\n 1. dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc i = x &&&\n    Suc i < length (dropWhile ((\\<noteq>) u) (tj_stack s))", "by (simp_all add: nth_tl[OF ne])"], ["proof (state)\nthis:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc i = x\n  Suc i < length (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "with dropWhile_nth[OF this(2)]"], ["proof (chain)\npicking this:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc i =\n  tj_stack s ! (Suc i + length (takeWhile ((\\<noteq>) u) (tj_stack s)))\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc i = x\n  Suc i < length (dropWhile ((\\<noteq>) u) (tj_stack s))", "have \"tj_stack s ! (Suc i + length ?tw) = x\""], ["proof (prove)\nusing this:\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc i =\n  tj_stack s ! (Suc i + length (takeWhile ((\\<noteq>) u) (tj_stack s)))\n  dropWhile ((\\<noteq>) u) (tj_stack s) ! Suc i = x\n  Suc i < length (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. tj_stack s ! (Suc i + length (takeWhile ((\\<noteq>) u) (tj_stack s))) =\n    x", "by simp"], ["proof (state)\nthis:\n  tj_stack s ! (Suc i + length (takeWhile ((\\<noteq>) u) (tj_stack s))) = x\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "finally"], ["proof (chain)\npicking this:\n  \\<delta> s x < \\<delta> s u", "have \"\\<delta> ?s x < \\<delta> ?s u\""], ["proof (prove)\nusing this:\n  \\<delta> s x < \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) x\n    < \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) u", "by (simp add: finish)"], ["proof (state)\nthis:\n  \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) x\n  < \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) u\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) x\n  < \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) u\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "from x s'.tj_stack_discovered"], ["proof (chain)\npicking this:\n  x \\<in> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))\n  set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))\n  \\<subseteq> dom (discovered (s'\\<lparr>state.more := x__\\<rparr>))", "have \"x \\<in> dom (discovered ?s)\""], ["proof (prove)\nusing this:\n  x \\<in> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))\n  set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))\n  \\<subseteq> dom (discovered (s'\\<lparr>state.more := x__\\<rparr>))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (discovered (s'\\<lparr>state.more := x__\\<rparr>))", "by auto"], ["proof (state)\nthis:\n  x \\<in> dom (discovered (s'\\<lparr>state.more := x__\\<rparr>))\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) x\n  < \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) u\n  x \\<in> dom (discovered (s'\\<lparr>state.more := x__\\<rparr>))", "have \"x \\<notin> scc\""], ["proof (prove)\nusing this:\n  \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) x\n  < \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) u\n  x \\<in> dom (discovered (s'\\<lparr>state.more := x__\\<rparr>))\n\ngoal (1 subgoal):\n 1. x \\<notin> scc", "using s'.scc_root_disc_le r True"], ["proof (prove)\nusing this:\n  \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) x\n  < \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) u\n  x \\<in> dom (discovered (s'\\<lparr>state.more := x__\\<rparr>))\n  \\<lbrakk>scc_root (s'\\<lparr>state.more := x__\\<rparr>) ?v ?scc;\n   ?x \\<in> ?scc;\n   ?x \\<in> dom (discovered (s'\\<lparr>state.more := x__\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) ?v\n                    \\<le> \\<delta> (s'\\<lparr>state.more := x__\\<rparr>) ?x\n  scc_root (s'\\<lparr>state.more := x__\\<rparr>) r scc\n  r \\<in> dom (finished s')\n  r = u\n\ngoal (1 subgoal):\n 1. x \\<notin> scc", "by force"], ["proof (state)\nthis:\n  x \\<notin> scc\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x__\\<rparr>))", "}"], ["proof (state)\nthis:\n  ?xa9\n  \\<in> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)) \\<Longrightarrow>\n  ?xa9 \\<notin> scc\n\ngoal (1 subgoal):\n 1. r = u \\<Longrightarrow>\n    \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?xa9\n  \\<in> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>)) \\<Longrightarrow>\n  ?xa9 \\<notin> scc\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>scc.\n       xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "by metis"], ["proof (state)\nthis:\n  \\<forall>xa\\<in>scc.\n     xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>xa\\<in>scc.\n     xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_fin u s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   scc_root (s'\\<lparr>state.more := ?x9\\<rparr>) r scc;\n   r \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>scc.\n                       x \\<notin> set (tj_stack\n  (s'\\<lparr>state.more := ?x9\\<rparr>))\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n        (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s));\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              scc_root (s'\\<lparr>state.more := x\\<rparr>) r\n                               scc \\<and>\n                              r \\<in> dom\n (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n                              (\\<forall>xa\\<in>scc.\n                                  xa \\<notin> set\n         (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))", "with finish"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_fin u s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   scc_root (s'\\<lparr>state.more := ?x9\\<rparr>) r scc;\n   r \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>scc.\n                       x \\<notin> set (tj_stack\n  (s'\\<lparr>state.more := ?x9\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  scc_root s r scc \\<and> r \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>scc. x \\<notin> set (tj_stack s))\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_fin u s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   scc_root (s'\\<lparr>state.more := ?x9\\<rparr>) r scc;\n   r \\<in> dom (finished s')\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>scc.\n                       x \\<notin> set (tj_stack\n  (s'\\<lparr>state.more := ?x9\\<rparr>))\n\ngoal (1 subgoal):\n 1. on_finish tarjan_params u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc \\<and>\n         r \\<in> dom (finished\n                       (s'\\<lparr>state.more :=\n                                    x\\<rparr>)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc.\n             xa \\<notin> set (tj_stack\n                               (s'\\<lparr>state.more := x\\<rparr>))))", "by (simp add: pw_leof_iff)"], ["proof (state)\nthis:\n  on_finish tarjan_params u s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       scc_root (s'\\<lparr>state.more := x\\<rparr>) r scc \\<and>\n       r \\<in> dom (finished\n                     (s'\\<lparr>state.more := x\\<rparr>)) \\<longrightarrow>\n       (\\<forall>xa\\<in>scc.\n           xa \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))))\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_discover tarjan_params u v s = on_new_root tarjan_params v s\n 2. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 3. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         scc_root (empty_state x) r scc \\<and>\n         r \\<in> dom (finished (empty_state x)) \\<longrightarrow>\n         (\\<forall>xa\\<in>scc. xa \\<notin> set (tj_stack (empty_state x))))", "qed simp_all"], ["", "end"], ["", "end"], ["", "context Tarjan_invar begin"], ["", "lemma no_finished_root:\n    assumes \"scc_root s r scc\"\n    and \"r \\<in> dom (finished s)\"\n    and \"x \\<in> scc\"\n    shows \"x \\<notin> set (tj_stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set (tj_stack s)", "using assms"], ["proof (prove)\nusing this:\n  scc_root s r scc\n  r \\<in> dom (finished s)\n  x \\<in> scc\n\ngoal (1 subgoal):\n 1. x \\<notin> set (tj_stack s)", "using i_no_finished_root[THEN make_invar_thm]"], ["proof (prove)\nusing this:\n  scc_root s r scc\n  r \\<in> dom (finished s)\n  x \\<in> scc\n  scc_root s ?r1 ?scc1 \\<and> ?r1 \\<in> dom (finished s) \\<longrightarrow>\n  (\\<forall>x\\<in>?scc1. x \\<notin> set (tj_stack s))\n\ngoal (1 subgoal):\n 1. x \\<notin> set (tj_stack s)", "by blast"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma tj_stack_reach_stack:\n    assumes \"u \\<in> set (tj_stack s)\"\n    shows \"\\<exists>v \\<in> set (stack s). (u,v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (stack s).\n       (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (stack s).\n       (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u", "have u_scc: \"u \\<in> scc_of E u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> scc_of E u", "by simp"], ["proof (state)\nthis:\n  u \\<in> scc_of E u\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (stack s).\n       (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u", "from assms tj_stack_discovered"], ["proof (chain)\npicking this:\n  u \\<in> set (tj_stack s)\n  set (tj_stack s) \\<subseteq> dom (discovered s)", "have u_disc: \"u \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  u \\<in> set (tj_stack s)\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. u \\<in> dom (discovered s)", "by auto"], ["proof (state)\nthis:\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (stack s).\n       (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u", "with scc_root_of_node_exists"], ["proof (chain)\npicking this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow>\n  \\<exists>r. scc_root s r (scc_of E ?v)\n  u \\<in> dom (discovered s)", "obtain r where r: \"scc_root s r (scc_of E u)\""], ["proof (prove)\nusing this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow>\n  \\<exists>r. scc_root s r (scc_of E ?v)\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        scc_root s r (scc_of E u) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  scc_root s r (scc_of E u)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (stack s).\n       (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u", "have \"r \\<in> set (stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> set (stack s)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<notin> set (stack s) \\<Longrightarrow> False", "assume \"r \\<notin> set (stack s)\""], ["proof (state)\nthis:\n  r \\<notin> set (stack s)\n\ngoal (1 subgoal):\n 1. r \\<notin> set (stack s) \\<Longrightarrow> False", "with r[unfolded scc_root_def] stack_set_def"], ["proof (chain)\npicking this:\n  is_scc E (scc_of E u) \\<and>\n  r \\<in> scc_of E u \\<and>\n  r \\<in> dom (discovered s) \\<and>\n  scc_of E u \\<inter> dom (discovered s)\n  \\<subseteq> (tree_edges s)\\<^sup>* `` {r}\n  set (stack s) = dom (discovered s) - dom (finished s)\n  r \\<notin> set (stack s)", "have \"r \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  is_scc E (scc_of E u) \\<and>\n  r \\<in> scc_of E u \\<and>\n  r \\<in> dom (discovered s) \\<and>\n  scc_of E u \\<inter> dom (discovered s)\n  \\<subseteq> (tree_edges s)\\<^sup>* `` {r}\n  set (stack s) = dom (discovered s) - dom (finished s)\n  r \\<notin> set (stack s)\n\ngoal (1 subgoal):\n 1. r \\<in> dom (finished s)", "by simp"], ["proof (state)\nthis:\n  r \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. r \\<notin> set (stack s) \\<Longrightarrow> False", "with u_scc"], ["proof (chain)\npicking this:\n  u \\<in> scc_of E u\n  r \\<in> dom (finished s)", "have \"u \\<notin> set (tj_stack s)\""], ["proof (prove)\nusing this:\n  u \\<in> scc_of E u\n  r \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<notin> set (tj_stack s)", "using no_finished_root r"], ["proof (prove)\nusing this:\n  u \\<in> scc_of E u\n  r \\<in> dom (finished s)\n  \\<lbrakk>scc_root s ?r ?scc; ?r \\<in> dom (finished s);\n   ?x \\<in> ?scc\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> set (tj_stack s)\n  scc_root s r (scc_of E u)\n\ngoal (1 subgoal):\n 1. u \\<notin> set (tj_stack s)", "by blast"], ["proof (state)\nthis:\n  u \\<notin> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. r \\<notin> set (stack s) \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  u \\<in> set (tj_stack s)\n  u \\<notin> set (tj_stack s)", "show False"], ["proof (prove)\nusing this:\n  u \\<in> set (tj_stack s)\n  u \\<notin> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (stack s).\n       (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u", "moreover"], ["proof (state)\nthis:\n  r \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (stack s).\n       (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u", "from r scc_reach_scc_root u_scc u_disc"], ["proof (chain)\npicking this:\n  scc_root s r (scc_of E u)\n  \\<lbrakk>scc_root s ?r ?scc; ?v \\<in> ?scc\\<rbrakk>\n  \\<Longrightarrow> (?v, ?r) \\<in> E\\<^sup>*\n  u \\<in> scc_of E u\n  u \\<in> dom (discovered s)", "have \"(u,r) \\<in> E\\<^sup>*\""], ["proof (prove)\nusing this:\n  scc_root s r (scc_of E u)\n  \\<lbrakk>scc_root s ?r ?scc; ?v \\<in> ?scc\\<rbrakk>\n  \\<Longrightarrow> (?v, ?r) \\<in> E\\<^sup>*\n  u \\<in> scc_of E u\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. (u, r) \\<in> E\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  (u, r) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (stack s).\n       (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u", "moreover"], ["proof (state)\nthis:\n  (u, r) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (stack s).\n       (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u", "from r scc_root_disc_le u_scc u_disc"], ["proof (chain)\npicking this:\n  scc_root s r (scc_of E u)\n  \\<lbrakk>scc_root s ?v ?scc; ?x \\<in> ?scc;\n   ?x \\<in> dom (discovered s)\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?v \\<le> \\<delta> s ?x\n  u \\<in> scc_of E u\n  u \\<in> dom (discovered s)", "have \"\\<delta> s r \\<le> \\<delta> s u\""], ["proof (prove)\nusing this:\n  scc_root s r (scc_of E u)\n  \\<lbrakk>scc_root s ?v ?scc; ?x \\<in> ?scc;\n   ?x \\<in> dom (discovered s)\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?v \\<le> \\<delta> s ?x\n  u \\<in> scc_of E u\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<delta> s r \\<le> \\<delta> s u", "by blast"], ["proof (state)\nthis:\n  \\<delta> s r \\<le> \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (stack s).\n       (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u", "ultimately"], ["proof (chain)\npicking this:\n  r \\<in> set (stack s)\n  (u, r) \\<in> E\\<^sup>*\n  \\<delta> s r \\<le> \\<delta> s u", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<in> set (stack s)\n  (u, r) \\<in> E\\<^sup>*\n  \\<delta> s r \\<le> \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (stack s).\n       (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u", "by metis"], ["proof (state)\nthis:\n  \\<exists>v\\<in>set (stack s).\n     (u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tj_stack_reach_hd_stack:\n    assumes \"v \\<in> set (tj_stack s)\"\n    shows \"(v, hd (stack s)) \\<in> E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, hd (stack s)) \\<in> E\\<^sup>*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, hd (stack s)) \\<in> E\\<^sup>*", "from tj_stack_reach_stack assms"], ["proof (chain)\npicking this:\n  ?u \\<in> set (tj_stack s) \\<Longrightarrow>\n  \\<exists>v\\<in>set (stack s).\n     (?u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s ?u\n  v \\<in> set (tj_stack s)", "obtain r where r: \"r \\<in> set (stack s)\" \"(v,r) \\<in> E\\<^sup>*\""], ["proof (prove)\nusing this:\n  ?u \\<in> set (tj_stack s) \\<Longrightarrow>\n  \\<exists>v\\<in>set (stack s).\n     (?u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s ?u\n  v \\<in> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r \\<in> set (stack s); (v, r) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  r \\<in> set (stack s)\n  (v, r) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, hd (stack s)) \\<in> E\\<^sup>*", "hence \"r = hd (stack s) \\<or> r \\<in> set (tl (stack s))\""], ["proof (prove)\nusing this:\n  r \\<in> set (stack s)\n  (v, r) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. r = hd (stack s) \\<or> r \\<in> set (tl (stack s))", "by (cases \"stack s\") auto"], ["proof (state)\nthis:\n  r = hd (stack s) \\<or> r \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. (v, hd (stack s)) \\<in> E\\<^sup>*", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = hd (stack s) \\<or> r \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. (v, hd (stack s)) \\<in> E\\<^sup>*", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. r = hd (stack s) \\<Longrightarrow> (v, hd (stack s)) \\<in> E\\<^sup>*\n 2. r \\<in> set (tl (stack s)) \\<Longrightarrow>\n    (v, hd (stack s)) \\<in> E\\<^sup>*", "assume \"r = hd (stack s)\""], ["proof (state)\nthis:\n  r = hd (stack s)\n\ngoal (2 subgoals):\n 1. r = hd (stack s) \\<Longrightarrow> (v, hd (stack s)) \\<in> E\\<^sup>*\n 2. r \\<in> set (tl (stack s)) \\<Longrightarrow>\n    (v, hd (stack s)) \\<in> E\\<^sup>*", "with r"], ["proof (chain)\npicking this:\n  r \\<in> set (stack s)\n  (v, r) \\<in> E\\<^sup>*\n  r = hd (stack s)", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<in> set (stack s)\n  (v, r) \\<in> E\\<^sup>*\n  r = hd (stack s)\n\ngoal (1 subgoal):\n 1. (v, hd (stack s)) \\<in> E\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (v, hd (stack s)) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. r \\<in> set (tl (stack s)) \\<Longrightarrow>\n    (v, hd (stack s)) \\<in> E\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<in> set (tl (stack s)) \\<Longrightarrow>\n    (v, hd (stack s)) \\<in> E\\<^sup>*", "from r"], ["proof (chain)\npicking this:\n  r \\<in> set (stack s)\n  (v, r) \\<in> E\\<^sup>*", "have ne :\"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  r \\<in> set (stack s)\n  (v, r) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<in> set (tl (stack s)) \\<Longrightarrow>\n    (v, hd (stack s)) \\<in> E\\<^sup>*", "assume \"r \\<in> set (tl (stack s))\""], ["proof (state)\nthis:\n  r \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. r \\<in> set (tl (stack s)) \\<Longrightarrow>\n    (v, hd (stack s)) \\<in> E\\<^sup>*", "with tl_stack_hd_tree_path ne"], ["proof (chain)\npicking this:\n  \\<lbrakk>stack s \\<noteq> []; ?v \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  stack s \\<noteq> []\n  r \\<in> set (tl (stack s))", "have \"(r,hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<lbrakk>stack s \\<noteq> []; ?v \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  stack s \\<noteq> []\n  r \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. (r, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (r, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. r \\<in> set (tl (stack s)) \\<Longrightarrow>\n    (v, hd (stack s)) \\<in> E\\<^sup>*", "with trancl_mono_mp tree_edges_ssE"], ["proof (chain)\npicking this:\n  \\<lbrakk>?U \\<subseteq> ?V; ?x \\<in> ?U\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?V\\<^sup>+\n  tree_edges s \\<subseteq> E\n  (r, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+", "have \"(r,hd (stack s))\\<in>E\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?U \\<subseteq> ?V; ?x \\<in> ?U\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?V\\<^sup>+\n  tree_edges s \\<subseteq> E\n  (r, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (r, hd (stack s)) \\<in> E\\<^sup>*", "by (metis rtrancl_eq_or_trancl)"], ["proof (state)\nthis:\n  (r, hd (stack s)) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. r \\<in> set (tl (stack s)) \\<Longrightarrow>\n    (v, hd (stack s)) \\<in> E\\<^sup>*", "with \\<open>(v,r)\\<in>E\\<^sup>*\\<close>"], ["proof (chain)\npicking this:\n  (v, r) \\<in> E\\<^sup>*\n  (r, hd (stack s)) \\<in> E\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, r) \\<in> E\\<^sup>*\n  (r, hd (stack s)) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, hd (stack s)) \\<in> E\\<^sup>*", "by (metis rtrancl_trans)"], ["proof (state)\nthis:\n  (v, hd (stack s)) \\<in> E\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, hd (stack s)) \\<in> E\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma empty_stack_imp_empty_tj_stack: \n    assumes \"stack s = []\"\n    shows \"tj_stack s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tj_stack s = []", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. tj_stack s \\<noteq> [] \\<Longrightarrow> False", "assume ne: \"tj_stack s \\<noteq> []\""], ["proof (state)\nthis:\n  tj_stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. tj_stack s \\<noteq> [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  tj_stack s \\<noteq> []", "obtain x where x: \"x \\<in> set (tj_stack s)\""], ["proof (prove)\nusing this:\n  tj_stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set (tj_stack s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. tj_stack s \\<noteq> [] \\<Longrightarrow> False", "with tj_stack_reach_stack"], ["proof (chain)\npicking this:\n  ?u \\<in> set (tj_stack s) \\<Longrightarrow>\n  \\<exists>v\\<in>set (stack s).\n     (?u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s ?u\n  x \\<in> set (tj_stack s)", "obtain r where \"r \\<in> set (stack s)\""], ["proof (prove)\nusing this:\n  ?u \\<in> set (tj_stack s) \\<Longrightarrow>\n  \\<exists>v\\<in>set (stack s).\n     (?u, v) \\<in> E\\<^sup>* \\<and> \\<delta> s v \\<le> \\<delta> s ?u\n  x \\<in> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r \\<in> set (stack s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. tj_stack s \\<noteq> [] \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  stack s = []\n  r \\<in> set (stack s)", "show False"], ["proof (prove)\nusing this:\n  stack s = []\n  r \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stacks_eq_iff: \"stack s = [] \\<longleftrightarrow> tj_stack s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stack s = []) = (tj_stack s = [])", "using empty_stack_imp_empty_tj_stack stack_ss_tj_stack"], ["proof (prove)\nusing this:\n  stack s = [] \\<Longrightarrow> tj_stack s = []\n  set (stack s) \\<subseteq> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. (stack s = []) = (tj_stack s = [])", "by auto"], ["", "end"], ["", "end"], ["", "context Tarjan begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma i_sccs_are_sccs:\n    \"is_invar (\\<lambda>s. \\<forall>scc \\<in> sccs s. is_scc E scc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar (\\<lambda>s. \\<forall>scc\\<in>sccs s. is_scc E scc)", "proof (induction rule: establish_invarI)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "case (finish s s' u)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "have EQ[simp]:\n      \"finished s' = (finished s)(u \\<mapsto> counter s)\"\n      \"discovered s' = discovered s\"\n      \"tree_edges s' = tree_edges s\"\n      \"sccs s' = sccs s\"\n      \"tj_stack s' = tj_stack s\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. (finished s' = finished s(u \\<mapsto> counter s) &&&\n     discovered s' = discovered s) &&&\n    tree_edges s' = tree_edges s &&&\n    sccs s' = sccs s &&& tj_stack s' = tj_stack s", "by simp_all"], ["proof (state)\nthis:\n  finished s' = finished s(u \\<mapsto> counter s)\n  discovered s' = discovered s\n  tree_edges s' = tree_edges s\n  sccs s' = sccs s\n  tj_stack s' = tj_stack s\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "{"], ["proof (state)\nthis:\n  finished s' = finished s(u \\<mapsto> counter s)\n  discovered s' = discovered s\n  tree_edges s' = tree_edges s\n  sccs s' = sccs s\n  tj_stack s' = tj_stack s\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "fix x"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "let ?s = \"s'\\<lparr>state.more := x\\<rparr>\""], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "assume TRANS: \"\\<And>\\<Psi>. tarjan_fin u s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow> \\<Psi> x\"\n      and inv': \"DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\""], ["proof (state)\nthis:\n  tarjan_fin u s' \\<le>\\<^sub>n SPEC ?\\<Psi>7 \\<Longrightarrow> ?\\<Psi>7 x\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "then"], ["proof (chain)\npicking this:\n  tarjan_fin u s' \\<le>\\<^sub>n SPEC ?\\<Psi>7 \\<Longrightarrow> ?\\<Psi>7 x\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)", "interpret s': Tarjan_invar where s=\"?s\""], ["proof (prove)\nusing this:\n  tarjan_fin u s' \\<le>\\<^sub>n SPEC ?\\<Psi>7 \\<Longrightarrow> ?\\<Psi>7 x\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (1 subgoal):\n 1. Tarjan_invar G (s'\\<lparr>state.more := x\\<rparr>)", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "from finish hd_in_set stack_set_def"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  set (stack s) = dom (discovered s) - dom (finished s)", "have \n        u_disc: \"u \\<in> dom (discovered s)\" \n        and u_n_fin: \"u \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  set (stack s) = dom (discovered s) - dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<in> dom (discovered s) &&& u \\<notin> dom (finished s)", "by blast+"], ["proof (state)\nthis:\n  u \\<in> dom (discovered s)\n  u \\<notin> dom (finished s)\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "have \"\\<forall>scc \\<in> sccs ?s. is_scc E scc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "proof (cases \"scc_root s' u (scc_of E u)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc\n 2. \\<not> scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "case False"], ["proof (state)\nthis:\n  \\<not> scc_root s' u (scc_of E u)\n\ngoal (2 subgoals):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc\n 2. \\<not> scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "have \"sccs ?s = sccs s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sccs (s'\\<lparr>state.more := x\\<rparr>) = sccs s", "apply (rule TRANS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tarjan_fin u s' \\<le>\\<^sub>n\n    SPEC (\\<lambda>a. sccs (s'\\<lparr>state.more := a\\<rparr>) = sccs s)", "unfolding tarjan_fin_def tj_stack_pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ll = if stack s' = [] then lowlink s'\n              else let ua = hd (stack s')\n                   in lowlink s'(ua \\<mapsto>\n                      min (\\<zeta> s' ua) (\\<zeta> s' u));\n         s'a = s'\\<lparr>lowlink := ll\\<rparr>\n     in ASSERT (u \\<in> set (tj_stack s')) \\<bind>\n        (\\<lambda>_.\n            ASSERT (distinct (tj_stack s')) \\<bind>\n            (\\<lambda>_.\n                if \\<zeta> s' u = \\<delta> s' u\n                then ASSERT (scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_.\n                         RETURN\n                          (tl (dropWhile ((\\<noteq>) u) (tj_stack s')),\n                           insert u\n                            (set (takeWhile ((\\<noteq>) u)\n                                   (tj_stack s')))) \\<bind>\n                         (\\<lambda>(tjs, scc).\n                             NOOP\n                              (s'a\\<lparr>tj_stack := tjs,\n                                     sccs := insert scc (sccs s')\\<rparr>)))\n                else ASSERT (\\<not> scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_. NOOP s'a)))) \\<le>\\<^sub>n\n    SPEC (\\<lambda>a. sccs (s'\\<lparr>state.more := a\\<rparr>) = sccs s)", "by (refine_vcg) (simp_all add: False)"], ["proof (state)\nthis:\n  sccs (s'\\<lparr>state.more := x\\<rparr>) = sccs s\n\ngoal (2 subgoals):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc\n 2. \\<not> scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "thus ?thesis"], ["proof (prove)\nusing this:\n  sccs (s'\\<lparr>state.more := x\\<rparr>) = sccs s\n\ngoal (1 subgoal):\n 1. \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "by (simp add: finish)"], ["proof (state)\nthis:\n  \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "case True"], ["proof (state)\nthis:\n  scc_root s' u (scc_of E u)\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "let ?dw = \"dropWhile ((\\<noteq>) u) (tj_stack s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "let ?tw = \"takeWhile ((\\<noteq>) u) (tj_stack s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "let ?tw' = \"insert u (set ?tw)\""], ["proof (state)\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "have [simp]: \"sccs ?s = insert ?tw' (sccs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sccs (s'\\<lparr>state.more := x\\<rparr>) =\n    insert (insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))) (sccs s)", "apply (rule TRANS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tarjan_fin u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         sccs (s'\\<lparr>state.more := a\\<rparr>) =\n         insert (insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s))))\n          (sccs s))", "unfolding tarjan_fin_def tj_stack_pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ll = if stack s' = [] then lowlink s'\n              else let ua = hd (stack s')\n                   in lowlink s'(ua \\<mapsto>\n                      min (\\<zeta> s' ua) (\\<zeta> s' u));\n         s'a = s'\\<lparr>lowlink := ll\\<rparr>\n     in ASSERT (u \\<in> set (tj_stack s')) \\<bind>\n        (\\<lambda>_.\n            ASSERT (distinct (tj_stack s')) \\<bind>\n            (\\<lambda>_.\n                if \\<zeta> s' u = \\<delta> s' u\n                then ASSERT (scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_.\n                         RETURN\n                          (tl (dropWhile ((\\<noteq>) u) (tj_stack s')),\n                           insert u\n                            (set (takeWhile ((\\<noteq>) u)\n                                   (tj_stack s')))) \\<bind>\n                         (\\<lambda>(tjs, scc).\n                             NOOP\n                              (s'a\\<lparr>tj_stack := tjs,\n                                     sccs := insert scc (sccs s')\\<rparr>)))\n                else ASSERT (\\<not> scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_. NOOP s'a)))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         sccs (s'\\<lparr>state.more := a\\<rparr>) =\n         insert (insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s))))\n          (sccs s))", "by (refine_vcg) (simp_all add: True)"], ["proof (state)\nthis:\n  sccs (s'\\<lparr>state.more := x\\<rparr>) =\n  insert (insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))) (sccs s)\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "have [simp]: \"tj_stack ?s = tl ?dw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tj_stack (s'\\<lparr>state.more := x\\<rparr>) =\n    tl (dropWhile ((\\<noteq>) u) (tj_stack s))", "apply (rule TRANS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tarjan_fin u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         tj_stack (s'\\<lparr>state.more := a\\<rparr>) =\n         tl (dropWhile ((\\<noteq>) u) (tj_stack s)))", "unfolding tarjan_fin_def tj_stack_pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ll = if stack s' = [] then lowlink s'\n              else let ua = hd (stack s')\n                   in lowlink s'(ua \\<mapsto>\n                      min (\\<zeta> s' ua) (\\<zeta> s' u));\n         s'a = s'\\<lparr>lowlink := ll\\<rparr>\n     in ASSERT (u \\<in> set (tj_stack s')) \\<bind>\n        (\\<lambda>_.\n            ASSERT (distinct (tj_stack s')) \\<bind>\n            (\\<lambda>_.\n                if \\<zeta> s' u = \\<delta> s' u\n                then ASSERT (scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_.\n                         RETURN\n                          (tl (dropWhile ((\\<noteq>) u) (tj_stack s')),\n                           insert u\n                            (set (takeWhile ((\\<noteq>) u)\n                                   (tj_stack s')))) \\<bind>\n                         (\\<lambda>(tjs, scc).\n                             NOOP\n                              (s'a\\<lparr>tj_stack := tjs,\n                                     sccs := insert scc (sccs s')\\<rparr>)))\n                else ASSERT (\\<not> scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_. NOOP s'a)))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         tj_stack (s'\\<lparr>state.more := a\\<rparr>) =\n         tl (dropWhile ((\\<noteq>) u) (tj_stack s)))", "by (refine_vcg) (simp_all add: True)"], ["proof (state)\nthis:\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) =\n  tl (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "from True scc_root_transfer'[where s'=s']"], ["proof (chain)\npicking this:\n  scc_root s' u (scc_of E u)\n  \\<lbrakk>discovered s = discovered s';\n   tree_edges s = tree_edges s'\\<rbrakk>\n  \\<Longrightarrow> scc_root s ?r ?scc = scc_root s' ?r ?scc", "have \"scc_root s u (scc_of E u)\""], ["proof (prove)\nusing this:\n  scc_root s' u (scc_of E u)\n  \\<lbrakk>discovered s = discovered s';\n   tree_edges s = tree_edges s'\\<rbrakk>\n  \\<Longrightarrow> scc_root s ?r ?scc = scc_root s' ?r ?scc\n\ngoal (1 subgoal):\n 1. scc_root s u (scc_of E u)", "by simp"], ["proof (state)\nthis:\n  scc_root s u (scc_of E u)\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "with inv' scc_root_transfer[where s'=\"?s\"] u_disc"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n  \\<lbrakk>DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>);\n   ?r \\<in> dom (discovered s);\n   dom (discovered s)\n   \\<subseteq> dom (discovered (s'\\<lparr>state.more := x\\<rparr>));\n   \\<forall>xa\\<in>dom (discovered s).\n      \\<delta> s xa = \\<delta> (s'\\<lparr>state.more := x\\<rparr>) xa;\n   \\<forall>xa\\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)) -\n                   dom (discovered s).\n      counter s \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) xa;\n   tree_edges s\n   \\<subseteq> tree_edges (s'\\<lparr>state.more := x\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> scc_root s ?r ?scc =\n                    scc_root (s'\\<lparr>state.more := x\\<rparr>) ?r ?scc\n  u \\<in> dom (discovered s)\n  scc_root s u (scc_of E u)", "have u_root: \"scc_root ?s u (scc_of E u)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n  \\<lbrakk>DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>);\n   ?r \\<in> dom (discovered s);\n   dom (discovered s)\n   \\<subseteq> dom (discovered (s'\\<lparr>state.more := x\\<rparr>));\n   \\<forall>xa\\<in>dom (discovered s).\n      \\<delta> s xa = \\<delta> (s'\\<lparr>state.more := x\\<rparr>) xa;\n   \\<forall>xa\\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)) -\n                   dom (discovered s).\n      counter s \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) xa;\n   tree_edges s\n   \\<subseteq> tree_edges (s'\\<lparr>state.more := x\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> scc_root s ?r ?scc =\n                    scc_root (s'\\<lparr>state.more := x\\<rparr>) ?r ?scc\n  u \\<in> dom (discovered s)\n  scc_root s u (scc_of E u)\n\ngoal (1 subgoal):\n 1. scc_root (s'\\<lparr>state.more := x\\<rparr>) u (scc_of E u)", "by simp"], ["proof (state)\nthis:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) u (scc_of E u)\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "have \"?tw' \\<subseteq> scc_of E u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n    \\<subseteq> scc_of E u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> insert u\n                (set (takeWhile ((\\<noteq>) u)\n                       (tj_stack s))) \\<Longrightarrow>\n       x \\<in> scc_of E u", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> insert u\n                (set (takeWhile ((\\<noteq>) u)\n                       (tj_stack s))) \\<Longrightarrow>\n       x \\<in> scc_of E u", "assume v: \"v \\<in> ?tw'\""], ["proof (state)\nthis:\n  v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> insert u\n                (set (takeWhile ((\\<noteq>) u)\n                       (tj_stack s))) \\<Longrightarrow>\n       x \\<in> scc_of E u", "show \"v \\<in> scc_of E u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> scc_of E u", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "assume \"v \\<noteq> u\""], ["proof (state)\nthis:\n  v \\<noteq> u\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "with v"], ["proof (chain)\npicking this:\n  v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n  v \\<noteq> u", "have v: \"v \\<in> set ?tw\""], ["proof (prove)\nusing this:\n  v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n  v \\<noteq> u\n\ngoal (1 subgoal):\n 1. v \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "hence v_tj: \"v \\<in> set (tj_stack s)\""], ["proof (prove)\nusing this:\n  v \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. v \\<in> set (tj_stack s)", "by (auto dest: set_takeWhileD)"], ["proof (state)\nthis:\n  v \\<in> set (tj_stack s)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "with tj_stack_discovered"], ["proof (chain)\npicking this:\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n  v \\<in> set (tj_stack s)", "have v_disc: \"v \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  set (tj_stack s) \\<subseteq> dom (discovered s)\n  v \\<in> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (discovered s)", "by auto"], ["proof (state)\nthis:\n  v \\<in> dom (discovered s)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "from hd_stack_in_tj_stack finish"], ["proof (chain)\npicking this:\n  stack s \\<noteq> [] \\<Longrightarrow> hd (stack s) \\<in> set (tj_stack s)\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "have \"?dw \\<noteq> []\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> [] \\<Longrightarrow> hd (stack s) \\<in> set (tj_stack s)\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "with hd_dropWhile[OF this] hd_in_set"], ["proof (chain)\npicking this:\n  \\<not> u \\<noteq> hd (dropWhile ((\\<noteq>) u) (tj_stack s))\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> []", "have \"u \\<in> set ?dw\""], ["proof (prove)\nusing this:\n  \\<not> u \\<noteq> hd (dropWhile ((\\<noteq>) u) (tj_stack s))\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  dropWhile ((\\<noteq>) u) (tj_stack s) \\<noteq> []\n\ngoal (1 subgoal):\n 1. u \\<in> set (dropWhile ((\\<noteq>) u) (tj_stack s))", "by metis"], ["proof (state)\nthis:\n  u \\<in> set (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "with v"], ["proof (chain)\npicking this:\n  v \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n  u \\<in> set (dropWhile ((\\<noteq>) u) (tj_stack s))", "have \"\\<delta> s v > \\<delta> s u\""], ["proof (prove)\nusing this:\n  v \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n  u \\<in> set (dropWhile ((\\<noteq>) u) (tj_stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<delta> s v", "using tjs_disc_dw_tw"], ["proof (prove)\nusing this:\n  v \\<in> set (takeWhile ((\\<noteq>) u) (tj_stack s))\n  u \\<in> set (dropWhile ((\\<noteq>) u) (tj_stack s))\n  \\<lbrakk>?x \\<in> set (dropWhile ((\\<noteq>) ?u) (tj_stack s));\n   ?y \\<in> set (takeWhile ((\\<noteq>) ?u) (tj_stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?x < \\<delta> s ?y\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<delta> s v", "by blast"], ["proof (state)\nthis:\n  \\<delta> s u < \\<delta> s v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "moreover"], ["proof (state)\nthis:\n  \\<delta> s u < \\<delta> s v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "have \"v \\<in> dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s) \\<Longrightarrow> False", "assume \"v \\<notin> dom (finished s)\""], ["proof (state)\nthis:\n  v \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s) \\<Longrightarrow> False", "with v_disc stack_set_def"], ["proof (chain)\npicking this:\n  v \\<in> dom (discovered s)\n  set (stack s) = dom (discovered s) - dom (finished s)\n  v \\<notin> dom (finished s)", "have \"v \\<in> set (stack s)\""], ["proof (prove)\nusing this:\n  v \\<in> dom (discovered s)\n  set (stack s) = dom (discovered s) - dom (finished s)\n  v \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<in> set (stack s)", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s) \\<Longrightarrow> False", "with \\<open>v\\<noteq>u\\<close> finish"], ["proof (chain)\npicking this:\n  v \\<noteq> u\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  v \\<in> set (stack s)", "have \"v \\<in> set (tl (stack s))\""], ["proof (prove)\nusing this:\n  v \\<noteq> u\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  v \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. v \\<in> set (tl (stack s))", "by (cases \"stack s\") auto"], ["proof (state)\nthis:\n  v \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s) \\<Longrightarrow> False", "with tl_lt_stack_hd_discover finish"], ["proof (chain)\npicking this:\n  \\<lbrakk>stack s \\<noteq> []; ?x \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?x < \\<delta> s (hd (stack s))\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  v \\<in> set (tl (stack s))", "have \"\\<delta> s v < \\<delta> s u\""], ["proof (prove)\nusing this:\n  \\<lbrakk>stack s \\<noteq> []; ?x \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?x < \\<delta> s (hd (stack s))\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  v \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s u", "by simp"], ["proof (state)\nthis:\n  \\<delta> s v < \\<delta> s u\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (finished s) \\<Longrightarrow> False", "with \\<open>\\<delta> s v > \\<delta> s u\\<close>"], ["proof (chain)\npicking this:\n  \\<delta> s u < \\<delta> s v\n  \\<delta> s v < \\<delta> s u", "show False"], ["proof (prove)\nusing this:\n  \\<delta> s u < \\<delta> s v\n  \\<delta> s v < \\<delta> s u\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> dom (finished s)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta> s u < \\<delta> s v\n  v \\<in> dom (finished s)", "have \"(u,v) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<delta> s u < \\<delta> s v\n  v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (tree_edges s)\\<^sup>+", "using parenthesis_impl_tree_path_not_finished[OF u_disc] u_n_fin"], ["proof (prove)\nusing this:\n  \\<delta> s u < \\<delta> s v\n  v \\<in> dom (finished s)\n  \\<lbrakk>?w \\<in> dom (finished s); \\<delta> s u < \\<delta> s ?w;\n   u \\<notin> dom (finished s)\\<rbrakk>\n  \\<Longrightarrow> (u, ?w) \\<in> (tree_edges s)\\<^sup>+\n  u \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (tree_edges s)\\<^sup>+", "by force"], ["proof (state)\nthis:\n  (u, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "with trancl_mono_mp tree_edges_ssE"], ["proof (chain)\npicking this:\n  \\<lbrakk>?U \\<subseteq> ?V; ?x \\<in> ?U\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?V\\<^sup>+\n  tree_edges s \\<subseteq> E\n  (u, v) \\<in> (tree_edges s)\\<^sup>+", "have \"(u,v)\\<in>E\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?U \\<subseteq> ?V; ?x \\<in> ?U\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?V\\<^sup>+\n  tree_edges s \\<subseteq> E\n  (u, v) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E\\<^sup>*", "by (metis rtrancl_eq_or_trancl)"], ["proof (state)\nthis:\n  (u, v) \\<in> E\\<^sup>*\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "moreover"], ["proof (state)\nthis:\n  (u, v) \\<in> E\\<^sup>*\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "from tj_stack_reach_hd_stack v_tj finish"], ["proof (chain)\npicking this:\n  ?v \\<in> set (tj_stack s) \\<Longrightarrow>\n  (?v, hd (stack s)) \\<in> E\\<^sup>*\n  v \\<in> set (tj_stack s)\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "have \"(v,u)\\<in>E\\<^sup>*\""], ["proof (prove)\nusing this:\n  ?v \\<in> set (tj_stack s) \\<Longrightarrow>\n  (?v, hd (stack s)) \\<in> E\\<^sup>*\n  v \\<in> set (tj_stack s)\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> E\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (v, u) \\<in> E\\<^sup>*\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "moreover"], ["proof (state)\nthis:\n  (v, u) \\<in> E\\<^sup>*\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "have \"is_scc E (scc_of E u)\" \"u \\<in> scc_of E u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scc E (scc_of E u) &&& u \\<in> scc_of E u", "by simp_all"], ["proof (state)\nthis:\n  is_scc E (scc_of E u)\n  u \\<in> scc_of E u\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> scc_of E u\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> scc_of E u", "ultimately"], ["proof (chain)\npicking this:\n  (u, v) \\<in> E\\<^sup>*\n  (v, u) \\<in> E\\<^sup>*\n  is_scc E (scc_of E u)\n  u \\<in> scc_of E u", "show ?thesis"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n  (v, u) \\<in> E\\<^sup>*\n  is_scc E (scc_of E u)\n  u \\<in> scc_of E u\n\ngoal (1 subgoal):\n 1. v \\<in> scc_of E u", "using is_scc_closed"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n  (v, u) \\<in> E\\<^sup>*\n  is_scc E (scc_of E u)\n  u \\<in> scc_of E u\n  \\<lbrakk>is_scc ?E ?U; ?x \\<in> ?U; (?x, ?y) \\<in> ?E\\<^sup>*;\n   (?y, ?x) \\<in> ?E\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> ?U\n\ngoal (1 subgoal):\n 1. v \\<in> scc_of E u", "by metis"], ["proof (state)\nthis:\n  v \\<in> scc_of E u\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> u \\<Longrightarrow> v \\<in> scc_of E u", "qed simp"], ["proof (state)\nthis:\n  v \\<in> scc_of E u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n  \\<subseteq> scc_of E u\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "moreover"], ["proof (state)\nthis:\n  insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n  \\<subseteq> scc_of E u\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "have \"scc_of E u \\<subseteq> ?tw'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scc_of E u\n    \\<subseteq> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> scc_of E u \\<Longrightarrow>\n       x \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> scc_of E u \\<Longrightarrow>\n       x \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "assume v: \"v \\<in> scc_of E u\""], ["proof (state)\nthis:\n  v \\<in> scc_of E u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> scc_of E u \\<Longrightarrow>\n       x \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "moreover"], ["proof (state)\nthis:\n  v \\<in> scc_of E u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> scc_of E u \\<Longrightarrow>\n       x \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "note u_root"], ["proof (state)\nthis:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) u (scc_of E u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> scc_of E u \\<Longrightarrow>\n       x \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "moreover"], ["proof (state)\nthis:\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) u (scc_of E u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> scc_of E u \\<Longrightarrow>\n       x \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "have \"u \\<in> dom (finished ?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  u \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> scc_of E u \\<Longrightarrow>\n       x \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> scc_of E u\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) u (scc_of E u)\n  u \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))", "have \"v \\<in> dom (finished ?s)\" \"v \\<notin> set (tj_stack ?s)\""], ["proof (prove)\nusing this:\n  v \\<in> scc_of E u\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) u (scc_of E u)\n  u \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>)) &&&\n    v \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "using s'.scc_root_finished_impl_scc_finished s'.no_finished_root"], ["proof (prove)\nusing this:\n  v \\<in> scc_of E u\n  scc_root (s'\\<lparr>state.more := x\\<rparr>) u (scc_of E u)\n  u \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  \\<lbrakk>?v \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>));\n   scc_root (s'\\<lparr>state.more := x\\<rparr>) ?v ?scc\\<rbrakk>\n  \\<Longrightarrow> ?scc\n                    \\<subseteq> dom (finished\n(s'\\<lparr>state.more := x\\<rparr>))\n  \\<lbrakk>scc_root (s'\\<lparr>state.more := x\\<rparr>) ?r ?scc;\n   ?r \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>));\n   ?x \\<in> ?scc\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> set (tj_stack\n(s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>)) &&&\n    v \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "by auto"], ["proof (state)\nthis:\n  v \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  v \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> scc_of E u \\<Longrightarrow>\n       x \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "with s'.finished_ss_sccs_tj_stack"], ["proof (chain)\npicking this:\n  dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  \\<subseteq> \\<Union> (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n              set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n  v \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  v \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "have \"v \\<in> \\<Union>(sccs ?s)\""], ["proof (prove)\nusing this:\n  dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  \\<subseteq> \\<Union> (sccs (s'\\<lparr>state.more := x\\<rparr>)) \\<union>\n              set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n  v \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  v \\<notin> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> (sccs (s'\\<lparr>state.more := x\\<rparr>))", "by blast"], ["proof (state)\nthis:\n  v \\<in> \\<Union> (sccs (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> scc_of E u \\<Longrightarrow>\n       x \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "hence \"v \\<in> \\<Union>(sccs s) \\<or> v \\<in> ?tw'\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (sccs (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> (sccs s) \\<or>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "by auto"], ["proof (state)\nthis:\n  v \\<in> \\<Union> (sccs s) \\<or>\n  v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> scc_of E u \\<Longrightarrow>\n       x \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "thus \"v \\<in> ?tw'\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (sccs s) \\<or>\n  v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (1 subgoal):\n 1. v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "assume \"v \\<in> \\<Union>(sccs s)\""], ["proof (state)\nthis:\n  v \\<in> \\<Union> (sccs s)\n\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "then"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> (sccs s)", "obtain scc where scc: \"v \\<in> scc\" \"scc \\<in> sccs s\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (sccs s)\n\ngoal (1 subgoal):\n 1. (\\<And>scc.\n        \\<lbrakk>v \\<in> scc; scc \\<in> sccs s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> scc\n  scc \\<in> sccs s\n\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "moreover"], ["proof (state)\nthis:\n  v \\<in> scc\n  scc \\<in> sccs s\n\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "with finish"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  v \\<in> scc\n  scc \\<in> sccs s", "have \"is_scc E scc\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  v \\<in> scc\n  scc \\<in> sccs s\n\ngoal (1 subgoal):\n 1. is_scc E scc", "by simp"], ["proof (state)\nthis:\n  is_scc E scc\n\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "moreover"], ["proof (state)\nthis:\n  is_scc E scc\n\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "have \"is_scc E (scc_of E u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scc E (scc_of E u)", "by simp"], ["proof (state)\nthis:\n  is_scc E (scc_of E u)\n\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "moreover"], ["proof (state)\nthis:\n  is_scc E (scc_of E u)\n\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "note v"], ["proof (state)\nthis:\n  v \\<in> scc_of E u\n\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> scc\n  scc \\<in> sccs s\n  is_scc E scc\n  is_scc E (scc_of E u)\n  v \\<in> scc_of E u", "have \"scc = scc_of E u\""], ["proof (prove)\nusing this:\n  v \\<in> scc\n  scc \\<in> sccs s\n  is_scc E scc\n  is_scc E (scc_of E u)\n  v \\<in> scc_of E u\n\ngoal (1 subgoal):\n 1. scc = scc_of E u", "using is_scc_unique"], ["proof (prove)\nusing this:\n  v \\<in> scc\n  scc \\<in> sccs s\n  is_scc E scc\n  is_scc E (scc_of E u)\n  v \\<in> scc_of E u\n  \\<lbrakk>is_scc ?E ?scc; is_scc ?E ?scc'; ?v \\<in> ?scc;\n   ?v \\<in> ?scc'\\<rbrakk>\n  \\<Longrightarrow> ?scc = ?scc'\n\ngoal (1 subgoal):\n 1. scc = scc_of E u", "by metis"], ["proof (state)\nthis:\n  scc = scc_of E u\n\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "hence \"u \\<in> scc\""], ["proof (prove)\nusing this:\n  scc = scc_of E u\n\ngoal (1 subgoal):\n 1. u \\<in> scc", "by simp"], ["proof (state)\nthis:\n  u \\<in> scc\n\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "with scc sccs_finished"], ["proof (chain)\npicking this:\n  v \\<in> scc\n  scc \\<in> sccs s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s)\n  u \\<in> scc", "have \"u \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  v \\<in> scc\n  scc \\<in> sccs s\n  \\<Union> (sccs s) \\<subseteq> dom (finished s)\n  u \\<in> scc\n\ngoal (1 subgoal):\n 1. u \\<in> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  u \\<in> dom (finished s)\n\ngoal (2 subgoals):\n 1. v \\<in> \\<Union> (sccs s) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n 2. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "with u_n_fin"], ["proof (chain)\npicking this:\n  u \\<notin> dom (finished s)\n  u \\<in> dom (finished s)", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<notin> dom (finished s)\n  u \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "by contradiction"], ["proof (state)\nthis:\n  v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (1 subgoal):\n 1. v \\<in> insert u\n             (set (takeWhile ((\\<noteq>) u) (tj_stack s))) \\<Longrightarrow>\n    v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "qed simp"], ["proof (state)\nthis:\n  v \\<in> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  scc_of E u\n  \\<subseteq> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "ultimately"], ["proof (chain)\npicking this:\n  insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n  \\<subseteq> scc_of E u\n  scc_of E u\n  \\<subseteq> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))", "have \"?tw' = scc_of E u\""], ["proof (prove)\nusing this:\n  insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n  \\<subseteq> scc_of E u\n  scc_of E u\n  \\<subseteq> insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s)))\n\ngoal (1 subgoal):\n 1. insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s))) = scc_of E u", "by auto"], ["proof (state)\nthis:\n  insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s))) = scc_of E u\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "hence \"is_scc E ?tw'\""], ["proof (prove)\nusing this:\n  insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s))) = scc_of E u\n\ngoal (1 subgoal):\n 1. is_scc E (insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s))))", "by simp"], ["proof (state)\nthis:\n  is_scc E (insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s))))\n\ngoal (1 subgoal):\n 1. scc_root s' u (scc_of E u) \\<Longrightarrow>\n    \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "with finish"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  is_scc E (insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s))))", "show ?thesis"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  is_scc E (insert u (set (takeWhile ((\\<noteq>) u) (tj_stack s))))\n\ngoal (1 subgoal):\n 1. \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc", "by auto"], ["proof (state)\nthis:\n  \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>). is_scc E scc\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_fin u s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>scc\\<in>sccs\n(s'\\<lparr>state.more := ?x9\\<rparr>).\n                       is_scc E scc\n\ngoal (6 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_fin u s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>scc\\<in>sccs\n(s'\\<lparr>state.more := ?x9\\<rparr>).\n                       is_scc E scc\n\ngoal (1 subgoal):\n 1. on_finish tarjan_params u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         (\\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n             is_scc E scc))", "by (auto simp: pw_leof_iff finish)"], ["proof (state)\nthis:\n  on_finish tarjan_params u s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       (\\<forall>scc\\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n           is_scc E scc))\n\ngoal (5 subgoals):\n 1. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC (\\<lambda>x. \\<forall>scc\\<in>sccs (empty_state x). is_scc E scc)\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>scc\\<in>sccs s. is_scc E scc; cond s;\n        \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>scc\n  \\<in>sccs (s'\\<lparr>state.more := x\\<rparr>).\n                                  is_scc E scc))", "qed (simp_all add: tarjan_back_def tarjan_disc_def)"], ["", "end"], ["", "lemmas (in Tarjan_invar) sccs_are_sccs =\n    i_sccs_are_sccs[THEN make_invar_thm]"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma i_lowlink_eq_LowLink:\n    \"is_invar (\\<lambda>s. \\<forall>x \\<in> dom (discovered s). \\<zeta> s x = LowLink s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "fix s s' :: \"'v tarjan_state\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "fix v w"], ["proof (state)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "let ?s = \"s'\\<lparr>state.more := x\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "assume pre_ll_sub_rev: \"\\<And>w. \\<lbrakk>Tarjan_invar G ?s; w \\<in> dom (discovered ?s); w \\<noteq> v\\<rbrakk> \\<Longrightarrow> lowlink_set ?s w \\<subseteq> lowlink_set s w \\<union> {v}\""], ["proof (state)\nthis:\n  \\<lbrakk>Tarjan_invar G (s'\\<lparr>state.more := x\\<rparr>);\n   ?w7 \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>));\n   ?w7 \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) ?w7\n                    \\<subseteq> lowlink_set s ?w7 \\<union> {v}\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "assume tree_sub : \"tree_edges s' = tree_edges s \\<or> (\\<exists>u. u \\<noteq> v \\<and> tree_edges s' = tree_edges s \\<union> {(u,v)})\""], ["proof (state)\nthis:\n  tree_edges s' = tree_edges s \\<or>\n  (\\<exists>u.\n      u \\<noteq> v \\<and> tree_edges s' = tree_edges s \\<union> {(u, v)})\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "assume \"Tarjan_invar G s\""], ["proof (state)\nthis:\n  Tarjan_invar G s\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "assume [simp]: \"discovered s' = (discovered s)(v \\<mapsto> counter s)\"\n                     \"finished s' = finished s\"\n                     \"lowlink s' = lowlink s\"\n                     \"cross_edges s' = cross_edges s\" \"back_edges s' = back_edges s\""], ["proof (state)\nthis:\n  discovered s' = discovered s(v \\<mapsto> counter s)\n  finished s' = finished s\n  lowlink s' = lowlink s\n  cross_edges s' = cross_edges s\n  back_edges s' = back_edges s\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "assume v_n_disc: \"v \\<notin> dom (discovered s)\""], ["proof (state)\nthis:\n  v \\<notin> dom (discovered s)\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "assume IH: \"\\<And>w. w\\<in>dom (discovered s) \\<Longrightarrow> \\<zeta> s w = LowLink s w\""], ["proof (state)\nthis:\n  ?w7 \\<in> dom (discovered s) \\<Longrightarrow>\n  \\<zeta> s ?w7 = Min (\\<delta> s ` lowlink_set s ?w7)\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "assume TRANS: \"\\<And>\\<Psi>. tarjan_disc v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow> \\<Psi> x\"\n      and INV: \"DFS_invar G tarjan_params ?s\"\n      and w_disc: \"w \\<in> dom (discovered ?s)\""], ["proof (state)\nthis:\n  tarjan_disc v s' \\<le>\\<^sub>n SPEC ?\\<Psi>7 \\<Longrightarrow> ?\\<Psi>7 x\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "interpret Tarjan_invar where s=s"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "from INV"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)", "interpret s':Tarjan_invar where s=\"?s\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (1 subgoal):\n 1. Tarjan_invar G (s'\\<lparr>state.more := x\\<rparr>)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "have [simp]: \"lowlink ?s = (lowlink s)(v \\<mapsto> counter s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s(v \\<mapsto>\n    counter s)", "by (rule TRANS) (auto simp: tarjan_disc_def)"], ["proof (state)\nthis:\n  lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s(v \\<mapsto>\n  counter s)\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "from v_n_disc edge_imp_discovered"], ["proof (chain)\npicking this:\n  v \\<notin> dom (discovered s)\n  (?v, ?w)\n  \\<in> tree_edges s \\<union> cross_edges s \\<union>\n        back_edges s \\<Longrightarrow>\n  ?v \\<in> dom (discovered s)\n  (?v, ?w)\n  \\<in> tree_edges s \\<union> cross_edges s \\<union>\n        back_edges s \\<Longrightarrow>\n  ?w \\<in> dom (discovered s)", "have \"edges s `` {v} = {}\""], ["proof (prove)\nusing this:\n  v \\<notin> dom (discovered s)\n  (?v, ?w)\n  \\<in> tree_edges s \\<union> cross_edges s \\<union>\n        back_edges s \\<Longrightarrow>\n  ?v \\<in> dom (discovered s)\n  (?v, ?w)\n  \\<in> tree_edges s \\<union> cross_edges s \\<union>\n        back_edges s \\<Longrightarrow>\n  ?w \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. (tree_edges s \\<union> cross_edges s \\<union> back_edges s) `` {v} = {}", "by auto"], ["proof (state)\nthis:\n  (tree_edges s \\<union> cross_edges s \\<union> back_edges s) `` {v} = {}\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "with tree_sub tree_edge_imp_discovered"], ["proof (chain)\npicking this:\n  tree_edges s' = tree_edges s \\<or>\n  (\\<exists>u.\n      u \\<noteq> v \\<and> tree_edges s' = tree_edges s \\<union> {(u, v)})\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  (tree_edges s \\<union> cross_edges s \\<union> back_edges s) `` {v} = {}", "have \"edges ?s `` {v} = {}\""], ["proof (prove)\nusing this:\n  tree_edges s' = tree_edges s \\<or>\n  (\\<exists>u.\n      u \\<noteq> v \\<and> tree_edges s' = tree_edges s \\<union> {(u, v)})\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  (tree_edges s \\<union> cross_edges s \\<union> back_edges s) `` {v} = {}\n\ngoal (1 subgoal):\n 1. (tree_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n     cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n     back_edges (s'\\<lparr>state.more := x\\<rparr>)) ``\n    {v} =\n    {}", "by auto"], ["proof (state)\nthis:\n  (tree_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n   cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n   back_edges (s'\\<lparr>state.more := x\\<rparr>)) ``\n  {v} =\n  {}\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "with s'.no_path_imp_no_lowlink_path"], ["proof (chain)\npicking this:\n  (tree_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n   cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n   back_edges (s'\\<lparr>state.more := x\\<rparr>)) ``\n  {?v} =\n  {} \\<Longrightarrow>\n  \\<not> lowlink_path (s'\\<lparr>state.more := x\\<rparr>) ?v ?p ?w\n  (tree_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n   cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n   back_edges (s'\\<lparr>state.more := x\\<rparr>)) ``\n  {v} =\n  {}", "have \"\\<And>w. \\<not>(\\<exists>p. lowlink_path ?s v p w)\""], ["proof (prove)\nusing this:\n  (tree_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n   cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n   back_edges (s'\\<lparr>state.more := x\\<rparr>)) ``\n  {?v} =\n  {} \\<Longrightarrow>\n  \\<not> lowlink_path (s'\\<lparr>state.more := x\\<rparr>) ?v ?p ?w\n  (tree_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n   cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n   back_edges (s'\\<lparr>state.more := x\\<rparr>)) ``\n  {v} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<nexists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) v p w", "by metis"], ["proof (state)\nthis:\n  \\<nexists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) v p ?w7\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "hence ll_v: \"lowlink_set ?s v = {v}\""], ["proof (prove)\nusing this:\n  \\<nexists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) v p ?w7\n\ngoal (1 subgoal):\n 1. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) v = {v}", "unfolding lowlink_set_def"], ["proof (prove)\nusing this:\n  \\<nexists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) v p ?w7\n\ngoal (1 subgoal):\n 1. {w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n     v = w \\<or>\n     (v, w) \\<in> E\\<^sup>+ \\<and>\n     (w, v) \\<in> E\\<^sup>+ \\<and>\n     (\\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) v p w)} =\n    {v}", "by auto"], ["proof (state)\nthis:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) v = {v}\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "have \"\\<zeta> ?s w = LowLink ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "proof (cases \"w=v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. w \\<noteq> v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "case True"], ["proof (state)\nthis:\n  w = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. w \\<noteq> v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "with ll_v"], ["proof (chain)\npicking this:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) v = {v}\n  w = v", "show ?thesis"], ["proof (prove)\nusing this:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) v = {v}\n  w = v\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "by simp"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "case False"], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "hence \"\\<zeta> ?s w = \\<zeta> s w\""], ["proof (prove)\nusing this:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "by simp"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "from IH"], ["proof (chain)\npicking this:\n  ?w7 \\<in> dom (discovered s) \\<Longrightarrow>\n  \\<zeta> s ?w7 = Min (\\<delta> s ` lowlink_set s ?w7)", "have \"\\<zeta> s w = LowLink s w\""], ["proof (prove)\nusing this:\n  ?w7 \\<in> dom (discovered s) \\<Longrightarrow>\n  \\<zeta> s ?w7 = Min (\\<delta> s ` lowlink_set s ?w7)\n\ngoal (1 subgoal):\n 1. \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)", "using w_disc False"], ["proof (prove)\nusing this:\n  ?w7 \\<in> dom (discovered s) \\<Longrightarrow>\n  \\<zeta> s ?w7 = Min (\\<delta> s ` lowlink_set s ?w7)\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)", "by simp"], ["proof (state)\nthis:\n  \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "have \"LowLink s w = LowLink ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w) =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "proof (rule LowLink_eqI[OF INV])"], ["proof (state)\ngoal (5 subgoals):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)\n 2. lowlink_set s w\n    \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 3. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> ?X\n 4. w \\<in> dom (discovered s)\n 5. \\<And>xa.\n       \\<lbrakk>xa \\<in> ?X;\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "from v_n_disc"], ["proof (chain)\npicking this:\n  v \\<notin> dom (discovered s)", "show \"discovered s \\<subseteq>\\<^sub>m discovered ?s\""], ["proof (prove)\nusing this:\n  v \\<notin> dom (discovered s)\n\ngoal (1 subgoal):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)", "by (simp add: map_le_def)"], ["proof (state)\nthis:\n  discovered s \\<subseteq>\\<^sub>m\n  discovered (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (4 subgoals):\n 1. lowlink_set s w\n    \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 2. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> ?X\n 3. w \\<in> dom (discovered s)\n 4. \\<And>xa.\n       \\<lbrakk>xa \\<in> ?X;\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "from tree_sub"], ["proof (chain)\npicking this:\n  tree_edges s' = tree_edges s \\<or>\n  (\\<exists>u.\n      u \\<noteq> v \\<and> tree_edges s' = tree_edges s \\<union> {(u, v)})", "show \"lowlink_set s w \\<subseteq> lowlink_set ?s w\""], ["proof (prove)\nusing this:\n  tree_edges s' = tree_edges s \\<or>\n  (\\<exists>u.\n      u \\<noteq> v \\<and> tree_edges s' = tree_edges s \\<union> {(u, v)})\n\ngoal (1 subgoal):\n 1. lowlink_set s w\n    \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "unfolding lowlink_set_def lowlink_path_def"], ["proof (prove)\nusing this:\n  tree_edges s' = tree_edges s \\<or>\n  (\\<exists>u.\n      u \\<noteq> v \\<and> tree_edges s' = tree_edges s \\<union> {(u, v)})\n\ngoal (1 subgoal):\n 1. {wa \\<in> dom (discovered s).\n     w = wa \\<or>\n     (w, wa) \\<in> E\\<^sup>+ \\<and>\n     (wa, w) \\<in> E\\<^sup>+ \\<and>\n     (\\<exists>p.\n         path E w p wa \\<and>\n         p \\<noteq> [] \\<and>\n         (last p, wa) \\<in> cross_edges s \\<union> back_edges s \\<and>\n         (1 < length p \\<longrightarrow>\n          p ! 1 \\<in> dom (finished s) \\<and>\n          (\\<forall>k<length p - 1.\n              (p ! k, p ! Suc k) \\<in> tree_edges s)))}\n    \\<subseteq> {wa \\<in> dom (discovered\n                                (s'\\<lparr>state.more := x\\<rparr>)).\n                 w = wa \\<or>\n                 (w, wa) \\<in> E\\<^sup>+ \\<and>\n                 (wa, w) \\<in> E\\<^sup>+ \\<and>\n                 (\\<exists>p.\n                     path E w p wa \\<and>\n                     p \\<noteq> [] \\<and>\n                     (last p, wa)\n                     \\<in> cross_edges\n                            (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n                           back_edges\n                            (s'\\<lparr>state.more := x\\<rparr>) \\<and>\n                     (1 < length p \\<longrightarrow>\n                      p ! 1\n                      \\<in> dom (finished\n                                  (s'\\<lparr>state.more :=\n         x\\<rparr>)) \\<and>\n                      (\\<forall>k<length p - 1.\n                          (p ! k, p ! Suc k)\n                          \\<in> tree_edges\n                                 (s'\\<lparr>state.more := x\\<rparr>))))}", "by auto"], ["proof (state)\nthis:\n  lowlink_set s w\n  \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (3 subgoals):\n 1. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> ?X\n 2. w \\<in> dom (discovered s)\n 3. \\<And>xa.\n       \\<lbrakk>xa \\<in> ?X;\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "show \"lowlink_set ?s w \\<subseteq> lowlink_set s w \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}", "proof (cases \"w = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow>\n    lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}\n 2. w \\<noteq> v \\<Longrightarrow>\n    lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}", "case True"], ["proof (state)\nthis:\n  w = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow>\n    lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}\n 2. w \\<noteq> v \\<Longrightarrow>\n    lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}", "with ll_v"], ["proof (chain)\npicking this:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) v = {v}\n  w = v", "show ?thesis"], ["proof (prove)\nusing this:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) v = {v}\n  w = v\n\ngoal (1 subgoal):\n 1. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}", "by auto"], ["proof (state)\nthis:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> lowlink_set s w \\<union> {v}\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}", "case False"], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}", "thus ?thesis"], ["proof (prove)\nusing this:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}", "using pre_ll_sub_rev w_disc INV"], ["proof (prove)\nusing this:\n  w \\<noteq> v\n  \\<lbrakk>Tarjan_invar G (s'\\<lparr>state.more := x\\<rparr>);\n   ?w7 \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>));\n   ?w7 \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) ?w7\n                    \\<subseteq> lowlink_set s ?w7 \\<union> {v}\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (1 subgoal):\n 1. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}", "by simp"], ["proof (state)\nthis:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> lowlink_set s w \\<union> {v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> lowlink_set s w \\<union> {v}\n\ngoal (2 subgoals):\n 1. w \\<in> dom (discovered s)\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> {v};\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "show \"w \\<in> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> dom (discovered s)", "using w_disc False"], ["proof (prove)\nusing this:\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<in> dom (discovered s)", "by simp"], ["proof (state)\nthis:\n  w \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> {v};\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "fix ll"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> {v};\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "assume \"ll \\<in> {v}\""], ["proof (state)\nthis:\n  ll \\<in> {v}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> {v};\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "with timing_less_counter lowlink_set_discovered"], ["proof (chain)\npicking this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  lowlink_set s ?v \\<subseteq> dom (discovered s)\n  ll \\<in> {v}", "have \n            \"\\<And>x. x\\<in>\\<delta> s`lowlink_set s w \\<Longrightarrow> x < \\<delta> ?s ll\""], ["proof (prove)\nusing this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> \\<delta> s ?v < counter s\n  ?v \\<in> dom (finished s) \\<Longrightarrow> \\<phi> s ?v < counter s\n  lowlink_set s ?v \\<subseteq> dom (discovered s)\n  ll \\<in> {v}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<delta> s ` lowlink_set s w \\<Longrightarrow>\n       xa < \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ll", "by simp force"], ["proof (state)\nthis:\n  ?x7 \\<in> \\<delta> s ` lowlink_set s w \\<Longrightarrow>\n  ?x7 < \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ll\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> {v};\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "moreover"], ["proof (state)\nthis:\n  ?x7 \\<in> \\<delta> s ` lowlink_set s w \\<Longrightarrow>\n  ?x7 < \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ll\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> {v};\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "from Min_in lowlink_set_finite lowlink_set_not_empty w_disc False"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min ?A \\<in> ?A\n  finite (lowlink_set s ?v)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> lowlink_set s ?v \\<noteq> {}\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  w \\<noteq> v", "have \n            \"LowLink s w \\<in> \\<delta> s`lowlink_set s w \""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min ?A \\<in> ?A\n  finite (lowlink_set s ?v)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> lowlink_set s ?v \\<noteq> {}\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w) \\<in> \\<delta> s ` lowlink_set s w", "by auto"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w) \\<in> \\<delta> s ` lowlink_set s w\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> {v};\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "ultimately"], ["proof (chain)\npicking this:\n  ?x7 \\<in> \\<delta> s ` lowlink_set s w \\<Longrightarrow>\n  ?x7 < \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ll\n  Min (\\<delta> s ` lowlink_set s w) \\<in> \\<delta> s ` lowlink_set s w", "show \"LowLink s w \\<le> \\<delta> ?s ll\""], ["proof (prove)\nusing this:\n  ?x7 \\<in> \\<delta> s ` lowlink_set s w \\<Longrightarrow>\n  ?x7 < \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ll\n  Min (\\<delta> s ` lowlink_set s w) \\<in> \\<delta> s ` lowlink_set s w\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ll", "by force"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w) =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "finally"], ["proof (chain)\npicking this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "."], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>w.\n              \\<lbrakk>Tarjan_invar G\n                        (?s'9\\<lparr>state.more := ?x9\\<rparr>);\n               w \\<in> dom (discovered\n                             (?s'9\\<lparr>state.more := ?x9\\<rparr>));\n               w \\<noteq> ?v9\\<rbrakk>\n              \\<Longrightarrow> lowlink_set\n                                 (?s'9\\<lparr>state.more := ?x9\\<rparr>) w\n                                \\<subseteq> lowlink_set ?s9 w \\<union>\n      {?v9};\n   tree_edges ?s'9 = tree_edges ?s9 \\<or>\n   (\\<exists>u.\n       u \\<noteq> ?v9 \\<and>\n       tree_edges ?s'9 = tree_edges ?s9 \\<union> {(u, ?v9)});\n   Tarjan_invar G ?s9;\n   discovered ?s'9 = discovered ?s9(?v9 \\<mapsto> counter ?s9);\n   finished ?s'9 = finished ?s9; lowlink ?s'9 = lowlink ?s9;\n   cross_edges ?s'9 = cross_edges ?s9; back_edges ?s'9 = back_edges ?s9;\n   ?v9 \\<notin> dom (discovered ?s9);\n   \\<And>w.\n      w \\<in> dom (discovered ?s9) \\<Longrightarrow>\n      \\<zeta> ?s9 w = Min (\\<delta> ?s9 ` lowlink_set ?s9 w);\n   \\<And>\\<Psi>.\n      tarjan_disc ?v9 ?s'9 \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n      \\<Psi> ?x9;\n   DFS_invar G tarjan_params (?s'9\\<lparr>state.more := ?x9\\<rparr>);\n   ?w9\n   \\<in> dom (discovered (?s'9\\<lparr>state.more := ?x9\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> (?s'9\\<lparr>state.more := ?x9\\<rparr>) ?w9 =\n                    Min (\\<delta> (?s'9\\<lparr>state.more := ?x9\\<rparr>) `\n                         lowlink_set (?s'9\\<lparr>state.more := ?x9\\<rparr>)\n                          ?w9)\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "note tarjan_disc_aux = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>w.\n              \\<lbrakk>Tarjan_invar G\n                        (?s'9\\<lparr>state.more := ?x9\\<rparr>);\n               w \\<in> dom (discovered\n                             (?s'9\\<lparr>state.more := ?x9\\<rparr>));\n               w \\<noteq> ?v9\\<rbrakk>\n              \\<Longrightarrow> lowlink_set\n                                 (?s'9\\<lparr>state.more := ?x9\\<rparr>) w\n                                \\<subseteq> lowlink_set ?s9 w \\<union>\n      {?v9};\n   tree_edges ?s'9 = tree_edges ?s9 \\<or>\n   (\\<exists>u.\n       u \\<noteq> ?v9 \\<and>\n       tree_edges ?s'9 = tree_edges ?s9 \\<union> {(u, ?v9)});\n   Tarjan_invar G ?s9;\n   discovered ?s'9 = discovered ?s9(?v9 \\<mapsto> counter ?s9);\n   finished ?s'9 = finished ?s9; lowlink ?s'9 = lowlink ?s9;\n   cross_edges ?s'9 = cross_edges ?s9; back_edges ?s'9 = back_edges ?s9;\n   ?v9 \\<notin> dom (discovered ?s9);\n   \\<And>w.\n      w \\<in> dom (discovered ?s9) \\<Longrightarrow>\n      \\<zeta> ?s9 w = Min (\\<delta> ?s9 ` lowlink_set ?s9 w);\n   \\<And>\\<Psi>.\n      tarjan_disc ?v9 ?s'9 \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n      \\<Psi> ?x9;\n   DFS_invar G tarjan_params (?s'9\\<lparr>state.more := ?x9\\<rparr>);\n   ?w9\n   \\<in> dom (discovered (?s'9\\<lparr>state.more := ?x9\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> (?s'9\\<lparr>state.more := ?x9\\<rparr>) ?w9 =\n                    Min (\\<delta> (?s'9\\<lparr>state.more := ?x9\\<rparr>) `\n                         lowlink_set (?s'9\\<lparr>state.more := ?x9\\<rparr>)\n                          ?w9)\n\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         \\<forall>x\\<in>dom (discovered s).\n            \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))", "proof (induct rule: establish_invarI_CB)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "case (new_root s s' v0)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s = []\n  v0 \\<in> V0\n  v0 \\<notin> dom (discovered s)\n  s' = new_root v0 s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "{"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s = []\n  v0 \\<in> V0\n  v0 \\<notin> dom (discovered s)\n  s' = new_root v0 s\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "fix w x"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "let ?s = \"new_root v0 s\\<lparr>state.more := x\\<rparr>\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have \"lowlink_set ?s w \\<subseteq> lowlink_set s w \\<union> {v0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowlink_set (new_root v0 s\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v0}", "unfolding lowlink_set_def lowlink_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {wa \\<in> dom (discovered\n                    (new_root v0 s\\<lparr>state.more := x\\<rparr>)).\n     w = wa \\<or>\n     (w, wa) \\<in> E\\<^sup>+ \\<and>\n     (wa, w) \\<in> E\\<^sup>+ \\<and>\n     (\\<exists>p.\n         path E w p wa \\<and>\n         p \\<noteq> [] \\<and>\n         (last p, wa)\n         \\<in> cross_edges\n                (new_root v0 s\\<lparr>state.more := x\\<rparr>) \\<union>\n               back_edges\n                (new_root v0 s\\<lparr>state.more := x\\<rparr>) \\<and>\n         (1 < length p \\<longrightarrow>\n          p ! 1\n          \\<in> dom (finished\n                      (new_root v0 s\\<lparr>state.more := x\\<rparr>)) \\<and>\n          (\\<forall>k<length p - 1.\n              (p ! k, p ! Suc k)\n              \\<in> tree_edges\n                     (new_root v0 s\\<lparr>state.more := x\\<rparr>))))}\n    \\<subseteq> {wa \\<in> dom (discovered s).\n                 w = wa \\<or>\n                 (w, wa) \\<in> E\\<^sup>+ \\<and>\n                 (wa, w) \\<in> E\\<^sup>+ \\<and>\n                 (\\<exists>p.\n                     path E w p wa \\<and>\n                     p \\<noteq> [] \\<and>\n                     (last p, wa)\n                     \\<in> cross_edges s \\<union> back_edges s \\<and>\n                     (1 < length p \\<longrightarrow>\n                      p ! 1 \\<in> dom (finished s) \\<and>\n                      (\\<forall>k<length p - 1.\n                          (p ! k, p ! Suc k) \\<in> tree_edges s)))} \\<union>\n                {v0}", "by auto"], ["proof (state)\nthis:\n  lowlink_set (new_root v0 s\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> lowlink_set s w \\<union> {v0}\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "}"], ["proof (state)\nthis:\n  lowlink_set (new_root v0 s\\<lparr>state.more := ?x9\\<rparr>) ?w9\n  \\<subseteq> lowlink_set s ?w9 \\<union> {v0}\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "note * = this"], ["proof (state)\nthis:\n  lowlink_set (new_root v0 s\\<lparr>state.more := ?x9\\<rparr>) ?w9\n  \\<subseteq> lowlink_set s ?w9 \\<union> {v0}\n\ngoal (6 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "from new_root"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s = []\n  v0 \\<in> V0\n  v0 \\<notin> dom (discovered s)\n  s' = new_root v0 s", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s = []\n  v0 \\<in> V0\n  v0 \\<notin> dom (discovered s)\n  s' = new_root v0 s\n\ngoal (1 subgoal):\n 1. on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         (\\<forall>xa\\<in>dom (discovered\n                                (s'\\<lparr>state.more := x\\<rparr>)).\n             \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) xa =\n             Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n                  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "using tarjan_disc_aux[OF *]"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s = []\n  v0 \\<in> V0\n  v0 \\<notin> dom (discovered s)\n  s' = new_root v0 s\n  \\<lbrakk>tree_edges (new_root v0 s) = tree_edges s \\<or>\n           (\\<exists>u.\n               u \\<noteq> v0 \\<and>\n               tree_edges (new_root v0 s) =\n               tree_edges s \\<union> {(u, v0)});\n   Tarjan_invar G s;\n   discovered (new_root v0 s) = discovered s(v0 \\<mapsto> counter s);\n   finished (new_root v0 s) = finished s;\n   lowlink (new_root v0 s) = lowlink s;\n   cross_edges (new_root v0 s) = cross_edges s;\n   back_edges (new_root v0 s) = back_edges s;\n   v0 \\<notin> dom (discovered s);\n   \\<And>w.\n      w \\<in> dom (discovered s) \\<Longrightarrow>\n      \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w);\n   \\<And>\\<Psi>.\n      tarjan_disc v0 (new_root v0 s) \\<le>\\<^sub>n\n      SPEC \\<Psi> \\<Longrightarrow>\n      \\<Psi> ?x9;\n   DFS_invar G tarjan_params\n    (new_root v0 s\\<lparr>state.more := ?x9\\<rparr>);\n   ?w9\n   \\<in> dom (discovered\n               (new_root v0 s\\<lparr>state.more := ?x9\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> (new_root v0 s\\<lparr>state.more := ?x9\\<rparr>)\n                     ?w9 =\n                    Min (\\<delta>\n                          (new_root v0 s\\<lparr>state.more := ?x9\\<rparr>) `\n                         lowlink_set\n                          (new_root v0 s\\<lparr>state.more := ?x9\\<rparr>)\n                          ?w9)\n\ngoal (1 subgoal):\n 1. on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         (\\<forall>xa\\<in>dom (discovered\n                                (s'\\<lparr>state.more := x\\<rparr>)).\n             \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) xa =\n             Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n                  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "by (auto simp add: pw_leof_iff)"], ["proof (state)\nthis:\n  on_new_root tarjan_params v0 s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       (\\<forall>xa\\<in>dom (discovered\n                              (s'\\<lparr>state.more := x\\<rparr>)).\n           \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) xa =\n           Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n                lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "case (discover s s' u v)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "let ?s' = \"discover (hd (stack s)) v (s\\<lparr>pending := pending s - {(hd (stack s),v)}\\<rparr>)\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "{"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "fix w x"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "let ?s = \"?s'\\<lparr>state.more := x\\<rparr>\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "assume INV: \"Tarjan_invar G ?s\"\n          and d: \"w \\<in> dom (discovered ?s')\"\n          and \"w\\<noteq>v\""], ["proof (state)\nthis:\n  Tarjan_invar G\n   (discover (hd (stack s)) v\n     (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n    \\<lparr>state.more := x\\<rparr>)\n  w \\<in> dom (discovered\n                (discover (hd (stack s)) v\n                  (s\\<lparr>pending :=\n                              pending s - {(hd (stack s), v)}\\<rparr>)))\n  w \\<noteq> v\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "interpret s': Tarjan_invar where s=\"?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Tarjan_invar G\n     (discover (hd (stack s)) v\n       (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n      \\<lparr>state.more := x\\<rparr>)", "by fact"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have \"lowlink_set ?s w \\<subseteq> lowlink_set s w \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowlink_set\n     (discover (hd (stack s)) v\n       (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n      \\<lparr>state.more := x\\<rparr>)\n     w\n    \\<subseteq> lowlink_set s w \\<union> {v}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> lowlink_set\n                 (discover (hd (stack s)) v\n                   (s\\<lparr>pending :=\n                               pending s - {(hd (stack s), v)}\\<rparr>)\n                  \\<lparr>state.more := x\\<rparr>)\n                 w \\<Longrightarrow>\n       xa \\<in> lowlink_set s w \\<union> {v}", "fix ll"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> lowlink_set\n                 (discover (hd (stack s)) v\n                   (s\\<lparr>pending :=\n                               pending s - {(hd (stack s), v)}\\<rparr>)\n                  \\<lparr>state.more := x\\<rparr>)\n                 w \\<Longrightarrow>\n       xa \\<in> lowlink_set s w \\<union> {v}", "assume ll: \"ll \\<in> lowlink_set ?s w\""], ["proof (state)\nthis:\n  ll \\<in> lowlink_set\n            (discover (hd (stack s)) v\n              (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n             \\<lparr>state.more := x\\<rparr>)\n            w\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> lowlink_set\n                 (discover (hd (stack s)) v\n                   (s\\<lparr>pending :=\n                               pending s - {(hd (stack s), v)}\\<rparr>)\n                  \\<lparr>state.more := x\\<rparr>)\n                 w \\<Longrightarrow>\n       xa \\<in> lowlink_set s w \\<union> {v}", "hence \"ll = w \\<or> (\\<exists>p. lowlink_path ?s w p ll)\""], ["proof (prove)\nusing this:\n  ll \\<in> lowlink_set\n            (discover (hd (stack s)) v\n              (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n             \\<lparr>state.more := x\\<rparr>)\n            w\n\ngoal (1 subgoal):\n 1. ll = w \\<or>\n    (\\<exists>p.\n        lowlink_path\n         (discover (hd (stack s)) v\n           (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n          \\<lparr>state.more := x\\<rparr>)\n         w p ll)", "by (auto simp add: lowlink_set_def)"], ["proof (state)\nthis:\n  ll = w \\<or>\n  (\\<exists>p.\n      lowlink_path\n       (discover (hd (stack s)) v\n         (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n        \\<lparr>state.more := x\\<rparr>)\n       w p ll)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> lowlink_set\n                 (discover (hd (stack s)) v\n                   (s\\<lparr>pending :=\n                               pending s - {(hd (stack s), v)}\\<rparr>)\n                  \\<lparr>state.more := x\\<rparr>)\n                 w \\<Longrightarrow>\n       xa \\<in> lowlink_set s w \\<union> {v}", "thus \"ll \\<in> lowlink_set s w \\<union> {v}\" (is \"ll \\<in> ?L\")"], ["proof (prove)\nusing this:\n  ll = w \\<or>\n  (\\<exists>p.\n      lowlink_path\n       (discover (hd (stack s)) v\n         (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n        \\<lparr>state.more := x\\<rparr>)\n       w p ll)\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s w \\<union> {v}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ll = w \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}\n 2. \\<exists>p.\n       lowlink_path\n        (discover (hd (stack s)) v\n          (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n         \\<lparr>state.more := x\\<rparr>)\n        w p ll \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> {v}", "assume \"ll = w\""], ["proof (state)\nthis:\n  ll = w\n\ngoal (2 subgoals):\n 1. ll = w \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}\n 2. \\<exists>p.\n       lowlink_path\n        (discover (hd (stack s)) v\n          (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n         \\<lparr>state.more := x\\<rparr>)\n        w p ll \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> {v}", "with d"], ["proof (chain)\npicking this:\n  w \\<in> dom (discovered\n                (discover (hd (stack s)) v\n                  (s\\<lparr>pending :=\n                              pending s - {(hd (stack s), v)}\\<rparr>)))\n  ll = w", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> dom (discovered\n                (discover (hd (stack s)) v\n                  (s\\<lparr>pending :=\n                              pending s - {(hd (stack s), v)}\\<rparr>)))\n  ll = w\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s w \\<union> {v}", "by (auto simp add: lowlink_set_def)"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s w \\<union> {v}\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       lowlink_path\n        (discover (hd (stack s)) v\n          (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n         \\<lparr>state.more := x\\<rparr>)\n        w p ll \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> {v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       lowlink_path\n        (discover (hd (stack s)) v\n          (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n         \\<lparr>state.more := x\\<rparr>)\n        w p ll \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> {v}", "assume \"\\<exists>p. lowlink_path ?s w p ll\""], ["proof (state)\nthis:\n  \\<exists>p.\n     lowlink_path\n      (discover (hd (stack s)) v\n        (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n       \\<lparr>state.more := x\\<rparr>)\n      w p ll\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       lowlink_path\n        (discover (hd (stack s)) v\n          (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n         \\<lparr>state.more := x\\<rparr>)\n        w p ll \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> {v}", "then"], ["proof (chain)\npicking this:\n  \\<exists>p.\n     lowlink_path\n      (discover (hd (stack s)) v\n        (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n       \\<lparr>state.more := x\\<rparr>)\n      w p ll", "guess p"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     lowlink_path\n      (discover (hd (stack s)) v\n        (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n       \\<lparr>state.more := x\\<rparr>)\n      w p ll\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  lowlink_path\n   (discover (hd (stack s)) v\n     (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n    \\<lparr>state.more := x\\<rparr>)\n   w p ll\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       lowlink_path\n        (discover (hd (stack s)) v\n          (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n         \\<lparr>state.more := x\\<rparr>)\n        w p ll \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> {v}", "note p = this"], ["proof (state)\nthis:\n  lowlink_path\n   (discover (hd (stack s)) v\n     (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n    \\<lparr>state.more := x\\<rparr>)\n   w p ll\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       lowlink_path\n        (discover (hd (stack s)) v\n          (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n         \\<lparr>state.more := x\\<rparr>)\n        w p ll \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> {v}", "hence [simp]: \"p\\<noteq>[]\""], ["proof (prove)\nusing this:\n  lowlink_path\n   (discover (hd (stack s)) v\n     (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n    \\<lparr>state.more := x\\<rparr>)\n   w p ll\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by (simp add: lowlink_path_def)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       lowlink_path\n        (discover (hd (stack s)) v\n          (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n         \\<lparr>state.more := x\\<rparr>)\n        w p ll \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> {v}", "from p"], ["proof (chain)\npicking this:\n  lowlink_path\n   (discover (hd (stack s)) v\n     (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n    \\<lparr>state.more := x\\<rparr>)\n   w p ll", "have \"hd p = w\""], ["proof (prove)\nusing this:\n  lowlink_path\n   (discover (hd (stack s)) v\n     (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n    \\<lparr>state.more := x\\<rparr>)\n   w p ll\n\ngoal (1 subgoal):\n 1. hd p = w", "by (auto simp add: lowlink_path_def path_hd)"], ["proof (state)\nthis:\n  hd p = w\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       lowlink_path\n        (discover (hd (stack s)) v\n          (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n         \\<lparr>state.more := x\\<rparr>)\n        w p ll \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> {v}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s w \\<union> {v}", "proof (rule tri_caseE)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> ?P; \\<not> ?Q\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}\n 2. ?P \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}\n 3. \\<lbrakk>\\<not> ?P; ?Q\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}", "assume \"v\\<noteq>ll\" \"v \\<notin> set p\""], ["proof (state)\nthis:\n  v \\<noteq> ll\n  v \\<notin> set p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> ?P; \\<not> ?Q\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}\n 2. ?P \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}\n 3. \\<lbrakk>\\<not> ?P; ?Q\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}", "hence \"lowlink_path s w p ll\""], ["proof (prove)\nusing this:\n  v \\<noteq> ll\n  v \\<notin> set p\n\ngoal (1 subgoal):\n 1. lowlink_path s w p ll", "using p"], ["proof (prove)\nusing this:\n  v \\<noteq> ll\n  v \\<notin> set p\n  lowlink_path\n   (discover (hd (stack s)) v\n     (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n    \\<lparr>state.more := x\\<rparr>)\n   w p ll\n\ngoal (1 subgoal):\n 1. lowlink_path s w p ll", "by (auto simp add: lowlink_path_def)"], ["proof (state)\nthis:\n  lowlink_path s w p ll\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> ?P; \\<not> ?Q\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}\n 2. ?P \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}\n 3. \\<lbrakk>\\<not> ?P; ?Q\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}", "with ll"], ["proof (chain)\npicking this:\n  ll \\<in> lowlink_set\n            (discover (hd (stack s)) v\n              (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n             \\<lparr>state.more := x\\<rparr>)\n            w\n  lowlink_path s w p ll", "show ?thesis"], ["proof (prove)\nusing this:\n  ll \\<in> lowlink_set\n            (discover (hd (stack s)) v\n              (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n             \\<lparr>state.more := x\\<rparr>)\n            w\n  lowlink_path s w p ll\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s w \\<union> {v}", "by (auto simp add: lowlink_set_def)"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s w \\<union> {v}\n\ngoal (2 subgoals):\n 1. v = ll \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}\n 2. \\<lbrakk>v \\<noteq> ll; v \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. v = ll \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}\n 2. \\<lbrakk>v \\<noteq> ll; v \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}", "assume \"v = ll\""], ["proof (state)\nthis:\n  v = ll\n\ngoal (2 subgoals):\n 1. v = ll \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}\n 2. \\<lbrakk>v \\<noteq> ll; v \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = ll\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s w \\<union> {v}", "by simp"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s w \\<union> {v}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> ll; v \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> ll; v \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}", "assume \"v \\<in> set p\" \"v \\<noteq> ll\""], ["proof (state)\nthis:\n  v \\<in> set p\n  v \\<noteq> ll\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> ll; v \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}", "then"], ["proof (chain)\npicking this:\n  v \\<in> set p\n  v \\<noteq> ll", "obtain i where i: \"i < length p\" \"p!i = v\""], ["proof (prove)\nusing this:\n  v \\<in> set p\n  v \\<noteq> ll\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length p; p ! i = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length p\n  p ! i = v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> ll; v \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}", "have \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "case \"0\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with i"], ["proof (chain)\npicking this:\n  i < length p\n  p ! i = v\n  i = 0", "have \"hd p = v\""], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = v\n  i = 0\n\ngoal (1 subgoal):\n 1. hd p = v", "by (simp add: hd_conv_nth)"], ["proof (state)\nthis:\n  hd p = v\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with \\<open>hd p = w\\<close> \\<open>w \\<noteq> v\\<close>"], ["proof (chain)\npicking this:\n  hd p = w\n  w \\<noteq> v\n  hd p = v", "show False"], ["proof (prove)\nusing this:\n  hd p = w\n  w \\<noteq> v\n  hd p = v\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "case (Suc n)"], ["proof (state)\nthis:\n  i = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with i s'.lowlink_path_finished[OF p, where j=i]"], ["proof (chain)\npicking this:\n  i < length p\n  p ! i = v\n  \\<lbrakk>i < length p; 0 < i\\<rbrakk>\n  \\<Longrightarrow> p ! i\n                    \\<in> dom (finished\n                                (discover (hd (stack s)) v\n                                  (s\\<lparr>pending :=\n        pending s - {(hd (stack s), v)}\\<rparr>)\n                                 \\<lparr>state.more := x\\<rparr>))\n  i = Suc n", "have \n                  \"v \\<in> dom (finished ?s)\""], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = v\n  \\<lbrakk>i < length p; 0 < i\\<rbrakk>\n  \\<Longrightarrow> p ! i\n                    \\<in> dom (finished\n                                (discover (hd (stack s)) v\n                                  (s\\<lparr>pending :=\n        pending s - {(hd (stack s), v)}\\<rparr>)\n                                 \\<lparr>state.more := x\\<rparr>))\n  i = Suc n\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished\n                  (discover (hd (stack s)) v\n                    (s\\<lparr>pending :=\n                                pending s - {(hd (stack s), v)}\\<rparr>)\n                   \\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  v \\<in> dom (finished\n                (discover (hd (stack s)) v\n                  (s\\<lparr>pending :=\n                              pending s - {(hd (stack s), v)}\\<rparr>)\n                 \\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with finished_discovered discover"], ["proof (chain)\npicking this:\n  dom (finished s) \\<subseteq> dom (discovered s)\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  v \\<in> dom (finished\n                (discover (hd (stack s)) v\n                  (s\\<lparr>pending :=\n                              pending s - {(hd (stack s), v)}\\<rparr>)\n                 \\<lparr>state.more := x\\<rparr>))", "show False"], ["proof (prove)\nusing this:\n  dom (finished s) \\<subseteq> dom (discovered s)\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  v \\<in> dom (finished\n                (discover (hd (stack s)) v\n                  (s\\<lparr>pending :=\n                              pending s - {(hd (stack s), v)}\\<rparr>)\n                 \\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> ll; v \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> {v}", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s w \\<union> {v}", ".."], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s w \\<union> {v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s w \\<union> {v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s w \\<union> {v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lowlink_set\n   (discover (hd (stack s)) v\n     (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n    \\<lparr>state.more := x\\<rparr>)\n   w\n  \\<subseteq> lowlink_set s w \\<union> {v}\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Tarjan_invar G\n            (discover (hd (stack s)) v\n              (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n             \\<lparr>state.more := ?x9\\<rparr>);\n   ?w9\n   \\<in> dom (discovered\n               (discover (hd (stack s)) v\n                 (s\\<lparr>pending :=\n                             pending s - {(hd (stack s), v)}\\<rparr>)));\n   ?w9 \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> lowlink_set\n                     (discover (hd (stack s)) v\n                       (s\\<lparr>pending :=\n                                   pending s - {(hd (stack s), v)}\\<rparr>)\n                      \\<lparr>state.more := ?x9\\<rparr>)\n                     ?w9\n                    \\<subseteq> lowlink_set s ?w9 \\<union> {v}\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>Tarjan_invar G\n            (discover (hd (stack s)) v\n              (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n             \\<lparr>state.more := ?x9\\<rparr>);\n   ?w9\n   \\<in> dom (discovered\n               (discover (hd (stack s)) v\n                 (s\\<lparr>pending :=\n                             pending s - {(hd (stack s), v)}\\<rparr>)));\n   ?w9 \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> lowlink_set\n                     (discover (hd (stack s)) v\n                       (s\\<lparr>pending :=\n                                   pending s - {(hd (stack s), v)}\\<rparr>)\n                      \\<lparr>state.more := ?x9\\<rparr>)\n                     ?w9\n                    \\<subseteq> lowlink_set s ?w9 \\<union> {v}\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "from discover hd_in_set stack_set_def"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  set (stack s) = dom (discovered s) - dom (finished s)", "have \"v \\<noteq> u\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  set (stack s) = dom (discovered s) - dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<noteq> u", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> u\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "with discover"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  v \\<noteq> u", "have **: \"tree_edges ?s' = tree_edges s \\<or> (\\<exists>u. u \\<noteq> v \\<and> tree_edges ?s' = tree_edges s \\<union> {(u,v)})\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  v \\<noteq> u\n\ngoal (1 subgoal):\n 1. tree_edges\n     (discover (hd (stack s)) v\n       (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)) =\n    tree_edges s \\<or>\n    (\\<exists>u.\n        u \\<noteq> v \\<and>\n        tree_edges\n         (discover (hd (stack s)) v\n           (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)) =\n        tree_edges s \\<union> {(u, v)})", "by auto"], ["proof (state)\nthis:\n  tree_edges\n   (discover (hd (stack s)) v\n     (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)) =\n  tree_edges s \\<or>\n  (\\<exists>u.\n      u \\<noteq> v \\<and>\n      tree_edges\n       (discover (hd (stack s)) v\n         (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)) =\n      tree_edges s \\<union> {(u, v)})\n\ngoal (5 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "from discover"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. on_discover tarjan_params u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         (\\<forall>xa\\<in>dom (discovered\n                                (s'\\<lparr>state.more := x\\<rparr>)).\n             \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) xa =\n             Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n                  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "using tarjan_disc_aux[OF * **]"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lbrakk>\\<And>w.\n              \\<lbrakk>Tarjan_invar G\n                        (discover (hd (stack s)) v\n                          (s\\<lparr>pending :=\npending s - {(hd (stack s), v)}\\<rparr>)\n                         \\<lparr>state.more := ?x9\\<rparr>);\n               w \\<in> dom (discovered\n                             (discover (hd (stack s)) v\n                               (s\\<lparr>pending :=\n     pending s - {(hd (stack s), v)}\\<rparr>)\n                              \\<lparr>state.more := ?x9\\<rparr>));\n               w \\<noteq> v\\<rbrakk>\n              \\<Longrightarrow> Tarjan_invar G\n                                 (discover (hd (stack s)) v\n                                   (s\\<lparr>pending :=\n         pending s - {(hd (stack s), v)}\\<rparr>)\n                                  \\<lparr>state.more := ?x9\\<rparr>);\n   \\<And>w.\n      \\<lbrakk>Tarjan_invar G\n                (discover (hd (stack s)) v\n                  (s\\<lparr>pending :=\n                              pending s - {(hd (stack s), v)}\\<rparr>)\n                 \\<lparr>state.more := ?x9\\<rparr>);\n       w \\<in> dom (discovered\n                     (discover (hd (stack s)) v\n                       (s\\<lparr>pending :=\n                                   pending s - {(hd (stack s), v)}\\<rparr>)\n                      \\<lparr>state.more := ?x9\\<rparr>));\n       w \\<noteq> v\\<rbrakk>\n      \\<Longrightarrow> w \\<in> dom (discovered\n(discover (hd (stack s)) v\n  (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)));\n   \\<And>w.\n      \\<lbrakk>Tarjan_invar G\n                (discover (hd (stack s)) v\n                  (s\\<lparr>pending :=\n                              pending s - {(hd (stack s), v)}\\<rparr>)\n                 \\<lparr>state.more := ?x9\\<rparr>);\n       w \\<in> dom (discovered\n                     (discover (hd (stack s)) v\n                       (s\\<lparr>pending :=\n                                   pending s - {(hd (stack s), v)}\\<rparr>)\n                      \\<lparr>state.more := ?x9\\<rparr>));\n       w \\<noteq> v\\<rbrakk>\n      \\<Longrightarrow> w \\<noteq> v;\n   Tarjan_invar G s;\n   discovered\n    (discover (hd (stack s)) v\n      (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)) =\n   discovered s(v \\<mapsto> counter s);\n   finished\n    (discover (hd (stack s)) v\n      (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)) =\n   finished s;\n   lowlink\n    (discover (hd (stack s)) v\n      (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)) =\n   lowlink s;\n   cross_edges\n    (discover (hd (stack s)) v\n      (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)) =\n   cross_edges s;\n   back_edges\n    (discover (hd (stack s)) v\n      (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)) =\n   back_edges s;\n   v \\<notin> dom (discovered s);\n   \\<And>w.\n      w \\<in> dom (discovered s) \\<Longrightarrow>\n      \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w);\n   \\<And>\\<Psi>.\n      tarjan_disc v\n       (discover (hd (stack s)) v\n         (s\\<lparr>pending :=\n                     pending s - {(hd (stack s), v)}\\<rparr>)) \\<le>\\<^sub>n\n      SPEC \\<Psi> \\<Longrightarrow>\n      \\<Psi> ?x9;\n   DFS_invar G tarjan_params\n    (discover (hd (stack s)) v\n      (s\\<lparr>pending := pending s - {(hd (stack s), v)}\\<rparr>)\n     \\<lparr>state.more := ?x9\\<rparr>);\n   ?w9\n   \\<in> dom (discovered\n               (discover (hd (stack s)) v\n                 (s\\<lparr>pending :=\n                             pending s - {(hd (stack s), v)}\\<rparr>)\n                \\<lparr>state.more := ?x9\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<zeta>\n                     (discover (hd (stack s)) v\n                       (s\\<lparr>pending :=\n                                   pending s - {(hd (stack s), v)}\\<rparr>)\n                      \\<lparr>state.more := ?x9\\<rparr>)\n                     ?w9 =\n                    Min (\\<delta>\n                          (discover (hd (stack s)) v\n                            (s\\<lparr>pending :=\n  pending s - {(hd (stack s), v)}\\<rparr>)\n                           \\<lparr>state.more := ?x9\\<rparr>) `\n                         lowlink_set\n                          (discover (hd (stack s)) v\n                            (s\\<lparr>pending :=\n  pending s - {(hd (stack s), v)}\\<rparr>)\n                           \\<lparr>state.more := ?x9\\<rparr>)\n                          ?w9)\n\ngoal (1 subgoal):\n 1. on_discover tarjan_params u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         (\\<forall>xa\\<in>dom (discovered\n                                (s'\\<lparr>state.more := x\\<rparr>)).\n             \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) xa =\n             Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n                  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "by (auto simp: pw_leof_iff)"], ["proof (state)\nthis:\n  on_discover tarjan_params u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       (\\<forall>xa\\<in>dom (discovered\n                              (s'\\<lparr>state.more := x\\<rparr>)).\n           \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) xa =\n           Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n                lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "case (cross_back_edge s s' u v)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "from cross_back_edge"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s", "have [simp]:\n        \"discovered s' = discovered s\"\n        \"finished s' = finished s\"\n        \"tree_edges s' = tree_edges s\"\n        \"lowlink s' = lowlink s\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n\ngoal (1 subgoal):\n 1. (discovered s' = discovered s &&& finished s' = finished s) &&&\n    tree_edges s' = tree_edges s &&& lowlink s' = lowlink s", "by simp_all"], ["proof (state)\nthis:\n  discovered s' = discovered s\n  finished s' = finished s\n  tree_edges s' = tree_edges s\n  lowlink s' = lowlink s\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "{"], ["proof (state)\nthis:\n  discovered s' = discovered s\n  finished s' = finished s\n  tree_edges s' = tree_edges s\n  lowlink s' = lowlink s\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "fix w :: \"'v\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "let ?s = \"s'\\<lparr>state.more := x\\<rparr>\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "let ?L = \"\\<delta> s ` lowlink_set s w\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "let ?L' = \"\\<delta> ?s ` lowlink_set ?s w\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "assume TRANS: \"\\<And>\\<Psi>. tarjan_back u v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow> \\<Psi> x\"\n          and inv': \"DFS_invar G tarjan_params ?s\"\n          and w_disc': \"w \\<in> dom (discovered ?s)\""], ["proof (state)\nthis:\n  tarjan_back u v s' \\<le>\\<^sub>n SPEC ?\\<Psi>7 \\<Longrightarrow>\n  ?\\<Psi>7 x\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "from inv'"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)", "interpret s':Tarjan_invar where s=\"?s\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (1 subgoal):\n 1. Tarjan_invar G (s'\\<lparr>state.more := x\\<rparr>)", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have ll_sub: \"lowlink_set s w \\<subseteq> lowlink_set ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowlink_set s w\n    \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "unfolding lowlink_set_def lowlink_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {wa \\<in> dom (discovered s).\n     w = wa \\<or>\n     (w, wa) \\<in> E\\<^sup>+ \\<and>\n     (wa, w) \\<in> E\\<^sup>+ \\<and>\n     (\\<exists>p.\n         path E w p wa \\<and>\n         p \\<noteq> [] \\<and>\n         (last p, wa) \\<in> cross_edges s \\<union> back_edges s \\<and>\n         (1 < length p \\<longrightarrow>\n          p ! 1 \\<in> dom (finished s) \\<and>\n          (\\<forall>k<length p - 1.\n              (p ! k, p ! Suc k) \\<in> tree_edges s)))}\n    \\<subseteq> {wa \\<in> dom (discovered\n                                (s'\\<lparr>state.more := x\\<rparr>)).\n                 w = wa \\<or>\n                 (w, wa) \\<in> E\\<^sup>+ \\<and>\n                 (wa, w) \\<in> E\\<^sup>+ \\<and>\n                 (\\<exists>p.\n                     path E w p wa \\<and>\n                     p \\<noteq> [] \\<and>\n                     (last p, wa)\n                     \\<in> cross_edges\n                            (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n                           back_edges\n                            (s'\\<lparr>state.more := x\\<rparr>) \\<and>\n                     (1 < length p \\<longrightarrow>\n                      p ! 1\n                      \\<in> dom (finished\n                                  (s'\\<lparr>state.more :=\n         x\\<rparr>)) \\<and>\n                      (\\<forall>k<length p - 1.\n                          (p ! k, p ! Suc k)\n                          \\<in> tree_edges\n                                 (s'\\<lparr>state.more := x\\<rparr>))))}", "by (auto simp: cross_back_edge)"], ["proof (state)\nthis:\n  lowlink_set s w\n  \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have ll_sub_rev: \"lowlink_set ?s w \\<subseteq> lowlink_set s w \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> {v}", "unfolding lowlink_set_def lowlink_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {wa \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n     w = wa \\<or>\n     (w, wa) \\<in> E\\<^sup>+ \\<and>\n     (wa, w) \\<in> E\\<^sup>+ \\<and>\n     (\\<exists>p.\n         path E w p wa \\<and>\n         p \\<noteq> [] \\<and>\n         (last p, wa)\n         \\<in> cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n               back_edges (s'\\<lparr>state.more := x\\<rparr>) \\<and>\n         (1 < length p \\<longrightarrow>\n          p ! 1\n          \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n          (\\<forall>k<length p - 1.\n              (p ! k, p ! Suc k)\n              \\<in> tree_edges (s'\\<lparr>state.more := x\\<rparr>))))}\n    \\<subseteq> {wa \\<in> dom (discovered s).\n                 w = wa \\<or>\n                 (w, wa) \\<in> E\\<^sup>+ \\<and>\n                 (wa, w) \\<in> E\\<^sup>+ \\<and>\n                 (\\<exists>p.\n                     path E w p wa \\<and>\n                     p \\<noteq> [] \\<and>\n                     (last p, wa)\n                     \\<in> cross_edges s \\<union> back_edges s \\<and>\n                     (1 < length p \\<longrightarrow>\n                      p ! 1 \\<in> dom (finished s) \\<and>\n                      (\\<forall>k<length p - 1.\n                          (p ! k, p ! Suc k) \\<in> tree_edges s)))} \\<union>\n                {v}", "by (auto simp: cross_back_edge)"], ["proof (state)\nthis:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> lowlink_set s w \\<union> {v}\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "from w_disc'"], ["proof (chain)\npicking this:\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))", "have w_disc: \"w \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. w \\<in> dom (discovered s)", "by simp"], ["proof (state)\nthis:\n  w \\<in> dom (discovered s)\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "with LowLink_le_disc"], ["proof (chain)\npicking this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow>\n  Min (\\<delta> s ` lowlink_set s ?v) \\<le> \\<delta> s ?v\n  w \\<in> dom (discovered s)", "have LLw: \"LowLink s w \\<le> \\<delta> s w\""], ["proof (prove)\nusing this:\n  ?v \\<in> dom (discovered s) \\<Longrightarrow>\n  Min (\\<delta> s ` lowlink_set s ?v) \\<le> \\<delta> s ?v\n  w \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "from cross_back_edge hd_in_set"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs", "have u_n_fin: \"u \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s)", "using stack_not_finished"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  u \\<notin> dom (finished s)\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "{"], ["proof (state)\nthis:\n  u \\<notin> dom (finished s)\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "assume *: \"v \\<in> lowlink_set ?s w \\<Longrightarrow> LowLink s w \\<le> \\<delta> ?s v\""], ["proof (state)\nthis:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n           w \\<Longrightarrow>\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have \"LowLink s w = LowLink ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w) =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "proof (rule LowLink_eqI[OF inv' _ ll_sub ll_sub_rev w_disc])"], ["proof (state)\ngoal (2 subgoals):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> {v};\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "show \"discovered s \\<subseteq>\\<^sub>m discovered ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  discovered s \\<subseteq>\\<^sub>m\n  discovered (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> {v};\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "fix ll"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> {v};\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "assume \"ll \\<in> {v}\" \"ll \\<in> lowlink_set ?s w\""], ["proof (state)\nthis:\n  ll \\<in> {v}\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> {v};\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "with *"], ["proof (chain)\npicking this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n           w \\<Longrightarrow>\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n  ll \\<in> {v}\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "show \"LowLink s w \\<le> \\<delta> ?s ll\""], ["proof (prove)\nusing this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n           w \\<Longrightarrow>\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n  ll \\<in> {v}\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ll", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w) =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "}"], ["proof (state)\nthis:\n  (v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n            w \\<Longrightarrow>\n   Min (\\<delta> s ` lowlink_set s w)\n   \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v) \\<Longrightarrow>\n  Min (\\<delta> s ` lowlink_set s w) =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "note LL_eqI = this"], ["proof (state)\nthis:\n  (v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n            w \\<Longrightarrow>\n   Min (\\<delta> s ` lowlink_set s w)\n   \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v) \\<Longrightarrow>\n  Min (\\<delta> s ` lowlink_set s w) =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have \"\\<zeta> ?s w = LowLink ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "proof (cases \"w=u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. w \\<noteq> u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "case True"], ["proof (state)\nthis:\n  w = u\n\ngoal (2 subgoals):\n 1. w = u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. w \\<noteq> u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "proof (cases \"(\\<delta> s v < \\<delta> s w \\<and> v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n            v \\<in> set (tj_stack s) \\<and>\n            \\<delta> s v < \\<zeta> s w) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n          v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w)\n\ngoal (2 subgoals):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n            v \\<in> set (tj_stack s) \\<and>\n            \\<delta> s v < \\<zeta> s w) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "note all_False = this"], ["proof (state)\nthis:\n  \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n          v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w)\n\ngoal (2 subgoals):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n            v \\<in> set (tj_stack s) \\<and>\n            \\<delta> s v < \\<zeta> s w) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "with \\<open>w = u\\<close>"], ["proof (chain)\npicking this:\n  w = u\n  \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n          v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w)", "have \"\\<zeta> ?s w = \\<zeta> s w\""], ["proof (prove)\nusing this:\n  w = u\n  \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n          v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w)\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "by (rule_tac TRANS) (auto simp add: tarjan_back_def cross_back_edge)"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n\ngoal (2 subgoals):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n            v \\<in> set (tj_stack s) \\<and>\n            \\<delta> s v < \\<zeta> s w) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n\ngoal (2 subgoals):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n            v \\<in> set (tj_stack s) \\<and>\n            \\<delta> s v < \\<zeta> s w) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "from cross_back_edge w_disc"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  w \\<in> dom (discovered s)", "have \\<zeta>w: \"... = LowLink s w\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  w \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)", "by simp"], ["proof (state)\nthis:\n  \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)\n\ngoal (2 subgoals):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n            v \\<in> set (tj_stack s) \\<and>\n            \\<delta> s v < \\<zeta> s w) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)\n\ngoal (2 subgoals):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n            v \\<in> set (tj_stack s) \\<and>\n            \\<delta> s v < \\<zeta> s w) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "have \"LowLink s w = LowLink ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w) =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "proof (rule LL_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n             w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "assume v: \"v \\<in> lowlink_set ?s w\""], ["proof (state)\nthis:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n             w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "show \"LowLink s w \\<le> \\<delta> ?s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "proof (cases \"\\<delta> s v < \\<delta> s w \\<and> \\<delta> s v < \\<zeta> s w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n 2. \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n            \\<delta> s v < \\<zeta> s w) \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<delta> s v < \\<delta> s w \\<and> \\<delta> s v < \\<zeta> s w)\n\ngoal (2 subgoals):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n 2. \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n            \\<delta> s v < \\<zeta> s w) \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "with \\<open>LowLink s w \\<le> \\<delta> s w\\<close> \\<zeta>w"], ["proof (chain)\npicking this:\n  Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w\n  \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)\n  \\<not> (\\<delta> s v < \\<delta> s w \\<and> \\<delta> s v < \\<zeta> s w)", "show ?thesis"], ["proof (prove)\nusing this:\n  Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w\n  \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)\n  \\<not> (\\<delta> s v < \\<delta> s w \\<and> \\<delta> s v < \\<zeta> s w)\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "by auto"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "case True"], ["proof (state)\nthis:\n  \\<delta> s v < \\<delta> s w \\<and> \\<delta> s v < \\<zeta> s w\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "with all_False"], ["proof (chain)\npicking this:\n  \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n          v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w)\n  \\<delta> s v < \\<delta> s w \\<and> \\<delta> s v < \\<zeta> s w", "have v_n_tj: \"v \\<notin> set (tj_stack s)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n          v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w)\n  \\<delta> s v < \\<delta> s w \\<and> \\<delta> s v < \\<zeta> s w\n\ngoal (1 subgoal):\n 1. v \\<notin> set (tj_stack s)", "by simp"], ["proof (state)\nthis:\n  v \\<notin> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "from v"], ["proof (chain)\npicking this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "have e: \"(v,u) \\<in> E\\<^sup>*\" \"(u,v) \\<in> E\\<^sup>*\""], ["proof (prove)\nusing this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> E\\<^sup>* &&& (u, v) \\<in> E\\<^sup>*", "unfolding lowlink_set_def"], ["proof (prove)\nusing this:\n  v \\<in> {wa \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n           w = wa \\<or>\n           (w, wa) \\<in> E\\<^sup>+ \\<and>\n           (wa, w) \\<in> E\\<^sup>+ \\<and>\n           (\\<exists>p.\n               lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p wa)}\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> E\\<^sup>* &&& (u, v) \\<in> E\\<^sup>*", "by (auto simp add: \\<open>w=u\\<close>)"], ["proof (state)\nthis:\n  (v, u) \\<in> E\\<^sup>*\n  (u, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "from v_n_tj"], ["proof (chain)\npicking this:\n  v \\<notin> set (tj_stack s)", "have \"v \\<notin> set (stack s)\""], ["proof (prove)\nusing this:\n  v \\<notin> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (stack s)", "using stack_ss_tj_stack"], ["proof (prove)\nusing this:\n  v \\<notin> set (tj_stack s)\n  set (stack s) \\<subseteq> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (stack s)", "by auto"], ["proof (state)\nthis:\n  v \\<notin> set (stack s)\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "with cross_back_edge"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  v \\<notin> set (stack s)", "have \"v \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  v \\<notin> set (stack s)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s)", "by (auto simp add: stack_set_def)"], ["proof (state)\nthis:\n  v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "with finished_ss_sccs_tj_stack v_n_tj sccs_are_sccs"], ["proof (chain)\npicking this:\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  v \\<notin> set (tj_stack s)\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  v \\<in> dom (finished s)", "obtain scc \n                  where scc: \"v \\<in> scc\" \"scc \\<in> sccs s\" \"is_scc E scc\""], ["proof (prove)\nusing this:\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  v \\<notin> set (tj_stack s)\n  \\<forall>scc\\<in>sccs s. is_scc E scc\n  v \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. (\\<And>scc.\n        \\<lbrakk>v \\<in> scc; scc \\<in> sccs s; is_scc E scc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> scc\n  scc \\<in> sccs s\n  is_scc E scc\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "with is_scc_closed e"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_scc ?E ?U; ?x \\<in> ?U; (?x, ?y) \\<in> ?E\\<^sup>*;\n   (?y, ?x) \\<in> ?E\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> ?U\n  (v, u) \\<in> E\\<^sup>*\n  (u, v) \\<in> E\\<^sup>*\n  v \\<in> scc\n  scc \\<in> sccs s\n  is_scc E scc", "have \"u \\<in> scc\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_scc ?E ?U; ?x \\<in> ?U; (?x, ?y) \\<in> ?E\\<^sup>*;\n   (?y, ?x) \\<in> ?E\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> ?U\n  (v, u) \\<in> E\\<^sup>*\n  (u, v) \\<in> E\\<^sup>*\n  v \\<in> scc\n  scc \\<in> sccs s\n  is_scc E scc\n\ngoal (1 subgoal):\n 1. u \\<in> scc", "by metis"], ["proof (state)\nthis:\n  u \\<in> scc\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "with scc sccs_finished u_n_fin"], ["proof (chain)\npicking this:\n  v \\<in> scc\n  scc \\<in> sccs s\n  is_scc E scc\n  \\<Union> (sccs s) \\<subseteq> dom (finished s)\n  u \\<notin> dom (finished s)\n  u \\<in> scc", "have False"], ["proof (prove)\nusing this:\n  v \\<in> scc\n  scc \\<in> sccs s\n  is_scc E scc\n  \\<Union> (sccs s) \\<subseteq> dom (finished s)\n  u \\<notin> dom (finished s)\n  u \\<in> scc\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", ".."], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w) =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (2 subgoals):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (\\<delta> s v < \\<delta> s w \\<and>\n            v \\<in> set (tj_stack s) \\<and>\n            \\<delta> s v < \\<zeta> s w) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "finally"], ["proof (chain)\npicking this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "."], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "case True"], ["proof (state)\nthis:\n  \\<delta> s v < \\<delta> s w \\<and>\n  v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "note all_True = this"], ["proof (state)\nthis:\n  \\<delta> s v < \\<delta> s w \\<and>\n  v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "with \\<open>w=u\\<close>"], ["proof (chain)\npicking this:\n  w = u\n  \\<delta> s v < \\<delta> s w \\<and>\n  v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w", "have \"\\<zeta> ?s w = \\<delta> s v\""], ["proof (prove)\nusing this:\n  w = u\n  \\<delta> s v < \\<delta> s w \\<and>\n  v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<delta> s v", "by (rule_tac TRANS) (simp add: tarjan_back_def cross_back_edge)"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<delta> s v\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<delta> s v\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "from True cross_back_edge w_disc"], ["proof (chain)\npicking this:\n  \\<delta> s v < \\<delta> s w \\<and>\n  v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  w \\<in> dom (discovered s)", "have \"\\<delta> s v < LowLink s w\""], ["proof (prove)\nusing this:\n  \\<delta> s v < \\<delta> s w \\<and>\n  v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  w \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<delta> s v < Min (\\<delta> s ` lowlink_set s w)", "by simp"], ["proof (state)\nthis:\n  \\<delta> s v < Min (\\<delta> s ` lowlink_set s w)\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "with lowlink_set_finite lowlink_set_not_empty w_disc"], ["proof (chain)\npicking this:\n  finite (lowlink_set s ?v)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> lowlink_set s ?v \\<noteq> {}\n  w \\<in> dom (discovered s)\n  \\<delta> s v < Min (\\<delta> s ` lowlink_set s w)", "have \"\\<delta> s v = Min (?L \\<union> {\\<delta> s v})\""], ["proof (prove)\nusing this:\n  finite (lowlink_set s ?v)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> lowlink_set s ?v \\<noteq> {}\n  w \\<in> dom (discovered s)\n  \\<delta> s v < Min (\\<delta> s ` lowlink_set s w)\n\ngoal (1 subgoal):\n 1. \\<delta> s v =\n    Min (\\<delta> s ` lowlink_set s w \\<union> {\\<delta> s v})", "by simp"], ["proof (state)\nthis:\n  \\<delta> s v = Min (\\<delta> s ` lowlink_set s w \\<union> {\\<delta> s v})\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  \\<delta> s v = Min (\\<delta> s ` lowlink_set s w \\<union> {\\<delta> s v})\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "have \"v \\<in> lowlink_set ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "have cb: \"(u,v) \\<in> cross_edges ?s \\<union> back_edges ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n          back_edges (s'\\<lparr>state.more := x\\<rparr>)", "by (simp add: cross_back_edge)"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n        back_edges (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "with s'.lowlink_path_single"], ["proof (chain)\npicking this:\n  (?v, ?w)\n  \\<in> cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n        back_edges (s'\\<lparr>state.more := x\\<rparr>) \\<Longrightarrow>\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) ?v [?v] ?w\n  (u, v)\n  \\<in> cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n        back_edges (s'\\<lparr>state.more := x\\<rparr>)", "have \"lowlink_path ?s u [u] v\""], ["proof (prove)\nusing this:\n  (?v, ?w)\n  \\<in> cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n        back_edges (s'\\<lparr>state.more := x\\<rparr>) \\<Longrightarrow>\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) ?v [?v] ?w\n  (u, v)\n  \\<in> cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n        back_edges (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (1 subgoal):\n 1. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) u [u] v", "by auto"], ["proof (state)\nthis:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) u [u] v\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "moreover"], ["proof (state)\nthis:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) u [u] v\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "from cb s'.cross_edges_ssE s'.back_edges_ssE"], ["proof (chain)\npicking this:\n  (u, v)\n  \\<in> cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n        back_edges (s'\\<lparr>state.more := x\\<rparr>)\n  cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<subseteq> E\n  back_edges (s'\\<lparr>state.more := x\\<rparr>) \\<subseteq> E", "have \"(u,v) \\<in> E\""], ["proof (prove)\nusing this:\n  (u, v)\n  \\<in> cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n        back_edges (s'\\<lparr>state.more := x\\<rparr>)\n  cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<subseteq> E\n  back_edges (s'\\<lparr>state.more := x\\<rparr>) \\<subseteq> E\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E", "by blast"], ["proof (state)\nthis:\n  (u, v) \\<in> E\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "hence \"(u,v) \\<in> E\\<^sup>*\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E\\<^sup>*", ".."], ["proof (state)\nthis:\n  (u, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "moreover"], ["proof (state)\nthis:\n  (u, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "from all_True tj_stack_reach_hd_stack"], ["proof (chain)\npicking this:\n  \\<delta> s v < \\<delta> s w \\<and>\n  v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w\n  ?v \\<in> set (tj_stack s) \\<Longrightarrow>\n  (?v, hd (stack s)) \\<in> E\\<^sup>*", "have \"(v,u) \\<in> E\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<delta> s v < \\<delta> s w \\<and>\n  v \\<in> set (tj_stack s) \\<and> \\<delta> s v < \\<zeta> s w\n  ?v \\<in> set (tj_stack s) \\<Longrightarrow>\n  (?v, hd (stack s)) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> E\\<^sup>*", "by (simp add: cross_back_edge)"], ["proof (state)\nthis:\n  (v, u) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "moreover"], ["proof (state)\nthis:\n  (v, u) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "note \\<open>v \\<in> dom (discovered s)\\<close>"], ["proof (state)\nthis:\n  v \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "ultimately"], ["proof (chain)\npicking this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) u [u] v\n  (u, v) \\<in> E\\<^sup>*\n  (v, u) \\<in> E\\<^sup>*\n  v \\<in> dom (discovered s)", "show ?thesis"], ["proof (prove)\nusing this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) u [u] v\n  (u, v) \\<in> E\\<^sup>*\n  (v, u) \\<in> E\\<^sup>*\n  v \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "by (auto intro: s'.lowlink_setI simp: \\<open>w=u\\<close>)"], ["proof (state)\nthis:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "with ll_sub ll_sub_rev"], ["proof (chain)\npicking this:\n  lowlink_set s w\n  \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> lowlink_set s w \\<union> {v}\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "have \"lowlink_set ?s w = lowlink_set s w \\<union> {v}\""], ["proof (prove)\nusing this:\n  lowlink_set s w\n  \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> lowlink_set s w \\<union> {v}\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w =\n    lowlink_set s w \\<union> {v}", "by auto"], ["proof (state)\nthis:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w =\n  lowlink_set s w \\<union> {v}\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "hence \"Min (?L \\<union> {\\<delta> s v}) = LowLink ?s w\""], ["proof (prove)\nusing this:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w =\n  lowlink_set s w \\<union> {v}\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w \\<union> {\\<delta> s v}) =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w \\<union> {\\<delta> s v}) =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<delta> s v < \\<delta> s w \\<and>\n    v \\<in> set (tj_stack s) \\<and>\n    \\<delta> s v < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "finally"], ["proof (chain)\npicking this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "."], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "case False \\<comment> \\<open>\\<open>w \\<noteq> u\\<close>\\<close>"], ["proof (state)\nthis:\n  w \\<noteq> u\n\ngoal (1 subgoal):\n 1. w \\<noteq> u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "hence \"\\<zeta> ?s w = \\<zeta> s w\""], ["proof (prove)\nusing this:\n  w \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "by (rule_tac TRANS) (simp add: tarjan_back_def cross_back_edge)"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n\ngoal (1 subgoal):\n 1. w \\<noteq> u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n\ngoal (1 subgoal):\n 1. w \\<noteq> u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "have \"\\<zeta> s w = LowLink s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)", "using w_disc False"], ["proof (prove)\nusing this:\n  w \\<in> dom (discovered s)\n  w \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)", "by (simp add: cross_back_edge)"], ["proof (state)\nthis:\n  \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "have \"LowLink s w = LowLink ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w) =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "proof (rule LL_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n             w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "assume v: \"v \\<in> lowlink_set ?s w\""], ["proof (state)\nthis:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n             w \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "thus \"LowLink s w \\<le> \\<delta> ?s v\""], ["proof (prove)\nusing this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "using LLw"], ["proof (prove)\nusing this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w;\n     Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w; ?P2\\<rbrakk>\n    \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                      \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n 2. \\<lbrakk>v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w;\n     Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                      \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "assume \"v \\<noteq> w\""], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w;\n     Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w; ?P2\\<rbrakk>\n    \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                      \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n 2. \\<lbrakk>v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w;\n     Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                      \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "with v"], ["proof (chain)\npicking this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  v \\<noteq> w", "obtain p where p: \"lowlink_path ?s w p v\" \"p\\<noteq>[]\""], ["proof (prove)\nusing this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v;\n         p \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: lowlink_set_def lowlink_path_def)"], ["proof (state)\nthis:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n  p \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w;\n     Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w; ?P2\\<rbrakk>\n    \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                      \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n 2. \\<lbrakk>v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w;\n     Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                      \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "hence \"hd p = w\""], ["proof (prove)\nusing this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd p = w", "by (auto simp add: lowlink_path_def path_hd)"], ["proof (state)\nthis:\n  hd p = w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w;\n     Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w; ?P2\\<rbrakk>\n    \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                      \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n 2. \\<lbrakk>v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w;\n     Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w;\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                      \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "proof (cases \"u \\<in> set p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n 2. u \\<notin> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "case False"], ["proof (state)\nthis:\n  u \\<notin> set p\n\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n 2. u \\<notin> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "with last_in_set p cross_back_edge"], ["proof (chain)\npicking this:\n  ?l \\<noteq> [] \\<Longrightarrow> last ?l \\<in> set ?l\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n  p \\<noteq> []\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  u \\<notin> set p", "have \"last p \\<noteq> hd (stack s)\""], ["proof (prove)\nusing this:\n  ?l \\<noteq> [] \\<Longrightarrow> last ?l \\<in> set ?l\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n  p \\<noteq> []\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  u \\<notin> set p\n\ngoal (1 subgoal):\n 1. last p \\<noteq> hd (stack s)", "by force"], ["proof (state)\nthis:\n  last p \\<noteq> hd (stack s)\n\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n 2. u \\<notin> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "with p"], ["proof (chain)\npicking this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n  p \\<noteq> []\n  last p \\<noteq> hd (stack s)", "have \"lowlink_path s w p v\""], ["proof (prove)\nusing this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n  p \\<noteq> []\n  last p \\<noteq> hd (stack s)\n\ngoal (1 subgoal):\n 1. lowlink_path s w p v", "by (auto simp: cross_back_edge lowlink_path_def)"], ["proof (state)\nthis:\n  lowlink_path s w p v\n\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n 2. u \\<notin> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "with v"], ["proof (chain)\npicking this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  lowlink_path s w p v", "have \"v \\<in> lowlink_set s w\""], ["proof (prove)\nusing this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  lowlink_path s w p v\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set s w", "by (auto intro: lowlink_setI simp: lowlink_set_def cross_back_edge)"], ["proof (state)\nthis:\n  v \\<in> lowlink_set s w\n\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n 2. u \\<notin> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> lowlink_set s w\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "case True"], ["proof (state)\nthis:\n  u \\<in> set p\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "then"], ["proof (chain)\npicking this:\n  u \\<in> set p", "obtain i where i: \"i < length p\" \"p!i = u\""], ["proof (prove)\nusing this:\n  u \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length p; p ! i = u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length p\n  p ! i = u\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "have \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "case \"0\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with i"], ["proof (chain)\npicking this:\n  i < length p\n  p ! i = u\n  i = 0", "have \"hd p = u\""], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = u\n  i = 0\n\ngoal (1 subgoal):\n 1. hd p = u", "by (simp add: hd_conv_nth)"], ["proof (state)\nthis:\n  hd p = u\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with \\<open>hd p = w\\<close> \\<open>w \\<noteq> u\\<close>"], ["proof (chain)\npicking this:\n  hd p = w\n  w \\<noteq> u\n  hd p = u", "show False"], ["proof (prove)\nusing this:\n  hd p = w\n  w \\<noteq> u\n  hd p = u\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "case (Suc n)"], ["proof (state)\nthis:\n  i = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with i s'.lowlink_path_finished[OF p(1), where j=i]"], ["proof (chain)\npicking this:\n  i < length p\n  p ! i = u\n  \\<lbrakk>i < length p; 0 < i\\<rbrakk>\n  \\<Longrightarrow> p ! i\n                    \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  i = Suc n", "have \n                    \"u \\<in> dom (finished ?s)\""], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = u\n  \\<lbrakk>i < length p; 0 < i\\<rbrakk>\n  \\<Longrightarrow> p ! i\n                    \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  i = Suc n\n\ngoal (1 subgoal):\n 1. u \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  u \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with u_n_fin"], ["proof (chain)\npicking this:\n  u \\<notin> dom (finished s)\n  u \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<notin> dom (finished s)\n  u \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", ".."], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w;\n     Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w;\n     \\<not> v \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                      \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v", "qed simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w) =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> u \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "finally"], ["proof (chain)\npicking this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "."], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_back u v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   ?w9 \\<in> dom (discovered (s'\\<lparr>state.more := ?x9\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> (s'\\<lparr>state.more := ?x9\\<rparr>) ?w9 =\n                    Min (\\<delta> (s'\\<lparr>state.more := ?x9\\<rparr>) `\n                         lowlink_set (s'\\<lparr>state.more := ?x9\\<rparr>)\n                          ?w9)\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "note aux = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_back u v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   ?w9 \\<in> dom (discovered (s'\\<lparr>state.more := ?x9\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> (s'\\<lparr>state.more := ?x9\\<rparr>) ?w9 =\n                    Min (\\<delta> (s'\\<lparr>state.more := ?x9\\<rparr>) `\n                         lowlink_set (s'\\<lparr>state.more := ?x9\\<rparr>)\n                          ?w9)\n\ngoal (4 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); discovered s' = discovered s;\n        finished s' = finished s; stack s' = stack s;\n        tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u, v)};\n        cross_edges s' \\<union> back_edges s' =\n        cross_edges s \\<union> back_edges s \\<union> {(u, v)};\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "with cross_back_edge"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_back u v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   ?w9 \\<in> dom (discovered (s'\\<lparr>state.more := ?x9\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> (s'\\<lparr>state.more := ?x9\\<rparr>) ?w9 =\n                    Min (\\<delta> (s'\\<lparr>state.more := ?x9\\<rparr>) `\n                         lowlink_set (s'\\<lparr>state.more := ?x9\\<rparr>)\n                          ?w9)", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  discovered s' = discovered s\n  finished s' = finished s\n  stack s' = stack s\n  tree_edges s' = tree_edges s\n  counter s' = counter s\n  pending s' = pending s - {(u, v)}\n  cross_edges s' \\<union> back_edges s' =\n  cross_edges s \\<union> back_edges s \\<union> {(u, v)}\n  state.more s' = state.more s\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_back u v s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   ?w9 \\<in> dom (discovered (s'\\<lparr>state.more := ?x9\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> (s'\\<lparr>state.more := ?x9\\<rparr>) ?w9 =\n                    Min (\\<delta> (s'\\<lparr>state.more := ?x9\\<rparr>) `\n                         lowlink_set (s'\\<lparr>state.more := ?x9\\<rparr>)\n                          ?w9)\n\ngoal (1 subgoal):\n 1. on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         (\\<forall>xa\\<in>dom (discovered\n                                (s'\\<lparr>state.more := x\\<rparr>)).\n             \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) xa =\n             Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n                  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "by (auto simp: pw_leof_iff)"], ["proof (state)\nthis:\n  on_cross_edge tarjan_params u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       (\\<forall>xa\\<in>dom (discovered\n                              (s'\\<lparr>state.more := x\\<rparr>)).\n           \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) xa =\n           Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n                lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "case (finish s s' u)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "have [simp]:\n        \"discovered s' = discovered s\"\n        \"finished s' = (finished s)(u\\<mapsto>counter s)\"\n        \"tree_edges s' = tree_edges s\"\n        \"back_edges s' = back_edges s\"\n        \"cross_edges s' = cross_edges s\"\n        \"lowlink s' = lowlink s\" \"tj_stack s' = tj_stack s\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. (discovered s' = discovered s &&&\n     finished s' = finished s(u \\<mapsto> counter s) &&&\n     tree_edges s' = tree_edges s) &&&\n    (back_edges s' = back_edges s &&& cross_edges s' = cross_edges s) &&&\n    lowlink s' = lowlink s &&& tj_stack s' = tj_stack s", "by simp_all"], ["proof (state)\nthis:\n  discovered s' = discovered s\n  finished s' = finished s(u \\<mapsto> counter s)\n  tree_edges s' = tree_edges s\n  back_edges s' = back_edges s\n  cross_edges s' = cross_edges s\n  lowlink s' = lowlink s\n  tj_stack s' = tj_stack s\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "from finish hd_in_set stack_discovered"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  set (stack s) \\<subseteq> dom (discovered s)", "have u_disc: \"u \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. u \\<in> dom (discovered s)", "by blast"], ["proof (state)\nthis:\n  u \\<in> dom (discovered s)\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "{"], ["proof (state)\nthis:\n  u \\<in> dom (discovered s)\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "fix w :: \"'v\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "let ?s = \"s'\\<lparr>state.more := x\\<rparr>\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "let ?L = \"\\<delta> s ` lowlink_set s w\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "let ?Lu = \"\\<delta> s ` lowlink_set s u\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "let ?L' = \"\\<delta> s ` lowlink_set ?s w\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "assume TRANS: \"\\<And>\\<Psi>. tarjan_fin u s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow> \\<Psi> x\"\n          and inv': \"DFS_invar G tarjan_params ?s\"\n          and w_disc: \"w \\<in> dom (discovered ?s)\""], ["proof (state)\nthis:\n  tarjan_fin u s' \\<le>\\<^sub>n SPEC ?\\<Psi>7 \\<Longrightarrow> ?\\<Psi>7 x\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "from inv'"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)", "interpret s':Tarjan_invar where s=\"?s\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params (s'\\<lparr>state.more := x\\<rparr>)\n\ngoal (1 subgoal):\n 1. Tarjan_invar G (s'\\<lparr>state.more := x\\<rparr>)", "by simp"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have ll_sub: \"lowlink_set s w \\<subseteq> lowlink_set ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowlink_set s w\n    \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "unfolding lowlink_set_def lowlink_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {wa \\<in> dom (discovered s).\n     w = wa \\<or>\n     (w, wa) \\<in> E\\<^sup>+ \\<and>\n     (wa, w) \\<in> E\\<^sup>+ \\<and>\n     (\\<exists>p.\n         path E w p wa \\<and>\n         p \\<noteq> [] \\<and>\n         (last p, wa) \\<in> cross_edges s \\<union> back_edges s \\<and>\n         (1 < length p \\<longrightarrow>\n          p ! 1 \\<in> dom (finished s) \\<and>\n          (\\<forall>k<length p - 1.\n              (p ! k, p ! Suc k) \\<in> tree_edges s)))}\n    \\<subseteq> {wa \\<in> dom (discovered\n                                (s'\\<lparr>state.more := x\\<rparr>)).\n                 w = wa \\<or>\n                 (w, wa) \\<in> E\\<^sup>+ \\<and>\n                 (wa, w) \\<in> E\\<^sup>+ \\<and>\n                 (\\<exists>p.\n                     path E w p wa \\<and>\n                     p \\<noteq> [] \\<and>\n                     (last p, wa)\n                     \\<in> cross_edges\n                            (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n                           back_edges\n                            (s'\\<lparr>state.more := x\\<rparr>) \\<and>\n                     (1 < length p \\<longrightarrow>\n                      p ! 1\n                      \\<in> dom (finished\n                                  (s'\\<lparr>state.more :=\n         x\\<rparr>)) \\<and>\n                      (\\<forall>k<length p - 1.\n                          (p ! k, p ! Suc k)\n                          \\<in> tree_edges\n                                 (s'\\<lparr>state.more := x\\<rparr>))))}", "by auto"], ["proof (state)\nthis:\n  lowlink_set s w\n  \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have ll_sub_rev: \"lowlink_set ?s w \\<subseteq> lowlink_set s w \\<union> lowlink_set s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> lowlink_set s w \\<union> lowlink_set s u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n                 w \\<Longrightarrow>\n       xa \\<in> lowlink_set s w \\<union> lowlink_set s u", "fix ll"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n                 w \\<Longrightarrow>\n       xa \\<in> lowlink_set s w \\<union> lowlink_set s u", "assume ll: \"ll \\<in> lowlink_set ?s w\""], ["proof (state)\nthis:\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n                 w \\<Longrightarrow>\n       xa \\<in> lowlink_set s w \\<union> lowlink_set s u", "hence \"ll = w \\<or> (\\<exists>p. lowlink_path ?s w p ll)\""], ["proof (prove)\nusing this:\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. ll = w \\<or>\n    (\\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll)", "by (auto simp add: lowlink_set_def)"], ["proof (state)\nthis:\n  ll = w \\<or>\n  (\\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n                 w \\<Longrightarrow>\n       xa \\<in> lowlink_set s w \\<union> lowlink_set s u", "thus \"ll \\<in> lowlink_set s w \\<union> lowlink_set s u\""], ["proof (prove)\nusing this:\n  ll = w \\<or>\n  (\\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll)\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "proof (rule disjE1)"], ["proof (state)\ngoal (2 subgoals):\n 1. ll = w \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u\n 2. \\<lbrakk>ll \\<noteq> w;\n     \\<exists>p.\n        lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "assume \"ll = w\""], ["proof (state)\nthis:\n  ll = w\n\ngoal (2 subgoals):\n 1. ll = w \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u\n 2. \\<lbrakk>ll \\<noteq> w;\n     \\<exists>p.\n        lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "with w_disc"], ["proof (chain)\npicking this:\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  ll = w", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  ll = w\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "by (auto simp add: lowlink_set_def)"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s w \\<union> lowlink_set s u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ll \\<noteq> w;\n     \\<exists>p.\n        lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ll \\<noteq> w;\n     \\<exists>p.\n        lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "assume \"ll \\<noteq> w\""], ["proof (state)\nthis:\n  ll \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ll \\<noteq> w;\n     \\<exists>p.\n        lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "assume \"\\<exists>p. lowlink_path ?s w p ll\""], ["proof (state)\nthis:\n  \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ll \\<noteq> w;\n     \\<exists>p.\n        lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll", "guess p"], ["proof (prove)\nusing this:\n  \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ll \\<noteq> w;\n     \\<exists>p.\n        lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "note p = this"], ["proof (state)\nthis:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ll \\<noteq> w;\n     \\<exists>p.\n        lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "hence [simp]: \"p\\<noteq>[]\""], ["proof (prove)\nusing this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by (simp add: lowlink_path_def)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ll \\<noteq> w;\n     \\<exists>p.\n        lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "from p"], ["proof (chain)\npicking this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll", "have \"hd p = w\""], ["proof (prove)\nusing this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n\ngoal (1 subgoal):\n 1. hd p = w", "by (auto simp add: lowlink_path_def path_hd)"], ["proof (state)\nthis:\n  hd p = w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ll \\<noteq> w;\n     \\<exists>p.\n        lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\\<rbrakk>\n    \\<Longrightarrow> ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "proof (cases \"u \\<in> set p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u\n 2. u \\<notin> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "case False"], ["proof (state)\nthis:\n  u \\<notin> set p\n\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u\n 2. u \\<notin> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "hence \"lowlink_path s w p ll\""], ["proof (prove)\nusing this:\n  u \\<notin> set p\n\ngoal (1 subgoal):\n 1. lowlink_path s w p ll", "using p"], ["proof (prove)\nusing this:\n  u \\<notin> set p\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n\ngoal (1 subgoal):\n 1. lowlink_path s w p ll", "by (auto simp add: lowlink_path_def)"], ["proof (state)\nthis:\n  lowlink_path s w p ll\n\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u\n 2. u \\<notin> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "with ll"], ["proof (chain)\npicking this:\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  lowlink_path s w p ll", "show ?thesis"], ["proof (prove)\nusing this:\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  lowlink_path s w p ll\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "by (auto simp add: lowlink_set_def)"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s w \\<union> lowlink_set s u\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "case True"], ["proof (state)\nthis:\n  u \\<in> set p\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "then"], ["proof (chain)\npicking this:\n  u \\<in> set p", "obtain i where i: \"i < length p\" \"p!i = u\""], ["proof (prove)\nusing this:\n  u \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length p; p ! i = u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length p\n  p ! i = u\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "moreover"], ["proof (state)\nthis:\n  i < length p\n  p ! i = u\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "let ?dp = \"drop i p\""], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "from i"], ["proof (chain)\npicking this:\n  i < length p\n  p ! i = u", "have \"?dp \\<noteq> []\""], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = u\n\ngoal (1 subgoal):\n 1. drop i p \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  drop i p \\<noteq> []\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "from i"], ["proof (chain)\npicking this:\n  i < length p\n  p ! i = u", "have \"hd ?dp = u\""], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = u\n\ngoal (1 subgoal):\n 1. hd (drop i p) = u", "by (simp add: hd_drop_conv_nth)"], ["proof (state)\nthis:\n  hd (drop i p) = u\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "moreover"], ["proof (state)\nthis:\n  hd (drop i p) = u\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "from i"], ["proof (chain)\npicking this:\n  i < length p\n  p ! i = u", "have \"last ?dp = last p\""], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = u\n\ngoal (1 subgoal):\n 1. last (drop i p) = last p", "by simp"], ["proof (state)\nthis:\n  last (drop i p) = last p\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "moreover"], ["proof (state)\nthis:\n  last (drop i p) = last p\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "{"], ["proof (state)\nthis:\n  last (drop i p) = last p\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "assume \"1 < length ?dp\"\n                and  \"k < length ?dp - 1\""], ["proof (state)\nthis:\n  1 < length (drop i p)\n  k < length (drop i p) - 1\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "hence l: \"1 < length p\" \"k+i < length p - 1\""], ["proof (prove)\nusing this:\n  1 < length (drop i p)\n  k < length (drop i p) - 1\n\ngoal (1 subgoal):\n 1. 1 < length p &&& k + i < length p - 1", "by (auto)"], ["proof (state)\nthis:\n  1 < length p\n  k + i < length p - 1\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "with p"], ["proof (chain)\npicking this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n  1 < length p\n  k + i < length p - 1", "have \"(p!(k+i), p!Suc (k+i)) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n  1 < length p\n  k + i < length p - 1\n\ngoal (1 subgoal):\n 1. (p ! (k + i), p ! Suc (k + i)) \\<in> tree_edges s", "by (auto simp add: lowlink_path_def)"], ["proof (state)\nthis:\n  (p ! (k + i), p ! Suc (k + i)) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "moreover"], ["proof (state)\nthis:\n  (p ! (k + i), p ! Suc (k + i)) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "from l"], ["proof (chain)\npicking this:\n  1 < length p\n  k + i < length p - 1", "have i: \"i+k \\<le> length p\" \"i+Suc k \\<le> length p\""], ["proof (prove)\nusing this:\n  1 < length p\n  k + i < length p - 1\n\ngoal (1 subgoal):\n 1. i + k \\<le> length p &&& i + Suc k \\<le> length p", "by simp_all"], ["proof (state)\nthis:\n  i + k \\<le> length p\n  i + Suc k \\<le> length p\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "ultimately"], ["proof (chain)\npicking this:\n  (p ! (k + i), p ! Suc (k + i)) \\<in> tree_edges s\n  i + k \\<le> length p\n  i + Suc k \\<le> length p", "have  \"(?dp!k,?dp!Suc k) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  (p ! (k + i), p ! Suc (k + i)) \\<in> tree_edges s\n  i + k \\<le> length p\n  i + Suc k \\<le> length p\n\ngoal (1 subgoal):\n 1. (drop i p ! k, drop i p ! Suc k) \\<in> tree_edges s", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  (drop i p ! k, drop i p ! Suc k) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "}"], ["proof (state)\nthis:\n  \\<lbrakk>1 < length (drop i p); ?k9 < length (drop i p) - 1\\<rbrakk>\n  \\<Longrightarrow> (drop i p ! ?k9, drop i p ! Suc ?k9) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "note aux = this"], ["proof (state)\nthis:\n  \\<lbrakk>1 < length (drop i p); ?k9 < length (drop i p) - 1\\<rbrakk>\n  \\<Longrightarrow> (drop i p ! ?k9, drop i p ! Suc ?k9) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>1 < length (drop i p); ?k9 < length (drop i p) - 1\\<rbrakk>\n  \\<Longrightarrow> (drop i p ! ?k9, drop i p ! Suc ?k9) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "{"], ["proof (state)\nthis:\n  \\<lbrakk>1 < length (drop i p); ?k9 < length (drop i p) - 1\\<rbrakk>\n  \\<Longrightarrow> (drop i p ! ?k9, drop i p ! Suc ?k9) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "assume *: \"1 < length ?dp\""], ["proof (state)\nthis:\n  1 < length (drop i p)\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "hence l: \"1 + i < length p\""], ["proof (prove)\nusing this:\n  1 < length (drop i p)\n\ngoal (1 subgoal):\n 1. 1 + i < length p", "by simp"], ["proof (state)\nthis:\n  1 + i < length p\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "with s'.lowlink_path_finished[OF p]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?j < length p; 0 < ?j\\<rbrakk>\n  \\<Longrightarrow> p ! ?j\n                    \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  1 + i < length p", "have \"p ! (1+i) \\<in> dom (finished ?s)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?j < length p; 0 < ?j\\<rbrakk>\n  \\<Longrightarrow> p ! ?j\n                    \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  1 + i < length p\n\ngoal (1 subgoal):\n 1. p ! (1 + i) \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))", "by auto"], ["proof (state)\nthis:\n  p ! (1 + i) \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "moreover"], ["proof (state)\nthis:\n  p ! (1 + i) \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "from l"], ["proof (chain)\npicking this:\n  1 + i < length p", "have \"i+1\\<le>length p\""], ["proof (prove)\nusing this:\n  1 + i < length p\n\ngoal (1 subgoal):\n 1. i + 1 \\<le> length p", "by simp"], ["proof (state)\nthis:\n  i + 1 \\<le> length p\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "ultimately"], ["proof (chain)\npicking this:\n  p ! (1 + i) \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  i + 1 \\<le> length p", "have \"?dp!1 \\<in> dom (finished ?s)\""], ["proof (prove)\nusing this:\n  p ! (1 + i) \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  i + 1 \\<le> length p\n\ngoal (1 subgoal):\n 1. drop i p ! 1 \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  drop i p ! 1 \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "moreover"], ["proof (state)\nthis:\n  drop i p ! 1 \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "from aux[of 0] *"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 < length (drop i p); 0 < length (drop i p) - 1\\<rbrakk>\n  \\<Longrightarrow> (drop i p ! 0, drop i p ! Suc 0) \\<in> tree_edges s\n  1 < length (drop i p)", "have \"(?dp!0,?dp!Suc 0) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < length (drop i p); 0 < length (drop i p) - 1\\<rbrakk>\n  \\<Longrightarrow> (drop i p ! 0, drop i p ! Suc 0) \\<in> tree_edges s\n  1 < length (drop i p)\n\ngoal (1 subgoal):\n 1. (drop i p ! 0, drop i p ! Suc 0) \\<in> tree_edges s", "by simp"], ["proof (state)\nthis:\n  (drop i p ! 0, drop i p ! Suc 0) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "with \\<open>hd ?dp = u\\<close> hd_conv_nth[of \"?dp\"] *"], ["proof (chain)\npicking this:\n  hd (drop i p) = u\n  drop i p \\<noteq> [] \\<Longrightarrow> hd (drop i p) = drop i p ! 0\n  1 < length (drop i p)\n  (drop i p ! 0, drop i p ! Suc 0) \\<in> tree_edges s", "have \"(u,?dp!Suc 0) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  hd (drop i p) = u\n  drop i p \\<noteq> [] \\<Longrightarrow> hd (drop i p) = drop i p ! 0\n  1 < length (drop i p)\n  (drop i p ! 0, drop i p ! Suc 0) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. (u, drop i p ! Suc 0) \\<in> tree_edges s", "by simp"], ["proof (state)\nthis:\n  (u, drop i p ! Suc 0) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "with no_self_loop_in_tree"], ["proof (chain)\npicking this:\n  (?v, ?v) \\<notin> tree_edges s\n  (u, drop i p ! Suc 0) \\<in> tree_edges s", "have \"?dp!1 \\<noteq> u\""], ["proof (prove)\nusing this:\n  (?v, ?v) \\<notin> tree_edges s\n  (u, drop i p ! Suc 0) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. drop i p ! 1 \\<noteq> u", "by auto"], ["proof (state)\nthis:\n  drop i p ! 1 \\<noteq> u\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "ultimately"], ["proof (chain)\npicking this:\n  drop i p ! 1 \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  drop i p ! 1 \\<noteq> u", "have \"?dp!1 \\<in> dom (finished s)\""], ["proof (prove)\nusing this:\n  drop i p ! 1 \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  drop i p ! 1 \\<noteq> u\n\ngoal (1 subgoal):\n 1. drop i p ! 1 \\<in> dom (finished s)", "by simp"], ["proof (state)\nthis:\n  drop i p ! 1 \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "}"], ["proof (state)\nthis:\n  1 < length (drop i p) \\<Longrightarrow>\n  drop i p ! 1 \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "moreover"], ["proof (state)\nthis:\n  1 < length (drop i p) \\<Longrightarrow>\n  drop i p ! 1 \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "from p"], ["proof (chain)\npicking this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll", "have P: \"path E w p ll\""], ["proof (prove)\nusing this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n\ngoal (1 subgoal):\n 1. path E w p ll", "by (simp add: lowlink_path_def)"], ["proof (state)\nthis:\n  path E w p ll\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "have \"p = (take i p)@?dp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = take i p @ drop i p", "by simp"], ["proof (state)\nthis:\n  p = take i p @ drop i p\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "with P path_conc_conv"], ["proof (chain)\npicking this:\n  path E w p ll\n  path ?E ?u (?la @ ?lb) ?w =\n  (\\<exists>v. path ?E ?u ?la v \\<and> path ?E v ?lb ?w)\n  p = take i p @ drop i p", "obtain x where p': \"path E x ?dp ll\" \"path E w (take i p) x\""], ["proof (prove)\nusing this:\n  path E w p ll\n  path ?E ?u (?la @ ?lb) ?w =\n  (\\<exists>v. path ?E ?u ?la v \\<and> path ?E v ?lb ?w)\n  p = take i p @ drop i p\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>path E x (drop i p) ll; path E w (take i p) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  path E x (drop i p) ll\n  path E w (take i p) x\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "with \\<open>?dp \\<noteq> []\\<close> path_hd"], ["proof (chain)\npicking this:\n  drop i p \\<noteq> []\n  \\<lbrakk>?p \\<noteq> []; path ?E ?v ?p ?w\\<rbrakk>\n  \\<Longrightarrow> hd ?p = ?v\n  path E x (drop i p) ll\n  path E w (take i p) x", "have \"hd ?dp = x\""], ["proof (prove)\nusing this:\n  drop i p \\<noteq> []\n  \\<lbrakk>?p \\<noteq> []; path ?E ?v ?p ?w\\<rbrakk>\n  \\<Longrightarrow> hd ?p = ?v\n  path E x (drop i p) ll\n  path E w (take i p) x\n\ngoal (1 subgoal):\n 1. hd (drop i p) = x", "by metis"], ["proof (state)\nthis:\n  hd (drop i p) = x\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "with \\<open>hd ?dp = u\\<close> p'"], ["proof (chain)\npicking this:\n  hd (drop i p) = u\n  path E x (drop i p) ll\n  path E w (take i p) x\n  hd (drop i p) = x", "have u_path: \"path E u ?dp ll\" and path_u: \"path E w (take i p) u\""], ["proof (prove)\nusing this:\n  hd (drop i p) = u\n  path E x (drop i p) ll\n  path E w (take i p) x\n  hd (drop i p) = x\n\ngoal (1 subgoal):\n 1. path E u (drop i p) ll &&& path E w (take i p) u", "by metis+"], ["proof (state)\nthis:\n  path E u (drop i p) ll\n  path E w (take i p) u\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "ultimately"], ["proof (chain)\npicking this:\n  i < length p\n  p ! i = u\n  hd (drop i p) = u\n  last (drop i p) = last p\n  \\<lbrakk>1 < length (drop i p); ?k9 < length (drop i p) - 1\\<rbrakk>\n  \\<Longrightarrow> (drop i p ! ?k9, drop i p ! Suc ?k9) \\<in> tree_edges s\n  1 < length (drop i p) \\<Longrightarrow>\n  drop i p ! 1 \\<in> dom (finished s)\n  path E u (drop i p) ll\n  path E w (take i p) u", "have \"lowlink_path s u ?dp ll\""], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = u\n  hd (drop i p) = u\n  last (drop i p) = last p\n  \\<lbrakk>1 < length (drop i p); ?k9 < length (drop i p) - 1\\<rbrakk>\n  \\<Longrightarrow> (drop i p ! ?k9, drop i p ! Suc ?k9) \\<in> tree_edges s\n  1 < length (drop i p) \\<Longrightarrow>\n  drop i p ! 1 \\<in> dom (finished s)\n  path E u (drop i p) ll\n  path E w (take i p) u\n\ngoal (1 subgoal):\n 1. lowlink_path s u (drop i p) ll", "using p"], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = u\n  hd (drop i p) = u\n  last (drop i p) = last p\n  \\<lbrakk>1 < length (drop i p); ?k9 < length (drop i p) - 1\\<rbrakk>\n  \\<Longrightarrow> (drop i p ! ?k9, drop i p ! Suc ?k9) \\<in> tree_edges s\n  1 < length (drop i p) \\<Longrightarrow>\n  drop i p ! 1 \\<in> dom (finished s)\n  path E u (drop i p) ll\n  path E w (take i p) u\n  lowlink_path (s'\\<lparr>state.more := x__\\<rparr>) w p ll\n\ngoal (1 subgoal):\n 1. lowlink_path s u (drop i p) ll", "by (simp add: lowlink_path_def)"], ["proof (state)\nthis:\n  lowlink_path s u (drop i p) ll\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "moreover"], ["proof (state)\nthis:\n  lowlink_path s u (drop i p) ll\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "from u_path path_is_trancl \\<open>?dp \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  path E u (drop i p) ll\n  \\<lbrakk>path ?E ?u ?l ?v; ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> ?E\\<^sup>+\n  drop i p \\<noteq> []", "have \"(u,ll) \\<in> E\\<^sup>+\""], ["proof (prove)\nusing this:\n  path E u (drop i p) ll\n  \\<lbrakk>path ?E ?u ?l ?v; ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> ?E\\<^sup>+\n  drop i p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (u, ll) \\<in> E\\<^sup>+", "by force"], ["proof (state)\nthis:\n  (u, ll) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "moreover"], ["proof (state)\nthis:\n  (u, ll) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "{"], ["proof (state)\nthis:\n  (u, ll) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "from ll \\<open>ll \\<noteq> w\\<close>"], ["proof (chain)\npicking this:\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x__\\<rparr>) w\n  ll \\<noteq> w", "have \"(ll,w) \\<in> E\\<^sup>+\""], ["proof (prove)\nusing this:\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x__\\<rparr>) w\n  ll \\<noteq> w\n\ngoal (1 subgoal):\n 1. (ll, w) \\<in> E\\<^sup>+", "by (auto simp add: lowlink_set_def)"], ["proof (state)\nthis:\n  (ll, w) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "also"], ["proof (state)\nthis:\n  (ll, w) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "from path_u path_is_rtrancl"], ["proof (chain)\npicking this:\n  path E w (take i p) u\n  path ?E ?u ?l ?v \\<Longrightarrow> (?u, ?v) \\<in> ?E\\<^sup>*", "have \"(w,u) \\<in> E\\<^sup>*\""], ["proof (prove)\nusing this:\n  path E w (take i p) u\n  path ?E ?u ?l ?v \\<Longrightarrow> (?u, ?v) \\<in> ?E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (w, u) \\<in> E\\<^sup>*", "by metis"], ["proof (state)\nthis:\n  (w, u) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "finally"], ["proof (chain)\npicking this:\n  (ll, u) \\<in> E\\<^sup>+", "have \"(ll,u)\\<in>E\\<^sup>+\""], ["proof (prove)\nusing this:\n  (ll, u) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. (ll, u) \\<in> E\\<^sup>+", "."], ["proof (state)\nthis:\n  (ll, u) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "}"], ["proof (state)\nthis:\n  (ll, u) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "moreover"], ["proof (state)\nthis:\n  (ll, u) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "note ll u_disc"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x__\\<rparr>) w\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "ultimately"], ["proof (chain)\npicking this:\n  lowlink_path s u (drop i p) ll\n  (u, ll) \\<in> E\\<^sup>+\n  (ll, u) \\<in> E\\<^sup>+\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x__\\<rparr>) w\n  u \\<in> dom (discovered s)", "have \"ll \\<in> lowlink_set s u\""], ["proof (prove)\nusing this:\n  lowlink_path s u (drop i p) ll\n  (u, ll) \\<in> E\\<^sup>+\n  (ll, u) \\<in> E\\<^sup>+\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x__\\<rparr>) w\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s u", "unfolding lowlink_set_def"], ["proof (prove)\nusing this:\n  lowlink_path s u (drop i p) ll\n  (u, ll) \\<in> E\\<^sup>+\n  (ll, u) \\<in> E\\<^sup>+\n  ll \\<in> {wa \\<in> dom (discovered (s'\\<lparr>state.more := x__\\<rparr>)).\n            w = wa \\<or>\n            (w, wa) \\<in> E\\<^sup>+ \\<and>\n            (wa, w) \\<in> E\\<^sup>+ \\<and>\n            (\\<exists>p.\n                lowlink_path (s'\\<lparr>state.more := x__\\<rparr>) w p wa)}\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. ll \\<in> {w \\<in> dom (discovered s).\n              u = w \\<or>\n              (u, w) \\<in> E\\<^sup>+ \\<and>\n              (w, u) \\<in> E\\<^sup>+ \\<and>\n              (\\<exists>p. lowlink_path s u p w)}", "by auto"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s u\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow>\n    ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "thus ?thesis"], ["proof (prove)\nusing this:\n  ll \\<in> lowlink_set s u\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set s w \\<union> lowlink_set s u", "by auto"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s w \\<union> lowlink_set s u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s w \\<union> lowlink_set s u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s w \\<union> lowlink_set s u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> lowlink_set s w \\<union> lowlink_set s u\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "hence ll_sub_rev': \"?L' \\<subseteq> ?L \\<union> ?Lu\""], ["proof (prove)\nusing this:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> lowlink_set s w \\<union> lowlink_set s u\n\ngoal (1 subgoal):\n 1. \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n    \\<subseteq> \\<delta> s ` lowlink_set s w \\<union>\n                \\<delta> s ` lowlink_set s u", "by auto"], ["proof (state)\nthis:\n  \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> \\<delta> s ` lowlink_set s w \\<union>\n              \\<delta> s ` lowlink_set s u\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have ref_ne: \"stack ?s \\<noteq> [] \\<Longrightarrow> \n             lowlink ?s = (lowlink s)(hd (stack ?s) \\<mapsto> min (\\<zeta> s (hd (stack ?s))) (\\<zeta> s u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s\n    (hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<mapsto>\n    min (\\<zeta> s (hd (stack (s'\\<lparr>state.more := x\\<rparr>))))\n     (\\<zeta> s u))", "apply (rule TRANS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    tarjan_fin u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         lowlink (s'\\<lparr>state.more := a\\<rparr>) = lowlink s\n         (hd (stack (s'\\<lparr>state.more := a\\<rparr>)) \\<mapsto>\n         min (\\<zeta> s (hd (stack (s'\\<lparr>state.more := a\\<rparr>))))\n          (\\<zeta> s u)))", "unfolding tarjan_fin_def tj_stack_pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    (let ll = if stack s' = [] then lowlink s'\n              else let ua = hd (stack s')\n                   in lowlink s'(ua \\<mapsto>\n                      min (\\<zeta> s' ua) (\\<zeta> s' u));\n         s'a = s'\\<lparr>lowlink := ll\\<rparr>\n     in ASSERT (u \\<in> set (tj_stack s')) \\<bind>\n        (\\<lambda>_.\n            ASSERT (distinct (tj_stack s')) \\<bind>\n            (\\<lambda>_.\n                if \\<zeta> s' u = \\<delta> s' u\n                then ASSERT (scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_.\n                         RETURN\n                          (tl (dropWhile ((\\<noteq>) u) (tj_stack s')),\n                           insert u\n                            (set (takeWhile ((\\<noteq>) u)\n                                   (tj_stack s')))) \\<bind>\n                         (\\<lambda>(tjs, scc).\n                             NOOP\n                              (s'a\\<lparr>tj_stack := tjs,\n                                     sccs := insert scc (sccs s')\\<rparr>)))\n                else ASSERT (\\<not> scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_. NOOP s'a)))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         lowlink (s'\\<lparr>state.more := a\\<rparr>) = lowlink s\n         (hd (stack (s'\\<lparr>state.more := a\\<rparr>)) \\<mapsto>\n         min (\\<zeta> s (hd (stack (s'\\<lparr>state.more := a\\<rparr>))))\n          (\\<zeta> s u)))", "by refine_vcg simp_all"], ["proof (state)\nthis:\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n  lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s\n  (hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<mapsto>\n  min (\\<zeta> s (hd (stack (s'\\<lparr>state.more := x\\<rparr>))))\n   (\\<zeta> s u))\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have ref_e: \"stack ?s = [] \\<Longrightarrow> lowlink ?s = lowlink s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) = [] \\<Longrightarrow>\n    lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s", "apply (rule TRANS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) = [] \\<Longrightarrow>\n    tarjan_fin u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a. lowlink (s'\\<lparr>state.more := a\\<rparr>) = lowlink s)", "unfolding tarjan_fin_def tj_stack_pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) = [] \\<Longrightarrow>\n    (let ll = if stack s' = [] then lowlink s'\n              else let ua = hd (stack s')\n                   in lowlink s'(ua \\<mapsto>\n                      min (\\<zeta> s' ua) (\\<zeta> s' u));\n         s'a = s'\\<lparr>lowlink := ll\\<rparr>\n     in ASSERT (u \\<in> set (tj_stack s')) \\<bind>\n        (\\<lambda>_.\n            ASSERT (distinct (tj_stack s')) \\<bind>\n            (\\<lambda>_.\n                if \\<zeta> s' u = \\<delta> s' u\n                then ASSERT (scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_.\n                         RETURN\n                          (tl (dropWhile ((\\<noteq>) u) (tj_stack s')),\n                           insert u\n                            (set (takeWhile ((\\<noteq>) u)\n                                   (tj_stack s')))) \\<bind>\n                         (\\<lambda>(tjs, scc).\n                             NOOP\n                              (s'a\\<lparr>tj_stack := tjs,\n                                     sccs := insert scc (sccs s')\\<rparr>)))\n                else ASSERT (\\<not> scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_. NOOP s'a)))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a. lowlink (s'\\<lparr>state.more := a\\<rparr>) = lowlink s)", "by refine_vcg simp_all"], ["proof (state)\nthis:\n  stack (s'\\<lparr>state.more := x\\<rparr>) = [] \\<Longrightarrow>\n  lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have ref_tj: \"\\<zeta> s u \\<noteq> \\<delta> s u \\<Longrightarrow> tj_stack ?s = tj_stack s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> s u \\<noteq> \\<delta> s u \\<Longrightarrow>\n    tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s", "apply (rule TRANS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> s u \\<noteq> \\<delta> s u \\<Longrightarrow>\n    tarjan_fin u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a. tj_stack (s'\\<lparr>state.more := a\\<rparr>) = tj_stack s)", "unfolding tarjan_fin_def tj_stack_pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> s u \\<noteq> \\<delta> s u \\<Longrightarrow>\n    (let ll = if stack s' = [] then lowlink s'\n              else let ua = hd (stack s')\n                   in lowlink s'(ua \\<mapsto>\n                      min (\\<zeta> s' ua) (\\<zeta> s' u));\n         s'a = s'\\<lparr>lowlink := ll\\<rparr>\n     in ASSERT (u \\<in> set (tj_stack s')) \\<bind>\n        (\\<lambda>_.\n            ASSERT (distinct (tj_stack s')) \\<bind>\n            (\\<lambda>_.\n                if \\<zeta> s' u = \\<delta> s' u\n                then ASSERT (scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_.\n                         RETURN\n                          (tl (dropWhile ((\\<noteq>) u) (tj_stack s')),\n                           insert u\n                            (set (takeWhile ((\\<noteq>) u)\n                                   (tj_stack s')))) \\<bind>\n                         (\\<lambda>(tjs, scc).\n                             NOOP\n                              (s'a\\<lparr>tj_stack := tjs,\n                                     sccs := insert scc (sccs s')\\<rparr>)))\n                else ASSERT (\\<not> scc_root s' u (scc_of E u)) \\<bind>\n                     (\\<lambda>_. NOOP s'a)))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a. tj_stack (s'\\<lparr>state.more := a\\<rparr>) = tj_stack s)", "by refine_vcg simp_all"], ["proof (state)\nthis:\n  \\<zeta> s u \\<noteq> \\<delta> s u \\<Longrightarrow>\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "have \"\\<zeta> ?s w = LowLink ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "proof (cases \"w = hd (stack ?s) \\<and> stack ?s \\<noteq> []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n    stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "case True"], ["proof (state)\nthis:\n  w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n\ngoal (2 subgoals):\n 1. w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n    stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "note all_True = this"], ["proof (state)\nthis:\n  w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n\ngoal (2 subgoals):\n 1. w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n    stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "with ref_ne"], ["proof (chain)\npicking this:\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n  lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s\n  (hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<mapsto>\n  min (\\<zeta> s (hd (stack (s'\\<lparr>state.more := x\\<rparr>))))\n   (\\<zeta> s u))\n  w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []", "have *: \"\\<zeta> ?s w = min (\\<zeta> s w) (\\<zeta> s u)\""], ["proof (prove)\nusing this:\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n  lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s\n  (hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<mapsto>\n  min (\\<zeta> s (hd (stack (s'\\<lparr>state.more := x\\<rparr>))))\n   (\\<zeta> s u))\n  w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    min (\\<zeta> s w) (\\<zeta> s u)", "by simp"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  min (\\<zeta> s w) (\\<zeta> s u)\n\ngoal (2 subgoals):\n 1. w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n    stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "proof (cases \"\\<zeta> s u < \\<zeta> s w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<zeta> s u < \\<zeta> s w\n\ngoal (2 subgoals):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "with * finish w_disc"], ["proof (chain)\npicking this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  min (\\<zeta> s w) (\\<zeta> s u)\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  \\<not> \\<zeta> s u < \\<zeta> s w", "have \"\\<zeta> ?s w = LowLink s w\""], ["proof (prove)\nusing this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  min (\\<zeta> s w) (\\<zeta> s u)\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  \\<not> \\<zeta> s u < \\<zeta> s w\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> s ` lowlink_set s w)", "by simp"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> s ` lowlink_set s w)\n\ngoal (2 subgoals):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> s ` lowlink_set s w)\n\ngoal (2 subgoals):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "have \"LowLink s w = LowLink ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w) =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "proof (rule LowLink_eqI[OF inv' _ ll_sub ll_sub_rev])"], ["proof (state)\ngoal (3 subgoals):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)\n 2. w \\<in> dom (discovered s)\n 3. \\<And>xa.\n       \\<lbrakk>xa \\<in> lowlink_set s u;\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "from w_disc"], ["proof (chain)\npicking this:\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))", "show \"w \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. w \\<in> dom (discovered s)", "by simp"], ["proof (state)\nthis:\n  w \\<in> dom (discovered s)\n\ngoal (2 subgoals):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> lowlink_set s u;\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "fix ll"], ["proof (state)\ngoal (2 subgoals):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> lowlink_set s u;\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "assume \"ll \\<in> lowlink_set s u\""], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s u\n\ngoal (2 subgoals):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> lowlink_set s u;\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "hence \"LowLink s u \\<le> \\<delta> s ll\""], ["proof (prove)\nusing this:\n  ll \\<in> lowlink_set s u\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u) \\<le> \\<delta> s ll", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s u) \\<le> \\<delta> s ll\n\ngoal (2 subgoals):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> lowlink_set s u;\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "moreover"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s u) \\<le> \\<delta> s ll\n\ngoal (2 subgoals):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> lowlink_set s u;\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "from False finish w_disc u_disc"], ["proof (chain)\npicking this:\n  \\<not> \\<zeta> s u < \\<zeta> s w\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  u \\<in> dom (discovered s)", "have \"LowLink s w \\<le> LowLink s u\""], ["proof (prove)\nusing this:\n  \\<not> \\<zeta> s u < \\<zeta> s w\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> Min (\\<delta> s ` lowlink_set s u)", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> Min (\\<delta> s ` lowlink_set s u)\n\ngoal (2 subgoals):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> lowlink_set s u;\n        xa \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\\<rbrakk>\n       \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w)\n                         \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>)\n                                xa", "ultimately"], ["proof (chain)\npicking this:\n  Min (\\<delta> s ` lowlink_set s u) \\<le> \\<delta> s ll\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> Min (\\<delta> s ` lowlink_set s u)", "show \"LowLink s w \\<le> \\<delta> ?s ll\""], ["proof (prove)\nusing this:\n  Min (\\<delta> s ` lowlink_set s u) \\<le> \\<delta> s ll\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> Min (\\<delta> s ` lowlink_set s u)\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w)\n    \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ll", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w)\n  \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ll\n\ngoal (1 subgoal):\n 1. discovered s \\<subseteq>\\<^sub>m\n    discovered (s'\\<lparr>state.more := x\\<rparr>)", "qed simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w) =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (2 subgoals):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n 2. \\<not> \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "finally"], ["proof (chain)\npicking this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "."], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "case True"], ["proof (state)\nthis:\n  \\<zeta> s u < \\<zeta> s w\n\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "note \\<zeta>rel = this"], ["proof (state)\nthis:\n  \\<zeta> s u < \\<zeta> s w\n\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "have \"LowLink s u \\<in> ?L'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u)\n    \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u)\n    \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "from all_True finish"], ["proof (chain)\npicking this:\n  w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "have w_tl: \"w\\<in>set (tl (stack s))\""], ["proof (prove)\nusing this:\n  w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. w \\<in> set (tl (stack s))", "by auto"], ["proof (state)\nthis:\n  w \\<in> set (tl (stack s))\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u)\n    \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "obtain ll where ll: \"ll \\<in> lowlink_set s u\" \"\\<delta> s ll = LowLink s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ll.\n        \\<lbrakk>ll \\<in> lowlink_set s u;\n         \\<delta> s ll = Min (\\<delta> s ` lowlink_set s u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Min_in[of ?Lu] lowlink_set_finite lowlink_set_not_empty u_disc"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (\\<delta> s ` lowlink_set s u);\n   \\<delta> s ` lowlink_set s u \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s u)\n                    \\<in> \\<delta> s ` lowlink_set s u\n  finite (lowlink_set s ?v)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> lowlink_set s ?v \\<noteq> {}\n  u \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. (\\<And>ll.\n        \\<lbrakk>ll \\<in> lowlink_set s u;\n         \\<delta> s ll = Min (\\<delta> s ` lowlink_set s u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set s u\n  \\<delta> s ll = Min (\\<delta> s ` lowlink_set s u)\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u)\n    \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "have \"ll \\<in> lowlink_set ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "proof (cases \"\\<delta> s u = \\<zeta> s u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> s u = \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 2. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "case True"], ["proof (state)\nthis:\n  \\<delta> s u = \\<zeta> s u\n\ngoal (2 subgoals):\n 1. \\<delta> s u = \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 2. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "moreover"], ["proof (state)\nthis:\n  \\<delta> s u = \\<zeta> s u\n\ngoal (2 subgoals):\n 1. \\<delta> s u = \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 2. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "from w_tl finish tl_lt_stack_hd_discover"], ["proof (chain)\npicking this:\n  w \\<in> set (tl (stack s))\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<lbrakk>stack s \\<noteq> []; ?x \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?x < \\<delta> s (hd (stack s))", "have \"\\<delta> s w < \\<delta> s u\""], ["proof (prove)\nusing this:\n  w \\<in> set (tl (stack s))\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<lbrakk>stack s \\<noteq> []; ?x \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s ?x < \\<delta> s (hd (stack s))\n\ngoal (1 subgoal):\n 1. \\<delta> s w < \\<delta> s u", "by simp"], ["proof (state)\nthis:\n  \\<delta> s w < \\<delta> s u\n\ngoal (2 subgoals):\n 1. \\<delta> s u = \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 2. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "moreover"], ["proof (state)\nthis:\n  \\<delta> s w < \\<delta> s u\n\ngoal (2 subgoals):\n 1. \\<delta> s u = \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 2. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "from w_disc"], ["proof (chain)\npicking this:\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))", "have \"LowLink s w \\<le> \\<delta> s w\""], ["proof (prove)\nusing this:\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w", "by (simp add: LowLink_le_disc)"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w\n\ngoal (2 subgoals):\n 1. \\<delta> s u = \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 2. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "with w_disc finish"], ["proof (chain)\npicking this:\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w", "have \"\\<zeta> s w \\<le> \\<delta> s w\""], ["proof (prove)\nusing this:\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  Min (\\<delta> s ` lowlink_set s w) \\<le> \\<delta> s w\n\ngoal (1 subgoal):\n 1. \\<zeta> s w \\<le> \\<delta> s w", "by simp"], ["proof (state)\nthis:\n  \\<zeta> s w \\<le> \\<delta> s w\n\ngoal (2 subgoals):\n 1. \\<delta> s u = \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 2. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "moreover"], ["proof (state)\nthis:\n  \\<zeta> s w \\<le> \\<delta> s w\n\ngoal (2 subgoals):\n 1. \\<delta> s u = \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 2. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "note \\<zeta>rel"], ["proof (state)\nthis:\n  \\<zeta> s u < \\<zeta> s w\n\ngoal (2 subgoals):\n 1. \\<delta> s u = \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 2. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta> s u = \\<zeta> s u\n  \\<delta> s w < \\<delta> s u\n  \\<zeta> s w \\<le> \\<delta> s w\n  \\<zeta> s u < \\<zeta> s w", "have False"], ["proof (prove)\nusing this:\n  \\<delta> s u = \\<zeta> s u\n  \\<delta> s w < \\<delta> s u\n  \\<zeta> s w \\<le> \\<delta> s w\n  \\<zeta> s u < \\<zeta> s w\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<delta> s u = \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n 2. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", ".."], ["proof (state)\nthis:\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "case False"], ["proof (state)\nthis:\n  \\<delta> s u \\<noteq> \\<zeta> s u\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "with u_disc finish ll"], ["proof (chain)\npicking this:\n  u \\<in> dom (discovered s)\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  ll \\<in> lowlink_set s u\n  \\<delta> s ll = Min (\\<delta> s ` lowlink_set s u)\n  \\<delta> s u \\<noteq> \\<zeta> s u", "have \"u \\<noteq> ll\""], ["proof (prove)\nusing this:\n  u \\<in> dom (discovered s)\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  ll \\<in> lowlink_set s u\n  \\<delta> s ll = Min (\\<delta> s ` lowlink_set s u)\n  \\<delta> s u \\<noteq> \\<zeta> s u\n\ngoal (1 subgoal):\n 1. u \\<noteq> ll", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> ll\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "with ll"], ["proof (chain)\npicking this:\n  ll \\<in> lowlink_set s u\n  \\<delta> s ll = Min (\\<delta> s ` lowlink_set s u)\n  u \\<noteq> ll", "have\n                  e: \"(ll,u) \\<in> E\\<^sup>+\" \"(u,ll) \\<in> E\\<^sup>+\" and\n                  p: \"\\<exists>p. lowlink_path s u p ll\" and\n                  ll_disc: \"ll \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  ll \\<in> lowlink_set s u\n  \\<delta> s ll = Min (\\<delta> s ` lowlink_set s u)\n  u \\<noteq> ll\n\ngoal (1 subgoal):\n 1. ((ll, u) \\<in> E\\<^sup>+ &&& (u, ll) \\<in> E\\<^sup>+) &&&\n    \\<exists>p. lowlink_path s u p ll &&& ll \\<in> dom (discovered s)", "by (auto simp: lowlink_set_def)"], ["proof (state)\nthis:\n  (ll, u) \\<in> E\\<^sup>+\n  (u, ll) \\<in> E\\<^sup>+\n  \\<exists>p. lowlink_path s u p ll\n  ll \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "from p"], ["proof (chain)\npicking this:\n  \\<exists>p. lowlink_path s u p ll", "have p': \"\\<exists>p. lowlink_path ?s u p ll\""], ["proof (prove)\nusing this:\n  \\<exists>p. lowlink_path s u p ll\n\ngoal (1 subgoal):\n 1. \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) u p ll", "unfolding lowlink_path_def"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     path E u p ll \\<and>\n     p \\<noteq> [] \\<and>\n     (last p, ll) \\<in> cross_edges s \\<union> back_edges s \\<and>\n     (1 < length p \\<longrightarrow>\n      p ! 1 \\<in> dom (finished s) \\<and>\n      (\\<forall>k<length p - 1. (p ! k, p ! Suc k) \\<in> tree_edges s))\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path E u p ll \\<and>\n       p \\<noteq> [] \\<and>\n       (last p, ll)\n       \\<in> cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n             back_edges (s'\\<lparr>state.more := x\\<rparr>) \\<and>\n       (1 < length p \\<longrightarrow>\n        p ! 1\n        \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n        (\\<forall>k<length p - 1.\n            (p ! k, p ! Suc k)\n            \\<in> tree_edges (s'\\<lparr>state.more := x\\<rparr>)))", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) u p ll\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "from w_tl tl_stack_hd_tree_path finish"], ["proof (chain)\npicking this:\n  w \\<in> set (tl (stack s))\n  \\<lbrakk>stack s \\<noteq> []; ?v \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "have T: \"(w,u) \\<in> (tree_edges ?s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  w \\<in> set (tl (stack s))\n  \\<lbrakk>stack s \\<noteq> []; ?v \\<in> set (tl (stack s))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack s)) \\<in> (tree_edges s)\\<^sup>+\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. (w, u) \\<in> (tree_edges (s'\\<lparr>state.more := x\\<rparr>))\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (w, u) \\<in> (tree_edges (s'\\<lparr>state.more := x\\<rparr>))\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "with s'.lowlink_path_tree_prepend all_True p'"], ["proof (chain)\npicking this:\n  \\<lbrakk>lowlink_path (s'\\<lparr>state.more := x\\<rparr>) ?v ?p ?w;\n   (?u, ?v) \\<in> (tree_edges (s'\\<lparr>state.more := x\\<rparr>))\\<^sup>+;\n   ?u \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<or>\n   stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<and>\n   ?u = hd (stack (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       lowlink_path (s'\\<lparr>state.more := x\\<rparr>) ?u p\n                        ?w\n  w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n  \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) u p ll\n  (w, u) \\<in> (tree_edges (s'\\<lparr>state.more := x\\<rparr>))\\<^sup>+", "have \"\\<exists>p. lowlink_path ?s w p ll\""], ["proof (prove)\nusing this:\n  \\<lbrakk>lowlink_path (s'\\<lparr>state.more := x\\<rparr>) ?v ?p ?w;\n   (?u, ?v) \\<in> (tree_edges (s'\\<lparr>state.more := x\\<rparr>))\\<^sup>+;\n   ?u \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<or>\n   stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<and>\n   ?u = hd (stack (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       lowlink_path (s'\\<lparr>state.more := x\\<rparr>) ?u p\n                        ?w\n  w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n  \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) u p ll\n  (w, u) \\<in> (tree_edges (s'\\<lparr>state.more := x\\<rparr>))\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll", "by blast"], ["proof (state)\nthis:\n  \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "moreover"], ["proof (state)\nthis:\n  \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "from T trancl_mono_mp[OF s'.tree_edges_ssE]"], ["proof (chain)\npicking this:\n  (w, u) \\<in> (tree_edges (s'\\<lparr>state.more := x\\<rparr>))\\<^sup>+\n  ?x \\<in> (tree_edges\n             (s'\\<lparr>state.more := x\\<rparr>))\\<^sup>+ \\<Longrightarrow>\n  ?x \\<in> E\\<^sup>+", "have \"(w,u) \\<in> E\\<^sup>+\""], ["proof (prove)\nusing this:\n  (w, u) \\<in> (tree_edges (s'\\<lparr>state.more := x\\<rparr>))\\<^sup>+\n  ?x \\<in> (tree_edges\n             (s'\\<lparr>state.more := x\\<rparr>))\\<^sup>+ \\<Longrightarrow>\n  ?x \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. (w, u) \\<in> E\\<^sup>+", "by blast"], ["proof (state)\nthis:\n  (w, u) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "with e"], ["proof (chain)\npicking this:\n  (ll, u) \\<in> E\\<^sup>+\n  (u, ll) \\<in> E\\<^sup>+\n  (w, u) \\<in> E\\<^sup>+", "have \"(w,ll) \\<in> E\\<^sup>+\""], ["proof (prove)\nusing this:\n  (ll, u) \\<in> E\\<^sup>+\n  (u, ll) \\<in> E\\<^sup>+\n  (w, u) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. (w, ll) \\<in> E\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (w, ll) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "moreover"], ["proof (state)\nthis:\n  (w, ll) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "{"], ["proof (state)\nthis:\n  (w, ll) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "note e(1)"], ["proof (state)\nthis:\n  (ll, u) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "also"], ["proof (state)\nthis:\n  (ll, u) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "from finish False ref_tj"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<delta> s u \\<noteq> \\<zeta> s u\n  \\<zeta> s u \\<noteq> \\<delta> s u \\<Longrightarrow>\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s", "have \"tj_stack ?s = tj_stack s\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<delta> s u \\<noteq> \\<zeta> s u\n  \\<zeta> s u \\<noteq> \\<delta> s u \\<Longrightarrow>\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s\n\ngoal (1 subgoal):\n 1. tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s", "by simp"], ["proof (state)\nthis:\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "with hd_in_set finish stack_ss_tj_stack"], ["proof (chain)\npicking this:\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  set (stack s) \\<subseteq> set (tj_stack s)\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s", "have \"u \\<in> set (tj_stack ?s)\""], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  set (stack s) \\<subseteq> set (tj_stack s)\n  tj_stack (s'\\<lparr>state.more := x\\<rparr>) = tj_stack s\n\ngoal (1 subgoal):\n 1. u \\<in> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "by auto"], ["proof (state)\nthis:\n  u \\<in> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "with s'.tj_stack_reach_stack"], ["proof (chain)\npicking this:\n  ?u \\<in> set (tj_stack\n                 (s'\\<lparr>state.more := x\\<rparr>)) \\<Longrightarrow>\n  \\<exists>v\\<in>set (stack (s'\\<lparr>state.more := x\\<rparr>)).\n     (?u, v) \\<in> E\\<^sup>* \\<and>\n     \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n     \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ?u\n  u \\<in> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))", "obtain x where x: \"x \\<in> set (stack ?s)\" \"(u,x) \\<in> E\\<^sup>*\""], ["proof (prove)\nusing this:\n  ?u \\<in> set (tj_stack\n                 (s'\\<lparr>state.more := x\\<rparr>)) \\<Longrightarrow>\n  \\<exists>v\\<in>set (stack (s'\\<lparr>state.more := x\\<rparr>)).\n     (?u, v) \\<in> E\\<^sup>* \\<and>\n     \\<delta> (s'\\<lparr>state.more := x\\<rparr>) v\n     \\<le> \\<delta> (s'\\<lparr>state.more := x\\<rparr>) ?u\n  u \\<in> set (tj_stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. (\\<And>xa.\n        \\<lbrakk>xa \\<in> set (stack (s'\\<lparr>state.more := x\\<rparr>));\n         (u, xa) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> set (stack (s'\\<lparr>state.more := x__\\<rparr>))\n  (u, x) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x__\\<rparr>) w", "note this(2)"], ["proof (state)\nthis:\n  (u, x) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x__\\<rparr>) w", "also"], ["proof (state)\nthis:\n  (u, x) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x__\\<rparr>) w", "have \"(x,w) \\<in> E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, w) \\<in> E\\<^sup>*", "proof (rule rtrancl_eq_or_trancl[THEN iffD2], safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> w \\<Longrightarrow> (x, w) \\<in> E\\<^sup>+", "assume \"x \\<noteq> w\""], ["proof (state)\nthis:\n  x \\<noteq> w\n\ngoal (1 subgoal):\n 1. x \\<noteq> w \\<Longrightarrow> (x, w) \\<in> E\\<^sup>+", "with all_True x"], ["proof (chain)\npicking this:\n  w = hd (stack (s'\\<lparr>state.more := x__\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x__\\<rparr>) \\<noteq> []\n  x \\<in> set (stack (s'\\<lparr>state.more := x__\\<rparr>))\n  (u, x) \\<in> E\\<^sup>*\n  x \\<noteq> w", "have \"x \\<in> set (tl (stack ?s))\""], ["proof (prove)\nusing this:\n  w = hd (stack (s'\\<lparr>state.more := x__\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x__\\<rparr>) \\<noteq> []\n  x \\<in> set (stack (s'\\<lparr>state.more := x__\\<rparr>))\n  (u, x) \\<in> E\\<^sup>*\n  x \\<noteq> w\n\ngoal (1 subgoal):\n 1. x \\<in> set (tl (stack (s'\\<lparr>state.more := x__\\<rparr>)))", "by (cases \"stack ?s\") auto"], ["proof (state)\nthis:\n  x \\<in> set (tl (stack (s'\\<lparr>state.more := x__\\<rparr>)))\n\ngoal (1 subgoal):\n 1. x \\<noteq> w \\<Longrightarrow> (x, w) \\<in> E\\<^sup>+", "with s'.tl_stack_hd_tree_path all_True"], ["proof (chain)\npicking this:\n  \\<lbrakk>stack (s'\\<lparr>state.more := x__\\<rparr>) \\<noteq> [];\n   ?v \\<in> set (tl (stack (s'\\<lparr>state.more := x__\\<rparr>)))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack (s'\\<lparr>state.more := x__\\<rparr>)))\n                    \\<in> (tree_edges\n                            (s'\\<lparr>state.more := x__\\<rparr>))\\<^sup>+\n  w = hd (stack (s'\\<lparr>state.more := x__\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x__\\<rparr>) \\<noteq> []\n  x \\<in> set (tl (stack (s'\\<lparr>state.more := x__\\<rparr>)))", "have \"(x,w) \\<in> (tree_edges s)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<lbrakk>stack (s'\\<lparr>state.more := x__\\<rparr>) \\<noteq> [];\n   ?v \\<in> set (tl (stack (s'\\<lparr>state.more := x__\\<rparr>)))\\<rbrakk>\n  \\<Longrightarrow> (?v, hd (stack (s'\\<lparr>state.more := x__\\<rparr>)))\n                    \\<in> (tree_edges\n                            (s'\\<lparr>state.more := x__\\<rparr>))\\<^sup>+\n  w = hd (stack (s'\\<lparr>state.more := x__\\<rparr>)) \\<and>\n  stack (s'\\<lparr>state.more := x__\\<rparr>) \\<noteq> []\n  x \\<in> set (tl (stack (s'\\<lparr>state.more := x__\\<rparr>)))\n\ngoal (1 subgoal):\n 1. (x, w) \\<in> (tree_edges s)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (x, w) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. x \\<noteq> w \\<Longrightarrow> (x, w) \\<in> E\\<^sup>+", "with trancl_mono_mp[OF tree_edges_ssE]"], ["proof (chain)\npicking this:\n  ?x \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow> ?x \\<in> E\\<^sup>+\n  (x, w) \\<in> (tree_edges s)\\<^sup>+", "show \"(x,w) \\<in> E\\<^sup>+\""], ["proof (prove)\nusing this:\n  ?x \\<in> (tree_edges s)\\<^sup>+ \\<Longrightarrow> ?x \\<in> E\\<^sup>+\n  (x, w) \\<in> (tree_edges s)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, w) \\<in> E\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (x, w) \\<in> E\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, w) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x__\\<rparr>) w", "finally"], ["proof (chain)\npicking this:\n  (ll, w) \\<in> E\\<^sup>+", "have \"(ll,w) \\<in> E\\<^sup>+\""], ["proof (prove)\nusing this:\n  (ll, w) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. (ll, w) \\<in> E\\<^sup>+", "."], ["proof (state)\nthis:\n  (ll, w) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x__\\<rparr>) w", "}"], ["proof (state)\nthis:\n  (ll, w) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "moreover"], ["proof (state)\nthis:\n  (ll, w) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "note ll_disc"], ["proof (state)\nthis:\n  ll \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<noteq> \\<zeta> s u \\<Longrightarrow>\n    ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n  (w, ll) \\<in> E\\<^sup>+\n  (ll, w) \\<in> E\\<^sup>+\n  ll \\<in> dom (discovered s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>p. lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p ll\n  (w, ll) \\<in> E\\<^sup>+\n  (ll, w) \\<in> E\\<^sup>+\n  ll \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "by (simp add: lowlink_set_def)"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u)\n    \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "hence \"\\<delta> s ll \\<in> ?L'\""], ["proof (prove)\nusing this:\n  ll \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. \\<delta> s ll\n    \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "by auto"], ["proof (state)\nthis:\n  \\<delta> s ll\n  \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u)\n    \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "with ll"], ["proof (chain)\npicking this:\n  ll \\<in> lowlink_set s u\n  \\<delta> s ll = Min (\\<delta> s ` lowlink_set s u)\n  \\<delta> s ll\n  \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "show ?thesis"], ["proof (prove)\nusing this:\n  ll \\<in> lowlink_set s u\n  \\<delta> s ll = Min (\\<delta> s ` lowlink_set s u)\n  \\<delta> s ll\n  \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u)\n    \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s u)\n  \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s u)\n  \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "hence \"LowLink ?s w \\<le> LowLink s u\""], ["proof (prove)\nusing this:\n  Min (\\<delta> s ` lowlink_set s u)\n  \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n    \\<le> Min (\\<delta> s ` lowlink_set s u)", "using Min_le_iff[of ?L'] s'.lowlink_set_not_empty w_disc s'.lowlink_set_finite"], ["proof (prove)\nusing this:\n  Min (\\<delta> s ` lowlink_set s u)\n  \\<in> \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<lbrakk>finite\n            (\\<delta> s `\n             lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w);\n   \\<delta> s ` lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w \\<noteq>\n   {}\\<rbrakk>\n  \\<Longrightarrow> (Min (\\<delta> s `\n                          lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n                     \\<le> ?x) =\n                    (\\<exists>a\\<in>\\<delta> s `\n                                    lowlink_set\n                                     (s'\\<lparr>state.more := x\\<rparr>) w.\n                        a \\<le> ?x)\n  ?v \\<in> dom (discovered\n                 (s'\\<lparr>state.more := x\\<rparr>)) \\<Longrightarrow>\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) ?v \\<noteq> {}\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  finite (lowlink_set (s'\\<lparr>state.more := x\\<rparr>) ?v)\n\ngoal (1 subgoal):\n 1. Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n    \\<le> Min (\\<delta> s ` lowlink_set s u)", "by fastforce"], ["proof (state)\nthis:\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n  \\<le> Min (\\<delta> s ` lowlink_set s u)\n\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n  \\<le> Min (\\<delta> s ` lowlink_set s u)\n\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "from True u_disc w_disc finish"], ["proof (chain)\npicking this:\n  \\<zeta> s u < \\<zeta> s w\n  u \\<in> dom (discovered s)\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "have \"LowLink s u < LowLink s w\""], ["proof (prove)\nusing this:\n  \\<zeta> s u < \\<zeta> s w\n  u \\<in> dom (discovered s)\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u) < Min (\\<delta> s ` lowlink_set s w)", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s u) < Min (\\<delta> s ` lowlink_set s w)\n\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "hence \"Min (?L \\<union> ?Lu) = LowLink s u\""], ["proof (prove)\nusing this:\n  Min (\\<delta> s ` lowlink_set s u) < Min (\\<delta> s ` lowlink_set s w)\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w \\<union>\n         \\<delta> s ` lowlink_set s u) =\n    Min (\\<delta> s ` lowlink_set s u)", "using Min_Un[of ?L ?Lu] lowlink_set_finite lowlink_set_not_empty u_disc w_disc"], ["proof (prove)\nusing this:\n  Min (\\<delta> s ` lowlink_set s u) < Min (\\<delta> s ` lowlink_set s w)\n  \\<lbrakk>finite (\\<delta> s ` lowlink_set s w);\n   \\<delta> s ` lowlink_set s w \\<noteq> {};\n   finite (\\<delta> s ` lowlink_set s u);\n   \\<delta> s ` lowlink_set s u \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w \\<union>\n                         \\<delta> s ` lowlink_set s u) =\n                    min (Min (\\<delta> s ` lowlink_set s w))\n                     (Min (\\<delta> s ` lowlink_set s u))\n  finite (lowlink_set s ?v)\n  ?v \\<in> dom (discovered s) \\<Longrightarrow> lowlink_set s ?v \\<noteq> {}\n  u \\<in> dom (discovered s)\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w \\<union>\n         \\<delta> s ` lowlink_set s u) =\n    Min (\\<delta> s ` lowlink_set s u)", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w \\<union> \\<delta> s ` lowlink_set s u) =\n  Min (\\<delta> s ` lowlink_set s u)\n\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "hence \"LowLink s u \\<le> LowLink ?s w\""], ["proof (prove)\nusing this:\n  Min (\\<delta> s ` lowlink_set s w \\<union> \\<delta> s ` lowlink_set s u) =\n  Min (\\<delta> s ` lowlink_set s u)\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u)\n    \\<le> Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n               lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "using Min_antimono[OF ll_sub_rev'] lowlink_set_finite s'.lowlink_set_not_empty w_disc"], ["proof (prove)\nusing this:\n  Min (\\<delta> s ` lowlink_set s w \\<union> \\<delta> s ` lowlink_set s u) =\n  Min (\\<delta> s ` lowlink_set s u)\n  \\<lbrakk>\\<delta> s `\n           lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w \\<noteq>\n           {};\n   finite\n    (\\<delta> s ` lowlink_set s w \\<union>\n     \\<delta> s ` lowlink_set s u)\\<rbrakk>\n  \\<Longrightarrow> Min (\\<delta> s ` lowlink_set s w \\<union>\n                         \\<delta> s ` lowlink_set s u)\n                    \\<le> Min (\\<delta> s `\n                               lowlink_set\n                                (s'\\<lparr>state.more := x\\<rparr>) w)\n  finite (lowlink_set s ?v)\n  ?v \\<in> dom (discovered\n                 (s'\\<lparr>state.more := x\\<rparr>)) \\<Longrightarrow>\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) ?v \\<noteq> {}\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u)\n    \\<le> Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n               lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "by auto"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s u)\n  \\<le> Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n             lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s u)\n  \\<le> Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n             lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "from True u_disc finish *"], ["proof (chain)\npicking this:\n  \\<zeta> s u < \\<zeta> s w\n  u \\<in> dom (discovered s)\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  min (\\<zeta> s w) (\\<zeta> s u)", "have \"LowLink s u = \\<zeta> ?s w\""], ["proof (prove)\nusing this:\n  \\<zeta> s u < \\<zeta> s w\n  u \\<in> dom (discovered s)\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  min (\\<zeta> s w) (\\<zeta> s u)\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s u) =\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s u) =\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. \\<zeta> s u < \\<zeta> s w \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "finally"], ["proof (chain)\npicking this:\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w) =\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w", "show ?thesis"], ["proof (prove)\nusing this:\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w) =\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", ".."], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "case False"], ["proof (state)\nthis:\n  \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n          stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [])\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "note all_False = this"], ["proof (state)\nthis:\n  \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n          stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [])\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "have \"\\<zeta> ?s w = \\<zeta> s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "proof (cases \"stack ?s = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) = [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n 2. stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "case True"], ["proof (state)\nthis:\n  stack (s'\\<lparr>state.more := x\\<rparr>) = []\n\ngoal (2 subgoals):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) = [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n 2. stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "with ref_e"], ["proof (chain)\npicking this:\n  stack (s'\\<lparr>state.more := x\\<rparr>) = [] \\<Longrightarrow>\n  lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s\n  stack (s'\\<lparr>state.more := x\\<rparr>) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  stack (s'\\<lparr>state.more := x\\<rparr>) = [] \\<Longrightarrow>\n  lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s\n  stack (s'\\<lparr>state.more := x\\<rparr>) = []\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "by simp"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n\ngoal (1 subgoal):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "case False"], ["proof (state)\nthis:\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n\ngoal (1 subgoal):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "with all_False"], ["proof (chain)\npicking this:\n  \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n          stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [])\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []", "have \"w \\<noteq> hd (stack ?s)\""], ["proof (prove)\nusing this:\n  \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n          stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [])\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n\ngoal (1 subgoal):\n 1. w \\<noteq> hd (stack (s'\\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  w \\<noteq> hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "with False ref_ne"], ["proof (chain)\npicking this:\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n  lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s\n  (hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<mapsto>\n  min (\\<zeta> s (hd (stack (s'\\<lparr>state.more := x\\<rparr>))))\n   (\\<zeta> s u))\n  w \\<noteq> hd (stack (s'\\<lparr>state.more := x\\<rparr>))", "show ?thesis"], ["proof (prove)\nusing this:\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [] \\<Longrightarrow>\n  lowlink (s'\\<lparr>state.more := x\\<rparr>) = lowlink s\n  (hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<mapsto>\n  min (\\<zeta> s (hd (stack (s'\\<lparr>state.more := x\\<rparr>))))\n   (\\<zeta> s u))\n  w \\<noteq> hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w", "by simp"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w = \\<zeta> s w\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "from finish"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "have \"\\<zeta> s w = LowLink s w\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)", "using w_disc"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  w \\<in> dom (discovered (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)", "by simp"], ["proof (state)\nthis:\n  \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "also"], ["proof (state)\nthis:\n  \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "{"], ["proof (state)\nthis:\n  \\<zeta> s w = Min (\\<delta> s ` lowlink_set s w)\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "assume \"v \\<in> lowlink_set s u\"\n              and *: \"v \\<notin> lowlink_set s w\""], ["proof (state)\nthis:\n  v \\<in> lowlink_set s u\n  v \\<notin> lowlink_set s w\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "hence \"v \\<noteq> w\" \"w\\<noteq>u\""], ["proof (prove)\nusing this:\n  v \\<in> lowlink_set s u\n  v \\<notin> lowlink_set s w\n\ngoal (1 subgoal):\n 1. v \\<noteq> w &&& w \\<noteq> u", "by (auto simp add: lowlink_set_def)"], ["proof (state)\nthis:\n  v \\<noteq> w\n  w \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "have \"v \\<notin> lowlink_set ?s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n             w \\<Longrightarrow>\n    False", "assume v: \"v \\<in> lowlink_set ?s w\""], ["proof (state)\nthis:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n             w \\<Longrightarrow>\n    False", "hence e: \"(v,w) \\<in> E\\<^sup>*\" \"(w,v) \\<in> E\\<^sup>*\"\n                and v_disc: \"v \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. ((v, w) \\<in> E\\<^sup>* &&& (w, v) \\<in> E\\<^sup>*) &&&\n    v \\<in> dom (discovered s)", "by (auto simp add: lowlink_set_def)"], ["proof (state)\nthis:\n  (v, w) \\<in> E\\<^sup>*\n  (w, v) \\<in> E\\<^sup>*\n  v \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n             w \\<Longrightarrow>\n    False", "from v \\<open>v\\<noteq>w\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  v \\<noteq> w", "obtain p where p: \"lowlink_path ?s w p v\""], ["proof (prove)\nusing this:\n  v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p\n         v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: lowlink_set_def)"], ["proof (state)\nthis:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n             w \\<Longrightarrow>\n    False", "hence [simp]: \"p\\<noteq>[]\""], ["proof (prove)\nusing this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by (simp add: lowlink_path_def)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n             w \\<Longrightarrow>\n    False", "from p"], ["proof (chain)\npicking this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v", "have \"hd p = w\""], ["proof (prove)\nusing this:\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n\ngoal (1 subgoal):\n 1. hd p = w", "by (auto simp add: lowlink_path_def path_hd)"], ["proof (state)\nthis:\n  hd p = w\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n             w \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"u \\<in> set p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow> False\n 2. u \\<notin> set p \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  u \\<notin> set p\n\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow> False\n 2. u \\<notin> set p \\<Longrightarrow> False", "hence \"lowlink_path s w p v\""], ["proof (prove)\nusing this:\n  u \\<notin> set p\n\ngoal (1 subgoal):\n 1. lowlink_path s w p v", "using p"], ["proof (prove)\nusing this:\n  u \\<notin> set p\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n\ngoal (1 subgoal):\n 1. lowlink_path s w p v", "by (auto simp add: lowlink_path_def)"], ["proof (state)\nthis:\n  lowlink_path s w p v\n\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow> False\n 2. u \\<notin> set p \\<Longrightarrow> False", "with e v_disc"], ["proof (chain)\npicking this:\n  (v, w) \\<in> E\\<^sup>*\n  (w, v) \\<in> E\\<^sup>*\n  v \\<in> dom (discovered s)\n  lowlink_path s w p v", "have \"v \\<in> lowlink_set s w\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> E\\<^sup>*\n  (w, v) \\<in> E\\<^sup>*\n  v \\<in> dom (discovered s)\n  lowlink_path s w p v\n\ngoal (1 subgoal):\n 1. v \\<in> lowlink_set s w", "by (auto intro: lowlink_setI)"], ["proof (state)\nthis:\n  v \\<in> lowlink_set s w\n\ngoal (2 subgoals):\n 1. u \\<in> set p \\<Longrightarrow> False\n 2. u \\<notin> set p \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  v \\<notin> lowlink_set s w\n  v \\<in> lowlink_set s w", "show False"], ["proof (prove)\nusing this:\n  v \\<notin> lowlink_set s w\n  v \\<in> lowlink_set s w\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  u \\<in> set p\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  u \\<in> set p", "obtain i where i: \"i < length p\" \"p!i = u\""], ["proof (prove)\nusing this:\n  u \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length p; p ! i = u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length p\n  p ! i = u\n\ngoal (1 subgoal):\n 1. u \\<in> set p \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "case \"0\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with i"], ["proof (chain)\npicking this:\n  i < length p\n  p ! i = u\n  i = 0", "have \"hd p = u\""], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = u\n  i = 0\n\ngoal (1 subgoal):\n 1. hd p = u", "by (simp add: hd_conv_nth)"], ["proof (state)\nthis:\n  hd p = u\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with \\<open>hd p = w\\<close> \\<open>w \\<noteq> u\\<close>"], ["proof (chain)\npicking this:\n  hd p = w\n  w \\<noteq> u\n  hd p = u", "show False"], ["proof (prove)\nusing this:\n  hd p = w\n  w \\<noteq> u\n  hd p = u\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "case (Suc n)"], ["proof (state)\nthis:\n  i = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with i p"], ["proof (chain)\npicking this:\n  i < length p\n  p ! i = u\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n  i = Suc n", "have *: \"(p!n,u) \\<in> tree_edges s\" \"n < length p\""], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = u\n  lowlink_path (s'\\<lparr>state.more := x\\<rparr>) w p v\n  i = Suc n\n\ngoal (1 subgoal):\n 1. (p ! n, u) \\<in> tree_edges s &&& n < length p", "unfolding lowlink_path_def"], ["proof (prove)\nusing this:\n  i < length p\n  p ! i = u\n  path E w p v \\<and>\n  p \\<noteq> [] \\<and>\n  (last p, v)\n  \\<in> cross_edges (s'\\<lparr>state.more := x\\<rparr>) \\<union>\n        back_edges (s'\\<lparr>state.more := x\\<rparr>) \\<and>\n  (1 < length p \\<longrightarrow>\n   p ! 1 \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n   (\\<forall>k<length p - 1.\n       (p ! k, p ! Suc k)\n       \\<in> tree_edges (s'\\<lparr>state.more := x\\<rparr>)))\n  i = Suc n\n\ngoal (1 subgoal):\n 1. (p ! n, u) \\<in> tree_edges s &&& n < length p", "by auto"], ["proof (state)\nthis:\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with tree_edge_imp_discovered"], ["proof (chain)\npicking this:\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  (p ! n, u) \\<in> tree_edges s\n  n < length p", "have \"p!n \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?v \\<in> dom (discovered s)\n  (?v, ?w) \\<in> tree_edges s \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n\ngoal (1 subgoal):\n 1. p ! n \\<in> dom (discovered s)", "by auto"], ["proof (state)\nthis:\n  p ! n \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  p ! n \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "from finish hd_in_set stack_not_finished"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)", "have \"u \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  ?x \\<in> set (stack s) \\<Longrightarrow> ?x \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  u \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n  u \\<notin> dom (finished s)", "have pn_n_fin: \"p!n \\<notin> dom (finished s)\""], ["proof (prove)\nusing this:\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n  u \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. p ! n \\<notin> dom (finished s)", "by (metis tree_edge_impl_parenthesis)"], ["proof (state)\nthis:\n  p ! n \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  p ! n \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "from * no_self_loop_in_tree"], ["proof (chain)\npicking this:\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n  (?v, ?v) \\<notin> tree_edges s", "have \"p!n \\<noteq> u\""], ["proof (prove)\nusing this:\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n  (?v, ?v) \\<notin> tree_edges s\n\ngoal (1 subgoal):\n 1. p ! n \\<noteq> u", "by blast"], ["proof (state)\nthis:\n  p ! n \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  p ! n \\<in> dom (discovered s)\n  p ! n \\<notin> dom (finished s)\n  p ! n \\<noteq> u", "have \"p!n \\<in> set (stack ?s)\""], ["proof (prove)\nusing this:\n  p ! n \\<in> dom (discovered s)\n  p ! n \\<notin> dom (finished s)\n  p ! n \\<noteq> u\n\ngoal (1 subgoal):\n 1. p ! n \\<in> set (stack (s'\\<lparr>state.more := x\\<rparr>))", "using stack_set_def finish"], ["proof (prove)\nusing this:\n  p ! n \\<in> dom (discovered s)\n  p ! n \\<notin> dom (finished s)\n  p ! n \\<noteq> u\n  set (stack s) = dom (discovered s) - dom (finished s)\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. p ! n \\<in> set (stack (s'\\<lparr>state.more := x\\<rparr>))", "by (cases \"stack s\") auto"], ["proof (state)\nthis:\n  p ! n \\<in> set (stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "hence s_ne: \"stack ?s \\<noteq> []\""], ["proof (prove)\nusing this:\n  p ! n \\<in> set (stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with all_False"], ["proof (chain)\npicking this:\n  \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n          stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [])\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []", "have \"w \\<noteq> hd (stack ?s)\""], ["proof (prove)\nusing this:\n  \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n          stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> [])\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n\ngoal (1 subgoal):\n 1. w \\<noteq> hd (stack (s'\\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  w \\<noteq> hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "from stack_is_tree_path finish"], ["proof (chain)\npicking this:\n  stack s \\<noteq> [] \\<Longrightarrow>\n  \\<exists>v0\\<in>V0.\n     path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s", "obtain v0 where\n                    \"path (tree_edges s) v0 (rev (stack ?s)) u\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> [] \\<Longrightarrow>\n  \\<exists>v0\\<in>V0.\n     path (tree_edges s) v0 (rev (tl (stack s))) (hd (stack s))\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        path (tree_edges s) v0\n         (rev (stack (s'\\<lparr>state.more := x\\<rparr>)))\n         u \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path (tree_edges s) v0 (rev (stack (s'\\<lparr>state.more := x\\<rparr>))) u\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with s_ne"], ["proof (chain)\npicking this:\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n  path (tree_edges s) v0 (rev (stack (s'\\<lparr>state.more := x\\<rparr>))) u", "have \"(hd (stack ?s), u) \\<in> tree_edges s\""], ["proof (prove)\nusing this:\n  stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq> []\n  path (tree_edges s) v0 (rev (stack (s'\\<lparr>state.more := x\\<rparr>))) u\n\ngoal (1 subgoal):\n 1. (hd (stack (s'\\<lparr>state.more := x\\<rparr>)), u) \\<in> tree_edges s", "by (auto simp: neq_Nil_conv path_simps)"], ["proof (state)\nthis:\n  (hd (stack (s'\\<lparr>state.more := x\\<rparr>)), u) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with * tree_eq_rule"], ["proof (chain)\npicking this:\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n  \\<lbrakk>(?v, ?w) \\<in> tree_edges s; (?u, ?w) \\<in> tree_edges s\\<rbrakk>\n  \\<Longrightarrow> ?v = ?u\n  (hd (stack (s'\\<lparr>state.more := x\\<rparr>)), u) \\<in> tree_edges s", "have **: \"hd (stack ?s) = p!n\""], ["proof (prove)\nusing this:\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n  \\<lbrakk>(?v, ?w) \\<in> tree_edges s; (?u, ?w) \\<in> tree_edges s\\<rbrakk>\n  \\<Longrightarrow> ?v = ?u\n  (hd (stack (s'\\<lparr>state.more := x\\<rparr>)), u) \\<in> tree_edges s\n\ngoal (1 subgoal):\n 1. hd (stack (s'\\<lparr>state.more := x\\<rparr>)) = p ! n", "by simp"], ["proof (state)\nthis:\n  hd (stack (s'\\<lparr>state.more := x\\<rparr>)) = p ! n\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> False\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> False", "case \"0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> False\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n  n = 0", "have \"hd p = p!n\""], ["proof (prove)\nusing this:\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n  n = 0\n\ngoal (1 subgoal):\n 1. hd p = p ! n", "by (simp add: hd_conv_nth)"], ["proof (state)\nthis:\n  hd p = p ! n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> False\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> False", "with \\<open>hd p = w\\<close> **"], ["proof (chain)\npicking this:\n  hd p = w\n  hd (stack (s'\\<lparr>state.more := x\\<rparr>)) = p ! n\n  hd p = p ! n", "have \"w = hd (stack ?s)\""], ["proof (prove)\nusing this:\n  hd p = w\n  hd (stack (s'\\<lparr>state.more := x\\<rparr>)) = p ! n\n  hd p = p ! n\n\ngoal (1 subgoal):\n 1. w = hd (stack (s'\\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  w = hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> False\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> False", "with \\<open>w\\<noteq>hd (stack ?s)\\<close>"], ["proof (chain)\npicking this:\n  w \\<noteq> hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n  w = hd (stack (s'\\<lparr>state.more := x\\<rparr>))", "show False"], ["proof (prove)\nusing this:\n  w \\<noteq> hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n  w = hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> False", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> False", "with * ** s'.lowlink_path_finished[OF p, where j=n]"], ["proof (chain)\npicking this:\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n  hd (stack (s'\\<lparr>state.more := x\\<rparr>)) = p ! n\n  \\<lbrakk>n < length p; 0 < n\\<rbrakk>\n  \\<Longrightarrow> p ! n\n                    \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  n = Suc m", "have \n                      \"hd (stack ?s) \\<in> dom (finished ?s)\""], ["proof (prove)\nusing this:\n  (p ! n, u) \\<in> tree_edges s\n  n < length p\n  hd (stack (s'\\<lparr>state.more := x\\<rparr>)) = p ! n\n  \\<lbrakk>n < length p; 0 < n\\<rbrakk>\n  \\<Longrightarrow> p ! n\n                    \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  n = Suc m\n\ngoal (1 subgoal):\n 1. hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n    \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n  \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> False", "with hd_in_set[OF s_ne] s'.stack_not_finished"], ["proof (chain)\npicking this:\n  hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n  \\<in> set (stack (s'\\<lparr>state.more := x\\<rparr>))\n  ?x \\<in> set (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<Longrightarrow>\n  ?x \\<notin> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n  \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))", "show ?thesis"], ["proof (prove)\nusing this:\n  hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n  \\<in> set (stack (s'\\<lparr>state.more := x\\<rparr>))\n  ?x \\<in> set (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<Longrightarrow>\n  ?x \\<notin> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n  hd (stack (s'\\<lparr>state.more := x\\<rparr>))\n  \\<in> dom (finished (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<notin> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v9 \\<in> lowlink_set s u; ?v9 \\<notin> lowlink_set s w\\<rbrakk>\n  \\<Longrightarrow> ?v9\n                    \\<notin> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n                              w\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "with ll_sub ll_sub_rev"], ["proof (chain)\npicking this:\n  lowlink_set s w\n  \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> lowlink_set s w \\<union> lowlink_set s u\n  \\<lbrakk>?v9 \\<in> lowlink_set s u; ?v9 \\<notin> lowlink_set s w\\<rbrakk>\n  \\<Longrightarrow> ?v9\n                    \\<notin> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n                              w", "have \"lowlink_set ?s w = lowlink_set s w\""], ["proof (prove)\nusing this:\n  lowlink_set s w\n  \\<subseteq> lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w\n  \\<subseteq> lowlink_set s w \\<union> lowlink_set s u\n  \\<lbrakk>?v9 \\<in> lowlink_set s u; ?v9 \\<notin> lowlink_set s w\\<rbrakk>\n  \\<Longrightarrow> ?v9\n                    \\<notin> lowlink_set (s'\\<lparr>state.more := x\\<rparr>)\n                              w\n\ngoal (1 subgoal):\n 1. lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w = lowlink_set s w", "by auto"], ["proof (state)\nthis:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w = lowlink_set s w\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "hence \"LowLink s w = LowLink ?s w\""], ["proof (prove)\nusing this:\n  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w = lowlink_set s w\n\ngoal (1 subgoal):\n 1. Min (\\<delta> s ` lowlink_set s w) =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "by simp"], ["proof (state)\nthis:\n  Min (\\<delta> s ` lowlink_set s w) =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<not> (w = hd (stack (s'\\<lparr>state.more := x\\<rparr>)) \\<and>\n            stack (s'\\<lparr>state.more := x\\<rparr>) \\<noteq>\n            []) \\<Longrightarrow>\n    \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "finally"], ["proof (chain)\npicking this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (1 subgoal):\n 1. \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n    Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n         lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)", "."], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) w =\n  Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n       lowlink_set (s'\\<lparr>state.more := x\\<rparr>) w)\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_fin u s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   ?w9 \\<in> dom (discovered (s'\\<lparr>state.more := ?x9\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> (s'\\<lparr>state.more := ?x9\\<rparr>) ?w9 =\n                    Min (\\<delta> (s'\\<lparr>state.more := ?x9\\<rparr>) `\n                         lowlink_set (s'\\<lparr>state.more := ?x9\\<rparr>)\n                          ?w9)\n\ngoal (3 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G tarjan_params s;\n        \\<forall>x\\<in>dom (discovered s).\n           \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x);\n        cond s; \\<not> is_break tarjan_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish tarjan_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G tarjan_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              (\\<forall>xa\n  \\<in>dom (discovered (s'\\<lparr>state.more := x\\<rparr>)).\n                                  \\<zeta>\n                                   (s'\\<lparr>state.more := x\\<rparr>) xa =\n                                  Min (\\<delta>\n  (s'\\<lparr>state.more := x\\<rparr>) `\n lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "with finish"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_fin u s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   ?w9 \\<in> dom (discovered (s'\\<lparr>state.more := ?x9\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> (s'\\<lparr>state.more := ?x9\\<rparr>) ?w9 =\n                    Min (\\<delta> (s'\\<lparr>state.more := ?x9\\<rparr>) `\n                         lowlink_set (s'\\<lparr>state.more := ?x9\\<rparr>)\n                          ?w9)", "show ?case"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  \\<forall>x\\<in>dom (discovered s).\n     \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x)\n  cond s\n  \\<not> is_break tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  pending s `` {u} = {}\n  s' = finish u s\n  \\<lbrakk>\\<And>\\<Psi>.\n              tarjan_fin u s' \\<le>\\<^sub>n SPEC \\<Psi> \\<Longrightarrow>\n              \\<Psi> ?x9;\n   DFS_invar G tarjan_params (s'\\<lparr>state.more := ?x9\\<rparr>);\n   ?w9 \\<in> dom (discovered (s'\\<lparr>state.more := ?x9\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<zeta> (s'\\<lparr>state.more := ?x9\\<rparr>) ?w9 =\n                    Min (\\<delta> (s'\\<lparr>state.more := ?x9\\<rparr>) `\n                         lowlink_set (s'\\<lparr>state.more := ?x9\\<rparr>)\n                          ?w9)\n\ngoal (1 subgoal):\n 1. on_finish tarjan_params u s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G tarjan_params\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         (\\<forall>xa\\<in>dom (discovered\n                                (s'\\<lparr>state.more := x\\<rparr>)).\n             \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) xa =\n             Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n                  lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))", "by (auto simp: pw_leof_iff)"], ["proof (state)\nthis:\n  on_finish tarjan_params u s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G tarjan_params\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       (\\<forall>xa\\<in>dom (discovered\n                              (s'\\<lparr>state.more := x\\<rparr>)).\n           \\<zeta> (s'\\<lparr>state.more := x\\<rparr>) xa =\n           Min (\\<delta> (s'\\<lparr>state.more := x\\<rparr>) `\n                lowlink_set (s'\\<lparr>state.more := x\\<rparr>) xa)))\n\ngoal (2 subgoals):\n 1. \\<And>u v s.\n       on_back_edge tarjan_params u v s = on_cross_edge tarjan_params u v s\n 2. on_init tarjan_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         \\<forall>xa\\<in>dom (discovered (empty_state x)).\n            \\<zeta> (empty_state x) xa =\n            Min (\\<delta> (empty_state x) ` lowlink_set (empty_state x) xa))", "qed simp_all"], ["proof (state)\nthis:\n  is_invar\n   (\\<lambda>s.\n       \\<forall>x\\<in>dom (discovered s).\n          \\<zeta> s x = Min (\\<delta> s ` lowlink_set s x))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "context Tarjan_invar begin"], ["", "context begin"], ["", "interpretation timing_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas lowlink_eq_LowLink =\n    i_lowlink_eq_LowLink[THEN make_invar_thm, rule_format]"], ["", "lemma lowlink_eq_disc_iff_scc_root:\n    assumes \"v \\<in> dom (finished s) \\<or> (stack s \\<noteq> [] \\<and> v = hd (stack s) \\<and> pending s `` {v} = {})\"\n    shows \"\\<zeta> s v = \\<delta> s v \\<longleftrightarrow> scc_root s v (scc_of E v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<zeta> s v = \\<delta> s v) = scc_root s v (scc_of E v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<zeta> s v = \\<delta> s v) = scc_root s v (scc_of E v)", "from assms"], ["proof (chain)\npicking this:\n  v \\<in> dom (finished s) \\<or>\n  stack s \\<noteq> [] \\<and> v = hd (stack s) \\<and> pending s `` {v} = {}", "have \"v \\<in> dom (discovered s)\""], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s) \\<or>\n  stack s \\<noteq> [] \\<and> v = hd (stack s) \\<and> pending s `` {v} = {}\n\ngoal (1 subgoal):\n 1. v \\<in> dom (discovered s)", "using finished_discovered hd_in_set stack_discovered"], ["proof (prove)\nusing this:\n  v \\<in> dom (finished s) \\<or>\n  stack s \\<noteq> [] \\<and> v = hd (stack s) \\<and> pending s `` {v} = {}\n  dom (finished s) \\<subseteq> dom (discovered s)\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (discovered s)", "by blast"], ["proof (state)\nthis:\n  v \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. (\\<zeta> s v = \\<delta> s v) = scc_root s v (scc_of E v)", "hence \"\\<zeta> s v = LowLink s v\""], ["proof (prove)\nusing this:\n  v \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<zeta> s v = Min (\\<delta> s ` lowlink_set s v)", "using lowlink_eq_LowLink"], ["proof (prove)\nusing this:\n  v \\<in> dom (discovered s)\n  ?x \\<in> dom (discovered s) \\<Longrightarrow>\n  \\<zeta> s ?x = Min (\\<delta> s ` lowlink_set s ?x)\n\ngoal (1 subgoal):\n 1. \\<zeta> s v = Min (\\<delta> s ` lowlink_set s v)", "by simp"], ["proof (state)\nthis:\n  \\<zeta> s v = Min (\\<delta> s ` lowlink_set s v)\n\ngoal (1 subgoal):\n 1. (\\<zeta> s v = \\<delta> s v) = scc_root s v (scc_of E v)", "with LowLink_eq_disc_iff_scc_root[OF assms]"], ["proof (chain)\npicking this:\n  (Min (\\<delta> s ` lowlink_set s v) = \\<delta> s v) =\n  scc_root s v (scc_of E v)\n  \\<zeta> s v = Min (\\<delta> s ` lowlink_set s v)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Min (\\<delta> s ` lowlink_set s v) = \\<delta> s v) =\n  scc_root s v (scc_of E v)\n  \\<zeta> s v = Min (\\<delta> s ` lowlink_set s v)\n\ngoal (1 subgoal):\n 1. (\\<zeta> s v = \\<delta> s v) = scc_root s v (scc_of E v)", "by simp"], ["proof (state)\nthis:\n  (\\<zeta> s v = \\<delta> s v) = scc_root s v (scc_of E v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nc_sccs_eq_reachable:\n    assumes NC: \"\\<not> cond s\"\n    shows \"reachable = \\<Union>(sccs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable = \\<Union> (sccs s)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. reachable \\<subseteq> \\<Union> (sccs s)\n 2. \\<Union> (sccs s) \\<subseteq> reachable", "from nc_finished_eq_reachable NC"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> cond s; \\<not> is_break tarjan_params s\\<rbrakk>\n  \\<Longrightarrow> dom (finished s) = reachable\n  \\<not> cond s", "have [simp]: \"reachable = dom (finished s)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> cond s; \\<not> is_break tarjan_params s\\<rbrakk>\n  \\<Longrightarrow> dom (finished s) = reachable\n  \\<not> cond s\n\ngoal (1 subgoal):\n 1. reachable = dom (finished s)", "by simp"], ["proof (state)\nthis:\n  reachable = dom (finished s)\n\ngoal (2 subgoals):\n 1. reachable \\<subseteq> \\<Union> (sccs s)\n 2. \\<Union> (sccs s) \\<subseteq> reachable", "with sccs_finished"], ["proof (chain)\npicking this:\n  \\<Union> (sccs s) \\<subseteq> dom (finished s)\n  reachable = dom (finished s)", "show \"\\<Union>(sccs s) \\<subseteq> reachable\""], ["proof (prove)\nusing this:\n  \\<Union> (sccs s) \\<subseteq> dom (finished s)\n  reachable = dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<Union> (sccs s) \\<subseteq> reachable", "by simp"], ["proof (state)\nthis:\n  \\<Union> (sccs s) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. reachable \\<subseteq> \\<Union> (sccs s)", "from NC"], ["proof (chain)\npicking this:\n  \\<not> cond s", "have \"stack s = []\""], ["proof (prove)\nusing this:\n  \\<not> cond s\n\ngoal (1 subgoal):\n 1. stack s = []", "by (simp add: cond_alt)"], ["proof (state)\nthis:\n  stack s = []\n\ngoal (1 subgoal):\n 1. reachable \\<subseteq> \\<Union> (sccs s)", "with stacks_eq_iff"], ["proof (chain)\npicking this:\n  (stack s = []) = (tj_stack s = [])\n  stack s = []", "have \"tj_stack s = []\""], ["proof (prove)\nusing this:\n  (stack s = []) = (tj_stack s = [])\n  stack s = []\n\ngoal (1 subgoal):\n 1. tj_stack s = []", "by simp"], ["proof (state)\nthis:\n  tj_stack s = []\n\ngoal (1 subgoal):\n 1. reachable \\<subseteq> \\<Union> (sccs s)", "with finished_ss_sccs_tj_stack"], ["proof (chain)\npicking this:\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  tj_stack s = []", "show \"reachable \\<subseteq> \\<Union>(sccs s)\""], ["proof (prove)\nusing this:\n  dom (finished s) \\<subseteq> \\<Union> (sccs s) \\<union> set (tj_stack s)\n  tj_stack s = []\n\ngoal (1 subgoal):\n 1. reachable \\<subseteq> \\<Union> (sccs s)", "by simp"], ["proof (state)\nthis:\n  reachable \\<subseteq> \\<Union> (sccs s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "context Tarjan begin"], ["", "lemma tarjan_fin_nofail:\n    assumes \"pre_on_finish u s'\"\n    shows \"nofail (tarjan_fin u s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (tarjan_fin u s')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail (tarjan_fin u s')", "from assms"], ["proof (chain)\npicking this:\n  pre_on_finish u s'", "obtain s where s: \"DFS_invar G tarjan_params s\" \"stack s \\<noteq> []\"  \"u = hd (stack s)\" \"s' = finish u s\"  \"cond s\" \"pending s `` {u} = {}\""], ["proof (prove)\nusing this:\n  pre_on_finish u s'\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>DFS_invar G tarjan_params s; stack s \\<noteq> [];\n         u = hd (stack s); s' = finish u s; cond s;\n         pending s `` {u} = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: pre_on_finish_def)"], ["proof (state)\nthis:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}\n\ngoal (1 subgoal):\n 1. nofail (tarjan_fin u s')", "then"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}", "interpret Tarjan_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail (tarjan_fin u s')", "from s hd_stack_in_tj_stack"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}\n  stack s \\<noteq> [] \\<Longrightarrow> hd (stack s) \\<in> set (tj_stack s)", "have \"u \\<in> set (tj_stack s')\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}\n  stack s \\<noteq> [] \\<Longrightarrow> hd (stack s) \\<in> set (tj_stack s)\n\ngoal (1 subgoal):\n 1. u \\<in> set (tj_stack s')", "by simp"], ["proof (state)\nthis:\n  u \\<in> set (tj_stack s')\n\ngoal (1 subgoal):\n 1. nofail (tarjan_fin u s')", "moreover"], ["proof (state)\nthis:\n  u \\<in> set (tj_stack s')\n\ngoal (1 subgoal):\n 1. nofail (tarjan_fin u s')", "from s tj_stack_distinct"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}\n  distinct (tj_stack s)", "have \"distinct (tj_stack s')\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}\n  distinct (tj_stack s)\n\ngoal (1 subgoal):\n 1. distinct (tj_stack s')", "by simp"], ["proof (state)\nthis:\n  distinct (tj_stack s')\n\ngoal (1 subgoal):\n 1. nofail (tarjan_fin u s')", "moreover"], ["proof (state)\nthis:\n  distinct (tj_stack s')\n\ngoal (1 subgoal):\n 1. nofail (tarjan_fin u s')", "have \"the (lowlink s' u) = the (discovered s' u) \\<longleftrightarrow> scc_root s' u (scc_of E u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)", "from s"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}", "have \"the (lowlink s' u) = the (discovered s' u) \\<longleftrightarrow> the (lowlink s u) = the (discovered s u)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}\n\ngoal (1 subgoal):\n 1. (the_lowlink s' u = the_discovered s' u) =\n    (the_lowlink s u = the_discovered s u)", "by simp"], ["proof (state)\nthis:\n  (the_lowlink s' u = the_discovered s' u) =\n  (the_lowlink s u = the_discovered s u)\n\ngoal (1 subgoal):\n 1. (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)", "also"], ["proof (state)\nthis:\n  (the_lowlink s' u = the_discovered s' u) =\n  (the_lowlink s u = the_discovered s u)\n\ngoal (1 subgoal):\n 1. (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)", "from s lowlink_eq_disc_iff_scc_root"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}\n  ?v \\<in> dom (finished s) \\<or>\n  stack s \\<noteq> [] \\<and>\n  ?v = hd (stack s) \\<and> pending s `` {?v} = {} \\<Longrightarrow>\n  (the_lowlink s ?v = the_discovered s ?v) = scc_root s ?v (scc_of E ?v)", "have \"... \\<longleftrightarrow> scc_root s u (scc_of E u)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}\n  ?v \\<in> dom (finished s) \\<or>\n  stack s \\<noteq> [] \\<and>\n  ?v = hd (stack s) \\<and> pending s `` {?v} = {} \\<Longrightarrow>\n  (the_lowlink s ?v = the_discovered s ?v) = scc_root s ?v (scc_of E ?v)\n\ngoal (1 subgoal):\n 1. (the_lowlink s u = the_discovered s u) = scc_root s u (scc_of E u)", "by blast"], ["proof (state)\nthis:\n  (the_lowlink s u = the_discovered s u) = scc_root s u (scc_of E u)\n\ngoal (1 subgoal):\n 1. (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)", "also"], ["proof (state)\nthis:\n  (the_lowlink s u = the_discovered s u) = scc_root s u (scc_of E u)\n\ngoal (1 subgoal):\n 1. (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)", "from s scc_root_transfer'[where s'=s']"], ["proof (chain)\npicking this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}\n  \\<lbrakk>discovered s = discovered s';\n   tree_edges s = tree_edges s'\\<rbrakk>\n  \\<Longrightarrow> scc_root s ?r ?scc = scc_root s' ?r ?scc", "have \"... \\<longleftrightarrow> scc_root s' u (scc_of E u)\""], ["proof (prove)\nusing this:\n  DFS_invar G tarjan_params s\n  stack s \\<noteq> []\n  u = hd (stack s)\n  s' = finish u s\n  cond s\n  pending s `` {u} = {}\n  \\<lbrakk>discovered s = discovered s';\n   tree_edges s = tree_edges s'\\<rbrakk>\n  \\<Longrightarrow> scc_root s ?r ?scc = scc_root s' ?r ?scc\n\ngoal (1 subgoal):\n 1. scc_root s u (scc_of E u) = scc_root s' u (scc_of E u)", "by simp"], ["proof (state)\nthis:\n  scc_root s u (scc_of E u) = scc_root s' u (scc_of E u)\n\ngoal (1 subgoal):\n 1. (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)", "finally"], ["proof (chain)\npicking this:\n  (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)", "show ?thesis"], ["proof (prove)\nusing this:\n  (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)\n\ngoal (1 subgoal):\n 1. (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)", "."], ["proof (state)\nthis:\n  (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)\n\ngoal (1 subgoal):\n 1. nofail (tarjan_fin u s')", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> set (tj_stack s')\n  distinct (tj_stack s')\n  (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> set (tj_stack s')\n  distinct (tj_stack s')\n  (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)\n\ngoal (1 subgoal):\n 1. nofail (tarjan_fin u s')", "unfolding tarjan_fin_def tj_stack_pop_def"], ["proof (prove)\nusing this:\n  u \\<in> set (tj_stack s')\n  distinct (tj_stack s')\n  (the_lowlink s' u = the_discovered s' u) = scc_root s' u (scc_of E u)\n\ngoal (1 subgoal):\n 1. nofail\n     (let ll = if stack s' = [] then lowlink s'\n               else let ua = hd (stack s')\n                    in lowlink s'(ua \\<mapsto>\n                       min (the_lowlink s' ua) (the_lowlink s' u));\n          s'a = s'\\<lparr>lowlink := ll\\<rparr>\n      in ASSERT (u \\<in> set (tj_stack s')) \\<bind>\n         (\\<lambda>_.\n             ASSERT (distinct (tj_stack s')) \\<bind>\n             (\\<lambda>_.\n                 if the_lowlink s' u = the_discovered s' u\n                 then ASSERT (scc_root s' u (scc_of E u)) \\<bind>\n                      (\\<lambda>_.\n                          RETURN\n                           (tl (dropWhile ((\\<noteq>) u) (tj_stack s')),\n                            insert u\n                             (set (takeWhile ((\\<noteq>) u)\n                                    (tj_stack s')))) \\<bind>\n                          (\\<lambda>(tjs, scc).\n                              NOOP\n                               (s'a\\<lparr>tj_stack := tjs,\nsccs := insert scc (sccs s')\\<rparr>)))\n                 else ASSERT (\\<not> scc_root s' u (scc_of E u)) \\<bind>\n                      (\\<lambda>_. NOOP s'a))))", "by simp"], ["proof (state)\nthis:\n  nofail (tarjan_fin u s')\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale DFS G tarjan_params"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS G tarjan_params", "by unfold_locales (simp_all add: tarjan_disc_def tarjan_back_def tarjan_fin_nofail)"], ["", "end"], ["", "interpretation tarjan: Tarjan_def for G"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>Interface\\<close>"], ["", "definition \"tarjan G \\<equiv> do {\n  ASSERT (fb_graph G);\n  s \\<leftarrow> tarjan.it_dfs TYPE('a) G;\n  RETURN (sccs s) }\""], ["", "definition \"tarjan_spec G \\<equiv> do {\n  ASSERT (fb_graph G); \n  SPEC (\\<lambda>sccs.  (\\<forall>scc \\<in> sccs. is_scc (g_E G) scc)\n              \\<and> \\<Union>sccs = tarjan.reachable TYPE('a) G)}\""], ["", "lemma tarjan_correct:\n  \"tarjan G \\<le> tarjan_spec G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tarjan G \\<le> tarjan_spec G", "unfolding tarjan_def tarjan_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_.\n        param_DFS_defs.it_dfs G (Tarjan_def.tarjan_params G) \\<bind>\n        (\\<lambda>s. RETURN (sccs s)))\n    \\<le> ASSERT (fb_graph G) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>sccs.\n                   (\\<forall>scc\\<in>sccs. is_scc (g_E G) scc) \\<and>\n                   \\<Union> sccs = (g_E G)\\<^sup>* `` g_V0 G))", "proof (refine_vcg le_ASSERTI order_trans[OF DFS.it_dfs_correct])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>fb_graph G; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> DFS G (Tarjan_def.tarjan_params G)\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>scc\\<in>sccs x. is_scc (g_E G) scc\n 3. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (sccs x) = (g_E G)\\<^sup>* `` g_V0 G", "assume \"fb_graph G\""], ["proof (state)\nthis:\n  fb_graph G\n\ngoal (3 subgoals):\n 1. \\<lbrakk>fb_graph G; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> DFS G (Tarjan_def.tarjan_params G)\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>scc\\<in>sccs x. is_scc (g_E G) scc\n 3. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (sccs x) = (g_E G)\\<^sup>* `` g_V0 G", "then"], ["proof (chain)\npicking this:\n  fb_graph G", "interpret fb_graph G"], ["proof (prove)\nusing this:\n  fb_graph G\n\ngoal (1 subgoal):\n 1. fb_graph G", "."], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>fb_graph G; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> DFS G (Tarjan_def.tarjan_params G)\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>scc\\<in>sccs x. is_scc (g_E G) scc\n 3. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (sccs x) = (g_E G)\\<^sup>* `` g_V0 G", "interpret Tarjan"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tarjan G", ".."], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>fb_graph G; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> DFS G (Tarjan_def.tarjan_params G)\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>scc\\<in>sccs x. is_scc (g_E G) scc\n 3. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (sccs x) = (g_E G)\\<^sup>* `` g_V0 G", "show \"DFS G (tarjan.tarjan_params TYPE('b) G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS G (Tarjan_def.tarjan_params G)", ".."], ["proof (state)\nthis:\n  DFS G (Tarjan_def.tarjan_params G)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>scc\\<in>sccs x. is_scc (g_E G) scc\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (sccs x) = (g_E G)\\<^sup>* `` g_V0 G", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>scc\\<in>sccs x. is_scc (g_E G) scc\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (sccs x) = (g_E G)\\<^sup>* `` g_V0 G", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>scc\\<in>sccs x. is_scc (g_E G) scc\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (sccs x) = (g_E G)\\<^sup>* `` g_V0 G", "assume C: \"DFS_invar G (tarjan.tarjan_params TYPE('b) G) s \\<and> \\<not> tarjan.cond TYPE('b) G s\""], ["proof (state)\nthis:\n  DFS_invar G (Tarjan_def.tarjan_params G) s \\<and>\n  \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) s\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>scc\\<in>sccs x. is_scc (g_E G) scc\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (sccs x) = (g_E G)\\<^sup>* `` g_V0 G", "then"], ["proof (chain)\npicking this:\n  DFS_invar G (Tarjan_def.tarjan_params G) s \\<and>\n  \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) s", "interpret Tarjan_invar G s"], ["proof (prove)\nusing this:\n  DFS_invar G (Tarjan_def.tarjan_params G) s \\<and>\n  \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) s\n\ngoal (1 subgoal):\n 1. Tarjan_invar G s", "by simp"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>scc\\<in>sccs x. is_scc (g_E G) scc\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (sccs x) = (g_E G)\\<^sup>* `` g_V0 G", "from sccs_are_sccs"], ["proof (chain)\npicking this:\n  \\<forall>scc\\<in>sccs s. is_scc (g_E G) scc", "show \"\\<forall>scc\\<in>sccs s. is_scc (g_E G) scc\""], ["proof (prove)\nusing this:\n  \\<forall>scc\\<in>sccs s. is_scc (g_E G) scc\n\ngoal (1 subgoal):\n 1. \\<forall>scc\\<in>sccs s. is_scc (g_E G) scc", "."], ["proof (state)\nthis:\n  \\<forall>scc\\<in>sccs s. is_scc (g_E G) scc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G;\n        DFS_invar G (Tarjan_def.tarjan_params G) x \\<and>\n        \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) x\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (sccs x) = (g_E G)\\<^sup>* `` g_V0 G", "from nc_sccs_eq_reachable C"], ["proof (chain)\npicking this:\n  \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G)\n          s \\<Longrightarrow>\n  (g_E G)\\<^sup>* `` g_V0 G = \\<Union> (sccs s)\n  DFS_invar G (Tarjan_def.tarjan_params G) s \\<and>\n  \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) s", "show \"\\<Union>(sccs s) = tarjan.reachable TYPE('b) G\""], ["proof (prove)\nusing this:\n  \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G)\n          s \\<Longrightarrow>\n  (g_E G)\\<^sup>* `` g_V0 G = \\<Union> (sccs s)\n  DFS_invar G (Tarjan_def.tarjan_params G) s \\<and>\n  \\<not> param_DFS_defs.cond G (Tarjan_def.tarjan_params G) s\n\ngoal (1 subgoal):\n 1. \\<Union> (sccs s) = (g_E G)\\<^sup>* `` g_V0 G", "by simp"], ["proof (state)\nthis:\n  \\<Union> (sccs s) = (g_E G)\\<^sup>* `` g_V0 G\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}