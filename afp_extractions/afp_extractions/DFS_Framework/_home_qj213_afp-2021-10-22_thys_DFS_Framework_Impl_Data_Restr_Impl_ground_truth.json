{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Impl/Data/Restr_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma restr_rel_simps:\n  assumes \"(s,s')\\<in>restr_rel R\"\n  shows \"visited s = visited s' \\<union> R\"\n  and \"simple_state.more s = simple_state.more s'\"", "lemma \n  assumes \"(s,s')\\<in>restr_rel R\"\n  shows restr_rel_stackD: \"(ss_stack s, ss_stack s') \\<in> \\<langle>Id \\<times>\\<^sub>r {(U,U'). U-R = U'}\\<rangle>list_rel\"\n  and restr_rel_vis_djD: \"visited s' \\<inter> R = {}\"", "lemma restr_simple_state_rel_combine: \n  \"\\<langle>ES\\<rangle>restr_simple_state_rel R = restr_rel R O \\<langle>ES\\<rangle>simple_state_rel\"", "lemmas gbs'_simps[simp, DFS_code_unfold]\n    = gen_basic_dfs_struct.simps[mk_record_simp, OF gbs'_def[unfolded gbs_simps]]", "lemmas rel_def = restr_rel_def[where R=R]", "lemma is_break_param'[param]: \"(is_break parami, is_break parami)\\<in>rel \\<rightarrow> bool_rel\"", "lemma do_init_refine[refine]: \"do_init \\<le> \\<Down> rel (a.c.do_init)\"", "lemma gen_cond_param: \"(gen_cond,a.c.gen_cond)\\<in>rel \\<rightarrow> bool_rel\"", "lemma cross_back_id[simp]: \n    \"do_cross_edge u v s = RETURN s\"\n    \"do_back_edge u v s = RETURN s\"\n    \"a.c.do_cross_edge u v s = RETURN s\"\n    \"a.c.do_back_edge u v s = RETURN s\"", "lemma pred_rel_simps:\n    assumes \"(s,s')\\<in>rel\"\n    shows \"a.c.is_discovered_impl u s \\<longleftrightarrow> a.c.is_discovered_impl u s' \\<or> u\\<in>R\"\n    and \"a.c.is_empty_stack_impl s \\<longleftrightarrow> a.c.is_empty_stack_impl s'\"", "lemma no_pending_refine:\n    assumes \"(s,s')\\<in>rel\" \"\\<not>a.c.is_empty_stack_impl s'\"\n    shows \"(hd (ss_stack s) = (u,{})) \\<Longrightarrow> hd (ss_stack s') = (u,{})\"", "lemma do_new_root_refine[refine]:\n    \"\\<lbrakk> (v0i,v0)\\<in>Id; (si,s)\\<in>rel; v0\\<notin>R \\<rbrakk> \n      \\<Longrightarrow> do_new_root v0i si \\<le> \\<Down> rel (a.c.do_new_root v0 s)\"", "lemma do_finish_refine[refine]:\n    \"\\<lbrakk>(s, s') \\<in> rel; (u,u')\\<in>Id\\<rbrakk>\n       \\<Longrightarrow> do_finish u s \\<le> \\<Down> rel (a.c.do_finish u' s')\"", "lemma aux_cnv_pending: \n    \"\\<lbrakk> (s, s') \\<in> rel; \n      \\<not> is_empty_stack_impl s; vs\\<in>Vs; vs\\<notin>R;\n      hd (ss_stack s) = (u,Vs) \\<rbrakk> \\<Longrightarrow>\n      hd (ss_stack s') = (u,insert vs (Vs-R))\"", "lemma get_pending_refine: \n    assumes \"(s, s') \\<in> rel\" \"gen_cond s\" \"\\<not> is_empty_stack_impl s\"\n    shows \"\n      get_pending_impl s \\<le> (sup \n        (\\<Down>(Id \\<times>\\<^sub>r \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel) (inf \n          (get_pending_impl s') \n          (SPEC (\\<lambda>(_,Vs,_). case Vs of None \\<Rightarrow> True | Some v \\<Rightarrow> v\\<notin>R))))\n        (\\<Down>(Id \\<times>\\<^sub>r \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel) (\n          SPEC (\\<lambda>(u,Vs,s''). \\<exists>v. Vs=Some v \\<and> v\\<in>R \\<and> s''=s') \n        )))\"", "lemma do_discover_refine[refine]:\n    \"\\<lbrakk> (s, s') \\<in> rel; (u,u')\\<in>Id; (v,v')\\<in>Id; v' \\<notin> R \\<rbrakk>\n       \\<Longrightarrow> do_discover u v s \\<le> \\<Down> rel (a.c.do_discover u' v' s')\"", "lemma aux_R_node_discovered: \"\\<lbrakk>(s,s')\\<in>rel; v\\<in>R\\<rbrakk> \\<Longrightarrow> is_discovered_impl v s\"", "lemma re_refine_aux: \"gen_dfs \\<le> \\<Down>rel a.c.gen_dfs\"", "theorem re_refine_aux2: \"gen_dfs \\<le>\\<Down>(rel O \\<langle>ES\\<rangle>simple_state_rel) a.a.it_dfs\"", "theorem re_refine: \"gen_dfs \\<le>\\<Down>(\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs\"", "lemma tailrec_refine: \"tailrec_impl \\<le> \\<Down>(\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs\""], "translations": [["", "lemma restr_rel_simps:\n  assumes \"(s,s')\\<in>restr_rel R\"\n  shows \"visited s = visited s' \\<union> R\"\n  and \"simple_state.more s = simple_state.more s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. visited s = visited s' \\<union> R &&&\n    simple_state.more s = simple_state.more s'", "using assms"], ["proof (prove)\nusing this:\n  (s, s') \\<in> restr_rel R\n\ngoal (1 subgoal):\n 1. visited s = visited s' \\<union> R &&&\n    simple_state.more s = simple_state.more s'", "unfolding restr_rel_def"], ["proof (prove)\nusing this:\n  (s, s')\n  \\<in> {(s, s').\n         (ss_stack s, ss_stack s')\n         \\<in> \\<langle>Id \\<times>\\<^sub>r\n                        {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n         on_stack s = on_stack s' \\<and>\n         visited s = visited s' \\<union> R \\<and>\n         visited s' \\<inter> R = {} \\<and>\n         simple_state.more s = simple_state.more s'}\n\ngoal (1 subgoal):\n 1. visited s = visited s' \\<union> R &&&\n    simple_state.more s = simple_state.more s'", "by auto"], ["", "lemma \n  assumes \"(s,s')\\<in>restr_rel R\"\n  shows restr_rel_stackD: \"(ss_stack s, ss_stack s') \\<in> \\<langle>Id \\<times>\\<^sub>r {(U,U'). U-R = U'}\\<rangle>list_rel\"\n  and restr_rel_vis_djD: \"visited s' \\<inter> R = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ss_stack s, ss_stack s')\n    \\<in> \\<langle>Id \\<times>\\<^sub>r\n                   {(U, U'). U - R = U'}\\<rangle>list_rel &&&\n    visited s' \\<inter> R = {}", "using assms"], ["proof (prove)\nusing this:\n  (s, s') \\<in> restr_rel R\n\ngoal (1 subgoal):\n 1. (ss_stack s, ss_stack s')\n    \\<in> \\<langle>Id \\<times>\\<^sub>r\n                   {(U, U'). U - R = U'}\\<rangle>list_rel &&&\n    visited s' \\<inter> R = {}", "unfolding restr_rel_def"], ["proof (prove)\nusing this:\n  (s, s')\n  \\<in> {(s, s').\n         (ss_stack s, ss_stack s')\n         \\<in> \\<langle>Id \\<times>\\<^sub>r\n                        {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n         on_stack s = on_stack s' \\<and>\n         visited s = visited s' \\<union> R \\<and>\n         visited s' \\<inter> R = {} \\<and>\n         simple_state.more s = simple_state.more s'}\n\ngoal (1 subgoal):\n 1. (ss_stack s, ss_stack s')\n    \\<in> \\<langle>Id \\<times>\\<^sub>r\n                   {(U, U'). U - R = U'}\\<rangle>list_rel &&&\n    visited s' \\<inter> R = {}", "by auto"], ["", "context fixes R :: \"'v set\" begin"], ["", "definition [to_relAPP]: \"restr_simple_state_rel ES \\<equiv> { (s,s') .\n    (ss_stack s, map (\\<lambda>u. (u,pending s' `` {u})) (stack s')) \n      \\<in> \\<langle>Id \\<times>\\<^sub>r {(U,U'). U-R = U'}\\<rangle>list_rel \\<and>\n    on_stack s = set (stack s') \\<and>\n    visited s = dom (discovered s') \\<union> R \\<and> dom (discovered s') \\<inter> R = {} \\<and>\n    dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n    set (stack s') \\<subseteq> dom (discovered s') \\<and>\n    (simple_state.more s, state.more s') \\<in> ES\n  }\""], ["", "end"], ["", "lemma restr_simple_state_rel_combine: \n  \"\\<langle>ES\\<rangle>restr_simple_state_rel R = restr_rel R O \\<langle>ES\\<rangle>simple_state_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>ES\\<rangle>restr_simple_state_rel R =\n    restr_rel R O \\<langle>ES\\<rangle>simple_state_rel", "unfolding restr_simple_state_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, s').\n     (ss_stack s, map (\\<lambda>u. (u, pending s' `` {u})) (stack s'))\n     \\<in> \\<langle>Id \\<times>\\<^sub>r\n                    {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n     on_stack s = set (stack s') \\<and>\n     visited s = dom (discovered s') \\<union> R \\<and>\n     dom (discovered s') \\<inter> R = {} \\<and>\n     dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n     set (stack s') \\<subseteq> dom (discovered s') \\<and>\n     (simple_state.more s, state.more s') \\<in> ES} =\n    restr_rel R O \\<langle>ES\\<rangle>simple_state_rel", "apply (intro equalityI subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(s, s').\n                (ss_stack s,\n                 map (\\<lambda>u. (u, pending s' `` {u})) (stack s'))\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n                on_stack s = set (stack s') \\<and>\n                visited s = dom (discovered s') \\<union> R \\<and>\n                dom (discovered s') \\<inter> R = {} \\<and>\n                dom (finished s') =\n                dom (discovered s') - set (stack s') \\<and>\n                set (stack s') \\<subseteq> dom (discovered s') \\<and>\n                (simple_state.more s, state.more s')\n                \\<in> ES} \\<Longrightarrow>\n       x \\<in> restr_rel R O \\<langle>ES\\<rangle>simple_state_rel\n 2. \\<And>x.\n       x \\<in> restr_rel R O\n               \\<langle>ES\\<rangle>simple_state_rel \\<Longrightarrow>\n       x \\<in> {(s, s').\n                (ss_stack s,\n                 map (\\<lambda>u. (u, pending s' `` {u})) (stack s'))\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n                on_stack s = set (stack s') \\<and>\n                visited s = dom (discovered s') \\<union> R \\<and>\n                dom (discovered s') \\<inter> R = {} \\<and>\n                dom (finished s') =\n                dom (discovered s') - set (stack s') \\<and>\n                set (stack s') \\<subseteq> dom (discovered s') \\<and>\n                (simple_state.more s, state.more s') \\<in> ES}", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(ss_stack a,\n                 map (\\<lambda>u. (u, pending b `` {u})) (stack b))\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, y). U - R = y}\\<rangle>list_rel;\n        on_stack a = set (stack b);\n        visited a = dom (discovered b) \\<union> R;\n        dom (discovered b) \\<inter> R = {};\n        dom (finished b) = dom (discovered b) - set (stack b);\n        set (stack b) \\<subseteq> dom (discovered b);\n        (simple_state.more a, state.more b) \\<in> ES\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> restr_rel R O\n                               \\<langle>ES\\<rangle>simple_state_rel\n 2. \\<And>x.\n       x \\<in> restr_rel R O\n               \\<langle>ES\\<rangle>simple_state_rel \\<Longrightarrow>\n       x \\<in> {(s, s').\n                (ss_stack s,\n                 map (\\<lambda>u. (u, pending s' `` {u})) (stack s'))\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n                on_stack s = set (stack s') \\<and>\n                visited s = dom (discovered s') \\<union> R \\<and>\n                dom (discovered s') \\<inter> R = {} \\<and>\n                dom (finished s') =\n                dom (discovered s') - set (stack s') \\<and>\n                set (stack s') \\<subseteq> dom (discovered s') \\<and>\n                (simple_state.more s, state.more s') \\<in> ES}", "apply (rule relcompI[OF _ simple_state_relI], auto simp: restr_rel_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> restr_rel R O\n               \\<langle>ES\\<rangle>simple_state_rel \\<Longrightarrow>\n       x \\<in> {(s, s').\n                (ss_stack s,\n                 map (\\<lambda>u. (u, pending s' `` {u})) (stack s'))\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n                on_stack s = set (stack s') \\<and>\n                visited s = dom (discovered s') \\<union> R \\<and>\n                dom (discovered s') \\<inter> R = {} \\<and>\n                dom (finished s') =\n                dom (discovered s') - set (stack s') \\<and>\n                set (stack s') \\<subseteq> dom (discovered s') \\<and>\n                (simple_state.more s, state.more s') \\<in> ES}", "apply (auto simp: restr_rel_def simple_state_rel_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  Locale that assumes a simple implementation, makes some \n  additional assumptions on the parameterization (intuitively, that it\n  is not too sensitive to adding nodes from R to the visited set), and then\n  provides a new implementation with pre-initialized visited set.\n\\<close>"], ["", "(* \n  TODO/FIXME: The refinement step from simple_impl is not yet clean,\n    as the parameterizatioin refinement is not handled properly.\n    Ideally, one would assume the required parameterization refinement\n    w.r.t. restr_simple_state_rel, and derive the refinement for \n    simple_state_rel.\n \n*)"], ["", "locale restricted_impl_defs =\n  graph_defs G +\n  a: simple_impl_defs \"graph_restrict G R\"\n  for G :: \"('v, 'more) graph_rec_scheme\"\n  and R\nbegin"], ["", "sublocale pre_simple_impl G"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation \"rel \\<equiv> restr_rel R\""], ["", "definition \"gbs' \\<equiv> gbs \\<lparr> \n    gbs_init := \\<lambda>e. RETURN \n      \\<lparr> ss_stack=[], on_stack={}, visited = R, \\<dots>=e \\<rparr> \\<rparr>\""], ["", "lemmas gbs'_simps[simp, DFS_code_unfold]\n    = gen_basic_dfs_struct.simps[mk_record_simp, OF gbs'_def[unfolded gbs_simps]]"], ["", "sublocale gen_param_dfs_defs gbs' parami simple_state.more_update V0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(* Seems to be fixed in Isabelle-2016\n  (* Some ad-hoc fix for locale abbreviations not being properly printed *)\n  abbreviation (output) \"abbrev_gen_dfs \\<equiv> gen_dfs\"\n  abbreviation (output) \"abbrev__gen_cond \\<equiv> gen_cond\"\n  abbreviation (output) \"abbrev__gen_step \\<equiv> gen_step\"\n\n  abbreviation (output) \"abbrev__ac_gen_dfs \\<equiv> a.c.gen_dfs\"\n  abbreviation (output) \"abbrev__ac_gen_cond \\<equiv> a.c.gen_cond\"\n  abbreviation (output) \"abbrev__ac_gen_step \\<equiv> a.c.gen_step\"\n\n  abbreviation \"abbrev_do_new_root \\<equiv> do_new_root\"\n  abbreviation \"abbrev_do_cross_edge \\<equiv> do_cross_edge\"\n  abbreviation \"abbrev_do_back_edge \\<equiv> do_back_edge\"\n  abbreviation \"abbrev_do_discover \\<equiv> do_discover\"\n  abbreviation \"abbrev_do_finish \\<equiv> do_finish\"\n\n  abbreviation \"abbrev_ac_do_new_root \\<equiv> a.c.do_new_root\"\n  abbreviation \"abbrev_ac_do_cross_edge \\<equiv> a.c.do_cross_edge\"\n  abbreviation \"abbrev_ac_do_back_edge \\<equiv> a.c.do_back_edge\"\n  abbreviation \"abbrev_ac_do_discover \\<equiv> a.c.do_discover\"\n  abbreviation \"abbrev_ac_do_finish \\<equiv> a.c.do_finish\"\n  *)"], ["", "sublocale tailrec_impl_defs G gds"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "locale restricted_impl = \n  fb_graph +\n  a: simple_impl \"graph_restrict G R\" +\n  restricted_impl_defs +\n  \n  (* Cross and back edges must not cause any effect. \n    Intuitively, we will see spurious cross edges to nodes from R.\n    TODO/FIXME: The condition here is a quite crude over-approximation!\n    *)\n  assumes [simp]: \"on_cross_edge parami = (\\<lambda>u v s. RETURN (simple_state.more s))\"\n  assumes [simp]: \"on_back_edge parami = (\\<lambda>u v s. RETURN (simple_state.more s))\"\n\n  (* TODO/FIXME: The next 4 are crude approximations. One should include\n    some precondition! *)\n  assumes is_break_refine: \n    \"\\<lbrakk> (s,s')\\<in>restr_rel R \\<rbrakk> \n      \\<Longrightarrow> is_break parami s \\<longleftrightarrow> is_break parami s'\"\n\n  assumes on_new_root_refine: \n    \"\\<lbrakk> (s,s')\\<in>restr_rel R \\<rbrakk> \n      \\<Longrightarrow> on_new_root parami v0 s \\<le> on_new_root parami v0 s'\"\n\n  assumes on_finish_refine: \n    \"\\<lbrakk> (s,s')\\<in>restr_rel R \\<rbrakk> \n      \\<Longrightarrow> on_finish parami u s \\<le> on_finish parami u s'\"\n\n  assumes on_discover_refine: \n    \"\\<lbrakk> (s,s')\\<in>restr_rel R \\<rbrakk> \n      \\<Longrightarrow> on_discover parami u v s \\<le> on_discover parami u v s'\"\n\nbegin"], ["", "lemmas rel_def = restr_rel_def[where R=R]"], ["", "sublocale gen_param_dfs gbs' parami simple_state.more_update V0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma is_break_param'[param]: \"(is_break parami, is_break parami)\\<in>rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_break parami, is_break parami) \\<in> rel \\<rightarrow> bool_rel", "using is_break_refine"], ["proof (prove)\nusing this:\n  (?s, ?s') \\<in> rel \\<Longrightarrow>\n  is_break parami ?s = is_break parami ?s'\n\ngoal (1 subgoal):\n 1. (is_break parami, is_break parami) \\<in> rel \\<rightarrow> bool_rel", "unfolding rel_def"], ["proof (prove)\nusing this:\n  (?s, ?s')\n  \\<in> {(s, s').\n         (ss_stack s, ss_stack s')\n         \\<in> \\<langle>Id \\<times>\\<^sub>r\n                        {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n         on_stack s = on_stack s' \\<and>\n         visited s = visited s' \\<union> R \\<and>\n         visited s' \\<inter> R = {} \\<and>\n         simple_state.more s = simple_state.more s'} \\<Longrightarrow>\n  is_break parami ?s = is_break parami ?s'\n\ngoal (1 subgoal):\n 1. (is_break parami, is_break parami)\n    \\<in> {(s, s').\n           (ss_stack s, ss_stack s')\n           \\<in> \\<langle>Id \\<times>\\<^sub>r\n                          {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n           on_stack s = on_stack s' \\<and>\n           visited s = visited s' \\<union> R \\<and>\n           visited s' \\<inter> R = {} \\<and>\n           simple_state.more s = simple_state.more s'} \\<rightarrow>\n          bool_rel", "by auto"], ["", "lemma do_init_refine[refine]: \"do_init \\<le> \\<Down> rel (a.c.do_init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. do_init \\<le> \\<Down> rel a.c.do_init", "unfolding do_action_defs a.c.do_action_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. on_init parami \\<bind> gbs_init gbs'\n    \\<le> \\<Down> rel (on_init parami \\<bind> gbs_init a.c.gbs)", "apply (simp add: rel_def a.c.init_impl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. on_init parami \\<bind>\n    (\\<lambda>e.\n        RETURN\n         \\<lparr>ss_stack = [], on_stack = {}, visited = R,\n            \\<dots> = e\\<rparr>)\n    \\<le> \\<Down>\n           {(s, s').\n            (ss_stack s, ss_stack s')\n            \\<in> \\<langle>Id \\<times>\\<^sub>r\n                           {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n            on_stack s = on_stack s' \\<and>\n            visited s = visited s' \\<union> R \\<and>\n            visited s' \\<inter> R = {} \\<and>\n            simple_state.more s = simple_state.more s'}\n           (on_init parami \\<bind>\n            (\\<lambda>e.\n                RETURN\n                 \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                    \\<dots> = e\\<rparr>))", "apply refine_rcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e ea.\n       (e, ea) \\<in> Id \\<Longrightarrow>\n       (\\<lparr>ss_stack = [], on_stack = {}, visited = R,\n           \\<dots> = e\\<rparr>,\n        \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n           \\<dots> = ea\\<rparr>)\n       \\<in> {(s, s').\n              (ss_stack s, ss_stack s')\n              \\<in> \\<langle>Id \\<times>\\<^sub>r\n                             {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n              on_stack s = on_stack s' \\<and>\n              visited s = visited s' \\<union> R \\<and>\n              visited s' \\<inter> R = {} \\<and>\n              simple_state.more s = simple_state.more s'}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_cond_param: \"(gen_cond,a.c.gen_cond)\\<in>rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_cond, a.c.gen_cond) \\<in> rel \\<rightarrow> bool_rel", "apply (clarsimp simp del: graph_restrict_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> rel \\<Longrightarrow> gen_cond a = a.c.gen_cond a'", "apply (frule is_break_param'[param_fo])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> rel;\n        (is_break parami a, is_break parami a') \\<in> bool_rel\\<rbrakk>\n       \\<Longrightarrow> gen_cond a = a.c.gen_cond a'", "unfolding gen_cond_def a.c.gen_cond_def rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a')\n                \\<in> {(s, s').\n                       (ss_stack s, ss_stack s')\n                       \\<in> \\<langle>Id \\<times>\\<^sub>r\n{(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n                       on_stack s = on_stack s' \\<and>\n                       visited s = visited s' \\<union> R \\<and>\n                       visited s' \\<inter> R = {} \\<and>\n                       simple_state.more s = simple_state.more s'};\n        (is_break parami a, is_break parami a') \\<in> bool_rel\\<rbrakk>\n       \\<Longrightarrow> ((V0 \\<subseteq> gen_discovered a \\<longrightarrow>\n                           \\<not> gds_is_empty_stack gds a) \\<and>\n                          \\<not> gds_is_break gds a) =\n                         ((a.a.V0\n                           \\<subseteq> a.c.gen_discovered\n  a' \\<longrightarrow>\n                           \\<not> gds_is_empty_stack a.c.gds a') \\<and>\n                          \\<not> gds_is_break a.c.gds a')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(ss_stack a, ss_stack a')\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, y). U - R = y}\\<rangle>list_rel \\<and>\n                on_stack a = on_stack a' \\<and>\n                visited a = visited a' \\<union> R \\<and>\n                visited a' \\<inter> R = {} \\<and>\n                simple_state.more a = simple_state.more a';\n        is_break parami a = is_break parami a'\\<rbrakk>\n       \\<Longrightarrow> ((V0 \\<subseteq> {v.\n     is_discovered_impl v a} \\<longrightarrow>\n                           \\<not> is_empty_stack_impl a) \\<and>\n                          \\<not> is_break parami a') =\n                         ((V0 - R\n                           \\<subseteq> {v.\n  is_discovered_impl v a'} \\<longrightarrow>\n                           \\<not> is_empty_stack_impl a') \\<and>\n                          \\<not> is_break parami a')", "unfolding a.c.is_discovered_impl_def a.c.is_empty_stack_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(ss_stack a, ss_stack a')\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, y). U - R = y}\\<rangle>list_rel \\<and>\n                on_stack a = on_stack a' \\<and>\n                visited a = visited a' \\<union> R \\<and>\n                visited a' \\<inter> R = {} \\<and>\n                simple_state.more a = simple_state.more a';\n        is_break parami a = is_break parami a'\\<rbrakk>\n       \\<Longrightarrow> ((V0 \\<subseteq> {v.\n     v \\<in> visited a} \\<longrightarrow>\n                           ss_stack a \\<noteq> []) \\<and>\n                          \\<not> is_break parami a') =\n                         ((V0 - R\n                           \\<subseteq> {v.\n  v \\<in> visited a'} \\<longrightarrow>\n                           ss_stack a' \\<noteq> []) \\<and>\n                          \\<not> is_break parami a')", "by auto"], ["", "lemma cross_back_id[simp]: \n    \"do_cross_edge u v s = RETURN s\"\n    \"do_back_edge u v s = RETURN s\"\n    \"a.c.do_cross_edge u v s = RETURN s\"\n    \"a.c.do_back_edge u v s = RETURN s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (do_cross_edge u v s = RETURN s &&& do_back_edge u v s = RETURN s) &&&\n    a.c.do_cross_edge u v s = RETURN s &&& a.c.do_back_edge u v s = RETURN s", "unfolding do_action_defs a.c.do_action_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gbs_cross_edge gbs' u v s \\<bind>\n     (\\<lambda>s.\n         on_cross_edge parami u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>))) =\n     RETURN s &&&\n     gbs_back_edge gbs' u v s \\<bind>\n     (\\<lambda>s.\n         on_back_edge parami u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>))) =\n     RETURN s) &&&\n    gbs_cross_edge a.c.gbs u v s \\<bind>\n    (\\<lambda>s.\n        on_cross_edge parami u v s \\<bind>\n        (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>))) =\n    RETURN s &&&\n    gbs_back_edge a.c.gbs u v s \\<bind>\n    (\\<lambda>s.\n        on_back_edge parami u v s \\<bind>\n        (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>))) =\n    RETURN s", "by simp_all"], ["", "lemma pred_rel_simps:\n    assumes \"(s,s')\\<in>rel\"\n    shows \"a.c.is_discovered_impl u s \\<longleftrightarrow> a.c.is_discovered_impl u s' \\<or> u\\<in>R\"\n    and \"a.c.is_empty_stack_impl s \\<longleftrightarrow> a.c.is_empty_stack_impl s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_discovered_impl u s = (is_discovered_impl u s' \\<or> u \\<in> R) &&&\n    is_empty_stack_impl s = is_empty_stack_impl s'", "using assms"], ["proof (prove)\nusing this:\n  (s, s') \\<in> rel\n\ngoal (1 subgoal):\n 1. is_discovered_impl u s = (is_discovered_impl u s' \\<or> u \\<in> R) &&&\n    is_empty_stack_impl s = is_empty_stack_impl s'", "unfolding a.c.is_discovered_impl_def a.c.is_empty_stack_impl_def"], ["proof (prove)\nusing this:\n  (s, s') \\<in> rel\n\ngoal (1 subgoal):\n 1. (u \\<in> visited s) = (u \\<in> visited s' \\<or> u \\<in> R) &&&\n    (ss_stack s = []) = (ss_stack s' = [])", "unfolding rel_def"], ["proof (prove)\nusing this:\n  (s, s')\n  \\<in> {(s, s').\n         (ss_stack s, ss_stack s')\n         \\<in> \\<langle>Id \\<times>\\<^sub>r\n                        {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n         on_stack s = on_stack s' \\<and>\n         visited s = visited s' \\<union> R \\<and>\n         visited s' \\<inter> R = {} \\<and>\n         simple_state.more s = simple_state.more s'}\n\ngoal (1 subgoal):\n 1. (u \\<in> visited s) = (u \\<in> visited s' \\<or> u \\<in> R) &&&\n    (ss_stack s = []) = (ss_stack s' = [])", "by auto"], ["", "lemma no_pending_refine:\n    assumes \"(s,s')\\<in>rel\" \"\\<not>a.c.is_empty_stack_impl s'\"\n    shows \"(hd (ss_stack s) = (u,{})) \\<Longrightarrow> hd (ss_stack s') = (u,{})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (ss_stack s) = (u, {}) \\<Longrightarrow> hd (ss_stack s') = (u, {})", "using assms"], ["proof (prove)\nusing this:\n  (s, s') \\<in> rel\n  \\<not> is_empty_stack_impl s'\n\ngoal (1 subgoal):\n 1. hd (ss_stack s) = (u, {}) \\<Longrightarrow> hd (ss_stack s') = (u, {})", "unfolding a.c.is_empty_stack_impl_def rel_def"], ["proof (prove)\nusing this:\n  (s, s')\n  \\<in> {(s, s').\n         (ss_stack s, ss_stack s')\n         \\<in> \\<langle>Id \\<times>\\<^sub>r\n                        {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n         on_stack s = on_stack s' \\<and>\n         visited s = visited s' \\<union> R \\<and>\n         visited s' \\<inter> R = {} \\<and>\n         simple_state.more s = simple_state.more s'}\n  ss_stack s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (ss_stack s) = (u, {}) \\<Longrightarrow> hd (ss_stack s') = (u, {})", "apply (cases \"ss_stack s'\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>hd (ss_stack s) = (u, {});\n        (s, s')\n        \\<in> {(s, s').\n               (ss_stack s, ss_stack s')\n               \\<in> \\<langle>Id \\<times>\\<^sub>r\n                              {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n               on_stack s = on_stack s' \\<and>\n               visited s = visited s' \\<union> R \\<and>\n               visited s' \\<inter> R = {} \\<and>\n               simple_state.more s = simple_state.more s'};\n        ss_stack s' \\<noteq> []; ss_stack s' = a # list\\<rbrakk>\n       \\<Longrightarrow> hd (ss_stack s') = (u, {})", "apply (auto elim: list_relE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma do_new_root_refine[refine]:\n    \"\\<lbrakk> (v0i,v0)\\<in>Id; (si,s)\\<in>rel; v0\\<notin>R \\<rbrakk> \n      \\<Longrightarrow> do_new_root v0i si \\<le> \\<Down> rel (a.c.do_new_root v0 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R\\<rbrakk>\n    \\<Longrightarrow> do_new_root v0i si\n                      \\<le> \\<Down> rel (a.c.do_new_root v0 s)", "unfolding do_action_defs a.c.do_action_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R\\<rbrakk>\n    \\<Longrightarrow> gbs_new_root gbs' v0i si \\<bind>\n                      (\\<lambda>s.\n                          on_new_root parami v0i s \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (s\\<lparr>simple_state.more := e\\<rparr>)))\n                      \\<le> \\<Down> rel\n                             (gbs_new_root a.c.gbs v0 s \\<bind>\n                              (\\<lambda>s.\n                                  on_new_root parami v0 s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))", "apply refine_rcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R\\<rbrakk>\n    \\<Longrightarrow> gbs_new_root gbs' v0i si\n                      \\<le> \\<Down> ?R' (gbs_new_root a.c.gbs v0 s)\n 2. \\<And>sa saa.\n       \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R;\n        (sa, saa) \\<in> ?R'\\<rbrakk>\n       \\<Longrightarrow> on_new_root parami v0i sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_new_root parami v0 saa)\n 3. \\<And>sa saa e ea.\n       \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R;\n        (sa, saa) \\<in> ?R'; (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (rule intro_prgR[where R=rel])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R\\<rbrakk>\n    \\<Longrightarrow> gbs_new_root gbs' v0i si\n                      \\<le> \\<Down> rel (gbs_new_root a.c.gbs v0 s)\n 2. \\<And>sa saa.\n       \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R;\n        (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_new_root parami v0i sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_new_root parami v0 saa)\n 3. \\<And>sa saa e ea.\n       \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R;\n        (sa, saa) \\<in> rel; (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (simp add: a.c.new_root_impl_def new_root_impl_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>v0i = v0; (si, s) \\<in> rel; v0 \\<notin> R\\<rbrakk>\n    \\<Longrightarrow> ASSERT (v0 \\<notin> visited si) \\<bind>\n                      (\\<lambda>_.\n                          RETURN\n                           (si\\<lparr>ss_stack := [(v0, E `` {v0})],\n                                 on_stack := {v0},\n                                 visited := insert v0 (visited si)\\<rparr>))\n                      \\<le> \\<Down> rel\n                             (ASSERT (v0 \\<notin> visited s) \\<bind>\n                              (\\<lambda>_.\n                                  RETURN\n                                   (s\\<lparr>ss_stack :=\n         [(v0, rel_restrict E R `` {v0})],\n  on_stack := {v0}, visited := insert v0 (visited s)\\<rparr>)))\n 2. \\<And>sa saa.\n       \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R;\n        (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_new_root parami v0i sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_new_root parami v0 saa)\n 3. \\<And>sa saa e ea.\n       \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R;\n        (sa, saa) \\<in> rel; (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (refine_rcg,auto simp: rel_def rel_restrict_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa saa.\n       \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R;\n        (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_new_root parami v0i sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_new_root parami v0 saa)\n 2. \\<And>sa saa e ea.\n       \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R;\n        (sa, saa) \\<in> rel; (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (rule intro_prgR[where R=Id])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa saa.\n       \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R;\n        (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_new_root parami v0i sa\n                         \\<le> \\<Down> Id (on_new_root parami v0 saa)\n 2. \\<And>sa saa e ea.\n       \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R;\n        (sa, saa) \\<in> rel; (e, ea) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (simp add: on_new_root_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa saa e ea.\n       \\<lbrakk>(v0i, v0) \\<in> Id; (si, s) \\<in> rel; v0 \\<notin> R;\n        (sa, saa) \\<in> rel; (e, ea) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (simp add: rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma do_finish_refine[refine]:\n    \"\\<lbrakk>(s, s') \\<in> rel; (u,u')\\<in>Id\\<rbrakk>\n       \\<Longrightarrow> do_finish u s \\<le> \\<Down> rel (a.c.do_finish u' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id\\<rbrakk>\n    \\<Longrightarrow> do_finish u s \\<le> \\<Down> rel (a.c.do_finish u' s')", "unfolding do_action_defs a.c.do_action_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id\\<rbrakk>\n    \\<Longrightarrow> gbs_finish gbs' u s \\<bind>\n                      (\\<lambda>s.\n                          on_finish parami u s \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (s\\<lparr>simple_state.more := e\\<rparr>)))\n                      \\<le> \\<Down> rel\n                             (gbs_finish a.c.gbs u' s' \\<bind>\n                              (\\<lambda>s.\n                                  on_finish parami u' s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))", "apply refine_rcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id\\<rbrakk>\n    \\<Longrightarrow> gbs_finish gbs' u s\n                      \\<le> \\<Down> ?R' (gbs_finish a.c.gbs u' s')\n 2. \\<And>sa saa.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id;\n        (sa, saa) \\<in> ?R'\\<rbrakk>\n       \\<Longrightarrow> on_finish parami u sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_finish parami u' saa)\n 3. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (sa, saa) \\<in> ?R';\n        (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (rule intro_prgR[where R=rel])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id\\<rbrakk>\n    \\<Longrightarrow> gbs_finish gbs' u s\n                      \\<le> \\<Down> rel (gbs_finish a.c.gbs u' s')\n 2. \\<And>sa saa.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id;\n        (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_finish parami u sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_finish parami u' saa)\n 3. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (sa, saa) \\<in> rel;\n        (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (simp add: finish_impl_def is_empty_stack_impl_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(s, s') \\<in> rel; u = u'\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (ss_stack s \\<noteq> [] \\<and>\n                        u' \\<in> on_stack s) \\<bind>\n                      (\\<lambda>_.\n                          RETURN\n                           (s\\<lparr>ss_stack := tl (ss_stack s),\n                                on_stack := on_stack s - {u'}\\<rparr>))\n                      \\<le> \\<Down> rel\n                             (ASSERT\n                               (ss_stack s' \\<noteq> [] \\<and>\n                                u' \\<in> on_stack s') \\<bind>\n                              (\\<lambda>_.\n                                  RETURN\n                                   (s'\\<lparr>ss_stack := tl (ss_stack s'),\n   on_stack := on_stack s' - {u'}\\<rparr>)))\n 2. \\<And>sa saa.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id;\n        (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_finish parami u sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_finish parami u' saa)\n 3. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (sa, saa) \\<in> rel;\n        (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (refine_rcg,auto simp: rel_def rel_restrict_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>u = u'; ss_stack s \\<noteq> [];\n     (ss_stack s, ss_stack s')\n     \\<in> \\<langle>Id \\<times>\\<^sub>r\n                    {(U, y). U - R = y}\\<rangle>list_rel;\n     ss_stack s' \\<noteq> []; u' \\<in> on_stack s';\n     on_stack s = on_stack s'; visited s = visited s' \\<union> R;\n     visited s' \\<inter> R = {};\n     simple_state.more s = simple_state.more s'\\<rbrakk>\n    \\<Longrightarrow> (tl (ss_stack s), tl (ss_stack s'))\n                      \\<in> \\<langle>Id \\<times>\\<^sub>r\n                                     {(U, y). U - R = y}\\<rangle>list_rel\n 2. \\<And>sa saa.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id;\n        (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_finish parami u sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_finish parami u' saa)\n 3. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (sa, saa) \\<in> rel;\n        (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply parametricity"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa saa.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id;\n        (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_finish parami u sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_finish parami u' saa)\n 2. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (sa, saa) \\<in> rel;\n        (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (rule intro_prgR[where R=Id])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa saa.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id;\n        (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_finish parami u sa\n                         \\<le> \\<Down> Id (on_finish parami u' saa)\n 2. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (sa, saa) \\<in> rel;\n        (e, ea) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (simp add: on_finish_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (sa, saa) \\<in> rel;\n        (e, ea) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (simp add: rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aux_cnv_pending: \n    \"\\<lbrakk> (s, s') \\<in> rel; \n      \\<not> is_empty_stack_impl s; vs\\<in>Vs; vs\\<notin>R;\n      hd (ss_stack s) = (u,Vs) \\<rbrakk> \\<Longrightarrow>\n      hd (ss_stack s') = (u,insert vs (Vs-R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> rel; \\<not> is_empty_stack_impl s; vs \\<in> Vs;\n     vs \\<notin> R; hd (ss_stack s) = (u, Vs)\\<rbrakk>\n    \\<Longrightarrow> hd (ss_stack s') = (u, insert vs (Vs - R))", "(* Conc-Pending node that is also in abs-visited is also abs-pending *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> rel; \\<not> is_empty_stack_impl s; vs \\<in> Vs;\n     vs \\<notin> R; hd (ss_stack s) = (u, Vs)\\<rbrakk>\n    \\<Longrightarrow> hd (ss_stack s') = (u, insert vs (Vs - R))", "unfolding rel_def is_empty_stack_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s')\n             \\<in> {(s, s').\n                    (ss_stack s, ss_stack s')\n                    \\<in> \\<langle>Id \\<times>\\<^sub>r\n                                   {(U, U').\n                                    U - R = U'}\\<rangle>list_rel \\<and>\n                    on_stack s = on_stack s' \\<and>\n                    visited s = visited s' \\<union> R \\<and>\n                    visited s' \\<inter> R = {} \\<and>\n                    simple_state.more s = simple_state.more s'};\n     ss_stack s \\<noteq> []; vs \\<in> Vs; vs \\<notin> R;\n     hd (ss_stack s) = (u, Vs)\\<rbrakk>\n    \\<Longrightarrow> hd (ss_stack s') = (u, insert vs (Vs - R))", "apply (cases \"ss_stack s'\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>(s, s')\n                \\<in> {(s, s').\n                       (ss_stack s, ss_stack s')\n                       \\<in> \\<langle>Id \\<times>\\<^sub>r\n{(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n                       on_stack s = on_stack s' \\<and>\n                       visited s = visited s' \\<union> R \\<and>\n                       visited s' \\<inter> R = {} \\<and>\n                       simple_state.more s = simple_state.more s'};\n        ss_stack s \\<noteq> []; vs \\<in> Vs; vs \\<notin> R;\n        hd (ss_stack s) = (u, Vs); ss_stack s' = a # list\\<rbrakk>\n       \\<Longrightarrow> hd (ss_stack s') = (u, insert vs (Vs - R))", "apply (auto elim: list_relE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma get_pending_refine: \n    assumes \"(s, s') \\<in> rel\" \"gen_cond s\" \"\\<not> is_empty_stack_impl s\"\n    shows \"\n      get_pending_impl s \\<le> (sup \n        (\\<Down>(Id \\<times>\\<^sub>r \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel) (inf \n          (get_pending_impl s') \n          (SPEC (\\<lambda>(_,Vs,_). case Vs of None \\<Rightarrow> True | Some v \\<Rightarrow> v\\<notin>R))))\n        (\\<Down>(Id \\<times>\\<^sub>r \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel) (\n          SPEC (\\<lambda>(u,Vs,s''). \\<exists>v. Vs=Some v \\<and> v\\<in>R \\<and> s''=s') \n        )))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_pending_impl s\n    \\<le> sup (\\<Down>\n                (Id \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                (inf (get_pending_impl s')\n                  (SPEC\n                    (\\<lambda>(uu_, Vs, uu_).\n                        case Vs of None \\<Rightarrow> True\n                        | Some v \\<Rightarrow> v \\<notin> R))))\n           (\\<Down>\n             (Id \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n             (SPEC\n               (\\<lambda>(u, Vs, s'').\n                   \\<exists>v.\n                      Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. get_pending_impl s\n    \\<le> sup (\\<Down>\n                (Id \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                (inf (get_pending_impl s')\n                  (SPEC\n                    (\\<lambda>(uu_, Vs, uu_).\n                        case Vs of None \\<Rightarrow> True\n                        | Some v \\<Rightarrow> v \\<notin> R))))\n           (\\<Down>\n             (Id \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n             (SPEC\n               (\\<lambda>(u, Vs, s'').\n                   \\<exists>v.\n                      Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "from assms"], ["proof (chain)\npicking this:\n  (s, s') \\<in> rel\n  gen_cond s\n  \\<not> is_empty_stack_impl s", "have \n      [simp]: \"ss_stack s' \\<noteq> []\"\n      and [simp]: \"ss_stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  (s, s') \\<in> rel\n  gen_cond s\n  \\<not> is_empty_stack_impl s\n\ngoal (1 subgoal):\n 1. ss_stack s' \\<noteq> [] &&& ss_stack s \\<noteq> []", "unfolding rel_def impl_defs"], ["proof (prove)\nusing this:\n  (s, s')\n  \\<in> {(s, s').\n         (ss_stack s, ss_stack s')\n         \\<in> \\<langle>Id \\<times>\\<^sub>r\n                        {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n         on_stack s = on_stack s' \\<and>\n         visited s = visited s' \\<union> R \\<and>\n         visited s' \\<inter> R = {} \\<and>\n         simple_state.more s = simple_state.more s'}\n  gen_cond s\n  ss_stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. ss_stack s' \\<noteq> [] &&& ss_stack s \\<noteq> []", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ss_stack s' \\<noteq> []\n  ss_stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. get_pending_impl s\n    \\<le> sup (\\<Down>\n                (Id \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                (inf (get_pending_impl s')\n                  (SPEC\n                    (\\<lambda>(uu_, Vs, uu_).\n                        case Vs of None \\<Rightarrow> True\n                        | Some v \\<Rightarrow> v \\<notin> R))))\n           (\\<Down>\n             (Id \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n             (SPEC\n               (\\<lambda>(u, Vs, s'').\n                   \\<exists>v.\n                      Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "from assms"], ["proof (chain)\npicking this:\n  (s, s') \\<in> rel\n  gen_cond s\n  \\<not> is_empty_stack_impl s", "show ?thesis"], ["proof (prove)\nusing this:\n  (s, s') \\<in> rel\n  gen_cond s\n  \\<not> is_empty_stack_impl s\n\ngoal (1 subgoal):\n 1. get_pending_impl s\n    \\<le> sup (\\<Down>\n                (Id \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                (inf (get_pending_impl s')\n                  (SPEC\n                    (\\<lambda>(uu_, Vs, uu_).\n                        case Vs of None \\<Rightarrow> True\n                        | Some v \\<Rightarrow> v \\<notin> R))))\n           (\\<Down>\n             (Id \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n             (SPEC\n               (\\<lambda>(u, Vs, s'').\n                   \\<exists>v.\n                      Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "unfolding get_pending_impl_def"], ["proof (prove)\nusing this:\n  (s, s') \\<in> rel\n  gen_cond s\n  \\<not> is_empty_stack_impl s\n\ngoal (1 subgoal):\n 1. ASSERT (ss_stack s \\<noteq> []) \\<bind>\n    (\\<lambda>_.\n        let (u, Vs) = hd (ss_stack s)\n        in if Vs = {} then RETURN (u, None, s)\n           else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                (\\<lambda>v.\n                    let Vs = Vs - {v};\n                        s = s\\<lparr>ss_stack :=\n (u, Vs) # tl (ss_stack s)\\<rparr>\n                    in RETURN (u, Some v, s)))\n    \\<le> sup (\\<Down>\n                (Id \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                (inf (ASSERT (ss_stack s' \\<noteq> []) \\<bind>\n                      (\\<lambda>_.\n                          let (u, Vs) = hd (ss_stack s')\n                          in if Vs = {} then RETURN (u, None, s')\n                             else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                                  (\\<lambda>v.\nlet Vs = Vs - {v};\n    s = s'\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\nin RETURN (u, Some v, s))))\n                  (SPEC\n                    (\\<lambda>(uu_, Vs, uu_).\n                        case Vs of None \\<Rightarrow> True\n                        | Some v \\<Rightarrow> v \\<notin> R))))\n           (\\<Down>\n             (Id \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n             (SPEC\n               (\\<lambda>(u, Vs, s'').\n                   \\<exists>v.\n                      Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (subst Let_def, subst Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n     (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s\\<rbrakk>\n    \\<Longrightarrow> ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                      (\\<lambda>_.\n                          case hd (ss_stack s) of\n                          (u, Vs) \\<Rightarrow>\n                            if Vs = {} then RETURN (u, None, s)\n                            else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                                 (\\<lambda>v.\n                                     let s = s\n     \\<lparr>ss_stack := (u, Vs - {v}) # tl (ss_stack s)\\<rparr>\n                                     in RETURN (u, Some v, s)))\n                      \\<le> sup (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (inf (ASSERT\n   (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n                                    (SPEC\n(\\<lambda>(uu_, Vs, uu_).\n    case Vs of None \\<Rightarrow> True\n    | Some v \\<Rightarrow> v \\<notin> R))))\n                             (\\<Down>\n                               (Id \\<times>\\<^sub>r\n                                \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                rel)\n                               (SPEC\n                                 (\\<lambda>(u, Vs, s'').\n                                     \\<exists>v.\n  Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (rule ASSERT_leI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n     (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s\\<rbrakk>\n    \\<Longrightarrow> ss_stack s \\<noteq> []\n 2. \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n     (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n     ss_stack s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (case hd (ss_stack s) of\n                       (u, Vs) \\<Rightarrow>\n                         if Vs = {} then RETURN (u, None, s)\n                         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                              (\\<lambda>v.\n                                  let s = s\n  \\<lparr>ss_stack := (u, Vs - {v}) # tl (ss_stack s)\\<rparr>\n                                  in RETURN (u, Some v, s)))\n                      \\<le> sup (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (inf (ASSERT\n   (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n                                    (SPEC\n(\\<lambda>(uu_, Vs, uu_).\n    case Vs of None \\<Rightarrow> True\n    | Some v \\<Rightarrow> v \\<notin> R))))\n                             (\\<Down>\n                               (Id \\<times>\\<^sub>r\n                                \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                rel)\n                               (SPEC\n                                 (\\<lambda>(u, Vs, s'').\n                                     \\<exists>v.\n  Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (auto simp: impl_defs gen_cond_def rel_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n     (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n     ss_stack s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (case hd (ss_stack s) of\n                       (u, Vs) \\<Rightarrow>\n                         if Vs = {} then RETURN (u, None, s)\n                         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                              (\\<lambda>v.\n                                  let s = s\n  \\<lparr>ss_stack := (u, Vs - {v}) # tl (ss_stack s)\\<rparr>\n                                  in RETURN (u, Some v, s)))\n                      \\<le> sup (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (inf (ASSERT\n   (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n                                    (SPEC\n(\\<lambda>(uu_, Vs, uu_).\n    case Vs of None \\<Rightarrow> True\n    | Some v \\<Rightarrow> v \\<notin> R))))\n                             (\\<Down>\n                               (Id \\<times>\\<^sub>r\n                                \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                rel)\n                               (SPEC\n                                 (\\<lambda>(u, Vs, s'').\n                                     \\<exists>v.\n  Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (split prod.split, intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        ss_stack s \\<noteq> []; hd (ss_stack s) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> (if x2 = {} then RETURN (x1, None, s)\n                          else SPEC (\\<lambda>v. v \\<in> x2) \\<bind>\n                               (\\<lambda>v.\n                                   let s = s\n   \\<lparr>ss_stack := (x1, x2 - {v}) # tl (ss_stack s)\\<rparr>\n                                   in RETURN (x1, Some v, s)))\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\n\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                                     (inf\n (ASSERT (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (rule lhs_step_If)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        ss_stack s \\<noteq> []; hd (ss_stack s) = (x1, x2); x2 = {}\\<rbrakk>\n       \\<Longrightarrow> RETURN (x1, None, s)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\n\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                                     (inf\n (ASSERT (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))\n 2. \\<And>x1 x2.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        ss_stack s \\<noteq> []; hd (ss_stack s) = (x1, x2);\n        x2 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>v. v \\<in> x2) \\<bind>\n                         (\\<lambda>v.\n                             let s = s\\<lparr>ss_stack :=\n          (x1, x2 - {v}) # tl (ss_stack s)\\<rparr>\n                             in RETURN (x1, Some v, s))\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\n\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                                     (inf\n (ASSERT (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "(* No pending *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        ss_stack s \\<noteq> []; hd (ss_stack s) = (x1, x2); x2 = {}\\<rbrakk>\n       \\<Longrightarrow> RETURN (x1, None, s)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\n\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                                     (inf\n (ASSERT (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))\n 2. \\<And>x1 x2.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        ss_stack s \\<noteq> []; hd (ss_stack s) = (x1, x2);\n        x2 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>v. v \\<in> x2) \\<bind>\n                         (\\<lambda>v.\n                             let s = s\\<lparr>ss_stack :=\n          (x1, x2 - {v}) # tl (ss_stack s)\\<rparr>\n                             in RETURN (x1, Some v, s))\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\n\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                                     (inf\n (ASSERT (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (rule le_supI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        ss_stack s \\<noteq> []; hd (ss_stack s) = (x1, x2); x2 = {}\\<rbrakk>\n       \\<Longrightarrow> RETURN (x1, None, s)\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                 rel)\n                                (inf (ASSERT\n (ss_stack s' \\<noteq> []) \\<bind>\n(\\<lambda>_.\n    let (u, Vs) = hd (ss_stack s')\n    in if Vs = {} then RETURN (u, None, s')\n       else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n            (\\<lambda>v.\n                let Vs = Vs - {v};\n                    s = s'\n                      \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n                in RETURN (u, Some v, s))))\n                                  (SPEC\n                                    (\\<lambda>(uu_, Vs, uu_).\n  case Vs of None \\<Rightarrow> True | Some v \\<Rightarrow> v \\<notin> R)))\n 2. \\<And>x1 x2.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        ss_stack s \\<noteq> []; hd (ss_stack s) = (x1, x2);\n        x2 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>v. v \\<in> x2) \\<bind>\n                         (\\<lambda>v.\n                             let s = s\\<lparr>ss_stack :=\n          (x1, x2 - {v}) # tl (ss_stack s)\\<rparr>\n                             in RETURN (x1, Some v, s))\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\n\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                                     (inf\n (ASSERT (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (simp add: pred_rel_simps no_pending_refine restr_rel_simps\n          RETURN_RES_refine_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        ss_stack s \\<noteq> []; hd (ss_stack s) = (x1, x2);\n        x2 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>v. v \\<in> x2) \\<bind>\n                         (\\<lambda>v.\n                             let s = s\\<lparr>ss_stack :=\n          (x1, x2 - {v}) # tl (ss_stack s)\\<rparr>\n                             in RETURN (x1, Some v, s))\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\n\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                                     (inf\n (ASSERT (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "(* Pending *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        ss_stack s \\<noteq> []; hd (ss_stack s) = (x1, x2);\n        x2 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>v. v \\<in> x2) \\<bind>\n                         (\\<lambda>v.\n                             let s = s\\<lparr>ss_stack :=\n          (x1, x2 - {v}) # tl (ss_stack s)\\<rparr>\n                             in RETURN (x1, Some v, s))\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\n\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                                     (inf\n (ASSERT (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (rule lhs_step_bind, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        (s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        ss_stack s \\<noteq> []; hd (ss_stack s) = (x1, x2); x2 \\<noteq> {};\n        nf_inres (SPEC (\\<lambda>v. v \\<in> x2)) v\\<rbrakk>\n       \\<Longrightarrow> (let s = s\\<lparr>ss_stack :=\n       (x1, x2 - {v}) # tl (ss_stack s)\\<rparr>\n                          in RETURN (x1, Some v, s))\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\n\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n                                     (inf\n (ASSERT (ss_stack s' \\<noteq> []) \\<bind>\n  (\\<lambda>_.\n      let (u, Vs) = hd (ss_stack s')\n      in if Vs = {} then RETURN (u, None, s')\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s'\n                        \\<lparr>ss_stack :=\n                                  (u, Vs) # tl (ss_stack s')\\<rparr>\n                  in RETURN (u, Some v, s))))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                   rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (simp split del: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (rename_tac v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (case_tac \"v\\<in>R\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<in> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))\n 2. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "(* Spurious node from R *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<in> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))\n 2. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (rule le_supI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<in> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r rel)\n                                (SPEC\n                                  (\\<lambda>(u, Vs, s'').\n\\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s'))\n 2. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (rule RETURN_SPEC_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            ((x1, Some v, s\n                              \\<lparr>ss_stack :=\n  (x1, x2 - {v}) # tl (ss_stack s)\\<rparr>),\n                             x')\n                            \\<in> Id \\<times>\\<^sub>r\n                                  Id \\<times>\\<^sub>r rel \\<and>\n                            (case x' of\n                             (u, Vs, s'') \\<Rightarrow>\n                               \\<exists>v.\n                                  Vs = Some v \\<and>\n                                  v \\<in> R \\<and> s'' = s')\n 2. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (auto simp: rel_def is_empty_stack_impl_def neq_Nil_conv) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 v x.\n       \\<lbrakk>gen_cond s; hd (ss_stack s) = (x1, x2); v \\<in> x2;\n        v \\<in> R;\n        (ss_stack s, ss_stack s')\n        \\<in> \\<langle>Id \\<times>\\<^sub>r\n                       {(U, y). U - R = y}\\<rangle>list_rel;\n        on_stack s = on_stack s'; visited s = visited s' \\<union> R;\n        visited s' \\<inter> R = {};\n        simple_state.more s = simple_state.more s';\n        ((x1, x2 - {v}) # tl (ss_stack s), ss_stack s')\n        \\<notin> \\<langle>Id \\<times>\\<^sub>r\n                          {(U, y). U - R = y}\\<rangle>list_rel;\n        x \\<in> x2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (cases \"ss_stack s'\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 v x a list.\n       \\<lbrakk>gen_cond s; hd (ss_stack s) = (x1, x2); v \\<in> x2;\n        v \\<in> R;\n        (ss_stack s, ss_stack s')\n        \\<in> \\<langle>Id \\<times>\\<^sub>r\n                       {(U, y). U - R = y}\\<rangle>list_rel;\n        on_stack s = on_stack s'; visited s = visited s' \\<union> R;\n        visited s' \\<inter> R = {};\n        simple_state.more s = simple_state.more s';\n        ((x1, x2 - {v}) # tl (ss_stack s), ss_stack s')\n        \\<notin> \\<langle>Id \\<times>\\<^sub>r\n                          {(U, y). U - R = y}\\<rangle>list_rel;\n        x \\<in> x2; ss_stack s' = a # list\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (auto elim!: list_relE) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "(* Non-spurious node *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> sup (\\<Down>\n                                     (Id \\<times>\\<^sub>r\nId \\<times>\\<^sub>r rel)\n                                     (inf\n (case hd (ss_stack s') of\n  (u, Vs) \\<Rightarrow>\n    if Vs = {} then RETURN (u, None, s')\n    else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n         (\\<lambda>v.\n             let Vs = Vs - {v};\n                 s = s'\n                   \\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n             in RETURN (u, Some v, s)))\n (SPEC\n   (\\<lambda>(uu_, Vs, uu_).\n       case Vs of None \\<Rightarrow> True\n       | Some v \\<Rightarrow> v \\<notin> R))))\n                                (\\<Down>\n                                  (Id \\<times>\\<^sub>r\n                                   Id \\<times>\\<^sub>r rel)\n                                  (SPEC\n                                    (\\<lambda>(u, Vs, s'').\n  \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))", "apply (rule le_supI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r rel)\n                                (inf (case hd (ss_stack s') of\n(u, Vs) \\<Rightarrow>\n  if Vs = {} then RETURN (u, None, s')\n  else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n       (\\<lambda>v.\n           let Vs = Vs - {v};\n               s = s'\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n           in RETURN (u, Some v, s)))\n                                  (SPEC\n                                    (\\<lambda>(uu_, Vs, uu_).\n  case Vs of None \\<Rightarrow> True | Some v \\<Rightarrow> v \\<notin> R)))", "apply (frule (4) aux_cnv_pending)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; \\<not> is_empty_stack_impl s;\n        hd (ss_stack s) = (x1, x2); x2 \\<noteq> {}; v \\<in> x2;\n        v \\<notin> R; hd (ss_stack s') = (x1, insert v (x2 - R))\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r rel)\n                                (inf (case hd (ss_stack s') of\n(u, Vs) \\<Rightarrow>\n  if Vs = {} then RETURN (u, None, s')\n  else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n       (\\<lambda>v.\n           let Vs = Vs - {v};\n               s = s'\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s')\\<rparr>\n           in RETURN (u, Some v, s)))\n                                  (SPEC\n                                    (\\<lambda>(uu_, Vs, uu_).\n  case Vs of None \\<Rightarrow> True | Some v \\<Rightarrow> v \\<notin> R)))", "apply (simp add: no_pending_refine pred_rel_simps memb_imp_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s;\n        \\<not> is_empty_stack_impl s'; hd (ss_stack s) = (x1, x2);\n        v \\<in> x2; v \\<notin> R;\n        hd (ss_stack s') = (x1, insert v (x2 - R))\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r rel)\n                                (inf (SPEC\n (\\<lambda>va. va = v \\<or> va \\<in> x2 \\<and> va \\<notin> R) \\<bind>\n(\\<lambda>va.\n    RETURN\n     (x1, Some va, s'\n      \\<lparr>ss_stack :=\n                (x1, insert v (x2 - R) - {va}) # tl (ss_stack s')\\<rparr>)))\n                                  (SPEC\n                                    (\\<lambda>(uu_, Vs, uu_).\n  case Vs of None \\<Rightarrow> True | Some v \\<Rightarrow> v \\<notin> R)))", "apply (subst nofail_inf_serialize, \n            (simp_all add: refine_pw_simps split: prod.splits) [2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s;\n        \\<not> is_empty_stack_impl s'; hd (ss_stack s) = (x1, x2);\n        v \\<in> x2; v \\<notin> R;\n        hd (ss_stack s') = (x1, insert v (x2 - R))\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r rel)\n                                (SPEC\n                                  (\\<lambda>va.\nva = v \\<or> va \\<in> x2 \\<and> va \\<notin> R) \\<bind>\n                                 (\\<lambda>va.\n                                     RETURN\n(x1, Some va, s'\n \\<lparr>ss_stack :=\n           (x1, insert v (x2 - R) - {va}) #\n           tl (ss_stack s')\\<rparr>)) \\<bind>\n                                 (\\<lambda>x.\n                                     ASSUME\n(inres\n  (SPEC\n    (\\<lambda>(uu_, Vs, uu_).\n        case Vs of None \\<Rightarrow> True\n        | Some v \\<Rightarrow> v \\<notin> R))\n  x) \\<bind>\n                                     (\\<lambda>_. RETURN x)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s;\n        \\<not> is_empty_stack_impl s'; hd (ss_stack s) = (x1, x2);\n        v \\<in> x2; v \\<notin> R;\n        hd (ss_stack s') = (x1, insert v (x2 - R))\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r rel)\n                                (SPEC\n                                  (\\<lambda>va.\nva = v \\<or> va \\<in> x2 \\<and> va \\<notin> R) \\<bind>\n                                 (\\<lambda>x.\n                                     ASSUME (x \\<notin> R) \\<bind>\n                                     (\\<lambda>_.\n   RETURN\n    (x1, Some x, s'\n     \\<lparr>ss_stack :=\n               (x1, insert v (x2 - R) - {x}) # tl (ss_stack s')\\<rparr>))))", "apply (rule rhs_step_bind_RES, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s;\n        \\<not> is_empty_stack_impl s'; hd (ss_stack s) = (x1, x2);\n        v \\<in> x2; v \\<notin> R;\n        hd (ss_stack s') = (x1, insert v (x2 - R))\\<rbrakk>\n       \\<Longrightarrow> RETURN\n                          (x1, Some v, s\n                           \\<lparr>ss_stack :=\n                                     (x1, x2 - {v}) #\n                                     tl (ss_stack s)\\<rparr>)\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r rel)\n                                (ASSUME (v \\<notin> R) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(x1, Some v, s'\n \\<lparr>ss_stack :=\n           (x1, insert v (x2 - R) - {v}) # tl (ss_stack s')\\<rparr>)))", "apply (simp add: rel_def is_empty_stack_impl_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v.\n       \\<lbrakk>(ss_stack s, ss_stack s')\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, y). U - R = y}\\<rangle>list_rel \\<and>\n                on_stack s = on_stack s' \\<and>\n                visited s = visited s' \\<union> R \\<and>\n                visited s' \\<inter> R = {} \\<and>\n                simple_state.more s = simple_state.more s';\n        gen_cond s; hd (ss_stack s) = (x1, x2); v \\<in> x2; v \\<notin> R;\n        hd (ss_stack s') = (x1, insert v (x2 - R))\\<rbrakk>\n       \\<Longrightarrow> x2 - {v} - R = x2 - R - {v} \\<and>\n                         (tl (ss_stack s), tl (ss_stack s'))\n                         \\<in> \\<langle>Id \\<times>\\<^sub>r\n  {(U, y). U - R = y}\\<rangle>list_rel", "apply (cases \"ss_stack s'\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 v a list.\n       \\<lbrakk>(ss_stack s, ss_stack s')\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, y). U - R = y}\\<rangle>list_rel \\<and>\n                on_stack s = on_stack s' \\<and>\n                visited s = visited s' \\<union> R \\<and>\n                visited s' \\<inter> R = {} \\<and>\n                simple_state.more s = simple_state.more s';\n        gen_cond s; hd (ss_stack s) = (x1, x2); v \\<in> x2; v \\<notin> R;\n        hd (ss_stack s') = (x1, insert v (x2 - R));\n        ss_stack s' = a # list\\<rbrakk>\n       \\<Longrightarrow> x2 - {v} - R = x2 - R - {v} \\<and>\n                         (tl (ss_stack s), tl (ss_stack s'))\n                         \\<in> \\<langle>Id \\<times>\\<^sub>r\n  {(U, y). U - R = y}\\<rangle>list_rel", "apply (auto elim: list_relE) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  get_pending_impl s\n  \\<le> sup (\\<Down>\n              (Id \\<times>\\<^sub>r\n               \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n              (inf (get_pending_impl s')\n                (SPEC\n                  (\\<lambda>(uu_, Vs, uu_).\n                      case Vs of None \\<Rightarrow> True\n                      | Some v \\<Rightarrow> v \\<notin> R))))\n         (\\<Down>\n           (Id \\<times>\\<^sub>r\n            \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r rel)\n           (SPEC\n             (\\<lambda>(u, Vs, s'').\n                 \\<exists>v. Vs = Some v \\<and> v \\<in> R \\<and> s'' = s')))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma do_discover_refine[refine]:\n    \"\\<lbrakk> (s, s') \\<in> rel; (u,u')\\<in>Id; (v,v')\\<in>Id; v' \\<notin> R \\<rbrakk>\n       \\<Longrightarrow> do_discover u v s \\<le> \\<Down> rel (a.c.do_discover u' v' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n     v' \\<notin> R\\<rbrakk>\n    \\<Longrightarrow> do_discover u v s\n                      \\<le> \\<Down> rel (a.c.do_discover u' v' s')", "unfolding do_action_defs a.c.do_action_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n     v' \\<notin> R\\<rbrakk>\n    \\<Longrightarrow> gbs_discover gbs' u v s \\<bind>\n                      (\\<lambda>s.\n                          on_discover parami u v s \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (s\\<lparr>simple_state.more := e\\<rparr>)))\n                      \\<le> \\<Down> rel\n                             (gbs_discover a.c.gbs u' v' s' \\<bind>\n                              (\\<lambda>s.\n                                  on_discover parami u' v' s \\<bind>\n                                  (\\<lambda>e.\nRETURN (s\\<lparr>simple_state.more := e\\<rparr>))))", "apply refine_rcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n     v' \\<notin> R\\<rbrakk>\n    \\<Longrightarrow> gbs_discover gbs' u v s\n                      \\<le> \\<Down> ?R' (gbs_discover a.c.gbs u' v' s')\n 2. \\<And>sa saa.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n        v' \\<notin> R; (sa, saa) \\<in> ?R'\\<rbrakk>\n       \\<Longrightarrow> on_discover parami u v sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_discover parami u' v' saa)\n 3. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n        v' \\<notin> R; (sa, saa) \\<in> ?R';\n        (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (rule intro_prgR[where R=rel])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n     v' \\<notin> R\\<rbrakk>\n    \\<Longrightarrow> gbs_discover gbs' u v s\n                      \\<le> \\<Down> rel (gbs_discover a.c.gbs u' v' s')\n 2. \\<And>sa saa.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n        v' \\<notin> R; (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_discover parami u v sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_discover parami u' v' saa)\n 3. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n        v' \\<notin> R; (sa, saa) \\<in> rel;\n        (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (simp add: discover_impl_def a.c.discover_impl_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(s, s') \\<in> rel; u = u'; v = v'; v' \\<notin> R\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (v' \\<notin> on_stack s \\<and>\n                        v' \\<notin> visited s) \\<bind>\n                      (\\<lambda>_.\n                          RETURN\n                           (s\\<lparr>ss_stack :=\n (v', E `` {v'}) # ss_stack s,\n                                on_stack := insert v' (on_stack s),\n                                visited := insert v' (visited s)\\<rparr>))\n                      \\<le> \\<Down> rel\n                             (ASSERT\n                               (v' \\<notin> on_stack s' \\<and>\n                                v' \\<notin> visited s') \\<bind>\n                              (\\<lambda>_.\n                                  RETURN\n                                   (s'\\<lparr>ss_stack :=\n          (v', rel_restrict E R `` {v'}) # ss_stack s',\n   on_stack := insert v' (on_stack s'),\n   visited := insert v' (visited s')\\<rparr>)))\n 2. \\<And>sa saa.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n        v' \\<notin> R; (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_discover parami u v sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_discover parami u' v' saa)\n 3. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n        v' \\<notin> R; (sa, saa) \\<in> rel;\n        (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (refine_rcg,auto simp: rel_def rel_restrict_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa saa.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n        v' \\<notin> R; (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_discover parami u v sa\n                         \\<le> \\<Down> (?R'1 sa saa)\n                                (on_discover parami u' v' saa)\n 2. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n        v' \\<notin> R; (sa, saa) \\<in> rel;\n        (e, ea) \\<in> ?R'1 sa saa\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (rule intro_prgR[where R=Id])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa saa.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n        v' \\<notin> R; (sa, saa) \\<in> rel\\<rbrakk>\n       \\<Longrightarrow> on_discover parami u v sa\n                         \\<le> \\<Down> Id (on_discover parami u' v' saa)\n 2. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n        v' \\<notin> R; (sa, saa) \\<in> rel; (e, ea) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (simp add: on_discover_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa saa e ea.\n       \\<lbrakk>(s, s') \\<in> rel; (u, u') \\<in> Id; (v, v') \\<in> Id;\n        v' \\<notin> R; (sa, saa) \\<in> rel; (e, ea) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (sa\\<lparr>simple_state.more := e\\<rparr>, saa\n                          \\<lparr>simple_state.more := ea\\<rparr>)\n                         \\<in> rel", "apply (auto simp: rel_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aux_R_node_discovered: \"\\<lbrakk>(s,s')\\<in>rel; v\\<in>R\\<rbrakk> \\<Longrightarrow> is_discovered_impl v s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> rel; v \\<in> R\\<rbrakk>\n    \\<Longrightarrow> is_discovered_impl v s", "by (auto simp: pred_rel_simps)"], ["", "lemma re_refine_aux: \"gen_dfs \\<le> \\<Down>rel a.c.gen_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs \\<le> \\<Down> rel a.c.gen_dfs", "unfolding a.c.gen_dfs_def gen_dfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE gen_cond gen_step\n    \\<le> \\<Down> rel\n           (gds_init a.c.gds \\<bind> WHILE a.c.gen_cond a.c.gen_step)", "apply (simp del: graph_restrict_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. do_init \\<bind> WHILE gen_cond gen_step\n    \\<le> \\<Down> rel (a.c.do_init \\<bind> WHILE a.c.gen_cond a.c.gen_step)", "(* Some manual refinements for finer control *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. do_init \\<bind> WHILE gen_cond gen_step\n    \\<le> \\<Down> rel (a.c.do_init \\<bind> WHILE a.c.gen_cond a.c.gen_step)", "apply (rule bind_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. do_init \\<le> \\<Down> ?R'1 a.c.do_init\n 2. \\<And>x x'.\n       (x, x') \\<in> ?R'1 \\<Longrightarrow>\n       WHILE gen_cond gen_step x\n       \\<le> \\<Down> rel (WHILE a.c.gen_cond a.c.gen_step x')", "apply (refine_rcg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       (x, x') \\<in> rel \\<Longrightarrow>\n       WHILE gen_cond gen_step x\n       \\<le> \\<Down> rel (WHILE a.c.gen_cond a.c.gen_step x')", "apply (erule WHILE_invisible_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x' s s'.\n       \\<lbrakk>(s, s') \\<in> rel; a.c.gen_cond s'\\<rbrakk>\n       \\<Longrightarrow> gen_cond s\n 2. \\<And>x x' s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> gen_step s\n                         \\<le> sup (\\<Down> rel\n                                     (ASSUME (a.c.gen_cond s') \\<bind>\n(\\<lambda>_. a.c.gen_step s')))\n                                (\\<Down> rel (RETURN s'))", "(* Condition *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x' s s'.\n       \\<lbrakk>(s, s') \\<in> rel; a.c.gen_cond s'\\<rbrakk>\n       \\<Longrightarrow> gen_cond s\n 2. \\<And>x x' s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> gen_step s\n                         \\<le> sup (\\<Down> rel\n                                     (ASSUME (a.c.gen_cond s') \\<bind>\n(\\<lambda>_. a.c.gen_step s')))\n                                (\\<Down> rel (RETURN s'))", "apply (frule gen_cond_param[param_fo], fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> gen_step s\n                         \\<le> sup (\\<Down> rel\n                                     (ASSUME (a.c.gen_cond s') \\<bind>\n(\\<lambda>_. a.c.gen_step s')))\n                                (\\<Down> rel (RETURN s'))", "(* Step *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> gen_step s\n                         \\<le> sup (\\<Down> rel\n                                     (ASSUME (a.c.gen_cond s') \\<bind>\n(\\<lambda>_. a.c.gen_step s')))\n                                (\\<Down> rel (RETURN s'))", "apply (frule (1) gen_cond_param[param_fo, THEN IdD, THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s'\\<rbrakk>\n       \\<Longrightarrow> gen_step s\n                         \\<le> sup (\\<Down> rel\n                                     (ASSUME (a.c.gen_cond s') \\<bind>\n(\\<lambda>_. a.c.gen_step s')))\n                                (\\<Down> rel (RETURN s'))", "apply (simp del: graph_restrict_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s'\\<rbrakk>\n       \\<Longrightarrow> gen_step s\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "unfolding gen_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s'\\<rbrakk>\n       \\<Longrightarrow> (if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0. gds_new_root gds v0 s)\n                          else gds_get_pending gds s \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow> gds_finish gds u s\n                                   | Some v \\<Rightarrow>\n if gds_is_discovered gds v s\n then if gds_is_finished gds v s then gds_cross_edge gds u v s\n      else gds_back_edge gds u v s\n else gds_discover gds u v s))\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (simp del: graph_restrict_simps cong: if_cong option.case_cong split del: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s'\\<rbrakk>\n       \\<Longrightarrow> (if is_empty_stack_impl s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> is_discovered_impl v0 s) \\<bind>\n                               (\\<lambda>v0. do_new_root v0 s)\n                          else get_pending_impl s \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow> do_finish u s\n                                   | Some v \\<Rightarrow>\n if is_discovered_impl v s then RETURN s else do_discover u v s))\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (rule lhs_step_If)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        is_empty_stack_impl s\\<rbrakk>\n       \\<Longrightarrow> SPEC\n                          (\\<lambda>v0.\n                              v0 \\<in> V0 \\<and>\n                              \\<not> is_discovered_impl v0 s) \\<bind>\n                         (\\<lambda>v0. do_new_root v0 s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s\\<rbrakk>\n       \\<Longrightarrow> get_pending_impl s \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "(* new_root *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        is_empty_stack_impl s\\<rbrakk>\n       \\<Longrightarrow> SPEC\n                          (\\<lambda>v0.\n                              v0 \\<in> V0 \\<and>\n                              \\<not> is_discovered_impl v0 s) \\<bind>\n                         (\\<lambda>v0. do_new_root v0 s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s\\<rbrakk>\n       \\<Longrightarrow> get_pending_impl s \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (frule (1) pred_rel_simps[THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        is_empty_stack_impl s; is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> SPEC\n                          (\\<lambda>v0.\n                              v0 \\<in> V0 \\<and>\n                              \\<not> is_discovered_impl v0 s) \\<bind>\n                         (\\<lambda>v0. do_new_root v0 s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s\\<rbrakk>\n       \\<Longrightarrow> get_pending_impl s \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (rule le_supI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        is_empty_stack_impl s; is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> SPEC\n                          (\\<lambda>v0.\n                              v0 \\<in> V0 \\<and>\n                              \\<not> is_discovered_impl v0 s) \\<bind>\n                         (\\<lambda>v0. do_new_root v0 s)\n                         \\<le> \\<Down> rel (a.c.gen_step s')\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s\\<rbrakk>\n       \\<Longrightarrow> get_pending_impl s \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (simp add: a.c.gen_step_def del: graph_restrict_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        is_empty_stack_impl s; is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> SPEC\n                          (\\<lambda>v0.\n                              v0 \\<in> V0 \\<and>\n                              \\<not> is_discovered_impl v0 s) \\<bind>\n                         (\\<lambda>v0. do_new_root v0 s)\n                         \\<le> \\<Down> rel\n                                (SPEC\n                                  (\\<lambda>v0.\nv0 \\<in> a.a.V0 \\<and> \\<not> is_discovered_impl v0 s') \\<bind>\n                                 (\\<lambda>v0. a.c.do_new_root v0 s'))\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s\\<rbrakk>\n       \\<Longrightarrow> get_pending_impl s \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply refine_rcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        is_empty_stack_impl s; is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> SPEC\n                          (\\<lambda>v0.\n                              v0 \\<in> V0 \\<and>\n                              \\<not> is_discovered_impl v0 s)\n                         \\<le> SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> a.a.V0 \\<and>\n                                    \\<not> is_discovered_impl v0 s')\n 2. \\<And>s s' v0 v0a.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        is_empty_stack_impl s; is_empty_stack_impl s'; (v0, v0a) \\<in> Id;\n        v0 \\<in> {v0 \\<in> V0. \\<not> is_discovered_impl v0 s};\n        v0a\n        \\<in> {v0 \\<in> a.a.V0. \\<not> is_discovered_impl v0 s'}\\<rbrakk>\n       \\<Longrightarrow> v0a \\<notin> R\n 3. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s\\<rbrakk>\n       \\<Longrightarrow> get_pending_impl s \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (auto simp: pred_rel_simps) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s\\<rbrakk>\n       \\<Longrightarrow> get_pending_impl s \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "(* pending edges *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s\\<rbrakk>\n       \\<Longrightarrow> get_pending_impl s \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (frule (1) pred_rel_simps[THEN Not_eq_iff[symmetric, THEN iffD1], THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> get_pending_impl s \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "thm order_trans[OF bind_mono(1)[OF get_pending_refine order_refl]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> get_pending_impl s \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (rule order_trans[OF bind_mono(1)[OF get_pending_refine order_refl]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> (s, ?s'43 s s') \\<in> rel\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> gen_cond s\n 3. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_empty_stack_impl s\n 4. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> sup (\\<Down>\n                               (Id \\<times>\\<^sub>r\n                                \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                rel)\n                               (inf (get_pending_impl (?s'43 s s'))\n                                 (SPEC\n                                   (\\<lambda>(uu_, Vs, uu_).\n case Vs of None \\<Rightarrow> True | Some v \\<Rightarrow> v \\<notin> R))))\n                          (\\<Down>\n                            (Id \\<times>\\<^sub>r\n                             \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                             rel)\n                            (SPEC\n                              (\\<lambda>(u, Vs, s'').\n                                  \\<exists>v.\n                                     Vs = Some v \\<and>\n                                     v \\<in> R \\<and>\n                                     s'' = ?s'43 s s'))) \\<bind>\n                         (\\<lambda>x.\n                             case x of\n                             (u, None, s) \\<Rightarrow> do_finish u s\n                             | (u, Some v, s) \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> sup (\\<Down>\n                               (Id \\<times>\\<^sub>r\n                                \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                rel)\n                               (inf (get_pending_impl s')\n                                 (SPEC\n                                   (\\<lambda>(uu_, Vs, uu_).\n case Vs of None \\<Rightarrow> True | Some v \\<Rightarrow> v \\<notin> R))))\n                          (\\<Down>\n                            (Id \\<times>\\<^sub>r\n                             \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                             rel)\n                            (SPEC\n                              (\\<lambda>(u, Vs, s'').\n                                  \\<exists>v.\n                                     Vs = Some v \\<and>\n                                     v \\<in> R \\<and> s'' = s'))) \\<bind>\n                         (\\<lambda>x.\n                             case x of\n                             (u, None, s) \\<Rightarrow> do_finish u s\n                             | (u, Some v, s) \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (unfold bind_distrib_sup1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> sup (\\<Down>\n                               (Id \\<times>\\<^sub>r\n                                \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                                rel)\n                               (inf (get_pending_impl s')\n                                 (SPEC\n                                   (\\<lambda>(uu_, Vs, uu_).\n case Vs of None \\<Rightarrow> True\n | Some v \\<Rightarrow> v \\<notin> R))) \\<bind>\n                              (\\<lambda>(u, Vs, s).\n                                  case Vs of\n                                  None \\<Rightarrow> do_finish u s\n                                  | Some v \\<Rightarrow>\nif is_discovered_impl v s then RETURN s else do_discover u v s))\n                          (\\<Down>\n                            (Id \\<times>\\<^sub>r\n                             \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                             rel)\n                            (SPEC\n                              (\\<lambda>(u, Vs, s'').\n                                  \\<exists>v.\n                                     Vs = Some v \\<and>\n                                     v \\<in> R \\<and> s'' = s')) \\<bind>\n                           (\\<lambda>(u, Vs, s).\n                               case Vs of None \\<Rightarrow> do_finish u s\n                               | Some v \\<Rightarrow>\n                                   if is_discovered_impl v s then RETURN s\n                                   else do_discover u v s))\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (rule sup_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (inf (get_pending_impl s')\n                            (SPEC\n                              (\\<lambda>(uu_, Vs, uu_).\n                                  case Vs of None \\<Rightarrow> True\n                                  | Some v \\<Rightarrow>\nv \\<notin> R))) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (SPEC\n                            (\\<lambda>(u, Vs, s'').\n                                \\<exists>v.\n                                   Vs = Some v \\<and>\n                                   v \\<in> R \\<and> s'' = s')) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "(* Non-spurious node *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (inf (get_pending_impl s')\n                            (SPEC\n                              (\\<lambda>(uu_, Vs, uu_).\n                                  case Vs of None \\<Rightarrow> True\n                                  | Some v \\<Rightarrow>\nv \\<notin> R))) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (SPEC\n                            (\\<lambda>(u, Vs, s'').\n                                \\<exists>v.\n                                   Vs = Some v \\<and>\n                                   v \\<in> R \\<and> s'' = s')) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (rule le_supI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (inf (get_pending_impl s')\n                            (SPEC\n                              (\\<lambda>(uu_, Vs, uu_).\n                                  case Vs of None \\<Rightarrow> True\n                                  | Some v \\<Rightarrow>\nv \\<notin> R))) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> \\<Down> rel (a.c.gen_step s')\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (SPEC\n                            (\\<lambda>(u, Vs, s'').\n                                \\<exists>v.\n                                   Vs = Some v \\<and>\n                                   v \\<in> R \\<and> s'' = s')) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (simp add: a.c.gen_step_def del: graph_restrict_simps cong: option.case_cong if_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r Id \\<times>\\<^sub>r rel)\n                          (inf (get_pending_impl s')\n                            (SPEC\n                              (\\<lambda>(uu_, Vs, uu_).\n                                  case Vs of None \\<Rightarrow> True\n                                  | Some v \\<Rightarrow>\nv \\<notin> R))) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> \\<Down> rel\n                                (get_pending_impl s' \\<bind>\n                                 (\\<lambda>(u, Vs, s).\n                                     case Vs of\n                                     None \\<Rightarrow> a.c.do_finish u s\n                                     | Some v \\<Rightarrow>\n   if is_discovered_impl v s then RETURN s else a.c.do_discover u v s))\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (SPEC\n                            (\\<lambda>(u, Vs, s'').\n                                \\<exists>v.\n                                   Vs = Some v \\<and>\n                                   v \\<in> R \\<and> s'' = s')) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (rule bind_refine'[OF conc_fun_mono[THEN monoD]], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' x x'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s';\n        (x, x') \\<in> Id \\<times>\\<^sub>r Id \\<times>\\<^sub>r rel;\n        inres\n         (\\<Down> (Id \\<times>\\<^sub>r Id \\<times>\\<^sub>r rel)\n           (inf (get_pending_impl s')\n             (SPEC\n               (\\<lambda>(uu_, Vs, uu_).\n                   case Vs of None \\<Rightarrow> True\n                   | Some v \\<Rightarrow> v \\<notin> R))))\n         x;\n        inres (get_pending_impl s') x';\n        nofail\n         (\\<Down> (Id \\<times>\\<^sub>r Id \\<times>\\<^sub>r rel)\n           (inf (get_pending_impl s')\n             (SPEC\n               (\\<lambda>(uu_, Vs, uu_).\n                   case Vs of None \\<Rightarrow> True\n                   | Some v \\<Rightarrow> v \\<notin> R))));\n        nofail (get_pending_impl s')\\<rbrakk>\n       \\<Longrightarrow> (case x of (u, None, s) \\<Rightarrow> do_finish u s\n                          | (u, Some v, s) \\<Rightarrow>\n                              if is_discovered_impl v s then RETURN s\n                              else do_discover u v s)\n                         \\<le> \\<Down> rel\n                                (case x' of\n                                 (u, None, s) \\<Rightarrow>\n                                   a.c.do_finish u s\n                                 | (u, Some v, s) \\<Rightarrow>\n                                     if is_discovered_impl v s then RETURN s\n                                     else a.c.do_discover u v s)\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (SPEC\n                            (\\<lambda>(u, Vs, s'').\n                                \\<exists>v.\n                                   Vs = Some v \\<and>\n                                   v \\<in> R \\<and> s'' = s')) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (clarsimp simp: refine_pw_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' a aa b ba bb.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s;\n        gen_dfs_defs.gen_cond a.c.gds (V0 - R) s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s';\n        (b, ba) \\<in> rel; inres (get_pending_impl s') (a, aa, ba);\n        nofail (get_pending_impl s'); (b, bb) \\<in> rel;\n        inres (get_pending_impl s') (a, aa, bb);\n        case aa of None \\<Rightarrow> True\n        | Some v \\<Rightarrow> v \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> (case aa of None \\<Rightarrow> do_finish a b\n                          | Some v \\<Rightarrow>\n                              if is_discovered_impl v b then RETURN b\n                              else do_discover a v b)\n                         \\<le> \\<Down> rel\n                                (case aa of\n                                 None \\<Rightarrow> a.c.do_finish a ba\n                                 | Some v \\<Rightarrow>\n                                     if is_discovered_impl v ba\n                                     then RETURN ba\n                                     else a.c.do_discover a v ba)\n 2. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (SPEC\n                            (\\<lambda>(u, Vs, s'').\n                                \\<exists>v.\n                                   Vs = Some v \\<and>\n                                   v \\<in> R \\<and> s'' = s')) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (refine_rcg, refine_dref_type, simp_all add: pred_rel_simps) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (SPEC\n                            (\\<lambda>(u, Vs, s'').\n                                \\<exists>v.\n                                   Vs = Some v \\<and>\n                                   v \\<in> R \\<and> s'' = s')) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "(* Spurious node *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (SPEC\n                            (\\<lambda>(u, Vs, s'').\n                                \\<exists>v.\n                                   Vs = Some v \\<and>\n                                   v \\<in> R \\<and> s'' = s')) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> sup (\\<Down> rel (a.c.gen_step s'))\n                                (\\<Down> rel (RETURN s'))", "apply (rule le_supI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (SPEC\n                            (\\<lambda>(u, Vs, s'').\n                                \\<exists>v.\n                                   Vs = Some v \\<and>\n                                   v \\<in> R \\<and> s'' = s')) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> \\<Down> rel (RETURN s')", "apply (rule RETURN_as_SPEC_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s; a.c.gen_cond s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (Id \\<times>\\<^sub>r\n                           \\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r\n                           rel)\n                          (SPEC\n                            (\\<lambda>(u, Vs, s'').\n                                \\<exists>v.\n                                   Vs = Some v \\<and>\n                                   v \\<in> R \\<and> s'' = s')) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> SPEC (\\<lambda>c. (c, s') \\<in> rel)", "apply (simp add: conc_fun_SPEC)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s;\n        gen_dfs_defs.gen_cond a.c.gds (V0 - R) s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s'\\<rbrakk>\n       \\<Longrightarrow> SPEC\n                          (\\<lambda>y.\n                              \\<exists>a aa b.\n                                 (y, a, aa, b)\n                                 \\<in> Id \\<times>\\<^sub>r\n Id \\<times>\\<^sub>r rel \\<and>\n                                 (\\<exists>v.\n                                     aa = Some v \\<and>\n                                     v \\<in> R \\<and> b = s')) \\<bind>\n                         (\\<lambda>(u, Vs, s).\n                             case Vs of None \\<Rightarrow> do_finish u s\n                             | Some v \\<Rightarrow>\n                                 if is_discovered_impl v s then RETURN s\n                                 else do_discover u v s)\n                         \\<le> SPEC (\\<lambda>c. (c, s') \\<in> rel)", "apply (refine_rcg refine_vcg bind_refine', simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x a b aa ba xa.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s;\n        gen_dfs_defs.gen_cond a.c.gds (V0 - R) s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s';\n        (ba, s') \\<in> rel \\<and> xa \\<in> R; x = (a, Some xa, ba);\n        b = (Some xa, ba); aa = Some xa;\n        \\<not> is_discovered_impl xa ba\\<rbrakk>\n       \\<Longrightarrow> do_discover a xa ba\n                         \\<le> SPEC (\\<lambda>c. (c, s') \\<in> rel)", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' ab baa xa.\n       \\<lbrakk>(s, s') \\<in> rel; gen_cond s;\n        gen_dfs_defs.gen_cond a.c.gds (V0 - R) s';\n        \\<not> is_empty_stack_impl s; \\<not> is_empty_stack_impl s';\n        \\<not> is_discovered_impl xa baa; (baa, s') \\<in> rel;\n        xa \\<in> R\\<rbrakk>\n       \\<Longrightarrow> do_discover ab xa baa\n                         \\<le> SPEC (\\<lambda>c. (c, s') \\<in> rel)", "apply (frule (1) aux_R_node_discovered, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem re_refine_aux2: \"gen_dfs \\<le>\\<Down>(rel O \\<langle>ES\\<rangle>simple_state_rel) a.a.it_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs\n    \\<le> \\<Down> (rel O \\<langle>ES\\<rangle>simple_state_rel) a.a.it_dfs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gen_dfs\n    \\<le> \\<Down> (rel O \\<langle>ES\\<rangle>simple_state_rel) a.a.it_dfs", "note re_refine_aux"], ["proof (state)\nthis:\n  gen_dfs \\<le> \\<Down> rel a.c.gen_dfs\n\ngoal (1 subgoal):\n 1. gen_dfs\n    \\<le> \\<Down> (rel O \\<langle>ES\\<rangle>simple_state_rel) a.a.it_dfs", "also"], ["proof (state)\nthis:\n  gen_dfs \\<le> \\<Down> rel a.c.gen_dfs\n\ngoal (1 subgoal):\n 1. gen_dfs\n    \\<le> \\<Down> (rel O \\<langle>ES\\<rangle>simple_state_rel) a.a.it_dfs", "note a.gen_dfs_refine"], ["proof (state)\nthis:\n  a.c.gen_dfs\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>simple_state_rel) a.a.gen_dfs.gen_dfs\n\ngoal (1 subgoal):\n 1. gen_dfs\n    \\<le> \\<Down> (rel O \\<langle>ES\\<rangle>simple_state_rel) a.a.it_dfs", "finally"], ["proof (chain)\npicking this:\n  gen_dfs\n  \\<le> \\<Down> rel\n         (\\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n           a.a.gen_dfs.gen_dfs)", "show ?thesis"], ["proof (prove)\nusing this:\n  gen_dfs\n  \\<le> \\<Down> rel\n         (\\<Down> (\\<langle>ES\\<rangle>simple_state_rel)\n           a.a.gen_dfs.gen_dfs)\n\ngoal (1 subgoal):\n 1. gen_dfs\n    \\<le> \\<Down> (rel O \\<langle>ES\\<rangle>simple_state_rel) a.a.it_dfs", "by (simp add: conc_fun_chain del: graph_restrict_simps)"], ["proof (state)\nthis:\n  gen_dfs\n  \\<le> \\<Down> (rel O \\<langle>ES\\<rangle>simple_state_rel) a.a.it_dfs\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem re_refine: \"gen_dfs \\<le>\\<Down>(\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs", "unfolding restr_simple_state_rel_combine"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs\n    \\<le> \\<Down> (rel O \\<langle>ES\\<rangle>simple_state_rel) a.a.it_dfs", "by (rule re_refine_aux2)"], ["", "(* Link to tailrec_impl *)"], ["", "sublocale tailrec_impl G gds"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tailrec_Impl.tailrec_impl G gds", "apply unfold_locales"], ["proof (prove)\ngoal (7 subgoals):\n 1. gds_init gds \\<le>\\<^sub>n SPEC (gds_is_empty_stack gds)\n 2. \\<And>v0 s.\n       pre_new_root v0 s \\<Longrightarrow>\n       gds_new_root gds v0 s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            insert v0 (gen_discovered s) \\<subseteq> gen_discovered s')\n 3. \\<And>s.\n       pre_get_pending s \\<Longrightarrow>\n       gds_get_pending gds s \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>(uu_, uu_, s').\n            gen_discovered s \\<subseteq> gen_discovered s')\n 4. \\<And>u s0 s.\n       pre_finish u s0 s \\<Longrightarrow>\n       gds_finish gds u s \\<le>\\<^sub>n\n       SPEC (\\<lambda>s'. gen_discovered s \\<subseteq> gen_discovered s')\n 5. \\<And>u v s0 s.\n       pre_cross_edge u v s0 s \\<Longrightarrow>\n       gds_cross_edge gds u v s \\<le>\\<^sub>n\n       SPEC (\\<lambda>s'. gen_discovered s \\<subseteq> gen_discovered s')\n 6. \\<And>u v s0 s.\n       pre_back_edge u v s0 s \\<Longrightarrow>\n       gds_back_edge gds u v s \\<le>\\<^sub>n\n       SPEC (\\<lambda>s'. gen_discovered s \\<subseteq> gen_discovered s')\n 7. \\<And>u v s0 s.\n       pre_discover u v s0 s \\<Longrightarrow>\n       gds_discover gds u v s \\<le>\\<^sub>n\n       SPEC (\\<lambda>s'. gen_discovered s \\<subseteq> gen_discovered s')", "apply (simp_all add: do_action_defs impl_defs[abs_def])"], ["proof (prove)\ngoal (5 subgoals):\n 1. on_init parami \\<bind>\n    (\\<lambda>e.\n        RETURN\n         \\<lparr>ss_stack = [], on_stack = {}, visited = R,\n            \\<dots> = e\\<rparr>) \\<le>\\<^sub>n\n    SPEC (\\<lambda>s. ss_stack s = [])\n 2. \\<And>v0 s.\n       pre_new_root v0 s \\<Longrightarrow>\n       ASSERT (v0 \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_new_root parami v0\n            (s\\<lparr>ss_stack := [(v0, E `` {v0})], on_stack := {v0},\n                 visited := insert v0 (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := [(v0, E `` {v0})], on_stack := {v0},\n                     visited := insert v0 (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC\n        (\\<lambda>s'.\n            v0 \\<in> visited s' \\<and> visited s \\<subseteq> visited s')\n 3. \\<And>s.\n       pre_get_pending s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> []) \\<bind>\n       (\\<lambda>_.\n           case hd (ss_stack s) of\n           (u, Vs) \\<Rightarrow>\n             if Vs = {} then RETURN (u, None, s)\n             else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                  (\\<lambda>v.\n                      let Vs = Vs - {v};\n                          s = s\\<lparr>ss_stack :=\n   (u, Vs) # tl (ss_stack s)\\<rparr>\n                      in RETURN (u, Some v, s))) \\<le>\\<^sub>n\n       SPEC (\\<lambda>(uu_, uu_, s'). visited s \\<subseteq> visited s')\n 4. \\<And>u s0 s.\n       pre_finish u s0 s \\<Longrightarrow>\n       ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n       (\\<lambda>x.\n           on_finish parami u\n            (s\\<lparr>ss_stack := tl (ss_stack s),\n                 on_stack := on_stack s - {u}\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := tl (ss_stack s),\n                     on_stack := on_stack s - {u},\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC (\\<lambda>s'. visited s \\<subseteq> visited s')\n 5. \\<And>u v s0 s.\n       pre_discover u v s0 s \\<Longrightarrow>\n       ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n       (\\<lambda>x.\n           on_discover parami u v\n            (s\\<lparr>ss_stack := (v, E `` {v}) # ss_stack s,\n                 on_stack := insert v (on_stack s),\n                 visited := insert v (visited s)\\<rparr>) \\<bind>\n           (\\<lambda>e.\n               RETURN\n                (s\\<lparr>ss_stack := (v, E `` {v}) # ss_stack s,\n                     on_stack := insert v (on_stack s),\n                     visited := insert v (visited s),\n                     simple_state.more := e\\<rparr>))) \\<le>\\<^sub>n\n       SPEC (\\<lambda>s'. visited s \\<subseteq> visited s')", "apply (auto simp: pw_leof_iff refine_pw_simps split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tailrec_refine: \"tailrec_impl \\<le> \\<Down>(\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs", "note tailrec_impl"], ["proof (state)\nthis:\n  local.tailrec_impl \\<le> gen_dfs\n\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs", "also"], ["proof (state)\nthis:\n  local.tailrec_impl \\<le> gen_dfs\n\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs", "note re_refine"], ["proof (state)\nthis:\n  gen_dfs\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs\n\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs", "finally"], ["proof (chain)\npicking this:\n  local.tailrec_impl\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs", "show ?thesis"], ["proof (prove)\nusing this:\n  local.tailrec_impl\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs\n\ngoal (1 subgoal):\n 1. local.tailrec_impl\n    \\<le> \\<Down> (\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs", "."], ["proof (state)\nthis:\n  local.tailrec_impl\n  \\<le> \\<Down> (\\<langle>ES\\<rangle>restr_simple_state_rel R) a.a.it_dfs\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Link to rec_impl *)"], ["", "end"], ["", "end"]]}