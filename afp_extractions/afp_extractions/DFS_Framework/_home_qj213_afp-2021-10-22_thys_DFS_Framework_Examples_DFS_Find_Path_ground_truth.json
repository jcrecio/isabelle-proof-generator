{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Examples/DFS_Find_Path.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma [simp]: \"s\\<lparr> state.more := \\<lparr> ppath = foo \\<rparr> \\<rparr> = s \\<lparr> ppath := foo \\<rparr>\"", "lemmas fp0_params_simps[simp] \n  = gen_parameterization.simps[mk_record_simp, OF fp0_params_def]", "lemma [simp]: \n    \"ppath (empty_state \\<lparr>ppath = e\\<rparr>) = e\"", "lemma [simp]: \n    \"ppath (s\\<lparr>state.more := state.more s'\\<rparr>) = ppath s'\"", "lemma fp0I: assumes \"fb_graph G\" shows \"fp0 G\"", "lemma fp0_invar_eq[simp]: \n  \"DFS_invar G (fp0_params P) = fp0_invar G P\"", "lemma i_no_path_no_P_discovered:\n    \"is_invar (\\<lambda>s. ppath s = None \\<longrightarrow> dom (discovered s) \\<inter> Collect P = {})\"", "lemma i_path_to_P:\n    \"is_invar (\\<lambda>s. ppath s = Some (vs,v) \\<longrightarrow> P v)\"", "lemma i_path_invar:\n    \"is_invar (\\<lambda>s. ppath s = Some (vs,v) \\<longrightarrow> \n                   (vs \\<noteq> [] \\<longrightarrow> hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \n                 \\<and> (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v)\n                 \\<and> (distinct (vs@[v]))\n                 )\"", "lemmas no_path_no_P_discovered\n    = i_no_path_no_P_discovered[THEN make_invar_thm, rule_format]", "lemmas path_to_P\n    = i_path_to_P[THEN make_invar_thm, rule_format]", "lemmas path_invar\n    = i_path_invar[THEN make_invar_thm, rule_format]", "lemma path_invar_nonempty:\n    assumes \"ppath s = Some (vs,v)\"\n    and \"vs \\<noteq> []\"\n    shows \"hd vs \\<in> V0\" \"path E (hd vs) vs v\"", "lemma path_invar_empty:\n    assumes \"ppath s = Some (vs,v)\"\n    and \"vs = []\"\n    shows \"v \\<in> V0\" \"path E v vs v\"", "lemma fp0_correct:\n    assumes \"\\<not>cond s\"\n    shows \"case ppath s of \n      None \\<Rightarrow> \\<not>(\\<exists>v0\\<in>V0. \\<exists>v. (v0,v) \\<in> E\\<^sup>* \\<and> P v)\n    | Some (p,v) \\<Rightarrow> (\\<exists>v0\\<in>V0. path E v0 p v \\<and> P v \\<and> distinct (p@[v]))\"", "lemma fp0_correct: \"it_dfs \\<le> SPEC (\\<lambda>s. case ppath s of \n      None \\<Rightarrow> \\<not>(\\<exists>v0\\<in>V0. \\<exists>v. (v0,v) \\<in> E\\<^sup>* \\<and> P v)\n    | Some (p,v) \\<Rightarrow> (\\<exists>v0\\<in>V0. path E v0 p v \\<and> P v \\<and> distinct (p@[v])))\"", "lemma find_path0_correct:\n  shows \"find_path0 G P \\<le> find_path0_spec G P\"", "lemmas find_path0_spec_rule[refine_vcg] = \n  ASSERT_le_defI[OF find_path0_spec_def]\n  ASSERT_leof_defI[OF find_path0_spec_def]", "lemma restr_invar_triv[simp, intro!]: \"restr_invar E {} P\"", "lemma restr_invar_imp_not_reachable: \"restr_invar E R P \\<Longrightarrow> E\\<^sup>*``R \\<inter> Collect P = {}\"", "lemmas find_path0_restr_spec_rule[refine_vcg] = \n  ASSERT_le_defI[OF find_path0_restr_spec_def]\n  ASSERT_leof_defI[OF find_path0_restr_spec_def]", "lemma find_path0_restr_correct:\n  shows \"find_path0_restr G P R \\<le> find_path0_restr_spec G P R\"", "lemmas find_path1_restr_spec_rule[refine_vcg] = \n  ASSERT_le_defI[OF find_path1_restr_spec_def]\n  ASSERT_leof_defI[OF find_path1_restr_spec_def]", "lemma find_path1_restr_correct:\n  shows \"find_path1_restr G P R \\<le> find_path1_restr_spec G P R\"", "lemmas find_path1_spec_rule[refine_vcg] = \n  ASSERT_le_defI[OF find_path1_spec_def]\n  ASSERT_leof_defI[OF find_path1_spec_def]", "lemma find_path1_correct: \n  shows \"find_path1 G P \\<le> find_path1_spec G P\"", "lemma fp0_rel_ppath_cong[simp]: \n  \"(s,s')\\<in>fp0_rel R \\<Longrightarrow> fp0_state_impl.ppath s = fp0_state.ppath s'\"", "lemma fp0_ss_rel_ppath_cong[simp]: \n  \"(s,s')\\<in>\\<langle>fp0_erel\\<rangle>simple_state_rel \\<Longrightarrow> fp0_state_impl.ppath s = fp0_state.ppath s'\"", "lemma fp0i_cong[cong]: \"simple_state.more s = simple_state.more s' \n  \\<Longrightarrow> fp0_state_impl.ppath s = fp0_state_impl.ppath s'\"", "lemma fp0_erelI: \"p=p' \n  \\<Longrightarrow> (\\<lparr> fp0_state_impl.ppath = p \\<rparr>, \\<lparr> fp0_state.ppath = p'\\<rparr>)\\<in>fp0_erel\"", "lemmas fp0_params_impl_simp[simp, DFS_code_unfold] \n  = gen_parameterization.simps[mk_record_simp, OF fp0_params_impl_def]", "lemma find_path0_restr_impl[refine]:\n  shows \"find_path0_restr_impl G P R \n     \\<le> \\<Down>(\\<langle>Id,Id\\<times>\\<^sub>rId\\<rangle>sum_rel) \n   (find_path0_restr G P R)\"", "lemma find_path0_impl[refine]: \"find_path0_impl G P \n  \\<le> \\<Down> (\\<langle>Id\\<times>\\<^sub>rId\\<rangle>option_rel) (find_path0 G P)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of fp0_state_erel i_fp0_state_ext]", "lemma [autoref_rules]:\n  fixes ns_rel vis_rel erel\n  defines \"R \\<equiv> \\<langle>ns_rel,vis_rel,\\<langle>erel\\<rangle>fp0_state_erel\\<rangle>ssnos_impl_rel\"\n  shows \n    \"(fp0_state_impl'_ext, fp0_state_impl_ext) \n      \\<in> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>option_rel \\<rightarrow> erel \\<rightarrow> \\<langle>erel\\<rangle>fp0_state_erel\"\n    \"(ppath_impl, fp0_state_impl.ppath) \\<in> R \\<rightarrow> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>option_rel\"", "lemma find_path0_autoref_aux:\n  assumes Vid: \"Rv = (Id :: 'a :: hashable rel)\"\n  shows \"(\\<lambda>G P. nres_of (find_path0_code G P), find_path0_spec) \n    \\<in> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> (Rv \\<rightarrow> bool_rel) \n      \\<rightarrow> \\<langle>\\<langle>\\<langle>Rv\\<rangle>list_rel \\<times>\\<^sub>r Rv\\<rangle>option_rel\\<rangle>nres_rel\"", "lemmas find_path0_autoref[autoref_rules] = find_path0_autoref_aux[OF PREFER_id_D]", "lemma find_path0_restr_autoref_aux:\n  assumes 1: \"(op_vis_insert, insert)\\<in>Rv \\<rightarrow> \\<langle>Rv\\<rangle>vis_rel \\<rightarrow> \\<langle>Rv\\<rangle>vis_rel\"\n  assumes 2: \"(op_vis_memb, (\\<in>))\\<in>Rv \\<rightarrow> \\<langle>Rv\\<rangle>vis_rel \\<rightarrow> bool_rel\"\n  assumes Vid: \"Rv = Id\"\n  shows \"(\\<lambda> G P R. nres_of (find_path0_restr_code op_vis_insert op_vis_memb G P R), \n    find_path0_restr_spec) \n    \\<in> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> (Rv \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>Rv\\<rangle>vis_rel \\<rightarrow>\n    \\<langle>\\<langle>\\<langle>Rv\\<rangle>vis_rel, \\<langle>Rv\\<rangle>list_rel \\<times>\\<^sub>r Rv\\<rangle>sum_rel\\<rangle>nres_rel\"", "lemmas find_path0_restr_autoref[autoref_rules] = find_path0_restr_autoref_aux[OF GEN_OP_D GEN_OP_D PREFER_id_D]", "lemma find_path1_restr_autoref_aux:\n  assumes G: \"(op_vis_insert, insert)\\<in>V \\<rightarrow> \\<langle>V\\<rangle>vis_rel \\<rightarrow> \\<langle>V\\<rangle>vis_rel\"\n             \"(op_vis_memb, (\\<in>))\\<in>V \\<rightarrow> \\<langle>V\\<rangle>vis_rel \\<rightarrow> bool_rel\"\n  assumes Vid[simp]: \"V=Id\"\n  shows \"(\\<lambda> G P R. nres_of (find_path1_restr_code op_vis_insert op_vis_memb G P R),find_path1_restr_spec)\n  \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> (V \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>V\\<rangle>vis_rel \\<rightarrow>\n    \\<langle>\\<langle>\\<langle>V\\<rangle>vis_rel, \\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r V\\<rangle>sum_rel\\<rangle>nres_rel\"", "lemmas find_path1_restr_autoref[autoref_rules] = find_path1_restr_autoref_aux[OF GEN_OP_D GEN_OP_D PREFER_id_D]", "lemma find_path1_code_autoref_aux:\n  assumes Vid: \"V = (Id :: 'a :: hashable rel)\"\n  shows \"(\\<lambda> G P. nres_of (find_path1_code G P), find_path1_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> (V \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r V\\<rangle>option_rel\\<rangle>nres_rel\"", "lemmas find_path1_autoref[autoref_rules] = find_path1_code_autoref_aux[OF PREFER_id_D]"], "translations": [["", "lemma [simp]: \"s\\<lparr> state.more := \\<lparr> ppath = foo \\<rparr> \\<rparr> = s \\<lparr> ppath := foo \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<lparr>state.more := \\<lparr>ppath = foo\\<rparr>\\<rparr> = s\n    \\<lparr>ppath := foo\\<rparr>", "by (cases s) simp"], ["", "abbreviation \"no_path \\<equiv> \\<lparr> ppath = None \\<rparr>\""], ["", "abbreviation \"a_path p v \\<equiv> \\<lparr> ppath = Some (p,v) \\<rparr>\""], ["", "definition fp0_params :: \"('v \\<Rightarrow> bool) \\<Rightarrow> 'v fp0_param\"\n  where \"fp0_params P \\<equiv> \\<lparr>\n  on_init = RETURN no_path,\n  on_new_root = \\<lambda>v0 s. if P v0 then RETURN (a_path [] v0) else RETURN no_path,\n  on_discover = \\<lambda>u v s. if P v \n                   then \\<comment> \\<open>\\<open>v\\<close> is already on the stack, so we need to pop it again\\<close>\n                      RETURN (a_path (rev (tl (stack s))) v) \n                   else RETURN no_path,\n  on_finish = \\<lambda>u s. RETURN (state.more s),\n  on_back_edge = \\<lambda>u v s. RETURN (state.more s),\n  on_cross_edge = \\<lambda>u v s. RETURN (state.more s),\n  is_break = \\<lambda>s. ppath s \\<noteq> None \\<rparr>\""], ["", "lemmas fp0_params_simps[simp] \n  = gen_parameterization.simps[mk_record_simp, OF fp0_params_def]"], ["", "interpretation fp0: param_DFS_defs where param = \"fp0_params P\"\n  for G P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "locale fp0 = param_DFS G \"fp0_params P\"\n  for G and P :: \"'v \\<Rightarrow> bool\"\nbegin"], ["", "lemma [simp]: \n    \"ppath (empty_state \\<lparr>ppath = e\\<rparr>) = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ppath (empty_state \\<lparr>ppath = e\\<rparr>) = e", "by (simp add: empty_state_def)"], ["", "lemma [simp]: \n    \"ppath (s\\<lparr>state.more := state.more s'\\<rparr>) = ppath s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ppath (s\\<lparr>state.more := state.more s'\\<rparr>) = ppath s'", "by (cases s, cases s') auto"], ["", "sublocale DFS where param = \"fp0_params P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS G (fp0_params P)", "by unfold_locales simp_all"], ["", "end"], ["", "lemma fp0I: assumes \"fb_graph G\" shows \"fp0 G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fp0 G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fp0 G", "interpret fb_graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. fp0 G", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fp0 G", "by unfold_locales"], ["proof (state)\nthis:\n  fp0 G\n\ngoal:\nNo subgoals!", "qed"], ["", "locale fp0_invar = fp0 + \n  DFS_invar where param = \"fp0_params P\""], ["", "lemma fp0_invar_eq[simp]: \n  \"DFS_invar G (fp0_params P) = fp0_invar G P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G (fp0_params P) = fp0_invar G P", "proof (intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. DFS_invar G (fp0_params P) x \\<Longrightarrow> fp0_invar G P x\n 2. \\<And>x. fp0_invar G P x \\<Longrightarrow> DFS_invar G (fp0_params P) x", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. DFS_invar G (fp0_params P) x \\<Longrightarrow> fp0_invar G P x\n 2. \\<And>x. fp0_invar G P x \\<Longrightarrow> DFS_invar G (fp0_params P) x", "assume \"DFS_invar G (fp0_params P) s\""], ["proof (state)\nthis:\n  DFS_invar G (fp0_params P) s\n\ngoal (2 subgoals):\n 1. \\<And>x. DFS_invar G (fp0_params P) x \\<Longrightarrow> fp0_invar G P x\n 2. \\<And>x. fp0_invar G P x \\<Longrightarrow> DFS_invar G (fp0_params P) x", "interpret DFS_invar G \"fp0_params P\" s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G (fp0_params P) s", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. DFS_invar G (fp0_params P) x \\<Longrightarrow> fp0_invar G P x\n 2. \\<And>x. fp0_invar G P x \\<Longrightarrow> DFS_invar G (fp0_params P) x", "show \"fp0_invar G P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fp0_invar G P s", "by unfold_locales"], ["proof (state)\nthis:\n  fp0_invar G P s\n\ngoal (1 subgoal):\n 1. \\<And>x. fp0_invar G P x \\<Longrightarrow> DFS_invar G (fp0_params P) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fp0_invar G P x \\<Longrightarrow> DFS_invar G (fp0_params P) x", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fp0_invar G P x \\<Longrightarrow> DFS_invar G (fp0_params P) x", "assume \"fp0_invar G P s\""], ["proof (state)\nthis:\n  fp0_invar G P s\n\ngoal (1 subgoal):\n 1. \\<And>x. fp0_invar G P x \\<Longrightarrow> DFS_invar G (fp0_params P) x", "interpret fp0_invar G P s"], ["proof (prove)\ngoal (1 subgoal):\n 1. fp0_invar G P s", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fp0_invar G P x \\<Longrightarrow> DFS_invar G (fp0_params P) x", "show \"DFS_invar G (fp0_params P) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G (fp0_params P) s", "by unfold_locales"], ["proof (state)\nthis:\n  DFS_invar G (fp0_params P) s\n\ngoal:\nNo subgoals!", "qed"], ["", "context fp0 begin"], ["", "lemma i_no_path_no_P_discovered:\n    \"is_invar (\\<lambda>s. ppath s = None \\<longrightarrow> dom (discovered s) \\<inter> Collect P = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         ppath s = None \\<longrightarrow>\n         dom (discovered s) \\<inter> Collect P = {})", "by (rule establish_invarI) simp_all"], ["", "lemma i_path_to_P:\n    \"is_invar (\\<lambda>s. ppath s = Some (vs,v) \\<longrightarrow> P v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar (\\<lambda>s. ppath s = Some (vs, v) \\<longrightarrow> P v)", "by (rule establish_invarI) auto"], ["", "lemma i_path_invar:\n    \"is_invar (\\<lambda>s. ppath s = Some (vs,v) \\<longrightarrow> \n                   (vs \\<noteq> [] \\<longrightarrow> hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \n                 \\<and> (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v)\n                 \\<and> (distinct (vs@[v]))\n                 )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         ppath s = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))", "proof (induct rule: establish_invarI)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init (fp0_params P) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         ppath (empty_state x) = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params P) v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params P) u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 4. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<in> dom (finished s);\n        s' =\n        cross_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 5. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<notin> dom (finished s);\n        s' =\n        back_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 6. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<notin> dom (discovered s);\n        s' =\n        discover u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))", "case (discover s s' u v)"], ["proof (state)\nthis:\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (6 subgoals):\n 1. on_init (fp0_params P) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         ppath (empty_state x) = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params P) v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params P) u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 4. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<in> dom (finished s);\n        s' =\n        cross_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 5. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<notin> dom (finished s);\n        s' =\n        back_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 6. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<notin> dom (discovered s);\n        s' =\n        discover u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))", "then"], ["proof (chain)\npicking this:\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)", "interpret fp0_invar where s=s"], ["proof (prove)\nusing this:\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. fp0_invar G P s", "by simp"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init (fp0_params P) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         ppath (empty_state x) = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params P) v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params P) u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 4. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<in> dom (finished s);\n        s' =\n        cross_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 5. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<notin> dom (finished s);\n        s' =\n        back_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 6. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<notin> dom (discovered s);\n        s' =\n        discover u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))", "from discover"], ["proof (chain)\npicking this:\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)", "have ne: \"stack s \\<noteq> []\""], ["proof (prove)\nusing this:\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  stack s \\<noteq> []\n\ngoal (6 subgoals):\n 1. on_init (fp0_params P) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         ppath (empty_state x) = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params P) v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params P) u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 4. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<in> dom (finished s);\n        s' =\n        cross_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 5. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<notin> dom (finished s);\n        s' =\n        back_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 6. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<notin> dom (discovered s);\n        s' =\n        discover u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))", "from discover"], ["proof (chain)\npicking this:\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)", "have vnis: \"v\\<notin>set (stack s)\""], ["proof (prove)\nusing this:\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (stack s)", "using stack_discovered"], ["proof (prove)\nusing this:\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (stack s)", "by auto"], ["proof (state)\nthis:\n  v \\<notin> set (stack s)\n\ngoal (6 subgoals):\n 1. on_init (fp0_params P) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         ppath (empty_state x) = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params P) v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params P) u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 4. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<in> dom (finished s);\n        s' =\n        cross_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 5. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<notin> dom (finished s);\n        s' =\n        back_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 6. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<notin> dom (discovered s);\n        s' =\n        discover u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))", "from pendingD discover"], ["proof (chain)\npicking this:\n  (?u, ?v) \\<in> pending s \\<Longrightarrow>\n  (?u, ?v) \\<in> E \\<and> ?u \\<in> dom (discovered s)\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)", "have \"v \\<in> succ (hd (stack s))\""], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> pending s \\<Longrightarrow>\n  (?u, ?v) \\<in> E \\<and> ?u \\<in> dom (discovered s)\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. v \\<in> E `` {hd (stack s)}", "by simp"], ["proof (state)\nthis:\n  v \\<in> E `` {hd (stack s)}\n\ngoal (6 subgoals):\n 1. on_init (fp0_params P) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         ppath (empty_state x) = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params P) v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params P) u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 4. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<in> dom (finished s);\n        s' =\n        cross_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 5. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<notin> dom (finished s);\n        s' =\n        back_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 6. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<notin> dom (discovered s);\n        s' =\n        discover u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))", "with hd_succ_stack_is_path[OF ne]"], ["proof (chain)\npicking this:\n  ?v \\<in> E `` {hd (stack s)} \\<Longrightarrow>\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) ?v\n  v \\<in> E `` {hd (stack s)}", "have \"\\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\""], ["proof (prove)\nusing this:\n  ?v \\<in> E `` {hd (stack s)} \\<Longrightarrow>\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) ?v\n  v \\<in> E `` {hd (stack s)}\n\ngoal (1 subgoal):\n 1. \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v", "."], ["proof (state)\nthis:\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\n\ngoal (6 subgoals):\n 1. on_init (fp0_params P) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         ppath (empty_state x) = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params P) v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params P) u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 4. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<in> dom (finished s);\n        s' =\n        cross_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 5. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<notin> dom (finished s);\n        s' =\n        back_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 6. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<notin> dom (discovered s);\n        s' =\n        discover u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))", "moreover"], ["proof (state)\nthis:\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\n\ngoal (6 subgoals):\n 1. on_init (fp0_params P) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         ppath (empty_state x) = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params P) v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params P) u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 4. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<in> dom (finished s);\n        s' =\n        cross_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 5. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<notin> dom (finished s);\n        s' =\n        back_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 6. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<notin> dom (discovered s);\n        s' =\n        discover u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))", "from last_stack_in_V0 ne"], ["proof (chain)\npicking this:\n  stack s \\<noteq> [] \\<Longrightarrow> last (stack s) \\<in> V0\n  stack s \\<noteq> []", "have \"last (stack s) \\<in> V0\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> [] \\<Longrightarrow> last (stack s) \\<in> V0\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (stack s) \\<in> V0", "by simp"], ["proof (state)\nthis:\n  last (stack s) \\<in> V0\n\ngoal (6 subgoals):\n 1. on_init (fp0_params P) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         ppath (empty_state x) = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params P) v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params P) u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 4. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<in> dom (finished s);\n        s' =\n        cross_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 5. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<notin> dom (finished s);\n        s' =\n        back_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 6. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<notin> dom (discovered s);\n        s' =\n        discover u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\n  last (stack s) \\<in> V0", "have \"path E (hd (rev (stack s)))  (rev (stack s)) v\" \"hd (rev (stack s)) \\<in> V0\""], ["proof (prove)\nusing this:\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\n  last (stack s) \\<in> V0\n\ngoal (1 subgoal):\n 1. path E (hd (rev (stack s))) (rev (stack s)) v &&&\n    hd (rev (stack s)) \\<in> V0", "using hd_rev[OF ne] path_hd[where p=\"rev (stack s)\"] ne"], ["proof (prove)\nusing this:\n  \\<exists>v0\\<in>V0. path E v0 (rev (stack s)) v\n  last (stack s) \\<in> V0\n  hd (rev (stack s)) = last (stack s)\n  \\<lbrakk>rev (stack s) \\<noteq> []; path ?E ?v (rev (stack s)) ?w\\<rbrakk>\n  \\<Longrightarrow> hd (rev (stack s)) = ?v\n  stack s \\<noteq> []\n\ngoal (1 subgoal):\n 1. path E (hd (rev (stack s))) (rev (stack s)) v &&&\n    hd (rev (stack s)) \\<in> V0", "by auto"], ["proof (state)\nthis:\n  path E (hd (rev (stack s))) (rev (stack s)) v\n  hd (rev (stack s)) \\<in> V0\n\ngoal (6 subgoals):\n 1. on_init (fp0_params P) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         ppath (empty_state x) = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params P) v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params P) u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 4. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<in> dom (finished s);\n        s' =\n        cross_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 5. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<notin> dom (finished s);\n        s' =\n        back_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 6. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<notin> dom (discovered s);\n        s' =\n        discover u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))", "with ne discover vnis"], ["proof (chain)\npicking this:\n  stack s \\<noteq> []\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  v \\<notin> set (stack s)\n  path E (hd (rev (stack s))) (rev (stack s)) v\n  hd (rev (stack s)) \\<in> V0", "show ?case"], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n  DFS_invar G (fp0_params P) s\n  ppath s = Some (vs, v) \\<longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  cond s\n  \\<not> is_break (fp0_params P) s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  v \\<notin> set (stack s)\n  path E (hd (rev (stack s))) (rev (stack s)) v\n  hd (rev (stack s)) \\<in> V0\n\ngoal (1 subgoal):\n 1. on_discover (fp0_params P) u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G (fp0_params P)\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         ppath (s'\\<lparr>state.more := x\\<rparr>) =\n         Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))", "by (auto simp: stack_distinct)"], ["proof (state)\nthis:\n  on_discover (fp0_params P) u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G (fp0_params P)\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       ppath (s'\\<lparr>state.more := x\\<rparr>) =\n       Some (vs, v) \\<longrightarrow>\n       (vs \\<noteq> [] \\<longrightarrow>\n        hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n       (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n       distinct (vs @ [v]))\n\ngoal (5 subgoals):\n 1. on_init (fp0_params P) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         ppath (empty_state x) = Some (vs, v) \\<longrightarrow>\n         (vs \\<noteq> [] \\<longrightarrow>\n          hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n         (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n         distinct (vs @ [v]))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params P) v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params P) u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 4. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<in> dom (finished s);\n        s' =\n        cross_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))\n 5. \\<And>s s' u va.\n       \\<lbrakk>DFS_invar G (fp0_params P) s;\n        ppath s = Some (vs, v) \\<longrightarrow>\n        (vs \\<noteq> [] \\<longrightarrow>\n         hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n        (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n        distinct (vs @ [v]);\n        cond s; \\<not> is_break (fp0_params P) s; stack s \\<noteq> [];\n        (u, va) \\<in> pending s; u = hd (stack s);\n        va \\<in> dom (discovered s); va \\<notin> dom (finished s);\n        s' =\n        back_edge u va\n         (s\\<lparr>pending := pending s - {(u, va)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params P) u va s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G (fp0_params P)\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              ppath (s'\\<lparr>state.more := x\\<rparr>) =\n                              Some (vs, v) \\<longrightarrow>\n                              (vs \\<noteq> [] \\<longrightarrow>\n                               hd vs \\<in> V0 \\<and>\n                               path E (hd vs) vs v) \\<and>\n                              (vs = [] \\<longrightarrow>\n                               v \\<in> V0 \\<and> path E v vs v) \\<and>\n                              distinct (vs @ [v]))", "qed auto"], ["", "end"], ["", "context fp0_invar\nbegin"], ["", "lemmas no_path_no_P_discovered\n    = i_no_path_no_P_discovered[THEN make_invar_thm, rule_format]"], ["", "lemmas path_to_P\n    = i_path_to_P[THEN make_invar_thm, rule_format]"], ["", "lemmas path_invar\n    = i_path_invar[THEN make_invar_thm, rule_format]"], ["", "lemma path_invar_nonempty:\n    assumes \"ppath s = Some (vs,v)\"\n    and \"vs \\<noteq> []\"\n    shows \"hd vs \\<in> V0\" \"path E (hd vs) vs v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd vs \\<in> V0 &&& path E (hd vs) vs v", "using assms path_invar"], ["proof (prove)\nusing this:\n  ppath s = Some (vs, v)\n  vs \\<noteq> []\n  ppath s = Some (?vs, ?v) \\<Longrightarrow>\n  (?vs \\<noteq> [] \\<longrightarrow>\n   hd ?vs \\<in> V0 \\<and> path E (hd ?vs) ?vs ?v) \\<and>\n  (?vs = [] \\<longrightarrow> ?v \\<in> V0 \\<and> path E ?v ?vs ?v) \\<and>\n  distinct (?vs @ [?v])\n\ngoal (1 subgoal):\n 1. hd vs \\<in> V0 &&& path E (hd vs) vs v", "by auto"], ["", "lemma path_invar_empty:\n    assumes \"ppath s = Some (vs,v)\"\n    and \"vs = []\"\n    shows \"v \\<in> V0\" \"path E v vs v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V0 &&& path E v vs v", "using assms path_invar"], ["proof (prove)\nusing this:\n  ppath s = Some (vs, v)\n  vs = []\n  ppath s = Some (?vs, ?v) \\<Longrightarrow>\n  (?vs \\<noteq> [] \\<longrightarrow>\n   hd ?vs \\<in> V0 \\<and> path E (hd ?vs) ?vs ?v) \\<and>\n  (?vs = [] \\<longrightarrow> ?v \\<in> V0 \\<and> path E ?v ?vs ?v) \\<and>\n  distinct (?vs @ [?v])\n\ngoal (1 subgoal):\n 1. v \\<in> V0 &&& path E v vs v", "by auto"], ["", "lemma fp0_correct:\n    assumes \"\\<not>cond s\"\n    shows \"case ppath s of \n      None \\<Rightarrow> \\<not>(\\<exists>v0\\<in>V0. \\<exists>v. (v0,v) \\<in> E\\<^sup>* \\<and> P v)\n    | Some (p,v) \\<Rightarrow> (\\<exists>v0\\<in>V0. path E v0 p v \\<and> P v \\<and> distinct (p@[v]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case ppath s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n    | Some (p, v) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           path E v0 p v \\<and> P v \\<and> distinct (p @ [v])", "proof (cases \"ppath s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ppath s = None \\<Longrightarrow>\n    case ppath s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n    | Some (p, v) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           path E v0 p v \\<and> P v \\<and> distinct (p @ [v])\n 2. \\<And>a.\n       ppath s = Some a \\<Longrightarrow>\n       case ppath s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n       | Some (p, v) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              path E v0 p v \\<and> P v \\<and> distinct (p @ [v])", "case None"], ["proof (state)\nthis:\n  ppath s = None\n\ngoal (2 subgoals):\n 1. ppath s = None \\<Longrightarrow>\n    case ppath s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n    | Some (p, v) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           path E v0 p v \\<and> P v \\<and> distinct (p @ [v])\n 2. \\<And>a.\n       ppath s = Some a \\<Longrightarrow>\n       case ppath s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n       | Some (p, v) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              path E v0 p v \\<and> P v \\<and> distinct (p @ [v])", "with assms nc_discovered_eq_reachable no_path_no_P_discovered"], ["proof (chain)\npicking this:\n  \\<not> cond s\n  \\<lbrakk>\\<not> cond s; \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> dom (discovered s) = reachable\n  ppath s = None \\<Longrightarrow>\n  dom (discovered s) \\<inter> Collect P = {}\n  ppath s = None", "have\n      \"reachable \\<inter> Collect P = {}\""], ["proof (prove)\nusing this:\n  \\<not> cond s\n  \\<lbrakk>\\<not> cond s; \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> dom (discovered s) = reachable\n  ppath s = None \\<Longrightarrow>\n  dom (discovered s) \\<inter> Collect P = {}\n  ppath s = None\n\ngoal (1 subgoal):\n 1. reachable \\<inter> Collect P = {}", "by auto"], ["proof (state)\nthis:\n  reachable \\<inter> Collect P = {}\n\ngoal (2 subgoals):\n 1. ppath s = None \\<Longrightarrow>\n    case ppath s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n    | Some (p, v) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           path E v0 p v \\<and> P v \\<and> distinct (p @ [v])\n 2. \\<And>a.\n       ppath s = Some a \\<Longrightarrow>\n       case ppath s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n       | Some (p, v) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              path E v0 p v \\<and> P v \\<and> distinct (p @ [v])", "thus ?thesis"], ["proof (prove)\nusing this:\n  reachable \\<inter> Collect P = {}\n\ngoal (1 subgoal):\n 1. case ppath s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n    | Some (p, v) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           path E v0 p v \\<and> P v \\<and> distinct (p @ [v])", "by (auto simp add: None)"], ["proof (state)\nthis:\n  case ppath s of\n  None \\<Rightarrow>\n    \\<not> (\\<exists>v0\\<in>V0.\n               \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n  | Some (p, v) \\<Rightarrow>\n      \\<exists>v0\\<in>V0. path E v0 p v \\<and> P v \\<and> distinct (p @ [v])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ppath s = Some a \\<Longrightarrow>\n       case ppath s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n       | Some (p, v) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              path E v0 p v \\<and> P v \\<and> distinct (p @ [v])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ppath s = Some a \\<Longrightarrow>\n       case ppath s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n       | Some (p, v) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              path E v0 p v \\<and> P v \\<and> distinct (p @ [v])", "case (Some vvs)"], ["proof (state)\nthis:\n  ppath s = Some vvs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ppath s = Some a \\<Longrightarrow>\n       case ppath s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n       | Some (p, v) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              path E v0 p v \\<and> P v \\<and> distinct (p @ [v])", "then"], ["proof (chain)\npicking this:\n  ppath s = Some vvs", "obtain v vs where [simp]: \"vvs = (vs,v)\""], ["proof (prove)\nusing this:\n  ppath s = Some vvs\n\ngoal (1 subgoal):\n 1. (\\<And>vs v. vvs = (vs, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases vvs) auto"], ["proof (state)\nthis:\n  vvs = (vs, v)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ppath s = Some a \\<Longrightarrow>\n       case ppath s of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n       | Some (p, v) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              path E v0 p v \\<and> P v \\<and> distinct (p @ [v])", "from Some path_invar[of vs v] path_to_P[of _ v]"], ["proof (chain)\npicking this:\n  ppath s = Some vvs\n  ppath s = Some (vs, v) \\<Longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  ppath s = Some (?vs, v) \\<Longrightarrow> P v", "show ?thesis"], ["proof (prove)\nusing this:\n  ppath s = Some vvs\n  ppath s = Some (vs, v) \\<Longrightarrow>\n  (vs \\<noteq> [] \\<longrightarrow>\n   hd vs \\<in> V0 \\<and> path E (hd vs) vs v) \\<and>\n  (vs = [] \\<longrightarrow> v \\<in> V0 \\<and> path E v vs v) \\<and>\n  distinct (vs @ [v])\n  ppath s = Some (?vs, v) \\<Longrightarrow> P v\n\ngoal (1 subgoal):\n 1. case ppath s of\n    None \\<Rightarrow>\n      \\<not> (\\<exists>v0\\<in>V0.\n                 \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n    | Some (p, v) \\<Rightarrow>\n        \\<exists>v0\\<in>V0.\n           path E v0 p v \\<and> P v \\<and> distinct (p @ [v])", "by auto"], ["proof (state)\nthis:\n  case ppath s of\n  None \\<Rightarrow>\n    \\<not> (\\<exists>v0\\<in>V0.\n               \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n  | Some (p, v) \\<Rightarrow>\n      \\<exists>v0\\<in>V0. path E v0 p v \\<and> P v \\<and> distinct (p @ [v])\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context fp0 begin"], ["", "lemma fp0_correct: \"it_dfs \\<le> SPEC (\\<lambda>s. case ppath s of \n      None \\<Rightarrow> \\<not>(\\<exists>v0\\<in>V0. \\<exists>v. (v0,v) \\<in> E\\<^sup>* \\<and> P v)\n    | Some (p,v) \\<Rightarrow> (\\<exists>v0\\<in>V0. path E v0 p v \\<and> P v \\<and> distinct (p@[v])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfs\n    \\<le> SPEC\n           (\\<lambda>s.\n               case ppath s of\n               None \\<Rightarrow>\n                 \\<not> (\\<exists>v0\\<in>V0.\n                            \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n               | Some (p, v) \\<Rightarrow>\n                   \\<exists>v0\\<in>V0.\n                      path E v0 p v \\<and> P v \\<and> distinct (p @ [v]))", "apply (rule weaken_SPEC[OF it_dfs_correct])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       DFS_invar G (fp0_params P) x \\<and> \\<not> cond x \\<Longrightarrow>\n       case ppath x of\n       None \\<Rightarrow>\n         \\<not> (\\<exists>v0\\<in>V0.\n                    \\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n       | Some (p, v) \\<Rightarrow>\n           \\<exists>v0\\<in>V0.\n              path E v0 p v \\<and> P v \\<and> distinct (p @ [v])", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fp0_invar G P x; \\<not> cond x\\<rbrakk>\n       \\<Longrightarrow> case ppath x of\n                         None \\<Rightarrow>\n                           \\<not> (\\<exists>v0\\<in>V0.\n\\<exists>v. (v0, v) \\<in> E\\<^sup>* \\<and> P v)\n                         | Some (p, v) \\<Rightarrow>\n                             \\<exists>v0\\<in>V0.\n                                path E v0 p v \\<and>\n                                P v \\<and> distinct (p @ [v])", "apply (simp add: fp0_invar.fp0_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \\<open>Basic Interface\\<close>"], ["", "text \\<open>Use this interface, rather than the internal stuff above! \\<close>"], ["", "(* Making it a well-defined interface. This interface should be used, not\n  the internal stuff. If more information about the result is needed, this \n  interface should be extended! *)"], ["", "type_synonym 'v fp_result = \"('v list \\<times> 'v) option\""], ["", "definition \"find_path0_pred G P \\<equiv> \\<lambda>r. case r of \n    None \\<Rightarrow> (g_E G)\\<^sup>* `` g_V0 G \\<inter> Collect P = {}\n  | Some (vs,v) \\<Rightarrow> P v \\<and> distinct (vs@[v]) \\<and> (\\<exists> v0 \\<in> g_V0 G. path (g_E G) v0 vs v)\""], ["", "definition find_path0_spec\n  :: \"('v, _) graph_rec_scheme \\<Rightarrow> ('v \\<Rightarrow> bool) \\<Rightarrow> 'v fp_result nres\"\n  \\<comment> \\<open>Searches a path from the root nodes to some target node that satisfies a \n      given predicate. If such a path is found, the path and the target node\n      are returned\\<close>\nwhere\n  \"find_path0_spec G P \\<equiv> do {\n    ASSERT (fb_graph G);\n    SPEC (find_path0_pred G P)\n  }\""], ["", "definition find_path0 \n  :: \"('v, 'more) graph_rec_scheme \\<Rightarrow> ('v \\<Rightarrow> bool) \\<Rightarrow> 'v fp_result nres\"\n  where \"find_path0 G P \\<equiv> do {\n  ASSERT (fp0 G);\n  s \\<leftarrow> fp0.it_dfs TYPE('more) G P;\n  RETURN (ppath s)\n}\""], ["", "lemma find_path0_correct:\n  shows \"find_path0 G P \\<le> find_path0_spec G P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path0 G P \\<le> find_path0_spec G P", "unfolding find_path0_def find_path0_spec_def find_path0_pred_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fp0 G) \\<bind>\n    (\\<lambda>_.\n        param_DFS_defs.it_dfs G (fp0_params P) \\<bind>\n        (\\<lambda>s. RETURN (ppath s)))\n    \\<le> ASSERT (fb_graph G) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>r.\n                   case r of\n                   None \\<Rightarrow>\n                     (g_E G)\\<^sup>* `` g_V0 G \\<inter> Collect P = {}\n                   | Some (vs, v) \\<Rightarrow>\n                       P v \\<and>\n                       distinct (vs @ [v]) \\<and>\n                       (\\<exists>v0\\<in>g_V0 G. path (g_E G) v0 vs v)))", "apply (refine_vcg le_ASSERTI order_trans[OF fp0.fp0_correct])"], ["proof (prove)\ngoal (2 subgoals):\n 1. fb_graph G \\<Longrightarrow> fp0 G\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; fp0 G;\n        case ppath x of\n        None \\<Rightarrow>\n          \\<not> (\\<exists>v0\\<in>g_V0 G.\n                     \\<exists>v. (v0, v) \\<in> (g_E G)\\<^sup>* \\<and> P v)\n        | Some (p, v) \\<Rightarrow>\n            \\<exists>v0\\<in>g_V0 G.\n               path (g_E G) v0 p v \\<and>\n               P v \\<and> distinct (p @ [v])\\<rbrakk>\n       \\<Longrightarrow> case ppath x of\n                         None \\<Rightarrow>\n                           (g_E G)\\<^sup>* `` g_V0 G \\<inter> Collect P = {}\n                         | Some (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             distinct (vs @ [v]) \\<and>\n                             (\\<exists>v0\\<in>g_V0 G. path (g_E G) v0 vs v)", "apply (erule fp0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; fp0 G;\n        case ppath x of\n        None \\<Rightarrow>\n          \\<not> (\\<exists>v0\\<in>g_V0 G.\n                     \\<exists>v. (v0, v) \\<in> (g_E G)\\<^sup>* \\<and> P v)\n        | Some (p, v) \\<Rightarrow>\n            \\<exists>v0\\<in>g_V0 G.\n               path (g_E G) v0 p v \\<and>\n               P v \\<and> distinct (p @ [v])\\<rbrakk>\n       \\<Longrightarrow> case ppath x of\n                         None \\<Rightarrow>\n                           (g_E G)\\<^sup>* `` g_V0 G \\<inter> Collect P = {}\n                         | Some (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             distinct (vs @ [v]) \\<and>\n                             (\\<exists>v0\\<in>g_V0 G. path (g_E G) v0 vs v)", "apply (auto split: option.split) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas find_path0_spec_rule[refine_vcg] = \n  ASSERT_le_defI[OF find_path0_spec_def]\n  ASSERT_leof_defI[OF find_path0_spec_def]"], ["", "subsection \\<open>Restricting the Graph\\<close>"], ["", "text \\<open> Extended interface, propagating set of already searched nodes (restriction) \\<close>"], ["", "(* Invariant for restriction: The restriction is closed under E \n  and contains no P-nodes *)"], ["", "definition restr_invar \n  \\<comment> \\<open>Invariant for a node restriction, i.e., a transition closed set of nodes \n    known to not contain a target node that satisfies a predicate.\\<close>\n  where\n  \"restr_invar E R P \\<equiv> E `` R \\<subseteq> R \\<and> R \\<inter> Collect P = {}\""], ["", "lemma restr_invar_triv[simp, intro!]: \"restr_invar E {} P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restr_invar E {} P", "unfolding restr_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` {} \\<subseteq> {} \\<and> {} \\<inter> Collect P = {}", "by simp"], ["", "lemma restr_invar_imp_not_reachable: \"restr_invar E R P \\<Longrightarrow> E\\<^sup>*``R \\<inter> Collect P = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restr_invar E R P \\<Longrightarrow>\n    E\\<^sup>* `` R \\<inter> Collect P = {}", "unfolding restr_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` R \\<subseteq> R \\<and> R \\<inter> Collect P = {} \\<Longrightarrow>\n    E\\<^sup>* `` R \\<inter> Collect P = {}", "by (simp add: Image_closed_trancl)"], ["", "type_synonym 'v fpr_result = \"'v set + ('v list \\<times> 'v)\""], ["", "definition \"find_path0_restr_pred G P R \\<equiv> \\<lambda>r. \n    case r of \n      Inl R' \\<Rightarrow> R' = R \\<union> (g_E G)\\<^sup>* `` g_V0 G \\<and> restr_invar (g_E G) R' P\n    | Inr (vs,v) \\<Rightarrow> P v \\<and> (\\<exists> v0 \\<in> g_V0 G - R. path (rel_restrict (g_E G) R) v0 vs v)\""], ["", "definition find_path0_restr_spec \n  \\<comment> \\<open>Find a path to a target node that satisfies a predicate, not considering\n      nodes from the given node restriction. If no path is found, an extended\n      restriction is returned, that contains the start nodes\\<close>\n  where \"find_path0_restr_spec G P R \\<equiv> do {\n    ASSERT (fb_graph G \\<and> restr_invar (g_E G) R P);\n    SPEC (find_path0_restr_pred G P R)}\""], ["", "lemmas find_path0_restr_spec_rule[refine_vcg] = \n  ASSERT_le_defI[OF find_path0_restr_spec_def]\n  ASSERT_leof_defI[OF find_path0_restr_spec_def]"], ["", "definition find_path0_restr \n  :: \"('v, 'more) graph_rec_scheme \\<Rightarrow> ('v \\<Rightarrow> bool) \\<Rightarrow> 'v set \\<Rightarrow> 'v fpr_result nres\"\n  where \"find_path0_restr G P R \\<equiv> do {\n  ASSERT (fb_graph G);\n  ASSERT (fp0 (graph_restrict G R));\n  s \\<leftarrow> fp0.it_dfs TYPE('more) (graph_restrict G R) P;\n  case ppath s of\n    None \\<Rightarrow> do {\n      ASSERT (dom (discovered s) = dom (finished s));\n      RETURN (Inl (R \\<union> dom (finished s)))\n    }\n  | Some (vs,v) \\<Rightarrow> RETURN (Inr (vs,v))\n}\""], ["", "lemma find_path0_restr_correct:\n  shows \"find_path0_restr G P R \\<le> find_path0_restr_spec G P R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path0_restr G P R \\<le> find_path0_restr_spec G P R", "proof (rule le_ASSERT_defI1[OF find_path0_restr_spec_def], clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path0_restr G P R\n                      \\<le> find_path0_restr_spec G P R", "assume \"fb_graph G\""], ["proof (state)\nthis:\n  fb_graph G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path0_restr G P R\n                      \\<le> find_path0_restr_spec G P R", "interpret a: fb_graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path0_restr G P R\n                      \\<le> find_path0_restr_spec G P R", "interpret fb_graph \"graph_restrict G R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph (graph_restrict G R)", "by (rule a.fb_graph_restrict)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path0_restr G P R\n                      \\<le> find_path0_restr_spec G P R", "assume I: \"restr_invar (g_E G) R P\""], ["proof (state)\nthis:\n  restr_invar (g_E G) R P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path0_restr G P R\n                      \\<le> find_path0_restr_spec G P R", "define reachable where \"reachable = graph_defs.reachable (graph_restrict G R)\""], ["proof (state)\nthis:\n  reachable =\n  (g_E (graph_restrict G R))\\<^sup>* `` g_V0 (graph_restrict G R)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path0_restr G P R\n                      \\<le> find_path0_restr_spec G P R", "interpret fp0 \"graph_restrict G R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fp0 (graph_restrict G R)", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path0_restr G P R\n                      \\<le> find_path0_restr_spec G P R", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path0_restr G P R \\<le> find_path0_restr_spec G P R", "unfolding find_path0_restr_def find_path0_restr_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_.\n        ASSERT (fp0 (graph_restrict G R)) \\<bind>\n        (\\<lambda>_.\n            param_DFS_defs.it_dfs (graph_restrict G R)\n             (fp0_params P) \\<bind>\n            (\\<lambda>s.\n                case ppath s of\n                None \\<Rightarrow>\n                  ASSERT (dom (discovered s) = dom (finished s)) \\<bind>\n                  (\\<lambda>_. RETURN (Inl (R \\<union> dom (finished s))))\n                | Some (vs, v) \\<Rightarrow> RETURN (Inr (vs, v)))))\n    \\<le> ASSERT (fb_graph G \\<and> restr_invar (g_E G) R P) \\<bind>\n          (\\<lambda>_. SPEC (find_path0_restr_pred G P R))", "apply (refine_rcg refine_vcg le_ASSERTI order_trans[OF it_dfs_correct])"], ["proof (prove)\ngoal (5 subgoals):\n 1. fb_graph G \\<and> restr_invar (g_E G) R P \\<Longrightarrow> fb_graph G\n 2. \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; fb_graph G\\<rbrakk>\n    \\<Longrightarrow> fp0 (graph_restrict G R)\n 3. \\<And>x.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R);\n        DFS_invar (graph_restrict G R) (fp0_params P) x \\<and>\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) x;\n        ppath x = None\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = dom (finished x)\n 4. \\<And>x.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R);\n        DFS_invar (graph_restrict G R) (fp0_params P) x \\<and>\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) x;\n        ppath x = None; dom (discovered x) = dom (finished x)\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 5. \\<And>x xa a b.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R);\n        DFS_invar (graph_restrict G R) (fp0_params P) x \\<and>\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) x;\n        ppath x = Some xa; xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (a, b))", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R);\n        DFS_invar (graph_restrict G R) (fp0_params P) x \\<and>\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) x;\n        ppath x = None\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = dom (finished x)\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R);\n        DFS_invar (graph_restrict G R) (fp0_params P) x \\<and>\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) x;\n        ppath x = None; dom (discovered x) = dom (finished x)\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 3. \\<And>x xa a b.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R);\n        DFS_invar (graph_restrict G R) (fp0_params P) x \\<and>\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) x;\n        ppath x = Some xa; xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (a, b))", "apply (clarsimp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = dom (finished x)\n 2. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 3. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = dom (finished x)\n 2. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 3. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "fix s"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = dom (finished x)\n 2. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 3. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "assume \"fp0_invar (graph_restrict G R) P s\"\n      and NC[simp]: \"\\<not>fp0.cond TYPE('b) (graph_restrict G R) P s\""], ["proof (state)\nthis:\n  fp0_invar (graph_restrict G R) P s\n  \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = dom (finished x)\n 2. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 3. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "then"], ["proof (chain)\npicking this:\n  fp0_invar (graph_restrict G R) P s\n  \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s", "interpret fp0_invar \"graph_restrict G R\" P s"], ["proof (prove)\nusing this:\n  fp0_invar (graph_restrict G R) P s\n  \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s\n\ngoal (1 subgoal):\n 1. fp0_invar (graph_restrict G R) P s", "by simp"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = dom (finished x)\n 2. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 3. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = dom (finished x)\n 2. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 3. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "assume [simp]: \"ppath s = None\""], ["proof (state)\nthis:\n  ppath s = None\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> dom (discovered x) = dom (finished x)\n 2. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 3. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "from nc_discovered_eq_finished"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s;\n   \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> dom (discovered s) = dom (finished s)", "show \"dom (discovered s) = dom (finished s)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s;\n   \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> dom (discovered s) = dom (finished s)\n\ngoal (1 subgoal):\n 1. dom (discovered s) = dom (finished s)", "by simp"], ["proof (state)\nthis:\n  dom (discovered s) = dom (finished s)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 2. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "from nc_finished_eq_reachable"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s;\n   \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> dom (finished s) =\n                    (g_E (graph_restrict G R))\\<^sup>* ``\n                    g_V0 (graph_restrict G R)", "have DFR[simp]: \"dom (finished s) = reachable\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s;\n   \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> dom (finished s) =\n                    (g_E (graph_restrict G R))\\<^sup>* ``\n                    g_V0 (graph_restrict G R)\n\ngoal (1 subgoal):\n 1. dom (finished s) = reachable", "by (simp add: reachable_def)"], ["proof (state)\nthis:\n  dom (finished s) = reachable\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 2. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "from I"], ["proof (chain)\npicking this:\n  restr_invar (g_E G) R P", "have \"g_E G `` R \\<subseteq> R\""], ["proof (prove)\nusing this:\n  restr_invar (g_E G) R P\n\ngoal (1 subgoal):\n 1. g_E G `` R \\<subseteq> R", "unfolding restr_invar_def"], ["proof (prove)\nusing this:\n  g_E G `` R \\<subseteq> R \\<and> R \\<inter> Collect P = {}\n\ngoal (1 subgoal):\n 1. g_E G `` R \\<subseteq> R", "by auto"], ["proof (state)\nthis:\n  g_E G `` R \\<subseteq> R\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 2. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "have \"reachable \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g_E (graph_restrict G R))\\<^sup>* `` g_V0 (graph_restrict G R)\n    \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G", "by (rule Image_mono, rule rtrancl_mono) (auto simp: rel_restrict_def)"], ["proof (state)\nthis:\n  reachable \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 2. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "hence \"R \\<union> dom (finished s) = R \\<union> (g_E G)\\<^sup>* `` g_V0 G\""], ["proof (prove)\nusing this:\n  reachable \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G\n\ngoal (1 subgoal):\n 1. R \\<union> dom (finished s) = R \\<union> (g_E G)\\<^sup>* `` g_V0 G", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G \\<Longrightarrow>\n    R \\<union> dom (finished s) = R \\<union> (g_E G)\\<^sup>* `` g_V0 G", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. reachable \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G \\<Longrightarrow>\n    R \\<union> dom (finished s)\n    \\<subseteq> R \\<union> (g_E G)\\<^sup>* `` g_V0 G\n 2. reachable \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G \\<Longrightarrow>\n    R \\<union> (g_E G)\\<^sup>* `` g_V0 G\n    \\<subseteq> R \\<union> dom (finished s)", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G \\<Longrightarrow>\n    R \\<union> (g_E G)\\<^sup>* `` g_V0 G\n    \\<subseteq> R \\<union> dom (finished s)", "unfolding DFR reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g_E (graph_restrict G R))\\<^sup>* `` g_V0 (graph_restrict G R)\n    \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G \\<Longrightarrow>\n    R \\<union> (g_E G)\\<^sup>* `` g_V0 G\n    \\<subseteq> R \\<union>\n                (g_E (graph_restrict G R))\\<^sup>* ``\n                g_V0 (graph_restrict G R)", "apply (auto elim: E_closed_restr_reach_cases[OF _ \\<open>g_E G `` R \\<subseteq> R\\<close>]) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  R \\<union> dom (finished s) = R \\<union> (g_E G)\\<^sup>* `` g_V0 G\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 2. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "moreover"], ["proof (state)\nthis:\n  R \\<union> dom (finished s) = R \\<union> (g_E G)\\<^sup>* `` g_V0 G\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 2. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "from nc_fin_closed I"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s;\n   \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> g_E (graph_restrict G R) `` dom (finished s)\n                    \\<subseteq> dom (finished s)\n  restr_invar (g_E G) R P", "have \"g_E G `` (R \\<union> dom (finished s)) \\<subseteq> R \\<union> dom (finished s)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s;\n   \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> g_E (graph_restrict G R) `` dom (finished s)\n                    \\<subseteq> dom (finished s)\n  restr_invar (g_E G) R P\n\ngoal (1 subgoal):\n 1. g_E G `` (R \\<union> dom (finished s))\n    \\<subseteq> R \\<union> dom (finished s)", "unfolding restr_invar_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s;\n   \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> g_E (graph_restrict G R) `` dom (finished s)\n                    \\<subseteq> dom (finished s)\n  g_E G `` R \\<subseteq> R \\<and> R \\<inter> Collect P = {}\n\ngoal (1 subgoal):\n 1. g_E G `` (R \\<union> dom (finished s))\n    \\<subseteq> R \\<union> dom (finished s)", "by (simp add: rel_restrict_def) blast"], ["proof (state)\nthis:\n  g_E G `` (R \\<union> dom (finished s))\n  \\<subseteq> R \\<union> dom (finished s)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 2. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "moreover"], ["proof (state)\nthis:\n  g_E G `` (R \\<union> dom (finished s))\n  \\<subseteq> R \\<union> dom (finished s)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 2. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "from no_path_no_P_discovered nc_discovered_eq_finished I"], ["proof (chain)\npicking this:\n  ppath s = None \\<Longrightarrow>\n  dom (discovered s) \\<inter> Collect P = {}\n  \\<lbrakk>\\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s;\n   \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> dom (discovered s) = dom (finished s)\n  restr_invar (g_E G) R P", "have \"(R \\<union> dom (finished s)) \\<inter> Collect P = {}\""], ["proof (prove)\nusing this:\n  ppath s = None \\<Longrightarrow>\n  dom (discovered s) \\<inter> Collect P = {}\n  \\<lbrakk>\\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s;\n   \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> dom (discovered s) = dom (finished s)\n  restr_invar (g_E G) R P\n\ngoal (1 subgoal):\n 1. (R \\<union> dom (finished s)) \\<inter> Collect P = {}", "unfolding restr_invar_def"], ["proof (prove)\nusing this:\n  ppath s = None \\<Longrightarrow>\n  dom (discovered s) \\<inter> Collect P = {}\n  \\<lbrakk>\\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P) s;\n   \\<not> is_break (fp0_params P) s\\<rbrakk>\n  \\<Longrightarrow> dom (discovered s) = dom (finished s)\n  g_E G `` R \\<subseteq> R \\<and> R \\<inter> Collect P = {}\n\ngoal (1 subgoal):\n 1. (R \\<union> dom (finished s)) \\<inter> Collect P = {}", "by auto"], ["proof (state)\nthis:\n  (R \\<union> dom (finished s)) \\<inter> Collect P = {}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = None;\n        dom (discovered x) = dom (finished x);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R\n                          (Inl (R \\<union> dom (finished x)))\n 2. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "ultimately"], ["proof (chain)\npicking this:\n  R \\<union> dom (finished s) = R \\<union> (g_E G)\\<^sup>* `` g_V0 G\n  g_E G `` (R \\<union> dom (finished s))\n  \\<subseteq> R \\<union> dom (finished s)\n  (R \\<union> dom (finished s)) \\<inter> Collect P = {}", "show \"find_path0_restr_pred G P R (Inl (R \\<union> dom (finished s)))\""], ["proof (prove)\nusing this:\n  R \\<union> dom (finished s) = R \\<union> (g_E G)\\<^sup>* `` g_V0 G\n  g_E G `` (R \\<union> dom (finished s))\n  \\<subseteq> R \\<union> dom (finished s)\n  (R \\<union> dom (finished s)) \\<inter> Collect P = {}\n\ngoal (1 subgoal):\n 1. find_path0_restr_pred G P R (Inl (R \\<union> dom (finished s)))", "unfolding restr_invar_def find_path0_restr_pred_def"], ["proof (prove)\nusing this:\n  R \\<union> dom (finished s) = R \\<union> (g_E G)\\<^sup>* `` g_V0 G\n  g_E G `` (R \\<union> dom (finished s))\n  \\<subseteq> R \\<union> dom (finished s)\n  (R \\<union> dom (finished s)) \\<inter> Collect P = {}\n\ngoal (1 subgoal):\n 1. case Inl (R \\<union> dom (finished s)) of\n    Inl R' \\<Rightarrow>\n      R' = R \\<union> (g_E G)\\<^sup>* `` g_V0 G \\<and>\n      g_E G `` R' \\<subseteq> R' \\<and> R' \\<inter> Collect P = {}\n    | Inr (vs, v) \\<Rightarrow>\n        P v \\<and>\n        (\\<exists>v0\\<in>g_V0 G - R. path (rel_restrict (g_E G) R) v0 vs v)", "by auto"], ["proof (state)\nthis:\n  find_path0_restr_pred G P R (Inl (R \\<union> dom (finished s)))\n\ngoal (1 subgoal):\n 1. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "}"], ["proof (state)\nthis:\n  ppath s = None \\<Longrightarrow>\n  find_path0_restr_pred G P R (Inl (R \\<union> dom (finished s)))\n\ngoal (1 subgoal):\n 1. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "{"], ["proof (state)\nthis:\n  ppath s = None \\<Longrightarrow>\n  find_path0_restr_pred G P R (Inl (R \\<union> dom (finished s)))\n\ngoal (1 subgoal):\n 1. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "fix v vs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "assume [simp]: \"ppath s = Some (vs,v)\""], ["proof (state)\nthis:\n  ppath s = Some (vs, v)\n\ngoal (1 subgoal):\n 1. \\<And>x aa ba.\n       \\<lbrakk>restr_invar (g_E G) R P; fb_graph G;\n        fp0 (graph_restrict G R); ppath x = Some (aa, ba);\n        fp0_invar (graph_restrict G R) P x;\n        \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n                x\\<rbrakk>\n       \\<Longrightarrow> find_path0_restr_pred G P R (Inr (aa, ba))", "from fp0_correct"], ["proof (chain)\npicking this:\n  \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n          s \\<Longrightarrow>\n  case ppath s of\n  None \\<Rightarrow>\n    \\<not> (\\<exists>v0\\<in>g_V0 (graph_restrict G R).\n               \\<exists>v.\n                  (v0, v) \\<in> (g_E (graph_restrict G R))\\<^sup>* \\<and>\n                  P v)\n  | Some (p, v) \\<Rightarrow>\n      \\<exists>v0\\<in>g_V0 (graph_restrict G R).\n         path (g_E (graph_restrict G R)) v0 p v \\<and>\n         P v \\<and> distinct (p @ [v])", "show \"find_path0_restr_pred G P R (Inr (vs, v))\""], ["proof (prove)\nusing this:\n  \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n          s \\<Longrightarrow>\n  case ppath s of\n  None \\<Rightarrow>\n    \\<not> (\\<exists>v0\\<in>g_V0 (graph_restrict G R).\n               \\<exists>v.\n                  (v0, v) \\<in> (g_E (graph_restrict G R))\\<^sup>* \\<and>\n                  P v)\n  | Some (p, v) \\<Rightarrow>\n      \\<exists>v0\\<in>g_V0 (graph_restrict G R).\n         path (g_E (graph_restrict G R)) v0 p v \\<and>\n         P v \\<and> distinct (p @ [v])\n\ngoal (1 subgoal):\n 1. find_path0_restr_pred G P R (Inr (vs, v))", "unfolding find_path0_restr_pred_def"], ["proof (prove)\nusing this:\n  \\<not> param_DFS_defs.cond (graph_restrict G R) (fp0_params P)\n          s \\<Longrightarrow>\n  case ppath s of\n  None \\<Rightarrow>\n    \\<not> (\\<exists>v0\\<in>g_V0 (graph_restrict G R).\n               \\<exists>v.\n                  (v0, v) \\<in> (g_E (graph_restrict G R))\\<^sup>* \\<and>\n                  P v)\n  | Some (p, v) \\<Rightarrow>\n      \\<exists>v0\\<in>g_V0 (graph_restrict G R).\n         path (g_E (graph_restrict G R)) v0 p v \\<and>\n         P v \\<and> distinct (p @ [v])\n\ngoal (1 subgoal):\n 1. case Inr (vs, v) of\n    Inl R' \\<Rightarrow>\n      R' = R \\<union> (g_E G)\\<^sup>* `` g_V0 G \\<and>\n      restr_invar (g_E G) R' P\n    | Inr (vs, v) \\<Rightarrow>\n        P v \\<and>\n        (\\<exists>v0\\<in>g_V0 G - R. path (rel_restrict (g_E G) R) v0 vs v)", "by auto"], ["proof (state)\nthis:\n  find_path0_restr_pred G P R (Inr (vs, v))\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ppath s = Some (?vs3, ?v3) \\<Longrightarrow>\n  find_path0_restr_pred G P R (Inr (?vs3, ?v3))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  find_path0_restr G P R \\<le> find_path0_restr_spec G P R\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Path of Minimal Length One, with Restriction\\<close>"], ["", "definition \"find_path1_restr_pred G P R \\<equiv> \\<lambda>r. \n      case r of \n        Inl R' \\<Rightarrow> R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and> restr_invar (g_E G) R' P\n      | Inr (vs,v) \\<Rightarrow> P v \\<and> vs \\<noteq> [] \\<and> (\\<exists> v0 \\<in> g_V0 G. path (g_E G \\<inter> UNIV \\<times> -R) v0 vs v)\""], ["", "definition find_path1_restr_spec \n  \\<comment> \\<open>Find a path of length at least one to a target node that satisfies P.\n    Takes an initial node restriction, and returns an extended node restriction.\\<close>\n  where \"find_path1_restr_spec G P R \\<equiv> do {\n    ASSERT (fb_graph G \\<and> restr_invar (g_E G) R P);\n    SPEC (find_path1_restr_pred G P R)}\""], ["", "lemmas find_path1_restr_spec_rule[refine_vcg] = \n  ASSERT_le_defI[OF find_path1_restr_spec_def]\n  ASSERT_leof_defI[OF find_path1_restr_spec_def]"], ["", "definition find_path1_restr\n  :: \"('v, 'more) graph_rec_scheme \\<Rightarrow> ('v \\<Rightarrow> bool) \\<Rightarrow> 'v set \\<Rightarrow> 'v fpr_result nres\"\n  where \"find_path1_restr G P R \\<equiv> \n  FOREACHc (g_V0 G) is_Inl (\\<lambda>v0 s. do {\n    ASSERT (is_Inl s); \\<comment> \\<open>TODO: Add FOREACH-condition as precondition in autoref!\\<close>\n    let R = projl s;\n    f0 \\<leftarrow> find_path0_restr_spec (G \\<lparr> g_V0 := g_E G `` {v0} \\<rparr>) P R;\n    case f0 of \n      Inl _ \\<Rightarrow> RETURN f0\n    | Inr (vs,v) \\<Rightarrow> RETURN (Inr (v0#vs,v))\n  }) (Inl R)\""], ["", "definition \"find_path1_tailrec_invar G P R0 it s \\<equiv> \n  case s of\n    Inl R \\<Rightarrow> R = R0 \\<union> (g_E G)\\<^sup>+ `` (g_V0 G - it) \\<and> restr_invar (g_E G) R P\n  | Inr (vs, v) \\<Rightarrow> P v \\<and> vs \\<noteq> [] \\<and> (\\<exists> v0 \\<in> g_V0 G - it. path (g_E G \\<inter> UNIV \\<times> -R0) v0 vs v)\""], ["", "lemma find_path1_restr_correct:\n  shows \"find_path1_restr G P R \\<le> find_path1_restr_spec G P R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path1_restr G P R \\<le> find_path1_restr_spec G P R", "proof (rule le_ASSERT_defI1[OF find_path1_restr_spec_def], clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "assume \"fb_graph G\""], ["proof (state)\nthis:\n  fb_graph G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "interpret a: fb_graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "interpret fb0: fb_graph \"G \\<lparr> g_E := g_E G \\<inter> UNIV \\<times> -R \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph (G\\<lparr>g_E := g_E G \\<inter> UNIV \\<times> - R\\<rparr>)", "by (rule a.fb_graph_subset, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "assume I: \"restr_invar (g_E G) R P\""], ["proof (state)\nthis:\n  restr_invar (g_E G) R P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "have aux2: \"\\<And>v0. v0 \\<in> g_V0 G \\<Longrightarrow> fb_graph (G \\<lparr> g_V0 := g_E G `` {v0} \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v0.\n       v0 \\<in> g_V0 G \\<Longrightarrow>\n       fb_graph (G\\<lparr>g_V0 := g_E G `` {v0}\\<rparr>)", "by (rule a.fb_graph_subset, auto)"], ["proof (state)\nthis:\n  ?v0.0 \\<in> g_V0 G \\<Longrightarrow>\n  fb_graph (G\\<lparr>g_V0 := g_E G `` {?v0.0}\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "{"], ["proof (state)\nthis:\n  ?v0.0 \\<in> g_V0 G \\<Longrightarrow>\n  fb_graph (G\\<lparr>g_V0 := g_E G `` {?v0.0}\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "fix v0 it s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "assume IT: \"it \\<subseteq> g_V0 G\" \"v0 \\<in> it\"\n    and \"is_Inl s\"\n    and FPI: \"find_path1_tailrec_invar G P R it s\"\n    and RI: \"restr_invar (g_E G) (projl s \\<union> (g_E G)\\<^sup>+ `` {v0}) P\""], ["proof (state)\nthis:\n  it \\<subseteq> g_V0 G\n  v0 \\<in> it\n  is_Inl s\n  find_path1_tailrec_invar G P R it s\n  restr_invar (g_E G) (projl s \\<union> (g_E G)\\<^sup>+ `` {v0}) P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "then"], ["proof (chain)\npicking this:\n  it \\<subseteq> g_V0 G\n  v0 \\<in> it\n  is_Inl s\n  find_path1_tailrec_invar G P R it s\n  restr_invar (g_E G) (projl s \\<union> (g_E G)\\<^sup>+ `` {v0}) P", "obtain R' where [simp]: \"s = Inl R'\""], ["proof (prove)\nusing this:\n  it \\<subseteq> g_V0 G\n  v0 \\<in> it\n  is_Inl s\n  find_path1_tailrec_invar G P R it s\n  restr_invar (g_E G) (projl s \\<union> (g_E G)\\<^sup>+ `` {v0}) P\n\ngoal (1 subgoal):\n 1. (\\<And>R'. s = Inl R' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases s) auto"], ["proof (state)\nthis:\n  s = Inl R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "from FPI"], ["proof (chain)\npicking this:\n  find_path1_tailrec_invar G P R it s", "have [simp]: \"R' = R \\<union> (g_E G)\\<^sup>+ `` (g_V0 G - it)\""], ["proof (prove)\nusing this:\n  find_path1_tailrec_invar G P R it s\n\ngoal (1 subgoal):\n 1. R' = R \\<union> (g_E G)\\<^sup>+ `` (g_V0 G - it)", "unfolding find_path1_tailrec_invar_def"], ["proof (prove)\nusing this:\n  case s of\n  Inl Ra \\<Rightarrow>\n    Ra = R \\<union> (g_E G)\\<^sup>+ `` (g_V0 G - it) \\<and>\n    restr_invar (g_E G) Ra P\n  | Inr (vs, v) \\<Rightarrow>\n      P v \\<and>\n      vs \\<noteq> [] \\<and>\n      (\\<exists>v0\\<in>g_V0 G - it.\n          path (g_E G \\<inter> UNIV \\<times> - R) v0 vs v)\n\ngoal (1 subgoal):\n 1. R' = R \\<union> (g_E G)\\<^sup>+ `` (g_V0 G - it)", "by simp"], ["proof (state)\nthis:\n  R' = R \\<union> (g_E G)\\<^sup>+ `` (g_V0 G - it)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "have \"find_path1_tailrec_invar G P R (it - {v0})\n            (Inl (projl s \\<union> (g_E G)\\<^sup>+ `` {v0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path1_tailrec_invar G P R (it - {v0})\n     (Inl (projl s \\<union> (g_E G)\\<^sup>+ `` {v0}))", "using RI"], ["proof (prove)\nusing this:\n  restr_invar (g_E G) (projl s \\<union> (g_E G)\\<^sup>+ `` {v0}) P\n\ngoal (1 subgoal):\n 1. find_path1_tailrec_invar G P R (it - {v0})\n     (Inl (projl s \\<union> (g_E G)\\<^sup>+ `` {v0}))", "by (auto simp: find_path1_tailrec_invar_def it_step_insert_iff[OF IT])"], ["proof (state)\nthis:\n  find_path1_tailrec_invar G P R (it - {v0})\n   (Inl (projl s \\<union> (g_E G)\\<^sup>+ `` {v0}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?it2 \\<subseteq> g_V0 G; ?v0.2 \\<in> ?it2; is_Inl ?s2;\n   find_path1_tailrec_invar G P R ?it2 ?s2;\n   restr_invar (g_E G) (projl ?s2 \\<union> (g_E G)\\<^sup>+ `` {?v0.2})\n    P\\<rbrakk>\n  \\<Longrightarrow> find_path1_tailrec_invar G P R (?it2 - {?v0.2})\n                     (Inl (projl ?s2 \\<union> (g_E G)\\<^sup>+ `` {?v0.2}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "note aux4 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?it2 \\<subseteq> g_V0 G; ?v0.2 \\<in> ?it2; is_Inl ?s2;\n   find_path1_tailrec_invar G P R ?it2 ?s2;\n   restr_invar (g_E G) (projl ?s2 \\<union> (g_E G)\\<^sup>+ `` {?v0.2})\n    P\\<rbrakk>\n  \\<Longrightarrow> find_path1_tailrec_invar G P R (?it2 - {?v0.2})\n                     (Inl (projl ?s2 \\<union> (g_E G)\\<^sup>+ `` {?v0.2}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?it2 \\<subseteq> g_V0 G; ?v0.2 \\<in> ?it2; is_Inl ?s2;\n   find_path1_tailrec_invar G P R ?it2 ?s2;\n   restr_invar (g_E G) (projl ?s2 \\<union> (g_E G)\\<^sup>+ `` {?v0.2})\n    P\\<rbrakk>\n  \\<Longrightarrow> find_path1_tailrec_invar G P R (?it2 - {?v0.2})\n                     (Inl (projl ?s2 \\<union> (g_E G)\\<^sup>+ `` {?v0.2}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "fix v0 u it s v p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "assume IT: \"it \\<subseteq> g_V0 G\" \"v0 \\<in> it\"\n    and \"is_Inl s\"\n    and FPI: \"find_path1_tailrec_invar G P R it s\"\n    and PV: \"P v\"\n    and PATH: \"path (rel_restrict (g_E G) (projl s)) u p v\" \"(v0,u)\\<in>(g_E G)\"\n    and PR: \"u \\<notin> projl s\""], ["proof (state)\nthis:\n  it \\<subseteq> g_V0 G\n  v0 \\<in> it\n  is_Inl s\n  find_path1_tailrec_invar G P R it s\n  P v\n  path (rel_restrict (g_E G) (projl s)) u p v\n  (v0, u) \\<in> g_E G\n  u \\<notin> projl s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "then"], ["proof (chain)\npicking this:\n  it \\<subseteq> g_V0 G\n  v0 \\<in> it\n  is_Inl s\n  find_path1_tailrec_invar G P R it s\n  P v\n  path (rel_restrict (g_E G) (projl s)) u p v\n  (v0, u) \\<in> g_E G\n  u \\<notin> projl s", "obtain R' where [simp]: \"s = Inl R'\""], ["proof (prove)\nusing this:\n  it \\<subseteq> g_V0 G\n  v0 \\<in> it\n  is_Inl s\n  find_path1_tailrec_invar G P R it s\n  P v\n  path (rel_restrict (g_E G) (projl s)) u p v\n  (v0, u) \\<in> g_E G\n  u \\<notin> projl s\n\ngoal (1 subgoal):\n 1. (\\<And>R'. s = Inl R' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases s) auto"], ["proof (state)\nthis:\n  s = Inl R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "from FPI"], ["proof (chain)\npicking this:\n  find_path1_tailrec_invar G P R it s", "have [simp]: \"R' = R \\<union> (g_E G)\\<^sup>+ `` (g_V0 G - it)\""], ["proof (prove)\nusing this:\n  find_path1_tailrec_invar G P R it s\n\ngoal (1 subgoal):\n 1. R' = R \\<union> (g_E G)\\<^sup>+ `` (g_V0 G - it)", "unfolding find_path1_tailrec_invar_def"], ["proof (prove)\nusing this:\n  case s of\n  Inl Ra \\<Rightarrow>\n    Ra = R \\<union> (g_E G)\\<^sup>+ `` (g_V0 G - it) \\<and>\n    restr_invar (g_E G) Ra P\n  | Inr (vs, v) \\<Rightarrow>\n      P v \\<and>\n      vs \\<noteq> [] \\<and>\n      (\\<exists>v0\\<in>g_V0 G - it.\n          path (g_E G \\<inter> UNIV \\<times> - R) v0 vs v)\n\ngoal (1 subgoal):\n 1. R' = R \\<union> (g_E G)\\<^sup>+ `` (g_V0 G - it)", "by simp"], ["proof (state)\nthis:\n  R' = R \\<union> (g_E G)\\<^sup>+ `` (g_V0 G - it)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "have \"find_path1_tailrec_invar G P R (it - {v0}) (Inr (v0 # p, v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path1_tailrec_invar G P R (it - {v0}) (Inr (v0 # p, v))", "apply (simp add: find_path1_tailrec_invar_def PV)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v0a\\<in>g_V0 G - (it - {v0}).\n       path (g_E G \\<inter> UNIV \\<times> - R) v0a (v0 # p) v", "apply (rule bexI[where x=v0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. path (g_E G \\<inter> UNIV \\<times> - R) v0 (v0 # p) v\n 2. v0 \\<in> g_V0 G - (it - {v0})", "using PR PATH(2) path_mono[OF rel_restrict_mono2[of R] PATH(1)]"], ["proof (prove)\nusing this:\n  u \\<notin> projl s\n  (v0, u) \\<in> g_E G\n  R \\<subseteq> projl s \\<Longrightarrow>\n  path (rel_restrict (g_E G) R) u p v\n\ngoal (2 subgoals):\n 1. path (g_E G \\<inter> UNIV \\<times> - R) v0 (v0 # p) v\n 2. v0 \\<in> g_V0 G - (it - {v0})", "apply (auto simp: path1_restr_conv) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<in> g_V0 G - (it - {v0})", "using IT"], ["proof (prove)\nusing this:\n  it \\<subseteq> g_V0 G\n  v0 \\<in> it\n\ngoal (1 subgoal):\n 1. v0 \\<in> g_V0 G - (it - {v0})", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  find_path1_tailrec_invar G P R (it - {v0}) (Inr (v0 # p, v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?it2 \\<subseteq> g_V0 G; ?v0.2 \\<in> ?it2; is_Inl ?s2;\n   find_path1_tailrec_invar G P R ?it2 ?s2; P ?v2;\n   path (rel_restrict (g_E G) (projl ?s2)) ?u2 ?p2 ?v2;\n   (?v0.2, ?u2) \\<in> g_E G; ?u2 \\<notin> projl ?s2\\<rbrakk>\n  \\<Longrightarrow> find_path1_tailrec_invar G P R (?it2 - {?v0.2})\n                     (Inr (?v0.2 # ?p2, ?v2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "note aux5 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?it2 \\<subseteq> g_V0 G; ?v0.2 \\<in> ?it2; is_Inl ?s2;\n   find_path1_tailrec_invar G P R ?it2 ?s2; P ?v2;\n   path (rel_restrict (g_E G) (projl ?s2)) ?u2 ?p2 ?v2;\n   (?v0.2, ?u2) \\<in> g_E G; ?u2 \\<notin> projl ?s2\\<rbrakk>\n  \\<Longrightarrow> find_path1_tailrec_invar G P R (?it2 - {?v0.2})\n                     (Inr (?v0.2 # ?p2, ?v2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; restr_invar (g_E G) R P\\<rbrakk>\n    \\<Longrightarrow> find_path1_restr G P R\n                      \\<le> find_path1_restr_spec G P R", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path1_restr G P R \\<le> find_path1_restr_spec G P R", "unfolding find_path1_restr_def find_path1_restr_spec_def find_path1_restr_pred_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C (g_V0 G) is_Inl\n     (\\<lambda>v0 s.\n         ASSERT (is_Inl s) \\<bind>\n         (\\<lambda>_.\n             let R = projl s\n             in find_path0_restr_spec\n                 (G\\<lparr>g_V0 := g_E G `` {v0}\\<rparr>) P R \\<bind>\n                (\\<lambda>f0.\n                    case f0 of Inl x \\<Rightarrow> RETURN f0\n                    | Inr (vs, v) \\<Rightarrow> RETURN (Inr (v0 # vs, v)))))\n     (Inl R)\n    \\<le> ASSERT (fb_graph G \\<and> restr_invar (g_E G) R P) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>r.\n                   case r of\n                   Inl R' \\<Rightarrow>\n                     R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                     restr_invar (g_E G) R' P\n                   | Inr (vs, v) \\<Rightarrow>\n                       P v \\<and>\n                       vs \\<noteq> [] \\<and>\n                       (\\<exists>v0\\<in>g_V0 G.\n                           path (g_E G \\<inter> UNIV \\<times> - R) v0 vs\n                            v)))", "apply (refine_rcg le_ASSERTI\n      refine_vcg FOREACHc_rule[where I=\"find_path1_tailrec_invar G P R\"]\n      (*order_trans[OF find_path0_restr_correct]*)\n      )"], ["proof (prove)\ngoal (7 subgoals):\n 1. fb_graph G \\<and> restr_invar (g_E G) R P \\<Longrightarrow>\n    finite (g_V0 G)\n 2. fb_graph G \\<and> restr_invar (g_E G) R P \\<Longrightarrow>\n    find_path1_tailrec_invar G P R (g_V0 G) (Inl R)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> fb_graph (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>)\n 4. \\<And>x it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> restr_invar\n                          (g_E (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>))\n                          (projl \\<sigma>) P\n 5. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>;\n        fb_graph (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) \\<and>\n        restr_invar (g_E (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>))\n         (projl \\<sigma>) P;\n        find_path0_restr_pred (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) P\n         (projl \\<sigma>) xa\\<rbrakk>\n       \\<Longrightarrow> (case xa of Inl x \\<Rightarrow> RETURN xa\n                          | Inr (vs, v) \\<Rightarrow>\n                              RETURN (Inr (x # vs, v)))\n                         \\<le> SPEC\n                                (find_path1_tailrec_invar G P R (it - {x}))\n 6. \\<And>\\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P;\n        find_path1_tailrec_invar G P R {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)\n 7. \\<And>it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; it \\<noteq> {};\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        \\<not> is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. fb_graph G \\<and> restr_invar (g_E G) R P \\<Longrightarrow>\n    find_path1_tailrec_invar G P R (g_V0 G) (Inl R)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> fb_graph (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> restr_invar\n                          (g_E (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>))\n                          (projl \\<sigma>) P\n 4. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>;\n        fb_graph (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) \\<and>\n        restr_invar (g_E (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>))\n         (projl \\<sigma>) P;\n        find_path0_restr_pred (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) P\n         (projl \\<sigma>) xa\\<rbrakk>\n       \\<Longrightarrow> (case xa of Inl x \\<Rightarrow> RETURN xa\n                          | Inr (vs, v) \\<Rightarrow>\n                              RETURN (Inr (x # vs, v)))\n                         \\<le> SPEC\n                                (find_path1_tailrec_invar G P R (it - {x}))\n 5. \\<And>\\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P;\n        find_path1_tailrec_invar G P R {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)\n 6. \\<And>it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; it \\<noteq> {};\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        \\<not> is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)", "using I"], ["proof (prove)\nusing this:\n  restr_invar (g_E G) R P\n\ngoal (6 subgoals):\n 1. fb_graph G \\<and> restr_invar (g_E G) R P \\<Longrightarrow>\n    find_path1_tailrec_invar G P R (g_V0 G) (Inl R)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> fb_graph (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> restr_invar\n                          (g_E (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>))\n                          (projl \\<sigma>) P\n 4. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>;\n        fb_graph (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) \\<and>\n        restr_invar (g_E (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>))\n         (projl \\<sigma>) P;\n        find_path0_restr_pred (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) P\n         (projl \\<sigma>) xa\\<rbrakk>\n       \\<Longrightarrow> (case xa of Inl x \\<Rightarrow> RETURN xa\n                          | Inr (vs, v) \\<Rightarrow>\n                              RETURN (Inr (x # vs, v)))\n                         \\<le> SPEC\n                                (find_path1_tailrec_invar G P R (it - {x}))\n 5. \\<And>\\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P;\n        find_path1_tailrec_invar G P R {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)\n 6. \\<And>it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; it \\<noteq> {};\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        \\<not> is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)", "apply (auto simp add: find_path1_tailrec_invar_def restr_invar_def) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> fb_graph (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> restr_invar\n                          (g_E (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>))\n                          (projl \\<sigma>) P\n 3. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>;\n        fb_graph (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) \\<and>\n        restr_invar (g_E (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>))\n         (projl \\<sigma>) P;\n        find_path0_restr_pred (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) P\n         (projl \\<sigma>) xa\\<rbrakk>\n       \\<Longrightarrow> (case xa of Inl x \\<Rightarrow> RETURN xa\n                          | Inr (vs, v) \\<Rightarrow>\n                              RETURN (Inr (x # vs, v)))\n                         \\<le> SPEC\n                                (find_path1_tailrec_invar G P R (it - {x}))\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P;\n        find_path1_tailrec_invar G P R {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)\n 5. \\<And>it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; it \\<noteq> {};\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        \\<not> is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)", "apply (blast intro: aux2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> restr_invar\n                          (g_E (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>))\n                          (projl \\<sigma>) P\n 2. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>;\n        fb_graph (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) \\<and>\n        restr_invar (g_E (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>))\n         (projl \\<sigma>) P;\n        find_path0_restr_pred (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) P\n         (projl \\<sigma>) xa\\<rbrakk>\n       \\<Longrightarrow> (case xa of Inl x \\<Rightarrow> RETURN xa\n                          | Inr (vs, v) \\<Rightarrow>\n                              RETURN (Inr (x # vs, v)))\n                         \\<le> SPEC\n                                (find_path1_tailrec_invar G P R (it - {x}))\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P;\n        find_path1_tailrec_invar G P R {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)\n 4. \\<And>it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; it \\<noteq> {};\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        \\<not> is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)", "apply (auto simp add: find_path1_tailrec_invar_def split: sum.splits) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; x \\<in> it;\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        is_Inl \\<sigma>; is_Inl \\<sigma>;\n        fb_graph (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) \\<and>\n        restr_invar (g_E (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>))\n         (projl \\<sigma>) P;\n        find_path0_restr_pred (G\\<lparr>g_V0 := g_E G `` {x}\\<rparr>) P\n         (projl \\<sigma>) xa\\<rbrakk>\n       \\<Longrightarrow> (case xa of Inl x \\<Rightarrow> RETURN xa\n                          | Inr (vs, v) \\<Rightarrow>\n                              RETURN (Inr (x # vs, v)))\n                         \\<le> SPEC\n                                (find_path1_tailrec_invar G P R (it - {x}))\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P;\n        find_path1_tailrec_invar G P R {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)\n 3. \\<And>it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; it \\<noteq> {};\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        \\<not> is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)", "apply (auto \n      simp: find_path0_restr_pred_def aux4 aux5\n      simp: trancl_Image_unfold_left[symmetric]\n      split: sum.splits) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P;\n        find_path1_tailrec_invar G P R {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)\n 2. \\<And>it \\<sigma>.\n       \\<lbrakk>fb_graph G \\<and> restr_invar (g_E G) R P; it \\<noteq> {};\n        it \\<subseteq> g_V0 G; find_path1_tailrec_invar G P R it \\<sigma>;\n        \\<not> is_Inl \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         Inl R' \\<Rightarrow>\n                           R' = R \\<union> (g_E G)\\<^sup>+ `` g_V0 G \\<and>\n                           restr_invar (g_E G) R' P\n                         | Inr (vs, v) \\<Rightarrow>\n                             P v \\<and>\n                             vs \\<noteq> [] \\<and>\n                             (\\<exists>v0\\<in>g_V0 G.\n                                 path (g_E G \\<inter> UNIV \\<times> - R) v0\n                                  vs v)", "apply (auto simp add: find_path1_tailrec_invar_def split: sum.splits) [2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  find_path1_restr G P R \\<le> find_path1_restr_spec G P R\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"find_path1_pred G P \\<equiv> \\<lambda>r. \n      case r of \n        None \\<Rightarrow> (g_E G)\\<^sup>+ `` g_V0 G \\<inter> Collect P = {}\n      | Some (vs, v) \\<Rightarrow> P v \\<and> vs \\<noteq> [] \\<and> (\\<exists> v0 \\<in> g_V0 G. path (g_E G) v0 vs v)\""], ["", "definition find_path1_spec \n  \\<comment> \\<open>Find a path of length at least one to a target node that satisfies \n      a given predicate.\\<close>\n  where \"find_path1_spec G P \\<equiv> do {\n    ASSERT (fb_graph G);\n    SPEC (find_path1_pred G P)}\""], ["", "lemmas find_path1_spec_rule[refine_vcg] = \n  ASSERT_le_defI[OF find_path1_spec_def]\n  ASSERT_leof_defI[OF find_path1_spec_def]"], ["", "subsection \\<open>Path of Minimal Length One, without Restriction\\<close>"], ["", "definition find_path1 \n  :: \"('v, 'more) graph_rec_scheme \\<Rightarrow> ('v \\<Rightarrow> bool) \\<Rightarrow> 'v fp_result nres\"\n  where \"find_path1 G P \\<equiv> do {\n  r \\<leftarrow> find_path1_restr_spec G P {};\n  case r of \n    Inl _ \\<Rightarrow> RETURN None\n  | Inr vsv \\<Rightarrow> RETURN (Some vsv)\n}\""], ["", "lemma find_path1_correct: \n  shows \"find_path1 G P \\<le> find_path1_spec G P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path1 G P \\<le> find_path1_spec G P", "unfolding find_path1_def find_path1_spec_def find_path1_pred_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path1_restr_spec G P {} \\<bind>\n    (\\<lambda>r.\n        case r of Inl x \\<Rightarrow> RETURN None\n        | Inr vsv \\<Rightarrow> RETURN (Some vsv))\n    \\<le> ASSERT (fb_graph G) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>r.\n                   case r of\n                   None \\<Rightarrow>\n                     (g_E G)\\<^sup>+ `` g_V0 G \\<inter> Collect P = {}\n                   | Some (vs, v) \\<Rightarrow>\n                       P v \\<and>\n                       vs \\<noteq> [] \\<and>\n                       (\\<exists>v0\\<in>g_V0 G. path (g_E G) v0 vs v)))", "apply (refine_rcg refine_vcg le_ASSERTI order_trans[OF find_path1_restr_correct])"], ["proof (prove)\ngoal (2 subgoals):\n 1. fb_graph G \\<Longrightarrow> restr_invar (g_E G) {} P\n 2. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G \\<and> restr_invar (g_E G) {} P;\n        find_path1_restr_pred G P {} x\\<rbrakk>\n       \\<Longrightarrow> (case x of Inl x \\<Rightarrow> RETURN None\n                          | Inr vsv \\<Rightarrow> RETURN (Some vsv))\n                         \\<le> SPEC\n                                (\\<lambda>r.\n                                    case r of\n                                    None \\<Rightarrow>\n(g_E G)\\<^sup>+ `` g_V0 G \\<inter> Collect P = {}\n                                    | Some (vs, v) \\<Rightarrow>\n  P v \\<and>\n  vs \\<noteq> [] \\<and> (\\<exists>v0\\<in>g_V0 G. path (g_E G) v0 vs v))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fb_graph G; fb_graph G \\<and> restr_invar (g_E G) {} P;\n        find_path1_restr_pred G P {} x\\<rbrakk>\n       \\<Longrightarrow> (case x of Inl x \\<Rightarrow> RETURN None\n                          | Inr vsv \\<Rightarrow> RETURN (Some vsv))\n                         \\<le> SPEC\n                                (\\<lambda>r.\n                                    case r of\n                                    None \\<Rightarrow>\n(g_E G)\\<^sup>+ `` g_V0 G \\<inter> Collect P = {}\n                                    | Some (vs, v) \\<Rightarrow>\n  P v \\<and>\n  vs \\<noteq> [] \\<and> (\\<exists>v0\\<in>g_V0 G. path (g_E G) v0 vs v))", "apply (fastforce \n    simp: find_path1_restr_spec_def find_path1_restr_pred_def\n    split: sum.splits \n    dest!: restr_invar_imp_not_reachable tranclD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Implementation\\<close>"], ["", "(* Implementation with stack *)"], ["", "record 'v fp0_state_impl = \"'v simple_state\" +\n  ppath :: \"('v list \\<times> 'v) option\""], ["", "definition \"fp0_erel \\<equiv> { \n  (\\<lparr> fp0_state_impl.ppath = p \\<rparr>, \\<lparr> fp0_state.ppath = p\\<rparr>) | p. True }\""], ["", "abbreviation \"fp0_rel R \\<equiv> \\<langle>fp0_erel\\<rangle>restr_simple_state_rel R\""], ["", "abbreviation \"no_path_impl \\<equiv> \\<lparr> fp0_state_impl.ppath = None \\<rparr>\""], ["", "abbreviation \"a_path_impl p v \\<equiv> \\<lparr> fp0_state_impl.ppath = Some (p,v) \\<rparr>\""], ["", "lemma fp0_rel_ppath_cong[simp]: \n  \"(s,s')\\<in>fp0_rel R \\<Longrightarrow> fp0_state_impl.ppath s = fp0_state.ppath s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s') \\<in> fp0_rel R \\<Longrightarrow>\n    fp0_state_impl.ppath s = fp0_state.ppath s'", "unfolding restr_simple_state_rel_def fp0_erel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s')\n    \\<in> {(s, s').\n           (ss_stack s, map (\\<lambda>u. (u, pending s' `` {u})) (stack s'))\n           \\<in> \\<langle>Id \\<times>\\<^sub>r\n                          {(U, U'). U - R = U'}\\<rangle>list_rel \\<and>\n           on_stack s = set (stack s') \\<and>\n           visited s = dom (discovered s') \\<union> R \\<and>\n           dom (discovered s') \\<inter> R = {} \\<and>\n           dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n           set (stack s') \\<subseteq> dom (discovered s') \\<and>\n           (simple_state.more s, state.more s')\n           \\<in> {(\\<lparr>fp0_state_impl.ppath = p\\<rparr>,\n                   \\<lparr>fp0_state.ppath = p\\<rparr>) |\n                  p. True}} \\<Longrightarrow>\n    fp0_state_impl.ppath s = fp0_state.ppath s'", "by (cases s, cases s', auto)"], ["", "lemma fp0_ss_rel_ppath_cong[simp]: \n  \"(s,s')\\<in>\\<langle>fp0_erel\\<rangle>simple_state_rel \\<Longrightarrow> fp0_state_impl.ppath s = fp0_state.ppath s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s')\n    \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel \\<Longrightarrow>\n    fp0_state_impl.ppath s = fp0_state.ppath s'", "unfolding simple_state_rel_def fp0_erel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s')\n    \\<in> {(s, s').\n           ss_stack s =\n           map (\\<lambda>u. (u, pending s' `` {u})) (stack s') \\<and>\n           on_stack s = set (stack s') \\<and>\n           visited s = dom (discovered s') \\<and>\n           dom (finished s') = dom (discovered s') - set (stack s') \\<and>\n           set (stack s') \\<subseteq> dom (discovered s') \\<and>\n           (simple_state.more s, state.more s')\n           \\<in> {(\\<lparr>fp0_state_impl.ppath = p\\<rparr>,\n                   \\<lparr>fp0_state.ppath = p\\<rparr>) |\n                  p. True}} \\<Longrightarrow>\n    fp0_state_impl.ppath s = fp0_state.ppath s'", "by (cases s, cases s', auto)"], ["", "lemma fp0i_cong[cong]: \"simple_state.more s = simple_state.more s' \n  \\<Longrightarrow> fp0_state_impl.ppath s = fp0_state_impl.ppath s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_state.more s = simple_state.more s' \\<Longrightarrow>\n    fp0_state_impl.ppath s = fp0_state_impl.ppath s'", "by (cases s, cases s', auto)"], ["", "lemma fp0_erelI: \"p=p' \n  \\<Longrightarrow> (\\<lparr> fp0_state_impl.ppath = p \\<rparr>, \\<lparr> fp0_state.ppath = p'\\<rparr>)\\<in>fp0_erel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p' \\<Longrightarrow>\n    (\\<lparr>fp0_state_impl.ppath = p\\<rparr>,\n     \\<lparr>fp0_state.ppath = p'\\<rparr>)\n    \\<in> fp0_erel", "unfolding fp0_erel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p' \\<Longrightarrow>\n    (\\<lparr>fp0_state_impl.ppath = p\\<rparr>,\n     \\<lparr>fp0_state.ppath = p'\\<rparr>)\n    \\<in> {(\\<lparr>fp0_state_impl.ppath = p\\<rparr>,\n            \\<lparr>fp0_state.ppath = p\\<rparr>) |\n           p. True}", "by auto"], ["", "definition fp0_params_impl \n  :: \"_ \\<Rightarrow> ('v,'v fp0_state_impl,('v,unit)fp0_state_impl_ext) gen_parameterization\"\nwhere \"fp0_params_impl P \\<equiv> \\<lparr>\n  on_init = RETURN no_path_impl,\n  on_new_root = \\<lambda>v0 s. \n    if P v0 then RETURN (a_path_impl [] v0) else RETURN no_path_impl,\n  on_discover = \\<lambda>u v s. \n    if P v then RETURN (a_path_impl (map fst (rev (tl (CAST (ss_stack s))))) v)\n    else RETURN no_path_impl,\n  on_finish = \\<lambda>u s. RETURN (simple_state.more s),\n  on_back_edge = \\<lambda>u v s. RETURN (simple_state.more s),\n  on_cross_edge = \\<lambda>u v s. RETURN (simple_state.more s),\n  is_break = \\<lambda>s. ppath s \\<noteq> None \\<rparr>\""], ["", "lemmas fp0_params_impl_simp[simp, DFS_code_unfold] \n  = gen_parameterization.simps[mk_record_simp, OF fp0_params_impl_def]"], ["", "interpretation fp0_impl:\n  restricted_impl_defs \"fp0_params_impl P\" \"fp0_params P\" G R \n  for G P R"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "locale fp0_restr = fb_graph\nbegin"], ["", "sublocale fp0?: fp0 \"graph_restrict G R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fp0 (graph_restrict G R)", "apply (rule fp0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph (graph_restrict G R)", "apply (rule fb_graph_restrict)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sublocale impl: restricted_impl G \"fp0_params P\" \"fp0_params_impl P\" \n    fp0_erel R"], ["proof (prove)\ngoal (1 subgoal):\n 1. restricted_impl G (fp0_params P) (fp0_params_impl P) fp0_erel R", "apply unfold_locales"], ["proof (prove)\ngoal (14 subgoals):\n 1. (simple_state.more_update, state.more_update)\n    \\<in> (fp0_erel \\<rightarrow> fp0_erel) \\<rightarrow>\n          \\<langle>fp0_erel\\<rangle>simple_state_rel \\<rightarrow>\n          \\<langle>fp0_erel\\<rangle>simple_state_rel\n 2. on_init (fp0_params_impl P)\n    \\<le> \\<Down> fp0_erel (on_init (fp0_params P))\n 3. (is_break (fp0_params_impl P), is_break (fp0_params P))\n    \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 4. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_new_root\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) v0 s;\n        (v0i, v0) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_new_root (param_DFS_defs.gbs (graph_restrict G R)) v0 s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params_impl P) v0i si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_new_root (fp0_params P) v0 s')\n 5. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_finish\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) v s0 s;\n        (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres (gbs_finish (param_DFS_defs.gbs (graph_restrict G R)) v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params_impl P) vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_finish (fp0_params P) v s')\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_cross_edge\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_cross_edge (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_cross_edge (fp0_params P) u v s')\n 7. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_back_edge\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_back_edge (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_back_edge (fp0_params P) u v s')\n 8. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_discover\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_discover (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_discover (fp0_params P) u v s')\n 9. on_cross_edge (fp0_params_impl P) =\n    (\\<lambda>u v s. RETURN (simple_state.more s))\n 10. on_back_edge (fp0_params_impl P) =\n     (\\<lambda>u v s. RETURN (simple_state.more s))\nA total of 14 subgoals...", "apply parametricity"], ["proof (prove)\ngoal (13 subgoals):\n 1. on_init (fp0_params_impl P)\n    \\<le> \\<Down> fp0_erel (on_init (fp0_params P))\n 2. (is_break (fp0_params_impl P), is_break (fp0_params P))\n    \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 3. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_new_root\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) v0 s;\n        (v0i, v0) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_new_root (param_DFS_defs.gbs (graph_restrict G R)) v0 s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params_impl P) v0i si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_new_root (fp0_params P) v0 s')\n 4. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_finish\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) v s0 s;\n        (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres (gbs_finish (param_DFS_defs.gbs (graph_restrict G R)) v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params_impl P) vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_finish (fp0_params P) v s')\n 5. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_cross_edge\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_cross_edge (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_cross_edge (fp0_params P) u v s')\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_back_edge\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_back_edge (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_back_edge (fp0_params P) u v s')\n 7. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_discover\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_discover (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_discover (fp0_params P) u v s')\n 8. on_cross_edge (fp0_params_impl P) =\n    (\\<lambda>u v s. RETURN (simple_state.more s))\n 9. on_back_edge (fp0_params_impl P) =\n    (\\<lambda>u v s. RETURN (simple_state.more s))\n 10. \\<And>s s'.\n        (s, s') \\<in> fp0_impl.rel R \\<Longrightarrow>\n        is_break (fp0_params_impl P) s = is_break (fp0_params_impl P) s'\nA total of 13 subgoals...", "apply (simp add: fp0_erel_def)"], ["proof (prove)\ngoal (12 subgoals):\n 1. (is_break (fp0_params_impl P), is_break (fp0_params P))\n    \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel \\<rightarrow> bool_rel\n 2. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_new_root\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) v0 s;\n        (v0i, v0) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_new_root (param_DFS_defs.gbs (graph_restrict G R)) v0 s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params_impl P) v0i si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_new_root (fp0_params P) v0 s')\n 3. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_finish\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) v s0 s;\n        (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres (gbs_finish (param_DFS_defs.gbs (graph_restrict G R)) v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params_impl P) vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_finish (fp0_params P) v s')\n 4. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_cross_edge\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_cross_edge (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_cross_edge (fp0_params P) u v s')\n 5. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_back_edge\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_back_edge (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_back_edge (fp0_params P) u v s')\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_discover\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_discover (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_discover (fp0_params P) u v s')\n 7. on_cross_edge (fp0_params_impl P) =\n    (\\<lambda>u v s. RETURN (simple_state.more s))\n 8. on_back_edge (fp0_params_impl P) =\n    (\\<lambda>u v s. RETURN (simple_state.more s))\n 9. \\<And>s s'.\n       (s, s') \\<in> fp0_impl.rel R \\<Longrightarrow>\n       is_break (fp0_params_impl P) s = is_break (fp0_params_impl P) s'\n 10. \\<And>s s' v0.\n        (s, s') \\<in> fp0_impl.rel R \\<Longrightarrow>\n        on_new_root (fp0_params_impl P) v0 s\n        \\<le> on_new_root (fp0_params_impl P) v0 s'\nA total of 12 subgoals...", "apply (auto) [1]"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_new_root\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) v0 s;\n        (v0i, v0) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_new_root (param_DFS_defs.gbs (graph_restrict G R)) v0 s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root (fp0_params_impl P) v0i si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_new_root (fp0_params P) v0 s')\n 2. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_finish\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) v s0 s;\n        (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres (gbs_finish (param_DFS_defs.gbs (graph_restrict G R)) v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_finish (fp0_params_impl P) vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_finish (fp0_params P) v s')\n 3. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_cross_edge\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_cross_edge (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_cross_edge (fp0_params P) u v s')\n 4. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_back_edge\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_back_edge (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_back_edge (fp0_params P) u v s')\n 5. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs_defs.pre_discover\n                 (gen_param_dfs_defs.gds\n                   (param_DFS_defs.gbs (graph_restrict G R)) (fp0_params P)\n                   state.more_update)\n                 (g_V0 (graph_restrict G R)) u v s0 s;\n        (ui, u) \\<in> Id; (vi, v) \\<in> Id;\n        (si, s) \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        (si', s') \\<in> \\<langle>fp0_erel\\<rangle>simple_state_rel;\n        nf_inres\n         (gbs_discover (param_DFS_defs.gbs (graph_restrict G R)) u v s)\n         s'\\<rbrakk>\n       \\<Longrightarrow> on_discover (fp0_params_impl P) ui vi si'\n                         \\<le> \\<Down> fp0_erel\n                                (on_discover (fp0_params P) u v s')\n 6. on_cross_edge (fp0_params_impl P) =\n    (\\<lambda>u v s. RETURN (simple_state.more s))\n 7. on_back_edge (fp0_params_impl P) =\n    (\\<lambda>u v s. RETURN (simple_state.more s))\n 8. \\<And>s s'.\n       (s, s') \\<in> fp0_impl.rel R \\<Longrightarrow>\n       is_break (fp0_params_impl P) s = is_break (fp0_params_impl P) s'\n 9. \\<And>s s' v0.\n       (s, s') \\<in> fp0_impl.rel R \\<Longrightarrow>\n       on_new_root (fp0_params_impl P) v0 s\n       \\<le> on_new_root (fp0_params_impl P) v0 s'\n 10. \\<And>s s' u.\n        (s, s') \\<in> fp0_impl.rel R \\<Longrightarrow>\n        on_finish (fp0_params_impl P) u s\n        \\<le> on_finish (fp0_params_impl P) u s'\nA total of 11 subgoals...", "apply (auto\n        simp: rev_map[symmetric] map_tl comp_def\n        simp: fp0_erel_def simple_state_rel_def) [7]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       (s, s') \\<in> fp0_impl.rel R \\<Longrightarrow>\n       is_break (fp0_params_impl P) s = is_break (fp0_params_impl P) s'\n 2. \\<And>s s' v0.\n       (s, s') \\<in> fp0_impl.rel R \\<Longrightarrow>\n       on_new_root (fp0_params_impl P) v0 s\n       \\<le> on_new_root (fp0_params_impl P) v0 s'\n 3. \\<And>s s' u.\n       (s, s') \\<in> fp0_impl.rel R \\<Longrightarrow>\n       on_finish (fp0_params_impl P) u s\n       \\<le> on_finish (fp0_params_impl P) u s'\n 4. \\<And>s s' u v.\n       (s, s') \\<in> fp0_impl.rel R \\<Longrightarrow>\n       on_discover (fp0_params_impl P) u v s\n       \\<le> on_discover (fp0_params_impl P) u v s'", "apply (auto simp: restr_rel_def) [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' u v.\n       (s, s') \\<in> fp0_impl.rel R \\<Longrightarrow>\n       on_discover (fp0_params_impl P) u v s\n       \\<le> on_discover (fp0_params_impl P) u v s'", "apply (clarsimp simp: restr_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' v.\n       \\<lbrakk>(ss_stack s, ss_stack s')\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, y). U - R = y}\\<rangle>list_rel;\n        on_stack s = on_stack s'; visited s = visited s' \\<union> R;\n        visited s' \\<inter> R = {};\n        simple_state.more s = simple_state.more s'; P v\\<rbrakk>\n       \\<Longrightarrow> map fst (rev (tl (ss_stack s))) =\n                         map fst (rev (tl (ss_stack s')))", "apply (rule IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' v.\n       \\<lbrakk>(ss_stack s, ss_stack s')\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, y). U - R = y}\\<rangle>list_rel;\n        on_stack s = on_stack s'; visited s = visited s' \\<union> R;\n        visited s' \\<inter> R = {};\n        simple_state.more s = simple_state.more s'; P v\\<rbrakk>\n       \\<Longrightarrow> (map fst (rev (tl (ss_stack s))),\n                          map fst (rev (tl (ss_stack s'))))\n                         \\<in> Id", "apply (subst list_rel_id_simp[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' v.\n       \\<lbrakk>(ss_stack s, ss_stack s')\n                \\<in> \\<langle>Id \\<times>\\<^sub>r\n                               {(U, y). U - R = y}\\<rangle>list_rel;\n        on_stack s = on_stack s'; visited s = visited s' \\<union> R;\n        visited s' \\<inter> R = {};\n        simple_state.more s = simple_state.more s'; P v\\<rbrakk>\n       \\<Longrightarrow> (map fst (rev (tl (ss_stack s))),\n                          map fst (rev (tl (ss_stack s'))))\n                         \\<in> \\<langle>Id\\<rangle>list_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition \"find_path0_restr_impl G P R \\<equiv> do {\n  ASSERT (fb_graph G);\n  ASSERT (fp0 (graph_restrict G R));\n  s \\<leftarrow> fp0_impl.tailrec_impl TYPE('a) G R P;\n  case ppath s of\n    None \\<Rightarrow> RETURN (Inl (visited s))\n  | Some (vs,v) \\<Rightarrow> RETURN (Inr (vs,v))\n}\""], ["", "lemma find_path0_restr_impl[refine]:\n  shows \"find_path0_restr_impl G P R \n     \\<le> \\<Down>(\\<langle>Id,Id\\<times>\\<^sub>rId\\<rangle>sum_rel) \n   (find_path0_restr G P R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path0_restr_impl G P R\n    \\<le> \\<Down> (\\<langle>Id, Id \\<times>\\<^sub>r Id\\<rangle>sum_rel)\n           (find_path0_restr G P R)", "proof (rule refine_ASSERT_defI2[OF find_path0_restr_def])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; fp0 (graph_restrict G R)\\<rbrakk>\n    \\<Longrightarrow> find_path0_restr_impl G P R\n                      \\<le> \\<Down>\n                             (\\<langle>Id,\n                              Id \\<times>\\<^sub>r Id\\<rangle>sum_rel)\n                             (find_path0_restr G P R)", "assume \"fb_graph G\""], ["proof (state)\nthis:\n  fb_graph G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; fp0 (graph_restrict G R)\\<rbrakk>\n    \\<Longrightarrow> find_path0_restr_impl G P R\n                      \\<le> \\<Down>\n                             (\\<langle>Id,\n                              Id \\<times>\\<^sub>r Id\\<rangle>sum_rel)\n                             (find_path0_restr G P R)", "then"], ["proof (chain)\npicking this:\n  fb_graph G", "interpret fb_graph G"], ["proof (prove)\nusing this:\n  fb_graph G\n\ngoal (1 subgoal):\n 1. fb_graph G", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; fp0 (graph_restrict G R)\\<rbrakk>\n    \\<Longrightarrow> find_path0_restr_impl G P R\n                      \\<le> \\<Down>\n                             (\\<langle>Id,\n                              Id \\<times>\\<^sub>r Id\\<rangle>sum_rel)\n                             (find_path0_restr G P R)", "interpret fp0_restr G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fp0_restr G", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fb_graph G; fp0 (graph_restrict G R)\\<rbrakk>\n    \\<Longrightarrow> find_path0_restr_impl G P R\n                      \\<le> \\<Down>\n                             (\\<langle>Id,\n                              Id \\<times>\\<^sub>r Id\\<rangle>sum_rel)\n                             (find_path0_restr G P R)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path0_restr_impl G P R\n    \\<le> \\<Down> (\\<langle>Id, Id \\<times>\\<^sub>r Id\\<rangle>sum_rel)\n           (find_path0_restr G P R)", "unfolding find_path0_restr_impl_def find_path0_restr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fb_graph G) \\<bind>\n    (\\<lambda>_.\n        ASSERT (fp0 (graph_restrict G R)) \\<bind>\n        (\\<lambda>_.\n            tailrec_impl_defs.tailrec_impl G\n             (gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G R)\n               (fp0_params_impl P) simple_state.more_update) \\<bind>\n            (\\<lambda>s.\n                case fp0_state_impl.ppath s of\n                None \\<Rightarrow> RETURN (Inl (visited s))\n                | Some (vs, v) \\<Rightarrow> RETURN (Inr (vs, v)))))\n    \\<le> \\<Down> (\\<langle>Id, Id \\<times>\\<^sub>r Id\\<rangle>sum_rel)\n           (ASSERT (fb_graph G) \\<bind>\n            (\\<lambda>_.\n                ASSERT (fp0 (graph_restrict G R)) \\<bind>\n                (\\<lambda>_.\n                    param_DFS_defs.it_dfs (graph_restrict G R)\n                     (fp0_params P) \\<bind>\n                    (\\<lambda>s.\n                        case fp0_state.ppath s of\n                        None \\<Rightarrow>\n                          ASSERT\n                           (dom (discovered s) = dom (finished s)) \\<bind>\n                          (\\<lambda>_.\n                              RETURN (Inl (R \\<union> dom (finished s))))\n                        | Some (vs, v) \\<Rightarrow>\n                            RETURN (Inr (vs, v))))))", "apply (refine_rcg impl.tailrec_refine)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s sa.\n       \\<lbrakk>fb_graph G; fp0 (graph_restrict G R); fb_graph G;\n        fp0 (graph_restrict G R); (s, sa) \\<in> fp0_rel R\\<rbrakk>\n       \\<Longrightarrow> (fp0_state_impl.ppath s, fp0_state.ppath sa)\n                         \\<in> \\<langle>?Ra6 s sa\\<rangle>option_rel\n 2. \\<And>s sa.\n       \\<lbrakk>fb_graph G; fp0 (graph_restrict G R); fb_graph G;\n        fp0 (graph_restrict G R); (s, sa) \\<in> fp0_rel R;\n        fp0_state_impl.ppath s = None; fp0_state.ppath sa = None;\n        dom (discovered sa) = dom (finished sa)\\<rbrakk>\n       \\<Longrightarrow> (Inl (visited s),\n                          Inl (R \\<union> dom (finished sa)))\n                         \\<in> \\<langle>Id,\n                         Id \\<times>\\<^sub>r Id\\<rangle>sum_rel\n 3. \\<And>s sa x x' x1 x2 x1a x2a.\n       \\<lbrakk>fb_graph G; fp0 (graph_restrict G R); fb_graph G;\n        fp0 (graph_restrict G R); (s, sa) \\<in> fp0_rel R;\n        fp0_state_impl.ppath s = Some x; fp0_state.ppath sa = Some x';\n        (x, x') \\<in> ?Ra6 s sa; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (Inr (x1a, x2a), Inr (x1, x2)) \\<in> \\<langle>Id,\n                         Id \\<times>\\<^sub>r Id\\<rangle>sum_rel", "apply refine_dref_type"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s sa.\n       \\<lbrakk>fb_graph G; fp0 (graph_restrict G R); fb_graph G;\n        fp0 (graph_restrict G R); (s, sa) \\<in> fp0_rel R\\<rbrakk>\n       \\<Longrightarrow> (fp0_state_impl.ppath s, fp0_state.ppath sa)\n                         \\<in> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n  Id\\<rangle>option_rel\n 2. \\<And>s sa.\n       \\<lbrakk>fb_graph G; fp0 (graph_restrict G R); fb_graph G;\n        fp0 (graph_restrict G R); (s, sa) \\<in> fp0_rel R;\n        fp0_state_impl.ppath s = None; fp0_state.ppath sa = None;\n        dom (discovered sa) = dom (finished sa)\\<rbrakk>\n       \\<Longrightarrow> (Inl (visited s),\n                          Inl (R \\<union> dom (finished sa)))\n                         \\<in> \\<langle>Id,\n                         Id \\<times>\\<^sub>r Id\\<rangle>sum_rel\n 3. \\<And>s sa x x' x1 x2 x1a x2a.\n       \\<lbrakk>fb_graph G; fp0 (graph_restrict G R); fb_graph G;\n        fp0 (graph_restrict G R); (s, sa) \\<in> fp0_rel R;\n        fp0_state_impl.ppath s = Some x; fp0_state.ppath sa = Some x';\n        (x, x') \\<in> \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (Inr (x1a, x2a), Inr (x1, x2)) \\<in> \\<langle>Id,\n                         Id \\<times>\\<^sub>r Id\\<rangle>sum_rel", "apply (auto simp: restr_simple_state_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  find_path0_restr_impl G P R\n  \\<le> \\<Down> (\\<langle>Id, Id \\<times>\\<^sub>r Id\\<rangle>sum_rel)\n         (find_path0_restr G P R)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"find_path0_impl G P \\<equiv> do {\n  ASSERT (fp0 G);\n  s \\<leftarrow> fp0_impl.tailrec_impl TYPE('a) G {} P;\n  RETURN (ppath s)\n}\""], ["", "lemma find_path0_impl[refine]: \"find_path0_impl G P \n  \\<le> \\<Down> (\\<langle>Id\\<times>\\<^sub>rId\\<rangle>option_rel) (find_path0 G P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path0_impl G P\n    \\<le> \\<Down> (\\<langle>Id \\<times>\\<^sub>r Id\\<rangle>option_rel)\n           (find_path0 G P)", "proof (rule refine_ASSERT_defI1[OF find_path0_def])"], ["proof (state)\ngoal (1 subgoal):\n 1. fp0 G \\<Longrightarrow>\n    find_path0_impl G P\n    \\<le> \\<Down> (\\<langle>Id \\<times>\\<^sub>r Id\\<rangle>option_rel)\n           (find_path0 G P)", "assume \"fp0 G\""], ["proof (state)\nthis:\n  fp0 G\n\ngoal (1 subgoal):\n 1. fp0 G \\<Longrightarrow>\n    find_path0_impl G P\n    \\<le> \\<Down> (\\<langle>Id \\<times>\\<^sub>r Id\\<rangle>option_rel)\n           (find_path0 G P)", "then"], ["proof (chain)\npicking this:\n  fp0 G", "interpret fp0 G"], ["proof (prove)\nusing this:\n  fp0 G\n\ngoal (1 subgoal):\n 1. fp0 G", "."], ["proof (state)\ngoal (1 subgoal):\n 1. fp0 G \\<Longrightarrow>\n    find_path0_impl G P\n    \\<le> \\<Down> (\\<langle>Id \\<times>\\<^sub>r Id\\<rangle>option_rel)\n           (find_path0 G P)", "interpret r: fp0_restr G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fp0_restr G", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. fp0 G \\<Longrightarrow>\n    find_path0_impl G P\n    \\<le> \\<Down> (\\<langle>Id \\<times>\\<^sub>r Id\\<rangle>option_rel)\n           (find_path0 G P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path0_impl G P\n    \\<le> \\<Down> (\\<langle>Id \\<times>\\<^sub>r Id\\<rangle>option_rel)\n           (find_path0 G P)", "unfolding find_path0_impl_def find_path0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (fp0 G) \\<bind>\n    (\\<lambda>_.\n        tailrec_impl_defs.tailrec_impl G\n         (gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {})\n           (fp0_params_impl P) simple_state.more_update) \\<bind>\n        (\\<lambda>s. RETURN (fp0_state_impl.ppath s)))\n    \\<le> \\<Down> (\\<langle>Id \\<times>\\<^sub>r Id\\<rangle>option_rel)\n           (ASSERT (fp0 G) \\<bind>\n            (\\<lambda>_.\n                param_DFS_defs.it_dfs G (fp0_params P) \\<bind>\n                (\\<lambda>s. RETURN (fp0_state.ppath s))))", "apply (refine_rcg r.impl.tailrec_refine[where R=\"{}\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s sa.\n       \\<lbrakk>fp0 G; fp0 G; (s, sa) \\<in> fp0_rel {}\\<rbrakk>\n       \\<Longrightarrow> (fp0_state_impl.ppath s, fp0_state.ppath sa)\n                         \\<in> \\<langle>Id \\<times>\\<^sub>r\n  Id\\<rangle>option_rel", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  find_path0_impl G P\n  \\<le> \\<Down> (\\<langle>Id \\<times>\\<^sub>r Id\\<rangle>option_rel)\n         (find_path0 G P)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Synthesis of Executable Code\\<close>"], ["", "(* Autoref *)"], ["", "record ('v,'si,'nsi)fp0_state_impl' = \"('si,'nsi)simple_state_nos_impl\" +\n  ppath_impl :: \"('v list \\<times> 'v) option\""], ["", "definition [to_relAPP]: \"fp0_state_erel erel \\<equiv> {\n  (\\<lparr>ppath_impl = pi, \\<dots> =  mi\\<rparr>,\\<lparr>ppath = p, \\<dots> = m\\<rparr>) | pi mi p m.\n    (pi,p)\\<in>\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>option_rel \\<and> (mi,m)\\<in>erel}\""], ["", "consts \n  i_fp0_state_ext :: \"interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of fp0_state_erel i_fp0_state_ext]"], ["", "term fp0_state_impl_ext"], ["", "lemma [autoref_rules]:\n  fixes ns_rel vis_rel erel\n  defines \"R \\<equiv> \\<langle>ns_rel,vis_rel,\\<langle>erel\\<rangle>fp0_state_erel\\<rangle>ssnos_impl_rel\"\n  shows \n    \"(fp0_state_impl'_ext, fp0_state_impl_ext) \n      \\<in> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>option_rel \\<rightarrow> erel \\<rightarrow> \\<langle>erel\\<rangle>fp0_state_erel\"\n    \"(ppath_impl, fp0_state_impl.ppath) \\<in> R \\<rightarrow> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fp0_state_impl'_ext, fp0_state_impl_ext)\n    \\<in> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                   Id\\<rangle>option_rel \\<rightarrow>\n          erel \\<rightarrow> \\<langle>erel\\<rangle>fp0_state_erel &&&\n    (ppath_impl, fp0_state_impl.ppath)\n    \\<in> R \\<rightarrow>\n          \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                   Id\\<rangle>option_rel", "unfolding fp0_state_erel_def ssnos_impl_rel_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fp0_state_impl'_ext, fp0_state_impl_ext)\n    \\<in> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                   Id\\<rangle>option_rel \\<rightarrow>\n          erel \\<rightarrow>\n          {(\\<lparr>ppath_impl = pi, \\<dots> = mi\\<rparr>,\n            \\<lparr>fp0_state_impl.ppath = p, \\<dots> = m\\<rparr>) |\n           pi mi p m.\n           (pi, p)\n           \\<in> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                          Id\\<rangle>option_rel \\<and>\n           (mi, m) \\<in> erel} &&&\n    (ppath_impl, fp0_state_impl.ppath)\n    \\<in> {(\\<lparr>ssnos_stack_impl = si, ssnos_visited_impl = visi,\n               \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si visi mi s os vis m.\n           (si, s) \\<in> ns_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>ppath_impl = pi, \\<dots> = mi\\<rparr>,\n                   \\<lparr>fp0_state_impl.ppath = p, \\<dots> = m\\<rparr>) |\n                  pi mi p m.\n                  (pi, p)\n                  \\<in> \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                 Id\\<rangle>option_rel \\<and>\n                  (mi, m) \\<in> erel}} \\<rightarrow>\n          \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                   Id\\<rangle>option_rel", "by auto"], ["", "schematic_goal find_path0_code:\n  fixes G :: \"('v :: hashable, _) graph_rec_scheme\"\n  assumes [autoref_rules]:\n    \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n    \"(Pi, P) \\<in> Id \\<rightarrow> bool_rel\"\n  notes [autoref_tyrel] = TYRELI[where R=\"\\<langle>Id::('v\\<times>'v) set\\<rangle>dflt_ahs_rel\"]\n  shows \"(nres_of (?c::?'c dres), find_path0_impl G P) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c, find_path0_impl G P) \\<in> ?R", "unfolding find_path0_impl_def[abs_def] DFS_code_unfold ssnos_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     ASSERT (fp0 G) \\<bind>\n     (\\<lambda>_.\n         RETURN no_path_impl \\<bind>\n         (\\<lambda>e.\n             RETURN\n              \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                 \\<dots> = e\\<rparr>) \\<bind>\n         FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                                   rwof\n                                    (RETURN no_path_impl \\<bind>\n                                     (\\<lambda>e.\n   RETURN\n    \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n       \\<dots> = e\\<rparr>))\n                                    (gen_dfs_defs.gen_cond\n(gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {}) (fp0_params_impl P)\n  simple_state.more_update)\n(g_V0 G))\n                                    (gen_dfs_defs.gen_step\n(gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {}) (fp0_params_impl P)\n  simple_state.more_update)\n(g_V0 G))\n                                    s \\<and>\n                                   (\\<not> fp0_state_impl.ppath s \\<noteq>\n     None \\<longrightarrow>\n                                    ss_stack s = []) \\<and>\n                                   g_V0 G - it\n                                   \\<subseteq> {v.\n          v \\<in> visited s}\\<^esup>\n          (g_V0 G) (\\<lambda>x. \\<not> fp0_state_impl.ppath x \\<noteq> None)\n          (\\<lambda>v0 s.\n              let s0 = s\n              in if v0 \\<in> visited s then RETURN s\n                 else ASSERT (v0 \\<notin> visited s) \\<bind>\n                      (\\<lambda>_.\n                          let s = s\\<lparr>ss_stack :=\n       [(v0, g_E G `` {v0})]\\<rparr>;\n                              s = op_nos_on_stack_update (\\<lambda>_. {v0})\n                                   s\n                          in Let (s\\<lparr>visited :=\n       insert v0 (visited s)\\<rparr>)\n                              RETURN) \\<bind>\n                      (\\<lambda>s.\n                          (if P v0 then RETURN (a_path_impl [] v0)\n                           else RETURN no_path_impl) \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (s\\<lparr>simple_state.more :=\n     e\\<rparr>))) \\<bind>\n                      WHILE\\<^bsup>\\<lambda>s.\nrwof\n (RETURN no_path_impl \\<bind>\n  (\\<lambda>e.\n      RETURN\n       \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n          \\<dots> = e\\<rparr>))\n (gen_dfs_defs.gen_cond\n   (gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {})\n     (fp0_params_impl P) simple_state.more_update)\n   (g_V0 G))\n (gen_dfs_defs.gen_step\n   (gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {})\n     (fp0_params_impl P) simple_state.more_update)\n   (g_V0 G))\n s \\<and>\ninsert v0 {v. v \\<in> visited s0} \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                       (\\<lambda>s.\n                           \\<not> fp0_state_impl.ppath s \\<noteq>\n                                  None \\<and>\n                           ss_stack s \\<noteq> [])\n                       (\\<lambda>s.\n                           ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                           (\\<lambda>_.\n                               let (u, Vs) = hd (ss_stack s)\n                               in if Vs = {} then RETURN (u, None, s)\n                                  else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n (\\<lambda>v.\n     let Vs = Vs - {v};\n         s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n     in RETURN (u, Some v, s))) \\<bind>\n                           (\\<lambda>(u, Vs, s).\n                               case Vs of\n                               None \\<Rightarrow>\n                                 ASSERT\n                                  (ss_stack s \\<noteq> [] \\<and>\n                                   u \\<in> on_stack s) \\<bind>\n                                 (\\<lambda>_.\n                                     let s = s\n     \\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                                     in Let\n   (op_nos_on_stack_update (\\<lambda>_. on_stack s - {u}) s) RETURN) \\<bind>\n                                 (\\<lambda>s.\n                                     RETURN (simple_state.more s) \\<bind>\n                                     (\\<lambda>e.\n   RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                               | Some v \\<Rightarrow>\n                                   if v \\<in> visited s\n                                   then if v \\<in> visited s - on_stack s\n  then RETURN s \\<bind>\n       (\\<lambda>s.\n           RETURN (simple_state.more s) \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n  else RETURN s \\<bind>\n       (\\<lambda>s.\n           RETURN (simple_state.more s) \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                   else ASSERT\n   (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n  (\\<lambda>_.\n      let s = s\\<lparr>ss_stack := (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n          s = op_nos_on_stack_update (\\<lambda>_. insert v (on_stack s)) s\n      in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n          RETURN) \\<bind>\n  (\\<lambda>s.\n      (if P v\n       then RETURN (a_path_impl (map fst (rev (tl (CAST (ss_stack s))))) v)\n       else RETURN no_path_impl) \\<bind>\n      (\\<lambda>e.\n          RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n         (\\<lambda>s. RETURN (fp0_state_impl.ppath s))))\n    \\<in> ?R", "unfolding if_cancel not_not comp_def nres_monad_laws"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     ASSERT (fp0 G) \\<bind>\n     (\\<lambda>_.\n         FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                                   rwof\n                                    (RETURN\n\\<lparr>ss_stack = [], on_stack = {}, visited = {},\n   \\<dots> = no_path_impl\\<rparr>)\n                                    (gen_dfs_defs.gen_cond\n(gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {}) (fp0_params_impl P)\n  simple_state.more_update)\n(g_V0 G))\n                                    (gen_dfs_defs.gen_step\n(gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {}) (fp0_params_impl P)\n  simple_state.more_update)\n(g_V0 G))\n                                    s \\<and>\n                                   (fp0_state_impl.ppath s =\n                                    None \\<longrightarrow>\n                                    ss_stack s = []) \\<and>\n                                   g_V0 G - it\n                                   \\<subseteq> {v.\n          v \\<in> visited s}\\<^esup>\n          (g_V0 G) (\\<lambda>x. fp0_state_impl.ppath x = None)\n          (\\<lambda>v0 s.\n              let s0 = s\n              in if v0 \\<in> visited s then RETURN s\n                 else ASSERT (v0 \\<notin> visited s) \\<bind>\n                      (\\<lambda>x.\n                          (let s = s\\<lparr>ss_stack :=\n        [(v0, g_E G `` {v0})]\\<rparr>;\n                               s = op_nos_on_stack_update (\\<lambda>_. {v0})\n                                    s\n                           in Let (s\\<lparr>visited :=\n        insert v0 (visited s)\\<rparr>)\n                               RETURN) \\<bind>\n                          (\\<lambda>x.\n                              (if P v0 then RETURN (a_path_impl [] v0)\n                               else RETURN no_path_impl) \\<bind>\n                              (\\<lambda>xa.\n                                  WHILE\\<^bsup>\\<lambda>s.\n            rwof\n             (RETURN\n               \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                  \\<dots> = no_path_impl\\<rparr>)\n             (gen_dfs_defs.gen_cond\n               (gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {})\n                 (fp0_params_impl P) simple_state.more_update)\n               (g_V0 G))\n             (gen_dfs_defs.gen_step\n               (gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {})\n                 (fp0_params_impl P) simple_state.more_update)\n               (g_V0 G))\n             s \\<and>\n            insert v0 {v. v \\<in> visited s0}\n            \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                                   (\\<lambda>s.\n fp0_state_impl.ppath s = None \\<and> ss_stack s \\<noteq> [])\n                                   (\\<lambda>s.\n ASSERT (ss_stack s \\<noteq> []) \\<bind>\n (\\<lambda>x.\n     (let (u, Vs) = hd (ss_stack s)\n      in if Vs = {} then RETURN (u, None, s)\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s\\<lparr>ss_stack :=\n                                     (u, Vs) # tl (ss_stack s)\\<rparr>\n                  in RETURN (u, Some v, s))) \\<bind>\n     (\\<lambda>(u, Vs, s).\n         case Vs of\n         None \\<Rightarrow>\n           ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n           (\\<lambda>x.\n               (let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                in Let (op_nos_on_stack_update\n                         (\\<lambda>_. on_stack s - {u}) s)\n                    RETURN) \\<bind>\n               (\\<lambda>s.\n                   RETURN\n                    (s\\<lparr>simple_state.more :=\n                                simple_state.more s\\<rparr>)))\n         | Some v \\<Rightarrow>\n             if v \\<in> visited s\n             then RETURN\n                   (s\\<lparr>simple_state.more :=\n                               simple_state.more s\\<rparr>)\n             else ASSERT\n                   (v \\<notin> on_stack s \\<and>\n                    v \\<notin> visited s) \\<bind>\n                  (\\<lambda>x.\n                      (let s = s\\<lparr>ss_stack :=\n    (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                           s = op_nos_on_stack_update\n                                (\\<lambda>_. insert v (on_stack s)) s\n                       in Let (s\\<lparr>visited :=\n    insert v (visited s)\\<rparr>)\n                           RETURN) \\<bind>\n                      (\\<lambda>s.\n                          (if P v\n                           then RETURN\n                                 (a_path_impl\n                                   (map fst (rev (tl (CAST (ss_stack s)))))\n                                   v)\n                           else RETURN no_path_impl) \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (s\\<lparr>simple_state.more :=\n     e\\<rparr>)))))))\n                                   (x\\<lparr>simple_state.more :=\n         xa\\<rparr>)))))\n          \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n             \\<dots> = no_path_impl\\<rparr> \\<bind>\n         (\\<lambda>s. RETURN (fp0_state_impl.ppath s))))\n    \\<in> ?R", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     ASSERT (fp0 G) \\<bind>\n     (\\<lambda>_.\n         FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n                                   rwof\n                                    (RETURN\n\\<lparr>ss_stack = [], on_stack = {}, visited = {},\n   \\<dots> = no_path_impl\\<rparr>)\n                                    (gen_dfs_defs.gen_cond\n(gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {}) (fp0_params_impl P)\n  simple_state.more_update)\n(g_V0 G))\n                                    (gen_dfs_defs.gen_step\n(gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {}) (fp0_params_impl P)\n  simple_state.more_update)\n(g_V0 G))\n                                    s \\<and>\n                                   (fp0_state_impl.ppath s =\n                                    None \\<longrightarrow>\n                                    ss_stack s = []) \\<and>\n                                   g_V0 G - it\n                                   \\<subseteq> {v.\n          v \\<in> visited s}\\<^esup>\n          (g_V0 G) (\\<lambda>x. fp0_state_impl.ppath x = None)\n          (\\<lambda>v0 s.\n              let s0 = s\n              in if v0 \\<in> visited s then RETURN s\n                 else ASSERT (v0 \\<notin> visited s) \\<bind>\n                      (\\<lambda>x.\n                          (let s = s\\<lparr>ss_stack :=\n        [(v0, g_E G `` {v0})]\\<rparr>;\n                               s = op_nos_on_stack_update (\\<lambda>_. {v0})\n                                    s\n                           in Let (s\\<lparr>visited :=\n        insert v0 (visited s)\\<rparr>)\n                               RETURN) \\<bind>\n                          (\\<lambda>x.\n                              (if P v0 then RETURN (a_path_impl [] v0)\n                               else RETURN no_path_impl) \\<bind>\n                              (\\<lambda>xa.\n                                  WHILE\\<^bsup>\\<lambda>s.\n            rwof\n             (RETURN\n               \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                  \\<dots> = no_path_impl\\<rparr>)\n             (gen_dfs_defs.gen_cond\n               (gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {})\n                 (fp0_params_impl P) simple_state.more_update)\n               (g_V0 G))\n             (gen_dfs_defs.gen_step\n               (gen_param_dfs_defs.gds (restricted_impl_defs.gbs' G {})\n                 (fp0_params_impl P) simple_state.more_update)\n               (g_V0 G))\n             s \\<and>\n            insert v0 {v. v \\<in> visited s0}\n            \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                                   (\\<lambda>s.\n fp0_state_impl.ppath s = None \\<and> ss_stack s \\<noteq> [])\n                                   (\\<lambda>s.\n ASSERT (ss_stack s \\<noteq> []) \\<bind>\n (\\<lambda>x.\n     (let (u, Vs) = hd (ss_stack s)\n      in if Vs = {} then RETURN (u, None, s)\n         else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n              (\\<lambda>v.\n                  let Vs = Vs - {v};\n                      s = s\\<lparr>ss_stack :=\n                                     (u, Vs) # tl (ss_stack s)\\<rparr>\n                  in RETURN (u, Some v, s))) \\<bind>\n     (\\<lambda>(u, Vs, s).\n         case Vs of\n         None \\<Rightarrow>\n           ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n           (\\<lambda>x.\n               (let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                in Let (op_nos_on_stack_update\n                         (\\<lambda>_. on_stack s - {u}) s)\n                    RETURN) \\<bind>\n               (\\<lambda>s.\n                   RETURN\n                    (s\\<lparr>simple_state.more :=\n                                simple_state.more s\\<rparr>)))\n         | Some v \\<Rightarrow>\n             if v \\<in> visited s\n             then RETURN\n                   (s\\<lparr>simple_state.more :=\n                               simple_state.more s\\<rparr>)\n             else ASSERT\n                   (v \\<notin> on_stack s \\<and>\n                    v \\<notin> visited s) \\<bind>\n                  (\\<lambda>x.\n                      (let s = s\\<lparr>ss_stack :=\n    (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                           s = op_nos_on_stack_update\n                                (\\<lambda>_. insert v (on_stack s)) s\n                       in Let (s\\<lparr>visited :=\n    insert v (visited s)\\<rparr>)\n                           RETURN) \\<bind>\n                      (\\<lambda>s.\n                          (if P v\n                           then RETURN\n                                 (a_path_impl\n                                   (map fst (rev (tl (CAST (ss_stack s)))))\n                                   v)\n                           else RETURN no_path_impl) \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (s\\<lparr>simple_state.more :=\n     e\\<rparr>)))))))\n                                   (x\\<lparr>simple_state.more :=\n         xa\\<rparr>)))))\n          \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n             \\<dots> = no_path_impl\\<rparr> \\<bind>\n         (\\<lambda>s. RETURN (fp0_state_impl.ppath s))))\n    \\<in> ?R", "apply (autoref_monadic (trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition find_path0_code uses find_path0_code"], ["", "export_code find_path0_code checking SML"], ["", "lemma find_path0_autoref_aux:\n  assumes Vid: \"Rv = (Id :: 'a :: hashable rel)\"\n  shows \"(\\<lambda>G P. nres_of (find_path0_code G P), find_path0_spec) \n    \\<in> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> (Rv \\<rightarrow> bool_rel) \n      \\<rightarrow> \\<langle>\\<langle>\\<langle>Rv\\<rangle>list_rel \\<times>\\<^sub>r Rv\\<rangle>option_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>G P. nres_of (find_path0_code G P), find_path0_spec)\n    \\<in> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (Rv \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>Rv\\<rangle>list_rel \\<times>\\<^sub>r\n                            Rv\\<rangle>option_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> nres_of (find_path0_code a aa)\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>Rv\\<rangle>list_rel \\<times>\\<^sub>r\n    Rv\\<rangle>option_rel)\n                                (find_path0_spec a' a'a)", "unfolding Vid"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Id \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> nres_of (find_path0_code a aa)\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n    Id\\<rangle>option_rel)\n                                (find_path0_spec a' a'a)", "apply (rule \n    order_trans[OF find_path0_code.refine[param_fo, THEN nres_relD]],\n    assumption+\n    )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Id \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                    Id\\<rangle>option_rel)\n                          (find_path0_impl a' a'a)\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n    Id\\<rangle>option_rel)\n                                (find_path0_spec a' a'a)", "using find_path0_impl find_path0_correct"], ["proof (prove)\nusing this:\n  find_path0_impl ?G ?P\n  \\<le> \\<Down> (\\<langle>Id \\<times>\\<^sub>r Id\\<rangle>option_rel)\n         (find_path0 ?G ?P)\n  find_path0 ?G ?P \\<le> find_path0_spec ?G ?P\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Id \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                    Id\\<rangle>option_rel)\n                          (find_path0_impl a' a'a)\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n    Id\\<rangle>option_rel)\n                                (find_path0_spec a' a'a)", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        aa = a'a;\n        \\<And>G P.\n           nofail (find_path0 G P) \\<longrightarrow>\n           nofail (find_path0_impl G P) \\<and>\n           (\\<forall>x.\n               inres (find_path0_impl G P) x \\<longrightarrow>\n               inres (find_path0 G P) x);\n        \\<And>G P.\n           nofail (find_path0_spec G P) \\<longrightarrow>\n           nofail (find_path0 G P) \\<and>\n           (\\<forall>x.\n               inres (find_path0 G P) x \\<longrightarrow>\n               inres (find_path0_spec G P) x)\\<rbrakk>\n       \\<Longrightarrow> nofail (find_path0_spec a' a'a) \\<longrightarrow>\n                         nofail (find_path0_impl a' a'a) \\<and>\n                         (\\<forall>x.\n                             inres (find_path0_impl a' a'a)\n                              x \\<longrightarrow>\n                             inres (find_path0_spec a' a'a) x)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas find_path0_autoref[autoref_rules] = find_path0_autoref_aux[OF PREFER_id_D]"], ["", "schematic_goal find_path0_restr_code:\n  fixes vis_rel :: \"('v\\<times>'v) set \\<Rightarrow> ('visi\\<times>'v set) set\"\n  notes [autoref_rel_intf] = REL_INTFI[of vis_rel \"i_set\" for I]\n  assumes [autoref_rules]: \"(op_vis_insert, insert)\\<in>Id \\<rightarrow> \\<langle>Id\\<rangle>vis_rel \\<rightarrow> \\<langle>Id\\<rangle>vis_rel\"\n  assumes [autoref_rules]: \"(op_vis_memb, (\\<in>))\\<in>Id \\<rightarrow> \\<langle>Id\\<rangle>vis_rel \\<rightarrow> bool_rel\"\n  assumes [autoref_rules]: \n    \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n    \"(Pi,P)\\<in>Id \\<rightarrow> bool_rel\"\n    \"(Ri,R)\\<in>\\<langle>Id\\<rangle>vis_rel\"\n  shows \"(nres_of (?c::?'c dres),\n    find_path0_restr_impl \n      G\n      P \n      (R:::\\<^sub>r\\<langle>Id\\<rangle>vis_rel)) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     find_path0_restr_impl G P (R ::: \\<langle>Id\\<rangle>vis_rel))\n    \\<in> ?R", "unfolding find_path0_restr_impl_def[abs_def] DFS_code_unfold ssnos_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     ASSERT (fb_graph G) \\<bind>\n     (\\<lambda>_.\n         ASSERT\n          (fp0 (graph_restrict G\n                 (R ::: \\<langle>Id\\<rangle>vis_rel))) \\<bind>\n         (\\<lambda>_.\n             RETURN no_path_impl \\<bind>\n             (\\<lambda>e.\n                 RETURN\n                  \\<lparr>ss_stack = [], on_stack = {},\n                     visited = R ::: \\<langle>Id\\<rangle>vis_rel,\n                     \\<dots> = e\\<rparr>) \\<bind>\n             FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n rwof\n  (RETURN no_path_impl \\<bind>\n   (\\<lambda>e.\n       RETURN\n        \\<lparr>ss_stack = [], on_stack = {},\n           visited = R ::: \\<langle>Id\\<rangle>vis_rel,\n           \\<dots> = e\\<rparr>))\n  (gen_dfs_defs.gen_cond\n    (gen_param_dfs_defs.gds\n      (restricted_impl_defs.gbs' G (R ::: \\<langle>Id\\<rangle>vis_rel))\n      (fp0_params_impl P) simple_state.more_update)\n    (g_V0 G))\n  (gen_dfs_defs.gen_step\n    (gen_param_dfs_defs.gds\n      (restricted_impl_defs.gbs' G (R ::: \\<langle>Id\\<rangle>vis_rel))\n      (fp0_params_impl P) simple_state.more_update)\n    (g_V0 G))\n  s \\<and>\n (\\<not> fp0_state_impl.ppath s \\<noteq> None \\<longrightarrow>\n  ss_stack s = []) \\<and>\n g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n              (g_V0 G)\n              (\\<lambda>x. \\<not> fp0_state_impl.ppath x \\<noteq> None)\n              (\\<lambda>v0 s.\n                  let s0 = s\n                  in if v0 \\<in> visited s then RETURN s\n                     else ASSERT (v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>_.\n                              let s = s\\<lparr>ss_stack :=\n           [(v0, g_E G `` {v0})]\\<rparr>;\n                                  s = op_nos_on_stack_update\n (\\<lambda>_. {v0}) s\n                              in Let (s\n\\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                  RETURN) \\<bind>\n                          (\\<lambda>s.\n                              (if P v0 then RETURN (a_path_impl [] v0)\n                               else RETURN no_path_impl) \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>simple_state.more :=\n         e\\<rparr>))) \\<bind>\n                          WHILE\\<^bsup>\\<lambda>s.\n    rwof\n     (RETURN no_path_impl \\<bind>\n      (\\<lambda>e.\n          RETURN\n           \\<lparr>ss_stack = [], on_stack = {},\n              visited = R ::: \\<langle>Id\\<rangle>vis_rel,\n              \\<dots> = e\\<rparr>))\n     (gen_dfs_defs.gen_cond\n       (gen_param_dfs_defs.gds\n         (restricted_impl_defs.gbs' G (R ::: \\<langle>Id\\<rangle>vis_rel))\n         (fp0_params_impl P) simple_state.more_update)\n       (g_V0 G))\n     (gen_dfs_defs.gen_step\n       (gen_param_dfs_defs.gds\n         (restricted_impl_defs.gbs' G (R ::: \\<langle>Id\\<rangle>vis_rel))\n         (fp0_params_impl P) simple_state.more_update)\n       (g_V0 G))\n     s \\<and>\n    insert v0 {v. v \\<in> visited s0}\n    \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                           (\\<lambda>s.\n                               \\<not> fp0_state_impl.ppath s \\<noteq>\nNone \\<and>\n                               ss_stack s \\<noteq> [])\n                           (\\<lambda>s.\n                               ASSERT (ss_stack s \\<noteq> []) \\<bind>\n                               (\\<lambda>_.\n                                   let (u, Vs) = hd (ss_stack s)\n                                   in if Vs = {} then RETURN (u, None, s)\nelse SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n     (\\<lambda>v.\n         let Vs = Vs - {v};\n             s = s\\<lparr>ss_stack := (u, Vs) # tl (ss_stack s)\\<rparr>\n         in RETURN (u, Some v, s))) \\<bind>\n                               (\\<lambda>(u, Vs, s).\n                                   case Vs of\n                                   None \\<Rightarrow>\n                                     ASSERT\n(ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n                                     (\\<lambda>_.\n   let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n   in Let (op_nos_on_stack_update (\\<lambda>_. on_stack s - {u}) s)\n       RETURN) \\<bind>\n                                     (\\<lambda>s.\n   RETURN (simple_state.more s) \\<bind>\n   (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n                                   | Some v \\<Rightarrow>\n if v \\<in> visited s\n then if v \\<in> visited s - on_stack s\n      then RETURN s \\<bind>\n           (\\<lambda>s.\n               RETURN (simple_state.more s) \\<bind>\n               (\\<lambda>e.\n                   RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n      else RETURN s \\<bind>\n           (\\<lambda>s.\n               RETURN (simple_state.more s) \\<bind>\n               (\\<lambda>e.\n                   RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n else ASSERT (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n      (\\<lambda>_.\n          let s = s\\<lparr>ss_stack :=\n                             (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n              s = op_nos_on_stack_update (\\<lambda>_. insert v (on_stack s))\n                   s\n          in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n              RETURN) \\<bind>\n      (\\<lambda>s.\n          (if P v\n           then RETURN\n                 (a_path_impl (map fst (rev (tl (CAST (ss_stack s))))) v)\n           else RETURN no_path_impl) \\<bind>\n          (\\<lambda>e.\n              RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n             (\\<lambda>s.\n                 case fp0_state_impl.ppath s of\n                 None \\<Rightarrow> RETURN (Inl (visited s))\n                 | Some (vs, v) \\<Rightarrow> RETURN (Inr (vs, v))))))\n    \\<in> ?R", "unfolding if_cancel not_not comp_def nres_monad_laws"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     ASSERT (fb_graph G) \\<bind>\n     (\\<lambda>_.\n         ASSERT\n          (fp0 (graph_restrict G\n                 (R ::: \\<langle>Id\\<rangle>vis_rel))) \\<bind>\n         (\\<lambda>_.\n             FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n rwof\n  (RETURN\n    \\<lparr>ss_stack = [], on_stack = {},\n       visited = R ::: \\<langle>Id\\<rangle>vis_rel,\n       \\<dots> = no_path_impl\\<rparr>)\n  (gen_dfs_defs.gen_cond\n    (gen_param_dfs_defs.gds\n      (restricted_impl_defs.gbs' G (R ::: \\<langle>Id\\<rangle>vis_rel))\n      (fp0_params_impl P) simple_state.more_update)\n    (g_V0 G))\n  (gen_dfs_defs.gen_step\n    (gen_param_dfs_defs.gds\n      (restricted_impl_defs.gbs' G (R ::: \\<langle>Id\\<rangle>vis_rel))\n      (fp0_params_impl P) simple_state.more_update)\n    (g_V0 G))\n  s \\<and>\n (fp0_state_impl.ppath s = None \\<longrightarrow> ss_stack s = []) \\<and>\n g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n              (g_V0 G) (\\<lambda>x. fp0_state_impl.ppath x = None)\n              (\\<lambda>v0 s.\n                  let s0 = s\n                  in if v0 \\<in> visited s then RETURN s\n                     else ASSERT (v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>x.\n                              (let s = s\\<lparr>ss_stack :=\n            [(v0, g_E G `` {v0})]\\<rparr>;\n                                   s = op_nos_on_stack_update\n  (\\<lambda>_. {v0}) s\n                               in Let (s\n \\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                   RETURN) \\<bind>\n                              (\\<lambda>x.\n                                  (if P v0 then RETURN (a_path_impl [] v0)\n                                   else RETURN no_path_impl) \\<bind>\n                                  (\\<lambda>xa.\nWHILE\\<^bsup>\\<lambda>s.\n                rwof\n                 (RETURN\n                   \\<lparr>ss_stack = [], on_stack = {},\n                      visited = R ::: \\<langle>Id\\<rangle>vis_rel,\n                      \\<dots> = no_path_impl\\<rparr>)\n                 (gen_dfs_defs.gen_cond\n                   (gen_param_dfs_defs.gds\n                     (restricted_impl_defs.gbs' G\n                       (R ::: \\<langle>Id\\<rangle>vis_rel))\n                     (fp0_params_impl P) simple_state.more_update)\n                   (g_V0 G))\n                 (gen_dfs_defs.gen_step\n                   (gen_param_dfs_defs.gds\n                     (restricted_impl_defs.gbs' G\n                       (R ::: \\<langle>Id\\<rangle>vis_rel))\n                     (fp0_params_impl P) simple_state.more_update)\n                   (g_V0 G))\n                 s \\<and>\n                insert v0 {v. v \\<in> visited s0}\n                \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n (\\<lambda>s. fp0_state_impl.ppath s = None \\<and> ss_stack s \\<noteq> [])\n (\\<lambda>s.\n     ASSERT (ss_stack s \\<noteq> []) \\<bind>\n     (\\<lambda>x.\n         (let (u, Vs) = hd (ss_stack s)\n          in if Vs = {} then RETURN (u, None, s)\n             else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                  (\\<lambda>v.\n                      let Vs = Vs - {v};\n                          s = s\\<lparr>ss_stack :=\n   (u, Vs) # tl (ss_stack s)\\<rparr>\n                      in RETURN (u, Some v, s))) \\<bind>\n         (\\<lambda>(u, Vs, s).\n             case Vs of\n             None \\<Rightarrow>\n               ASSERT\n                (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n               (\\<lambda>x.\n                   (let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                    in Let (op_nos_on_stack_update\n                             (\\<lambda>_. on_stack s - {u}) s)\n                        RETURN) \\<bind>\n                   (\\<lambda>s.\n                       RETURN\n                        (s\\<lparr>simple_state.more :=\n                                    simple_state.more s\\<rparr>)))\n             | Some v \\<Rightarrow>\n                 if v \\<in> visited s\n                 then RETURN\n                       (s\\<lparr>simple_state.more :=\n                                   simple_state.more s\\<rparr>)\n                 else ASSERT\n                       (v \\<notin> on_stack s \\<and>\n                        v \\<notin> visited s) \\<bind>\n                      (\\<lambda>x.\n                          (let s = s\\<lparr>ss_stack :=\n        (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                               s = op_nos_on_stack_update\n                                    (\\<lambda>_. insert v (on_stack s)) s\n                           in Let (s\\<lparr>visited :=\n        insert v (visited s)\\<rparr>)\n                               RETURN) \\<bind>\n                          (\\<lambda>s.\n                              (if P v\n                               then RETURN\n                                     (a_path_impl\n (map fst (rev (tl (CAST (ss_stack s))))) v)\n                               else RETURN no_path_impl) \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>simple_state.more :=\n         e\\<rparr>)))))))\n (x\\<lparr>simple_state.more := xa\\<rparr>)))))\n              \\<lparr>ss_stack = [], on_stack = {},\n                 visited = R ::: \\<langle>Id\\<rangle>vis_rel,\n                 \\<dots> = no_path_impl\\<rparr> \\<bind>\n             (\\<lambda>s.\n                 case fp0_state_impl.ppath s of\n                 None \\<Rightarrow> RETURN (Inl (visited s))\n                 | Some (vs, v) \\<Rightarrow> RETURN (Inr (vs, v))))))\n    \\<in> ?R", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     ASSERT (fb_graph G) \\<bind>\n     (\\<lambda>_.\n         ASSERT\n          (fp0 (graph_restrict G\n                 (R ::: \\<langle>Id\\<rangle>vis_rel))) \\<bind>\n         (\\<lambda>_.\n             FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n rwof\n  (RETURN\n    \\<lparr>ss_stack = [], on_stack = {},\n       visited = R ::: \\<langle>Id\\<rangle>vis_rel,\n       \\<dots> = no_path_impl\\<rparr>)\n  (gen_dfs_defs.gen_cond\n    (gen_param_dfs_defs.gds\n      (restricted_impl_defs.gbs' G (R ::: \\<langle>Id\\<rangle>vis_rel))\n      (fp0_params_impl P) simple_state.more_update)\n    (g_V0 G))\n  (gen_dfs_defs.gen_step\n    (gen_param_dfs_defs.gds\n      (restricted_impl_defs.gbs' G (R ::: \\<langle>Id\\<rangle>vis_rel))\n      (fp0_params_impl P) simple_state.more_update)\n    (g_V0 G))\n  s \\<and>\n (fp0_state_impl.ppath s = None \\<longrightarrow> ss_stack s = []) \\<and>\n g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n              (g_V0 G) (\\<lambda>x. fp0_state_impl.ppath x = None)\n              (\\<lambda>v0 s.\n                  let s0 = s\n                  in if v0 \\<in> visited s then RETURN s\n                     else ASSERT (v0 \\<notin> visited s) \\<bind>\n                          (\\<lambda>x.\n                              (let s = s\\<lparr>ss_stack :=\n            [(v0, g_E G `` {v0})]\\<rparr>;\n                                   s = op_nos_on_stack_update\n  (\\<lambda>_. {v0}) s\n                               in Let (s\n \\<lparr>visited := insert v0 (visited s)\\<rparr>)\n                                   RETURN) \\<bind>\n                              (\\<lambda>x.\n                                  (if P v0 then RETURN (a_path_impl [] v0)\n                                   else RETURN no_path_impl) \\<bind>\n                                  (\\<lambda>xa.\nWHILE\\<^bsup>\\<lambda>s.\n                rwof\n                 (RETURN\n                   \\<lparr>ss_stack = [], on_stack = {},\n                      visited = R ::: \\<langle>Id\\<rangle>vis_rel,\n                      \\<dots> = no_path_impl\\<rparr>)\n                 (gen_dfs_defs.gen_cond\n                   (gen_param_dfs_defs.gds\n                     (restricted_impl_defs.gbs' G\n                       (R ::: \\<langle>Id\\<rangle>vis_rel))\n                     (fp0_params_impl P) simple_state.more_update)\n                   (g_V0 G))\n                 (gen_dfs_defs.gen_step\n                   (gen_param_dfs_defs.gds\n                     (restricted_impl_defs.gbs' G\n                       (R ::: \\<langle>Id\\<rangle>vis_rel))\n                     (fp0_params_impl P) simple_state.more_update)\n                   (g_V0 G))\n                 s \\<and>\n                insert v0 {v. v \\<in> visited s0}\n                \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n (\\<lambda>s. fp0_state_impl.ppath s = None \\<and> ss_stack s \\<noteq> [])\n (\\<lambda>s.\n     ASSERT (ss_stack s \\<noteq> []) \\<bind>\n     (\\<lambda>x.\n         (let (u, Vs) = hd (ss_stack s)\n          in if Vs = {} then RETURN (u, None, s)\n             else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n                  (\\<lambda>v.\n                      let Vs = Vs - {v};\n                          s = s\\<lparr>ss_stack :=\n   (u, Vs) # tl (ss_stack s)\\<rparr>\n                      in RETURN (u, Some v, s))) \\<bind>\n         (\\<lambda>(u, Vs, s).\n             case Vs of\n             None \\<Rightarrow>\n               ASSERT\n                (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n               (\\<lambda>x.\n                   (let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n                    in Let (op_nos_on_stack_update\n                             (\\<lambda>_. on_stack s - {u}) s)\n                        RETURN) \\<bind>\n                   (\\<lambda>s.\n                       RETURN\n                        (s\\<lparr>simple_state.more :=\n                                    simple_state.more s\\<rparr>)))\n             | Some v \\<Rightarrow>\n                 if v \\<in> visited s\n                 then RETURN\n                       (s\\<lparr>simple_state.more :=\n                                   simple_state.more s\\<rparr>)\n                 else ASSERT\n                       (v \\<notin> on_stack s \\<and>\n                        v \\<notin> visited s) \\<bind>\n                      (\\<lambda>x.\n                          (let s = s\\<lparr>ss_stack :=\n        (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                               s = op_nos_on_stack_update\n                                    (\\<lambda>_. insert v (on_stack s)) s\n                           in Let (s\\<lparr>visited :=\n        insert v (visited s)\\<rparr>)\n                               RETURN) \\<bind>\n                          (\\<lambda>s.\n                              (if P v\n                               then RETURN\n                                     (a_path_impl\n (map fst (rev (tl (CAST (ss_stack s))))) v)\n                               else RETURN no_path_impl) \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>simple_state.more :=\n         e\\<rparr>)))))))\n (x\\<lparr>simple_state.more := xa\\<rparr>)))))\n              \\<lparr>ss_stack = [], on_stack = {},\n                 visited = R ::: \\<langle>Id\\<rangle>vis_rel,\n                 \\<dots> = no_path_impl\\<rparr> \\<bind>\n             (\\<lambda>s.\n                 case fp0_state_impl.ppath s of\n                 None \\<Rightarrow> RETURN (Inl (visited s))\n                 | Some (vs, v) \\<Rightarrow> RETURN (Inr (vs, v))))))\n    \\<in> ?R", "apply (autoref_monadic (trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition find_path0_restr_code uses find_path0_restr_code"], ["", "export_code find_path0_restr_code checking SML"], ["", "lemma find_path0_restr_autoref_aux:\n  assumes 1: \"(op_vis_insert, insert)\\<in>Rv \\<rightarrow> \\<langle>Rv\\<rangle>vis_rel \\<rightarrow> \\<langle>Rv\\<rangle>vis_rel\"\n  assumes 2: \"(op_vis_memb, (\\<in>))\\<in>Rv \\<rightarrow> \\<langle>Rv\\<rangle>vis_rel \\<rightarrow> bool_rel\"\n  assumes Vid: \"Rv = Id\"\n  shows \"(\\<lambda> G P R. nres_of (find_path0_restr_code op_vis_insert op_vis_memb G P R), \n    find_path0_restr_spec) \n    \\<in> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> (Rv \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>Rv\\<rangle>vis_rel \\<rightarrow>\n    \\<langle>\\<langle>\\<langle>Rv\\<rangle>vis_rel, \\<langle>Rv\\<rangle>list_rel \\<times>\\<^sub>r Rv\\<rangle>sum_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>G P R.\n        nres_of (find_path0_restr_code op_vis_insert op_vis_memb G P R),\n     find_path0_restr_spec)\n    \\<in> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (Rv \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>Rv\\<rangle>vis_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>Rv\\<rangle>vis_rel,\n          \\<langle>Rv\\<rangle>list_rel \\<times>\\<^sub>r\n          Rv\\<rangle>sum_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Rv \\<rightarrow> bool_rel;\n        (ab, a'b) \\<in> \\<langle>Rv\\<rangle>vis_rel\\<rbrakk>\n       \\<Longrightarrow> nres_of\n                          (find_path0_restr_code op_vis_insert op_vis_memb a\n                            aa ab)\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>Rv\\<rangle>vis_rel,\n                                 \\<langle>Rv\\<rangle>list_rel \\<times>\\<^sub>r\n                                 Rv\\<rangle>sum_rel)\n                                (find_path0_restr_spec a' a'a a'b)", "unfolding Vid"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Id \\<rightarrow> bool_rel;\n        (ab, a'b) \\<in> \\<langle>Id\\<rangle>vis_rel\\<rbrakk>\n       \\<Longrightarrow> nres_of\n                          (find_path0_restr_code op_vis_insert op_vis_memb a\n                            aa ab)\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>Id\\<rangle>vis_rel,\n                                 \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                 Id\\<rangle>sum_rel)\n                                (find_path0_restr_spec a' a'a a'b)", "apply (rule \n    order_trans[OF find_path0_restr_code.refine[OF 1[unfolded Vid] 2[unfolded Vid], param_fo, THEN nres_relD]]\n    )"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Id \\<rightarrow> bool_rel;\n        (ab, a'b) \\<in> \\<langle>Id\\<rangle>vis_rel\\<rbrakk>\n       \\<Longrightarrow> (a, ?G6 a a' aa a'a ab a'b)\n                         \\<in> \\<langle>?Rm6 a a' aa a'a ab a'b,\n                         Id\\<rangle>g_impl_rel_ext\n 2. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Id \\<rightarrow> bool_rel;\n        (ab, a'b) \\<in> \\<langle>Id\\<rangle>vis_rel\\<rbrakk>\n       \\<Longrightarrow> (aa, ?P6 a a' aa a'a ab a'b)\n                         \\<in> Id \\<rightarrow> bool_rel\n 3. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Id \\<rightarrow> bool_rel;\n        (ab, a'b) \\<in> \\<langle>Id\\<rangle>vis_rel\\<rbrakk>\n       \\<Longrightarrow> (ab, ?R6 a a' aa a'a ab a'b)\n                         \\<in> \\<langle>Id\\<rangle>vis_rel\n 4. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Id \\<rightarrow> bool_rel;\n        (ab, a'b) \\<in> \\<langle>Id\\<rangle>vis_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (\\<langle>\\<langle>Id\\<rangle>vis_rel,\n                           \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                           Id\\<rangle>sum_rel)\n                          (find_path0_restr_impl (?G6 a a' aa a'a ab a'b)\n                            (?P6 a a' aa a'a ab a'b)\n                            (?R6 a a' aa a'a ab a'b :::\n                             \\<langle>Id\\<rangle>vis_rel))\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>Id\\<rangle>vis_rel,\n                                 \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                 Id\\<rangle>sum_rel)\n                                (find_path0_restr_spec a' a'a a'b)", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Id \\<rightarrow> bool_rel;\n        (ab, a'b) \\<in> \\<langle>Id\\<rangle>vis_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (\\<langle>\\<langle>Id\\<rangle>vis_rel,\n                           \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                           Id\\<rangle>sum_rel)\n                          (find_path0_restr_impl a' a'a\n                            (a'b ::: \\<langle>Id\\<rangle>vis_rel))\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>Id\\<rangle>vis_rel,\n                                 \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                 Id\\<rangle>sum_rel)\n                                (find_path0_restr_spec a' a'a a'b)", "using find_path0_restr_impl find_path0_restr_correct"], ["proof (prove)\nusing this:\n  find_path0_restr_impl ?G ?P ?R\n  \\<le> \\<Down> (\\<langle>Id, Id \\<times>\\<^sub>r Id\\<rangle>sum_rel)\n         (find_path0_restr ?G ?P ?R)\n  find_path0_restr ?G ?P ?R \\<le> find_path0_restr_spec ?G ?P ?R\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        (aa, a'a) \\<in> Id \\<rightarrow> bool_rel;\n        (ab, a'b) \\<in> \\<langle>Id\\<rangle>vis_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down>\n                          (\\<langle>\\<langle>Id\\<rangle>vis_rel,\n                           \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                           Id\\<rangle>sum_rel)\n                          (find_path0_restr_impl a' a'a\n                            (a'b ::: \\<langle>Id\\<rangle>vis_rel))\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>Id\\<rangle>vis_rel,\n                                 \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                 Id\\<rangle>sum_rel)\n                                (find_path0_restr_spec a' a'a a'b)", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext;\n        aa = a'a; (ab, a'b) \\<in> \\<langle>Id\\<rangle>vis_rel;\n        \\<And>G P R.\n           nofail (find_path0_restr G P R) \\<longrightarrow>\n           nofail (find_path0_restr_impl G P R) \\<and>\n           (\\<forall>x.\n               inres (find_path0_restr_impl G P R) x \\<longrightarrow>\n               inres (find_path0_restr G P R) x);\n        \\<And>G P R.\n           nofail (find_path0_restr_spec G P R) \\<longrightarrow>\n           nofail (find_path0_restr G P R) \\<and>\n           (\\<forall>x.\n               inres (find_path0_restr G P R) x \\<longrightarrow>\n               inres (find_path0_restr_spec G P R) x)\\<rbrakk>\n       \\<Longrightarrow> nofail\n                          (find_path0_restr_spec a' a'a\n                            a'b) \\<longrightarrow>\n                         nofail (find_path0_restr_impl a' a'a a'b) \\<and>\n                         (\\<forall>x.\n                             (nofail\n                               (find_path0_restr_impl a' a'a\n                                 a'b) \\<longrightarrow>\n                              (\\<exists>s'.\n                                  (x, s')\n                                  \\<in> \\<langle>\\<langle>Id\\<rangle>vis_rel,\n                                  Id\\<rangle>sum_rel \\<and>\n                                  inres (find_path0_restr_impl a' a'a a'b)\n                                   s')) \\<longrightarrow>\n                             (\\<exists>s'.\n                                 (x, s')\n                                 \\<in> \\<langle>\\<langle>Id\\<rangle>vis_rel,\n                                 Id\\<rangle>sum_rel \\<and>\n                                 inres (find_path0_restr_spec a' a'a a'b)\n                                  s'))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas find_path0_restr_autoref[autoref_rules] = find_path0_restr_autoref_aux[OF GEN_OP_D GEN_OP_D PREFER_id_D]"], ["", "schematic_goal find_path1_restr_code:\n  fixes vis_rel :: \"('v\\<times>'v) set \\<Rightarrow> ('visi\\<times>'v set) set\"\n  notes [autoref_rel_intf] = REL_INTFI[of vis_rel \"i_set\" for I]\n  assumes [autoref_rules]: \"(op_vis_insert, insert)\\<in>Id \\<rightarrow> \\<langle>Id\\<rangle>vis_rel \\<rightarrow> \\<langle>Id\\<rangle>vis_rel\"\n  assumes [autoref_rules]: \"(op_vis_memb, (\\<in>))\\<in>Id \\<rightarrow> \\<langle>Id\\<rangle>vis_rel \\<rightarrow> bool_rel\"\n  assumes [autoref_rules]: \n    \"(Gi, G) \\<in> \\<langle>Rm, Id\\<rangle>g_impl_rel_ext\"\n    \"(Pi,P)\\<in>Id \\<rightarrow> bool_rel\"\n    \"(Ri,R)\\<in>\\<langle>Id\\<rangle>vis_rel\"\n  shows \"(nres_of ?c,find_path1_restr G P R)\n  \\<in> \\<langle>\\<langle>\\<langle>Id\\<rangle>vis_rel, \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r Id\\<rangle>sum_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c, find_path1_restr G P R)\n    \\<in> \\<langle>\\<langle>\\<langle>Id\\<rangle>vis_rel,\n    \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n    Id\\<rangle>sum_rel\\<rangle>nres_rel", "unfolding find_path1_restr_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     FOREACH\\<^sub>C (g_V0 G) is_Inl\n      (\\<lambda>v0 s.\n          ASSERT (is_Inl s) \\<bind>\n          (\\<lambda>_.\n              let R = projl s\n              in find_path0_restr_spec\n                  (G\\<lparr>g_V0 := g_E G `` {v0}\\<rparr>) P R \\<bind>\n                 (\\<lambda>f0.\n                     case f0 of Inl x \\<Rightarrow> RETURN f0\n                     | Inr (vs, v) \\<Rightarrow>\n                         RETURN (Inr (v0 # vs, v)))))\n      (Inl R))\n    \\<in> \\<langle>\\<langle>\\<langle>Id\\<rangle>vis_rel,\n    \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n    Id\\<rangle>sum_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     FOREACH\\<^sub>C (g_V0 G) is_Inl\n      (\\<lambda>v0 s.\n          ASSERT (is_Inl s) \\<bind>\n          (\\<lambda>_.\n              let R = projl s\n              in find_path0_restr_spec\n                  (G\\<lparr>g_V0 := g_E G `` {v0}\\<rparr>) P R \\<bind>\n                 (\\<lambda>f0.\n                     case f0 of Inl x \\<Rightarrow> RETURN f0\n                     | Inr (vs, v) \\<Rightarrow>\n                         RETURN (Inr (v0 # vs, v)))))\n      (Inl R))\n    \\<in> \\<langle>\\<langle>\\<langle>Id\\<rangle>vis_rel,\n    \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n    Id\\<rangle>sum_rel\\<rangle>nres_rel", "apply (autoref_monadic (trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition find_path1_restr_code uses find_path1_restr_code"], ["", "export_code find_path1_restr_code checking SML"], ["", "lemma find_path1_restr_autoref_aux:\n  assumes G: \"(op_vis_insert, insert)\\<in>V \\<rightarrow> \\<langle>V\\<rangle>vis_rel \\<rightarrow> \\<langle>V\\<rangle>vis_rel\"\n             \"(op_vis_memb, (\\<in>))\\<in>V \\<rightarrow> \\<langle>V\\<rangle>vis_rel \\<rightarrow> bool_rel\"\n  assumes Vid[simp]: \"V=Id\"\n  shows \"(\\<lambda> G P R. nres_of (find_path1_restr_code op_vis_insert op_vis_memb G P R),find_path1_restr_spec)\n  \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> (V \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>V\\<rangle>vis_rel \\<rightarrow>\n    \\<langle>\\<langle>\\<langle>V\\<rangle>vis_rel, \\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r V\\<rangle>sum_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>G P R.\n        nres_of (find_path1_restr_code op_vis_insert op_vis_memb G P R),\n     find_path1_restr_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>V\\<rangle>vis_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>vis_rel,\n          \\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n          V\\<rangle>sum_rel\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>G P R.\n        nres_of (find_path1_restr_code op_vis_insert op_vis_memb G P R),\n     find_path1_restr_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>V\\<rangle>vis_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>vis_rel,\n          \\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n          V\\<rangle>sum_rel\\<rangle>nres_rel", "note find_path1_restr_code.refine[OF G[simplified], param_fo, THEN nres_relD]"], ["proof (state)\nthis:\n  \\<lbrakk>(?Gi1, ?G1) \\<in> \\<langle>?Rm1, Id\\<rangle>g_impl_rel_ext;\n   (?Pi1, ?P1) \\<in> Id \\<rightarrow> bool_rel;\n   (?Ri1, ?R1) \\<in> \\<langle>Id\\<rangle>vis_rel\\<rbrakk>\n  \\<Longrightarrow> nres_of\n                     (find_path1_restr_code op_vis_insert op_vis_memb ?Gi1\n                       ?Pi1 ?Ri1)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>Id\\<rangle>vis_rel,\n                            \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                            Id\\<rangle>sum_rel)\n                           (find_path1_restr ?G1 ?P1 ?R1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>G P R.\n        nres_of (find_path1_restr_code op_vis_insert op_vis_memb G P R),\n     find_path1_restr_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>V\\<rangle>vis_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>vis_rel,\n          \\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n          V\\<rangle>sum_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  \\<lbrakk>(?Gi1, ?G1) \\<in> \\<langle>?Rm1, Id\\<rangle>g_impl_rel_ext;\n   (?Pi1, ?P1) \\<in> Id \\<rightarrow> bool_rel;\n   (?Ri1, ?R1) \\<in> \\<langle>Id\\<rangle>vis_rel\\<rbrakk>\n  \\<Longrightarrow> nres_of\n                     (find_path1_restr_code op_vis_insert op_vis_memb ?Gi1\n                       ?Pi1 ?Ri1)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>Id\\<rangle>vis_rel,\n                            \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                            Id\\<rangle>sum_rel)\n                           (find_path1_restr ?G1 ?P1 ?R1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>G P R.\n        nres_of (find_path1_restr_code op_vis_insert op_vis_memb G P R),\n     find_path1_restr_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>V\\<rangle>vis_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>vis_rel,\n          \\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n          V\\<rangle>sum_rel\\<rangle>nres_rel", "note find_path1_restr_correct"], ["proof (state)\nthis:\n  find_path1_restr ?G ?P ?R \\<le> find_path1_restr_spec ?G ?P ?R\n\ngoal (1 subgoal):\n 1. (\\<lambda>G P R.\n        nres_of (find_path1_restr_code op_vis_insert op_vis_memb G P R),\n     find_path1_restr_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>V\\<rangle>vis_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>vis_rel,\n          \\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n          V\\<rangle>sum_rel\\<rangle>nres_rel", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?Gi3, ?G1) \\<in> \\<langle>?Rm3, Id\\<rangle>g_impl_rel_ext;\n   (?Pi3, ?P1) \\<in> Id \\<rightarrow> bool_rel;\n   (?Ri3, ?R1) \\<in> \\<langle>Id\\<rangle>vis_rel\\<rbrakk>\n  \\<Longrightarrow> nres_of\n                     (find_path1_restr_code op_vis_insert op_vis_memb ?Gi3\n                       ?Pi3 ?Ri3)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>Id\\<rangle>vis_rel,\n                            \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                            Id\\<rangle>sum_rel)\n                           (find_path1_restr_spec ?G1 ?P1 ?R1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?Gi3, ?G1) \\<in> \\<langle>?Rm3, Id\\<rangle>g_impl_rel_ext;\n   (?Pi3, ?P1) \\<in> Id \\<rightarrow> bool_rel;\n   (?Ri3, ?R1) \\<in> \\<langle>Id\\<rangle>vis_rel\\<rbrakk>\n  \\<Longrightarrow> nres_of\n                     (find_path1_restr_code op_vis_insert op_vis_memb ?Gi3\n                       ?Pi3 ?Ri3)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>Id\\<rangle>vis_rel,\n                            \\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                            Id\\<rangle>sum_rel)\n                           (find_path1_restr_spec ?G1 ?P1 ?R1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>G P R.\n        nres_of (find_path1_restr_code op_vis_insert op_vis_memb G P R),\n     find_path1_restr_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>V\\<rangle>vis_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>vis_rel,\n          \\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n          V\\<rangle>sum_rel\\<rangle>nres_rel", "by (force intro!: nres_relI)"], ["proof (state)\nthis:\n  (\\<lambda>G P R.\n      nres_of (find_path1_restr_code op_vis_insert op_vis_memb G P R),\n   find_path1_restr_spec)\n  \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n        (V \\<rightarrow> bool_rel) \\<rightarrow>\n        \\<langle>V\\<rangle>vis_rel \\<rightarrow>\n        \\<langle>\\<langle>\\<langle>V\\<rangle>vis_rel,\n        \\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n        V\\<rangle>sum_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas find_path1_restr_autoref[autoref_rules] = find_path1_restr_autoref_aux[OF GEN_OP_D GEN_OP_D PREFER_id_D]"], ["", "schematic_goal find_path1_code:\n  assumes Vid: \"V = (Id :: 'a :: hashable rel)\"\n  assumes [unfolded Vid,autoref_rules]:\n    \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n    \"(Pi,P)\\<in>V \\<rightarrow> bool_rel\"\n  notes [autoref_tyrel] = TYRELI[where R=\"\\<langle>(Id::('a\\<times>'a::hashable)set)\\<rangle>dflt_ahs_rel\"]\n  shows \"(nres_of ?c,find_path1 G P)\n  \\<in> \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r V\\<rangle>option_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c, find_path1 G P)\n    \\<in> \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            V\\<rangle>option_rel\\<rangle>nres_rel", "unfolding find_path1_def[abs_def] Vid"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     find_path1_restr_spec G P {} \\<bind>\n     case_sum (\\<lambda>x. RETURN None) (\\<lambda>vsv. RETURN (Some vsv)))\n    \\<in> \\<langle>\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                            Id\\<rangle>option_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nres_of ?c,\n     find_path1_restr_spec G P {} \\<bind>\n     case_sum (\\<lambda>x. RETURN None) (\\<lambda>vsv. RETURN (Some vsv)))\n    \\<in> \\<langle>\\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                            Id\\<rangle>option_rel\\<rangle>nres_rel", "apply (autoref_monadic (trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition find_path1_code uses find_path1_code"], ["", "export_code find_path1_code checking SML"], ["", "lemma find_path1_code_autoref_aux:\n  assumes Vid: \"V = (Id :: 'a :: hashable rel)\"\n  shows \"(\\<lambda> G P. nres_of (find_path1_code G P), find_path1_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> (V \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r V\\<rangle>option_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>G P. nres_of (find_path1_code G P), find_path1_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            V\\<rangle>option_rel\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>G P. nres_of (find_path1_code G P), find_path1_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            V\\<rangle>option_rel\\<rangle>nres_rel", "note find_path1_code.refine[OF Vid, param_fo, THEN nres_relD, simplified]"], ["proof (state)\nthis:\n  \\<lbrakk>(?Gi1, ?G1) \\<in> \\<langle>?Rm1, V\\<rangle>g_impl_rel_ext;\n   (?Pi1, ?P1) \\<in> V \\<rightarrow> bool_rel\\<rbrakk>\n  \\<Longrightarrow> nres_of (find_path1_code ?Gi1 ?Pi1)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                                     V\\<rangle>option_rel)\n                           (find_path1 ?G1 ?P1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>G P. nres_of (find_path1_code G P), find_path1_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            V\\<rangle>option_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  \\<lbrakk>(?Gi1, ?G1) \\<in> \\<langle>?Rm1, V\\<rangle>g_impl_rel_ext;\n   (?Pi1, ?P1) \\<in> V \\<rightarrow> bool_rel\\<rbrakk>\n  \\<Longrightarrow> nres_of (find_path1_code ?Gi1 ?Pi1)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                                     V\\<rangle>option_rel)\n                           (find_path1 ?G1 ?P1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>G P. nres_of (find_path1_code G P), find_path1_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            V\\<rangle>option_rel\\<rangle>nres_rel", "note find_path1_correct"], ["proof (state)\nthis:\n  find_path1 ?G ?P \\<le> find_path1_spec ?G ?P\n\ngoal (1 subgoal):\n 1. (\\<lambda>G P. nres_of (find_path1_code G P), find_path1_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            V\\<rangle>option_rel\\<rangle>nres_rel", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?Gi3, ?G1) \\<in> \\<langle>?Rm3, V\\<rangle>g_impl_rel_ext;\n   (?Pi3, ?P1) \\<in> V \\<rightarrow> bool_rel\\<rbrakk>\n  \\<Longrightarrow> nres_of (find_path1_code ?Gi3 ?Pi3)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                                     V\\<rangle>option_rel)\n                           (find_path1_spec ?G1 ?P1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?Gi3, ?G1) \\<in> \\<langle>?Rm3, V\\<rangle>g_impl_rel_ext;\n   (?Pi3, ?P1) \\<in> V \\<rightarrow> bool_rel\\<rbrakk>\n  \\<Longrightarrow> nres_of (find_path1_code ?Gi3 ?Pi3)\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                                     V\\<rangle>option_rel)\n                           (find_path1_spec ?G1 ?P1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>G P. nres_of (find_path1_code G P), find_path1_spec)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          (V \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                            V\\<rangle>option_rel\\<rangle>nres_rel", "by (force intro!: nres_relI)"], ["proof (state)\nthis:\n  (\\<lambda>G P. nres_of (find_path1_code G P), find_path1_spec)\n  \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n        (V \\<rightarrow> bool_rel) \\<rightarrow>\n        \\<langle>\\<langle>\\<langle>V\\<rangle>list_rel \\<times>\\<^sub>r\n                          V\\<rangle>option_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas find_path1_autoref[autoref_rules] = find_path1_code_autoref_aux[OF PREFER_id_D]"], ["", "subsection \\<open>Conclusion\\<close>"], ["", "text \\<open>\n  We have synthesized an efficient implementation for an algorithm to find a path\n  to a reachable node that satisfies a predicate. The algorithm comes in four variants,\n  with and without empty path, and with and without node restriction.\n\n  We have set up the Autoref tool, to insert this algorithms for the following \n  specifications:\n  \\<^item> @{term \"find_path0_spec G P\"} --- find path to node that satisfies @{term P}.\n  \\<^item> @{term \"find_path1_spec G P\"} --- find non-empty path to node that satisfies @{term P}.\n  \\<^item> @{term \"find_path0_restr_spec G P R\"} --- find path, with nodes from @{term R} already searched.\n  \\<^item> @{term \"find_path1_restr_spec\"} --- find non-empty path, with nodes from @{term R} already searched.\n\n\\<close>"], ["", "thm find_path0_autoref"], ["", "thm find_path1_autoref"], ["", "thm find_path0_restr_autoref"], ["", "thm find_path1_restr_autoref"], ["", "end"]]}