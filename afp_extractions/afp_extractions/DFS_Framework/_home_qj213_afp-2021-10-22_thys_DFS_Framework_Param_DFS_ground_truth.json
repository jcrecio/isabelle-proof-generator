{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Param_DFS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemmas dflt_parametrization_simp[simp] =\n  gen_parameterization.simps[mk_record_simp, OF dflt_parametrization_def]", "lemma discover_simps[simp]:\n    \"counter (discover u v s) = Suc (counter s)\"\n    \"discovered (discover u v s) = (discovered s)(v \\<mapsto> counter s)\" \n    \"finished (discover u v s) = finished s\"\n    \"stack (discover u v s) = v#stack s\"\n    \"pending (discover u v s) = pending s \\<union> {v} \\<times> E``{v}\"\n    \"tree_edges (discover u v s) = insert (u,v) (tree_edges s)\"\n    \"cross_edges (discover u v s) = cross_edges s\"\n    \"back_edges (discover u v s) = back_edges s\"\n    \"state.more (discover u v s) = state.more s\"", "lemma finish_simps[simp]:\n    \"counter (finish u s) = Suc (counter s)\"\n    \"discovered (finish u s) = discovered s\"\n    \"finished (finish u s) = (finished s)(u \\<mapsto> counter s)\"\n    \"stack (finish u s) = tl (stack s)\"\n    \"pending (finish u s) = pending s\"\n    \"tree_edges (finish u s) = tree_edges s\"\n    \"cross_edges (finish u s) = cross_edges s\"\n    \"back_edges (finish u s) = back_edges s\"\n    \"state.more (finish u s) = state.more s\"", "lemma back_edge_simps[simp]:\n    \"counter (back_edge u v s) = counter s\"\n    \"discovered (back_edge u v s) = discovered s\"\n    \"finished (back_edge u v s) = finished s\"\n    \"stack (back_edge u v s) = stack s\"\n    \"pending (back_edge u v s) = pending s\"\n    \"tree_edges (back_edge u v s) = tree_edges s\"\n    \"cross_edges (back_edge u v s) = cross_edges s\"\n    \"back_edges (back_edge u v s) = insert (u,v) (back_edges s)\"\n    \"state.more (back_edge u v s) = state.more s\"", "lemma cross_edge_simps[simp]:\n    \"counter (cross_edge u v s) = counter s\"\n    \"discovered (cross_edge u v s) = discovered s\"\n    \"finished (cross_edge u v s) = finished s\"\n    \"stack (cross_edge u v s) = stack s\"\n    \"pending (cross_edge u v s) = pending s\"\n    \"tree_edges (cross_edge u v s) = tree_edges s\"\n    \"cross_edges (cross_edge u v s) = insert (u,v) (cross_edges s)\"\n    \"back_edges (cross_edge u v s) = back_edges s\"\n    \"state.more (cross_edge u v s) = state.more s\"", "lemma new_root_simps[simp]:\n    \"counter (new_root v0 s) = Suc (counter s)\"\n    \"discovered (new_root v0 s) = (discovered s)(v0 \\<mapsto> counter s)\"\n    \"finished (new_root v0 s) = finished s\"\n    \"stack (new_root v0 s) = [v0]\"\n    \"pending (new_root v0 s) = ({v0}\\<times>E``{v0})\"\n    \"tree_edges (new_root v0 s) = tree_edges s\"\n    \"cross_edges (new_root v0 s) = cross_edges s\"\n    \"back_edges (new_root v0 s) = back_edges s\"\n    \"state.more (new_root v0 s) = state.more s\"", "lemma empty_state_simps[simp]:\n    \"counter (empty_state e) = 0\"\n    \"discovered (empty_state e) = Map.empty\"\n    \"finished (empty_state e) = Map.empty\"\n    \"pending (empty_state e) = {}\"\n    \"stack (empty_state e) = []\"\n    \"tree_edges (empty_state e) = {}\"\n    \"back_edges (empty_state e) = {}\"\n    \"cross_edges (empty_state e) = {}\"\n    \"state.more (empty_state e) = e\"", "lemmas op_defs = discover_def finish_def back_edge_def cross_edge_def new_root_def", "lemmas do_defs = do_discover_def do_finish_def do_known_edge_def\n    do_cross_edge_def do_back_edge_def do_new_root_def", "lemmas pred_defs = is_discovered_def is_finished_def is_empty_stack_def", "lemma cond_alt:\n    \"cond = (\\<lambda>s. (V0 \\<subseteq> dom (discovered s) \\<longrightarrow> stack s \\<noteq> []) \\<and> \\<not>is_break param s)\"", "lemma make_invar_thm: \"is_invar I \\<Longrightarrow> I s\"\n    \\<comment> \\<open>Lemma to transfer an invariant into this locale\\<close>", "lemmas indep_invar_rules = \n    leof_True_rule[where m=\"on_init param\"]\n    leof_True_rule[where m=\"on_new_root param v0 s'\" for v0 s']\n    leof_True_rule[where m=\"on_discover param u v s'\" for u v s']\n    leof_True_rule[where m=\"on_finish param v s'\" for v s']\n    leof_True_rule[where m=\"on_cross_edge param u v s'\" for u v s']\n    leof_True_rule[where m=\"on_back_edge param u v s'\" for u v s']", "lemma rwof_eq_DFS_invar[simp]: \n    \"rwof init cond step = DFS_invar G param\"\n    \\<comment> \\<open>The DFS-invar locale is equivalent to the strongest invariant of the loop.\\<close>", "lemma DFS_invar_step: \"\\<lbrakk>nofail it_dfs; DFS_invar G param s; cond s\\<rbrakk> \n    \\<Longrightarrow> step s \\<le> SPEC (DFS_invar G param)\"\n    \\<comment> \\<open>A step preserves the (best) invariant.\\<close>", "lemma DFS_invar_step': \"\\<lbrakk>nofail (step s); DFS_invar G param s; cond s\\<rbrakk> \n    \\<Longrightarrow> step s \\<le> SPEC (DFS_invar G param)\"", "lemmas pre_on_defs = pre_on_new_root_def pre_on_finish_def \n    pre_edge_selected_def pre_on_cross_edge_def pre_on_back_edge_def\n    pre_on_discover_def pre_is_break_def", "lemma establish_invarI[case_names init new_root finish cross_edge back_edge discover]:\n    \\<comment> \\<open>Establish a DFS invariant (explicit preconditions).\\<close>\n    assumes init: \"on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\"\n    assumes new_root: \"\\<And>s s' v0. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n         \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n \n             SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                         \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes finish: \"\\<And>s s' u. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s \\<noteq> []; u = hd (stack s); \n       pending s `` {u} = {};\n       s' = finish u s\\<rbrakk>\n         \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n \n              SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes cross_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s); v\\<in>dom (finished s);\n        s' = cross_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes back_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s); v\\<notin>dom (finished s);\n        s' = back_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>) \n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes discover: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> [];  (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<notin> dom (discovered s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    shows \"is_invar I\"", "lemma establish_invarI'[case_names init new_root finish cross_edge back_edge discover]:\n    \\<comment> \\<open>Establish a DFS invariant (symbolic preconditions).\\<close>\n    assumes init: \"on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\"\n    assumes new_root: \"\\<And>s' v0. pre_on_new_root v0 s'\n         \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n \n             SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                         \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes finish: \"\\<And>s' u. pre_on_finish u s' \n         \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n \n              SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes cross_edge: \"\\<And>s' u v. pre_on_cross_edge u v s'\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes back_edge: \"\\<And>s' u v. pre_on_back_edge u v s'\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>) \n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes discover: \"\\<And>s' u v. pre_on_discover u v s'\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    shows \"is_invar I\"", "lemma establish_invarI_ND [case_names prereq init new_discover finish cross_edge back_edge]:\n    \\<comment> \\<open>Establish a DFS invariant (new-root and discover cases are combined).\\<close>\n    assumes prereq: \"\\<And>u v s. on_discover param u v s = on_new_root param v s\"\n    assumes init: \"on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\"\n    assumes new_discover: \"\\<And>s s' v. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       v \\<notin> dom (discovered s); \n       discovered s' = (discovered s)(v\\<mapsto>counter s); finished s' = finished s;\n       counter s' = Suc (counter s); stack s' = v#stack s;\n       back_edges s' = back_edges s; cross_edges s' = cross_edges s;\n       tree_edges s' \\<supseteq> tree_edges s;\n       state.more s' = state.more s\\<rbrakk>\n         \\<Longrightarrow> on_new_root param v s' \\<le>\\<^sub>n \n             SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                         \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes finish: \"\\<And>s s' u. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s \\<noteq> []; u = hd (stack s); \n       pending s `` {u} = {};\n       s' = finish u s\\<rbrakk>\n         \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n \n              SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes cross_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s); v\\<in>dom (finished s);\n        s' = cross_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes back_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s); v\\<notin>dom (finished s);\n        s' = back_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>) \n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    shows \"is_invar I\"", "lemma establish_invarI_CB [case_names prereq init new_root finish cross_back_edge discover]:\n    \\<comment> \\<open>Establish a DFS invariant (cross and back edge cases are combined).\\<close>\n    assumes prereq: \"\\<And>u v s. on_back_edge param u v s = on_cross_edge param u v s\"\n    assumes init: \"on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\"\n    assumes new_root: \"\\<And>s s' v0. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n         \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n \n             SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                         \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes finish: \"\\<And>s s' u. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s \\<noteq> []; u = hd (stack s); \n       pending s `` {u} = {};\n       s' = finish u s\\<rbrakk>\n         \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n \n              SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes cross_back_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s);\n        discovered s' = discovered s; finished s' = finished s;\n        stack s' = stack s; tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u,v)};\n        cross_edges s' \\<union> back_edges s' = cross_edges s \\<union> back_edges s \\<union> {(u,v)};\n        state.more s' = state.more s \\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes discover: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> [];  (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<notin> dom (discovered s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    shows \"is_invar I\"", "lemma establish_invarI_ND_CB [case_names prereq_ND prereq_CB init new_discover finish cross_back_edge]:\n    \\<comment> \\<open>Establish a DFS invariant (new-root/discover and cross/back-edge cases are combined).\\<close>\n    assumes prereq: \n        \"\\<And>u v s. on_discover param u v s = on_new_root param v s\"\n        \"\\<And>u v s. on_back_edge param u v s = on_cross_edge param u v s\"\n    assumes init: \"on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\"\n    assumes new_discover: \"\\<And>s s' v. \n     \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n      v \\<notin> dom (discovered s); \n      discovered s' = (discovered s)(v\\<mapsto>counter s); finished s' = finished s;\n      counter s' = Suc (counter s); stack s' = v#stack s;\n      back_edges s' = back_edges s; cross_edges s' = cross_edges s;\n      tree_edges s' \\<supseteq> tree_edges s;\n      state.more s' = state.more s\\<rbrakk>\n        \\<Longrightarrow> on_new_root param v s' \\<le>\\<^sub>n \n            SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes finish: \"\\<And>s s' u. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s \\<noteq> []; u = hd (stack s); \n       pending s `` {u} = {};\n       s' = finish u s\\<rbrakk>\n         \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n \n              SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes cross_back_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s);\n        discovered s' = discovered s; finished s' = finished s;\n        stack s' = stack s; tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u,v)};\n        cross_edges s' \\<union> back_edges s' = cross_edges s \\<union> back_edges s \\<union> {(u,v)};\n        state.more s' = state.more s \\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    shows \"is_invar I\"", "lemma is_invarI_full [case_names init new_root finish cross_edge back_edge discover]:\n    \\<comment> \\<open>Establish a DFS invariant not taking into account the parameterization.\\<close>\n    assumes init: \"\\<And>e. I (empty_state e)\"\n    assumes new_root: \"\\<And>s s' v0 e. \n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s = []; v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk> \n      \\<Longrightarrow> I s'\"\n    and finish: \"\\<And>s s' u e. \n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s); s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk> \n       \\<Longrightarrow> I s'\"\n    and cross_edge: \"\\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u}; v \\<in> dom (discovered s); \n        v \\<in> dom (finished s);\n        u = hd (stack s); \n        s' = (cross_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>))\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\"\n    and back_edge: \"\\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u}; v \\<in> dom (discovered s); v \\<notin> dom (finished s); \n        u = hd (stack s); \n        s' = (back_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>))\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\"\n    and discover: \"\\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u}; v \\<notin> dom (discovered s); \n        u = hd (stack s); \n        s' = (discover u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>))\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\"\n  shows \"is_invar I\"", "lemma is_invarI [case_names init new_root finish visited discover]:\n    \\<comment> \\<open>Establish a DFS invariant not taking into account the parameterization, cross/back-edges combined.\\<close>\n    assumes init': \"\\<And>e. I (empty_state e)\"\n    and new_root': \"\\<And>s s' v0 e. \n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s = []; v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk> \n      \\<Longrightarrow> I s'\"\n    and finish': \"\\<And>s s' u e. \n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s); s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk> \n       \\<Longrightarrow> I s'\"\n    and visited': \"\\<And>s s' u v e c b.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u}; v \\<in> dom (discovered s);\n        u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\\<lparr> \n          pending := pending s - {(u,v)},\n          state.more := e, \n          cross_edges := c, \n          back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\"\n    and discover': \"\\<And>s s' u v e.\n       \\<lbrakk>I s; cond s;  DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u}; v \\<notin> dom (discovered s); \n        u = hd (stack s); \n        s' = (discover u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>))\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\"\n    shows \"is_invar I\"", "lemma i_basic_invar: \"is_invar basic_invar\"", "lemmas basic_invar = make_invar_thm[OF i_basic_invar]", "lemma pending_ssE: \"pending s \\<subseteq> E\"", "lemma pendingD:\n    \"(u,v)\\<in>pending s \\<Longrightarrow> (u,v)\\<in>E \\<and> u\\<in>dom (discovered s)\"", "lemma stack_set_def:\n    \"set (stack s) = dom (discovered s) - dom (finished s)\"", "lemma stack_discovered:\n    \"set (stack s) \\<subseteq> dom (discovered s)\"", "lemma stack_distinct:\n    \"distinct (stack s)\"", "lemma last_stack_in_V0:\n    \"stack s \\<noteq> [] \\<Longrightarrow> last (stack s) \\<in> V0\"", "lemma stack_not_finished:\n    \"x \\<in> set (stack s) \\<Longrightarrow> x \\<notin> dom (finished s)\"", "lemma discovered_not_stack_imp_finished:\n    \"x \\<in> dom (discovered s) \\<Longrightarrow> x \\<notin> set (stack s) \\<Longrightarrow> x \\<in> dom (finished s)\"", "lemma finished_discovered:\n    \"dom (finished s) \\<subseteq> dom (discovered s)\"", "lemma finished_no_pending:\n    \"v \\<in> dom (finished s) \\<Longrightarrow> pending s `` {v} = {}\"", "lemma discovered_eq_finished_un_stack:\n    \"dom (discovered s) = dom (finished s) \\<union> set (stack s)\"", "lemma pending_on_stack:\n    \"(v,w) \\<in> pending s \\<Longrightarrow> v \\<in> set (stack s)\"", "lemma empty_stack_imp_empty_pending:\n    \"stack s = [] \\<Longrightarrow> pending s = {}\"", "lemma i_discovered_reachable: \n    \"is_invar (\\<lambda>s. dom (discovered s) \\<subseteq> reachable)\"", "lemma i_discovered_closed: \"is_invar discovered_closed\"", "lemma i_discovered_finite: \"is_invar (\\<lambda>s. finite (dom (discovered s)))\"", "lemmas discovered_reachable = \n    i_discovered_reachable [THEN make_invar_thm]", "lemma stack_reachable: \"set (stack s) \\<subseteq> reachable\"", "lemmas discovered_closed = i_discovered_closed[THEN make_invar_thm]", "lemmas discovered_finite[simp, intro!] = i_discovered_finite[THEN make_invar_thm]", "lemma finished_finite[simp, intro!]: \"finite (dom (finished s))\"", "lemma finished_closed:\n    \"E `` dom (finished s) \\<subseteq> dom (discovered s)\"", "lemma finished_imp_succ_discovered:\n    \"v \\<in> dom (finished s) \\<Longrightarrow> w \\<in> succ v \\<Longrightarrow> w \\<in> dom (discovered s)\"", "lemma pending_reachable: \"pending s \\<subseteq> reachable \\<times> reachable\"", "lemma pending_finite[simp, intro!]: \"finite (pending s)\"", "lemma no_pending_imp_succ_discovered:\n    assumes \"u \\<in> dom (discovered s)\"\n    and \"pending s `` {u} = {}\"\n    and \"v \\<in> succ u\"\n    shows \"v \\<in> dom (discovered s)\"", "lemma nc_finished_eq_reachable:\n    assumes NC: \"\\<not>cond s\" \"\\<not>is_break param s\" \n    shows \"dom (finished s) = reachable\"", "lemma nc_V0_finished:\n    assumes NC: \"\\<not> cond s\" \"\\<not> is_break param s\"\n    shows \"V0 \\<subseteq> dom (finished s)\"", "lemma nc_discovered_eq_finished:\n    assumes NC: \"\\<not> cond s\" \"\\<not> is_break param s\"\n    shows \"dom (discovered s) = dom (finished s)\"", "lemma nc_discovered_eq_reachable:\n    assumes NC: \"\\<not> cond s\" \"\\<not> is_break param s\"\n    shows \"dom (discovered s) = reachable\"", "lemma nc_fin_closed: \n    assumes NC: \"\\<not>cond s\"\n    assumes NB: \"\\<not>is_break param s\"\n    shows \"E``dom (finished s) \\<subseteq> dom (finished s)\"", "lemma param_dfs_variant_wf[simp, intro!]:\n    assumes [simp, intro!]: \"finite reachable\"\n    shows \"wf param_dfs_variant\"", "lemma param_dfs_variant_step:   \n    assumes A: \"DFS_invar G param s\" \"cond s\" \"nofail it_dfs\"\n    shows \"step s \\<le> SPEC (\\<lambda>s'. (s',s)\\<in>param_dfs_variant)\"", "lemma it_dfsT_eq_it_dfs:\n    assumes [simp, intro!]: \"finite reachable\"\n    shows \"it_dfsT = it_dfs\"", "lemmas nofails = nofail_on_init nofail_on_new_root nofail_on_finish \n    nofail_on_cross_edge nofail_on_back_edge nofail_on_discover", "lemma init_leof_invar: \"init \\<le>\\<^sub>n SPEC (DFS_invar G param)\"", "lemma it_dfs_eq_spec: \"it_dfs = SPEC (\\<lambda>s. DFS_invar G param s \\<and> \\<not>cond s)\"", "lemma it_dfs_correct: \"it_dfs \\<le> SPEC (\\<lambda>s. DFS_invar G param s \\<and> \\<not>cond s)\"", "lemma it_dfs_SPEC:\n    assumes \"\\<And>s. \\<lbrakk>DFS_invar G param s; \\<not>cond s\\<rbrakk> \\<Longrightarrow> P s\"\n    shows \"it_dfs \\<le> SPEC P\"", "lemma it_dfsT_correct: \n    assumes \"finite reachable\"\n    shows \"it_dfsT \\<le> SPEC (\\<lambda>s. DFS_invar G param s \\<and> \\<not>cond s)\"", "lemma it_dfsT_SPEC:\n    assumes \"finite reachable\"\n    assumes \"\\<And>s. \\<lbrakk>DFS_invar G param s; \\<not>cond s\\<rbrakk> \\<Longrightarrow> P s\"\n    shows \"it_dfsT \\<le> SPEC P\""], "translations": [["", "lemmas dflt_parametrization_simp[simp] =\n  gen_parameterization.simps[mk_record_simp, OF dflt_parametrization_def]"], ["", "text \\<open>This locale builds a DFS algorithm from a graph and a parameterization.\\<close>"], ["", "locale param_DFS_defs =\n  graph_defs G\n  for G :: \"('v, 'more) graph_rec_scheme\"\n  +\n  fixes param :: \"('v,'es) parameterization\"\nbegin"], ["", "subsection \\<open>DFS operations\\<close>"], ["", "subsubsection \\<open>Node predicates\\<close>"], ["", "text \\<open>First, we define some predicates to check whether nodes are in certain sets\\<close>"], ["", "definition is_discovered :: \"'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> bool\"\n    where \"is_discovered u s \\<equiv> u \\<in> dom (discovered s)\""], ["", "definition is_finished :: \"'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> bool\"\n    where \"is_finished u s \\<equiv> u \\<in> dom (finished s)\""], ["", "definition is_empty_stack :: \"('v,'es) state_scheme \\<Rightarrow> bool\"\n    where \"is_empty_stack s \\<equiv> stack s = []\""], ["", "(*definition top_pending :: \"('v,'es) state_scheme \\<Rightarrow> 'v \\<times> 'v set\" where\n    \"top_pending s \\<equiv> (hd (stack s), pending s `` {hd (stack s)})\"*)"], ["", "subsubsection \\<open>Effects on Basic State\\<close>"], ["", "text \\<open>We define the effect of the operations on the basic part of the state\\<close>"], ["", "definition discover \n    :: \"'v \\<Rightarrow> 'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> ('v,'es) state_scheme\"\n  where\n  \"discover u v s \\<equiv> let\n    d = (discovered s)(v \\<mapsto> counter s); c = counter s + 1;\n    st = v#stack s;\n    p = pending s \\<union> {v} \\<times> E``{v};\n    t = insert (u,v) (tree_edges s)\n  in s\\<lparr> discovered := d, counter := c, stack := st, pending := p, tree_edges := t\\<rparr>\""], ["", "lemma discover_simps[simp]:\n    \"counter (discover u v s) = Suc (counter s)\"\n    \"discovered (discover u v s) = (discovered s)(v \\<mapsto> counter s)\" \n    \"finished (discover u v s) = finished s\"\n    \"stack (discover u v s) = v#stack s\"\n    \"pending (discover u v s) = pending s \\<union> {v} \\<times> E``{v}\"\n    \"tree_edges (discover u v s) = insert (u,v) (tree_edges s)\"\n    \"cross_edges (discover u v s) = cross_edges s\"\n    \"back_edges (discover u v s) = back_edges s\"\n    \"state.more (discover u v s) = state.more s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((counter (discover u v s) = Suc (counter s) &&&\n      discovered (discover u v s) = discovered s(v \\<mapsto> counter s)) &&&\n     finished (discover u v s) = finished s &&&\n     stack (discover u v s) = v # stack s) &&&\n    (pending (discover u v s) = pending s \\<union> {v} \\<times> E `` {v} &&&\n     tree_edges (discover u v s) = insert (u, v) (tree_edges s)) &&&\n    cross_edges (discover u v s) = cross_edges s &&&\n    back_edges (discover u v s) = back_edges s &&&\n    state.more (discover u v s) = state.more s", "by (simp_all add: discover_def)"], ["", "definition finish \n    :: \"'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> ('v,'es) state_scheme\" \n  where\n  \"finish u s \\<equiv> let\n    f = (finished s)(u \\<mapsto> counter s); c = counter s + 1;\n    st = tl (stack s)\n  in s\\<lparr> finished := f, counter := c, stack := st\\<rparr>\""], ["", "lemma finish_simps[simp]:\n    \"counter (finish u s) = Suc (counter s)\"\n    \"discovered (finish u s) = discovered s\"\n    \"finished (finish u s) = (finished s)(u \\<mapsto> counter s)\"\n    \"stack (finish u s) = tl (stack s)\"\n    \"pending (finish u s) = pending s\"\n    \"tree_edges (finish u s) = tree_edges s\"\n    \"cross_edges (finish u s) = cross_edges s\"\n    \"back_edges (finish u s) = back_edges s\"\n    \"state.more (finish u s) = state.more s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((counter (finish u s) = Suc (counter s) &&&\n      discovered (finish u s) = discovered s) &&&\n     finished (finish u s) = finished s(u \\<mapsto> counter s) &&&\n     stack (finish u s) = tl (stack s)) &&&\n    (pending (finish u s) = pending s &&&\n     tree_edges (finish u s) = tree_edges s) &&&\n    cross_edges (finish u s) = cross_edges s &&&\n    back_edges (finish u s) = back_edges s &&&\n    state.more (finish u s) = state.more s", "by (simp_all add: finish_def)"], ["", "definition back_edge\n    :: \"'v \\<Rightarrow> 'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> ('v,'es) state_scheme\"\n  where\n  \"back_edge u v s \\<equiv> let\n    b = insert (u,v) (back_edges s)\n   in s\\<lparr> back_edges := b \\<rparr>\""], ["", "lemma back_edge_simps[simp]:\n    \"counter (back_edge u v s) = counter s\"\n    \"discovered (back_edge u v s) = discovered s\"\n    \"finished (back_edge u v s) = finished s\"\n    \"stack (back_edge u v s) = stack s\"\n    \"pending (back_edge u v s) = pending s\"\n    \"tree_edges (back_edge u v s) = tree_edges s\"\n    \"cross_edges (back_edge u v s) = cross_edges s\"\n    \"back_edges (back_edge u v s) = insert (u,v) (back_edges s)\"\n    \"state.more (back_edge u v s) = state.more s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((counter (back_edge u v s) = counter s &&&\n      discovered (back_edge u v s) = discovered s) &&&\n     finished (back_edge u v s) = finished s &&&\n     stack (back_edge u v s) = stack s) &&&\n    (pending (back_edge u v s) = pending s &&&\n     tree_edges (back_edge u v s) = tree_edges s) &&&\n    cross_edges (back_edge u v s) = cross_edges s &&&\n    back_edges (back_edge u v s) = insert (u, v) (back_edges s) &&&\n    state.more (back_edge u v s) = state.more s", "by (simp_all add: back_edge_def)"], ["", "definition cross_edge\n    :: \"'v \\<Rightarrow> 'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> ('v,'es) state_scheme\"\n  where\n  \"cross_edge u v s \\<equiv> let\n    c = insert (u,v) (cross_edges s)\n   in s\\<lparr> cross_edges := c \\<rparr>\""], ["", "lemma cross_edge_simps[simp]:\n    \"counter (cross_edge u v s) = counter s\"\n    \"discovered (cross_edge u v s) = discovered s\"\n    \"finished (cross_edge u v s) = finished s\"\n    \"stack (cross_edge u v s) = stack s\"\n    \"pending (cross_edge u v s) = pending s\"\n    \"tree_edges (cross_edge u v s) = tree_edges s\"\n    \"cross_edges (cross_edge u v s) = insert (u,v) (cross_edges s)\"\n    \"back_edges (cross_edge u v s) = back_edges s\"\n    \"state.more (cross_edge u v s) = state.more s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((counter (cross_edge u v s) = counter s &&&\n      discovered (cross_edge u v s) = discovered s) &&&\n     finished (cross_edge u v s) = finished s &&&\n     stack (cross_edge u v s) = stack s) &&&\n    (pending (cross_edge u v s) = pending s &&&\n     tree_edges (cross_edge u v s) = tree_edges s) &&&\n    cross_edges (cross_edge u v s) = insert (u, v) (cross_edges s) &&&\n    back_edges (cross_edge u v s) = back_edges s &&&\n    state.more (cross_edge u v s) = state.more s", "by (simp_all add: cross_edge_def)"], ["", "definition new_root\n    :: \"'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> ('v,'es) state_scheme\"\n  where\n    \"new_root v0 s \\<equiv> let\n       c = Suc (counter s);\n       d = (discovered s)(v0 \\<mapsto> counter s);\n       p = {v0}\\<times>E``{v0};\n       st = [v0]\n     in s\\<lparr>counter := c, discovered := d, pending := p, stack := st\\<rparr>\""], ["", "lemma new_root_simps[simp]:\n    \"counter (new_root v0 s) = Suc (counter s)\"\n    \"discovered (new_root v0 s) = (discovered s)(v0 \\<mapsto> counter s)\"\n    \"finished (new_root v0 s) = finished s\"\n    \"stack (new_root v0 s) = [v0]\"\n    \"pending (new_root v0 s) = ({v0}\\<times>E``{v0})\"\n    \"tree_edges (new_root v0 s) = tree_edges s\"\n    \"cross_edges (new_root v0 s) = cross_edges s\"\n    \"back_edges (new_root v0 s) = back_edges s\"\n    \"state.more (new_root v0 s) = state.more s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((counter (new_root v0 s) = Suc (counter s) &&&\n      discovered (new_root v0 s) = discovered s(v0 \\<mapsto> counter s)) &&&\n     finished (new_root v0 s) = finished s &&&\n     stack (new_root v0 s) = [v0]) &&&\n    (pending (new_root v0 s) = {v0} \\<times> E `` {v0} &&&\n     tree_edges (new_root v0 s) = tree_edges s) &&&\n    cross_edges (new_root v0 s) = cross_edges s &&&\n    back_edges (new_root v0 s) = back_edges s &&&\n    state.more (new_root v0 s) = state.more s", "by (simp_all add: new_root_def)"], ["", "definition \"empty_state e\n    \\<equiv> \\<lparr> counter = 0,\n         discovered = Map.empty,\n         finished = Map.empty,\n         pending = {},\n         stack = [],\n         tree_edges = {},\n         back_edges = {},\n         cross_edges = {},\n         \\<dots> = e \\<rparr>\""], ["", "lemma empty_state_simps[simp]:\n    \"counter (empty_state e) = 0\"\n    \"discovered (empty_state e) = Map.empty\"\n    \"finished (empty_state e) = Map.empty\"\n    \"pending (empty_state e) = {}\"\n    \"stack (empty_state e) = []\"\n    \"tree_edges (empty_state e) = {}\"\n    \"back_edges (empty_state e) = {}\"\n    \"cross_edges (empty_state e) = {}\"\n    \"state.more (empty_state e) = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((counter (empty_state e) = 0 &&&\n      discovered (empty_state e) = Map.empty) &&&\n     finished (empty_state e) = Map.empty &&&\n     pending (empty_state e) = {}) &&&\n    (stack (empty_state e) = [] &&& tree_edges (empty_state e) = {}) &&&\n    back_edges (empty_state e) = {} &&&\n    cross_edges (empty_state e) = {} &&& state.more (empty_state e) = e", "by (simp_all add: empty_state_def)"], ["", "subsubsection \\<open>Effects on Whole State\\<close>"], ["", "text \\<open>The effects of the operations on the whole state are defined by \n    combining the effects of the basic state with the parameterization.\\<close>"], ["", "definition do_cross_edge\n    :: \"'v \\<Rightarrow> 'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> ('v,'es) state_scheme nres\"\n  where\n  \"do_cross_edge u v s \\<equiv> do {\n      let s = cross_edge u v s;\n      e \\<leftarrow> on_cross_edge param u v s;\n      RETURN (s\\<lparr>state.more := e\\<rparr>)\n    }\""], ["", "definition do_back_edge\n    :: \"'v \\<Rightarrow> 'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> ('v,'es) state_scheme nres\"\n  where\n  \"do_back_edge u v s \\<equiv> do {\n      let s = back_edge u v s;\n      e \\<leftarrow> on_back_edge param u v s;\n      RETURN (s\\<lparr>state.more := e\\<rparr>)\n    }\""], ["", "definition do_known_edge\n    :: \"'v \\<Rightarrow> 'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> ('v,'es) state_scheme nres\"\n  where\n  \"do_known_edge u v s \\<equiv> \n    if is_finished v s then \n      do_cross_edge u v s \n    else \n      do_back_edge u v s\""], ["", "definition do_discover\n    :: \"'v \\<Rightarrow> 'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> ('v,'es) state_scheme nres\"\n  where\n  \"do_discover u v s \\<equiv> do {\n    let s = discover u v s;\n    e \\<leftarrow> on_discover param u v s;\n    RETURN (s\\<lparr>state.more := e\\<rparr>)\n  }\""], ["", "definition do_finish\n    :: \"'v \\<Rightarrow> ('v,'es) state_scheme \\<Rightarrow> ('v,'es) state_scheme nres\"\n  where\n  \"do_finish u s \\<equiv> do {\n    let s = finish u s;\n    e \\<leftarrow> on_finish param u s;\n    RETURN (s\\<lparr>state.more := e\\<rparr>)\n  }\""], ["", "definition get_new_root where\n    \"get_new_root s \\<equiv> SPEC (\\<lambda>v. v\\<in>V0 \\<and> \\<not>is_discovered v s)\""], ["", "definition do_new_root where \n  \"do_new_root v0 s \\<equiv> do {\n    let s = new_root v0 s;\n    e \\<leftarrow> on_new_root param v0 s;\n    RETURN (s\\<lparr>state.more := e\\<rparr>)\n  }\""], ["", "lemmas op_defs = discover_def finish_def back_edge_def cross_edge_def new_root_def"], ["", "lemmas do_defs = do_discover_def do_finish_def do_known_edge_def\n    do_cross_edge_def do_back_edge_def do_new_root_def"], ["", "lemmas pred_defs = is_discovered_def is_finished_def is_empty_stack_def"], ["", "definition \"init \\<equiv> do {\n    e \\<leftarrow> on_init param;\n    RETURN (empty_state e)\n  }\""], ["", "subsection \\<open>DFS Algorithm\\<close>"], ["", "text \\<open>We phrase the DFS algorithm iteratively:\n    While there are undiscovered root nodes or the stack is not empty,\n      inspect the topmost node on the stack: \n        Follow any pending edge, or finish the node if there \n        are no pending edges left.\n\n    \\<close>"], ["", "definition cond :: \"('v,'es) state_scheme \\<Rightarrow> bool\" where\n    \"cond s \\<longleftrightarrow> (V0 \\<subseteq> {v. is_discovered v s} \\<longrightarrow> \\<not>is_empty_stack s) \n      \\<and> \\<not>is_break param s\""], ["", "lemma cond_alt:\n    \"cond = (\\<lambda>s. (V0 \\<subseteq> dom (discovered s) \\<longrightarrow> stack s \\<noteq> []) \\<and> \\<not>is_break param s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond =\n    (\\<lambda>s.\n        (V0 \\<subseteq> dom (discovered s) \\<longrightarrow>\n         stack s \\<noteq> []) \\<and>\n        \\<not> is_break param s)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       cond s =\n       ((V0 \\<subseteq> dom (discovered s) \\<longrightarrow>\n         stack s \\<noteq> []) \\<and>\n        \\<not> is_break param s)", "unfolding cond_def is_discovered_def is_empty_stack_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       ((V0 \\<subseteq> {v. v \\<in> dom (discovered s)} \\<longrightarrow>\n         stack s \\<noteq> []) \\<and>\n        \\<not> is_break param s) =\n       ((V0 \\<subseteq> dom (discovered s) \\<longrightarrow>\n         stack s \\<noteq> []) \\<and>\n        \\<not> is_break param s)", "by auto"], ["", "definition get_pending ::\n    \"('v, 'es) state_scheme \\<Rightarrow> ('v \\<times> 'v option \\<times> ('v, 'es) state_scheme) nres\" \n    \\<comment> \\<open>Get topmost stack node and a pending edge if any. The pending\n          edge is removed.\\<close>\n  where \"get_pending s \\<equiv> do {\n    let u = hd (stack s);\n    let Vs = pending s `` {u};\n\n    if Vs = {} then\n      RETURN (u,None,s)\n    else do {\n      v \\<leftarrow> RES Vs;\n      let s = s\\<lparr> pending := pending s - {(u,v)}\\<rparr>;\n      RETURN (u,Some v,s)\n    }\n  }\""], ["", "definition step :: \"('v,'es) state_scheme \\<Rightarrow> ('v,'es) state_scheme nres\" \n  where\n    \"step s \\<equiv> \n      if is_empty_stack s then do {\n        v0 \\<leftarrow> get_new_root s;\n        do_new_root v0 s\n      } else do {\n        (u,Vs,s) \\<leftarrow> get_pending s;\n        case Vs of \n          None \\<Rightarrow> do_finish u s \n        | Some v \\<Rightarrow> do {\n          if is_discovered v s then \n            do_known_edge u v s\n          else \n            do_discover u v s\n        }\n      }\""], ["", "definition \"it_dfs \\<equiv> init \\<bind> WHILE cond step\""], ["", "definition \"it_dfsT \\<equiv> init \\<bind> WHILET cond step\""], ["", "end"], ["", "subsection \\<open>Invariants\\<close>"], ["", "text \\<open>We now build the infrastructure for establishing invariants \n  of DFS algorithms. The infrastructure is modular and extensible, i.e., \n  we can define re-usable libraries of invariants.\n\\<close>"], ["", "text \\<open>For technical reasons, invariants are established in a two-step process:\n  \\<^enum> First, we prove the invariant wrt. the parameterization in the \\<open>param_DFS\\<close> locale.\n  \\<^enum> Next, we transfer the invariant to the \\<open>DFS_invar\\<close>-locale.\n\\<close>"], ["", "(* This locale is required to establish new invariants.\n  We would like to directly establish new invariants in the \n  DFS_invar-locale, unfortunately this causes technical problems:\n  When interpreting the DFS_invar locale in a proof inside the \n  DFS_invar-locale itself, we get \"duplicate constant\" warnings,\n  unless we prefix the interpreted locale, which may be quite confusing\n  in a proof, as the user has to choose the prefixed lemmas, while the\n  unprefixed ones are also available, but for the wrong state.\n *)"], ["", "locale param_DFS =\n  fb_graph G + param_DFS_defs G param\n  for G :: \"('v, 'more) graph_rec_scheme\"\n  and param :: \"('v,'es) parameterization\"\nbegin"], ["", "definition is_invar :: \"(('v, 'es) state_scheme \\<Rightarrow> bool) \\<Rightarrow> bool\"\n    \\<comment> \\<open>Predicate that states that @{term I} is an invariant.\\<close>\n    where \"is_invar I \\<equiv> is_rwof_invar init cond step I\""], ["", "end"], ["", "text \\<open>Invariants are transferred to this locale, which is parameterized\n  with a state. \\<close>"], ["", "locale DFS_invar =\n  param_DFS G param\n  for G :: \"('v, 'more) graph_rec_scheme\"\n  and param :: \"('v,'es) parameterization\"\n  +\n  fixes s :: \"('v,'es) state_scheme\"\n  assumes rwof: \"rwof init cond step s\"\nbegin"], ["", "lemma make_invar_thm: \"is_invar I \\<Longrightarrow> I s\"\n    \\<comment> \\<open>Lemma to transfer an invariant into this locale\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar I \\<Longrightarrow> I s", "using rwof_cons[OF _ rwof, folded is_invar_def]"], ["proof (prove)\nusing this:\n  is_invar ?I \\<Longrightarrow> ?I s\n\ngoal (1 subgoal):\n 1. is_invar I \\<Longrightarrow> I s", "."], ["", "end"], ["", "subsubsection \\<open>Establishing Invariants\\<close>"], ["", "context param_DFS\nbegin"], ["", "text \\<open> Include this into refine-rules to discard any information about \n    parameterization \\<close>"], ["", "lemmas indep_invar_rules = \n    leof_True_rule[where m=\"on_init param\"]\n    leof_True_rule[where m=\"on_new_root param v0 s'\" for v0 s']\n    leof_True_rule[where m=\"on_discover param u v s'\" for u v s']\n    leof_True_rule[where m=\"on_finish param v s'\" for v s']\n    leof_True_rule[where m=\"on_cross_edge param u v s'\" for u v s']\n    leof_True_rule[where m=\"on_back_edge param u v s'\" for u v s']"], ["", "lemma rwof_eq_DFS_invar[simp]: \n    \"rwof init cond step = DFS_invar G param\"\n    \\<comment> \\<open>The DFS-invar locale is equivalent to the strongest invariant of the loop.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rwof init cond step = DFS_invar G param", "apply (auto intro: DFS_invar.rwof intro!: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. rwof init cond step x \\<Longrightarrow> DFS_invar G param x", "by unfold_locales"], ["", "lemma DFS_invar_step: \"\\<lbrakk>nofail it_dfs; DFS_invar G param s; cond s\\<rbrakk> \n    \\<Longrightarrow> step s \\<le> SPEC (DFS_invar G param)\"\n    \\<comment> \\<open>A step preserves the (best) invariant.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail it_dfs; DFS_invar G param s; cond s\\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (DFS_invar G param)", "unfolding it_dfs_def rwof_eq_DFS_invar[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail (init \\<bind> WHILE cond step); rwof init cond step s;\n     cond s\\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (rwof init cond step)", "by (rule rwof_step)"], ["", "lemma DFS_invar_step': \"\\<lbrakk>nofail (step s); DFS_invar G param s; cond s\\<rbrakk> \n    \\<Longrightarrow> step s \\<le> SPEC (DFS_invar G param)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail (step s); DFS_invar G param s; cond s\\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (DFS_invar G param)", "unfolding it_dfs_def rwof_eq_DFS_invar[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail (step s); rwof init cond step s; cond s\\<rbrakk>\n    \\<Longrightarrow> step s \\<le> SPEC (rwof init cond step)", "by (rule rwof_step')"], ["", "text \\<open>We define symbolic names for the preconditions of certain operations\\<close>"], ["", "definition \"pre_is_break s \\<equiv> DFS_invar G param s\""], ["", "definition \"pre_on_new_root v0 s' \\<equiv> \\<exists>s.\n    DFS_invar G param s \\<and> cond s \\<and> \n    stack s = [] \\<and> v0 \\<in> V0 \\<and> v0 \\<notin> dom (discovered s) \\<and>\n    s' = new_root v0 s\""], ["", "definition \"pre_on_finish u s' \\<equiv> \\<exists>s.\n    DFS_invar G param s \\<and> cond s \\<and> \n    stack s \\<noteq> [] \\<and> u = hd (stack s) \\<and> pending s `` {u} = {} \\<and> s' = finish u s\""], ["", "definition \"pre_edge_selected u v s \\<equiv> \n    DFS_invar G param s \\<and> cond s \\<and> \n    stack s \\<noteq> [] \\<and> u = hd (stack s) \\<and> (u, v) \\<in> pending s\""], ["", "definition \"pre_on_cross_edge u v s' \\<equiv> \\<exists>s. pre_edge_selected u v s \\<and>\n        v \\<in> dom (discovered s) \\<and> v\\<in>dom (finished s) \n        \\<and> s' = cross_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\""], ["", "definition \"pre_on_back_edge u v s' \\<equiv> \\<exists>s. pre_edge_selected u v s \\<and>\n        v \\<in> dom (discovered s) \\<and> v\\<notin>dom (finished s) \n        \\<and> s' = back_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\""], ["", "definition \"pre_on_discover u v s' \\<equiv> \\<exists>s. pre_edge_selected u v s \\<and>\n        v \\<notin> dom (discovered s) \n        \\<and> s' = discover u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\""], ["", "lemmas pre_on_defs = pre_on_new_root_def pre_on_finish_def \n    pre_edge_selected_def pre_on_cross_edge_def pre_on_back_edge_def\n    pre_on_discover_def pre_is_break_def"], ["", "text \\<open>Next, we define a set of rules to establish an invariant.\\<close>"], ["", "lemma establish_invarI[case_names init new_root finish cross_edge back_edge discover]:\n    \\<comment> \\<open>Establish a DFS invariant (explicit preconditions).\\<close>\n    assumes init: \"on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\"\n    assumes new_root: \"\\<And>s s' v0. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n         \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n \n             SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                         \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes finish: \"\\<And>s s' u. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s \\<noteq> []; u = hd (stack s); \n       pending s `` {u} = {};\n       s' = finish u s\\<rbrakk>\n         \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n \n              SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes cross_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s); v\\<in>dom (finished s);\n        s' = cross_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes back_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s); v\\<notin>dom (finished s);\n        s' = back_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>) \n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes discover: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> [];  (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<notin> dom (discovered s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    shows \"is_invar I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar I", "unfolding is_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rwof_invar init cond step I", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. init \\<le>\\<^sub>n SPEC I\n 2. \\<And>s.\n       \\<lbrakk>rwof init cond step s; I s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I", "show \"init \\<le>\\<^sub>n SPEC I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init \\<le>\\<^sub>n SPEC I", "unfolding init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. on_init param \\<bind> (\\<lambda>e. RETURN (empty_state e)) \\<le>\\<^sub>n\n    SPEC I", "by (refine_rcg refine_vcg) (simp add: init)"], ["proof (state)\nthis:\n  init \\<le>\\<^sub>n SPEC I\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof init cond step s; I s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof init cond step s; I s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof init cond step s; I s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I", "assume \"rwof init cond step s\" and IC: \"I s\" \"cond s\""], ["proof (state)\nthis:\n  rwof init cond step s\n  I s\n  cond s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof init cond step s; I s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I", "hence DI: \"DFS_invar G param s\""], ["proof (prove)\nusing this:\n  rwof init cond step s\n  I s\n  cond s\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by unfold_locales"], ["proof (state)\nthis:\n  DFS_invar G param s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof init cond step s; I s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I", "then"], ["proof (chain)\npicking this:\n  DFS_invar G param s", "interpret DFS_invar G param s"], ["proof (prove)\nusing this:\n  DFS_invar G param s\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof init cond step s; I s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I", "from \\<open>cond s\\<close>"], ["proof (chain)\npicking this:\n  cond s", "have IB: \"\\<not> is_break param s\""], ["proof (prove)\nusing this:\n  cond s\n\ngoal (1 subgoal):\n 1. \\<not> is_break param s", "by (simp add: cond_def)"], ["proof (state)\nthis:\n  \\<not> is_break param s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof init cond step s; I s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I", "have B: \"step s \\<le>\\<^sub>n SPEC (DFS_invar G param)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step s \\<le>\\<^sub>n SPEC (DFS_invar G param)", "by rule (metis DFS_invar_step' DI \\<open>cond s\\<close>)"], ["proof (state)\nthis:\n  step s \\<le>\\<^sub>n SPEC (DFS_invar G param)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof init cond step s; I s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I", "note rule_assms = DI IC IB"], ["proof (state)\nthis:\n  DFS_invar G param s\n  I s\n  cond s\n  \\<not> is_break param s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rwof init cond step s; I s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le>\\<^sub>n SPEC I", "show \"step s \\<le>\\<^sub>n SPEC I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step s \\<le>\\<^sub>n SPEC I", "apply (rule leof_use_spec_rule[OF B])"], ["proof (prove)\ngoal (1 subgoal):\n 1. step s \\<le>\\<^sub>n\n    SPEC (\\<lambda>s. DFS_invar G param s \\<longrightarrow> I s)", "unfolding step_def do_defs pred_defs get_pending_def get_new_root_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if stack s = []\n     then SPEC\n           (\\<lambda>v.\n               v \\<in> V0 \\<and> v \\<notin> dom (discovered s)) \\<bind>\n          (\\<lambda>v0.\n              let s = new_root v0 s\n              in on_new_root param v0 s \\<bind>\n                 (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>)))\n     else (let u = hd (stack s); Vs = pending s `` {u}\n           in if Vs = {} then RETURN (u, None, s)\n              else RES Vs \\<bind>\n                   (\\<lambda>v.\n                       let s = s\\<lparr>pending :=\n    pending s - {(u, v)}\\<rparr>\n                       in RETURN (u, Some v, s))) \\<bind>\n          (\\<lambda>(u, Vs, s).\n              case Vs of\n              None \\<Rightarrow>\n                let s = finish u s\n                in on_finish param u s \\<bind>\n                   (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n              | Some v \\<Rightarrow>\n                  if v \\<in> dom (discovered s)\n                  then if v \\<in> dom (finished s)\n                       then let s = cross_edge u v s\n                            in on_cross_edge param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = back_edge u v s\n                            in on_back_edge param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))\n                  else let s = discover u v s\n                       in on_discover param u v s \\<bind>\n                          (\\<lambda>e.\n                              RETURN\n                               (s\\<lparr>state.more :=\n     e\\<rparr>)))) \\<le>\\<^sub>n\n    SPEC (\\<lambda>s. DFS_invar G param s \\<longrightarrow> I s)", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>stack s = [];\n        x \\<in> {v \\<in> V0. v \\<notin> dom (discovered s)}\\<rbrakk>\n       \\<Longrightarrow> on_new_root param x (new_root x s) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              RETURN\n                               (new_root x s\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>s.\n                                   DFS_invar G param s \\<longrightarrow>\n                                   I s))\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n        x2 = (x1a, x2a); (hd (stack s), None, s) = (x1, x2);\n        x1a = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param x1 (finish x1 x2a) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (finish x1 x2a\n                                \\<lparr>state.more :=\n    x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>s.\n                                   DFS_invar G param s \\<longrightarrow>\n                                   I s))\n 3. \\<And>x1 x2 x1a x2a v.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n        x2 = (x1a, x2a); (hd (stack s), None, s) = (x1, x2); x1a = Some v;\n        v \\<in> dom (discovered x2a); v \\<in> dom (finished x2a)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param x1 v\n                          (cross_edge x1 v x2a) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (cross_edge x1 v x2a\n                                \\<lparr>state.more :=\n    x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>s.\n                                   DFS_invar G param s \\<longrightarrow>\n                                   I s))\n 4. \\<And>x1 x2 x1a x2a v.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n        x2 = (x1a, x2a); (hd (stack s), None, s) = (x1, x2); x1a = Some v;\n        v \\<in> dom (discovered x2a); v \\<notin> dom (finished x2a)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param x1 v\n                          (back_edge x1 v x2a) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (back_edge x1 v x2a\n                                \\<lparr>state.more :=\n    x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>s.\n                                   DFS_invar G param s \\<longrightarrow>\n                                   I s))\n 5. \\<And>x1 x2 x1a x2a v.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {hd (stack s)} = {};\n        x2 = (x1a, x2a); (hd (stack s), None, s) = (x1, x2); x1a = Some v;\n        v \\<notin> dom (discovered x2a)\\<rbrakk>\n       \\<Longrightarrow> on_discover param x1 v\n                          (discover x1 v x2a) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (discover x1 v x2a\n                                \\<lparr>state.more :=\n    x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>s.\n                                   DFS_invar G param s \\<longrightarrow>\n                                   I s))\n 6. \\<And>x x1 x2 x1a x2a.\n       \\<lbrakk>stack s \\<noteq> [];\n        pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)}; x2 = (x1a, x2a);\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (x1, x2);\n        x1a = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param x1 (finish x1 x2a) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (finish x1 x2a\n                                \\<lparr>state.more :=\n    x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>s.\n                                   DFS_invar G param s \\<longrightarrow>\n                                   I s))\n 7. \\<And>x x1 x2 x1a x2a v.\n       \\<lbrakk>stack s \\<noteq> [];\n        pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)}; x2 = (x1a, x2a);\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (x1, x2);\n        x1a = Some v; v \\<in> dom (discovered x2a);\n        v \\<in> dom (finished x2a)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param x1 v\n                          (cross_edge x1 v x2a) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (cross_edge x1 v x2a\n                                \\<lparr>state.more :=\n    x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>s.\n                                   DFS_invar G param s \\<longrightarrow>\n                                   I s))\n 8. \\<And>x x1 x2 x1a x2a v.\n       \\<lbrakk>stack s \\<noteq> [];\n        pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)}; x2 = (x1a, x2a);\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (x1, x2);\n        x1a = Some v; v \\<in> dom (discovered x2a);\n        v \\<notin> dom (finished x2a)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param x1 v\n                          (back_edge x1 v x2a) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (back_edge x1 v x2a\n                                \\<lparr>state.more :=\n    x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>s.\n                                   DFS_invar G param s \\<longrightarrow>\n                                   I s))\n 9. \\<And>x x1 x2 x1a x2a v.\n       \\<lbrakk>stack s \\<noteq> [];\n        pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)}; x2 = (x1a, x2a);\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (x1, x2);\n        x1a = Some v; v \\<notin> dom (discovered x2a)\\<rbrakk>\n       \\<Longrightarrow> on_discover param x1 v\n                          (discover x1 v x2a) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              RETURN\n                               (discover x1 v x2a\n                                \\<lparr>state.more :=\n    x\\<rparr>) \\<le>\\<^sub>n\n                              SPEC\n                               (\\<lambda>s.\n                                   DFS_invar G param s \\<longrightarrow>\n                                   I s))", "apply (simp_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>stack s = [];\n        x \\<in> V0 \\<and> x \\<notin> dom (discovered s)\\<rbrakk>\n       \\<Longrightarrow> on_new_root param x (new_root x s) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (new_root x s\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (new_root x s\n                                 \\<lparr>state.more := xa\\<rparr>))\n 2. \\<And>x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} = {}; x2 = (None, s);\n        hd (stack s) = x1; x1a = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param x1 (finish x1 s) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (finish x1 s\n                                \\<lparr>state.more :=\n    x\\<rparr>) \\<longrightarrow>\n                              I (finish x1 s\n                                 \\<lparr>state.more := x\\<rparr>))\n 3. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x; x \\<in> dom (discovered s);\n        x \\<in> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param x1 x\n                          (cross_edge x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (cross_edge x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (cross_edge x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))\n 4. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x; x \\<in> dom (discovered s);\n        x \\<notin> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param x1 x\n                          (back_edge x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (back_edge x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (back_edge x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))\n 5. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x;\n        x \\<notin> dom (discovered s)\\<rbrakk>\n       \\<Longrightarrow> on_discover param x1 x\n                          (discover x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (discover x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (discover x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))", "apply (blast intro: new_root[OF rule_assms])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} = {}; x2 = (None, s);\n        hd (stack s) = x1; x1a = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param x1 (finish x1 s) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (finish x1 s\n                                \\<lparr>state.more :=\n    x\\<rparr>) \\<longrightarrow>\n                              I (finish x1 s\n                                 \\<lparr>state.more := x\\<rparr>))\n 2. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x; x \\<in> dom (discovered s);\n        x \\<in> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param x1 x\n                          (cross_edge x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (cross_edge x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (cross_edge x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))\n 3. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x; x \\<in> dom (discovered s);\n        x \\<notin> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param x1 x\n                          (back_edge x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (back_edge x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (back_edge x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))\n 4. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x;\n        x \\<notin> dom (discovered s)\\<rbrakk>\n       \\<Longrightarrow> on_discover param x1 x\n                          (discover x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (discover x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (discover x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))", "apply (blast intro: finish[OF rule_assms])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x; x \\<in> dom (discovered s);\n        x \\<in> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param x1 x\n                          (cross_edge x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (cross_edge x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (cross_edge x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))\n 2. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x; x \\<in> dom (discovered s);\n        x \\<notin> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param x1 x\n                          (back_edge x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (back_edge x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (back_edge x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))\n 3. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x;\n        x \\<notin> dom (discovered s)\\<rbrakk>\n       \\<Longrightarrow> on_discover param x1 x\n                          (discover x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (discover x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (discover x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))", "apply (rule cross_edge[OF rule_assms], auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x; x \\<in> dom (discovered s);\n        x \\<notin> dom (finished s)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param x1 x\n                          (back_edge x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (back_edge x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (back_edge x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))\n 2. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x;\n        x \\<notin> dom (discovered s)\\<rbrakk>\n       \\<Longrightarrow> on_discover param x1 x\n                          (discover x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (discover x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (discover x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))", "apply (rule back_edge[OF rule_assms], auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2 x1a.\n       \\<lbrakk>stack s \\<noteq> []; pending s `` {x1} \\<noteq> {};\n        (x1, x) \\<in> pending s;\n        x2 = (Some x, s\\<lparr>pending := pending s - {(x1, x)}\\<rparr>);\n        hd (stack s) = x1; x1a = Some x;\n        x \\<notin> dom (discovered s)\\<rbrakk>\n       \\<Longrightarrow> on_discover param x1 x\n                          (discover x1 x\n                            (s\\<lparr>pending :=\n  pending s - {(x1, x)}\\<rparr>)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>xa.\n                              DFS_invar G param\n                               (discover x1 x\n                                 (s\\<lparr>pending :=\n       pending s - {(x1, x)}\\<rparr>)\n                                \\<lparr>state.more :=\n    xa\\<rparr>) \\<longrightarrow>\n                              I (discover x1 x\n                                  (s\\<lparr>pending :=\n        pending s - {(x1, x)}\\<rparr>)\n                                 \\<lparr>state.more := xa\\<rparr>))", "apply (rule discover[OF rule_assms], auto) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  step s \\<le>\\<^sub>n SPEC I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma establish_invarI'[case_names init new_root finish cross_edge back_edge discover]:\n    \\<comment> \\<open>Establish a DFS invariant (symbolic preconditions).\\<close>\n    assumes init: \"on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\"\n    assumes new_root: \"\\<And>s' v0. pre_on_new_root v0 s'\n         \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n \n             SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                         \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes finish: \"\\<And>s' u. pre_on_finish u s' \n         \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n \n              SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes cross_edge: \"\\<And>s' u v. pre_on_cross_edge u v s'\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes back_edge: \"\\<And>s' u v. pre_on_back_edge u v s'\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>) \n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes discover: \"\\<And>s' u v. pre_on_discover u v s'\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    shows \"is_invar I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar I", "apply (rule establish_invarI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "using assms"], ["proof (prove)\nusing this:\n  on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n  pre_on_new_root ?v0.1 ?s'1 \\<Longrightarrow>\n  on_new_root param ?v0.1 ?s'1 \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (?s'1\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (?s'1\\<lparr>state.more := x\\<rparr>))\n  pre_on_finish ?u1 ?s'1 \\<Longrightarrow>\n  on_finish param ?u1 ?s'1 \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (?s'1\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (?s'1\\<lparr>state.more := x\\<rparr>))\n  pre_on_cross_edge ?u1 ?v1 ?s'1 \\<Longrightarrow>\n  on_cross_edge param ?u1 ?v1 ?s'1 \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (?s'1\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (?s'1\\<lparr>state.more := x\\<rparr>))\n  pre_on_back_edge ?u1 ?v1 ?s'1 \\<Longrightarrow>\n  on_back_edge param ?u1 ?v1 ?s'1 \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (?s'1\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (?s'1\\<lparr>state.more := x\\<rparr>))\n  pre_on_discover ?u1 ?v1 ?s'1 \\<Longrightarrow>\n  on_discover param ?u1 ?v1 ?s'1 \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (?s'1\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (?s'1\\<lparr>state.more := x\\<rparr>))\n\ngoal (6 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "unfolding pre_on_defs"], ["proof (prove)\nusing this:\n  on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n  \\<exists>s.\n     DFS_invar G param s \\<and>\n     cond s \\<and>\n     stack s = [] \\<and>\n     ?v0.1 \\<in> V0 \\<and>\n     ?v0.1 \\<notin> dom (discovered s) \\<and>\n     ?s'1 = new_root ?v0.1 s \\<Longrightarrow>\n  on_new_root param ?v0.1 ?s'1 \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (?s'1\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (?s'1\\<lparr>state.more := x\\<rparr>))\n  \\<exists>s.\n     DFS_invar G param s \\<and>\n     cond s \\<and>\n     stack s \\<noteq> [] \\<and>\n     ?u1 = hd (stack s) \\<and>\n     pending s `` {?u1} = {} \\<and> ?s'1 = finish ?u1 s \\<Longrightarrow>\n  on_finish param ?u1 ?s'1 \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (?s'1\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (?s'1\\<lparr>state.more := x\\<rparr>))\n  \\<exists>s.\n     (DFS_invar G param s \\<and>\n      cond s \\<and>\n      stack s \\<noteq> [] \\<and>\n      ?u1 = hd (stack s) \\<and> (?u1, ?v1) \\<in> pending s) \\<and>\n     ?v1 \\<in> dom (discovered s) \\<and>\n     ?v1 \\<in> dom (finished s) \\<and>\n     ?s'1 =\n     cross_edge ?u1 ?v1\n      (s\\<lparr>pending :=\n                  pending s - {(?u1, ?v1)}\\<rparr>) \\<Longrightarrow>\n  on_cross_edge param ?u1 ?v1 ?s'1 \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (?s'1\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (?s'1\\<lparr>state.more := x\\<rparr>))\n  \\<exists>s.\n     (DFS_invar G param s \\<and>\n      cond s \\<and>\n      stack s \\<noteq> [] \\<and>\n      ?u1 = hd (stack s) \\<and> (?u1, ?v1) \\<in> pending s) \\<and>\n     ?v1 \\<in> dom (discovered s) \\<and>\n     ?v1 \\<notin> dom (finished s) \\<and>\n     ?s'1 =\n     back_edge ?u1 ?v1\n      (s\\<lparr>pending :=\n                  pending s - {(?u1, ?v1)}\\<rparr>) \\<Longrightarrow>\n  on_back_edge param ?u1 ?v1 ?s'1 \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (?s'1\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (?s'1\\<lparr>state.more := x\\<rparr>))\n  \\<exists>s.\n     (DFS_invar G param s \\<and>\n      cond s \\<and>\n      stack s \\<noteq> [] \\<and>\n      ?u1 = hd (stack s) \\<and> (?u1, ?v1) \\<in> pending s) \\<and>\n     ?v1 \\<notin> dom (discovered s) \\<and>\n     ?s'1 =\n     discover ?u1 ?v1\n      (s\\<lparr>pending :=\n                  pending s - {(?u1, ?v1)}\\<rparr>) \\<Longrightarrow>\n  on_discover param ?u1 ?v1 ?s'1 \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (?s'1\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (?s'1\\<lparr>state.more := x\\<rparr>))\n\ngoal (6 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "apply -"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>on_init param \\<le>\\<^sub>n\n             SPEC (\\<lambda>x. I (empty_state x));\n     \\<And>v0 s'.\n        \\<exists>s.\n           DFS_invar G param s \\<and>\n           cond s \\<and>\n           stack s = [] \\<and>\n           v0 \\<in> V0 \\<and>\n           v0 \\<notin> dom (discovered s) \\<and>\n           s' = new_root v0 s \\<Longrightarrow>\n        on_new_root param v0 s' \\<le>\\<^sub>n\n        SPEC\n         (\\<lambda>x.\n             DFS_invar G param\n              (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n             I (s'\\<lparr>state.more := x\\<rparr>));\n     \\<And>u s'.\n        \\<exists>s.\n           DFS_invar G param s \\<and>\n           cond s \\<and>\n           stack s \\<noteq> [] \\<and>\n           u = hd (stack s) \\<and>\n           pending s `` {u} = {} \\<and> s' = finish u s \\<Longrightarrow>\n        on_finish param u s' \\<le>\\<^sub>n\n        SPEC\n         (\\<lambda>x.\n             DFS_invar G param\n              (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n             I (s'\\<lparr>state.more := x\\<rparr>));\n     \\<And>u v s'.\n        \\<exists>s.\n           (DFS_invar G param s \\<and>\n            cond s \\<and>\n            stack s \\<noteq> [] \\<and>\n            u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n           v \\<in> dom (discovered s) \\<and>\n           v \\<in> dom (finished s) \\<and>\n           s' =\n           cross_edge u v\n            (s\\<lparr>pending :=\n                        pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n        on_cross_edge param u v s' \\<le>\\<^sub>n\n        SPEC\n         (\\<lambda>x.\n             DFS_invar G param\n              (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n             I (s'\\<lparr>state.more := x\\<rparr>));\n     \\<And>u v s'.\n        \\<exists>s.\n           (DFS_invar G param s \\<and>\n            cond s \\<and>\n            stack s \\<noteq> [] \\<and>\n            u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n           v \\<in> dom (discovered s) \\<and>\n           v \\<notin> dom (finished s) \\<and>\n           s' =\n           back_edge u v\n            (s\\<lparr>pending :=\n                        pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n        on_back_edge param u v s' \\<le>\\<^sub>n\n        SPEC\n         (\\<lambda>x.\n             DFS_invar G param\n              (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n             I (s'\\<lparr>state.more := x\\<rparr>));\n     \\<And>u v s'.\n        \\<exists>s.\n           (DFS_invar G param s \\<and>\n            cond s \\<and>\n            stack s \\<noteq> [] \\<and>\n            u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n           v \\<notin> dom (discovered s) \\<and>\n           s' =\n           discover u v\n            (s\\<lparr>pending :=\n                        pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n        on_discover param u v s' \\<le>\\<^sub>n\n        SPEC\n         (\\<lambda>x.\n             DFS_invar G param\n              (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n             I (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n    \\<Longrightarrow> on_init param \\<le>\\<^sub>n\n                      SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s;\n        on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x));\n        \\<And>v0 s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s = [] \\<and>\n              v0 \\<in> V0 \\<and>\n              v0 \\<notin> dom (discovered s) \\<and>\n              s' = new_root v0 s \\<Longrightarrow>\n           on_new_root param v0 s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s \\<noteq> [] \\<and>\n              u = hd (stack s) \\<and>\n              pending s `` {u} = {} \\<and> s' = finish u s \\<Longrightarrow>\n           on_finish param u s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<in> dom (finished s) \\<and>\n              s' =\n              cross_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<notin> dom (finished s) \\<and>\n              s' =\n              back_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<notin> dom (discovered s) \\<and>\n              s' =\n              discover u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_discover param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s;\n        on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x));\n        \\<And>v0 s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s = [] \\<and>\n              v0 \\<in> V0 \\<and>\n              v0 \\<notin> dom (discovered s) \\<and>\n              s' = new_root v0 s \\<Longrightarrow>\n           on_new_root param v0 s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s \\<noteq> [] \\<and>\n              u = hd (stack s) \\<and>\n              pending s `` {u} = {} \\<and> s' = finish u s \\<Longrightarrow>\n           on_finish param u s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<in> dom (finished s) \\<and>\n              s' =\n              cross_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<notin> dom (finished s) \\<and>\n              s' =\n              back_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<notin> dom (discovered s) \\<and>\n              s' =\n              discover u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_discover param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>);\n        on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x));\n        \\<And>v0 s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s = [] \\<and>\n              v0 \\<in> V0 \\<and>\n              v0 \\<notin> dom (discovered s) \\<and>\n              s' = new_root v0 s \\<Longrightarrow>\n           on_new_root param v0 s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s \\<noteq> [] \\<and>\n              u = hd (stack s) \\<and>\n              pending s `` {u} = {} \\<and> s' = finish u s \\<Longrightarrow>\n           on_finish param u s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<in> dom (finished s) \\<and>\n              s' =\n              cross_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<notin> dom (finished s) \\<and>\n              s' =\n              back_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<notin> dom (discovered s) \\<and>\n              s' =\n              discover u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_discover param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>);\n        on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x));\n        \\<And>v0 s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s = [] \\<and>\n              v0 \\<in> V0 \\<and>\n              v0 \\<notin> dom (discovered s) \\<and>\n              s' = new_root v0 s \\<Longrightarrow>\n           on_new_root param v0 s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s \\<noteq> [] \\<and>\n              u = hd (stack s) \\<and>\n              pending s `` {u} = {} \\<and> s' = finish u s \\<Longrightarrow>\n           on_finish param u s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<in> dom (finished s) \\<and>\n              s' =\n              cross_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<notin> dom (finished s) \\<and>\n              s' =\n              back_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<notin> dom (discovered s) \\<and>\n              s' =\n              discover u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_discover param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>);\n        on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x));\n        \\<And>v0 s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s = [] \\<and>\n              v0 \\<in> V0 \\<and>\n              v0 \\<notin> dom (discovered s) \\<and>\n              s' = new_root v0 s \\<Longrightarrow>\n           on_new_root param v0 s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s \\<noteq> [] \\<and>\n              u = hd (stack s) \\<and>\n              pending s `` {u} = {} \\<and> s' = finish u s \\<Longrightarrow>\n           on_finish param u s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<in> dom (finished s) \\<and>\n              s' =\n              cross_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<notin> dom (finished s) \\<and>\n              s' =\n              back_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<notin> dom (discovered s) \\<and>\n              s' =\n              discover u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_discover param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s;\n        on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x));\n        \\<And>v0 s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s = [] \\<and>\n              v0 \\<in> V0 \\<and>\n              v0 \\<notin> dom (discovered s) \\<and>\n              s' = new_root v0 s \\<Longrightarrow>\n           on_new_root param v0 s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s \\<noteq> [] \\<and>\n              u = hd (stack s) \\<and>\n              pending s `` {u} = {} \\<and> s' = finish u s \\<Longrightarrow>\n           on_finish param u s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<in> dom (finished s) \\<and>\n              s' =\n              cross_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<notin> dom (finished s) \\<and>\n              s' =\n              back_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<notin> dom (discovered s) \\<and>\n              s' =\n              discover u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_discover param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s;\n        on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x));\n        \\<And>v0 s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s = [] \\<and>\n              v0 \\<in> V0 \\<and>\n              v0 \\<notin> dom (discovered s) \\<and>\n              s' = new_root v0 s \\<Longrightarrow>\n           on_new_root param v0 s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s \\<noteq> [] \\<and>\n              u = hd (stack s) \\<and>\n              pending s `` {u} = {} \\<and> s' = finish u s \\<Longrightarrow>\n           on_finish param u s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<in> dom (finished s) \\<and>\n              s' =\n              cross_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<notin> dom (finished s) \\<and>\n              s' =\n              back_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<notin> dom (discovered s) \\<and>\n              s' =\n              discover u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_discover param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>);\n        on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x));\n        \\<And>v0 s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s = [] \\<and>\n              v0 \\<in> V0 \\<and>\n              v0 \\<notin> dom (discovered s) \\<and>\n              s' = new_root v0 s \\<Longrightarrow>\n           on_new_root param v0 s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s \\<noteq> [] \\<and>\n              u = hd (stack s) \\<and>\n              pending s `` {u} = {} \\<and> s' = finish u s \\<Longrightarrow>\n           on_finish param u s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<in> dom (finished s) \\<and>\n              s' =\n              cross_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<notin> dom (finished s) \\<and>\n              s' =\n              back_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<notin> dom (discovered s) \\<and>\n              s' =\n              discover u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_discover param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>);\n        on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x));\n        \\<And>v0 s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s = [] \\<and>\n              v0 \\<in> V0 \\<and>\n              v0 \\<notin> dom (discovered s) \\<and>\n              s' = new_root v0 s \\<Longrightarrow>\n           on_new_root param v0 s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s \\<noteq> [] \\<and>\n              u = hd (stack s) \\<and>\n              pending s `` {u} = {} \\<and> s' = finish u s \\<Longrightarrow>\n           on_finish param u s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<in> dom (finished s) \\<and>\n              s' =\n              cross_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<notin> dom (finished s) \\<and>\n              s' =\n              back_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<notin> dom (discovered s) \\<and>\n              s' =\n              discover u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_discover param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>);\n        on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x));\n        \\<And>v0 s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s = [] \\<and>\n              v0 \\<in> V0 \\<and>\n              v0 \\<notin> dom (discovered s) \\<and>\n              s' = new_root v0 s \\<Longrightarrow>\n           on_new_root param v0 s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u s'.\n           \\<exists>s.\n              DFS_invar G param s \\<and>\n              cond s \\<and>\n              stack s \\<noteq> [] \\<and>\n              u = hd (stack s) \\<and>\n              pending s `` {u} = {} \\<and> s' = finish u s \\<Longrightarrow>\n           on_finish param u s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<in> dom (finished s) \\<and>\n              s' =\n              cross_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<in> dom (discovered s) \\<and>\n              v \\<notin> dom (finished s) \\<and>\n              s' =\n              back_edge u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>));\n        \\<And>u v s'.\n           \\<exists>s.\n              (DFS_invar G param s \\<and>\n               cond s \\<and>\n               stack s \\<noteq> [] \\<and>\n               u = hd (stack s) \\<and> (u, v) \\<in> pending s) \\<and>\n              v \\<notin> dom (discovered s) \\<and>\n              s' =\n              discover u v\n               (s\\<lparr>pending :=\n                           pending s - {(u, v)}\\<rparr>) \\<Longrightarrow>\n           on_discover param u v s' \\<le>\\<^sub>n\n           SPEC\n            (\\<lambda>x.\n                DFS_invar G param\n                 (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n                I (s'\\<lparr>state.more := x\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "apply (rprems,blast)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma establish_invarI_ND [case_names prereq init new_discover finish cross_edge back_edge]:\n    \\<comment> \\<open>Establish a DFS invariant (new-root and discover cases are combined).\\<close>\n    assumes prereq: \"\\<And>u v s. on_discover param u v s = on_new_root param v s\"\n    assumes init: \"on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\"\n    assumes new_discover: \"\\<And>s s' v. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       v \\<notin> dom (discovered s); \n       discovered s' = (discovered s)(v\\<mapsto>counter s); finished s' = finished s;\n       counter s' = Suc (counter s); stack s' = v#stack s;\n       back_edges s' = back_edges s; cross_edges s' = cross_edges s;\n       tree_edges s' \\<supseteq> tree_edges s;\n       state.more s' = state.more s\\<rbrakk>\n         \\<Longrightarrow> on_new_root param v s' \\<le>\\<^sub>n \n             SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                         \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes finish: \"\\<And>s s' u. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s \\<noteq> []; u = hd (stack s); \n       pending s `` {u} = {};\n       s' = finish u s\\<rbrakk>\n         \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n \n              SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes cross_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s); v\\<in>dom (finished s);\n        s' = cross_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes back_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s); v\\<notin>dom (finished s);\n        s' = back_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>) \n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    shows \"is_invar I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar I", "proof (induct rule: establish_invarI)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "case (new_root s)"], ["proof (state)\nthis:\n  DFS_invar G param s\n  I s\n  cond s\n  \\<not> is_break param s\n  stack s = []\n  v0_ \\<in> V0\n  v0_ \\<notin> dom (discovered s)\n  s'_ = new_root v0_ s\n\ngoal (6 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "thus ?case"], ["proof (prove)\nusing this:\n  DFS_invar G param s\n  I s\n  cond s\n  \\<not> is_break param s\n  stack s = []\n  v0_ \\<in> V0\n  v0_ \\<notin> dom (discovered s)\n  s'_ = new_root v0_ s\n\ngoal (1 subgoal):\n 1. on_new_root param v0_ s'_ \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G param\n          (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         I (s'_\\<lparr>state.more := x\\<rparr>))", "by (auto intro!: new_discover)"], ["proof (state)\nthis:\n  on_new_root param v0_ s'_ \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'_\\<lparr>state.more := x\\<rparr>))\n\ngoal (5 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "case (discover s s' u v)"], ["proof (state)\nthis:\n  DFS_invar G param s\n  I s\n  cond s\n  \\<not> is_break param s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (5 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "hence\n      \"on_new_root param v s' \\<le>\\<^sub>n \n        SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                   \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\""], ["proof (prove)\nusing this:\n  DFS_invar G param s\n  I s\n  cond s\n  \\<not> is_break param s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<notin> dom (discovered s)\n  s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. on_new_root param v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G param\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         I (s'\\<lparr>state.more := x\\<rparr>))", "by (auto intro!: new_discover)"], ["proof (state)\nthis:\n  on_new_root param v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (5 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "with prereq"], ["proof (chain)\npicking this:\n  on_discover param ?u1 ?v1 ?s1 = on_new_root param ?v1 ?s1\n  on_new_root param v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  on_discover param ?u1 ?v1 ?s1 = on_new_root param ?v1 ?s1\n  on_new_root param v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. on_discover param u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G param\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         I (s'\\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  on_discover param u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (4 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "qed fact+"], ["", "(* Variant of establish_invarI, where cross_edge and back_edge are combined *)"], ["", "lemma establish_invarI_CB [case_names prereq init new_root finish cross_back_edge discover]:\n    \\<comment> \\<open>Establish a DFS invariant (cross and back edge cases are combined).\\<close>\n    assumes prereq: \"\\<And>u v s. on_back_edge param u v s = on_cross_edge param u v s\"\n    assumes init: \"on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\"\n    assumes new_root: \"\\<And>s s' v0. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n         \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n \n             SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                         \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes finish: \"\\<And>s s' u. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s \\<noteq> []; u = hd (stack s); \n       pending s `` {u} = {};\n       s' = finish u s\\<rbrakk>\n         \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n \n              SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes cross_back_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s);\n        discovered s' = discovered s; finished s' = finished s;\n        stack s' = stack s; tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u,v)};\n        cross_edges s' \\<union> back_edges s' = cross_edges s \\<union> back_edges s \\<union> {(u,v)};\n        state.more s' = state.more s \\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes discover: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> [];  (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<notin> dom (discovered s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    shows \"is_invar I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar I", "proof (induct rule: establish_invarI)"], ["proof (state)\ngoal (6 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "case cross_edge"], ["proof (state)\nthis:\n  DFS_invar G param s_\n  I s_\n  cond s_\n  \\<not> is_break param s_\n  stack s_ \\<noteq> []\n  (u_, v_) \\<in> pending s_\n  u_ = hd (stack s_)\n  v_ \\<in> dom (discovered s_)\n  v_ \\<in> dom (finished s_)\n  s'_ =\n  cross_edge u_ v_ (s_\\<lparr>pending := pending s_ - {(u_, v_)}\\<rparr>)\n\ngoal (6 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "thus ?case"], ["proof (prove)\nusing this:\n  DFS_invar G param s_\n  I s_\n  cond s_\n  \\<not> is_break param s_\n  stack s_ \\<noteq> []\n  (u_, v_) \\<in> pending s_\n  u_ = hd (stack s_)\n  v_ \\<in> dom (discovered s_)\n  v_ \\<in> dom (finished s_)\n  s'_ =\n  cross_edge u_ v_ (s_\\<lparr>pending := pending s_ - {(u_, v_)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. on_cross_edge param u_ v_ s'_ \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G param\n          (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         I (s'_\\<lparr>state.more := x\\<rparr>))", "by (auto intro!: cross_back_edge)"], ["proof (state)\nthis:\n  on_cross_edge param u_ v_ s'_ \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'_\\<lparr>state.more := x\\<rparr>))\n\ngoal (5 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "case (back_edge s s' u v)"], ["proof (state)\nthis:\n  DFS_invar G param s\n  I s\n  cond s\n  \\<not> is_break param s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (5 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "hence\n      \"on_cross_edge param u v s' \\<le>\\<^sub>n \n             SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                         \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\""], ["proof (prove)\nusing this:\n  DFS_invar G param s\n  I s\n  cond s\n  \\<not> is_break param s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. on_cross_edge param u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G param\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         I (s'\\<lparr>state.more := x\\<rparr>))", "by (auto intro!: cross_back_edge)"], ["proof (state)\nthis:\n  on_cross_edge param u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (5 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "with prereq"], ["proof (chain)\npicking this:\n  on_back_edge param ?u1 ?v1 ?s1 = on_cross_edge param ?u1 ?v1 ?s1\n  on_cross_edge param u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  on_back_edge param ?u1 ?v1 ?s1 = on_cross_edge param ?u1 ?v1 ?s1\n  on_cross_edge param u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. on_back_edge param u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G param\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         I (s'\\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  on_back_edge param u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (4 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "qed fact+"], ["", "(* Variant of establish_invarI, where cross_edge and back_edge, and discover and new_root are combined *)"], ["", "lemma establish_invarI_ND_CB [case_names prereq_ND prereq_CB init new_discover finish cross_back_edge]:\n    \\<comment> \\<open>Establish a DFS invariant (new-root/discover and cross/back-edge cases are combined).\\<close>\n    assumes prereq: \n        \"\\<And>u v s. on_discover param u v s = on_new_root param v s\"\n        \"\\<And>u v s. on_back_edge param u v s = on_cross_edge param u v s\"\n    assumes init: \"on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\"\n    assumes new_discover: \"\\<And>s s' v. \n     \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n      v \\<notin> dom (discovered s); \n      discovered s' = (discovered s)(v\\<mapsto>counter s); finished s' = finished s;\n      counter s' = Suc (counter s); stack s' = v#stack s;\n      back_edges s' = back_edges s; cross_edges s' = cross_edges s;\n      tree_edges s' \\<supseteq> tree_edges s;\n      state.more s' = state.more s\\<rbrakk>\n        \\<Longrightarrow> on_new_root param v s' \\<le>\\<^sub>n \n            SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes finish: \"\\<And>s s' u. \n      \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n       stack s \\<noteq> []; u = hd (stack s); \n       pending s `` {u} = {};\n       s' = finish u s\\<rbrakk>\n         \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n \n              SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                        \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    assumes cross_back_edge: \"\\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s); \n        v \\<in> dom (discovered s);\n        discovered s' = discovered s; finished s' = finished s;\n        stack s' = stack s; tree_edges s' = tree_edges s; counter s' = counter s;\n        pending s' = pending s - {(u,v)};\n        cross_edges s' \\<union> back_edges s' = cross_edges s \\<union> back_edges s \\<union> {(u,v)};\n        state.more s' = state.more s \\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n           SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                      \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\"\n    shows \"is_invar I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar I", "proof (induct rule: establish_invarI_ND)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u v s. on_discover param u v s = on_new_root param v s\n 2. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "case cross_edge"], ["proof (state)\nthis:\n  DFS_invar G param s_\n  I s_\n  cond s_\n  \\<not> is_break param s_\n  stack s_ \\<noteq> []\n  (u_, v_) \\<in> pending s_\n  u_ = hd (stack s_)\n  v_ \\<in> dom (discovered s_)\n  v_ \\<in> dom (finished s_)\n  s'_ =\n  cross_edge u_ v_ (s_\\<lparr>pending := pending s_ - {(u_, v_)}\\<rparr>)\n\ngoal (6 subgoals):\n 1. \\<And>u v s. on_discover param u v s = on_new_root param v s\n 2. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "thus ?case"], ["proof (prove)\nusing this:\n  DFS_invar G param s_\n  I s_\n  cond s_\n  \\<not> is_break param s_\n  stack s_ \\<noteq> []\n  (u_, v_) \\<in> pending s_\n  u_ = hd (stack s_)\n  v_ \\<in> dom (discovered s_)\n  v_ \\<in> dom (finished s_)\n  s'_ =\n  cross_edge u_ v_ (s_\\<lparr>pending := pending s_ - {(u_, v_)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. on_cross_edge param u_ v_ s'_ \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G param\n          (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         I (s'_\\<lparr>state.more := x\\<rparr>))", "by (auto intro!: cross_back_edge)"], ["proof (state)\nthis:\n  on_cross_edge param u_ v_ s'_ \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'_\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'_\\<lparr>state.more := x\\<rparr>))\n\ngoal (5 subgoals):\n 1. \\<And>u v s. on_discover param u v s = on_new_root param v s\n 2. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u v s. on_discover param u v s = on_new_root param v s\n 2. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "case (back_edge s s' u v)"], ["proof (state)\nthis:\n  DFS_invar G param s\n  I s\n  cond s\n  \\<not> is_break param s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (5 subgoals):\n 1. \\<And>u v s. on_discover param u v s = on_new_root param v s\n 2. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "hence\n      \"on_cross_edge param u v s' \\<le>\\<^sub>n \n             SPEC (\\<lambda>x. DFS_invar G param (s'\\<lparr>state.more := x\\<rparr>)\n                         \\<longrightarrow> I (s'\\<lparr>state.more := x\\<rparr>))\""], ["proof (prove)\nusing this:\n  DFS_invar G param s\n  I s\n  cond s\n  \\<not> is_break param s\n  stack s \\<noteq> []\n  (u, v) \\<in> pending s\n  u = hd (stack s)\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. on_cross_edge param u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G param\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         I (s'\\<lparr>state.more := x\\<rparr>))", "by (auto intro!: cross_back_edge)"], ["proof (state)\nthis:\n  on_cross_edge param u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (5 subgoals):\n 1. \\<And>u v s. on_discover param u v s = on_new_root param v s\n 2. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "with prereq"], ["proof (chain)\npicking this:\n  on_discover param ?u1 ?v1 ?s1 = on_new_root param ?v1 ?s1\n  on_back_edge param ?u1 ?v1 ?s1 = on_cross_edge param ?u1 ?v1 ?s1\n  on_cross_edge param u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  on_discover param ?u1 ?v1 ?s1 = on_new_root param ?v1 ?s1\n  on_back_edge param ?u1 ?v1 ?s1 = on_cross_edge param ?u1 ?v1 ?s1\n  on_cross_edge param u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (1 subgoal):\n 1. on_back_edge param u v s' \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         DFS_invar G param\n          (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n         I (s'\\<lparr>state.more := x\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  on_back_edge param u v s' \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>x.\n       DFS_invar G param\n        (s'\\<lparr>state.more := x\\<rparr>) \\<longrightarrow>\n       I (s'\\<lparr>state.more := x\\<rparr>))\n\ngoal (4 subgoals):\n 1. \\<And>u v s. on_discover param u v s = on_new_root param v s\n 2. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 3. \\<And>s s' v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        v \\<notin> dom (discovered s);\n        discovered s' = discovered s(v \\<mapsto> counter s);\n        finished s' = finished s; counter s' = Suc (counter s);\n        stack s' = v # stack s; back_edges s' = back_edges s;\n        cross_edges s' = cross_edges s;\n        tree_edges s \\<subseteq> tree_edges s';\n        state.more s' = state.more s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "qed fact+"], ["", "lemma is_invarI_full [case_names init new_root finish cross_edge back_edge discover]:\n    \\<comment> \\<open>Establish a DFS invariant not taking into account the parameterization.\\<close>\n    assumes init: \"\\<And>e. I (empty_state e)\"\n    assumes new_root: \"\\<And>s s' v0 e. \n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s = []; v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk> \n      \\<Longrightarrow> I s'\"\n    and finish: \"\\<And>s s' u e. \n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s); s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk> \n       \\<Longrightarrow> I s'\"\n    and cross_edge: \"\\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u}; v \\<in> dom (discovered s); \n        v \\<in> dom (finished s);\n        u = hd (stack s); \n        s' = (cross_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>))\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\"\n    and back_edge: \"\\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u}; v \\<in> dom (discovered s); v \\<notin> dom (finished s); \n        u = hd (stack s); \n        s' = (back_edge u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>))\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\"\n    and discover: \"\\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u}; v \\<notin> dom (discovered s); \n        u = hd (stack s); \n        s' = (discover u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>))\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\"\n  shows \"is_invar I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar I", "apply (rule establish_invarI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. on_init param \\<le>\\<^sub>n SPEC (\\<lambda>x. I (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s = []; v0 \\<in> V0; v0 \\<notin> dom (discovered s);\n        s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; u = hd (stack s); pending s `` {u} = {};\n        s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish param u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G param s; I s; cond s; \\<not> is_break param s;\n        stack s \\<noteq> []; (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover param u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G param\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              I (s'\\<lparr>state.more := x\\<rparr>))", "apply (blast intro: indep_invar_rules assms)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_invarI [case_names init new_root finish visited discover]:\n    \\<comment> \\<open>Establish a DFS invariant not taking into account the parameterization, cross/back-edges combined.\\<close>\n    assumes init': \"\\<And>e. I (empty_state e)\"\n    and new_root': \"\\<And>s s' v0 e. \n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s = []; v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk> \n      \\<Longrightarrow> I s'\"\n    and finish': \"\\<And>s s' u e. \n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s); s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk> \n       \\<Longrightarrow> I s'\"\n    and visited': \"\\<And>s s' u v e c b.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u}; v \\<in> dom (discovered s);\n        u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\\<lparr> \n          pending := pending s - {(u,v)},\n          state.more := e, \n          cross_edges := c, \n          back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\"\n    and discover': \"\\<And>s s' u v e.\n       \\<lbrakk>I s; cond s;  DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u}; v \\<notin> dom (discovered s); \n        u = hd (stack s); \n        s' = (discover u v (s\\<lparr>pending := pending s - {(u,v)}\\<rparr>))\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\"\n    shows \"is_invar I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar I", "proof (induct rule: is_invarI_full)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e. I (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s = []; v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 6. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'", "case (cross_edge s s' u v e)"], ["proof (state)\nthis:\n  I s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e\\<rparr>\n\ngoal (6 subgoals):\n 1. \\<And>e. I (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s = []; v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        u = hd (stack s);\n        s' =\n        cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 6. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'", "thus ?case"], ["proof (prove)\nusing this:\n  I s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<in> dom (finished s)\n  u = hd (stack s)\n  s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e\\<rparr>\n\ngoal (1 subgoal):\n 1. I s'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<in> dom (finished s); u = hd (stack s);\n     s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> I s'", "apply (rule visited'[of s s' v u \"insert (u,v) (cross_edges s)\" \"back_edges s\" e])"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<in> dom (finished s); u = hd (stack s);\n     s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> I s\n 2. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<in> dom (finished s); u = hd (stack s);\n     s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> cond s\n 3. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<in> dom (finished s); u = hd (stack s);\n     s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> DFS_invar G param s\n 4. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<in> dom (finished s); u = hd (stack s);\n     s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> DFS_invar G param s'\n 5. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<in> dom (finished s); u = hd (stack s);\n     s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> stack s \\<noteq> []\n 6. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<in> dom (finished s); u = hd (stack s);\n     s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> v \\<in> pending s `` {u}\n 7. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<in> dom (finished s); u = hd (stack s);\n     s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> v \\<in> dom (discovered s)\n 8. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<in> dom (finished s); u = hd (stack s);\n     s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> u = hd (stack s)\n 9. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<in> dom (finished s); u = hd (stack s);\n     s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> cross_edges s\n                      \\<subseteq> insert (u, v) (cross_edges s)\n 10. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n      stack s \\<noteq> []; v \\<in> pending s `` {u};\n      v \\<in> dom (discovered s); v \\<in> dom (finished s);\n      u = hd (stack s);\n      s' = cross_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n      \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n     \\<Longrightarrow> back_edges s \\<subseteq> back_edges s\nA total of 11 subgoals...", "apply clarsimp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  I s'\n\ngoal (5 subgoals):\n 1. \\<And>e. I (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s = []; v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. I (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s = []; v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'", "case (back_edge s s' u v e)"], ["proof (state)\nthis:\n  I s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e. I (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s = []; v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        u = hd (stack s);\n        s' =\n        back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'", "thus ?case"], ["proof (prove)\nusing this:\n  I s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  v \\<in> pending s `` {u}\n  v \\<in> dom (discovered s)\n  v \\<notin> dom (finished s)\n  u = hd (stack s)\n  s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n  \\<lparr>state.more := e\\<rparr>\n\ngoal (1 subgoal):\n 1. I s'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n     u = hd (stack s);\n     s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> I s'", "apply (rule visited'[of s s' v u \"cross_edges s\" \"insert (u,v) (back_edges s)\" e])"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n     u = hd (stack s);\n     s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> I s\n 2. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n     u = hd (stack s);\n     s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> cond s\n 3. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n     u = hd (stack s);\n     s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> DFS_invar G param s\n 4. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n     u = hd (stack s);\n     s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> DFS_invar G param s'\n 5. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n     u = hd (stack s);\n     s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> stack s \\<noteq> []\n 6. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n     u = hd (stack s);\n     s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> v \\<in> pending s `` {u}\n 7. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n     u = hd (stack s);\n     s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> v \\<in> dom (discovered s)\n 8. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n     u = hd (stack s);\n     s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> u = hd (stack s)\n 9. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n     stack s \\<noteq> []; v \\<in> pending s `` {u};\n     v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n     u = hd (stack s);\n     s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n     \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> cross_edges s \\<subseteq> cross_edges s\n 10. \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n      stack s \\<noteq> []; v \\<in> pending s `` {u};\n      v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n      u = hd (stack s);\n      s' = back_edge u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n      \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n     \\<Longrightarrow> back_edges s \\<subseteq> insert (u, v) (back_edges s)\nA total of 11 subgoals...", "apply clarsimp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  I s'\n\ngoal (4 subgoals):\n 1. \\<And>e. I (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s = []; v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>I s; cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> I s'", "qed fact+"], ["", "end"], ["", "subsection \\<open>Basic Invariants\\<close>"], ["", "text \\<open>We establish some basic invariants\\<close>"], ["", "context param_DFS begin"], ["", "(* Establish some invariants *)"], ["", "definition \"basic_invar s \\<equiv>\n    set (stack s) = dom (discovered s) - dom (finished s) \\<and>\n    distinct (stack s) \\<and>\n    (stack s \\<noteq> [] \\<longrightarrow> last (stack s) \\<in> V0) \\<and>\n    dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n    Domain (pending s) \\<subseteq> dom (discovered s) - dom (finished s) \\<and>\n    pending s \\<subseteq> E\""], ["", "lemma i_basic_invar: \"is_invar basic_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar basic_invar", "unfolding basic_invar_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar\n     (\\<lambda>s.\n         set (stack s) = dom (discovered s) - dom (finished s) \\<and>\n         distinct (stack s) \\<and>\n         (stack s \\<noteq> [] \\<longrightarrow>\n          last (stack s) \\<in> V0) \\<and>\n         dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n         Domain (pending s)\n         \\<subseteq> dom (discovered s) - dom (finished s) \\<and>\n         pending s \\<subseteq> E)", "apply (induction rule: is_invarI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>e.\n       set (stack (empty_state e)) =\n       dom (discovered (empty_state e)) -\n       dom (finished (empty_state e)) \\<and>\n       distinct (stack (empty_state e)) \\<and>\n       (stack (empty_state e) \\<noteq> [] \\<longrightarrow>\n        last (stack (empty_state e)) \\<in> V0) \\<and>\n       dom (finished (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) \\<and>\n       Domain (pending (empty_state e))\n       \\<subseteq> dom (discovered (empty_state e)) -\n                   dom (finished (empty_state e)) \\<and>\n       pending (empty_state e) \\<subseteq> E\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>set (stack s) = dom (discovered s) - dom (finished s) \\<and>\n                distinct (stack s) \\<and>\n                (stack s \\<noteq> [] \\<longrightarrow>\n                 last (stack s) \\<in> V0) \\<and>\n                dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n                Domain (pending s)\n                \\<subseteq> dom (discovered s) - dom (finished s) \\<and>\n                pending s \\<subseteq> E;\n        cond s; DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> set (stack s') =\n                         dom (discovered s') - dom (finished s') \\<and>\n                         distinct (stack s') \\<and>\n                         (stack s' \\<noteq> [] \\<longrightarrow>\n                          last (stack s') \\<in> V0) \\<and>\n                         dom (finished s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         Domain (pending s')\n                         \\<subseteq> dom (discovered s') -\n                                     dom (finished s') \\<and>\n                         pending s' \\<subseteq> E\n 3. \\<And>s s' u e.\n       \\<lbrakk>set (stack s) = dom (discovered s) - dom (finished s) \\<and>\n                distinct (stack s) \\<and>\n                (stack s \\<noteq> [] \\<longrightarrow>\n                 last (stack s) \\<in> V0) \\<and>\n                dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n                Domain (pending s)\n                \\<subseteq> dom (discovered s) - dom (finished s) \\<and>\n                pending s \\<subseteq> E;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> set (stack s') =\n                         dom (discovered s') - dom (finished s') \\<and>\n                         distinct (stack s') \\<and>\n                         (stack s' \\<noteq> [] \\<longrightarrow>\n                          last (stack s') \\<in> V0) \\<and>\n                         dom (finished s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         Domain (pending s')\n                         \\<subseteq> dom (discovered s') -\n                                     dom (finished s') \\<and>\n                         pending s' \\<subseteq> E\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>set (stack s) = dom (discovered s) - dom (finished s) \\<and>\n                distinct (stack s) \\<and>\n                (stack s \\<noteq> [] \\<longrightarrow>\n                 last (stack s) \\<in> V0) \\<and>\n                dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n                Domain (pending s)\n                \\<subseteq> dom (discovered s) - dom (finished s) \\<and>\n                pending s \\<subseteq> E;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> set (stack s') =\n                         dom (discovered s') - dom (finished s') \\<and>\n                         distinct (stack s') \\<and>\n                         (stack s' \\<noteq> [] \\<longrightarrow>\n                          last (stack s') \\<in> V0) \\<and>\n                         dom (finished s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         Domain (pending s')\n                         \\<subseteq> dom (discovered s') -\n                                     dom (finished s') \\<and>\n                         pending s' \\<subseteq> E\n 5. \\<And>s s' u v e.\n       \\<lbrakk>set (stack s) = dom (discovered s) - dom (finished s) \\<and>\n                distinct (stack s) \\<and>\n                (stack s \\<noteq> [] \\<longrightarrow>\n                 last (stack s) \\<in> V0) \\<and>\n                dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n                Domain (pending s)\n                \\<subseteq> dom (discovered s) - dom (finished s) \\<and>\n                pending s \\<subseteq> E;\n        cond s; DFS_invar G param s; DFS_invar G param s';\n        stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> set (stack s') =\n                         dom (discovered s') - dom (finished s') \\<and>\n                         distinct (stack s') \\<and>\n                         (stack s' \\<noteq> [] \\<longrightarrow>\n                          last (stack s') \\<in> V0) \\<and>\n                         dom (finished s')\n                         \\<subseteq> dom (discovered s') \\<and>\n                         Domain (pending s')\n                         \\<subseteq> dom (discovered s') -\n                                     dom (finished s') \\<and>\n                         pending s' \\<subseteq> E", "apply (clarsimp_all simp: neq_Nil_conv last_tl)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s v0 e.\n       \\<lbrakk>cond s; DFS_invar G param s;\n        DFS_invar G param (new_root v0 s\\<lparr>state.more := e\\<rparr>);\n        stack s = []; v0 \\<in> V0;\n        Domain ({v0} \\<times> E `` {v0})\n        \\<subseteq> insert v0 (dom (discovered s)) -\n                    dom (finished s) \\<longrightarrow>\n        dom (finished s)\n        \\<subseteq> insert v0 (dom (discovered s)) \\<longrightarrow>\n        {v0} =\n        insert v0 (dom (discovered s)) - dom (finished s) \\<longrightarrow>\n        \\<not> (insert v0 (dom (discovered s)) - dom (finished s)) \\<times>\n               E `` (insert v0 (dom (discovered s)) - dom (finished s))\n               \\<subseteq> E;\n        {} = dom (discovered s) - dom (finished s);\n        dom (finished s) \\<subseteq> dom (discovered s);\n        Domain (pending s) = {}; pending s \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. discovered s v0 = Some y\n 2. \\<And>s e y ys.\n       \\<lbrakk>cond s; DFS_invar G param s;\n        DFS_invar G param (finish y s\\<lparr>state.more := e\\<rparr>);\n        pending s `` {y} = {}; stack s = y # ys;\n        insert y (set ys) = dom (discovered s) - dom (finished s);\n        (if ys = [] then y else last ys) \\<in> V0;\n        dom (finished s) \\<subseteq> dom (discovered s);\n        Domain (pending s)\n        \\<subseteq> dom (discovered s) - dom (finished s);\n        pending s \\<subseteq> E; y \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> set ys =\n                         dom (discovered s) -\n                         insert y (dom (finished s)) \\<and>\n                         y \\<in> dom (discovered s) \\<and>\n                         Domain (pending s)\n                         \\<subseteq> dom (discovered s) -\n                                     insert y (dom (finished s))\n 3. \\<And>s v e c b y ya ys.\n       \\<lbrakk>cond s; DFS_invar G param s;\n        DFS_invar G param\n         (s\\<lparr>pending := pending s - {(y, v)}, state.more := e,\n              cross_edges := c, back_edges := b\\<rparr>);\n        (y, v) \\<in> pending s; cross_edges s \\<subseteq> c;\n        back_edges s \\<subseteq> b; discovered s v = Some ya;\n        stack s = y # ys;\n        insert y (set ys) = dom (discovered s) - dom (finished s);\n        (if ys = [] then y else last ys) \\<in> V0;\n        dom (finished s) \\<subseteq> dom (discovered s);\n        Domain (pending s)\n        \\<subseteq> dom (discovered s) - dom (finished s);\n        pending s \\<subseteq> E; y \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> Domain (pending s - {(y, v)})\n                         \\<subseteq> dom (discovered s) -\n                                     dom (finished s) \\<and>\n                         pending s - {(y, v)} \\<subseteq> E\n 4. \\<And>s v e y ys.\n       \\<lbrakk>cond s; DFS_invar G param s;\n        DFS_invar G param\n         (discover y v (s\\<lparr>pending := pending s - {(y, v)}\\<rparr>)\n          \\<lparr>state.more := e\\<rparr>);\n        (y, v) \\<in> pending s;\n        pending s - {(y, v)} \\<subseteq> E \\<longrightarrow>\n        Domain (pending s - {(y, v)} \\<union> {v} \\<times> E `` {v})\n        \\<subseteq> insert v (dom (discovered s)) -\n                    dom (finished s) \\<longrightarrow>\n        dom (finished s)\n        \\<subseteq> insert v (dom (discovered s)) \\<longrightarrow>\n        insert v (dom (discovered s) - dom (finished s)) =\n        insert v (dom (discovered s)) - dom (finished s) \\<longrightarrow>\n        \\<not> {v} \\<times> E `` {v} \\<subseteq> E;\n        stack s = y # ys;\n        insert y (set ys) = dom (discovered s) - dom (finished s);\n        (if ys = [] then y else last ys) \\<in> V0;\n        dom (finished s) \\<subseteq> dom (discovered s);\n        Domain (pending s)\n        \\<subseteq> dom (discovered s) - dom (finished s);\n        pending s \\<subseteq> E; y \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. discovered s v = Some y", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context DFS_invar begin"], ["", "lemmas basic_invar = make_invar_thm[OF i_basic_invar]"], ["", "lemma pending_ssE: \"pending s \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pending s \\<subseteq> E", "using basic_invar"], ["proof (prove)\nusing this:\n  basic_invar s\n\ngoal (1 subgoal):\n 1. pending s \\<subseteq> E", "by (auto simp: basic_invar_def)"], ["", "lemma pendingD:\n    \"(u,v)\\<in>pending s \\<Longrightarrow> (u,v)\\<in>E \\<and> u\\<in>dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> pending s \\<Longrightarrow>\n    (u, v) \\<in> E \\<and> u \\<in> dom (discovered s)", "using basic_invar"], ["proof (prove)\nusing this:\n  basic_invar s\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> pending s \\<Longrightarrow>\n    (u, v) \\<in> E \\<and> u \\<in> dom (discovered s)", "by (auto simp: basic_invar_def)"], ["", "lemma stack_set_def:\n    \"set (stack s) = dom (discovered s) - dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (stack s) = dom (discovered s) - dom (finished s)", "using basic_invar"], ["proof (prove)\nusing this:\n  basic_invar s\n\ngoal (1 subgoal):\n 1. set (stack s) = dom (discovered s) - dom (finished s)", "by (simp add: basic_invar_def)"], ["", "lemma stack_discovered:\n    \"set (stack s) \\<subseteq> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (stack s) \\<subseteq> dom (discovered s)", "using stack_set_def"], ["proof (prove)\nusing this:\n  set (stack s) = dom (discovered s) - dom (finished s)\n\ngoal (1 subgoal):\n 1. set (stack s) \\<subseteq> dom (discovered s)", "by auto"], ["", "lemma stack_distinct:\n    \"distinct (stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (stack s)", "using basic_invar"], ["proof (prove)\nusing this:\n  basic_invar s\n\ngoal (1 subgoal):\n 1. distinct (stack s)", "by (simp add: basic_invar_def)"], ["", "lemma last_stack_in_V0:\n    \"stack s \\<noteq> [] \\<Longrightarrow> last (stack s) \\<in> V0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stack s \\<noteq> [] \\<Longrightarrow> last (stack s) \\<in> V0", "using basic_invar"], ["proof (prove)\nusing this:\n  basic_invar s\n\ngoal (1 subgoal):\n 1. stack s \\<noteq> [] \\<Longrightarrow> last (stack s) \\<in> V0", "by (simp add: basic_invar_def)"], ["", "lemma stack_not_finished:\n    \"x \\<in> set (stack s) \\<Longrightarrow> x \\<notin> dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (stack s) \\<Longrightarrow> x \\<notin> dom (finished s)", "using stack_set_def"], ["proof (prove)\nusing this:\n  set (stack s) = dom (discovered s) - dom (finished s)\n\ngoal (1 subgoal):\n 1. x \\<in> set (stack s) \\<Longrightarrow> x \\<notin> dom (finished s)", "by auto"], ["", "lemma discovered_not_stack_imp_finished:\n    \"x \\<in> dom (discovered s) \\<Longrightarrow> x \\<notin> set (stack s) \\<Longrightarrow> x \\<in> dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (discovered s); x \\<notin> set (stack s)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (finished s)", "using stack_set_def"], ["proof (prove)\nusing this:\n  set (stack s) = dom (discovered s) - dom (finished s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (discovered s); x \\<notin> set (stack s)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (finished s)", "by auto"], ["", "lemma finished_discovered:\n    \"dom (finished s) \\<subseteq> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (finished s) \\<subseteq> dom (discovered s)", "using basic_invar"], ["proof (prove)\nusing this:\n  basic_invar s\n\ngoal (1 subgoal):\n 1. dom (finished s) \\<subseteq> dom (discovered s)", "by (auto simp add: basic_invar_def)"], ["", "lemma finished_no_pending:\n    \"v \\<in> dom (finished s) \\<Longrightarrow> pending s `` {v} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s) \\<Longrightarrow> pending s `` {v} = {}", "using basic_invar"], ["proof (prove)\nusing this:\n  basic_invar s\n\ngoal (1 subgoal):\n 1. v \\<in> dom (finished s) \\<Longrightarrow> pending s `` {v} = {}", "by (auto simp add: basic_invar_def)"], ["", "lemma discovered_eq_finished_un_stack:\n    \"dom (discovered s) = dom (finished s) \\<union> set (stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (discovered s) = dom (finished s) \\<union> set (stack s)", "using stack_set_def finished_discovered"], ["proof (prove)\nusing this:\n  set (stack s) = dom (discovered s) - dom (finished s)\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. dom (discovered s) = dom (finished s) \\<union> set (stack s)", "by auto"], ["", "lemma pending_on_stack:\n    \"(v,w) \\<in> pending s \\<Longrightarrow> v \\<in> set (stack s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> pending s \\<Longrightarrow> v \\<in> set (stack s)", "using basic_invar"], ["proof (prove)\nusing this:\n  basic_invar s\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> pending s \\<Longrightarrow> v \\<in> set (stack s)", "by (auto simp add: basic_invar_def)"], ["", "lemma empty_stack_imp_empty_pending:\n    \"stack s = [] \\<Longrightarrow> pending s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stack s = [] \\<Longrightarrow> pending s = {}", "using pending_on_stack"], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> pending s \\<Longrightarrow> ?v \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. stack s = [] \\<Longrightarrow> pending s = {}", "by auto"], ["", "end"], ["", "context param_DFS begin"], ["", "(* Establish some more invariants *)"], ["", "lemma i_discovered_reachable: \n    \"is_invar (\\<lambda>s. dom (discovered s) \\<subseteq> reachable)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar (\\<lambda>s. dom (discovered s) \\<subseteq> reachable)", "proof (induct rule: is_invarI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. dom (discovered (empty_state e)) \\<subseteq> reachable\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable\n 3. \\<And>s s' u e.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        v \\<in> pending s `` {u}; v \\<in> dom (discovered s);\n        u = hd (stack s); cross_edges s \\<subseteq> c;\n        back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable\n 5. \\<And>s s' u v e.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        v \\<in> pending s `` {u}; v \\<notin> dom (discovered s);\n        u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable", "case (discover s)"], ["proof (state)\nthis:\n  dom (discovered s) \\<subseteq> reachable\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e. dom (discovered (empty_state e)) \\<subseteq> reachable\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable\n 3. \\<And>s s' u e.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        v \\<in> pending s `` {u}; v \\<in> dom (discovered s);\n        u = hd (stack s); cross_edges s \\<subseteq> c;\n        back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable\n 5. \\<And>s s' u v e.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        v \\<in> pending s `` {u}; v \\<notin> dom (discovered s);\n        u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable", "then"], ["proof (chain)\npicking this:\n  dom (discovered s) \\<subseteq> reachable\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "interpret i: DFS_invar where s=s"], ["proof (prove)\nusing this:\n  dom (discovered s) \\<subseteq> reachable\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. dom (discovered (empty_state e)) \\<subseteq> reachable\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable\n 3. \\<And>s s' u e.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        v \\<in> pending s `` {u}; v \\<in> dom (discovered s);\n        u = hd (stack s); cross_edges s \\<subseteq> c;\n        back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable\n 5. \\<And>s s' u v e.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        v \\<in> pending s `` {u}; v \\<notin> dom (discovered s);\n        u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable", "from discover"], ["proof (chain)\npicking this:\n  dom (discovered s) \\<subseteq> reachable\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  dom (discovered s) \\<subseteq> reachable\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'_\n  stack s \\<noteq> []\n  v_ \\<in> pending s `` {u_}\n  v_ \\<notin> dom (discovered s)\n  u_ = hd (stack s)\n  s'_ = discover u_ v_ (s\\<lparr>pending := pending s - {(u_, v_)}\\<rparr>)\n  \\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. dom (discovered s'_) \\<subseteq> reachable", "apply (clarsimp dest!: i.pendingD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s;\n        DFS_invar G param\n         (discover (hd (stack s)) v_\n           (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n          \\<lparr>state.more := e_\\<rparr>);\n        stack s \\<noteq> []; u_ = hd (stack s);\n        s'_ =\n        discover (hd (stack s)) v_\n         (s\\<lparr>pending := pending s - {(hd (stack s), v_)}\\<rparr>)\n        \\<lparr>state.more := e_\\<rparr>;\n        v_ \\<notin> reachable; (hd (stack s), v_) \\<in> E;\n        discovered s (hd (stack s)) = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. discovered s v_ = Some y", "by (metis contra_subsetD list.set_sel(1) rtrancl_image_advance i.stack_discovered)"], ["proof (state)\nthis:\n  dom (discovered s'_) \\<subseteq> reachable\n\ngoal (4 subgoals):\n 1. \\<And>e. dom (discovered (empty_state e)) \\<subseteq> reachable\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s = [];\n        v0 \\<notin> dom (discovered s); v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable\n 3. \\<And>s s' u e.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        pending s `` {u} = {}; u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>dom (discovered s) \\<subseteq> reachable; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        v \\<in> pending s `` {u}; v \\<in> dom (discovered s);\n        u = hd (stack s); cross_edges s \\<subseteq> c;\n        back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> dom (discovered s') \\<subseteq> reachable", "qed auto"], ["", "definition \"discovered_closed s \\<equiv>\n      E``dom (finished s) \\<subseteq> dom (discovered s)\n    \\<and> (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\""], ["", "lemma i_discovered_closed: \"is_invar discovered_closed\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar discovered_closed", "proof (induct rule: is_invarI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. discovered_closed (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'", "case (finish s s')"], ["proof (state)\nthis:\n  discovered_closed s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>e. discovered_closed (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'", "hence \"(E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\""], ["proof (prove)\nusing this:\n  discovered_closed s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)", "by (simp add: discovered_closed_def)"], ["proof (state)\nthis:\n  (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (5 subgoals):\n 1. \\<And>e. discovered_closed (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'", "moreover"], ["proof (state)\nthis:\n  (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (5 subgoals):\n 1. \\<And>e. discovered_closed (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'", "from finish"], ["proof (chain)\npicking this:\n  discovered_closed s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>", "have \"set (stack s') \\<subseteq> set (stack s)\""], ["proof (prove)\nusing this:\n  discovered_closed s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. set (stack s') \\<subseteq> set (stack s)", "by (auto simp add: neq_Nil_conv cond_def)"], ["proof (state)\nthis:\n  set (stack s') \\<subseteq> set (stack s)\n\ngoal (5 subgoals):\n 1. \\<And>e. discovered_closed (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'", "ultimately"], ["proof (chain)\npicking this:\n  (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\n  set (stack s') \\<subseteq> set (stack s)", "have \"(E - pending s') `` set (stack s') \\<subseteq> dom (discovered s')\""], ["proof (prove)\nusing this:\n  (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\n  set (stack s') \\<subseteq> set (stack s)\n\ngoal (1 subgoal):\n 1. (E - pending s') `` set (stack s') \\<subseteq> dom (discovered s')", "using finish"], ["proof (prove)\nusing this:\n  (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\n  set (stack s') \\<subseteq> set (stack s)\n  discovered_closed s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. (E - pending s') `` set (stack s') \\<subseteq> dom (discovered s')", "by simp blast"], ["proof (state)\nthis:\n  (E - pending s') `` set (stack s') \\<subseteq> dom (discovered s')\n\ngoal (5 subgoals):\n 1. \\<And>e. discovered_closed (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'", "moreover"], ["proof (state)\nthis:\n  (E - pending s') `` set (stack s') \\<subseteq> dom (discovered s')\n\ngoal (5 subgoals):\n 1. \\<And>e. discovered_closed (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'", "from \\<open>stack s \\<noteq> []\\<close> finish"], ["proof (chain)\npicking this:\n  stack s \\<noteq> []\n  discovered_closed s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>", "have \"E``dom (finished s') \\<subseteq> dom (discovered s')\""], ["proof (prove)\nusing this:\n  stack s \\<noteq> []\n  discovered_closed s\n  cond s\n  DFS_invar G param s\n  DFS_invar G param s'\n  stack s \\<noteq> []\n  pending s `` {u_} = {}\n  u_ = hd (stack s)\n  s' = finish u_ s\\<lparr>state.more := e_\\<rparr>\n\ngoal (1 subgoal):\n 1. E `` dom (finished s') \\<subseteq> dom (discovered s')", "apply (cases \"stack s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>stack s \\<noteq> []; discovered_closed s; cond s;\n     DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n     pending s `` {u_} = {}; u_ = hd (stack s);\n     s' = finish u_ s\\<lparr>state.more := e_\\<rparr>; stack s = []\\<rbrakk>\n    \\<Longrightarrow> E `` dom (finished s') \\<subseteq> dom (discovered s')\n 2. \\<And>a list.\n       \\<lbrakk>stack s \\<noteq> []; discovered_closed s; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        pending s `` {u_} = {}; u_ = hd (stack s);\n        s' = finish u_ s\\<lparr>state.more := e_\\<rparr>;\n        stack s = a # list\\<rbrakk>\n       \\<Longrightarrow> E `` dom (finished s')\n                         \\<subseteq> dom (discovered s')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>stack s \\<noteq> []; discovered_closed s; cond s;\n        DFS_invar G param s; DFS_invar G param s'; stack s \\<noteq> [];\n        pending s `` {u_} = {}; u_ = hd (stack s);\n        s' = finish u_ s\\<lparr>state.more := e_\\<rparr>;\n        stack s = a # list\\<rbrakk>\n       \\<Longrightarrow> E `` dom (finished s')\n                         \\<subseteq> dom (discovered s')", "apply (simp add: discovered_closed_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>E `` dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n                (E - pending s) `` insert a (set list)\n                \\<subseteq> dom (discovered s);\n        cond s; DFS_invar G param s;\n        DFS_invar G param (finish a s\\<lparr>state.more := e_\\<rparr>);\n        pending s `` {a} = {}; u_ = a;\n        s' = finish a s\\<lparr>state.more := e_\\<rparr>;\n        stack s = a # list\\<rbrakk>\n       \\<Longrightarrow> E `` insert a (dom (finished s))\n                         \\<subseteq> dom (discovered s)", "apply (blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  E `` dom (finished s') \\<subseteq> dom (discovered s')\n\ngoal (5 subgoals):\n 1. \\<And>e. discovered_closed (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 3. \\<And>s s' u e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; pending s `` {u} = {};\n        u = hd (stack s);\n        s' = finish u s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 4. \\<And>s s' u v e c b.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 5. \\<And>s s' u v e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'", "ultimately"], ["proof (chain)\npicking this:\n  (E - pending s') `` set (stack s') \\<subseteq> dom (discovered s')\n  E `` dom (finished s') \\<subseteq> dom (discovered s')", "show ?case"], ["proof (prove)\nusing this:\n  (E - pending s') `` set (stack s') \\<subseteq> dom (discovered s')\n  E `` dom (finished s') \\<subseteq> dom (discovered s')\n\ngoal (1 subgoal):\n 1. discovered_closed s'", "by (simp add: discovered_closed_def)"], ["proof (state)\nthis:\n  discovered_closed s'\n\ngoal (4 subgoals):\n 1. \\<And>e. discovered_closed (empty_state e)\n 2. \\<And>s s' v0 e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s = []; v0 \\<notin> dom (discovered s);\n        v0 \\<in> V0;\n        s' = new_root v0 s\\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 3. \\<And>s s' u v e c b.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<in> dom (discovered s); u = hd (stack s);\n        cross_edges s \\<subseteq> c; back_edges s \\<subseteq> b;\n        s' = s\n        \\<lparr>pending := pending s - {(u, v)}, state.more := e,\n           cross_edges := c, back_edges := b\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'\n 4. \\<And>s s' u v e.\n       \\<lbrakk>discovered_closed s; cond s; DFS_invar G param s;\n        DFS_invar G param s'; stack s \\<noteq> []; v \\<in> pending s `` {u};\n        v \\<notin> dom (discovered s); u = hd (stack s);\n        s' = discover u v (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\n        \\<lparr>state.more := e\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> discovered_closed s'", "qed (auto simp add: discovered_closed_def cond_def)"], ["", "lemma i_discovered_finite: \"is_invar (\\<lambda>s. finite (dom (discovered s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar (\\<lambda>s. finite (dom (discovered s)))", "by (induction rule: is_invarI) auto"], ["", "end"], ["", "context DFS_invar\nbegin"], ["", "lemmas discovered_reachable = \n    i_discovered_reachable [THEN make_invar_thm]"], ["", "lemma stack_reachable: \"set (stack s) \\<subseteq> reachable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (stack s) \\<subseteq> reachable", "using stack_discovered discovered_reachable"], ["proof (prove)\nusing this:\n  set (stack s) \\<subseteq> dom (discovered s)\n  dom (discovered s) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. set (stack s) \\<subseteq> reachable", "by blast"], ["", "lemmas discovered_closed = i_discovered_closed[THEN make_invar_thm]"], ["", "lemmas discovered_finite[simp, intro!] = i_discovered_finite[THEN make_invar_thm]"], ["", "lemma finished_finite[simp, intro!]: \"finite (dom (finished s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (finished s))", "using finished_discovered discovered_finite"], ["proof (prove)\nusing this:\n  dom (finished s) \\<subseteq> dom (discovered s)\n  finite (dom (discovered s))\n\ngoal (1 subgoal):\n 1. finite (dom (finished s))", "by (rule finite_subset)"], ["", "lemma finished_closed:\n    \"E `` dom (finished s) \\<subseteq> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` dom (finished s) \\<subseteq> dom (discovered s)", "using discovered_closed[unfolded discovered_closed_def]"], ["proof (prove)\nusing this:\n  E `` dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n  (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. E `` dom (finished s) \\<subseteq> dom (discovered s)", "by auto"], ["", "lemma finished_imp_succ_discovered:\n    \"v \\<in> dom (finished s) \\<Longrightarrow> w \\<in> succ v \\<Longrightarrow> w \\<in> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> dom (finished s); w \\<in> E `` {v}\\<rbrakk>\n    \\<Longrightarrow> w \\<in> dom (discovered s)", "using discovered_closed[unfolded discovered_closed_def]"], ["proof (prove)\nusing this:\n  E `` dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n  (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> dom (finished s); w \\<in> E `` {v}\\<rbrakk>\n    \\<Longrightarrow> w \\<in> dom (discovered s)", "by auto"], ["", "lemma pending_reachable: \"pending s \\<subseteq> reachable \\<times> reachable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pending s \\<subseteq> reachable \\<times> reachable", "using pendingD discovered_reachable"], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> pending s \\<Longrightarrow>\n  (?u, ?v) \\<in> E \\<and> ?u \\<in> dom (discovered s)\n  dom (discovered s) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. pending s \\<subseteq> reachable \\<times> reachable", "by (fast intro: rtrancl_image_advance_rtrancl)"], ["", "lemma pending_finite[simp, intro!]: \"finite (pending s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (pending s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (pending s)", "have \"pending s \\<subseteq> (SIGMA u:dom (discovered s). E``{u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pending s \\<subseteq> (SIGMA u:dom (discovered s). E `` {u})", "by (auto dest: pendingD)"], ["proof (state)\nthis:\n  pending s \\<subseteq> (SIGMA u:dom (discovered s). E `` {u})\n\ngoal (1 subgoal):\n 1. finite (pending s)", "also"], ["proof (state)\nthis:\n  pending s \\<subseteq> (SIGMA u:dom (discovered s). E `` {u})\n\ngoal (1 subgoal):\n 1. finite (pending s)", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (SIGMA u:dom (discovered s). E `` {u})", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (dom (discovered s))\n 2. \\<And>u. u \\<in> dom (discovered s) \\<Longrightarrow> finite (E `` {u})", "apply (rule discovered_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> dom (discovered s) \\<Longrightarrow> finite (E `` {u})", "using discovered_reachable"], ["proof (prove)\nusing this:\n  dom (discovered s) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> dom (discovered s) \\<Longrightarrow> finite (E `` {u})", "by (blast intro: finitely_branching)"], ["proof (state)\nthis:\n  finite (SIGMA u:dom (discovered s). E `` {u})\n\ngoal (1 subgoal):\n 1. finite (pending s)", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite (pending s)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (pending s)\n\ngoal (1 subgoal):\n 1. finite (pending s)", "."], ["proof (state)\nthis:\n  finite (pending s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_pending_imp_succ_discovered:\n    assumes \"u \\<in> dom (discovered s)\"\n    and \"pending s `` {u} = {}\"\n    and \"v \\<in> succ u\"\n    shows \"v \\<in> dom (discovered s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (discovered s)", "proof (cases \"u \\<in> dom (finished s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> dom (finished s) \\<Longrightarrow> v \\<in> dom (discovered s)\n 2. u \\<notin> dom (finished s) \\<Longrightarrow> v \\<in> dom (discovered s)", "case True"], ["proof (state)\nthis:\n  u \\<in> dom (finished s)\n\ngoal (2 subgoals):\n 1. u \\<in> dom (finished s) \\<Longrightarrow> v \\<in> dom (discovered s)\n 2. u \\<notin> dom (finished s) \\<Longrightarrow> v \\<in> dom (discovered s)", "with finished_imp_succ_discovered assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  u \\<in> dom (discovered s)\n  pending s `` {u} = {}\n  v \\<in> E `` {u}\n  u \\<in> dom (finished s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (discovered s)\n  u \\<in> dom (discovered s)\n  pending s `` {u} = {}\n  v \\<in> E `` {u}\n  u \\<in> dom (finished s)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (discovered s)", "by simp"], ["proof (state)\nthis:\n  v \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> v \\<in> dom (discovered s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> v \\<in> dom (discovered s)", "case False"], ["proof (state)\nthis:\n  u \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> v \\<in> dom (discovered s)", "with stack_set_def assms"], ["proof (chain)\npicking this:\n  set (stack s) = dom (discovered s) - dom (finished s)\n  u \\<in> dom (discovered s)\n  pending s `` {u} = {}\n  v \\<in> E `` {u}\n  u \\<notin> dom (finished s)", "have \"u \\<in> set (stack s)\""], ["proof (prove)\nusing this:\n  set (stack s) = dom (discovered s) - dom (finished s)\n  u \\<in> dom (discovered s)\n  pending s `` {u} = {}\n  v \\<in> E `` {u}\n  u \\<notin> dom (finished s)\n\ngoal (1 subgoal):\n 1. u \\<in> set (stack s)", "by auto"], ["proof (state)\nthis:\n  u \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. u \\<notin> dom (finished s) \\<Longrightarrow> v \\<in> dom (discovered s)", "with assms discovered_closed[unfolded discovered_closed_def]"], ["proof (chain)\npicking this:\n  u \\<in> dom (discovered s)\n  pending s `` {u} = {}\n  v \\<in> E `` {u}\n  E `` dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n  (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\n  u \\<in> set (stack s)", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> dom (discovered s)\n  pending s `` {u} = {}\n  v \\<in> E `` {u}\n  E `` dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n  (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\n  u \\<in> set (stack s)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (discovered s)", "by blast"], ["proof (state)\nthis:\n  v \\<in> dom (discovered s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nc_finished_eq_reachable:\n    assumes NC: \"\\<not>cond s\" \"\\<not>is_break param s\" \n    shows \"dom (finished s) = reachable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (finished s) = reachable", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (finished s) = reachable", "from NC basic_invar"], ["proof (chain)\npicking this:\n  \\<not> cond s\n  \\<not> is_break param s\n  basic_invar s", "have [simp]: \"stack s = []\" \"dom (discovered s) = dom (finished s)\" and SS: \"V0 \\<subseteq> dom (discovered s)\""], ["proof (prove)\nusing this:\n  \\<not> cond s\n  \\<not> is_break param s\n  basic_invar s\n\ngoal (1 subgoal):\n 1. (stack s = [] &&& dom (discovered s) = dom (finished s)) &&&\n    V0 \\<subseteq> dom (discovered s)", "unfolding basic_invar_def cond_alt"], ["proof (prove)\nusing this:\n  \\<not> ((V0 \\<subseteq> dom (discovered s) \\<longrightarrow>\n           stack s \\<noteq> []) \\<and>\n          \\<not> is_break param s)\n  \\<not> is_break param s\n  set (stack s) = dom (discovered s) - dom (finished s) \\<and>\n  distinct (stack s) \\<and>\n  (stack s \\<noteq> [] \\<longrightarrow> last (stack s) \\<in> V0) \\<and>\n  dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n  Domain (pending s)\n  \\<subseteq> dom (discovered s) - dom (finished s) \\<and>\n  pending s \\<subseteq> E\n\ngoal (1 subgoal):\n 1. (stack s = [] &&& dom (discovered s) = dom (finished s)) &&&\n    V0 \\<subseteq> dom (discovered s)", "by auto"], ["proof (state)\nthis:\n  stack s = []\n  dom (discovered s) = dom (finished s)\n  V0 \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. dom (finished s) = reachable", "show \"dom (finished s) = reachable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (finished s) = reachable", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. dom (finished s) \\<subseteq> reachable\n 2. reachable \\<subseteq> dom (finished s)", "from discovered_reachable"], ["proof (chain)\npicking this:\n  dom (discovered s) \\<subseteq> reachable", "show \"dom (finished s) \\<subseteq> reachable\""], ["proof (prove)\nusing this:\n  dom (discovered s) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. dom (finished s) \\<subseteq> reachable", "by simp"], ["proof (state)\nthis:\n  dom (finished s) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. reachable \\<subseteq> dom (finished s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable \\<subseteq> dom (finished s)", "from discovered_closed"], ["proof (chain)\npicking this:\n  discovered_closed s", "have \"E``(dom (finished s)) \\<subseteq> dom (finished s)\""], ["proof (prove)\nusing this:\n  discovered_closed s\n\ngoal (1 subgoal):\n 1. E `` dom (finished s) \\<subseteq> dom (finished s)", "unfolding discovered_closed_def"], ["proof (prove)\nusing this:\n  E `` dom (finished s) \\<subseteq> dom (discovered s) \\<and>\n  (E - pending s) `` set (stack s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. E `` dom (finished s) \\<subseteq> dom (finished s)", "by auto"], ["proof (state)\nthis:\n  E `` dom (finished s) \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. reachable \\<subseteq> dom (finished s)", "with SS"], ["proof (chain)\npicking this:\n  V0 \\<subseteq> dom (discovered s)\n  E `` dom (finished s) \\<subseteq> dom (finished s)", "show \"reachable \\<subseteq> dom (finished s)\""], ["proof (prove)\nusing this:\n  V0 \\<subseteq> dom (discovered s)\n  E `` dom (finished s) \\<subseteq> dom (finished s)\n\ngoal (1 subgoal):\n 1. reachable \\<subseteq> dom (finished s)", "by (simp, metis rtrancl_reachable_induct)"], ["proof (state)\nthis:\n  reachable \\<subseteq> dom (finished s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom (finished s) = reachable\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nc_V0_finished:\n    assumes NC: \"\\<not> cond s\" \"\\<not> is_break param s\"\n    shows \"V0 \\<subseteq> dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V0 \\<subseteq> dom (finished s)", "using nc_finished_eq_reachable[OF NC]"], ["proof (prove)\nusing this:\n  dom (finished s) = reachable\n\ngoal (1 subgoal):\n 1. V0 \\<subseteq> dom (finished s)", "by blast"], ["", "lemma nc_discovered_eq_finished:\n    assumes NC: \"\\<not> cond s\" \"\\<not> is_break param s\"\n    shows \"dom (discovered s) = dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (discovered s) = dom (finished s)", "using finished_discovered"], ["proof (prove)\nusing this:\n  dom (finished s) \\<subseteq> dom (discovered s)\n\ngoal (1 subgoal):\n 1. dom (discovered s) = dom (finished s)", "using nc_finished_eq_reachable[OF NC] discovered_reachable"], ["proof (prove)\nusing this:\n  dom (finished s) \\<subseteq> dom (discovered s)\n  dom (finished s) = reachable\n  dom (discovered s) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. dom (discovered s) = dom (finished s)", "by blast"], ["", "lemma nc_discovered_eq_reachable:\n    assumes NC: \"\\<not> cond s\" \"\\<not> is_break param s\"\n    shows \"dom (discovered s) = reachable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (discovered s) = reachable", "using NC"], ["proof (prove)\nusing this:\n  \\<not> cond s\n  \\<not> is_break param s\n\ngoal (1 subgoal):\n 1. dom (discovered s) = reachable", "using nc_discovered_eq_finished nc_finished_eq_reachable"], ["proof (prove)\nusing this:\n  \\<not> cond s\n  \\<not> is_break param s\n  \\<lbrakk>\\<not> cond s; \\<not> is_break param s\\<rbrakk>\n  \\<Longrightarrow> dom (discovered s) = dom (finished s)\n  \\<lbrakk>\\<not> cond s; \\<not> is_break param s\\<rbrakk>\n  \\<Longrightarrow> dom (finished s) = reachable\n\ngoal (1 subgoal):\n 1. dom (discovered s) = reachable", "by blast"], ["", "lemma nc_fin_closed: \n    assumes NC: \"\\<not>cond s\"\n    assumes NB: \"\\<not>is_break param s\"\n    shows \"E``dom (finished s) \\<subseteq> dom (finished s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` dom (finished s) \\<subseteq> dom (finished s)", "using finished_imp_succ_discovered"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> dom (finished s); ?w \\<in> E `` {?v}\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> dom (discovered s)\n\ngoal (1 subgoal):\n 1. E `` dom (finished s) \\<subseteq> dom (finished s)", "by (auto simp: nc_discovered_eq_finished[OF NC NB])"], ["", "end"], ["", "subsection \\<open>Total Correctness\\<close>"], ["", "text \\<open>We can show termination of the DFS algorithm, independently of the parameterization\\<close>"], ["", "context param_DFS begin"], ["", "definition \"param_dfs_variant \\<equiv> inv_image \n    (finite_psupset reachable <*lex*> finite_psubset <*lex*> less_than)\n    (\\<lambda>s. (dom (discovered s), pending s, length (stack s)))\""], ["", "lemma param_dfs_variant_wf[simp, intro!]:\n    assumes [simp, intro!]: \"finite reachable\"\n    shows \"wf param_dfs_variant\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf param_dfs_variant", "unfolding param_dfs_variant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image\n         (finite_psupset reachable <*lex*> finite_psubset <*lex*> less_than)\n         (\\<lambda>s. (dom (discovered s), pending s, length (stack s))))", "by auto"], ["", "lemma param_dfs_variant_step:   \n    assumes A: \"DFS_invar G param s\" \"cond s\" \"nofail it_dfs\"\n    shows \"step s \\<le> SPEC (\\<lambda>s'. (s',s)\\<in>param_dfs_variant)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step s \\<le> SPEC (\\<lambda>s'. (s', s) \\<in> param_dfs_variant)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. step s \\<le> SPEC (\\<lambda>s'. (s', s) \\<in> param_dfs_variant)", "interpret DFS_invar G param s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS_invar G param s", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. step s \\<le> SPEC (\\<lambda>s'. (s', s) \\<in> param_dfs_variant)", "from A"], ["proof (chain)\npicking this:\n  DFS_invar G param s\n  cond s\n  nofail it_dfs", "show ?thesis"], ["proof (prove)\nusing this:\n  DFS_invar G param s\n  cond s\n  nofail it_dfs\n\ngoal (1 subgoal):\n 1. step s \\<le> SPEC (\\<lambda>s'. (s', s) \\<in> param_dfs_variant)", "unfolding rwof_eq_DFS_invar[symmetric] it_dfs_def"], ["proof (prove)\nusing this:\n  rwof init cond step s\n  cond s\n  nofail (init \\<bind> WHILE cond step)\n\ngoal (1 subgoal):\n 1. step s \\<le> SPEC (\\<lambda>s'. (s', s) \\<in> param_dfs_variant)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rwof init cond step s; cond s;\n     nofail (init \\<bind> WHILE cond step)\\<rbrakk>\n    \\<Longrightarrow> step s\n                      \\<le> SPEC\n                             (\\<lambda>s'. (s', s) \\<in> param_dfs_variant)", "apply (drule (2) WHILE_nofail_imp_rwof_nofail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rwof init cond step s; cond s; nofail (step s)\\<rbrakk>\n    \\<Longrightarrow> step s\n                      \\<le> SPEC\n                             (\\<lambda>s'. (s', s) \\<in> param_dfs_variant)", "unfolding step_def get_new_root_def do_defs get_pending_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rwof init cond\n              (\\<lambda>s.\n                  if is_empty_stack s\n                  then SPEC\n                        (\\<lambda>v.\n                            v \\<in> V0 \\<and>\n                            \\<not> is_discovered v s) \\<bind>\n                       (\\<lambda>v0.\n                           let s = new_root v0 s\n                           in on_new_root param v0 s \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>state.more := e\\<rparr>)))\n                  else (let u = hd (stack s); Vs = pending s `` {u}\n                        in if Vs = {} then RETURN (u, None, s)\n                           else RES Vs \\<bind>\n                                (\\<lambda>v.\n                                    let s = s\n    \\<lparr>pending := pending s - {(u, v)}\\<rparr>\n                                    in RETURN (u, Some v, s))) \\<bind>\n                       (\\<lambda>(u, Vs, s).\n                           case Vs of\n                           None \\<Rightarrow>\n                             let s = finish u s\n                             in on_finish param u s \\<bind>\n                                (\\<lambda>e.\n                                    RETURN\n                                     (s\\<lparr>state.more := e\\<rparr>))\n                           | Some v \\<Rightarrow>\n                               if is_discovered v s\n                               then if is_finished v s\n                                    then let s = cross_edge u v s\n   in on_cross_edge param u v s \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                    else let s = back_edge u v s\n   in on_back_edge param u v s \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                               else let s = discover u v s\n                                    in on_discover param u v s \\<bind>\n (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n              s;\n     cond s;\n     nofail\n      (if is_empty_stack s\n       then SPEC\n             (\\<lambda>v.\n                 v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n            (\\<lambda>v0.\n                let s = new_root v0 s\n                in on_new_root param v0 s \\<bind>\n                   (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>)))\n       else (let u = hd (stack s); Vs = pending s `` {u}\n             in if Vs = {} then RETURN (u, None, s)\n                else RES Vs \\<bind>\n                     (\\<lambda>v.\n                         let s = s\\<lparr>pending :=\n      pending s - {(u, v)}\\<rparr>\n                         in RETURN (u, Some v, s))) \\<bind>\n            (\\<lambda>(u, Vs, s).\n                case Vs of\n                None \\<Rightarrow>\n                  let s = finish u s\n                  in on_finish param u s \\<bind>\n                     (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                | Some v \\<Rightarrow>\n                    if is_discovered v s\n                    then if is_finished v s\n                         then let s = cross_edge u v s\n                              in on_cross_edge param u v s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>))\n                         else let s = back_edge u v s\n                              in on_back_edge param u v s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>))\n                    else let s = discover u v s\n                         in on_discover param u v s \\<bind>\n                            (\\<lambda>e.\n                                RETURN\n                                 (s\\<lparr>state.more :=\n       e\\<rparr>))))\\<rbrakk>\n    \\<Longrightarrow> (if is_empty_stack s\n                       then SPEC\n                             (\\<lambda>v.\n                                 v \\<in> V0 \\<and>\n                                 \\<not> is_discovered v s) \\<bind>\n                            (\\<lambda>v0.\n                                let s = new_root v0 s\n                                in on_new_root param v0 s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>)))\n                       else (let u = hd (stack s); Vs = pending s `` {u}\n                             in if Vs = {} then RETURN (u, None, s)\n                                else RES Vs \\<bind>\n                                     (\\<lambda>v.\n   let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n   in RETURN (u, Some v, s))) \\<bind>\n                            (\\<lambda>(u, Vs, s).\n                                case Vs of\n                                None \\<Rightarrow>\n                                  let s = finish u s\n                                  in on_finish param u s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                | Some v \\<Rightarrow>\n                                    if is_discovered v s\n                                    then if is_finished v s\n   then let s = cross_edge u v s\n        in on_cross_edge param u v s \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n   else let s = back_edge u v s\n        in on_back_edge param u v s \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                    else let s = discover u v s\n   in on_discover param u v s \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                      \\<le> SPEC\n                             (\\<lambda>s'. (s', s) \\<in> param_dfs_variant)", "unfolding param_dfs_variant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rwof init cond\n              (\\<lambda>s.\n                  if is_empty_stack s\n                  then SPEC\n                        (\\<lambda>v.\n                            v \\<in> V0 \\<and>\n                            \\<not> is_discovered v s) \\<bind>\n                       (\\<lambda>v0.\n                           let s = new_root v0 s\n                           in on_new_root param v0 s \\<bind>\n                              (\\<lambda>e.\n                                  RETURN\n                                   (s\\<lparr>state.more := e\\<rparr>)))\n                  else (let u = hd (stack s); Vs = pending s `` {u}\n                        in if Vs = {} then RETURN (u, None, s)\n                           else RES Vs \\<bind>\n                                (\\<lambda>v.\n                                    let s = s\n    \\<lparr>pending := pending s - {(u, v)}\\<rparr>\n                                    in RETURN (u, Some v, s))) \\<bind>\n                       (\\<lambda>(u, Vs, s).\n                           case Vs of\n                           None \\<Rightarrow>\n                             let s = finish u s\n                             in on_finish param u s \\<bind>\n                                (\\<lambda>e.\n                                    RETURN\n                                     (s\\<lparr>state.more := e\\<rparr>))\n                           | Some v \\<Rightarrow>\n                               if is_discovered v s\n                               then if is_finished v s\n                                    then let s = cross_edge u v s\n   in on_cross_edge param u v s \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                    else let s = back_edge u v s\n   in on_back_edge param u v s \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                               else let s = discover u v s\n                                    in on_discover param u v s \\<bind>\n (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n              s;\n     cond s;\n     nofail\n      (if is_empty_stack s\n       then SPEC\n             (\\<lambda>v.\n                 v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n            (\\<lambda>v0.\n                let s = new_root v0 s\n                in on_new_root param v0 s \\<bind>\n                   (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>)))\n       else (let u = hd (stack s); Vs = pending s `` {u}\n             in if Vs = {} then RETURN (u, None, s)\n                else RES Vs \\<bind>\n                     (\\<lambda>v.\n                         let s = s\\<lparr>pending :=\n      pending s - {(u, v)}\\<rparr>\n                         in RETURN (u, Some v, s))) \\<bind>\n            (\\<lambda>(u, Vs, s).\n                case Vs of\n                None \\<Rightarrow>\n                  let s = finish u s\n                  in on_finish param u s \\<bind>\n                     (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                | Some v \\<Rightarrow>\n                    if is_discovered v s\n                    then if is_finished v s\n                         then let s = cross_edge u v s\n                              in on_cross_edge param u v s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>))\n                         else let s = back_edge u v s\n                              in on_back_edge param u v s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>))\n                    else let s = discover u v s\n                         in on_discover param u v s \\<bind>\n                            (\\<lambda>e.\n                                RETURN\n                                 (s\\<lparr>state.more :=\n       e\\<rparr>))))\\<rbrakk>\n    \\<Longrightarrow> (if is_empty_stack s\n                       then SPEC\n                             (\\<lambda>v.\n                                 v \\<in> V0 \\<and>\n                                 \\<not> is_discovered v s) \\<bind>\n                            (\\<lambda>v0.\n                                let s = new_root v0 s\n                                in on_new_root param v0 s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>)))\n                       else (let u = hd (stack s); Vs = pending s `` {u}\n                             in if Vs = {} then RETURN (u, None, s)\n                                else RES Vs \\<bind>\n                                     (\\<lambda>v.\n   let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n   in RETURN (u, Some v, s))) \\<bind>\n                            (\\<lambda>(u, Vs, s).\n                                case Vs of\n                                None \\<Rightarrow>\n                                  let s = finish u s\n                                  in on_finish param u s \\<bind>\n                                     (\\<lambda>e.\n   RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                | Some v \\<Rightarrow>\n                                    if is_discovered v s\n                                    then if is_finished v s\n   then let s = cross_edge u v s\n        in on_cross_edge param u v s \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n   else let s = back_edge u v s\n        in on_back_edge param u v s \\<bind>\n           (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                    else let s = discover u v s\n   in on_discover param u v s \\<bind>\n      (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                      \\<le> SPEC\n                             (\\<lambda>s'.\n                                 (s', s)\n                                 \\<in> inv_image\n  (finite_psupset reachable <*lex*> finite_psubset <*lex*> less_than)\n  (\\<lambda>s. (dom (discovered s), pending s, length (stack s))))", "apply refine_vcg"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        is_empty_stack s;\n        x \\<in> V0 \\<and> \\<not> is_discovered x s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param x (new_root x s)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (new_root x s\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 2. \\<And>a b aa ba.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param a (finish a ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (finish a ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 3. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        is_discovered x ba; is_finished x ba\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param a x (cross_edge a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (cross_edge a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 4. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        is_discovered x ba; \\<not> is_finished x ba\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param a x (back_edge a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (back_edge a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 5. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        \\<not> is_discovered x ba\\<rbrakk>\n       \\<Longrightarrow> on_discover param a x (discover a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (discover a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 6. \\<And>x a b aa ba.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param a (finish a ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (finish a ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 7. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; is_discovered xa ba;\n        is_finished xa ba\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param a xa (cross_edge a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (cross_edge a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 8. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; is_discovered xa ba;\n        \\<not> is_finished xa ba\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param a xa (back_edge a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (back_edge a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 9. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; \\<not> is_discovered xa ba\\<rbrakk>\n       \\<Longrightarrow> on_discover param a xa (discover a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (discover a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))", "using discovered_reachable"], ["proof (prove)\nusing this:\n  dom (discovered s) \\<subseteq> reachable\n\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        is_empty_stack s;\n        x \\<in> V0 \\<and> \\<not> is_discovered x s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param x (new_root x s)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (new_root x s\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 2. \\<And>a b aa ba.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param a (finish a ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (finish a ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 3. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        is_discovered x ba; is_finished x ba\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param a x (cross_edge a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (cross_edge a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 4. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        is_discovered x ba; \\<not> is_finished x ba\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param a x (back_edge a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (back_edge a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 5. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        \\<not> is_discovered x ba\\<rbrakk>\n       \\<Longrightarrow> on_discover param a x (discover a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (discover a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 6. \\<And>x a b aa ba.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param a (finish a ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (finish a ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 7. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; is_discovered xa ba;\n        is_finished xa ba\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param a xa (cross_edge a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (cross_edge a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 8. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; is_discovered xa ba;\n        \\<not> is_finished xa ba\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param a xa (back_edge a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (back_edge a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 9. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; \\<not> is_discovered xa ba\\<rbrakk>\n       \\<Longrightarrow> on_discover param a xa (discover a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (discover a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))", "(* TODO: Clean, up. *) \n        (* FIXME: auto-steps take loooong *)"], ["proof (prove)\nusing this:\n  dom (discovered s) \\<subseteq> reachable\n\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        is_empty_stack s;\n        x \\<in> V0 \\<and> \\<not> is_discovered x s\\<rbrakk>\n       \\<Longrightarrow> on_new_root param x (new_root x s)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (new_root x s\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 2. \\<And>a b aa ba.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param a (finish a ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (finish a ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 3. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        is_discovered x ba; is_finished x ba\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param a x (cross_edge a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (cross_edge a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 4. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        is_discovered x ba; \\<not> is_finished x ba\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param a x (back_edge a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (back_edge a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 5. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        \\<not> is_discovered x ba\\<rbrakk>\n       \\<Longrightarrow> on_discover param a x (discover a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (discover a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 6. \\<And>x a b aa ba.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param a (finish a ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (finish a ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 7. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; is_discovered xa ba;\n        is_finished xa ba\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param a xa (cross_edge a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (cross_edge a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 8. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; is_discovered xa ba;\n        \\<not> is_finished xa ba\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param a xa (back_edge a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (back_edge a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 9. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; \\<not> is_discovered xa ba\\<rbrakk>\n       \\<Longrightarrow> on_discover param a xa (discover a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (discover a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))", "apply (auto \n        split: option.splits \n        simp: refine_pw_simps pw_le_iff is_discovered_def finite_psupset_def\n      ) [1]"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param a (finish a ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (finish a ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 2. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        is_discovered x ba; is_finished x ba\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param a x (cross_edge a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (cross_edge a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 3. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        is_discovered x ba; \\<not> is_finished x ba\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param a x (back_edge a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (back_edge a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 4. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        \\<not> is_discovered x ba\\<rbrakk>\n       \\<Longrightarrow> on_discover param a x (discover a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (discover a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 5. \\<And>x a b aa ba.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param a (finish a ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (finish a ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 6. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; is_discovered xa ba;\n        is_finished xa ba\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param a xa (cross_edge a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (cross_edge a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 7. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; is_discovered xa ba;\n        \\<not> is_finished xa ba\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param a xa (back_edge a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (back_edge a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 8. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; \\<not> is_discovered xa ba\\<rbrakk>\n       \\<Longrightarrow> on_discover param a xa (discover a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (discover a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))", "apply (auto simp: refine_pw_simps pw_le_iff is_empty_stack_def) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        is_discovered x ba; is_finished x ba\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param a x (cross_edge a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (cross_edge a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 2. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        is_discovered x ba; \\<not> is_finished x ba\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param a x (back_edge a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (back_edge a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 3. \\<And>a b aa ba x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} = {};\n        (hd (stack s), None, s) = (a, b); b = (aa, ba); aa = Some x;\n        \\<not> is_discovered x ba\\<rbrakk>\n       \\<Longrightarrow> on_discover param a x (discover a x ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (discover a x ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 4. \\<And>x a b aa ba.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = None\\<rbrakk>\n       \\<Longrightarrow> on_finish param a (finish a ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (finish a ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 5. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; is_discovered xa ba;\n        is_finished xa ba\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge param a xa (cross_edge a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (cross_edge a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 6. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; is_discovered xa ba;\n        \\<not> is_finished xa ba\\<rbrakk>\n       \\<Longrightarrow> on_back_edge param a xa (back_edge a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (back_edge a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))\n 7. \\<And>x a b aa ba xa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (if is_empty_stack s\n          then SPEC\n                (\\<lambda>v.\n                    v \\<in> V0 \\<and> \\<not> is_discovered v s) \\<bind>\n               (\\<lambda>v0.\n                   let s = new_root v0 s\n                   in on_new_root param v0 s \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>state.more := e\\<rparr>)))\n          else (let u = hd (stack s); Vs = pending s `` {u}\n                in if Vs = {} then RETURN (u, None, s)\n                   else RES Vs \\<bind>\n                        (\\<lambda>v.\n                            let s = s\\<lparr>pending :=\n         pending s - {(u, v)}\\<rparr>\n                            in RETURN (u, Some v, s))) \\<bind>\n               (\\<lambda>(u, Vs, s).\n                   case Vs of\n                   None \\<Rightarrow>\n                     let s = finish u s\n                     in on_finish param u s \\<bind>\n                        (\\<lambda>e.\n                            RETURN (s\\<lparr>state.more := e\\<rparr>))\n                   | Some v \\<Rightarrow>\n                       if is_discovered v s\n                       then if is_finished v s\n                            then let s = cross_edge u v s\n                                 in on_cross_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                            else let s = back_edge u v s\n                                 in on_back_edge param u v s \\<bind>\n                                    (\\<lambda>e.\n  RETURN (s\\<lparr>state.more := e\\<rparr>))\n                       else let s = discover u v s\n                            in on_discover param u v s \\<bind>\n                               (\\<lambda>e.\n                                   RETURN\n                                    (s\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        x \\<in> pending s `` {hd (stack s)};\n        (hd (stack s), Some x, s\n         \\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>) =\n        (a, b);\n        b = (aa, ba); aa = Some xa; \\<not> is_discovered xa ba\\<rbrakk>\n       \\<Longrightarrow> on_discover param a xa (discover a xa ba)\n                         \\<le> SPEC\n                                (\\<lambda>e.\n                                    RETURN\n                                     (discover a xa ba\n\\<lparr>state.more := e\\<rparr>)\n                                    \\<le> SPEC\n     (\\<lambda>s'.\n         (s', s)\n         \\<in> inv_image\n                (finite_psupset reachable <*lex*>\n                 finite_psubset <*lex*> less_than)\n                (\\<lambda>s.\n                    (dom (discovered s), pending s, length (stack s)))))", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a b aa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (RES (pending s `` {a}) \\<bind>\n          (\\<lambda>x.\n              if is_discovered x\n                  (s\\<lparr>pending := pending s - {(a, x)}\\<rparr>)\n              then if is_finished x\n                       (s\\<lparr>pending :=\n                                   pending s - {(hd (stack s), x)}\\<rparr>)\n                   then let sa = cross_edge (hd (stack s)) x\n                                  (s\\<lparr>pending :=\n        pending s - {(hd (stack s), x)}\\<rparr>)\n                        in on_cross_edge param (hd (stack s)) x sa \\<bind>\n                           (\\<lambda>e.\n                               RETURN (sa\\<lparr>state.more := e\\<rparr>))\n                   else let sa = back_edge (hd (stack s)) x\n                                  (s\\<lparr>pending :=\n        pending s - {(hd (stack s), x)}\\<rparr>)\n                        in on_back_edge param (hd (stack s)) x sa \\<bind>\n                           (\\<lambda>e.\n                               RETURN (sa\\<lparr>state.more := e\\<rparr>))\n              else let sa = discover (hd (stack s)) x\n                             (s\\<lparr>pending :=\n   pending s - {(hd (stack s), x)}\\<rparr>)\n                   in on_discover param (hd (stack s)) x sa \\<bind>\n                      (\\<lambda>e.\n                          RETURN (sa\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {a} \\<noteq> {};\n        (a, x) \\<in> pending s; hd (stack s) = a;\n        b = (Some x, s\\<lparr>pending := pending s - {(a, x)}\\<rparr>);\n        aa = Some x;\n        is_discovered x (s\\<lparr>pending := pending s - {(a, x)}\\<rparr>);\n        is_finished x\n         (s\\<lparr>pending := pending s - {(a, x)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((dom (discovered s), dom (discovered s))\n                          \\<in> finite_psupset reachable \\<longrightarrow>\n                          on_cross_edge param a x\n                           (cross_edge a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>))\n                          \\<le> RES UNIV) \\<and>\n                         (pending s - {(a, x)}\n                          \\<subset> pending s \\<longrightarrow>\n                          on_cross_edge param a x\n                           (cross_edge a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>))\n                          \\<le> RES UNIV) \\<and>\n                         ((dom (discovered s), dom (discovered s))\n                          \\<notin> finite_psupset reachable \\<and>\n                          \\<not> pending s - {(a, x)}\n                                 \\<subset> pending s \\<longrightarrow>\n                          on_cross_edge param a x\n                           (cross_edge a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>)) =\n                          SUCCEED)\n 2. \\<And>x a b aa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (RES (pending s `` {a}) \\<bind>\n          (\\<lambda>x.\n              if is_discovered x\n                  (s\\<lparr>pending := pending s - {(a, x)}\\<rparr>)\n              then if is_finished x\n                       (s\\<lparr>pending :=\n                                   pending s - {(hd (stack s), x)}\\<rparr>)\n                   then let sa = cross_edge (hd (stack s)) x\n                                  (s\\<lparr>pending :=\n        pending s - {(hd (stack s), x)}\\<rparr>)\n                        in on_cross_edge param (hd (stack s)) x sa \\<bind>\n                           (\\<lambda>e.\n                               RETURN (sa\\<lparr>state.more := e\\<rparr>))\n                   else let sa = back_edge (hd (stack s)) x\n                                  (s\\<lparr>pending :=\n        pending s - {(hd (stack s), x)}\\<rparr>)\n                        in on_back_edge param (hd (stack s)) x sa \\<bind>\n                           (\\<lambda>e.\n                               RETURN (sa\\<lparr>state.more := e\\<rparr>))\n              else let sa = discover (hd (stack s)) x\n                             (s\\<lparr>pending :=\n   pending s - {(hd (stack s), x)}\\<rparr>)\n                   in on_discover param (hd (stack s)) x sa \\<bind>\n                      (\\<lambda>e.\n                          RETURN (sa\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {a} \\<noteq> {};\n        (a, x) \\<in> pending s; hd (stack s) = a;\n        b = (Some x, s\\<lparr>pending := pending s - {(a, x)}\\<rparr>);\n        aa = Some x;\n        is_discovered x (s\\<lparr>pending := pending s - {(a, x)}\\<rparr>);\n        \\<not> is_finished x\n                (s\\<lparr>pending := pending s - {(a, x)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((dom (discovered s), dom (discovered s))\n                          \\<in> finite_psupset reachable \\<longrightarrow>\n                          on_back_edge param a x\n                           (back_edge a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>))\n                          \\<le> RES UNIV) \\<and>\n                         (pending s - {(a, x)}\n                          \\<subset> pending s \\<longrightarrow>\n                          on_back_edge param a x\n                           (back_edge a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>))\n                          \\<le> RES UNIV) \\<and>\n                         ((dom (discovered s), dom (discovered s))\n                          \\<notin> finite_psupset reachable \\<and>\n                          \\<not> pending s - {(a, x)}\n                                 \\<subset> pending s \\<longrightarrow>\n                          on_back_edge param a x\n                           (back_edge a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>)) =\n                          SUCCEED)\n 3. \\<And>x a b aa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (RES (pending s `` {a}) \\<bind>\n          (\\<lambda>x.\n              if is_discovered x\n                  (s\\<lparr>pending := pending s - {(a, x)}\\<rparr>)\n              then if is_finished x\n                       (s\\<lparr>pending :=\n                                   pending s - {(hd (stack s), x)}\\<rparr>)\n                   then let sa = cross_edge (hd (stack s)) x\n                                  (s\\<lparr>pending :=\n        pending s - {(hd (stack s), x)}\\<rparr>)\n                        in on_cross_edge param (hd (stack s)) x sa \\<bind>\n                           (\\<lambda>e.\n                               RETURN (sa\\<lparr>state.more := e\\<rparr>))\n                   else let sa = back_edge (hd (stack s)) x\n                                  (s\\<lparr>pending :=\n        pending s - {(hd (stack s), x)}\\<rparr>)\n                        in on_back_edge param (hd (stack s)) x sa \\<bind>\n                           (\\<lambda>e.\n                               RETURN (sa\\<lparr>state.more := e\\<rparr>))\n              else let sa = discover (hd (stack s)) x\n                             (s\\<lparr>pending :=\n   pending s - {(hd (stack s), x)}\\<rparr>)\n                   in on_discover param (hd (stack s)) x sa \\<bind>\n                      (\\<lambda>e.\n                          RETURN (sa\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {a} \\<noteq> {};\n        (a, x) \\<in> pending s; hd (stack s) = a;\n        b = (Some x, s\\<lparr>pending := pending s - {(a, x)}\\<rparr>);\n        aa = Some x;\n        \\<not> is_discovered x\n                (s\\<lparr>pending := pending s - {(a, x)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((insert x (dom (discovered s)),\n                           dom (discovered s))\n                          \\<in> finite_psupset reachable \\<longrightarrow>\n                          on_discover param a x\n                           (discover a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>))\n                          \\<le> RES UNIV) \\<and>\n                         (insert x (dom (discovered s)) =\n                          dom (discovered s) \\<and>\n                          pending s - {(a, x)} \\<union>\n                          {x} \\<times> E `` {x}\n                          \\<subset> pending s \\<longrightarrow>\n                          on_discover param a x\n                           (discover a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>))\n                          \\<le> RES UNIV) \\<and>\n                         ((insert x (dom (discovered s)),\n                           dom (discovered s))\n                          \\<notin> finite_psupset reachable \\<and>\n                          (insert x (dom (discovered s)) =\n                           dom (discovered s) \\<longrightarrow>\n                           \\<not> pending s - {(a, x)} \\<union>\n                                  {x} \\<times> E `` {x}\n                                  \\<subset> pending s) \\<longrightarrow>\n                          on_discover param a x\n                           (discover a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>)) =\n                          SUCCEED)", "apply (auto \n        simp: refine_pw_simps pw_le_iff is_discovered_def\n        split: if_split_asm\n        ) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b aa.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        nofail\n         (RES (pending s `` {a}) \\<bind>\n          (\\<lambda>x.\n              if is_discovered x\n                  (s\\<lparr>pending := pending s - {(a, x)}\\<rparr>)\n              then if is_finished x\n                       (s\\<lparr>pending :=\n                                   pending s - {(hd (stack s), x)}\\<rparr>)\n                   then let sa = cross_edge (hd (stack s)) x\n                                  (s\\<lparr>pending :=\n        pending s - {(hd (stack s), x)}\\<rparr>)\n                        in on_cross_edge param (hd (stack s)) x sa \\<bind>\n                           (\\<lambda>e.\n                               RETURN (sa\\<lparr>state.more := e\\<rparr>))\n                   else let sa = back_edge (hd (stack s)) x\n                                  (s\\<lparr>pending :=\n        pending s - {(hd (stack s), x)}\\<rparr>)\n                        in on_back_edge param (hd (stack s)) x sa \\<bind>\n                           (\\<lambda>e.\n                               RETURN (sa\\<lparr>state.more := e\\<rparr>))\n              else let sa = discover (hd (stack s)) x\n                             (s\\<lparr>pending :=\n   pending s - {(hd (stack s), x)}\\<rparr>)\n                   in on_discover param (hd (stack s)) x sa \\<bind>\n                      (\\<lambda>e.\n                          RETURN (sa\\<lparr>state.more := e\\<rparr>))));\n        \\<not> is_empty_stack s; pending s `` {a} \\<noteq> {};\n        (a, x) \\<in> pending s; hd (stack s) = a;\n        b = (Some x, s\\<lparr>pending := pending s - {(a, x)}\\<rparr>);\n        aa = Some x;\n        \\<not> is_discovered x\n                (s\\<lparr>pending := pending s - {(a, x)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((insert x (dom (discovered s)),\n                           dom (discovered s))\n                          \\<in> finite_psupset reachable \\<longrightarrow>\n                          on_discover param a x\n                           (discover a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>))\n                          \\<le> RES UNIV) \\<and>\n                         (insert x (dom (discovered s)) =\n                          dom (discovered s) \\<and>\n                          pending s - {(a, x)} \\<union>\n                          {x} \\<times> E `` {x}\n                          \\<subset> pending s \\<longrightarrow>\n                          on_discover param a x\n                           (discover a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>))\n                          \\<le> RES UNIV) \\<and>\n                         ((insert x (dom (discovered s)),\n                           dom (discovered s))\n                          \\<notin> finite_psupset reachable \\<and>\n                          (insert x (dom (discovered s)) =\n                           dom (discovered s) \\<longrightarrow>\n                           \\<not> pending s - {(a, x)} \\<union>\n                                  {x} \\<times> E `` {x}\n                                  \\<subset> pending s) \\<longrightarrow>\n                          on_discover param a x\n                           (discover a x\n                             (s\\<lparr>pending :=\n   pending s - {(a, x)}\\<rparr>)) =\n                          SUCCEED)", "apply (clarsimp simp: refine_pw_simps pw_le_iff is_discovered_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        \\<forall>x.\n           (hd (stack s), x) \\<in> pending s \\<longrightarrow>\n           nofail\n            (if x \\<in> dom (discovered s)\n             then if is_finished x\n                      (s\\<lparr>pending :=\n                                  pending s - {(hd (stack s), x)}\\<rparr>)\n                  then let sa = cross_edge (hd (stack s)) x\n                                 (s\\<lparr>pending :=\n       pending s - {(hd (stack s), x)}\\<rparr>)\n                       in on_cross_edge param (hd (stack s)) x sa \\<bind>\n                          (\\<lambda>e.\n                              RETURN (sa\\<lparr>state.more := e\\<rparr>))\n                  else let sa = back_edge (hd (stack s)) x\n                                 (s\\<lparr>pending :=\n       pending s - {(hd (stack s), x)}\\<rparr>)\n                       in on_back_edge param (hd (stack s)) x sa \\<bind>\n                          (\\<lambda>e.\n                              RETURN (sa\\<lparr>state.more := e\\<rparr>))\n             else let sa = discover (hd (stack s)) x\n                            (s\\<lparr>pending :=\n  pending s - {(hd (stack s), x)}\\<rparr>)\n                  in on_discover param (hd (stack s)) x sa \\<bind>\n                     (\\<lambda>e.\n                         RETURN (sa\\<lparr>state.more := e\\<rparr>)));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        (hd (stack s), x) \\<in> pending s;\n        (insert x (dom (discovered s)), dom (discovered s))\n        \\<in> finite_psupset reachable \\<and>\n        \\<not> nofail\n                (on_discover param (hd (stack s)) x\n                  (discover (hd (stack s)) x\n                    (s\\<lparr>pending :=\n                                pending s -\n                                {(hd (stack s), x)}\\<rparr>))) \\<or>\n        insert x (dom (discovered s)) = dom (discovered s) \\<and>\n        pending s - {(hd (stack s), x)} \\<union> {x} \\<times> E `` {x}\n        \\<subset> pending s \\<and>\n        \\<not> nofail\n                (on_discover param (hd (stack s)) x\n                  (discover (hd (stack s)) x\n                    (s\\<lparr>pending :=\n                                pending s -\n                                {(hd (stack s), x)}\\<rparr>))) \\<or>\n        (insert x (dom (discovered s)), dom (discovered s))\n        \\<notin> finite_psupset reachable \\<and>\n        (insert x (dom (discovered s)) =\n         dom (discovered s) \\<longrightarrow>\n         \\<not> pending s - {(hd (stack s), x)} \\<union>\n                {x} \\<times> E `` {x}\n                \\<subset> pending s) \\<and>\n        on_discover param (hd (stack s)) x\n         (discover (hd (stack s)) x\n           (s\\<lparr>pending :=\n                       pending s - {(hd (stack s), x)}\\<rparr>)) \\<noteq>\n        SUCCEED\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. discovered s x = Some y", "using discovered_reachable pending_reachable"], ["proof (prove)\nusing this:\n  dom (discovered s) \\<subseteq> reachable\n  pending s \\<subseteq> reachable \\<times> reachable\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>rwof init cond\n                 (\\<lambda>s.\n                     if is_empty_stack s\n                     then SPEC\n                           (\\<lambda>v.\n                               v \\<in> V0 \\<and>\n                               \\<not> is_discovered v s) \\<bind>\n                          (\\<lambda>v0.\n                              let s = new_root v0 s\n                              in on_new_root param v0 s \\<bind>\n                                 (\\<lambda>e.\n                                     RETURN\n(s\\<lparr>state.more := e\\<rparr>)))\n                     else (let u = hd (stack s); Vs = pending s `` {u}\n                           in if Vs = {} then RETURN (u, None, s)\n                              else RES Vs \\<bind>\n                                   (\\<lambda>v.\n let s = s\\<lparr>pending := pending s - {(u, v)}\\<rparr>\n in RETURN (u, Some v, s))) \\<bind>\n                          (\\<lambda>(u, Vs, s).\n                              case Vs of\n                              None \\<Rightarrow>\n                                let s = finish u s\n                                in on_finish param u s \\<bind>\n                                   (\\<lambda>e.\n RETURN (s\\<lparr>state.more := e\\<rparr>))\n                              | Some v \\<Rightarrow>\n                                  if is_discovered v s\n                                  then if is_finished v s\n then let s = cross_edge u v s\n      in on_cross_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n else let s = back_edge u v s\n      in on_back_edge param u v s \\<bind>\n         (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))\n                                  else let s = discover u v s\n in on_discover param u v s \\<bind>\n    (\\<lambda>e. RETURN (s\\<lparr>state.more := e\\<rparr>))))\n                 s;\n        cond s;\n        \\<forall>x.\n           (hd (stack s), x) \\<in> pending s \\<longrightarrow>\n           nofail\n            (if x \\<in> dom (discovered s)\n             then if is_finished x\n                      (s\\<lparr>pending :=\n                                  pending s - {(hd (stack s), x)}\\<rparr>)\n                  then let sa = cross_edge (hd (stack s)) x\n                                 (s\\<lparr>pending :=\n       pending s - {(hd (stack s), x)}\\<rparr>)\n                       in on_cross_edge param (hd (stack s)) x sa \\<bind>\n                          (\\<lambda>e.\n                              RETURN (sa\\<lparr>state.more := e\\<rparr>))\n                  else let sa = back_edge (hd (stack s)) x\n                                 (s\\<lparr>pending :=\n       pending s - {(hd (stack s), x)}\\<rparr>)\n                       in on_back_edge param (hd (stack s)) x sa \\<bind>\n                          (\\<lambda>e.\n                              RETURN (sa\\<lparr>state.more := e\\<rparr>))\n             else let sa = discover (hd (stack s)) x\n                            (s\\<lparr>pending :=\n  pending s - {(hd (stack s), x)}\\<rparr>)\n                  in on_discover param (hd (stack s)) x sa \\<bind>\n                     (\\<lambda>e.\n                         RETURN (sa\\<lparr>state.more := e\\<rparr>)));\n        \\<not> is_empty_stack s; pending s `` {hd (stack s)} \\<noteq> {};\n        (hd (stack s), x) \\<in> pending s;\n        (insert x (dom (discovered s)), dom (discovered s))\n        \\<in> finite_psupset reachable \\<and>\n        \\<not> nofail\n                (on_discover param (hd (stack s)) x\n                  (discover (hd (stack s)) x\n                    (s\\<lparr>pending :=\n                                pending s -\n                                {(hd (stack s), x)}\\<rparr>))) \\<or>\n        insert x (dom (discovered s)) = dom (discovered s) \\<and>\n        pending s - {(hd (stack s), x)} \\<union> {x} \\<times> E `` {x}\n        \\<subset> pending s \\<and>\n        \\<not> nofail\n                (on_discover param (hd (stack s)) x\n                  (discover (hd (stack s)) x\n                    (s\\<lparr>pending :=\n                                pending s -\n                                {(hd (stack s), x)}\\<rparr>))) \\<or>\n        (insert x (dom (discovered s)), dom (discovered s))\n        \\<notin> finite_psupset reachable \\<and>\n        (insert x (dom (discovered s)) =\n         dom (discovered s) \\<longrightarrow>\n         \\<not> pending s - {(hd (stack s), x)} \\<union>\n                {x} \\<times> E `` {x}\n                \\<subset> pending s) \\<and>\n        on_discover param (hd (stack s)) x\n         (discover (hd (stack s)) x\n           (s\\<lparr>pending :=\n                       pending s - {(hd (stack s), x)}\\<rparr>)) \\<noteq>\n        SUCCEED\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. discovered s x = Some y", "apply (auto\n        simp: is_discovered_def\n        simp: refine_pw_simps pw_le_iff finite_psupset_def\n        split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  step s \\<le> SPEC (\\<lambda>s'. (s', s) \\<in> param_dfs_variant)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context param_DFS begin"], ["", "lemma it_dfsT_eq_it_dfs:\n    assumes [simp, intro!]: \"finite reachable\"\n    shows \"it_dfsT = it_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfsT = it_dfs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. it_dfsT = it_dfs", "have \"it_dfs \\<le> it_dfsT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfs \\<le> it_dfsT", "unfolding it_dfs_def it_dfsT_def WHILE_def WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. init \\<bind> WHILE\\<^bsup>\\<lambda>_. True\\<^esup> cond step\n    \\<le> init \\<bind>\n          WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> cond step", "apply (rule bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. init \\<le> init\n 2. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE\\<^bsup>\\<lambda>_. True\\<^esup> cond step x\n       \\<le> WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> cond step x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE\\<^bsup>\\<lambda>_. True\\<^esup> cond step x\n       \\<le> WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> cond step x", "apply (rule WHILEI_le_WHILEIT)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  it_dfs \\<le> it_dfsT\n\ngoal (1 subgoal):\n 1. it_dfsT = it_dfs", "also"], ["proof (state)\nthis:\n  it_dfs \\<le> it_dfsT\n\ngoal (1 subgoal):\n 1. it_dfsT = it_dfs", "have \"it_dfsT \\<le> it_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfsT \\<le> it_dfs", "proof (cases \"nofail it_dfs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nofail it_dfs \\<Longrightarrow> it_dfsT \\<le> it_dfs\n 2. \\<not> nofail it_dfs \\<Longrightarrow> it_dfsT \\<le> it_dfs", "case False"], ["proof (state)\nthis:\n  \\<not> nofail it_dfs\n\ngoal (2 subgoals):\n 1. nofail it_dfs \\<Longrightarrow> it_dfsT \\<le> it_dfs\n 2. \\<not> nofail it_dfs \\<Longrightarrow> it_dfsT \\<le> it_dfs", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> nofail it_dfs\n\ngoal (1 subgoal):\n 1. it_dfsT \\<le> it_dfs", "by (simp add: not_nofail_iff)"], ["proof (state)\nthis:\n  it_dfsT \\<le> it_dfs\n\ngoal (1 subgoal):\n 1. nofail it_dfs \\<Longrightarrow> it_dfsT \\<le> it_dfs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail it_dfs \\<Longrightarrow> it_dfsT \\<le> it_dfs", "case True"], ["proof (state)\nthis:\n  nofail it_dfs\n\ngoal (1 subgoal):\n 1. nofail it_dfs \\<Longrightarrow> it_dfsT \\<le> it_dfs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfsT \\<le> it_dfs", "unfolding it_dfsT_def it_dfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. init \\<bind> WHILE\\<^sub>T cond step \\<le> init \\<bind> WHILE cond step", "apply (rule bind_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. init \\<le> init\n 2. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE\\<^sub>T cond step x \\<le> WHILE cond step x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE\\<^sub>T cond step x \\<le> WHILE cond step x", "apply (subst WHILET_eq_WHILE_tproof[\n          where I=\"DFS_invar G param\"\n          and V=\"param_dfs_variant\"\n          ])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. RETURN x \\<le> init \\<Longrightarrow> wf param_dfs_variant\n 2. \\<And>x. RETURN x \\<le> init \\<Longrightarrow> DFS_invar G param x\n 3. \\<And>x s.\n       \\<lbrakk>RETURN x \\<le> init; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    DFS_invar G param s' \\<and>\n                                    (s', s) \\<in> param_dfs_variant)\n 4. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE cond step x \\<le> WHILE cond step x", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. RETURN x \\<le> init \\<Longrightarrow> DFS_invar G param x\n 2. \\<And>x s.\n       \\<lbrakk>RETURN x \\<le> init; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    DFS_invar G param s' \\<and>\n                                    (s', s) \\<in> param_dfs_variant)\n 3. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE cond step x \\<le> WHILE cond step x", "apply (subst rwof_eq_DFS_invar[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. RETURN x \\<le> init \\<Longrightarrow> rwof init cond step x\n 2. \\<And>x s.\n       \\<lbrakk>RETURN x \\<le> init; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    DFS_invar G param s' \\<and>\n                                    (s', s) \\<in> param_dfs_variant)\n 3. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE cond step x \\<le> WHILE cond step x", "using rwof_init[OF True[unfolded it_dfs_def]]"], ["proof (prove)\nusing this:\n  init \\<le> SPEC (rwof init cond step)\n\ngoal (3 subgoals):\n 1. \\<And>x. RETURN x \\<le> init \\<Longrightarrow> rwof init cond step x\n 2. \\<And>x s.\n       \\<lbrakk>RETURN x \\<le> init; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    DFS_invar G param s' \\<and>\n                                    (s', s) \\<in> param_dfs_variant)\n 3. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE cond step x \\<le> WHILE cond step x", "apply (fastforce dest: order_trans) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>RETURN x \\<le> init; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    DFS_invar G param s' \\<and>\n                                    (s', s) \\<in> param_dfs_variant)\n 2. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE cond step x \\<le> WHILE cond step x", "apply (rule SPEC_rule_conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>RETURN x \\<le> init; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le> SPEC (DFS_invar G param)\n 2. \\<And>x s.\n       \\<lbrakk>RETURN x \\<le> init; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>v. (v, s) \\<in> param_dfs_variant)\n 3. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE cond step x \\<le> WHILE cond step x", "apply (rule DFS_invar_step[OF True], assumption+) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>RETURN x \\<le> init; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s\n                         \\<le> SPEC\n                                (\\<lambda>v. (v, s) \\<in> param_dfs_variant)\n 2. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE cond step x \\<le> WHILE cond step x", "apply (rule param_dfs_variant_step, (assumption|rule True)+) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       RETURN x \\<le> init \\<Longrightarrow>\n       WHILE cond step x \\<le> WHILE cond step x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  it_dfsT \\<le> it_dfs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  it_dfsT \\<le> it_dfs\n\ngoal (1 subgoal):\n 1. it_dfsT = it_dfs", "finally"], ["proof (chain)\npicking this:\n  it_dfs = it_dfsT", "show ?thesis"], ["proof (prove)\nusing this:\n  it_dfs = it_dfsT\n\ngoal (1 subgoal):\n 1. it_dfsT = it_dfs", "by simp"], ["proof (state)\nthis:\n  it_dfsT = it_dfs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Non-Failing Parameterization\\<close>"], ["", "text \\<open>\n  The proofs so far have been done modulo failure of the parameterization.\n  In this locale, we assume that the parameterization does not fail,\n  and derive the correctness proof of the DFS algorithm wrt. its invariant.\n\\<close>"], ["", "(* Locale that assumes that parameterization does not fail *)"], ["", "locale DFS =\n  param_DFS G param\n  for G :: \"('v, 'more) graph_rec_scheme\"\n  and param :: \"('v,'es) parameterization\"\n  +\n  assumes nofail_on_init: \n    \"nofail (on_init param)\"\n\n  assumes nofail_on_new_root:\n    \"pre_on_new_root v0 s \\<Longrightarrow> nofail (on_new_root param v0 s)\"\n\n  assumes nofail_on_finish: \n    \"pre_on_finish u s \\<Longrightarrow> nofail (on_finish param u s)\"\n\n  assumes nofail_on_cross_edge: \n    \"pre_on_cross_edge u v s \\<Longrightarrow> nofail (on_cross_edge param u v s)\"\n\n  assumes nofail_on_back_edge: \n    \"pre_on_back_edge u v s \\<Longrightarrow> nofail (on_back_edge param u v s)\"\n\n  assumes nofail_on_discover: \n    \"pre_on_discover u v s \\<Longrightarrow> nofail (on_discover param u v s)\"\n\nbegin"], ["", "lemmas nofails = nofail_on_init nofail_on_new_root nofail_on_finish \n    nofail_on_cross_edge nofail_on_back_edge nofail_on_discover"], ["", "lemma init_leof_invar: \"init \\<le>\\<^sub>n SPEC (DFS_invar G param)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init \\<le>\\<^sub>n SPEC (DFS_invar G param)", "unfolding rwof_eq_DFS_invar[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. init \\<le>\\<^sub>n SPEC (rwof init cond step)", "by (rule rwof_leof_init)"], ["", "lemma it_dfs_eq_spec: \"it_dfs = SPEC (\\<lambda>s. DFS_invar G param s \\<and> \\<not>cond s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfs = SPEC (\\<lambda>s. DFS_invar G param s \\<and> \\<not> cond s)", "unfolding rwof_eq_DFS_invar[symmetric] it_dfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. init \\<bind> WHILE cond step =\n    SPEC (\\<lambda>s. rwof init cond step s \\<and> \\<not> cond s)", "apply (rule nofail_WHILE_eq_rwof)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (init \\<bind> WHILE cond step)", "apply (subst WHILE_eq_I_rwof)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (init \\<bind> WHILE\\<^bsup>rwof init cond step\\<^esup> cond step)", "unfolding rwof_eq_DFS_invar"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (init \\<bind> WHILE\\<^bsup>DFS_invar G param\\<^esup> cond step)", "apply (rule SPEC_nofail[where \\<Phi>=\"\\<lambda>_. True\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. init \\<bind> WHILE\\<^bsup>DFS_invar G param\\<^esup> cond step\n    \\<le> SPEC (\\<lambda>_. True)", "apply (refine_vcg leofD[OF _ init_leof_invar, THEN weaken_SPEC])"], ["proof (prove)\ngoal (3 subgoals):\n 1. nofail init\n 2. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le> SPEC (DFS_invar G param)\n 3. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> True", "apply (simp add: init_def refine_pw_simps nofail_on_init)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> step s \\<le> SPEC (DFS_invar G param)\n 2. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> True", "apply (rule DFS_invar_step')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> nofail (step s)\n 2. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> DFS_invar G param s\n 3. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> cond s\n 4. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> True", "apply (simp add: step_def refine_pw_simps nofail_on_init do_defs \n      get_pending_def get_new_root_def pred_defs\n      split: option.split)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> (pending s `` {hd (stack s)} = {} \\<longrightarrow>\n                          (stack s = [] \\<longrightarrow>\n                           (\\<forall>x.\n                               x \\<in> V0 \\<and>\n                               x \\<notin> dom\n     (discovered s) \\<longrightarrow>\n                               nofail\n                                (on_new_root param x\n                                  (new_root x s)))) \\<and>\n                          (stack s \\<noteq> [] \\<longrightarrow>\n                           nofail\n                            (on_finish param (hd (stack s))\n                              (finish (hd (stack s)) s)))) \\<and>\n                         (pending s `` {hd (stack s)} \\<noteq>\n                          {} \\<longrightarrow>\n                          (stack s = [] \\<longrightarrow>\n                           (\\<forall>x.\n                               x \\<in> V0 \\<and>\n                               x \\<notin> dom\n     (discovered s) \\<longrightarrow>\n                               nofail\n                                (on_new_root param x\n                                  (new_root x s)))) \\<and>\n                          (stack s \\<noteq> [] \\<longrightarrow>\n                           (\\<forall>x.\n                               (x \\<in> dom (finished s) \\<longrightarrow>\n                                (x \\<in> dom\n    (discovered s) \\<longrightarrow>\n                                 (hd (stack s), x)\n                                 \\<in> pending s \\<longrightarrow>\n                                 nofail\n                                  (on_cross_edge param (hd (stack s)) x\n                                    (cross_edge (hd (stack s)) x\n(s\\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>)))) \\<and>\n                                (x \\<notin> dom\n       (discovered s) \\<longrightarrow>\n                                 (hd (stack s), x)\n                                 \\<in> pending s \\<longrightarrow>\n                                 nofail\n                                  (on_discover param (hd (stack s)) x\n                                    (discover (hd (stack s)) x\n(s\\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>))))) \\<and>\n                               (x \\<notin> dom\n      (finished s) \\<longrightarrow>\n                                (x \\<in> dom\n    (discovered s) \\<longrightarrow>\n                                 (hd (stack s), x)\n                                 \\<in> pending s \\<longrightarrow>\n                                 nofail\n                                  (on_back_edge param (hd (stack s)) x\n                                    (back_edge (hd (stack s)) x\n(s\\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>)))) \\<and>\n                                (x \\<notin> dom\n       (discovered s) \\<longrightarrow>\n                                 (hd (stack s), x)\n                                 \\<in> pending s \\<longrightarrow>\n                                 nofail\n                                  (on_discover param (hd (stack s)) x\n                                    (discover (hd (stack s)) x\n(s\\<lparr>pending := pending s - {(hd (stack s), x)}\\<rparr>))))))))\n 2. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> DFS_invar G param s\n 3. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> cond s\n 4. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s;\n        \\<not> cond s\\<rbrakk>\n       \\<Longrightarrow> True", "apply (intro allI conjI impI nofails)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x s xa.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s;\n        pending s `` {hd (stack s)} = {}; stack s = [];\n        xa \\<in> V0 \\<and> xa \\<notin> dom (discovered s)\\<rbrakk>\n       \\<Longrightarrow> pre_on_new_root xa (new_root xa s)\n 2. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s;\n        pending s `` {hd (stack s)} = {}; stack s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> pre_on_finish (hd (stack s))\n                          (finish (hd (stack s)) s)\n 3. \\<And>x s xa.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s;\n        pending s `` {hd (stack s)} \\<noteq> {}; stack s = [];\n        xa \\<in> V0 \\<and> xa \\<notin> dom (discovered s)\\<rbrakk>\n       \\<Longrightarrow> pre_on_new_root xa (new_root xa s)\n 4. \\<And>x s xa.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s;\n        pending s `` {hd (stack s)} \\<noteq> {}; stack s \\<noteq> [];\n        xa \\<in> dom (finished s); xa \\<in> dom (discovered s);\n        (hd (stack s), xa) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_on_cross_edge (hd (stack s)) xa\n                          (cross_edge (hd (stack s)) xa\n                            (s\\<lparr>pending :=\n  pending s - {(hd (stack s), xa)}\\<rparr>))\n 5. \\<And>x s xa.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s;\n        pending s `` {hd (stack s)} \\<noteq> {}; stack s \\<noteq> [];\n        xa \\<in> dom (finished s); xa \\<notin> dom (discovered s);\n        (hd (stack s), xa) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_on_discover (hd (stack s)) xa\n                          (discover (hd (stack s)) xa\n                            (s\\<lparr>pending :=\n  pending s - {(hd (stack s), xa)}\\<rparr>))\n 6. \\<And>x s xa.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s;\n        pending s `` {hd (stack s)} \\<noteq> {}; stack s \\<noteq> [];\n        xa \\<notin> dom (finished s); xa \\<in> dom (discovered s);\n        (hd (stack s), xa) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_on_back_edge (hd (stack s)) xa\n                          (back_edge (hd (stack s)) xa\n                            (s\\<lparr>pending :=\n  pending s - {(hd (stack s), xa)}\\<rparr>))\n 7. \\<And>x s xa.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s;\n        pending s `` {hd (stack s)} \\<noteq> {}; stack s \\<noteq> [];\n        xa \\<notin> dom (finished s); xa \\<notin> dom (discovered s);\n        (hd (stack s), xa) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_on_discover (hd (stack s)) xa\n                          (discover (hd (stack s)) xa\n                            (s\\<lparr>pending :=\n  pending s - {(hd (stack s), xa)}\\<rparr>))\n 8. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> DFS_invar G param s\n 9. \\<And>x s.\n       \\<lbrakk>DFS_invar G param x; DFS_invar G param s; cond s\\<rbrakk>\n       \\<Longrightarrow> cond s\n 10. \\<And>x s.\n        \\<lbrakk>DFS_invar G param x; DFS_invar G param s;\n         \\<not> cond s\\<rbrakk>\n        \\<Longrightarrow> True", "apply (auto simp add: pre_on_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma it_dfs_correct: \"it_dfs \\<le> SPEC (\\<lambda>s. DFS_invar G param s \\<and> \\<not>cond s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfs \\<le> SPEC (\\<lambda>s. DFS_invar G param s \\<and> \\<not> cond s)", "by (simp add: it_dfs_eq_spec)"], ["", "lemma it_dfs_SPEC:\n    assumes \"\\<And>s. \\<lbrakk>DFS_invar G param s; \\<not>cond s\\<rbrakk> \\<Longrightarrow> P s\"\n    shows \"it_dfs \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfs \\<le> SPEC P", "using weaken_SPEC[OF it_dfs_correct]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      DFS_invar G param x \\<and> \\<not> cond x \\<Longrightarrow>\n      ?\\<Psi> x) \\<Longrightarrow>\n  it_dfs \\<le> SPEC ?\\<Psi>\n\ngoal (1 subgoal):\n 1. it_dfs \\<le> SPEC P", "using assms"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      DFS_invar G param x \\<and> \\<not> cond x \\<Longrightarrow>\n      ?\\<Psi> x) \\<Longrightarrow>\n  it_dfs \\<le> SPEC ?\\<Psi>\n  \\<lbrakk>DFS_invar G param ?s4; \\<not> cond ?s4\\<rbrakk>\n  \\<Longrightarrow> P ?s4\n\ngoal (1 subgoal):\n 1. it_dfs \\<le> SPEC P", "by blast"], ["", "lemma it_dfsT_correct: \n    assumes \"finite reachable\"\n    shows \"it_dfsT \\<le> SPEC (\\<lambda>s. DFS_invar G param s \\<and> \\<not>cond s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfsT\n    \\<le> SPEC (\\<lambda>s. DFS_invar G param s \\<and> \\<not> cond s)", "apply (subst it_dfsT_eq_it_dfs[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfs \\<le> SPEC (\\<lambda>s. DFS_invar G param s \\<and> \\<not> cond s)", "by (rule it_dfs_correct)"], ["", "lemma it_dfsT_SPEC:\n    assumes \"finite reachable\"\n    assumes \"\\<And>s. \\<lbrakk>DFS_invar G param s; \\<not>cond s\\<rbrakk> \\<Longrightarrow> P s\"\n    shows \"it_dfsT \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfsT \\<le> SPEC P", "apply (subst it_dfsT_eq_it_dfs[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. it_dfs \\<le> SPEC P", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>DFS_invar G param ?s4; \\<not> cond ?s4\\<rbrakk>\n  \\<Longrightarrow> P ?s4\n\ngoal (1 subgoal):\n 1. it_dfs \\<le> SPEC P", "by (rule it_dfs_SPEC)"], ["", "end"], ["", "end"]]}