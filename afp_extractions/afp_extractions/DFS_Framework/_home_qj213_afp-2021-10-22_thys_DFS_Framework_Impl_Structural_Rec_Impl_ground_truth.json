{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Impl/Structural/Rec_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma gen_step'_refine: \n    \"\\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk> \\<Longrightarrow> gen_step' s \\<le> gen_step s\"", "lemma gen_dfs'_refine: \"gen_dfs' \\<le> gen_dfs\"", "lemma gen_rwof'_imp_rwof:\n    assumes NF: \"nofail gen_dfs\"\n    assumes A: \"gen_rwof' s\"\n    shows \"gen_rwof s\"", "lemma reachable_invar: \n    \"gen_rwof' s \\<Longrightarrow> set (stack s) \\<subseteq> reachable \\<and> pending s \\<subseteq> E \n      \\<and> set (stack s) \\<subseteq> gen_discovered s \\<and> distinct (stack s)\n      \\<and> pending s \\<subseteq> set (stack s) \\<times> UNIV\"", "lemma mk_spec_aux: \n    \"\\<lbrakk>m \\<le>\\<^sub>n SPEC \\<Phi>; m\\<le>SPEC gen_rwof' \\<rbrakk> \\<Longrightarrow> m \\<le> SPEC (\\<lambda>s. gen_rwof' s \\<and> \\<Phi> s)\"", "lemma pcp_imp_pgp: \n      \"post_choose_pending u vo s0 s \\<Longrightarrow> post_get_pending u vo s0 s\"", "lemma rec_impl_aux: \"\\<lbrakk> xd\\<notin>Domain P \\<rbrakk> \\<Longrightarrow> P - {y} \\<times> (succ y - ita) - {(y, xd)} - {xd} \\<times> UNIV =\n           P - insert (y, xd) ({y} \\<times> (succ y - ita))\"", "lemma rec_impl: \"rec_impl \\<le> gen_dfs\""], "translations": [["", "lemma gen_step'_refine: \n    \"\\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk> \\<Longrightarrow> gen_step' s \\<le> gen_step s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk>\n    \\<Longrightarrow> gen_step' s \\<le> gen_step s", "apply (simp only: gen_step'_def gen_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk>\n    \\<Longrightarrow> ASSERT True \\<bind>\n                      (\\<lambda>_.\n                          if gds_is_empty_stack gds s\n                          then SPEC\n                                (\\<lambda>v0.\n                                    v0 \\<in> V0 \\<and>\n                                    \\<not> gds_is_discovered gds v0\n      s) \\<bind>\n                               (\\<lambda>v0. gds_new_root gds v0 s)\n                          else let u = hd (stack s)\n                               in SELECT\n                                   (\\<lambda>v.\n (u, v) \\<in> pending s) \\<bind>\n                                  (\\<lambda>Vs.\nchoose_pending u Vs s \\<bind>\n(\\<lambda>s.\n    case Vs of None \\<Rightarrow> gds_finish gds u s\n    | Some v \\<Rightarrow>\n        if gds_is_discovered gds v s\n        then if gds_is_finished gds v s then gds_cross_edge gds u v s\n             else gds_back_edge gds u v s\n        else gds_discover gds u v s)))\n                      \\<le> (if gds_is_empty_stack gds s\n                             then SPEC\n                                   (\\<lambda>v0.\n v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                  (\\<lambda>v0. gds_new_root gds v0 s)\n                             else gds_get_pending gds s \\<bind>\n                                  (\\<lambda>(u, Vs, s).\ncase Vs of None \\<Rightarrow> gds_finish gds u s\n| Some v \\<Rightarrow>\n    if gds_is_discovered gds v s\n    then if gds_is_finished gds v s then gds_cross_edge gds u v s\n         else gds_back_edge gds u v s\n    else gds_discover gds u v s))", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof s; gen_cond s; stack s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> SELECT\n                       (\\<lambda>v.\n                           (hd (stack s), v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending (hd (stack s)) Vs s \\<bind>\n                          (\\<lambda>sa.\n                              case Vs of\n                              None \\<Rightarrow>\n                                gds_finish gds (hd (stack s)) sa\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v sa\n                                  then if gds_is_finished gds v sa\n then gds_cross_edge gds (hd (stack s)) v sa\n else gds_back_edge gds (hd (stack s)) v sa\n                                  else gds_discover gds (hd (stack s)) v\n  sa))\n                      \\<le> gds_get_pending gds s \\<bind>\n                            (\\<lambda>(u, Vs, s).\n                                case Vs of\n                                None \\<Rightarrow> gds_finish gds u s\n                                | Some v \\<Rightarrow>\n                                    if gds_is_discovered gds v s\n                                    then if gds_is_finished gds v s\n   then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                    else gds_discover gds u v s)", "apply (rule order_trans[OF _ bind_mono(1)[OF get_pending_fmt order_refl]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>gen_rwof s; gen_cond s; stack s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> SELECT\n                       (\\<lambda>v.\n                           (hd (stack s), v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending (hd (stack s)) Vs s \\<bind>\n                          (\\<lambda>sa.\n                              case Vs of\n                              None \\<Rightarrow>\n                                gds_finish gds (hd (stack s)) sa\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v sa\n                                  then if gds_is_finished gds v sa\n then gds_cross_edge gds (hd (stack s)) v sa\n else gds_back_edge gds (hd (stack s)) v sa\n                                  else gds_discover gds (hd (stack s)) v\n  sa))\n                      \\<le> (let u = hd (stack s)\n                             in SELECT\n                                 (\\<lambda>v.\n                                     (u, v) \\<in> pending s) \\<bind>\n                                (\\<lambda>vo.\n                                    choose_pending u vo s \\<bind>\n                                    (\\<lambda>s.\n  RETURN (u, vo, s)))) \\<bind>\n                            (\\<lambda>x.\n                                case x of\n                                (u, None, s) \\<Rightarrow>\n                                  gds_finish gds u s\n                                | (u, Some v, s) \\<Rightarrow>\n                                    if gds_is_discovered gds v s\n                                    then if gds_is_finished gds v s\n   then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                    else gds_discover gds u v s)\n 2. \\<lbrakk>gen_rwof s; gen_cond s; stack s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> pre_get_pending s", "apply (simp add: pw_le_iff refine_pw_simps\n      split: option.splits if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof s; gen_cond s; stack s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> pre_get_pending s", "apply (simp add: pre_defs gen_cond_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_dfs'_refine: \"gen_dfs' \\<le> gen_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs' \\<le> gen_dfs", "unfolding gen_dfs'_def gen_dfs_def WHILE_eq_I_rwof[where f=gen_step]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE gen_cond gen_step'\n    \\<le> gds_init gds \\<bind>\n          WHILE\\<^bsup>gen_rwof\\<^esup> gen_cond gen_step", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<bind> WHILE gen_cond gen_step'\n    \\<le> \\<Down> Id\n           (gds_init gds \\<bind>\n            WHILE\\<^bsup>gen_rwof\\<^esup> gen_cond gen_step)", "apply (refine_rcg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id; (xa, x'a) \\<in> Id; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> gen_cond xa = gen_cond x'a\n 2. \\<And>x x' xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id; (xa, x'a) \\<in> Id; gen_cond xa;\n        gen_cond x'a; gen_rwof x'a\\<rbrakk>\n       \\<Longrightarrow> gen_step' xa \\<le> \\<Down> Id (gen_step x'a)", "by (simp_all add: gen_step'_refine)"], ["", "lemma gen_rwof'_imp_rwof:\n    assumes NF: \"nofail gen_dfs\"\n    assumes A: \"gen_rwof' s\"\n    shows \"gen_rwof s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_rwof s", "apply (rule rwof_step_refine)"], ["proof (prove)\ngoal (3 subgoals):\n 1. nofail (gds_init gds \\<bind> WHILE gen_cond gen_step)\n 2. rwof (gds_init gds) gen_cond ?step' s\n 3. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> ?step' s \\<le>\\<^sub>n gen_step s", "apply (rule NF[unfolded gen_dfs_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. rwof (gds_init gds) gen_cond ?step' s\n 2. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> ?step' s \\<le>\\<^sub>n gen_step s", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof s; gen_cond s\\<rbrakk>\n       \\<Longrightarrow> gen_step' s \\<le>\\<^sub>n gen_step s", "apply (rule leof_lift[OF gen_step'_refine], assumption+) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reachable_invar: \n    \"gen_rwof' s \\<Longrightarrow> set (stack s) \\<subseteq> reachable \\<and> pending s \\<subseteq> E \n      \\<and> set (stack s) \\<subseteq> gen_discovered s \\<and> distinct (stack s)\n      \\<and> pending s \\<subseteq> set (stack s) \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_rwof' s \\<Longrightarrow>\n    set (stack s) \\<subseteq> reachable \\<and>\n    pending s \\<subseteq> E \\<and>\n    set (stack s) \\<subseteq> gen_discovered s \\<and>\n    distinct (stack s) \\<and>\n    pending s \\<subseteq> set (stack s) \\<times> UNIV", "apply (erule establish_rwof_invar[rotated -1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. gds_init gds \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>a.\n         set (stack a) \\<subseteq> reachable \\<and>\n         pending a \\<subseteq> E \\<and>\n         set (stack a) \\<subseteq> gen_discovered a \\<and>\n         distinct (stack a) \\<and>\n         pending a \\<subseteq> set (stack a) \\<times> UNIV)\n 2. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s\\<rbrakk>\n       \\<Longrightarrow> gen_step' s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              set (stack a) \\<subseteq> reachable \\<and>\n                              pending a \\<subseteq> E \\<and>\n                              set (stack a)\n                              \\<subseteq> gen_discovered a \\<and>\n                              distinct (stack a) \\<and>\n                              pending a\n                              \\<subseteq> set (stack a) \\<times> UNIV)", "apply (rule leof_trans[OF init_spec], auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s\\<rbrakk>\n       \\<Longrightarrow> gen_step' s \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              set (stack a) \\<subseteq> reachable \\<and>\n                              pending a \\<subseteq> E \\<and>\n                              set (stack a)\n                              \\<subseteq> gen_discovered a \\<and>\n                              distinct (stack a) \\<and>\n                              pending a\n                              \\<subseteq> set (stack a) \\<times> UNIV)", "apply (subst gen_step'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s\\<rbrakk>\n       \\<Longrightarrow> ASSERT (gen_rwof s) \\<bind>\n                         (\\<lambda>_.\n                             if gds_is_empty_stack gds s\n                             then SPEC\n                                   (\\<lambda>v0.\n v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                  (\\<lambda>v0. gds_new_root gds v0 s)\n                             else let u = hd (stack s)\n                                  in SELECT\n(\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                                     (\\<lambda>Vs.\n   choose_pending u Vs s \\<bind>\n   (\\<lambda>s.\n       case Vs of None \\<Rightarrow> gds_finish gds u s\n       | Some v \\<Rightarrow>\n           if gds_is_discovered gds v s\n           then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                else gds_back_edge gds u v s\n           else gds_discover gds u v s))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>a.\n                              set (stack a) \\<subseteq> reachable \\<and>\n                              pending a \\<subseteq> E \\<and>\n                              set (stack a)\n                              \\<subseteq> gen_discovered a \\<and>\n                              distinct (stack a) \\<and>\n                              pending a\n                              \\<subseteq> set (stack a) \\<times> UNIV)", "apply (refine_rcg refine_vcg\n      leof_trans[OF new_root_spec]\n      SELECT_rule[THEN leof_lift]\n      leof_trans[OF choose_pending_spec[THEN leof_strengthen_SPEC]]\n      leof_trans[OF finish_spec]\n      leof_trans[OF cross_edge_spec]\n      leof_trans[OF back_edge_spec]\n      leof_trans[OF discover_spec]\n      )"], ["proof (prove)\ngoal (60 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; gds_is_empty_stack gds s;\n        x \\<in> {v0 \\<in> V0. \\<not> gds_is_discovered gds v0 s}\\<rbrakk>\n       \\<Longrightarrow> pre_new_root x s\n 2. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; gds_is_empty_stack gds s;\n        x \\<in> {v0 \\<in> V0. \\<not> gds_is_discovered gds v0 s};\n        xa \\<in> {s'.\n                  stack s' = [x] \\<and>\n                  pending s' = {x} \\<times> E `` {x} \\<and>\n                  gen_discovered s' = insert x (gen_discovered s)}\\<rbrakk>\n       \\<Longrightarrow> set (stack xa) \\<subseteq> reachable\n 3. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; gds_is_empty_stack gds s;\n        x \\<in> {v0 \\<in> V0. \\<not> gds_is_discovered gds v0 s};\n        xa \\<in> {s'.\n                  stack s' = [x] \\<and>\n                  pending s' = {x} \\<times> E `` {x} \\<and>\n                  gen_discovered s' = insert x (gen_discovered s)}\\<rbrakk>\n       \\<Longrightarrow> pending xa \\<subseteq> E\n 4. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; gds_is_empty_stack gds s;\n        x \\<in> {v0 \\<in> V0. \\<not> gds_is_discovered gds v0 s};\n        xa \\<in> {s'.\n                  stack s' = [x] \\<and>\n                  pending s' = {x} \\<times> E `` {x} \\<and>\n                  gen_discovered s' = insert x (gen_discovered s)}\\<rbrakk>\n       \\<Longrightarrow> set (stack xa) \\<subseteq> gen_discovered xa\n 5. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; gds_is_empty_stack gds s;\n        x \\<in> {v0 \\<in> V0. \\<not> gds_is_discovered gds v0 s};\n        xa \\<in> {s'.\n                  stack s' = [x] \\<and>\n                  pending s' = {x} \\<times> E `` {x} \\<and>\n                  gen_discovered s' = insert x (gen_discovered s)}\\<rbrakk>\n       \\<Longrightarrow> distinct (stack xa)\n 6. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; gds_is_empty_stack gds s;\n        x \\<in> {v0 \\<in> V0. \\<not> gds_is_discovered gds v0 s};\n        xa \\<in> {s'.\n                  stack s' = [x] \\<and>\n                  pending s' = {x} \\<times> E `` {x} \\<and>\n                  gen_discovered s' = insert x (gen_discovered s)}\\<rbrakk>\n       \\<Longrightarrow> pending xa \\<subseteq> set (stack xa) \\<times> UNIV\n 7. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        (hd (stack s), x) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 8. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        (hd (stack s), x) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> hd (stack s) = hd (stack s)\n 9. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n        (hd (stack s), x) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> case Some x of\n                         None \\<Rightarrow> pending s `` {hd (stack s)} = {}\n                         | Some v \\<Rightarrow>\n                             v \\<in> pending s `` {hd (stack s)}\n 10. \\<And>s x xa.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; \\<not> gds_is_empty_stack gds s;\n         (hd (stack s), x) \\<in> pending s;\n         xa \\<in> {xa.\n                   inres (choose_pending (hd (stack s)) (Some x) s)\n                    xa \\<and>\n                   (case Some x of None \\<Rightarrow> pending xa = pending s\n                    | Some v \\<Rightarrow>\n                        pending xa = pending s - {(hd (stack s), v)}) \\<and>\n                   stack xa = stack s \\<and>\n                   (\\<forall>x.\n                       gds_is_discovered gds x xa =\n                       gds_is_discovered gds x s)};\n         Some x = None\\<rbrakk>\n        \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.67 s x xa) xa\nA total of 60 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (23 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>gen_rwof' s; pending s \\<subseteq> E \\<and> pending s = {};\n        gen_cond s; gen_rwof s; stack s = [];\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s\\<rbrakk>\n       \\<Longrightarrow> pre_new_root x s\n 2. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s; pending s \\<subseteq> E \\<and> pending s = {};\n        gen_cond s; gen_rwof s; stack s = [];\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s;\n        stack xa = [x] \\<and>\n        pending xa = {x} \\<times> E `` {x} \\<and>\n        gen_discovered xa = insert x (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> reachable\n 3. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s; pending s \\<subseteq> E \\<and> pending s = {};\n        gen_cond s; gen_rwof s; stack s = [];\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s;\n        stack xa = [x] \\<and>\n        pending xa = {x} \\<times> E `` {x} \\<and>\n        gen_discovered xa = insert x (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> {x} \\<times> E `` {x} \\<subseteq> E\n 4. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s; pending s \\<subseteq> E \\<and> pending s = {};\n        gen_cond s; gen_rwof s; stack s = [];\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s;\n        stack xa = [x] \\<and>\n        pending xa = {x} \\<times> E `` {x} \\<and>\n        gen_discovered xa = insert x (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> {x} \\<times> E `` {x} \\<subseteq> {x} \\<times> UNIV\n 5. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), x) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 6. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_cross_edge (hd (stack s)) v (?s0.76 s v xa v)\n                          xa\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 9. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n         pending xb = pending s - {(hd (stack s), v)} \\<and>\n         stack xb = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xb =\n             gds_is_discovered gds x s)\\<rbrakk>\n        \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\nA total of 23 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_; pending s_ \\<subseteq> E \\<and> pending s_ = {};\n     gen_cond s_; gen_rwof s_; stack s_ = [];\n     x_ \\<in> V0 \\<and> \\<not> gds_is_discovered gds x_ s_\\<rbrakk>\n    \\<Longrightarrow> pre_new_root x_ s_", "by (simp add: pre_defs, simp add: gen_cond_def)"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s; pending s \\<subseteq> E \\<and> pending s = {};\n        gen_cond s; gen_rwof s; stack s = [];\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s;\n        stack xa = [x] \\<and>\n        pending xa = {x} \\<times> E `` {x} \\<and>\n        gen_discovered xa = insert x (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> reachable\n 2. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s; pending s \\<subseteq> E \\<and> pending s = {};\n        gen_cond s; gen_rwof s; stack s = [];\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s;\n        stack xa = [x] \\<and>\n        pending xa = {x} \\<times> E `` {x} \\<and>\n        gen_discovered xa = insert x (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> {x} \\<times> E `` {x} \\<subseteq> E\n 3. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s; pending s \\<subseteq> E \\<and> pending s = {};\n        gen_cond s; gen_rwof s; stack s = [];\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s;\n        stack xa = [x] \\<and>\n        pending xa = {x} \\<times> E `` {x} \\<and>\n        gen_discovered xa = insert x (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> {x} \\<times> E `` {x} \\<subseteq> {x} \\<times> UNIV\n 4. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), x) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 5. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_cross_edge (hd (stack s)) v (?s0.76 s v xa v)\n                          xa\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 8. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n         pending xb = pending s - {(hd (stack s), v)} \\<and>\n         stack xb = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xb =\n             gds_is_discovered gds x s)\\<rbrakk>\n        \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                          \\<subseteq> set (stack s) \\<times> UNIV\nA total of 22 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_; pending s_ \\<subseteq> E \\<and> pending s_ = {};\n     gen_cond s_; gen_rwof s_; stack s_ = [];\n     x_ \\<in> V0 \\<and> \\<not> gds_is_discovered gds x_ s_;\n     stack xa_ = [x_] \\<and>\n     pending xa_ = {x_} \\<times> E `` {x_} \\<and>\n     gen_discovered xa_ = insert x_ (gen_discovered s_)\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> reachable", "by auto"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s; pending s \\<subseteq> E \\<and> pending s = {};\n        gen_cond s; gen_rwof s; stack s = [];\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s;\n        stack xa = [x] \\<and>\n        pending xa = {x} \\<times> E `` {x} \\<and>\n        gen_discovered xa = insert x (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> {x} \\<times> E `` {x} \\<subseteq> E\n 2. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s; pending s \\<subseteq> E \\<and> pending s = {};\n        gen_cond s; gen_rwof s; stack s = [];\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s;\n        stack xa = [x] \\<and>\n        pending xa = {x} \\<times> E `` {x} \\<and>\n        gen_discovered xa = insert x (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> {x} \\<times> E `` {x} \\<subseteq> {x} \\<times> UNIV\n 3. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), x) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 4. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_cross_edge (hd (stack s)) v (?s0.76 s v xa v)\n                          xa\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 7. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 10. \\<And>s x xa v.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n        \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\nA total of 21 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_; pending s_ \\<subseteq> E \\<and> pending s_ = {};\n     gen_cond s_; gen_rwof s_; stack s_ = [];\n     x_ \\<in> V0 \\<and> \\<not> gds_is_discovered gds x_ s_;\n     stack xa_ = [x_] \\<and>\n     pending xa_ = {x_} \\<times> E `` {x_} \\<and>\n     gen_discovered xa_ = insert x_ (gen_discovered s_)\\<rbrakk>\n    \\<Longrightarrow> {x_} \\<times> E `` {x_} \\<subseteq> E", "by auto"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s; pending s \\<subseteq> E \\<and> pending s = {};\n        gen_cond s; gen_rwof s; stack s = [];\n        x \\<in> V0 \\<and> \\<not> gds_is_discovered gds x s;\n        stack xa = [x] \\<and>\n        pending xa = {x} \\<times> E `` {x} \\<and>\n        gen_discovered xa = insert x (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> {x} \\<times> E `` {x} \\<subseteq> {x} \\<times> UNIV\n 2. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), x) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_cross_edge (hd (stack s)) v (?s0.76 s v xa v)\n                          xa\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 6. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 9. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> v \\<in> reachable\nA total of 20 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_; pending s_ \\<subseteq> E \\<and> pending s_ = {};\n     gen_cond s_; gen_rwof s_; stack s_ = [];\n     x_ \\<in> V0 \\<and> \\<not> gds_is_discovered gds x_ s_;\n     stack xa_ = [x_] \\<and>\n     pending xa_ = {x_} \\<times> E `` {x_} \\<and>\n     gen_discovered xa_ = insert x_ (gen_discovered s_)\\<rbrakk>\n    \\<Longrightarrow> {x_} \\<times> E `` {x_} \\<subseteq> {x_} \\<times> UNIV", "by auto"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), x) \\<in> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_cross_edge (hd (stack s)) v (?s0.76 s v xa v)\n                          xa\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 5. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 8. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                          \\<subseteq> E \\<and>\n                          {v} \\<times> E `` {v} \\<subseteq> E\nA total of 19 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), x_) \\<in> pending s_\\<rbrakk>\n    \\<Longrightarrow> pre_get_pending s_", "by (simp add: pre_defs, simp add: gen_cond_def)"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_cross_edge (hd (stack s)) v (?s0.76 s v xa v)\n                          xa\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 4. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 7. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> set (stack s)\n                          \\<subseteq> insert v (gen_discovered s)\nA total of 18 subgoals...", "apply ((unfold pre_defs, intro conjI); assumption?) []"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_empty_stack gds s\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_break gds s\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), Some v, xa)\n 4. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds v xa\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 7. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 10. \\<And>s x xa v.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n        \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\nA total of 21 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     gds_is_finished gds v_ xa_\\<rbrakk>\n    \\<Longrightarrow> \\<not> gds_is_empty_stack gds s_", "by (clarsimp simp: gen_cond_def)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_break gds s\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), Some v, xa)\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds v xa\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 6. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 9. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> v \\<in> reachable\nA total of 20 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     gds_is_finished gds v_ xa_\\<rbrakk>\n    \\<Longrightarrow> \\<not> gds_is_break gds s_", "by (clarsimp simp: gen_cond_def)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), Some v, xa)\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds v xa\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 5. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 8. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                          \\<subseteq> E \\<and>\n                          {v} \\<times> E `` {v} \\<subseteq> E\nA total of 19 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     gds_is_finished gds v_ xa_\\<rbrakk>\n    \\<Longrightarrow> inres (gds_get_pending gds s_)\n                       (hd (stack s_), Some v_, xa_)", "apply (rule pwD2[OF get_pending_fmt])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     gds_is_finished gds v_ xa_\\<rbrakk>\n    \\<Longrightarrow> pre_get_pending s_\n 2. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     gds_is_finished gds v_ xa_\\<rbrakk>\n    \\<Longrightarrow> inres\n                       (let u = hd (stack s_)\n                        in SELECT\n                            (\\<lambda>v. (u, v) \\<in> pending s_) \\<bind>\n                           (\\<lambda>vo.\n                               choose_pending u vo s_ \\<bind>\n                               (\\<lambda>s. RETURN (u, vo, s))))\n                       (hd (stack s_), Some v_, xa_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     gds_is_finished gds v_ xa_\\<rbrakk>\n    \\<Longrightarrow> pre_get_pending s_", "by (simp add: pre_defs gen_cond_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     gds_is_finished gds v_ xa_\\<rbrakk>\n    \\<Longrightarrow> inres\n                       (let u = hd (stack s_)\n                        in SELECT\n                            (\\<lambda>v. (u, v) \\<in> pending s_) \\<bind>\n                           (\\<lambda>vo.\n                               choose_pending u vo s_ \\<bind>\n                               (\\<lambda>s. RETURN (u, vo, s))))\n                       (hd (stack s_), Some v_, xa_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     gds_is_finished gds v_ xa_\\<rbrakk>\n    \\<Longrightarrow> inres\n                       (let u = hd (stack s_)\n                        in SELECT\n                            (\\<lambda>v. (u, v) \\<in> pending s_) \\<bind>\n                           (\\<lambda>vo.\n                               choose_pending u vo s_ \\<bind>\n                               (\\<lambda>s. RETURN (u, vo, s))))\n                       (hd (stack s_), Some v_, xa_)", "by (clarsimp simp: refine_pw_simps; blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds v xa\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 4. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 7. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> set (stack s)\n                          \\<subseteq> insert v (gen_discovered s)\nA total of 18 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     gds_is_finished gds v_ xa_\\<rbrakk>\n    \\<Longrightarrow> gds_is_discovered gds v_ xa_", "by (force simp: neq_Nil_conv) []"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 6. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> v \\<notin> set (stack s)\nA total of 17 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_; gds_is_finished gds v_ xa_;\n     pending xb_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xb_ = stack s_ \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x xb_ = gds_is_discovered gds x s_)\\<rbrakk>\n    \\<Longrightarrow> pending s_ - {(hd (stack s_), v_)} \\<subseteq> E", "by (clarsimp simp: neq_Nil_conv gen_cond_def, blast) []"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 5. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                          \\<subseteq> insert v (set (stack s)) \\<times>\nUNIV \\<and>\n                          {v} \\<times> E `` {v}\n                          \\<subseteq> insert v (set (stack s)) \\<times> UNIV\nA total of 16 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_; gds_is_finished gds v_ xa_;\n     pending xb_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xb_ = stack s_ \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x xb_ = gds_is_discovered gds x s_)\\<rbrakk>\n    \\<Longrightarrow> pending s_ - {(hd (stack s_), v_)}\n                      \\<subseteq> set (stack s_) \\<times> UNIV", "by (clarsimp simp: neq_Nil_conv gen_cond_def; auto)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge (hd (stack s)) v (?s0.83 s v xa v) xa\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 4. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 10. \\<And>s.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n        \\<Longrightarrow> pre_get_pending s\nA total of 15 subgoals...", "apply (unfold pre_defs, intro conjI, assumption) []"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_empty_stack gds s\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_break gds s\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), Some v, xa)\n 4. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds v xa\n 5. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_finished gds v xa\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 8. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                          \\<subseteq> E \\<and>\n                          {v} \\<times> E `` {v} \\<subseteq> E\nA total of 19 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     \\<not> gds_is_finished gds v_ xa_\\<rbrakk>\n    \\<Longrightarrow> \\<not> gds_is_empty_stack gds s_", "by (clarsimp_all simp: gen_cond_def)"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_break gds s\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), Some v, xa)\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds v xa\n 4. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_finished gds v xa\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 7. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> set (stack s)\n                          \\<subseteq> insert v (gen_discovered s)\nA total of 18 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     \\<not> gds_is_finished gds v_ xa_\\<rbrakk>\n    \\<Longrightarrow> \\<not> gds_is_break gds s_", "by (clarsimp_all simp: gen_cond_def)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), Some v, xa)\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds v xa\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_finished gds v xa\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 6. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> v \\<notin> set (stack s)\nA total of 17 subgoals...", "apply (rule pwD2[OF get_pending_fmt])"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> inres\n                          (let u = hd (stack s)\n                           in SELECT\n                               (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                              (\\<lambda>vo.\n                                  choose_pending u vo s \\<bind>\n                                  (\\<lambda>s. RETURN (u, vo, s))))\n                          (hd (stack s), Some v, xa)\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds v xa\n 4. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_finished gds v xa\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 7. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> set (stack s)\n                          \\<subseteq> insert v (gen_discovered s)\nA total of 18 subgoals...", "apply (simp add: pre_defs gen_cond_def; fail)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> inres\n                          (let u = hd (stack s)\n                           in SELECT\n                               (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                              (\\<lambda>vo.\n                                  choose_pending u vo s \\<bind>\n                                  (\\<lambda>s. RETURN (u, vo, s))))\n                          (hd (stack s), Some v, xa)\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds v xa\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_finished gds v xa\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 6. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> v \\<notin> set (stack s)\nA total of 17 subgoals...", "apply (clarsimp simp: refine_pw_simps select_def, blast; fail)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> gds_is_discovered gds v xa\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_finished gds v xa\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 5. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 10. \\<And>s x xa v xb.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         (hd (stack s), v) \\<in> pending s;\n         inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n         pending xa = pending s - {(hd (stack s), v)} \\<and>\n         stack xa = stack s \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa = gds_is_discovered gds x s);\n         x = v; \\<not> gds_is_discovered gds v s;\n         pending xb =\n         pending s - {(hd (stack s), v)} \\<union>\n         {v} \\<times> E `` {v} \\<and>\n         stack xb = v # stack s \\<and>\n         gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n        \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                          \\<subseteq> insert v (set (stack s)) \\<times>\nUNIV \\<and>\n                          {v} \\<times> E `` {v}\n                          \\<subseteq> insert v (set (stack s)) \\<times> UNIV\nA total of 16 subgoals...", "apply (simp; fail)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s;\n        \\<not> gds_is_finished gds v xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_finished gds v xa\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 4. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 10. \\<And>s.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n        \\<Longrightarrow> pre_get_pending s\nA total of 15 subgoals...", "apply (simp; fail)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)} \\<subseteq> E\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 9. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 10. \\<And>s.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n        \\<Longrightarrow> pending s `` {hd (stack s)} = {}\nA total of 14 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     \\<not> gds_is_finished gds v_ xa_;\n     pending xb_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xb_ = stack s_ \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x xb_ = gds_is_discovered gds x s_)\\<rbrakk>\n    \\<Longrightarrow> pending s_ - {(hd (stack s_), v_)} \\<subseteq> E", "by auto"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; gds_is_discovered gds v s; \\<not> gds_is_finished gds v xa;\n        pending xb = pending s - {(hd (stack s), v)} \\<and>\n        stack xb = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xb = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> set (stack s) \\<times> UNIV\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 8. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 9. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 10. \\<And>s x.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n         inres (choose_pending (hd (stack s)) None s) x \\<and>\n         pending x = pending s \\<and>\n         stack x = stack s \\<and>\n         (\\<forall>xa.\n             gds_is_discovered gds xa x =\n             gds_is_discovered gds xa s)\\<rbrakk>\n        \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\nA total of 13 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; gds_is_discovered gds v_ s_;\n     \\<not> gds_is_finished gds v_ xa_;\n     pending xb_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xb_ = stack s_ \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x xb_ = gds_is_discovered gds x s_)\\<rbrakk>\n    \\<Longrightarrow> pending s_ - {(hd (stack s_), v_)}\n                      \\<subseteq> set (stack s_) \\<times> UNIV", "by fast"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_discover (hd (stack s)) v (?s0.90 s v xa v) xa\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 7. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 8. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 9. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\n 10. \\<And>s x xa.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n         inres (choose_pending (hd (stack s)) None s) x \\<and>\n         pending x = pending s \\<and>\n         stack x = stack s \\<and>\n         (\\<forall>xa.\n             gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n         pending xa = pending s \\<and>\n         stack xa = tl (stack s) \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa =\n             gds_is_discovered gds x s)\\<rbrakk>\n        \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\nA total of 12 subgoals...", "apply (unfold pre_defs, intro conjI, assumption) []"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_empty_stack gds s\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_break gds s\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), Some v, xa)\n 4. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_discovered gds v xa\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 9. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 10. \\<And>s.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n        \\<Longrightarrow> pre_get_pending s\nA total of 15 subgoals...", "apply (clarsimp simp: gen_cond_def; fail)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_break gds s\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), Some v, xa)\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_discovered gds v xa\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 9. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 10. \\<And>s.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n        \\<Longrightarrow> pending s `` {hd (stack s)} = {}\nA total of 14 subgoals...", "apply (clarsimp simp: gen_cond_def; fail)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), Some v, xa)\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_discovered gds v xa\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 8. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 9. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 10. \\<And>s x.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n         inres (choose_pending (hd (stack s)) None s) x \\<and>\n         pending x = pending s \\<and>\n         stack x = stack s \\<and>\n         (\\<forall>xa.\n             gds_is_discovered gds xa x =\n             gds_is_discovered gds xa s)\\<rbrakk>\n        \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\nA total of 13 subgoals...", "apply (rule pwD2[OF get_pending_fmt])"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> inres\n                          (let u = hd (stack s)\n                           in SELECT\n                               (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                              (\\<lambda>vo.\n                                  choose_pending u vo s \\<bind>\n                                  (\\<lambda>s. RETURN (u, vo, s))))\n                          (hd (stack s), Some v, xa)\n 3. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_discovered gds v xa\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 8. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 9. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 10. \\<And>s.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n        \\<Longrightarrow> pending s `` {hd (stack s)} = {}\nA total of 14 subgoals...", "apply (simp add: pre_defs gen_cond_def; fail)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> inres\n                          (let u = hd (stack s)\n                           in SELECT\n                               (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                              (\\<lambda>vo.\n                                  choose_pending u vo s \\<bind>\n                                  (\\<lambda>s. RETURN (u, vo, s))))\n                          (hd (stack s), Some v, xa)\n 2. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_discovered gds v xa\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 7. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 8. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 9. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 10. \\<And>s x.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n         inres (choose_pending (hd (stack s)) None s) x \\<and>\n         pending x = pending s \\<and>\n         stack x = stack s \\<and>\n         (\\<forall>xa.\n             gds_is_discovered gds xa x =\n             gds_is_discovered gds xa s)\\<rbrakk>\n        \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\nA total of 13 subgoals...", "apply (clarsimp simp: refine_pw_simps select_def, blast; fail)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>s x xa v.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_discovered gds v xa\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 6. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 7. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 8. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 9. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\n 10. \\<And>s x xa.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n         inres (choose_pending (hd (stack s)) None s) x \\<and>\n         pending x = pending s \\<and>\n         stack x = stack s \\<and>\n         (\\<forall>xa.\n             gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n         pending xa = pending s \\<and>\n         stack xa = tl (stack s) \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa =\n             gds_is_discovered gds x s)\\<rbrakk>\n        \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\nA total of 12 subgoals...", "apply (simp; fail)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> reachable\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 5. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 6. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 7. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 8. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\n 9. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 10. \\<And>s x xa.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n         inres (choose_pending (hd (stack s)) None s) x \\<and>\n         pending x = pending s \\<and>\n         stack x = stack s \\<and>\n         (\\<forall>xa.\n             gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n         pending xa = pending s \\<and>\n         stack xa = tl (stack s) \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa =\n             gds_is_discovered gds x s)\\<rbrakk>\n        \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; \\<not> gds_is_discovered gds v_ s_;\n     pending xb_ =\n     pending s_ - {(hd (stack s_), v_)} \\<union>\n     {v_} \\<times> E `` {v_} \\<and>\n     stack xb_ = v_ # stack s_ \\<and>\n     gen_discovered xb_ = insert v_ (gen_discovered s_)\\<rbrakk>\n    \\<Longrightarrow> v_ \\<in> reachable", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_; gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_; x_ = v_;\n     \\<not> gds_is_discovered gds v_ s_;\n     set (stack s_) \\<subseteq> reachable;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_;\n     pending xb_ =\n     pending s_ - {(hd (stack s_), v_)} \\<union> {v_} \\<times> E `` {v_};\n     pending s_ \\<subseteq> E;\n     pending xa_ = pending s_ - {(hd (stack s_), v_)};\n     stack xb_ = v_ # stack s_;\n     gen_discovered xb_ = insert v_ (gen_discovered s_);\n     set (stack s_) \\<subseteq> gen_discovered s_; stack xa_ = stack s_;\n     \\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_;\n     distinct (stack s_);\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV\\<rbrakk>\n    \\<Longrightarrow> v_ \\<in> reachable", "by (meson ImageI SigmaD1 rtrancl_image_unfold_right subset_eq)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> E \\<and>\n                         {v} \\<times> E `` {v} \\<subseteq> E\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 4. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 5. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 6. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 7. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\n 8. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 9. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 10. \\<And>s x xa.\n        \\<lbrakk>gen_rwof' s;\n         set (stack s) \\<subseteq> reachable \\<and>\n         pending s \\<subseteq> E \\<and>\n         set (stack s) \\<subseteq> gen_discovered s \\<and>\n         distinct (stack s) \\<and>\n         pending s \\<subseteq> set (stack s) \\<times> UNIV;\n         gen_cond s; gen_rwof s; stack s \\<noteq> [];\n         \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n         inres (choose_pending (hd (stack s)) None s) x \\<and>\n         pending x = pending s \\<and>\n         stack x = stack s \\<and>\n         (\\<forall>xa.\n             gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n         pending xa = pending s \\<and>\n         stack xa = tl (stack s) \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xa =\n             gds_is_discovered gds x s)\\<rbrakk>\n        \\<Longrightarrow> pending s\n                          \\<subseteq> set (tl (stack s)) \\<times> UNIV", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_;\n     set (stack s_) \\<subseteq> reachable \\<and>\n     pending s_ \\<subseteq> E \\<and>\n     set (stack s_) \\<subseteq> gen_discovered s_ \\<and>\n     distinct (stack s_) \\<and>\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV;\n     gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_ \\<and>\n     pending xa_ = pending s_ - {(hd (stack s_), v_)} \\<and>\n     stack xa_ = stack s_ \\<and>\n     (\\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_);\n     x_ = v_; \\<not> gds_is_discovered gds v_ s_;\n     pending xb_ =\n     pending s_ - {(hd (stack s_), v_)} \\<union>\n     {v_} \\<times> E `` {v_} \\<and>\n     stack xb_ = v_ # stack s_ \\<and>\n     gen_discovered xb_ = insert v_ (gen_discovered s_)\\<rbrakk>\n    \\<Longrightarrow> pending s_ - {(hd (stack s_), v_)}\n                      \\<subseteq> E \\<and>\n                      {v_} \\<times> E `` {v_} \\<subseteq> E", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gen_rwof' s_; gen_cond s_; gen_rwof s_; stack s_ \\<noteq> [];\n     (hd (stack s_), v_) \\<in> pending s_; x_ = v_;\n     \\<not> gds_is_discovered gds v_ s_;\n     set (stack s_) \\<subseteq> reachable;\n     inres (choose_pending (hd (stack s_)) (Some v_) s_) xa_;\n     pending xb_ =\n     pending s_ - {(hd (stack s_), v_)} \\<union> {v_} \\<times> E `` {v_};\n     pending s_ \\<subseteq> E;\n     pending xa_ = pending s_ - {(hd (stack s_), v_)};\n     stack xb_ = v_ # stack s_;\n     gen_discovered xb_ = insert v_ (gen_discovered s_);\n     set (stack s_) \\<subseteq> gen_discovered s_; stack xa_ = stack s_;\n     \\<forall>x. gds_is_discovered gds x xa_ = gds_is_discovered gds x s_;\n     distinct (stack s_);\n     pending s_ \\<subseteq> set (stack s_) \\<times> UNIV\\<rbrakk>\n    \\<Longrightarrow> pending s_ - {(hd (stack s_), v_)}\n                      \\<subseteq> E \\<and>\n                      {v_} \\<times> E `` {v_} \\<subseteq> E", "by blast"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> set (stack s)\n                         \\<subseteq> insert v (gen_discovered s)\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 3. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 4. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 5. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 6. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\n 7. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 8. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 9. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply force"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> set (stack s)\n 2. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 3. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 4. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 5. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\n 6. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 7. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 8. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply force"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s x xa v xb.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        (hd (stack s), v) \\<in> pending s;\n        inres (choose_pending (hd (stack s)) (Some v) s) xa \\<and>\n        pending xa = pending s - {(hd (stack s), v)} \\<and>\n        stack xa = stack s \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s);\n        x = v; \\<not> gds_is_discovered gds v s;\n        pending xb =\n        pending s - {(hd (stack s), v)} \\<union>\n        {v} \\<times> E `` {v} \\<and>\n        stack xb = v # stack s \\<and>\n        gen_discovered xb = insert v (gen_discovered s)\\<rbrakk>\n       \\<Longrightarrow> pending s - {(hd (stack s), v)}\n                         \\<subseteq> insert v (set (stack s)) \\<times>\n                                     UNIV \\<and>\n                         {v} \\<times> E `` {v}\n                         \\<subseteq> insert v (set (stack s)) \\<times> UNIV\n 2. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 3. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 4. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\n 5. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 6. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 7. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply fast"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 2. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 3. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\n 4. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 5. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 6. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply (auto simp: pre_defs gen_cond_def; fail)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 2. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\n 3. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 4. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 5. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply fast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pre_finish (hd (stack s)) (?s0.103 s x) x\n 2. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 3. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 4. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply ((unfold pre_defs, intro conjI); assumption?)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_empty_stack gds s\n 2. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_break gds s\n 3. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), None, x)\n 4. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 5. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 6. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply (clarsimp simp: gen_cond_def; fail)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_break gds s\n 2. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), None, x)\n 3. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 4. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 5. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply (clarsimp simp: gen_cond_def; fail)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> inres (gds_get_pending gds s)\n                          (hd (stack s), None, x)\n 2. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 3. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 4. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply (rule pwD2[OF get_pending_fmt])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending s\n 2. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> inres\n                          (let u = hd (stack s)\n                           in SELECT\n                               (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                              (\\<lambda>vo.\n                                  choose_pending u vo s \\<bind>\n                                  (\\<lambda>s. RETURN (u, vo, s))))\n                          (hd (stack s), None, x)\n 3. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 4. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 5. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply (simp add: pre_defs gen_cond_def; fail)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> inres\n                          (let u = hd (stack s)\n                           in SELECT\n                               (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                              (\\<lambda>vo.\n                                  choose_pending u vo s \\<bind>\n                                  (\\<lambda>s. RETURN (u, vo, s))))\n                          (hd (stack s), None, x)\n 2. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 3. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 4. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply (clarsimp simp: refine_pw_simps; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> reachable\n 2. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 3. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply (auto simp: neq_Nil_conv; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> set (tl (stack s)) \\<subseteq> gen_discovered s\n 2. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply (auto simp: neq_Nil_conv; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x xa.\n       \\<lbrakk>gen_rwof' s;\n        set (stack s) \\<subseteq> reachable \\<and>\n        pending s \\<subseteq> E \\<and>\n        set (stack s) \\<subseteq> gen_discovered s \\<and>\n        distinct (stack s) \\<and>\n        pending s \\<subseteq> set (stack s) \\<times> UNIV;\n        gen_cond s; gen_rwof s; stack s \\<noteq> [];\n        \\<forall>x. (hd (stack s), x) \\<notin> pending s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x = gds_is_discovered gds xa s);\n        pending xa = pending s \\<and>\n        stack xa = tl (stack s) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xa = gds_is_discovered gds x s)\\<rbrakk>\n       \\<Longrightarrow> pending s\n                         \\<subseteq> set (tl (stack s)) \\<times> UNIV", "apply (clarsimp simp: neq_Nil_conv; blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mk_spec_aux: \n    \"\\<lbrakk>m \\<le>\\<^sub>n SPEC \\<Phi>; m\\<le>SPEC gen_rwof' \\<rbrakk> \\<Longrightarrow> m \\<le> SPEC (\\<lambda>s. gen_rwof' s \\<and> \\<Phi> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le>\\<^sub>n SPEC \\<Phi>; m \\<le> SPEC gen_rwof'\\<rbrakk>\n    \\<Longrightarrow> m \\<le> SPEC (\\<lambda>s. gen_rwof' s \\<and> \\<Phi> s)", "by (rule SPEC_rule_conj_leofI1)"], ["", "definition \"post_choose_pending u vo s0 s \\<equiv> \n    gen_rwof' s0 \n  \\<and> gen_cond s0\n  \\<and> stack s0 \\<noteq> []\n  \\<and> u=hd (stack s0)  \n  \\<and> inres (choose_pending u vo s0) s \n  \\<and> stack s = stack s0\n  \\<and> (\\<forall>x. gds_is_discovered gds x s = gds_is_discovered gds x s0)\n  \\<^cancel>\\<open>\\<and> gds_is_break gds s = gds_is_break gds s0\\<close>\n  \\<and> (case vo of\n      None \\<Rightarrow> pending s0``{u}={} \\<and> pending s = pending s0\n    | Some v \\<Rightarrow> v \\<in> pending s0``{u} \\<and> pending s = pending s0 - {(u,v)})\""], ["", "context\n    assumes nofail: \n      \"nofail (gds_init gds \\<bind> WHILE gen_cond gen_step')\"\n    assumes nofail2: \n      \"nofail (gen_dfs)\"\n  begin"], ["", "lemma pcp_imp_pgp: \n      \"post_choose_pending u vo s0 s \\<Longrightarrow> post_get_pending u vo s0 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post_choose_pending u vo s0 s \\<Longrightarrow>\n    post_get_pending u vo s0 s", "unfolding post_choose_pending_def pre_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    (gen_rwof s0 \\<and>\n     \\<not> gds_is_empty_stack gds s0 \\<and>\n     \\<not> gds_is_break gds s0) \\<and>\n    inres (gds_get_pending gds s0) (u, vo, s)", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    gen_rwof s0\n 2. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    \\<not> gds_is_empty_stack gds s0\n 3. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    \\<not> gds_is_break gds s0\n 4. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    inres (gds_get_pending gds s0) (u, vo, s)", "apply (simp add: gen_rwof'_imp_rwof[OF nofail2])"], ["proof (prove)\ngoal (3 subgoals):\n 1. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    \\<not> gds_is_empty_stack gds s0\n 2. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    \\<not> gds_is_break gds s0\n 3. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    inres (gds_get_pending gds s0) (u, vo, s)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    \\<not> gds_is_break gds s0\n 2. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    inres (gds_get_pending gds s0) (u, vo, s)", "apply (simp add: gen_cond_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    inres (gds_get_pending gds s0) (u, vo, s)", "apply (rule pwD2[OF get_pending_fmt])"], ["proof (prove)\ngoal (2 subgoals):\n 1. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    pre_get_pending s0\n 2. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    inres\n     (let u = hd (stack s0)\n      in SELECT (\\<lambda>v. (u, v) \\<in> pending s0) \\<bind>\n         (\\<lambda>vo.\n             choose_pending u vo s0 \\<bind>\n             (\\<lambda>s. RETURN (u, vo, s))))\n     (u, vo, s)", "apply (simp add: pre_defs gen_cond_def \n          gen_rwof'_imp_rwof[OF nofail2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_rwof' s0 \\<and>\n    gen_cond s0 \\<and>\n    stack s0 \\<noteq> [] \\<and>\n    u = hd (stack s0) \\<and>\n    inres (choose_pending u vo s0) s \\<and>\n    stack s = stack s0 \\<and>\n    (\\<forall>x.\n        gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n    (case vo of\n     None \\<Rightarrow> pending s0 `` {u} = {} \\<and> pending s = pending s0\n     | Some v \\<Rightarrow>\n         v \\<in> pending s0 `` {u} \\<and>\n         pending s = pending s0 - {(u, v)}) \\<Longrightarrow>\n    inres\n     (let u = hd (stack s0)\n      in SELECT (\\<lambda>v. (u, v) \\<in> pending s0) \\<bind>\n         (\\<lambda>vo.\n             choose_pending u vo s0 \\<bind>\n             (\\<lambda>s. RETURN (u, vo, s))))\n     (u, vo, s)", "apply (auto simp add: refine_pw_simps select_def split: option.splits) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal gds_init_refine: \"?prop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ?prop", "apply (rule mk_spec_aux[OF init_spec])"], ["proof (prove)\ngoal (1 subgoal):\n 1. gds_init gds \\<le> SPEC gen_rwof'", "apply (rule rwof_init[OF nofail])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal gds_new_root_refine: \n      \"\\<lbrakk>pre_new_root v0 s; gen_rwof' s\\<rbrakk> \\<Longrightarrow> gds_new_root gds v0 s \\<le> SPEC ?\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_new_root v0 s; gen_rwof' s\\<rbrakk>\n    \\<Longrightarrow> gds_new_root gds v0 s \\<le> SPEC ?\\<Phi>", "apply (rule mk_spec_aux[OF new_root_spec], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_new_root v0 s; gen_rwof' s\\<rbrakk>\n    \\<Longrightarrow> gds_new_root gds v0 s \\<le> SPEC gen_rwof'", "apply (rule order_trans[OF _ rwof_step[OF nofail, where s=s]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pre_new_root v0 s; gen_rwof' s\\<rbrakk>\n    \\<Longrightarrow> gds_new_root gds v0 s \\<le> gen_step' s\n 2. \\<lbrakk>pre_new_root v0 s; gen_rwof' s\\<rbrakk>\n    \\<Longrightarrow> gen_rwof' s\n 3. \\<lbrakk>pre_new_root v0 s; gen_rwof' s\\<rbrakk>\n    \\<Longrightarrow> gen_cond s", "unfolding gen_step'_def pre_new_root_def gen_cond_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>rwof (gds_init gds)\n              (\\<lambda>s.\n                  (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                   \\<not> gds_is_empty_stack gds s) \\<and>\n                  \\<not> gds_is_break gds s)\n              gen_step s \\<and>\n             gds_is_empty_stack gds s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             v0 \\<in> V0 - gen_discovered s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s\\<rbrakk>\n    \\<Longrightarrow> gds_new_root gds v0 s\n                      \\<le> ASSERT\n                             (rwof (gds_init gds)\n                               (\\<lambda>s.\n                                   (V0 \\<subseteq> gen_discovered\n              s \\<longrightarrow>\n                                    \\<not> gds_is_empty_stack gds s) \\<and>\n                                   \\<not> gds_is_break gds s)\n                               gen_step s) \\<bind>\n                            (\\<lambda>_.\n                                if gds_is_empty_stack gds s\n                                then SPEC\n(\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                     (\\<lambda>v0. gds_new_root gds v0 s)\n                                else let u = hd (stack s)\n                                     in SELECT\n   (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n  (\\<lambda>Vs.\n      choose_pending u Vs s \\<bind>\n      (\\<lambda>s.\n          case Vs of None \\<Rightarrow> gds_finish gds u s\n          | Some v \\<Rightarrow>\n              if gds_is_discovered gds v s\n              then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                   else gds_back_edge gds u v s\n              else gds_discover gds u v s)))\n 2. \\<lbrakk>rwof (gds_init gds)\n              (\\<lambda>s.\n                  (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                   \\<not> gds_is_empty_stack gds s) \\<and>\n                  \\<not> gds_is_break gds s)\n              gen_step s \\<and>\n             gds_is_empty_stack gds s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             v0 \\<in> V0 - gen_discovered s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s\\<rbrakk>\n    \\<Longrightarrow> rwof (gds_init gds)\n                       (\\<lambda>s.\n                           (V0 \\<subseteq> gen_discovered\n      s \\<longrightarrow>\n                            \\<not> gds_is_empty_stack gds s) \\<and>\n                           \\<not> gds_is_break gds s)\n                       (\\<lambda>s.\n                           ASSERT\n                            (rwof (gds_init gds)\n                              (\\<lambda>s.\n                                  (V0 \\<subseteq> gen_discovered\n             s \\<longrightarrow>\n                                   \\<not> gds_is_empty_stack gds s) \\<and>\n                                  \\<not> gds_is_break gds s)\n                              gen_step s) \\<bind>\n                           (\\<lambda>_.\n                               if gds_is_empty_stack gds s\n                               then SPEC\n                                     (\\<lambda>v0.\n   v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                    (\\<lambda>v0. gds_new_root gds v0 s)\n                               else let u = hd (stack s)\n                                    in SELECT\n  (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n (\\<lambda>Vs.\n     choose_pending u Vs s \\<bind>\n     (\\<lambda>s.\n         case Vs of None \\<Rightarrow> gds_finish gds u s\n         | Some v \\<Rightarrow>\n             if gds_is_discovered gds v s\n             then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                  else gds_back_edge gds u v s\n             else gds_discover gds u v s))))\n                       s\n 3. \\<lbrakk>rwof (gds_init gds)\n              (\\<lambda>s.\n                  (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                   \\<not> gds_is_empty_stack gds s) \\<and>\n                  \\<not> gds_is_break gds s)\n              gen_step s \\<and>\n             gds_is_empty_stack gds s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             v0 \\<in> V0 - gen_discovered s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s\\<rbrakk>\n    \\<Longrightarrow> (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                       \\<not> gds_is_empty_stack gds s) \\<and>\n                      \\<not> gds_is_break gds s", "apply (auto simp: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal gds_choose_pending_refine: \n      assumes 1: \"pre_get_pending s\"\n      assumes 2: \"gen_rwof' s\"\n      assumes [simp]: \"u=hd (stack s)\"\n      assumes 3: \"case vo of \n          None \\<Rightarrow> pending s `` {u} = {}\n        | Some v \\<Rightarrow> v \\<in> pending s `` {u}\"\n      shows \"choose_pending u vo s \\<le> SPEC (post_choose_pending u vo s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_pending u vo s \\<le> SPEC (post_choose_pending u vo s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. choose_pending u vo s \\<le> SPEC (post_choose_pending u vo s)", "from WHILE_nofail_imp_rwof_nofail[OF nofail 2] 1 3"], ["proof (chain)\npicking this:\n  gen_cond s \\<Longrightarrow> nofail (gen_step' s)\n  pre_get_pending s\n  case vo of None \\<Rightarrow> pending s `` {u} = {}\n  | Some v \\<Rightarrow> v \\<in> pending s `` {u}", "have \n        \"nofail (choose_pending u vo s)\""], ["proof (prove)\nusing this:\n  gen_cond s \\<Longrightarrow> nofail (gen_step' s)\n  pre_get_pending s\n  case vo of None \\<Rightarrow> pending s `` {u} = {}\n  | Some v \\<Rightarrow> v \\<in> pending s `` {u}\n\ngoal (1 subgoal):\n 1. nofail (choose_pending u vo s)", "unfolding pre_defs gen_step'_def gen_cond_def"], ["proof (prove)\nusing this:\n  (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n   \\<not> gds_is_empty_stack gds s) \\<and>\n  \\<not> gds_is_break gds s \\<Longrightarrow>\n  nofail\n   (ASSERT\n     (rwof (gds_init gds)\n       (\\<lambda>s.\n           (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n            \\<not> gds_is_empty_stack gds s) \\<and>\n           \\<not> gds_is_break gds s)\n       gen_step s) \\<bind>\n    (\\<lambda>_.\n        if gds_is_empty_stack gds s\n        then SPEC\n              (\\<lambda>v0.\n                  v0 \\<in> V0 \\<and>\n                  \\<not> gds_is_discovered gds v0 s) \\<bind>\n             (\\<lambda>v0. gds_new_root gds v0 s)\n        else let u = hd (stack s)\n             in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                (\\<lambda>Vs.\n                    choose_pending u Vs s \\<bind>\n                    (\\<lambda>s.\n                        case Vs of None \\<Rightarrow> gds_finish gds u s\n                        | Some v \\<Rightarrow>\n                            if gds_is_discovered gds v s\n                            then if gds_is_finished gds v s\n                                 then gds_cross_edge gds u v s\n                                 else gds_back_edge gds u v s\n                            else gds_discover gds u v s))))\n  rwof (gds_init gds)\n   (\\<lambda>s.\n       (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n        \\<not> gds_is_empty_stack gds s) \\<and>\n       \\<not> gds_is_break gds s)\n   gen_step s \\<and>\n  \\<not> gds_is_empty_stack gds s \\<and> \\<not> gds_is_break gds s\n  case vo of None \\<Rightarrow> pending s `` {u} = {}\n  | Some v \\<Rightarrow> v \\<in> pending s `` {u}\n\ngoal (1 subgoal):\n 1. nofail (choose_pending u vo s)", "by (auto simp: refine_pw_simps select_def \n          split: option.splits if_split_asm)"], ["proof (state)\nthis:\n  nofail (choose_pending u vo s)\n\ngoal (1 subgoal):\n 1. choose_pending u vo s \\<le> SPEC (post_choose_pending u vo s)", "also"], ["proof (state)\nthis:\n  nofail (choose_pending u vo s)\n\ngoal (1 subgoal):\n 1. choose_pending u vo s \\<le> SPEC (post_choose_pending u vo s)", "have \"choose_pending u vo s \\<le>\\<^sub>n SPEC (post_choose_pending u vo s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_pending u vo s \\<le>\\<^sub>n SPEC (post_choose_pending u vo s)", "apply (rule leof_trans[OF choose_pending_spec[OF 1 _ 3, THEN leof_strengthen_SPEC]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. u = hd (stack s)\n 2. SPEC\n     (\\<lambda>x.\n         inres (choose_pending u vo s) x \\<and>\n         (case vo of None \\<Rightarrow> pending x = pending s\n          | Some v \\<Rightarrow> pending x = pending s - {(u, v)}) \\<and>\n         stack x = stack s \\<and>\n         (\\<forall>xa.\n             gds_is_discovered gds xa x =\n             gds_is_discovered gds xa s)) \\<le>\\<^sub>n\n    SPEC (post_choose_pending u vo s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>x.\n         inres (choose_pending u vo s) x \\<and>\n         (case vo of None \\<Rightarrow> pending x = pending s\n          | Some v \\<Rightarrow> pending x = pending s - {(u, v)}) \\<and>\n         stack x = stack s \\<and>\n         (\\<forall>xa.\n             gds_is_discovered gds xa x =\n             gds_is_discovered gds xa s)) \\<le>\\<^sub>n\n    SPEC (post_choose_pending u vo s)", "apply (rule leof_RES_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       inres (choose_pending u vo s) x \\<and>\n       (case vo of None \\<Rightarrow> pending x = pending s\n        | Some v \\<Rightarrow> pending x = pending s - {(u, v)}) \\<and>\n       stack x = stack s \\<and>\n       (\\<forall>xa.\n           gds_is_discovered gds xa x =\n           gds_is_discovered gds xa s) \\<Longrightarrow>\n       post_choose_pending u vo s x", "using 1"], ["proof (prove)\nusing this:\n  pre_get_pending s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       inres (choose_pending u vo s) x \\<and>\n       (case vo of None \\<Rightarrow> pending x = pending s\n        | Some v \\<Rightarrow> pending x = pending s - {(u, v)}) \\<and>\n       stack x = stack s \\<and>\n       (\\<forall>xa.\n           gds_is_discovered gds xa x =\n           gds_is_discovered gds xa s) \\<Longrightarrow>\n       post_choose_pending u vo s x", "apply (simp add: post_choose_pending_def 2 pre_defs gen_cond_def split: option.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>vo = None; gen_rwof s; stack s \\<noteq> [];\n        \\<not> gds_is_break gds s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 2. \\<And>x x2.\n       \\<lbrakk>gen_rwof s; stack s \\<noteq> []; \\<not> gds_is_break gds s;\n        vo = Some x2;\n        inres (choose_pending (hd (stack s)) (Some x2) s) x \\<and>\n        pending x = pending s - {(hd (stack s), x2)} \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> (hd (stack s), x2) \\<in> pending s", "using 3"], ["proof (prove)\nusing this:\n  case vo of None \\<Rightarrow> pending s `` {u} = {}\n  | Some v \\<Rightarrow> v \\<in> pending s `` {u}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>vo = None; gen_rwof s; stack s \\<noteq> [];\n        \\<not> gds_is_break gds s;\n        inres (choose_pending (hd (stack s)) None s) x \\<and>\n        pending x = pending s \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> pending s `` {hd (stack s)} = {}\n 2. \\<And>x x2.\n       \\<lbrakk>gen_rwof s; stack s \\<noteq> []; \\<not> gds_is_break gds s;\n        vo = Some x2;\n        inres (choose_pending (hd (stack s)) (Some x2) s) x \\<and>\n        pending x = pending s - {(hd (stack s), x2)} \\<and>\n        stack x = stack s \\<and>\n        (\\<forall>xa.\n            gds_is_discovered gds xa x =\n            gds_is_discovered gds xa s)\\<rbrakk>\n       \\<Longrightarrow> (hd (stack s), x2) \\<in> pending s", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  choose_pending u vo s \\<le>\\<^sub>n SPEC (post_choose_pending u vo s)\n\ngoal (1 subgoal):\n 1. choose_pending u vo s \\<le> SPEC (post_choose_pending u vo s)", "finally (leofD)"], ["proof (chain)\npicking this:\n  choose_pending u vo s \\<le> SPEC (post_choose_pending u vo s)", "show ?thesis"], ["proof (prove)\nusing this:\n  choose_pending u vo s \\<le> SPEC (post_choose_pending u vo s)\n\ngoal (1 subgoal):\n 1. choose_pending u vo s \\<le> SPEC (post_choose_pending u vo s)", "."], ["proof (state)\nthis:\n  choose_pending u vo s \\<le> SPEC (post_choose_pending u vo s)\n\ngoal:\nNo subgoals!", "qed"], ["", "schematic_goal gds_finish_refine: \n      \"\\<lbrakk>pre_finish u s0 s; post_choose_pending u None s0 s\\<rbrakk> \\<Longrightarrow> gds_finish gds u s \\<le> SPEC ?\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_finish u s0 s; post_choose_pending u None s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_finish gds u s \\<le> SPEC ?\\<Phi>", "apply (rule mk_spec_aux[OF finish_spec], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_finish u s0 s; post_choose_pending u None s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_finish gds u s \\<le> SPEC gen_rwof'", "apply (rule order_trans[OF _ rwof_step[OF nofail, where s=s0]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pre_finish u s0 s; post_choose_pending u None s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_finish gds u s \\<le> gen_step' s0\n 2. \\<lbrakk>pre_finish u s0 s; post_choose_pending u None s0 s\\<rbrakk>\n    \\<Longrightarrow> gen_rwof' s0\n 3. \\<lbrakk>pre_finish u s0 s; post_choose_pending u None s0 s\\<rbrakk>\n    \\<Longrightarrow> gen_cond s0", "unfolding gen_step'_def pre_defs gen_cond_def post_choose_pending_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(rwof (gds_init gds)\n               (\\<lambda>s.\n                   (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                    \\<not> gds_is_empty_stack gds s) \\<and>\n                   \\<not> gds_is_break gds s)\n               gen_step s0 \\<and>\n              \\<not> gds_is_empty_stack gds s0 \\<and>\n              \\<not> gds_is_break gds s0) \\<and>\n             inres (gds_get_pending gds s0) (u, None, s);\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u None s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case None of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> gds_finish gds u s\n                      \\<le> ASSERT\n                             (rwof (gds_init gds)\n                               (\\<lambda>s.\n                                   (V0 \\<subseteq> gen_discovered\n              s \\<longrightarrow>\n                                    \\<not> gds_is_empty_stack gds s) \\<and>\n                                   \\<not> gds_is_break gds s)\n                               gen_step s0) \\<bind>\n                            (\\<lambda>_.\n                                if gds_is_empty_stack gds s0\n                                then SPEC\n(\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s0) \\<bind>\n                                     (\\<lambda>v0. gds_new_root gds v0 s0)\n                                else let u = hd (stack s0)\n                                     in SELECT\n   (\\<lambda>v. (u, v) \\<in> pending s0) \\<bind>\n  (\\<lambda>Vs.\n      choose_pending u Vs s0 \\<bind>\n      (\\<lambda>s.\n          case Vs of None \\<Rightarrow> gds_finish gds u s\n          | Some v \\<Rightarrow>\n              if gds_is_discovered gds v s\n              then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                   else gds_back_edge gds u v s\n              else gds_discover gds u v s)))\n 2. \\<lbrakk>(rwof (gds_init gds)\n               (\\<lambda>s.\n                   (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                    \\<not> gds_is_empty_stack gds s) \\<and>\n                   \\<not> gds_is_break gds s)\n               gen_step s0 \\<and>\n              \\<not> gds_is_empty_stack gds s0 \\<and>\n              \\<not> gds_is_break gds s0) \\<and>\n             inres (gds_get_pending gds s0) (u, None, s);\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u None s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case None of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> rwof (gds_init gds)\n                       (\\<lambda>s.\n                           (V0 \\<subseteq> gen_discovered\n      s \\<longrightarrow>\n                            \\<not> gds_is_empty_stack gds s) \\<and>\n                           \\<not> gds_is_break gds s)\n                       (\\<lambda>s.\n                           ASSERT\n                            (rwof (gds_init gds)\n                              (\\<lambda>s.\n                                  (V0 \\<subseteq> gen_discovered\n             s \\<longrightarrow>\n                                   \\<not> gds_is_empty_stack gds s) \\<and>\n                                  \\<not> gds_is_break gds s)\n                              gen_step s) \\<bind>\n                           (\\<lambda>_.\n                               if gds_is_empty_stack gds s\n                               then SPEC\n                                     (\\<lambda>v0.\n   v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                    (\\<lambda>v0. gds_new_root gds v0 s)\n                               else let u = hd (stack s)\n                                    in SELECT\n  (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n (\\<lambda>Vs.\n     choose_pending u Vs s \\<bind>\n     (\\<lambda>s.\n         case Vs of None \\<Rightarrow> gds_finish gds u s\n         | Some v \\<Rightarrow>\n             if gds_is_discovered gds v s\n             then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                  else gds_back_edge gds u v s\n             else gds_discover gds u v s))))\n                       s0\n 3. \\<lbrakk>(rwof (gds_init gds)\n               (\\<lambda>s.\n                   (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                    \\<not> gds_is_empty_stack gds s) \\<and>\n                   \\<not> gds_is_break gds s)\n               gen_step s0 \\<and>\n              \\<not> gds_is_empty_stack gds s0 \\<and>\n              \\<not> gds_is_break gds s0) \\<and>\n             inres (gds_get_pending gds s0) (u, None, s);\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u None s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case None of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n                       \\<not> gds_is_empty_stack gds s0) \\<and>\n                      \\<not> gds_is_break gds s0", "apply (auto simp: pw_le_iff refine_pw_simps split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal gds_cross_edge_refine: \n      \"\\<lbrakk>pre_cross_edge u v s0 s; post_choose_pending u (Some v) s0 s\\<rbrakk> \\<Longrightarrow> gds_cross_edge gds u v s \\<le> SPEC ?\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_cross_edge u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_cross_edge gds u v s \\<le> SPEC ?\\<Phi>", "apply (rule mk_spec_aux[OF cross_edge_spec], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_cross_edge u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_cross_edge gds u v s \\<le> SPEC gen_rwof'", "apply (rule order_trans[OF _ rwof_step[OF nofail, where s=s0]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pre_cross_edge u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_cross_edge gds u v s \\<le> gen_step' s0\n 2. \\<lbrakk>pre_cross_edge u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gen_rwof' s0\n 3. \\<lbrakk>pre_cross_edge u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gen_cond s0", "unfolding gen_step'_def pre_defs gen_cond_def post_choose_pending_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> gds_cross_edge gds u v s\n                      \\<le> ASSERT\n                             (rwof (gds_init gds)\n                               (\\<lambda>s.\n                                   (V0 \\<subseteq> gen_discovered\n              s \\<longrightarrow>\n                                    \\<not> gds_is_empty_stack gds s) \\<and>\n                                   \\<not> gds_is_break gds s)\n                               gen_step s0) \\<bind>\n                            (\\<lambda>_.\n                                if gds_is_empty_stack gds s0\n                                then SPEC\n(\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s0) \\<bind>\n                                     (\\<lambda>v0. gds_new_root gds v0 s0)\n                                else let u = hd (stack s0)\n                                     in SELECT\n   (\\<lambda>v. (u, v) \\<in> pending s0) \\<bind>\n  (\\<lambda>Vs.\n      choose_pending u Vs s0 \\<bind>\n      (\\<lambda>s.\n          case Vs of None \\<Rightarrow> gds_finish gds u s\n          | Some v \\<Rightarrow>\n              if gds_is_discovered gds v s\n              then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                   else gds_back_edge gds u v s\n              else gds_discover gds u v s)))\n 2. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> rwof (gds_init gds)\n                       (\\<lambda>s.\n                           (V0 \\<subseteq> gen_discovered\n      s \\<longrightarrow>\n                            \\<not> gds_is_empty_stack gds s) \\<and>\n                           \\<not> gds_is_break gds s)\n                       (\\<lambda>s.\n                           ASSERT\n                            (rwof (gds_init gds)\n                              (\\<lambda>s.\n                                  (V0 \\<subseteq> gen_discovered\n             s \\<longrightarrow>\n                                   \\<not> gds_is_empty_stack gds s) \\<and>\n                                  \\<not> gds_is_break gds s)\n                              gen_step s) \\<bind>\n                           (\\<lambda>_.\n                               if gds_is_empty_stack gds s\n                               then SPEC\n                                     (\\<lambda>v0.\n   v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                    (\\<lambda>v0. gds_new_root gds v0 s)\n                               else let u = hd (stack s)\n                                    in SELECT\n  (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n (\\<lambda>Vs.\n     choose_pending u Vs s \\<bind>\n     (\\<lambda>s.\n         case Vs of None \\<Rightarrow> gds_finish gds u s\n         | Some v \\<Rightarrow>\n             if gds_is_discovered gds v s\n             then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                  else gds_back_edge gds u v s\n             else gds_discover gds u v s))))\n                       s0\n 3. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n                       \\<not> gds_is_empty_stack gds s0) \\<and>\n                      \\<not> gds_is_break gds s0", "apply (simp add: pw_le_iff refine_pw_simps select_def split: option.split, blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> rwof (gds_init gds)\n                       (\\<lambda>s.\n                           (V0 \\<subseteq> gen_discovered\n      s \\<longrightarrow>\n                            \\<not> gds_is_empty_stack gds s) \\<and>\n                           \\<not> gds_is_break gds s)\n                       (\\<lambda>s.\n                           ASSERT\n                            (rwof (gds_init gds)\n                              (\\<lambda>s.\n                                  (V0 \\<subseteq> gen_discovered\n             s \\<longrightarrow>\n                                   \\<not> gds_is_empty_stack gds s) \\<and>\n                                  \\<not> gds_is_break gds s)\n                              gen_step s) \\<bind>\n                           (\\<lambda>_.\n                               if gds_is_empty_stack gds s\n                               then SPEC\n                                     (\\<lambda>v0.\n   v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                    (\\<lambda>v0. gds_new_root gds v0 s)\n                               else let u = hd (stack s)\n                                    in SELECT\n  (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n (\\<lambda>Vs.\n     choose_pending u Vs s \\<bind>\n     (\\<lambda>s.\n         case Vs of None \\<Rightarrow> gds_finish gds u s\n         | Some v \\<Rightarrow>\n             if gds_is_discovered gds v s\n             then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                  else gds_back_edge gds u v s\n             else gds_discover gds u v s))))\n                       s0\n 2. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n                       \\<not> gds_is_empty_stack gds s0) \\<and>\n                      \\<not> gds_is_break gds s0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n                       \\<not> gds_is_empty_stack gds s0) \\<and>\n                      \\<not> gds_is_break gds s0", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal gds_back_edge_refine: \n      \"\\<lbrakk>pre_back_edge u v s0 s; post_choose_pending u (Some v) s0 s\\<rbrakk> \\<Longrightarrow> gds_back_edge gds u v s \\<le> SPEC ?\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_back_edge u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_back_edge gds u v s \\<le> SPEC ?\\<Phi>", "apply (rule mk_spec_aux[OF back_edge_spec], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_back_edge u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_back_edge gds u v s \\<le> SPEC gen_rwof'", "apply (rule order_trans[OF _ rwof_step[OF nofail, where s=s0]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pre_back_edge u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_back_edge gds u v s \\<le> gen_step' s0\n 2. \\<lbrakk>pre_back_edge u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gen_rwof' s0\n 3. \\<lbrakk>pre_back_edge u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gen_cond s0", "unfolding gen_step'_def pre_defs gen_cond_def post_choose_pending_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and>\n             \\<not> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> gds_back_edge gds u v s\n                      \\<le> ASSERT\n                             (rwof (gds_init gds)\n                               (\\<lambda>s.\n                                   (V0 \\<subseteq> gen_discovered\n              s \\<longrightarrow>\n                                    \\<not> gds_is_empty_stack gds s) \\<and>\n                                   \\<not> gds_is_break gds s)\n                               gen_step s0) \\<bind>\n                            (\\<lambda>_.\n                                if gds_is_empty_stack gds s0\n                                then SPEC\n(\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s0) \\<bind>\n                                     (\\<lambda>v0. gds_new_root gds v0 s0)\n                                else let u = hd (stack s0)\n                                     in SELECT\n   (\\<lambda>v. (u, v) \\<in> pending s0) \\<bind>\n  (\\<lambda>Vs.\n      choose_pending u Vs s0 \\<bind>\n      (\\<lambda>s.\n          case Vs of None \\<Rightarrow> gds_finish gds u s\n          | Some v \\<Rightarrow>\n              if gds_is_discovered gds v s\n              then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                   else gds_back_edge gds u v s\n              else gds_discover gds u v s)))\n 2. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and>\n             \\<not> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> rwof (gds_init gds)\n                       (\\<lambda>s.\n                           (V0 \\<subseteq> gen_discovered\n      s \\<longrightarrow>\n                            \\<not> gds_is_empty_stack gds s) \\<and>\n                           \\<not> gds_is_break gds s)\n                       (\\<lambda>s.\n                           ASSERT\n                            (rwof (gds_init gds)\n                              (\\<lambda>s.\n                                  (V0 \\<subseteq> gen_discovered\n             s \\<longrightarrow>\n                                   \\<not> gds_is_empty_stack gds s) \\<and>\n                                  \\<not> gds_is_break gds s)\n                              gen_step s) \\<bind>\n                           (\\<lambda>_.\n                               if gds_is_empty_stack gds s\n                               then SPEC\n                                     (\\<lambda>v0.\n   v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                    (\\<lambda>v0. gds_new_root gds v0 s)\n                               else let u = hd (stack s)\n                                    in SELECT\n  (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n (\\<lambda>Vs.\n     choose_pending u Vs s \\<bind>\n     (\\<lambda>s.\n         case Vs of None \\<Rightarrow> gds_finish gds u s\n         | Some v \\<Rightarrow>\n             if gds_is_discovered gds v s\n             then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                  else gds_back_edge gds u v s\n             else gds_discover gds u v s))))\n                       s0\n 3. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and>\n             \\<not> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n                       \\<not> gds_is_empty_stack gds s0) \\<and>\n                      \\<not> gds_is_break gds s0", "apply (simp add: pw_le_iff refine_pw_simps select_def split: option.split, blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and>\n             \\<not> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> rwof (gds_init gds)\n                       (\\<lambda>s.\n                           (V0 \\<subseteq> gen_discovered\n      s \\<longrightarrow>\n                            \\<not> gds_is_empty_stack gds s) \\<and>\n                           \\<not> gds_is_break gds s)\n                       (\\<lambda>s.\n                           ASSERT\n                            (rwof (gds_init gds)\n                              (\\<lambda>s.\n                                  (V0 \\<subseteq> gen_discovered\n             s \\<longrightarrow>\n                                   \\<not> gds_is_empty_stack gds s) \\<and>\n                                  \\<not> gds_is_break gds s)\n                              gen_step s) \\<bind>\n                           (\\<lambda>_.\n                               if gds_is_empty_stack gds s\n                               then SPEC\n                                     (\\<lambda>v0.\n   v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                    (\\<lambda>v0. gds_new_root gds v0 s)\n                               else let u = hd (stack s)\n                                    in SELECT\n  (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n (\\<lambda>Vs.\n     choose_pending u Vs s \\<bind>\n     (\\<lambda>s.\n         case Vs of None \\<Rightarrow> gds_finish gds u s\n         | Some v \\<Rightarrow>\n             if gds_is_discovered gds v s\n             then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                  else gds_back_edge gds u v s\n             else gds_discover gds u v s))))\n                       s0\n 2. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and>\n             \\<not> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n                       \\<not> gds_is_empty_stack gds s0) \\<and>\n                      \\<not> gds_is_break gds s0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             gds_is_discovered gds v s \\<and>\n             \\<not> gds_is_finished gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n                       \\<not> gds_is_empty_stack gds s0) \\<and>\n                      \\<not> gds_is_break gds s0", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal gds_discover_refine: \n      \"\\<lbrakk>pre_discover u v s0 s; post_choose_pending u (Some v) s0 s\\<rbrakk> \\<Longrightarrow> gds_discover gds u v s \\<le> SPEC ?\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_discover u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_discover gds u v s \\<le> SPEC ?\\<Phi>", "apply (rule mk_spec_aux[OF discover_spec], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_discover u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_discover gds u v s \\<le> SPEC gen_rwof'", "apply (rule order_trans[OF _ rwof_step[OF nofail, where s=s0]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pre_discover u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gds_discover gds u v s \\<le> gen_step' s0\n 2. \\<lbrakk>pre_discover u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gen_rwof' s0\n 3. \\<lbrakk>pre_discover u v s0 s;\n     post_choose_pending u (Some v) s0 s\\<rbrakk>\n    \\<Longrightarrow> gen_cond s0", "unfolding gen_step'_def pre_defs gen_cond_def post_choose_pending_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> gds_discover gds u v s\n                      \\<le> ASSERT\n                             (rwof (gds_init gds)\n                               (\\<lambda>s.\n                                   (V0 \\<subseteq> gen_discovered\n              s \\<longrightarrow>\n                                    \\<not> gds_is_empty_stack gds s) \\<and>\n                                   \\<not> gds_is_break gds s)\n                               gen_step s0) \\<bind>\n                            (\\<lambda>_.\n                                if gds_is_empty_stack gds s0\n                                then SPEC\n(\\<lambda>v0. v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s0) \\<bind>\n                                     (\\<lambda>v0. gds_new_root gds v0 s0)\n                                else let u = hd (stack s0)\n                                     in SELECT\n   (\\<lambda>v. (u, v) \\<in> pending s0) \\<bind>\n  (\\<lambda>Vs.\n      choose_pending u Vs s0 \\<bind>\n      (\\<lambda>s.\n          case Vs of None \\<Rightarrow> gds_finish gds u s\n          | Some v \\<Rightarrow>\n              if gds_is_discovered gds v s\n              then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                   else gds_back_edge gds u v s\n              else gds_discover gds u v s)))\n 2. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> rwof (gds_init gds)\n                       (\\<lambda>s.\n                           (V0 \\<subseteq> gen_discovered\n      s \\<longrightarrow>\n                            \\<not> gds_is_empty_stack gds s) \\<and>\n                           \\<not> gds_is_break gds s)\n                       (\\<lambda>s.\n                           ASSERT\n                            (rwof (gds_init gds)\n                              (\\<lambda>s.\n                                  (V0 \\<subseteq> gen_discovered\n             s \\<longrightarrow>\n                                   \\<not> gds_is_empty_stack gds s) \\<and>\n                                  \\<not> gds_is_break gds s)\n                              gen_step s) \\<bind>\n                           (\\<lambda>_.\n                               if gds_is_empty_stack gds s\n                               then SPEC\n                                     (\\<lambda>v0.\n   v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                    (\\<lambda>v0. gds_new_root gds v0 s)\n                               else let u = hd (stack s)\n                                    in SELECT\n  (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n (\\<lambda>Vs.\n     choose_pending u Vs s \\<bind>\n     (\\<lambda>s.\n         case Vs of None \\<Rightarrow> gds_finish gds u s\n         | Some v \\<Rightarrow>\n             if gds_is_discovered gds v s\n             then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                  else gds_back_edge gds u v s\n             else gds_discover gds u v s))))\n                       s0\n 3. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n                       \\<not> gds_is_empty_stack gds s0) \\<and>\n                      \\<not> gds_is_break gds s0", "apply (simp add: pw_le_iff refine_pw_simps select_def split: option.split, blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> rwof (gds_init gds)\n                       (\\<lambda>s.\n                           (V0 \\<subseteq> gen_discovered\n      s \\<longrightarrow>\n                            \\<not> gds_is_empty_stack gds s) \\<and>\n                           \\<not> gds_is_break gds s)\n                       (\\<lambda>s.\n                           ASSERT\n                            (rwof (gds_init gds)\n                              (\\<lambda>s.\n                                  (V0 \\<subseteq> gen_discovered\n             s \\<longrightarrow>\n                                   \\<not> gds_is_empty_stack gds s) \\<and>\n                                  \\<not> gds_is_break gds s)\n                              gen_step s) \\<bind>\n                           (\\<lambda>_.\n                               if gds_is_empty_stack gds s\n                               then SPEC\n                                     (\\<lambda>v0.\n   v0 \\<in> V0 \\<and> \\<not> gds_is_discovered gds v0 s) \\<bind>\n                                    (\\<lambda>v0. gds_new_root gds v0 s)\n                               else let u = hd (stack s)\n                                    in SELECT\n  (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n (\\<lambda>Vs.\n     choose_pending u Vs s \\<bind>\n     (\\<lambda>s.\n         case Vs of None \\<Rightarrow> gds_finish gds u s\n         | Some v \\<Rightarrow>\n             if gds_is_discovered gds v s\n             then if gds_is_finished gds v s then gds_cross_edge gds u v s\n                  else gds_back_edge gds u v s\n             else gds_discover gds u v s))))\n                       s0\n 2. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n                       \\<not> gds_is_empty_stack gds s0) \\<and>\n                      \\<not> gds_is_break gds s0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((rwof (gds_init gds)\n                (\\<lambda>s.\n                    (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                     \\<not> gds_is_empty_stack gds s) \\<and>\n                    \\<not> gds_is_break gds s)\n                gen_step s0 \\<and>\n               \\<not> gds_is_empty_stack gds s0 \\<and>\n               \\<not> gds_is_break gds s0) \\<and>\n              inres (gds_get_pending gds s0) (u, Some v, s)) \\<and>\n             \\<not> gds_is_discovered gds v s;\n     rwof (gds_init gds)\n      (\\<lambda>s.\n          (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n           \\<not> gds_is_empty_stack gds s) \\<and>\n          \\<not> gds_is_break gds s)\n      (\\<lambda>s.\n          ASSERT\n           (rwof (gds_init gds)\n             (\\<lambda>s.\n                 (V0 \\<subseteq> gen_discovered s \\<longrightarrow>\n                  \\<not> gds_is_empty_stack gds s) \\<and>\n                 \\<not> gds_is_break gds s)\n             gen_step s) \\<bind>\n          (\\<lambda>_.\n              if gds_is_empty_stack gds s\n              then SPEC\n                    (\\<lambda>v0.\n                        v0 \\<in> V0 \\<and>\n                        \\<not> gds_is_discovered gds v0 s) \\<bind>\n                   (\\<lambda>v0. gds_new_root gds v0 s)\n              else let u = hd (stack s)\n                   in SELECT (\\<lambda>v. (u, v) \\<in> pending s) \\<bind>\n                      (\\<lambda>Vs.\n                          choose_pending u Vs s \\<bind>\n                          (\\<lambda>s.\n                              case Vs of\n                              None \\<Rightarrow> gds_finish gds u s\n                              | Some v \\<Rightarrow>\n                                  if gds_is_discovered gds v s\n                                  then if gds_is_finished gds v s\n then gds_cross_edge gds u v s else gds_back_edge gds u v s\n                                  else gds_discover gds u v s))))\n      s0 \\<and>\n     ((V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n       \\<not> gds_is_empty_stack gds s0) \\<and>\n      \\<not> gds_is_break gds s0) \\<and>\n     stack s0 \\<noteq> [] \\<and>\n     u = hd (stack s0) \\<and>\n     inres (choose_pending u (Some v) s0) s \\<and>\n     stack s = stack s0 \\<and>\n     (\\<forall>x.\n         gds_is_discovered gds x s = gds_is_discovered gds x s0) \\<and>\n     (case Some v of\n      None \\<Rightarrow>\n        pending s0 `` {u} = {} \\<and> pending s = pending s0\n      | Some v \\<Rightarrow>\n          v \\<in> pending s0 `` {u} \\<and>\n          pending s = pending s0 - {(u, v)})\\<rbrakk>\n    \\<Longrightarrow> (V0 \\<subseteq> gen_discovered s0 \\<longrightarrow>\n                       \\<not> gds_is_empty_stack gds s0) \\<and>\n                      \\<not> gds_is_break gds s0", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma rec_impl_aux: \"\\<lbrakk> xd\\<notin>Domain P \\<rbrakk> \\<Longrightarrow> P - {y} \\<times> (succ y - ita) - {(y, xd)} - {xd} \\<times> UNIV =\n           P - insert (y, xd) ({y} \\<times> (succ y - ita))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xd \\<notin> Domain P \\<Longrightarrow>\n    P - {y} \\<times> (E `` {y} - ita) - {(y, xd)} - {xd} \\<times> UNIV =\n    P - insert (y, xd) ({y} \\<times> (E `` {y} - ita))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rec_impl: \"rec_impl \\<le> gen_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rec_impl \\<le> gen_dfs", "apply (rule le_nofailI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail gen_dfs \\<Longrightarrow> local.rec_impl \\<le> gen_dfs", "apply (rule order_trans[OF _ gen_dfs'_refine])"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail gen_dfs \\<Longrightarrow> local.rec_impl \\<le> gen_dfs'", "unfolding gen_dfs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail gen_dfs \\<Longrightarrow>\n    local.rec_impl \\<le> gds_init gds \\<bind> WHILE gen_cond gen_step'", "apply (rule WHILE_refine_rwof)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail gen_dfs;\n     nofail (gds_init gds \\<bind> WHILE gen_cond gen_step')\\<rbrakk>\n    \\<Longrightarrow> local.rec_impl\n                      \\<le> SPEC\n                             (\\<lambda>s.\n                                 gen_rwof' s \\<and> \\<not> gen_cond s)", "unfolding rec_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail gen_dfs;\n     nofail (gds_init gds \\<bind> WHILE gen_cond gen_step')\\<rbrakk>\n    \\<Longrightarrow> gds_init gds \\<bind>\n                      FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n          gen_rwof' s \\<and>\n          (\\<not> gds_is_break gds s \\<longrightarrow>\n           gds_is_empty_stack gds s \\<and>\n           V0 - it \\<subseteq> gen_discovered s)\\<^esup>\n                       V0 ((Not \\<circ>\\<circ> gds_is_break) gds)\n                       (\\<lambda>v0 s.\n                           let s0 = GHOST s\n                           in if gds_is_discovered gds v0 s then RETURN s\n                              else gds_new_root gds v0 s \\<bind>\n                                   (\\<lambda>s.\n if gds_is_break gds s then RETURN s\n else REC_annot\n       (\\<lambda>(u, s).\n           gen_rwof' s \\<and>\n           \\<not> gds_is_break gds s \\<and>\n           (\\<exists>stk. stack s = u # stk) \\<and>\n           E \\<inter> {u} \\<times> UNIV \\<subseteq> pending s)\n       (\\<lambda>(u, s) s'.\n           gen_rwof' s' \\<and>\n           (\\<not> gds_is_break gds s' \\<longrightarrow>\n            stack s' = tl (stack s) \\<and>\n            pending s' = pending s - {u} \\<times> UNIV \\<and>\n            gen_discovered s \\<subseteq> gen_discovered s'))\n       (\\<lambda>D (u, s).\n           FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s'.\n                                     gen_rwof' s' \\<and>\n                                     (\\<not> gds_is_break gds\n        s' \\<longrightarrow>\nstack s' = stack s \\<and>\npending s' = pending s - {u} \\<times> (E `` {u} - it) \\<and>\ngen_discovered s \\<union> (E `` {u} - it)\n\\<subseteq> gen_discovered s')\\<^esup>\n            (E `` {u}) (\\<lambda>s. \\<not> gds_is_break gds s)\n            (\\<lambda>v s.\n                choose_pending u (Some v) s \\<bind>\n                (\\<lambda>s.\n                    if gds_is_discovered gds v s\n                    then if gds_is_finished gds v s\n                         then gds_cross_edge gds u v s\n                         else gds_back_edge gds u v s\n                    else gds_discover gds u v s \\<bind>\n                         (\\<lambda>s.\n                             if gds_is_break gds s then RETURN s\n                             else D (v, s))))\n            s \\<bind>\n           (\\<lambda>s.\n               if gds_is_break gds s then RETURN s\n               else choose_pending u None s \\<bind>\n                    (\\<lambda>s. gds_finish gds u s \\<bind> RETURN)))\n       (v0, s)))\n                      \\<le> SPEC\n                             (\\<lambda>s.\n                                 gen_rwof' s \\<and> \\<not> gen_cond s)", "apply (refine_rcg refine_vcg\n      order_trans[OF gds_init_refine]\n      order_trans[OF gds_choose_pending_refine]\n      order_trans[OF gds_new_root_refine]\n      order_trans[OF gds_finish_refine]\n      order_trans[OF gds_back_edge_refine]\n      order_trans[OF gds_cross_edge_refine]\n      order_trans[OF gds_discover_refine]\n    )"], ["proof (prove)\ngoal (79 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}\\<rbrakk>\n       \\<Longrightarrow> finite V0\n 2. \\<And>x.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}\\<rbrakk>\n       \\<Longrightarrow> gen_rwof' x\n 3. \\<And>x.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {};\n        \\<not> gds_is_break gds x\\<rbrakk>\n       \\<Longrightarrow> gds_is_empty_stack gds x\n 4. \\<And>x.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {};\n        \\<not> gds_is_break gds x\\<rbrakk>\n       \\<Longrightarrow> V0 - V0 \\<subseteq> gen_discovered x\n 5. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma> \\<and>\n         V0 - it \\<subseteq> gen_discovered \\<sigma>);\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        gds_is_discovered gds xa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> gen_rwof' \\<sigma>\n 6. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma> \\<and>\n         V0 - it \\<subseteq> gen_discovered \\<sigma>);\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        gds_is_discovered gds xa \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> gds_is_empty_stack gds \\<sigma>\n 7. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma> \\<and>\n         V0 - it \\<subseteq> gen_discovered \\<sigma>);\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        gds_is_discovered gds xa \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> V0 - (it - {xa})\n                         \\<subseteq> gen_discovered \\<sigma>\n 8. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma> \\<and>\n         V0 - it \\<subseteq> gen_discovered \\<sigma>);\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> pre_new_root xa \\<sigma>\n 9. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n         gds_is_empty_stack gds \\<sigma> \\<and>\n         V0 - it \\<subseteq> gen_discovered \\<sigma>);\n        (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> gen_rwof' \\<sigma>\n 10. \\<And>x xa it \\<sigma> xb.\n        \\<lbrakk>nofail gen_dfs;\n         nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n         gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n         it \\<subseteq> V0;\n         gen_rwof' \\<sigma> \\<and>\n         (\\<not> gds_is_break gds \\<sigma> \\<longrightarrow>\n          gds_is_empty_stack gds \\<sigma> \\<and>\n          V0 - it \\<subseteq> gen_discovered \\<sigma>);\n         (Not \\<circ>\\<circ> gds_is_break) gds \\<sigma>;\n         \\<not> gds_is_discovered gds xa \\<sigma>;\n         gen_rwof' xb \\<and>\n         stack xb = [xa] \\<and>\n         pending xb = {xa} \\<times> E `` {xa} \\<and>\n         gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n         gds_is_break gds xb\\<rbrakk>\n        \\<Longrightarrow> gen_rwof' xb\nA total of 79 subgoals...", "apply (simp_all split: if_split_asm)"], ["proof (prove)\ngoal (27 subgoals):\n 1. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        gds_is_discovered gds xa \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> V0 - (it - {xa})\n                         \\<subseteq> gen_discovered \\<sigma>\n 2. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> pre_new_root xa \\<sigma>\n 3. \\<And>x xa it \\<sigma> xb x1.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; x1 \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds x1 \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [x1] \\<and>\n        pending xb = {x1} \\<times> E `` {x1} \\<and>\n        gen_discovered xb = insert x1 (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb; xa = x1\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> {x1} \\<times> UNIV\n                         \\<subseteq> {x1} \\<times> E `` {x1}\n 4. \\<And>x xa it \\<sigma> xb f xc a b.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (E `` {a})\n 5. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>'.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending \\<sigma>'\n 6. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>'.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> a = hd (stack b)\n 7. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>'.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (a, xd) \\<in> pending b\n 8. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        gds_is_discovered gds xd xe; gds_is_finished gds xd xe\\<rbrakk>\n       \\<Longrightarrow> pre_cross_edge a xd \\<sigma>' xe\n 9. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        gds_is_discovered gds xd xe; gds_is_finished gds xd xe;\n        gen_rwof' xf \\<and>\n        pending xf = pending xe \\<and>\n        stack xf = stack xe \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xf = gds_is_discovered gds x xe);\n        \\<not> gds_is_break gds xf\\<rbrakk>\n       \\<Longrightarrow> stack xe = stack b\n 10. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n        \\<lbrakk>nofail gen_dfs;\n         nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n         gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n         it \\<subseteq> V0;\n         gen_rwof' \\<sigma> \\<and>\n         stack \\<sigma> = [] \\<and>\n         V0 - it \\<subseteq> gen_discovered \\<sigma>;\n         \\<not> gds_is_break gds \\<sigma>;\n         \\<not> gds_is_discovered gds xa \\<sigma>;\n         gen_rwof' xb \\<and>\n         stack xb = [xa] \\<and>\n         pending xb = {xa} \\<times> E `` {xa} \\<and>\n         gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n         \\<not> gds_is_break gds xb;\n         \\<And>x.\n            case x of\n            (u, s) \\<Rightarrow>\n              gen_rwof' s \\<and>\n              \\<not> gds_is_break gds s \\<and>\n              (\\<exists>stk. stack s = u # stk) \\<and>\n              E \\<inter> {u} \\<times> UNIV\n              \\<subseteq> pending s \\<Longrightarrow>\n            f x\n            \\<le> SPEC\n                   (case x of\n                    (u, s) \\<Rightarrow>\n                      \\<lambda>s'.\n                         gen_rwof' s' \\<and>\n                         (\\<not> gds_is_break gds s' \\<longrightarrow>\n                          stack s' = tl (stack s) \\<and>\n                          pending s' = pending s - {u} \\<times> UNIV \\<and>\n                          gen_discovered s \\<subseteq> gen_discovered s'));\n         gen_rwof' b \\<and>\n         \\<not> gds_is_break gds b \\<and>\n         (\\<exists>stk. stack b = a # stk) \\<and>\n         E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n         xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n         gen_rwof' \\<sigma>' \\<and>\n         stack \\<sigma>' = stack b \\<and>\n         pending \\<sigma>' =\n         pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n         gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n         E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n         \\<not> gds_is_break gds \\<sigma>';\n         post_choose_pending a (Some xd) \\<sigma>' xe;\n         gds_is_discovered gds xd xe; gds_is_finished gds xd xe;\n         gen_rwof' xf \\<and>\n         pending xf = pending xe \\<and>\n         stack xf = stack xe \\<and>\n         (\\<forall>x.\n             gds_is_discovered gds x xf = gds_is_discovered gds x xe);\n         \\<not> gds_is_break gds xf\\<rbrakk>\n        \\<Longrightarrow> pending xe =\n                          pending b - {a} \\<times> (E `` {a} - (ita - {xd}))\nA total of 27 subgoals...", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (27 subgoals):\n 1. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        gds_is_discovered gds xa \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> V0 - (it - {xa})\n                         \\<subseteq> gen_discovered \\<sigma>\nA total of 27 subgoals...", "apply (auto simp add: pre_defs; fail)"], ["proof (prove)\ngoal (26 subgoals):\n 1. \\<And>x xa it \\<sigma>.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> pre_new_root xa \\<sigma>\nA total of 26 subgoals...", "apply (auto simp add: pre_defs gen_rwof'_imp_rwof; fail)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x xa it \\<sigma> xb x1.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; x1 \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds x1 \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [x1] \\<and>\n        pending xb = {x1} \\<times> E `` {x1} \\<and>\n        gen_discovered xb = insert x1 (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb; xa = x1\\<rbrakk>\n       \\<Longrightarrow> E \\<inter> {x1} \\<times> UNIV\n                         \\<subseteq> {x1} \\<times> E `` {x1}\nA total of 25 subgoals...", "apply (auto; fail)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (E `` {a})\nA total of 24 subgoals...", "apply (auto dest: reachable_invar; fail)"], ["proof (prove)\ngoal (23 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>'.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending \\<sigma>'\nA total of 23 subgoals...", "apply (auto simp add: pre_defs gen_rwof'_imp_rwof; fail)"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>'.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> a = hd (stack b)\nA total of 22 subgoals...", "apply (auto; fail)"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>'.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (a, xd) \\<in> pending b\nA total of 21 subgoals...", "apply (auto; fail)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        gds_is_discovered gds xd xe; gds_is_finished gds xd xe\\<rbrakk>\n       \\<Longrightarrow> pre_cross_edge a xd \\<sigma>' xe\nA total of 20 subgoals...", "apply ((drule pcp_imp_pgp, auto simp add: pre_defs gen_rwof'_imp_rwof); fail)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        gds_is_discovered gds xd xe; gds_is_finished gds xd xe;\n        gen_rwof' xf \\<and>\n        pending xf = pending xe \\<and>\n        stack xf = stack xe \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xf = gds_is_discovered gds x xe);\n        \\<not> gds_is_break gds xf\\<rbrakk>\n       \\<Longrightarrow> stack xe = stack b\nA total of 19 subgoals...", "apply (auto simp: post_choose_pending_def; fail)"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        gds_is_discovered gds xd xe; gds_is_finished gds xd xe;\n        gen_rwof' xf \\<and>\n        pending xf = pending xe \\<and>\n        stack xf = stack xe \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xf = gds_is_discovered gds x xe);\n        \\<not> gds_is_break gds xf\\<rbrakk>\n       \\<Longrightarrow> pending xe =\n                         pending b - {a} \\<times> (E `` {a} - (ita - {xd}))\nA total of 18 subgoals...", "apply (auto simp: post_choose_pending_def; fail)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        gds_is_discovered gds xd xe; gds_is_finished gds xd xe;\n        gen_rwof' xf \\<and>\n        pending xf = pending xe \\<and>\n        stack xf = stack xe \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xf = gds_is_discovered gds x xe);\n        \\<not> gds_is_break gds xf\\<rbrakk>\n       \\<Longrightarrow> gen_discovered b\n                         \\<subseteq> gen_discovered xe \\<and>\n                         E `` {a} - (ita - {xd})\n                         \\<subseteq> gen_discovered xe\nA total of 17 subgoals...", "apply (auto simp: post_choose_pending_def; fail)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        gds_is_discovered gds xd xe;\n        \\<not> gds_is_finished gds xd xe\\<rbrakk>\n       \\<Longrightarrow> pre_back_edge a xd \\<sigma>' xe\nA total of 16 subgoals...", "apply ((drule pcp_imp_pgp, auto simp add: pre_defs gen_rwof'_imp_rwof); fail)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        gds_is_discovered gds xd xe; \\<not> gds_is_finished gds xd xe;\n        gen_rwof' xf \\<and>\n        pending xf = pending xe \\<and>\n        stack xf = stack xe \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xf = gds_is_discovered gds x xe);\n        \\<not> gds_is_break gds xf\\<rbrakk>\n       \\<Longrightarrow> stack xe = stack b\nA total of 15 subgoals...", "apply (auto simp: post_choose_pending_def; fail)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        gds_is_discovered gds xd xe; \\<not> gds_is_finished gds xd xe;\n        gen_rwof' xf \\<and>\n        pending xf = pending xe \\<and>\n        stack xf = stack xe \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xf = gds_is_discovered gds x xe);\n        \\<not> gds_is_break gds xf\\<rbrakk>\n       \\<Longrightarrow> pending xe =\n                         pending b - {a} \\<times> (E `` {a} - (ita - {xd}))\nA total of 14 subgoals...", "apply (auto simp: post_choose_pending_def; fail)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        gds_is_discovered gds xd xe; \\<not> gds_is_finished gds xd xe;\n        gen_rwof' xf \\<and>\n        pending xf = pending xe \\<and>\n        stack xf = stack xe \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xf = gds_is_discovered gds x xe);\n        \\<not> gds_is_break gds xf\\<rbrakk>\n       \\<Longrightarrow> gen_discovered b\n                         \\<subseteq> gen_discovered xe \\<and>\n                         E `` {a} - (ita - {xd})\n                         \\<subseteq> gen_discovered xe\nA total of 13 subgoals...", "apply (auto simp: post_choose_pending_def; fail)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        \\<not> gds_is_discovered gds xd xe\\<rbrakk>\n       \\<Longrightarrow> pre_discover a xd \\<sigma>' xe\nA total of 12 subgoals...", "apply ((drule pcp_imp_pgp, auto simp add: pre_defs gen_rwof'_imp_rwof); fail)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        \\<not> gds_is_discovered gds xd xe;\n        gen_rwof' xf \\<and>\n        pending xf = pending xe \\<union> {xd} \\<times> E `` {xd} \\<and>\n        stack xf = xd # stack xe \\<and>\n        gen_discovered xf = insert xd (gen_discovered xe);\n        \\<not> gds_is_break gds xf\\<rbrakk>\n       \\<Longrightarrow> f (xd, xf)\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    gen_rwof' s' \\<and>\n                                    (\\<not> gds_is_break gds\n       s' \\<longrightarrow>\n                                     stack s' = stack b \\<and>\n                                     pending s' =\n                                     pending b -\n                                     {a} \\<times>\n                                     (E `` {a} - (ita - {xd})) \\<and>\n                                     gen_discovered b\n                                     \\<subseteq> gen_discovered s' \\<and>\n                                     E `` {a} - (ita - {xd})\n                                     \\<subseteq> gen_discovered s'))\nA total of 11 subgoals...", "apply (rule order_trans)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        \\<not> gds_is_discovered gds xd xe;\n        gen_rwof' xf \\<and>\n        pending xf = pending xe \\<union> {xd} \\<times> E `` {xd} \\<and>\n        stack xf = xd # stack xe \\<and>\n        gen_discovered xf = insert xd (gen_discovered xe);\n        \\<not> gds_is_break gds xf\\<rbrakk>\n       \\<Longrightarrow> f (xd, xf)\n                         \\<le> ?y1520 x xa it \\<sigma> xb f xc a b xd ita\n                                \\<sigma>' xe xf\nA total of 12 subgoals...", "apply rprems"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        \\<not> gds_is_discovered gds xd xe;\n        gen_rwof' xf \\<and>\n        pending xf = pending xe \\<union> {xd} \\<times> E `` {xd} \\<and>\n        stack xf = xd # stack xe \\<and>\n        gen_discovered xf = insert xd (gen_discovered xe);\n        \\<not> gds_is_break gds xf\\<rbrakk>\n       \\<Longrightarrow> case (xd, xf) of\n                         (u, s) \\<Rightarrow>\n                           gen_rwof' s \\<and>\n                           \\<not> gds_is_break gds s \\<and>\n                           (\\<exists>stk. stack s = u # stk) \\<and>\n                           E \\<inter> {u} \\<times> UNIV\n                           \\<subseteq> pending s\nA total of 12 subgoals...", "apply (auto; fail) []"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b xd ita \\<sigma>' xe xf.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b); xd \\<in> ita; ita \\<subseteq> E `` {a};\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> (E `` {a} - ita) \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} - ita \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a (Some xd) \\<sigma>' xe;\n        \\<not> gds_is_discovered gds xd xe;\n        gen_rwof' xf \\<and>\n        pending xf = pending xe \\<union> {xd} \\<times> E `` {xd} \\<and>\n        stack xf = xd # stack xe \\<and>\n        gen_discovered xf = insert xd (gen_discovered xe);\n        \\<not> gds_is_break gds xf\\<rbrakk>\n       \\<Longrightarrow> SPEC\n                          (case (xd, xf) of\n                           (u, s) \\<Rightarrow>\n                             \\<lambda>s'.\n                                gen_rwof' s' \\<and>\n                                (\\<not> gds_is_break gds\n   s' \\<longrightarrow>\n                                 stack s' = tl (stack s) \\<and>\n                                 pending s' =\n                                 pending s - {u} \\<times> UNIV \\<and>\n                                 gen_discovered s\n                                 \\<subseteq> gen_discovered s'))\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    gen_rwof' s' \\<and>\n                                    (\\<not> gds_is_break gds\n       s' \\<longrightarrow>\n                                     stack s' = stack b \\<and>\n                                     pending s' =\n                                     pending b -\n                                     {a} \\<times>\n                                     (E `` {a} - (ita - {xd})) \\<and>\n                                     gen_discovered b\n                                     \\<subseteq> gen_discovered s' \\<and>\n                                     E `` {a} - (ita - {xd})\n                                     \\<subseteq> gen_discovered s'))\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail gen_dfs;\n     nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n     gen_rwof' x_ \\<and> stack x_ = [] \\<and> pending x_ = {};\n     xa_ \\<in> it_; it_ \\<subseteq> V0;\n     gen_rwof' \\<sigma>_ \\<and>\n     stack \\<sigma>_ = [] \\<and>\n     V0 - it_ \\<subseteq> gen_discovered \\<sigma>_;\n     \\<not> gds_is_break gds \\<sigma>_;\n     \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n     gen_rwof' xb_ \\<and>\n     stack xb_ = [xa_] \\<and>\n     pending xb_ = {xa_} \\<times> E `` {xa_} \\<and>\n     gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n     \\<not> gds_is_break gds xb_;\n     \\<And>x.\n        case x of\n        (u, s) \\<Rightarrow>\n          gen_rwof' s \\<and>\n          \\<not> gds_is_break gds s \\<and>\n          (\\<exists>stk. stack s = u # stk) \\<and>\n          E \\<inter> {u} \\<times> UNIV\n          \\<subseteq> pending s \\<Longrightarrow>\n        f_ x\n        \\<le> SPEC\n               (case x of\n                (u, s) \\<Rightarrow>\n                  \\<lambda>s'.\n                     gen_rwof' s' \\<and>\n                     (\\<not> gds_is_break gds s' \\<longrightarrow>\n                      stack s' = tl (stack s) \\<and>\n                      pending s' = pending s - {u} \\<times> UNIV \\<and>\n                      gen_discovered s \\<subseteq> gen_discovered s'));\n     gen_rwof' b_ \\<and>\n     \\<not> gds_is_break gds b_ \\<and>\n     (\\<exists>stk. stack b_ = a_ # stk) \\<and>\n     E \\<inter> {a_} \\<times> UNIV \\<subseteq> pending b_;\n     xc_ = (a_, b_); xd_ \\<in> ita_; ita_ \\<subseteq> E `` {a_};\n     gen_rwof' \\<sigma>'_ \\<and>\n     stack \\<sigma>'_ = stack b_ \\<and>\n     pending \\<sigma>'_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) \\<and>\n     gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_ \\<and>\n     E `` {a_} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n     \\<not> gds_is_break gds \\<sigma>'_;\n     post_choose_pending a_ (Some xd_) \\<sigma>'_ xe_;\n     \\<not> gds_is_discovered gds xd_ xe_;\n     gen_rwof' xf_ \\<and>\n     pending xf_ = pending xe_ \\<union> {xd_} \\<times> E `` {xd_} \\<and>\n     stack xf_ = xd_ # stack xe_ \\<and>\n     gen_discovered xf_ = insert xd_ (gen_discovered xe_);\n     \\<not> gds_is_break gds xf_\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (case (xd_, xf_) of\n                        (u, s) \\<Rightarrow>\n                          \\<lambda>s'.\n                             gen_rwof' s' \\<and>\n                             (\\<not> gds_is_break gds s' \\<longrightarrow>\n                              stack s' = tl (stack s) \\<and>\n                              pending s' =\n                              pending s - {u} \\<times> UNIV \\<and>\n                              gen_discovered s\n                              \\<subseteq> gen_discovered s'))\n                      \\<le> SPEC\n                             (\\<lambda>s'.\n                                 gen_rwof' s' \\<and>\n                                 (\\<not> gds_is_break gds\n    s' \\<longrightarrow>\n                                  stack s' = stack b_ \\<and>\n                                  pending s' =\n                                  pending b_ -\n                                  {a_} \\<times>\n                                  (E `` {a_} - (ita_ - {xd_})) \\<and>\n                                  gen_discovered b_\n                                  \\<subseteq> gen_discovered s' \\<and>\n                                  E `` {a_} - (ita_ - {xd_})\n                                  \\<subseteq> gen_discovered s'))", "apply (rule SPEC_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xg.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x_ \\<and> stack x_ = [] \\<and> pending x_ = {};\n        xa_ \\<in> it_; it_ \\<subseteq> V0;\n        gen_rwof' \\<sigma>_ \\<and>\n        stack \\<sigma>_ = [] \\<and>\n        V0 - it_ \\<subseteq> gen_discovered \\<sigma>_;\n        \\<not> gds_is_break gds \\<sigma>_;\n        \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n        gen_rwof' xb_ \\<and>\n        stack xb_ = [xa_] \\<and>\n        pending xb_ = {xa_} \\<times> E `` {xa_} \\<and>\n        gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n        \\<not> gds_is_break gds xb_;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f_ x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b_ \\<and>\n        \\<not> gds_is_break gds b_ \\<and>\n        (\\<exists>stk. stack b_ = a_ # stk) \\<and>\n        E \\<inter> {a_} \\<times> UNIV \\<subseteq> pending b_;\n        xc_ = (a_, b_); xd_ \\<in> ita_; ita_ \\<subseteq> E `` {a_};\n        gen_rwof' \\<sigma>'_ \\<and>\n        stack \\<sigma>'_ = stack b_ \\<and>\n        pending \\<sigma>'_ =\n        pending b_ - {a_} \\<times> (E `` {a_} - ita_) \\<and>\n        gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_ \\<and>\n        E `` {a_} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n        \\<not> gds_is_break gds \\<sigma>'_;\n        post_choose_pending a_ (Some xd_) \\<sigma>'_ xe_;\n        \\<not> gds_is_discovered gds xd_ xe_;\n        gen_rwof' xf_ \\<and>\n        pending xf_ = pending xe_ \\<union> {xd_} \\<times> E `` {xd_} \\<and>\n        stack xf_ = xd_ # stack xe_ \\<and>\n        gen_discovered xf_ = insert xd_ (gen_discovered xe_);\n        \\<not> gds_is_break gds xf_;\n        (case (xd_, xf_) of\n         (u, s) \\<Rightarrow>\n           \\<lambda>s'.\n              gen_rwof' s' \\<and>\n              (\\<not> gds_is_break gds s' \\<longrightarrow>\n               stack s' = tl (stack s) \\<and>\n               pending s' = pending s - {u} \\<times> UNIV \\<and>\n               gen_discovered s \\<subseteq> gen_discovered s'))\n         xg\\<rbrakk>\n       \\<Longrightarrow> gen_rwof' xg \\<and>\n                         (\\<not> gds_is_break gds xg \\<longrightarrow>\n                          stack xg = stack b_ \\<and>\n                          pending xg =\n                          pending b_ -\n                          {a_} \\<times> (E `` {a_} - (ita_ - {xd_})) \\<and>\n                          gen_discovered b_\n                          \\<subseteq> gen_discovered xg \\<and>\n                          E `` {a_} - (ita_ - {xd_})\n                          \\<subseteq> gen_discovered xg)", "apply (simp add: post_choose_pending_def gen_rwof'_imp_rwof\n        split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xg.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x_ \\<and> stack x_ = [] \\<and> pending x_ = {};\n        xa_ \\<in> it_; it_ \\<subseteq> V0;\n        gen_rwof' \\<sigma>_ \\<and>\n        stack \\<sigma>_ = [] \\<and>\n        V0 - it_ \\<subseteq> gen_discovered \\<sigma>_;\n        \\<not> gds_is_break gds \\<sigma>_;\n        \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n        gen_rwof' xb_ \\<and>\n        stack xb_ = [xa_] \\<and>\n        pending xb_ = {xa_} \\<times> E `` {xa_} \\<and>\n        gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n        \\<not> gds_is_break gds xb_;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f_ x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b_ \\<and>\n        \\<not> gds_is_break gds b_ \\<and>\n        (\\<exists>stk. stack b_ = hd (stack b_) # stk) \\<and>\n        E \\<inter> {hd (stack b_)} \\<times> UNIV \\<subseteq> pending b_;\n        xc_ = (hd (stack b_), b_); xd_ \\<in> ita_;\n        ita_ \\<subseteq> E `` {hd (stack b_)};\n        gen_rwof' \\<sigma>'_ \\<and>\n        stack \\<sigma>'_ = stack b_ \\<and>\n        pending \\<sigma>'_ =\n        pending b_ -\n        {hd (stack b_)} \\<times> (E `` {hd (stack b_)} - ita_) \\<and>\n        gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_ \\<and>\n        E `` {hd (stack b_)} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n        \\<not> gds_is_break gds \\<sigma>'_;\n        gen_cond \\<sigma>'_ \\<and>\n        stack b_ \\<noteq> [] \\<and>\n        a_ = hd (stack b_) \\<and>\n        inres (choose_pending a_ (Some xd_) \\<sigma>'_) xe_ \\<and>\n        stack xe_ = stack b_ \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xe_ =\n            gds_is_discovered gds x \\<sigma>'_) \\<and>\n        (a_, xd_) \\<in> pending b_ \\<and>\n        pending xe_ =\n        pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)};\n        \\<not> gds_is_discovered gds xd_ \\<sigma>'_;\n        gen_rwof' xf_ \\<and>\n        pending xf_ =\n        pending b_ -\n        {hd (stack b_)} \\<times> (E `` {hd (stack b_)} - ita_) -\n        {(hd (stack b_), xd_)} \\<union>\n        {xd_} \\<times> E `` {xd_} \\<and>\n        stack xf_ = xd_ # stack b_ \\<and>\n        gen_discovered xf_ = insert xd_ (gen_discovered \\<sigma>'_);\n        \\<not> gds_is_break gds xf_;\n        gen_rwof' xg \\<and>\n        (\\<not> gds_is_break gds xg \\<longrightarrow>\n         stack xg = stack b_ \\<and>\n         pending xg =\n         pending b_ -\n         {hd (stack b_)} \\<times> (E `` {hd (stack b_)} - ita_) -\n         {(hd (stack b_), xd_)} \\<union>\n         {xd_} \\<times> E `` {xd_} -\n         {xd_} \\<times> UNIV \\<and>\n         gds_is_discovered gds xd_ xg \\<and>\n         gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered xg)\\<rbrakk>\n       \\<Longrightarrow> \\<not> gds_is_break gds xg \\<longrightarrow>\n                         pending b_ -\n                         {hd (stack b_)} \\<times>\n                         (E `` {hd (stack b_)} - ita_) -\n                         {(hd (stack b_), xd_)} \\<union>\n                         {xd_} \\<times> E `` {xd_} -\n                         {xd_} \\<times> UNIV =\n                         pending b_ -\n                         {hd (stack b_)} \\<times>\n                         (E `` {hd (stack b_)} - (ita_ - {xd_})) \\<and>\n                         gen_discovered b_\n                         \\<subseteq> gen_discovered xg \\<and>\n                         E `` {hd (stack b_)} - (ita_ - {xd_})\n                         \\<subseteq> gen_discovered xg", "apply (clarsimp \n        simp: gen_rwof'_imp_rwof Un_Diff\n        split: if_split_asm) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xg stk.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        xa_ \\<in> it_; it_ \\<subseteq> V0;\n        \\<not> gds_is_break gds \\<sigma>_;\n        \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n        \\<not> gds_is_break gds xb_;\n        \\<And>a b.\n           gen_rwof' b \\<and>\n           \\<not> gds_is_break gds b \\<and>\n           (\\<exists>stk. stack b = a # stk) \\<and>\n           E \\<inter> {a} \\<times> UNIV\n           \\<subseteq> pending b \\<Longrightarrow>\n           f_ (a, b)\n           \\<le> SPEC\n                  (\\<lambda>s'.\n                      gen_rwof' s' \\<and>\n                      (\\<not> gds_is_break gds s' \\<longrightarrow>\n                       stack s' = tl (stack b) \\<and>\n                       pending s' = pending b - {a} \\<times> UNIV \\<and>\n                       gen_discovered b \\<subseteq> gen_discovered s'));\n        xc_ = (hd (stack b_), b_); xd_ \\<in> ita_;\n        ita_ \\<subseteq> E `` {hd (stack b_)};\n        \\<not> gds_is_break gds \\<sigma>'_;\n        \\<not> gds_is_discovered gds xd_ \\<sigma>'_;\n        \\<not> gds_is_break gds xf_; gen_rwof' x_; gen_rwof' \\<sigma>_;\n        gen_rwof' xb_; gen_rwof' b_; gen_rwof' \\<sigma>'_;\n        gen_cond \\<sigma>'_; gen_rwof' xf_; gen_rwof' xg; stack x_ = [];\n        pending x_ = {}; stack \\<sigma>_ = [];\n        V0 - it_ \\<subseteq> gen_discovered \\<sigma>_; stack xb_ = [xa_];\n        \\<not> gds_is_break gds b_; stack \\<sigma>'_ = stack b_;\n        stack b_ \\<noteq> [];\n        pending xf_ =\n        pending b_ -\n        {hd (stack b_)} \\<times> (E `` {hd (stack b_)} - ita_) -\n        {(hd (stack b_), xd_)} \\<union>\n        {xd_} \\<times> E `` {xd_};\n        pending xb_ = {xa_} \\<times> E `` {xa_};\n        gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n        E \\<inter> {hd (stack b_)} \\<times> UNIV \\<subseteq> pending b_;\n        stack b_ = hd (stack b_) # stk;\n        pending \\<sigma>'_ =\n        pending b_ - {hd (stack b_)} \\<times> (E `` {hd (stack b_)} - ita_);\n        a_ = hd (stack b_); stack xf_ = xd_ # stack b_;\n        gen_discovered xf_ = insert xd_ (gen_discovered \\<sigma>'_);\n        gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_;\n        E `` {hd (stack b_)} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n        inres (choose_pending (hd (stack b_)) (Some xd_) \\<sigma>'_) xe_;\n        stack xe_ = stack b_;\n        \\<forall>x.\n           gds_is_discovered gds x xe_ = gds_is_discovered gds x \\<sigma>'_;\n        (hd (stack b_), xd_) \\<in> pending b_;\n        pending xe_ =\n        pending b_ -\n        {hd (stack b_)} \\<times> (E `` {hd (stack b_)} - ita_) -\n        {(hd (stack b_), xd_)};\n        \\<not> gds_is_break gds xg; stack xg = stack b_;\n        pending xg =\n        pending b_ -\n        {hd (stack b_)} \\<times> (E `` {hd (stack b_)} - ita_) -\n        {(hd (stack b_), xd_)} -\n        {xd_} \\<times> UNIV;\n        gds_is_discovered gds xd_ xg;\n        gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered xg\\<rbrakk>\n       \\<Longrightarrow> pending b_ -\n                         {hd (stack b_)} \\<times>\n                         (E `` {hd (stack b_)} - ita_) -\n                         {(hd (stack b_), xd_)} -\n                         {xd_} \\<times> UNIV =\n                         pending b_ -\n                         {hd (stack b_)} \\<times>\n                         (E `` {hd (stack b_)} - (ita_ - {xd_})) \\<and>\n                         gen_discovered b_\n                         \\<subseteq> gen_discovered xg \\<and>\n                         E `` {hd (stack b_)} - (ita_ - {xd_})\n                         \\<subseteq> gen_discovered xg", "apply (clarsimp simp: it_step_insert_iff neq_Nil_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xg stk.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        xa_ \\<in> it_; it_ \\<subseteq> V0;\n        \\<not> gds_is_break gds \\<sigma>_;\n        \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n        \\<not> gds_is_break gds xb_;\n        \\<And>a b.\n           gen_rwof' b \\<and>\n           \\<not> gds_is_break gds b \\<and>\n           (\\<exists>stk. stack b = a # stk) \\<and>\n           E \\<inter> {a} \\<times> UNIV\n           \\<subseteq> pending b \\<Longrightarrow>\n           f_ (a, b)\n           \\<le> SPEC\n                  (\\<lambda>s'.\n                      gen_rwof' s' \\<and>\n                      (\\<not> gds_is_break gds s' \\<longrightarrow>\n                       stack s' = tl (stack b) \\<and>\n                       pending s' = pending b - {a} \\<times> UNIV \\<and>\n                       gen_discovered b \\<subseteq> gen_discovered s'));\n        xc_ = (a_, b_); xd_ \\<in> ita_; ita_ \\<subseteq> E `` {a_};\n        \\<not> gds_is_break gds \\<sigma>'_;\n        \\<not> gds_is_discovered gds xd_ \\<sigma>'_;\n        \\<not> gds_is_break gds xf_; gen_rwof' x_; gen_rwof' \\<sigma>_;\n        gen_rwof' xb_; gen_rwof' b_; gen_rwof' \\<sigma>'_;\n        gen_cond \\<sigma>'_; gen_rwof' xf_; gen_rwof' xg; stack x_ = [];\n        pending x_ = {}; stack \\<sigma>_ = [];\n        V0 - it_ \\<subseteq> gen_discovered \\<sigma>_; stack xb_ = [xa_];\n        \\<not> gds_is_break gds b_; stack \\<sigma>'_ = a_ # stk;\n        pending xf_ =\n        pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} \\<union>\n        {xd_} \\<times> E `` {xd_};\n        pending xb_ = {xa_} \\<times> E `` {xa_};\n        gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n        E \\<inter> {a_} \\<times> UNIV \\<subseteq> pending b_;\n        pending \\<sigma>'_ = pending b_ - {a_} \\<times> (E `` {a_} - ita_);\n        stack xf_ = xd_ # a_ # stk;\n        gen_discovered xf_ = insert xd_ (gen_discovered \\<sigma>'_);\n        gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_;\n        E `` {a_} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n        inres (choose_pending a_ (Some xd_) \\<sigma>'_) xe_;\n        stack xe_ = a_ # stk;\n        \\<forall>x.\n           gds_is_discovered gds x xe_ = gds_is_discovered gds x \\<sigma>'_;\n        (a_, xd_) \\<in> pending b_;\n        pending xe_ =\n        pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)};\n        \\<not> gds_is_break gds xg; stack xg = a_ # stk;\n        pending xg =\n        pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} -\n        {xd_} \\<times> UNIV;\n        gds_is_discovered gds xd_ xg;\n        gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered xg;\n        stack b_ = a_ # stk\\<rbrakk>\n       \\<Longrightarrow> pending b_ - {a_} \\<times> (E `` {a_} - ita_) -\n                         {(a_, xd_)} -\n                         {xd_} \\<times> UNIV =\n                         pending b_ -\n                         insert (a_, xd_)\n                          ({a_} \\<times> (E `` {a_} - ita_)) \\<and>\n                         gen_discovered b_\n                         \\<subseteq> gen_discovered xg \\<and>\n                         E `` {a_} - ita_ \\<subseteq> gen_discovered xg", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xg stk.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        xa_ \\<in> it_; it_ \\<subseteq> V0;\n        \\<not> gds_is_break gds \\<sigma>_;\n        \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n        \\<not> gds_is_break gds xb_;\n        \\<And>a b.\n           gen_rwof' b \\<and>\n           \\<not> gds_is_break gds b \\<and>\n           (\\<exists>stk. stack b = a # stk) \\<and>\n           E \\<inter> {a} \\<times> UNIV\n           \\<subseteq> pending b \\<Longrightarrow>\n           f_ (a, b)\n           \\<le> SPEC\n                  (\\<lambda>s'.\n                      gen_rwof' s' \\<and>\n                      (\\<not> gds_is_break gds s' \\<longrightarrow>\n                       stack s' = tl (stack b) \\<and>\n                       pending s' = pending b - {a} \\<times> UNIV \\<and>\n                       gen_discovered b \\<subseteq> gen_discovered s'));\n        xc_ = (a_, b_); xd_ \\<in> ita_; ita_ \\<subseteq> E `` {a_};\n        \\<not> gds_is_break gds \\<sigma>'_;\n        \\<not> gds_is_discovered gds xd_ \\<sigma>'_;\n        \\<not> gds_is_break gds xf_; gen_rwof' x_; gen_rwof' \\<sigma>_;\n        gen_rwof' xb_; gen_rwof' b_; gen_rwof' \\<sigma>'_;\n        gen_cond \\<sigma>'_; gen_rwof' xf_; gen_rwof' xg; stack x_ = [];\n        pending x_ = {}; stack \\<sigma>_ = [];\n        V0 - it_ \\<subseteq> gen_discovered \\<sigma>_; stack xb_ = [xa_];\n        \\<not> gds_is_break gds b_; stack \\<sigma>'_ = a_ # stk;\n        pending xf_ =\n        pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} \\<union>\n        {xd_} \\<times> E `` {xd_};\n        pending xb_ = {xa_} \\<times> E `` {xa_};\n        gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n        E \\<inter> {a_} \\<times> UNIV \\<subseteq> pending b_;\n        pending \\<sigma>'_ = pending b_ - {a_} \\<times> (E `` {a_} - ita_);\n        stack xf_ = xd_ # a_ # stk;\n        gen_discovered xf_ = insert xd_ (gen_discovered \\<sigma>'_);\n        gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_;\n        E `` {a_} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n        inres (choose_pending a_ (Some xd_) \\<sigma>'_) xe_;\n        stack xe_ = a_ # stk;\n        \\<forall>x.\n           gds_is_discovered gds x xe_ = gds_is_discovered gds x \\<sigma>'_;\n        (a_, xd_) \\<in> pending b_;\n        pending xe_ =\n        pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)};\n        \\<not> gds_is_break gds xg; stack xg = a_ # stk;\n        pending xg =\n        pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} -\n        {xd_} \\<times> UNIV;\n        gds_is_discovered gds xd_ xg;\n        gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered xg;\n        stack b_ = a_ # stk\\<rbrakk>\n       \\<Longrightarrow> pending b_ - {a_} \\<times> (E `` {a_} - ita_) -\n                         {(a_, xd_)} -\n                         {xd_} \\<times> UNIV =\n                         pending b_ -\n                         insert (a_, xd_) ({a_} \\<times> (E `` {a_} - ita_))\nA total of 2 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail gen_dfs;\n     nofail (gds_init gds \\<bind> WHILE gen_cond gen_step'); xa_ \\<in> it_;\n     it_ \\<subseteq> V0; \\<not> gds_is_break gds \\<sigma>_;\n     \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n     \\<not> gds_is_break gds xb_;\n     \\<And>a b.\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b \\<Longrightarrow>\n        f_ (a, b)\n        \\<le> SPEC\n               (\\<lambda>s'.\n                   gen_rwof' s' \\<and>\n                   (\\<not> gds_is_break gds s' \\<longrightarrow>\n                    stack s' = tl (stack b) \\<and>\n                    pending s' = pending b - {a} \\<times> UNIV \\<and>\n                    gen_discovered b \\<subseteq> gen_discovered s'));\n     xc_ = (a_, b_); xd_ \\<in> ita_; ita_ \\<subseteq> E `` {a_};\n     \\<not> gds_is_break gds \\<sigma>'_;\n     \\<not> gds_is_discovered gds xd_ \\<sigma>'_;\n     \\<not> gds_is_break gds xf_; gen_rwof' x_; gen_rwof' \\<sigma>_;\n     gen_rwof' xb_; gen_rwof' b_; gen_rwof' \\<sigma>'_; gen_cond \\<sigma>'_;\n     gen_rwof' xf_; gen_rwof' xg_; stack x_ = []; pending x_ = {};\n     stack \\<sigma>_ = []; V0 - it_ \\<subseteq> gen_discovered \\<sigma>_;\n     stack xb_ = [xa_]; \\<not> gds_is_break gds b_;\n     stack \\<sigma>'_ = a_ # stk_;\n     pending xf_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} \\<union>\n     {xd_} \\<times> E `` {xd_};\n     pending xb_ = {xa_} \\<times> E `` {xa_};\n     gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n     E \\<inter> {a_} \\<times> UNIV \\<subseteq> pending b_;\n     pending \\<sigma>'_ = pending b_ - {a_} \\<times> (E `` {a_} - ita_);\n     stack xf_ = xd_ # a_ # stk_;\n     gen_discovered xf_ = insert xd_ (gen_discovered \\<sigma>'_);\n     gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_;\n     E `` {a_} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n     inres (choose_pending a_ (Some xd_) \\<sigma>'_) xe_;\n     stack xe_ = a_ # stk_;\n     \\<forall>x.\n        gds_is_discovered gds x xe_ = gds_is_discovered gds x \\<sigma>'_;\n     (a_, xd_) \\<in> pending b_;\n     pending xe_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)};\n     \\<not> gds_is_break gds xg_; stack xg_ = a_ # stk_;\n     pending xg_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} -\n     {xd_} \\<times> UNIV;\n     gds_is_discovered gds xd_ xg_;\n     gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered xg_;\n     stack b_ = a_ # stk_\\<rbrakk>\n    \\<Longrightarrow> pending b_ - {a_} \\<times> (E `` {a_} - ita_) -\n                      {(a_, xd_)} -\n                      {xd_} \\<times> UNIV =\n                      pending b_ -\n                      insert (a_, xd_) ({a_} \\<times> (E `` {a_} - ita_))", "apply (rule rec_impl_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail gen_dfs;\n     nofail (gds_init gds \\<bind> WHILE gen_cond gen_step'); xa_ \\<in> it_;\n     it_ \\<subseteq> V0; \\<not> gds_is_break gds \\<sigma>_;\n     \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n     \\<not> gds_is_break gds xb_;\n     \\<And>a b.\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b \\<Longrightarrow>\n        f_ (a, b)\n        \\<le> SPEC\n               (\\<lambda>s'.\n                   gen_rwof' s' \\<and>\n                   (\\<not> gds_is_break gds s' \\<longrightarrow>\n                    stack s' = tl (stack b) \\<and>\n                    pending s' = pending b - {a} \\<times> UNIV \\<and>\n                    gen_discovered b \\<subseteq> gen_discovered s'));\n     xc_ = (a_, b_); xd_ \\<in> ita_; ita_ \\<subseteq> E `` {a_};\n     \\<not> gds_is_break gds \\<sigma>'_;\n     \\<not> gds_is_discovered gds xd_ \\<sigma>'_;\n     \\<not> gds_is_break gds xf_; gen_rwof' x_; gen_rwof' \\<sigma>_;\n     gen_rwof' xb_; gen_rwof' b_; gen_rwof' \\<sigma>'_; gen_cond \\<sigma>'_;\n     gen_rwof' xf_; gen_rwof' xg_; stack x_ = []; pending x_ = {};\n     stack \\<sigma>_ = []; V0 - it_ \\<subseteq> gen_discovered \\<sigma>_;\n     stack xb_ = [xa_]; \\<not> gds_is_break gds b_;\n     stack \\<sigma>'_ = a_ # stk_;\n     pending xf_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} \\<union>\n     {xd_} \\<times> E `` {xd_};\n     pending xb_ = {xa_} \\<times> E `` {xa_};\n     gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n     E \\<inter> {a_} \\<times> UNIV \\<subseteq> pending b_;\n     pending \\<sigma>'_ = pending b_ - {a_} \\<times> (E `` {a_} - ita_);\n     stack xf_ = xd_ # a_ # stk_;\n     gen_discovered xf_ = insert xd_ (gen_discovered \\<sigma>'_);\n     gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_;\n     E `` {a_} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n     inres (choose_pending a_ (Some xd_) \\<sigma>'_) xe_;\n     stack xe_ = a_ # stk_;\n     \\<forall>x.\n        gds_is_discovered gds x xe_ = gds_is_discovered gds x \\<sigma>'_;\n     (a_, xd_) \\<in> pending b_;\n     pending xe_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)};\n     \\<not> gds_is_break gds xg_; stack xg_ = a_ # stk_;\n     pending xg_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} -\n     {xd_} \\<times> UNIV;\n     gds_is_discovered gds xd_ xg_;\n     gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered xg_;\n     stack b_ = a_ # stk_\\<rbrakk>\n    \\<Longrightarrow> xd_ \\<notin> Domain (pending b_)", "apply (drule reachable_invar)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail gen_dfs;\n     nofail (gds_init gds \\<bind> WHILE gen_cond gen_step'); xa_ \\<in> it_;\n     it_ \\<subseteq> V0; \\<not> gds_is_break gds \\<sigma>_;\n     \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n     \\<not> gds_is_break gds xb_;\n     \\<And>a b.\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b \\<Longrightarrow>\n        f_ (a, b)\n        \\<le> SPEC\n               (\\<lambda>s'.\n                   gen_rwof' s' \\<and>\n                   (\\<not> gds_is_break gds s' \\<longrightarrow>\n                    stack s' = tl (stack b) \\<and>\n                    pending s' = pending b - {a} \\<times> UNIV \\<and>\n                    gen_discovered b \\<subseteq> gen_discovered s'));\n     xc_ = (a_, b_); xd_ \\<in> ita_; ita_ \\<subseteq> E `` {a_};\n     \\<not> gds_is_break gds \\<sigma>'_;\n     \\<not> gds_is_discovered gds xd_ \\<sigma>'_;\n     \\<not> gds_is_break gds xf_; gen_cond \\<sigma>'_; stack x_ = [];\n     pending x_ = {}; stack \\<sigma>_ = [];\n     V0 - it_ \\<subseteq> gen_discovered \\<sigma>_; stack xb_ = [xa_];\n     \\<not> gds_is_break gds b_; stack \\<sigma>'_ = a_ # stk_;\n     pending xf_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} \\<union>\n     {xd_} \\<times> E `` {xd_};\n     pending xb_ = {xa_} \\<times> E `` {xa_};\n     gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n     E \\<inter> {a_} \\<times> UNIV \\<subseteq> pending b_;\n     pending \\<sigma>'_ = pending b_ - {a_} \\<times> (E `` {a_} - ita_);\n     stack xf_ = xd_ # a_ # stk_;\n     gen_discovered xf_ = insert xd_ (gen_discovered \\<sigma>'_);\n     gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_;\n     E `` {a_} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n     inres (choose_pending a_ (Some xd_) \\<sigma>'_) xe_;\n     stack xe_ = a_ # stk_;\n     \\<forall>x.\n        gds_is_discovered gds x xe_ = gds_is_discovered gds x \\<sigma>'_;\n     (a_, xd_) \\<in> pending b_;\n     pending xe_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)};\n     \\<not> gds_is_break gds xg_; stack xg_ = a_ # stk_;\n     pending xg_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} -\n     {xd_} \\<times> UNIV;\n     gds_is_discovered gds xd_ xg_;\n     gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered xg_;\n     stack b_ = a_ # stk_;\n     set (stack x_) \\<subseteq> reachable \\<and>\n     pending x_ \\<subseteq> E \\<and>\n     set (stack x_) \\<subseteq> gen_discovered x_ \\<and>\n     distinct (stack x_) \\<and>\n     pending x_ \\<subseteq> set (stack x_) \\<times> UNIV;\n     set (stack \\<sigma>_) \\<subseteq> reachable \\<and>\n     pending \\<sigma>_ \\<subseteq> E \\<and>\n     set (stack \\<sigma>_) \\<subseteq> gen_discovered \\<sigma>_ \\<and>\n     distinct (stack \\<sigma>_) \\<and>\n     pending \\<sigma>_ \\<subseteq> set (stack \\<sigma>_) \\<times> UNIV;\n     set (stack xb_) \\<subseteq> reachable \\<and>\n     pending xb_ \\<subseteq> E \\<and>\n     set (stack xb_) \\<subseteq> gen_discovered xb_ \\<and>\n     distinct (stack xb_) \\<and>\n     pending xb_ \\<subseteq> set (stack xb_) \\<times> UNIV;\n     set (stack b_) \\<subseteq> reachable \\<and>\n     pending b_ \\<subseteq> E \\<and>\n     set (stack b_) \\<subseteq> gen_discovered b_ \\<and>\n     distinct (stack b_) \\<and>\n     pending b_ \\<subseteq> set (stack b_) \\<times> UNIV;\n     set (stack \\<sigma>'_) \\<subseteq> reachable \\<and>\n     pending \\<sigma>'_ \\<subseteq> E \\<and>\n     set (stack \\<sigma>'_) \\<subseteq> gen_discovered \\<sigma>'_ \\<and>\n     distinct (stack \\<sigma>'_) \\<and>\n     pending \\<sigma>'_ \\<subseteq> set (stack \\<sigma>'_) \\<times> UNIV;\n     set (stack xf_) \\<subseteq> reachable \\<and>\n     pending xf_ \\<subseteq> E \\<and>\n     set (stack xf_) \\<subseteq> gen_discovered xf_ \\<and>\n     distinct (stack xf_) \\<and>\n     pending xf_ \\<subseteq> set (stack xf_) \\<times> UNIV;\n     set (stack xg_) \\<subseteq> reachable \\<and>\n     pending xg_ \\<subseteq> E \\<and>\n     set (stack xg_) \\<subseteq> gen_discovered xg_ \\<and>\n     distinct (stack xg_) \\<and>\n     pending xg_ \\<subseteq> set (stack xg_) \\<times> UNIV\\<rbrakk>\n    \\<Longrightarrow> xd_ \\<notin> Domain (pending b_)", "apply (metis Domain.cases SigmaD1 mem_Collect_eq rev_subsetD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xg stk.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        xa_ \\<in> it_; it_ \\<subseteq> V0;\n        \\<not> gds_is_break gds \\<sigma>_;\n        \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n        \\<not> gds_is_break gds xb_;\n        \\<And>a b.\n           gen_rwof' b \\<and>\n           \\<not> gds_is_break gds b \\<and>\n           (\\<exists>stk. stack b = a # stk) \\<and>\n           E \\<inter> {a} \\<times> UNIV\n           \\<subseteq> pending b \\<Longrightarrow>\n           f_ (a, b)\n           \\<le> SPEC\n                  (\\<lambda>s'.\n                      gen_rwof' s' \\<and>\n                      (\\<not> gds_is_break gds s' \\<longrightarrow>\n                       stack s' = tl (stack b) \\<and>\n                       pending s' = pending b - {a} \\<times> UNIV \\<and>\n                       gen_discovered b \\<subseteq> gen_discovered s'));\n        xc_ = (a_, b_); xd_ \\<in> ita_; ita_ \\<subseteq> E `` {a_};\n        \\<not> gds_is_break gds \\<sigma>'_;\n        \\<not> gds_is_discovered gds xd_ \\<sigma>'_;\n        \\<not> gds_is_break gds xf_; gen_rwof' x_; gen_rwof' \\<sigma>_;\n        gen_rwof' xb_; gen_rwof' b_; gen_rwof' \\<sigma>'_;\n        gen_cond \\<sigma>'_; gen_rwof' xf_; gen_rwof' xg; stack x_ = [];\n        pending x_ = {}; stack \\<sigma>_ = [];\n        V0 - it_ \\<subseteq> gen_discovered \\<sigma>_; stack xb_ = [xa_];\n        \\<not> gds_is_break gds b_; stack \\<sigma>'_ = a_ # stk;\n        pending xf_ =\n        pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} \\<union>\n        {xd_} \\<times> E `` {xd_};\n        pending xb_ = {xa_} \\<times> E `` {xa_};\n        gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n        E \\<inter> {a_} \\<times> UNIV \\<subseteq> pending b_;\n        pending \\<sigma>'_ = pending b_ - {a_} \\<times> (E `` {a_} - ita_);\n        stack xf_ = xd_ # a_ # stk;\n        gen_discovered xf_ = insert xd_ (gen_discovered \\<sigma>'_);\n        gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_;\n        E `` {a_} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n        inres (choose_pending a_ (Some xd_) \\<sigma>'_) xe_;\n        stack xe_ = a_ # stk;\n        \\<forall>x.\n           gds_is_discovered gds x xe_ = gds_is_discovered gds x \\<sigma>'_;\n        (a_, xd_) \\<in> pending b_;\n        pending xe_ =\n        pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)};\n        \\<not> gds_is_break gds xg; stack xg = a_ # stk;\n        pending xg =\n        pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} -\n        {xd_} \\<times> UNIV;\n        gds_is_discovered gds xd_ xg;\n        gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered xg;\n        stack b_ = a_ # stk\\<rbrakk>\n       \\<Longrightarrow> gen_discovered b_\n                         \\<subseteq> gen_discovered xg \\<and>\n                         E `` {a_} - ita_ \\<subseteq> gen_discovered xg", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail gen_dfs;\n     nofail (gds_init gds \\<bind> WHILE gen_cond gen_step'); xa_ \\<in> it_;\n     it_ \\<subseteq> V0; \\<not> gds_is_break gds \\<sigma>_;\n     \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n     \\<not> gds_is_break gds xb_;\n     \\<And>a b.\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b \\<Longrightarrow>\n        f_ (a, b)\n        \\<le> SPEC\n               (\\<lambda>s'.\n                   gen_rwof' s' \\<and>\n                   (\\<not> gds_is_break gds s' \\<longrightarrow>\n                    stack s' = tl (stack b) \\<and>\n                    pending s' = pending b - {a} \\<times> UNIV \\<and>\n                    gen_discovered b \\<subseteq> gen_discovered s'));\n     xc_ = (a_, b_); xd_ \\<in> ita_; ita_ \\<subseteq> E `` {a_};\n     \\<not> gds_is_break gds \\<sigma>'_;\n     \\<not> gds_is_discovered gds xd_ \\<sigma>'_;\n     \\<not> gds_is_break gds xf_; gen_rwof' x_; gen_rwof' \\<sigma>_;\n     gen_rwof' xb_; gen_rwof' b_; gen_rwof' \\<sigma>'_; gen_cond \\<sigma>'_;\n     gen_rwof' xf_; gen_rwof' xg_; stack x_ = []; pending x_ = {};\n     stack \\<sigma>_ = []; V0 - it_ \\<subseteq> gen_discovered \\<sigma>_;\n     stack xb_ = [xa_]; \\<not> gds_is_break gds b_;\n     stack \\<sigma>'_ = a_ # stk_;\n     pending xf_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} \\<union>\n     {xd_} \\<times> E `` {xd_};\n     pending xb_ = {xa_} \\<times> E `` {xa_};\n     gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n     E \\<inter> {a_} \\<times> UNIV \\<subseteq> pending b_;\n     pending \\<sigma>'_ = pending b_ - {a_} \\<times> (E `` {a_} - ita_);\n     stack xf_ = xd_ # a_ # stk_;\n     gen_discovered xf_ = insert xd_ (gen_discovered \\<sigma>'_);\n     gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_;\n     E `` {a_} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n     inres (choose_pending a_ (Some xd_) \\<sigma>'_) xe_;\n     stack xe_ = a_ # stk_;\n     \\<forall>x.\n        gds_is_discovered gds x xe_ = gds_is_discovered gds x \\<sigma>'_;\n     (a_, xd_) \\<in> pending b_;\n     pending xe_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)};\n     \\<not> gds_is_break gds xg_; stack xg_ = a_ # stk_;\n     pending xg_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} -\n     {xd_} \\<times> UNIV;\n     gds_is_discovered gds xd_ xg_;\n     gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered xg_;\n     stack b_ = a_ # stk_\\<rbrakk>\n    \\<Longrightarrow> gen_discovered b_\n                      \\<subseteq> gen_discovered xg_ \\<and>\n                      E `` {a_} - ita_ \\<subseteq> gen_discovered xg_", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nofail gen_dfs;\n     nofail (gds_init gds \\<bind> WHILE gen_cond gen_step'); xa_ \\<in> it_;\n     it_ \\<subseteq> V0; \\<not> gds_is_break gds \\<sigma>_;\n     \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n     \\<not> gds_is_break gds xb_;\n     \\<And>a b.\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b \\<Longrightarrow>\n        f_ (a, b)\n        \\<le> SPEC\n               (\\<lambda>s'.\n                   gen_rwof' s' \\<and>\n                   (\\<not> gds_is_break gds s' \\<longrightarrow>\n                    stack s' = tl (stack b) \\<and>\n                    pending s' = pending b - {a} \\<times> UNIV \\<and>\n                    gen_discovered b \\<subseteq> gen_discovered s'));\n     xc_ = (a_, b_); xd_ \\<in> ita_; ita_ \\<subseteq> E `` {a_};\n     \\<not> gds_is_break gds \\<sigma>'_;\n     \\<not> gds_is_discovered gds xd_ \\<sigma>'_;\n     \\<not> gds_is_break gds xf_; gen_rwof' x_; gen_rwof' \\<sigma>_;\n     gen_rwof' xb_; gen_rwof' b_; gen_rwof' \\<sigma>'_; gen_cond \\<sigma>'_;\n     gen_rwof' xf_; gen_rwof' xg_; stack x_ = []; pending x_ = {};\n     stack \\<sigma>_ = []; V0 - it_ \\<subseteq> gen_discovered \\<sigma>_;\n     stack xb_ = [xa_]; \\<not> gds_is_break gds b_;\n     stack \\<sigma>'_ = a_ # stk_;\n     pending xf_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} \\<union>\n     {xd_} \\<times> E `` {xd_};\n     pending xb_ = {xa_} \\<times> E `` {xa_};\n     gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n     E \\<inter> {a_} \\<times> UNIV \\<subseteq> pending b_;\n     pending \\<sigma>'_ = pending b_ - {a_} \\<times> (E `` {a_} - ita_);\n     stack xf_ = xd_ # a_ # stk_;\n     gen_discovered xf_ = insert xd_ (gen_discovered \\<sigma>'_);\n     gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_;\n     E `` {a_} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n     inres (choose_pending a_ (Some xd_) \\<sigma>'_) xe_;\n     stack xe_ = a_ # stk_;\n     \\<forall>x.\n        gds_is_discovered gds x xe_ = gds_is_discovered gds x \\<sigma>'_;\n     (a_, xd_) \\<in> pending b_;\n     pending xe_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)};\n     \\<not> gds_is_break gds xg_; stack xg_ = a_ # stk_;\n     pending xg_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} -\n     {xd_} \\<times> UNIV;\n     gds_is_discovered gds xd_ xg_;\n     gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered xg_;\n     stack b_ = a_ # stk_\\<rbrakk>\n    \\<Longrightarrow> gen_discovered b_ \\<subseteq> gen_discovered xg_\nA total of 2 subgoals...", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail gen_dfs;\n     nofail (gds_init gds \\<bind> WHILE gen_cond gen_step'); xa_ \\<in> it_;\n     it_ \\<subseteq> V0; \\<not> gds_is_break gds \\<sigma>_;\n     \\<not> gds_is_discovered gds xa_ \\<sigma>_;\n     \\<not> gds_is_break gds xb_;\n     \\<And>a b.\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b \\<Longrightarrow>\n        f_ (a, b)\n        \\<le> SPEC\n               (\\<lambda>s'.\n                   gen_rwof' s' \\<and>\n                   (\\<not> gds_is_break gds s' \\<longrightarrow>\n                    stack s' = tl (stack b) \\<and>\n                    pending s' = pending b - {a} \\<times> UNIV \\<and>\n                    gen_discovered b \\<subseteq> gen_discovered s'));\n     xc_ = (a_, b_); xd_ \\<in> ita_; ita_ \\<subseteq> E `` {a_};\n     \\<not> gds_is_break gds \\<sigma>'_;\n     \\<not> gds_is_discovered gds xd_ \\<sigma>'_;\n     \\<not> gds_is_break gds xf_; gen_rwof' x_; gen_rwof' \\<sigma>_;\n     gen_rwof' xb_; gen_rwof' b_; gen_rwof' \\<sigma>'_; gen_cond \\<sigma>'_;\n     gen_rwof' xf_; gen_rwof' xg_; stack x_ = []; pending x_ = {};\n     stack \\<sigma>_ = []; V0 - it_ \\<subseteq> gen_discovered \\<sigma>_;\n     stack xb_ = [xa_]; \\<not> gds_is_break gds b_;\n     stack \\<sigma>'_ = a_ # stk_;\n     pending xf_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} \\<union>\n     {xd_} \\<times> E `` {xd_};\n     pending xb_ = {xa_} \\<times> E `` {xa_};\n     gen_discovered xb_ = insert xa_ (gen_discovered \\<sigma>_);\n     E \\<inter> {a_} \\<times> UNIV \\<subseteq> pending b_;\n     pending \\<sigma>'_ = pending b_ - {a_} \\<times> (E `` {a_} - ita_);\n     stack xf_ = xd_ # a_ # stk_;\n     gen_discovered xf_ = insert xd_ (gen_discovered \\<sigma>'_);\n     gen_discovered b_ \\<subseteq> gen_discovered \\<sigma>'_;\n     E `` {a_} - ita_ \\<subseteq> gen_discovered \\<sigma>'_;\n     inres (choose_pending a_ (Some xd_) \\<sigma>'_) xe_;\n     stack xe_ = a_ # stk_;\n     \\<forall>x.\n        gds_is_discovered gds x xe_ = gds_is_discovered gds x \\<sigma>'_;\n     (a_, xd_) \\<in> pending b_;\n     pending xe_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)};\n     \\<not> gds_is_break gds xg_; stack xg_ = a_ # stk_;\n     pending xg_ =\n     pending b_ - {a_} \\<times> (E `` {a_} - ita_) - {(a_, xd_)} -\n     {xd_} \\<times> UNIV;\n     gds_is_discovered gds xd_ xg_;\n     gen_discovered \\<sigma>'_ \\<subseteq> gen_discovered xg_;\n     stack b_ = a_ # stk_\\<rbrakk>\n    \\<Longrightarrow> E `` {a_} - ita_ \\<subseteq> gen_discovered xg_", "apply (metis order_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b \\<sigma>'.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b);\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> E `` {a} \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> pre_get_pending \\<sigma>'\nA total of 10 subgoals...", "apply (auto simp add: pre_defs gen_rwof'_imp_rwof; fail)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b \\<sigma>'.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b);\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> E `` {a} \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> a = hd (stack b)\nA total of 9 subgoals...", "apply (auto; fail)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b \\<sigma>'.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b);\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> E `` {a} \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (pending b - {a} \\<times> E `` {a}) `` {a} = {}\nA total of 8 subgoals...", "apply (auto dest: reachable_invar; fail)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b \\<sigma>' xd.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        xc = (a, b);\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> E `` {a} \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a None \\<sigma>' xd\\<rbrakk>\n       \\<Longrightarrow> pre_finish a \\<sigma>' xd\nA total of 7 subgoals...", "apply ((drule pcp_imp_pgp, auto simp add: pre_defs gen_rwof'_imp_rwof); fail)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b \\<sigma>' xd xe x1.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        x1 = a;\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> E `` {a} \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a None \\<sigma>' xd;\n        gen_rwof' xe \\<and>\n        pending xe = pending xd \\<and>\n        stack xe = tl (stack xd) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xe = gds_is_discovered gds x xd);\n        xc = (a, b); \\<not> gds_is_break gds xe\\<rbrakk>\n       \\<Longrightarrow> tl (stack xd) = tl (stack b)\nA total of 6 subgoals...", "apply (auto simp: post_choose_pending_def; fail)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b \\<sigma>' xd xe x1.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        x1 = a;\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> E `` {a} \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a None \\<sigma>' xd;\n        gen_rwof' xe \\<and>\n        pending xe = pending xd \\<and>\n        stack xe = tl (stack xd) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xe = gds_is_discovered gds x xd);\n        xc = (a, b); \\<not> gds_is_break gds xe\\<rbrakk>\n       \\<Longrightarrow> pending xd = pending b - {a} \\<times> UNIV\nA total of 5 subgoals...", "apply (auto simp: post_choose_pending_def; fail)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa it \\<sigma> xb f xc a b \\<sigma>' xd xe x1.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        \\<And>x.\n           case x of\n           (u, s) \\<Rightarrow>\n             gen_rwof' s \\<and>\n             \\<not> gds_is_break gds s \\<and>\n             (\\<exists>stk. stack s = u # stk) \\<and>\n             E \\<inter> {u} \\<times> UNIV\n             \\<subseteq> pending s \\<Longrightarrow>\n           f x\n           \\<le> SPEC\n                  (case x of\n                   (u, s) \\<Rightarrow>\n                     \\<lambda>s'.\n                        gen_rwof' s' \\<and>\n                        (\\<not> gds_is_break gds s' \\<longrightarrow>\n                         stack s' = tl (stack s) \\<and>\n                         pending s' = pending s - {u} \\<times> UNIV \\<and>\n                         gen_discovered s \\<subseteq> gen_discovered s'));\n        gen_rwof' b \\<and>\n        \\<not> gds_is_break gds b \\<and>\n        (\\<exists>stk. stack b = a # stk) \\<and>\n        E \\<inter> {a} \\<times> UNIV \\<subseteq> pending b;\n        x1 = a;\n        gen_rwof' \\<sigma>' \\<and>\n        stack \\<sigma>' = stack b \\<and>\n        pending \\<sigma>' = pending b - {a} \\<times> E `` {a} \\<and>\n        gen_discovered b \\<subseteq> gen_discovered \\<sigma>' \\<and>\n        E `` {a} \\<subseteq> gen_discovered \\<sigma>';\n        \\<not> gds_is_break gds \\<sigma>';\n        post_choose_pending a None \\<sigma>' xd;\n        gen_rwof' xe \\<and>\n        pending xe = pending xd \\<and>\n        stack xe = tl (stack xd) \\<and>\n        (\\<forall>x.\n            gds_is_discovered gds x xe = gds_is_discovered gds x xd);\n        xc = (a, b); \\<not> gds_is_break gds xe\\<rbrakk>\n       \\<Longrightarrow> gen_discovered b \\<subseteq> gen_discovered xd\nA total of 4 subgoals...", "apply (auto simp: post_choose_pending_def; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa it \\<sigma> xb r.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {}; xa \\<in> it;\n        it \\<subseteq> V0;\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and>\n        V0 - it \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>;\n        \\<not> gds_is_discovered gds xa \\<sigma>;\n        gen_rwof' xb \\<and>\n        stack xb = [xa] \\<and>\n        pending xb = {xa} \\<times> E `` {xa} \\<and>\n        gen_discovered xb = insert xa (gen_discovered \\<sigma>);\n        \\<not> gds_is_break gds xb;\n        gen_rwof' r \\<and>\n        stack r = [] \\<and>\n        pending r = {} \\<and>\n        gds_is_discovered gds xa r \\<and>\n        gen_discovered \\<sigma> \\<subseteq> gen_discovered r;\n        \\<not> gds_is_break gds r\\<rbrakk>\n       \\<Longrightarrow> V0 - (it - {xa}) \\<subseteq> gen_discovered r\nA total of 3 subgoals...", "apply (auto; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {};\n        gen_rwof' \\<sigma> \\<and>\n        stack \\<sigma> = [] \\<and> V0 \\<subseteq> gen_discovered \\<sigma>;\n        \\<not> gds_is_break gds \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> gen_cond \\<sigma>\nA total of 2 subgoals...", "apply (auto simp: gen_cond_def; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>nofail gen_dfs;\n        nofail (gds_init gds \\<bind> WHILE gen_cond gen_step');\n        gen_rwof' x \\<and> stack x = [] \\<and> pending x = {};\n        it \\<subseteq> V0; gen_rwof' \\<sigma>;\n        gds_is_break gds \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> gen_cond \\<sigma>", "apply (auto simp: gen_cond_def; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}