{"file_name": "/home/qj213/afp-2021-10-22/thys/DFS_Framework/Examples/Feedback_Arcs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DFS_Framework", "problem_names": ["lemma is_fas_alt:\n  \"is_fas G EC = acyclic ((g_E G \\<inter> ((g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV) - EC))\"", "lemma fas_more_cong: \"state.more s = state.more s' \\<Longrightarrow> fas s = fas s'\"", "lemma [simp]: \"s\\<lparr> state.more := \\<lparr> fas = foo \\<rparr> \\<rparr> = s \\<lparr> fas := foo \\<rparr>\"", "lemmas fas_params_simp[simp] = \n  gen_parameterization.simps[mk_record_simp, OF fas_params_def[simplified]]", "lemma fasI:\n  assumes \"graph G\"\n  assumes \"finite ((g_E G)\\<^sup>* `` g_V0 G)\"\n  shows \"fas G\"", "lemma (in fas) i_fas_eq_back: \"is_invar (\\<lambda>s. fas_state.fas s = back_edges s)\"", "lemmas fas_eq_back = i_fas_eq_back[THEN make_invar_thm]", "lemma find_fas_correct_aux:\n    assumes NC: \"\\<not>cond s\"\n    shows \"is_fas G (fas_state.fas s)\"", "lemma find_fas_correct:\n  assumes \"graph G\"\n  assumes \"finite ((g_E G)\\<^sup>* `` g_V0 G)\"\n  shows \"find_fas G \\<le> SPEC (is_fas G)\"", "lemmas fas_params_impl_simp[simp,DFS_code_unfold] = \n  gen_parameterization.simps[mk_record_simp, OF fas_params_impl_def[simplified]]", "lemma fas_impl: \"(si,s)\\<in>fas_rel \n  \\<Longrightarrow> fas_state_impl.fas si = fas_state.fas s\"", "lemmas impl_refine = simple_tailrec_refine simple_tailrecT_refine simple_rec_refine", "lemma find_fas_impl_refine: \"find_fas_impl G \\<le> \\<Down>Id (find_fas G)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of fas_state_erel i_fas_state_ext]", "lemma [autoref_rules]:\n  fixes ns_rel vis_rel frel erel\n  defines \"R \\<equiv> \\<langle>ns_rel,vis_rel,\\<langle>frel,erel\\<rangle>fas_state_erel\\<rangle>ss_impl_rel\"\n  shows \n    \"(fas_state_impl'_ext, fas_state_impl_ext) \\<in> frel \\<rightarrow> erel \\<rightarrow> \\<langle>frel,erel\\<rangle>fas_state_erel\"\n    \"(fas_impl, fas_state_impl.fas) \\<in> R \\<rightarrow> frel\"\n    \"(fas_state_impl'.fas_impl_update, fas_update) \\<in> (frel \\<rightarrow> frel) \\<rightarrow> R \\<rightarrow> R\"", "lemma find_fas_code_refine[refine]:\n  fixes V :: \"('vi\\<times>'v) set\"\n  assumes \"is_bounded_hashcode V eq bhc\"\n  assumes \"(eq,(=)) \\<in> V \\<rightarrow> V \\<rightarrow> bool_rel\"\n  assumes \"is_valid_def_hm_size TYPE ('vi) sz\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  shows \"RETURN (find_fas_code eq bhc sz Gi) \\<le> \\<Down>(\\<langle>V\\<times>\\<^sub>rV\\<rangle>ahs_rel (prod_bhc bhc bhc)) (find_fas G)\"", "theorem find_fas_code_autoref[autoref_rules]:\n  fixes V :: \"('vi\\<times>'v) set\" and bhc\n  defines \"RR \\<equiv> \\<langle>\\<langle>V\\<times>\\<^sub>rV\\<rangle>ahs_rel (prod_bhc bhc bhc)\\<rangle>nres_rel\"\n  assumes BHC: \"SIDE_GEN_ALGO (is_bounded_hashcode V eq bhc)\"\n  assumes EQ: \"GEN_OP eq (=) (V \\<rightarrow> V \\<rightarrow> bool_rel)\"\n  assumes VDS: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE ('vi) sz)\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  shows \"(RETURN (find_fas_code eq bhc sz Gi),\n    (OP find_fas \n      ::: \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> RR)$G)\\<in>RR\"", "lemma is_fas_join: \"is_fas G (F1 \\<union> F2) \\<longleftrightarrow>\n  is_fas \\<lparr> g_V = g_V G, g_E = g_E G - F2, g_V0 = (g_E G)\\<^sup>* `` g_V0 G \\<rparr> F1\"", "lemma graphI_init:\n  assumes \"graph G\"\n  shows \"graph \\<lparr> g_V = g_V G, g_E = g_E G - FI, g_V0 = (g_E G)\\<^sup>* `` g_V0 G \\<rparr>\"", "lemma find_fas_init_correct:\n  assumes [simp, intro!]: \"graph G\"\n  assumes [simp, intro!]: \"finite ((g_E G)\\<^sup>* `` g_V0 G)\"\n  shows \"find_fas_init G FI \\<le> SPEC (\\<lambda>fas. is_fas G fas \\<and> FI \\<subseteq> fas)\"", "lemma gen_cast_set[autoref_rules_raw]:\n  assumes PRIO_TAG_GEN_ALGO\n  assumes INS: \"GEN_OP ins Set.insert (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs2\\<rightarrow>\\<langle>Rk\\<rangle>Rs2)\"\n  assumes EM: \"GEN_OP emp {} (\\<langle>Rk\\<rangle>Rs2)\"\n  assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 tsl)\"\n  shows \"(\\<lambda>s. gen_union (\\<lambda>x. foldli (tsl x)) ins s emp,CAST) \n    \\<in> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2)\"", "lemma gen_cast_fun_set_rel[autoref_rules_raw]:\n  assumes INS: \"GEN_OP mem (\\<in>) (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs\\<rightarrow>bool_rel)\"\n  shows \"(\\<lambda>s x. mem x s,CAST) \\<in> (\\<langle>Rk\\<rangle>Rs) \\<rightarrow> (\\<langle>Rk\\<rangle>fun_set_rel)\"", "lemma find_fas_init_impl_aux_unfolds: \n  \"Let (E\\<^sup>*``V0) = Let (CAST (E\\<^sup>*``V0))\" \n  \"(\\<lambda>S. RETURN (FI \\<union> S)) = (\\<lambda>S. RETURN (FI \\<union> CAST S))\"", "theorem find_fas_init_code_autoref[autoref_rules]:\n  fixes V :: \"('vi\\<times>'v) set\" and bhc\n  defines \"RR \\<equiv> \\<langle>V\\<times>\\<^sub>rV\\<rangle>fun_set_rel\"\n  assumes \"SIDE_GEN_ALGO (is_bounded_hashcode V eq bhc)\"\n  assumes \"GEN_OP eq (=) (V \\<rightarrow> V \\<rightarrow> bool_rel)\"\n  assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE ('vi) sz)\"\n  shows \"(\\<lambda>Gi FIi. RETURN (find_fas_init_code eq bhc sz Gi FIi),find_fas_init) \n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> RR \\<rightarrow> \\<langle>RR\\<rangle>nres_rel\""], "translations": [["", "lemma is_fas_alt:\n  \"is_fas G EC = acyclic ((g_E G \\<inter> ((g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV) - EC))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fas G EC =\n    acyclic (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV - EC)", "unfolding is_fas_def acyclic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<exists>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n                (u, u) \\<in> (g_E G - EC)\\<^sup>+)) =\n    (\\<forall>x.\n        (x, x)\n        \\<notin> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                  EC)\\<^sup>+)", "proof (clarsimp, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n                   (u, u) \\<notin> (g_E G - EC)\\<^sup>+;\n        (x, x)\n        \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n               EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n                   (u, u) \\<notin> (g_E G - EC)\\<^sup>+;\n        (x, x)\n        \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n               EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "assume A: \"(u,u) \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV - EC)\\<^sup>+\""], ["proof (state)\nthis:\n  (u, u)\n  \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n         EC)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n                   (u, u) \\<notin> (g_E G - EC)\\<^sup>+;\n        (x, x)\n        \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n               EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(u,u)\\<in>(g_E G - EC)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (u, u)\n  \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n         EC)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (u, u) \\<in> (g_E G - EC)\\<^sup>+", "by (rule trancl_mono) blast"], ["proof (state)\nthis:\n  (u, u) \\<in> (g_E G - EC)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n                   (u, u) \\<notin> (g_E G - EC)\\<^sup>+;\n        (x, x)\n        \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n               EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (u, u) \\<in> (g_E G - EC)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n                   (u, u) \\<notin> (g_E G - EC)\\<^sup>+;\n        (x, x)\n        \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n               EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "from A"], ["proof (chain)\npicking this:\n  (u, u)\n  \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n         EC)\\<^sup>+", "have \"u \\<in> (g_E G)\\<^sup>* `` g_V0 G\""], ["proof (prove)\nusing this:\n  (u, u)\n  \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n         EC)\\<^sup>+\n\ngoal (1 subgoal):\n 1. u \\<in> (g_E G)\\<^sup>* `` g_V0 G", "by (cases rule: converse_tranclE) auto"], ["proof (state)\nthis:\n  u \\<in> (g_E G)\\<^sup>* `` g_V0 G\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n                   (u, u) \\<notin> (g_E G - EC)\\<^sup>+;\n        (x, x)\n        \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n               EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  u \\<in> (g_E G)\\<^sup>* `` g_V0 G\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n                   (u, u) \\<notin> (g_E G - EC)\\<^sup>+;\n        (x, x)\n        \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n               EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G. (u, u) \\<notin> (g_E G - EC)\\<^sup>+\""], ["proof (state)\nthis:\n  \\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n     (u, u) \\<notin> (g_E G - EC)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n                   (u, u) \\<notin> (g_E G - EC)\\<^sup>+;\n        (x, x)\n        \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n               EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (u, u) \\<in> (g_E G - EC)\\<^sup>+\n  u \\<in> (g_E G)\\<^sup>* `` g_V0 G\n  \\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n     (u, u) \\<notin> (g_E G - EC)\\<^sup>+", "show False"], ["proof (prove)\nusing this:\n  (u, u) \\<in> (g_E G - EC)\\<^sup>+\n  u \\<in> (g_E G)\\<^sup>* `` g_V0 G\n  \\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n     (u, u) \\<notin> (g_E G - EC)\\<^sup>+\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "fix u v0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "assume 1: \"v0\\<in>g_V0 G\" and 2: \"(v0,u)\\<in>(g_E G)\\<^sup>*\" and 3: \"(u,u)\\<in>(g_E G - EC)\\<^sup>+\""], ["proof (state)\nthis:\n  v0 \\<in> g_V0 G\n  (v0, u) \\<in> (g_E G)\\<^sup>*\n  (u, u) \\<in> (g_E G - EC)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "have \"(u, u) \\<in> (Restr (g_E G - EC) ((g_E G)\\<^sup>* `` g_V0 G))\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, u) \\<in> (Restr (g_E G - EC) ((g_E G)\\<^sup>* `` g_V0 G))\\<^sup>+", "apply (rule trancl_restrict_reachable[OF 3, where S=\"(g_E G)\\<^sup>* `` g_V0 G\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (g_E G - EC) `` (g_E G)\\<^sup>* `` g_V0 G\n    \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G\n 2. u \\<in> (g_E G)\\<^sup>* `` g_V0 G", "apply (rule order_trans[OF _ rtrancl_image_unfold_right])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (g_E G - EC) `` (g_E G)\\<^sup>* `` g_V0 G\n    \\<subseteq> g_E G `` (g_E G)\\<^sup>* `` g_V0 G\n 2. u \\<in> (g_E G)\\<^sup>* `` g_V0 G", "using 1 2"], ["proof (prove)\nusing this:\n  v0 \\<in> g_V0 G\n  (v0, u) \\<in> (g_E G)\\<^sup>*\n\ngoal (2 subgoals):\n 1. (g_E G - EC) `` (g_E G)\\<^sup>* `` g_V0 G\n    \\<subseteq> g_E G `` (g_E G)\\<^sup>* `` g_V0 G\n 2. u \\<in> (g_E G)\\<^sup>* `` g_V0 G", "by auto"], ["proof (state)\nthis:\n  (u, u) \\<in> (Restr (g_E G - EC) ((g_E G)\\<^sup>* `` g_V0 G))\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(u, u) \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV - EC)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (u, u) \\<in> (Restr (g_E G - EC) ((g_E G)\\<^sup>* `` g_V0 G))\\<^sup>+\n\ngoal (1 subgoal):\n 1. (u, u)\n    \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n           EC)\\<^sup>+", "by (rule trancl_mono) auto"], ["proof (state)\nthis:\n  (u, u)\n  \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n         EC)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (u, u)\n  \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n         EC)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<forall>x. (x, x) \\<notin> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV - EC)\\<^sup>+\""], ["proof (state)\nthis:\n  \\<forall>x.\n     (x, x)\n     \\<notin> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n               EC)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>u x.\n       \\<lbrakk>\\<forall>x.\n                   (x, x)\n                   \\<notin> (g_E G \\<inter>\n                             (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n                             EC)\\<^sup>+;\n        (x, u) \\<in> (g_E G)\\<^sup>*; x \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - EC)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (u, u)\n  \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n         EC)\\<^sup>+\n  \\<forall>x.\n     (x, x)\n     \\<notin> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n               EC)\\<^sup>+", "show False"], ["proof (prove)\nusing this:\n  (u, u)\n  \\<in> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n         EC)\\<^sup>+\n  \\<forall>x.\n     (x, x)\n     \\<notin> (g_E G \\<inter> (g_E G)\\<^sup>* `` g_V0 G \\<times> UNIV -\n               EC)\\<^sup>+\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Instantiation of the DFS-Framework\\<close>"], ["", "record 'v fas_state = \"'v state\" +\n  fas :: \"('v\\<times>'v) set\""], ["", "(* Some utility lemmas for the simplifier, to handle idiosyncrasies of\n  the record package. *)"], ["", "lemma fas_more_cong: \"state.more s = state.more s' \\<Longrightarrow> fas s = fas s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state.more s = state.more s' \\<Longrightarrow> fas s = fas s'", "by (cases s, cases s', simp)"], ["", "lemma [simp]: \"s\\<lparr> state.more := \\<lparr> fas = foo \\<rparr> \\<rparr> = s \\<lparr> fas := foo \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<lparr>state.more := \\<lparr>fas = foo\\<rparr>\\<rparr> = s\n    \\<lparr>fas := foo\\<rparr>", "by (cases s) simp"], ["", "definition fas_params :: \"('v,('v,unit) fas_state_ext) parameterization\"\nwhere \"fas_params \\<equiv> dflt_parametrization state.more \n  (RETURN \\<lparr> fas = {} \\<rparr>) \\<lparr>\n    on_back_edge := \\<lambda>u v s. RETURN \\<lparr> fas = insert (u,v) (fas s) \\<rparr>\n  \\<rparr>\""], ["", "lemmas fas_params_simp[simp] = \n  gen_parameterization.simps[mk_record_simp, OF fas_params_def[simplified]]"], ["", "interpretation fas: param_DFS_defs where param=fas_params for G"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open> Find feedback arc set \\<close>"], ["", "definition \"find_fas G \\<equiv> do {\n  ASSERT (graph G);\n  ASSERT (finite ((g_E G)\\<^sup>* `` g_V0 G));\n  s \\<leftarrow> fas.it_dfsT TYPE('a) G;\n  RETURN (fas_state.fas s)\n}\""], ["", "locale fas =\n  param_DFS G fas_params\n  for G :: \"('v, 'more) graph_rec_scheme\" \n  +\n  assumes finite_reachable[simp, intro!]: \"finite ((g_E G)\\<^sup>* `` g_V0 G)\"\nbegin"], ["", "sublocale DFS G fas_params"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS G fas_params", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. nofail (on_init fas_params)\n 2. \\<And>v0 s.\n       pre_on_new_root v0 s \\<Longrightarrow>\n       nofail (on_new_root fas_params v0 s)\n 3. \\<And>u s.\n       pre_on_finish u s \\<Longrightarrow> nofail (on_finish fas_params u s)\n 4. \\<And>u v s.\n       pre_on_cross_edge u v s \\<Longrightarrow>\n       nofail (on_cross_edge fas_params u v s)\n 5. \\<And>u v s.\n       pre_on_back_edge u v s \\<Longrightarrow>\n       nofail (on_back_edge fas_params u v s)\n 6. \\<And>u v s.\n       pre_on_discover u v s \\<Longrightarrow>\n       nofail (on_discover fas_params u v s)", "apply (simp_all add: fas_params_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma fasI:\n  assumes \"graph G\"\n  assumes \"finite ((g_E G)\\<^sup>* `` g_V0 G)\"\n  shows \"fas G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Feedback_Arcs.fas G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Feedback_Arcs.fas G", "interpret graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. Feedback_Arcs.fas G", "interpret fb_graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fb_graph G", "by (rule fb_graphI_fr[OF assms(2)])"], ["proof (state)\ngoal (1 subgoal):\n 1. Feedback_Arcs.fas G", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Feedback_Arcs.fas G", "by unfold_locales fact"], ["proof (state)\nthis:\n  Feedback_Arcs.fas G\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Correctness Proof\\<close>"], ["", "locale fas_invar = DFS_invar where param = fas_params + fas\nbegin"], ["", "lemma (in fas) i_fas_eq_back: \"is_invar (\\<lambda>s. fas_state.fas s = back_edges s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar (\\<lambda>s. fas_state.fas s = back_edges s)", "apply (induct rule: establish_invarI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. on_init fas_params \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>x.\n         fas_state.fas (empty_state x) = back_edges (empty_state x))\n 2. \\<And>s s' v0.\n       \\<lbrakk>DFS_invar G fas_params s; fas_state.fas s = back_edges s;\n        cond s; \\<not> is_break fas_params s; stack s = []; v0 \\<in> V0;\n        v0 \\<notin> dom (discovered s); s' = new_root v0 s\\<rbrakk>\n       \\<Longrightarrow> on_new_root fas_params v0 s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G fas_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              fas_state.fas\n                               (s'\\<lparr>state.more := x\\<rparr>) =\n                              back_edges\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 3. \\<And>s s' u.\n       \\<lbrakk>DFS_invar G fas_params s; fas_state.fas s = back_edges s;\n        cond s; \\<not> is_break fas_params s; stack s \\<noteq> [];\n        u = hd (stack s); pending s `` {u} = {}; s' = finish u s\\<rbrakk>\n       \\<Longrightarrow> on_finish fas_params u s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G fas_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              fas_state.fas\n                               (s'\\<lparr>state.more := x\\<rparr>) =\n                              back_edges\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 4. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G fas_params s; fas_state.fas s = back_edges s;\n        cond s; \\<not> is_break fas_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<in> dom (finished s);\n        s' =\n        cross_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge fas_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G fas_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              fas_state.fas\n                               (s'\\<lparr>state.more := x\\<rparr>) =\n                              back_edges\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 5. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G fas_params s; fas_state.fas s = back_edges s;\n        cond s; \\<not> is_break fas_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<in> dom (discovered s); v \\<notin> dom (finished s);\n        s' =\n        back_edge u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_back_edge fas_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G fas_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              fas_state.fas\n                               (s'\\<lparr>state.more := x\\<rparr>) =\n                              back_edges\n                               (s'\\<lparr>state.more := x\\<rparr>))\n 6. \\<And>s s' u v.\n       \\<lbrakk>DFS_invar G fas_params s; fas_state.fas s = back_edges s;\n        cond s; \\<not> is_break fas_params s; stack s \\<noteq> [];\n        (u, v) \\<in> pending s; u = hd (stack s);\n        v \\<notin> dom (discovered s);\n        s' =\n        discover u v\n         (s\\<lparr>pending := pending s - {(u, v)}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> on_discover fas_params u v s' \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>x.\n                              DFS_invar G fas_params\n                               (s'\\<lparr>state.more :=\n      x\\<rparr>) \\<longrightarrow>\n                              fas_state.fas\n                               (s'\\<lparr>state.more := x\\<rparr>) =\n                              back_edges\n                               (s'\\<lparr>state.more := x\\<rparr>))", "apply (simp_all add: cond_def cong: fas_more_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fas_state.fas (empty_state \\<lparr>fas_state.fas = {}\\<rparr>) = {}", "apply (simp add: empty_state_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas fas_eq_back = i_fas_eq_back[THEN make_invar_thm]"], ["", "lemma find_fas_correct_aux:\n    assumes NC: \"\\<not>cond s\"\n    shows \"is_fas G (fas_state.fas s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fas G (fas_state.fas s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_fas G (fas_state.fas s)", "note [simp] = fas_eq_back"], ["proof (state)\nthis:\n  fas_state.fas s = back_edges s\n\ngoal (1 subgoal):\n 1. is_fas G (fas_state.fas s)", "from nc_edges_covered[OF NC] edges_disjoint"], ["proof (chain)\npicking this:\n  \\<not> is_break fas_params s \\<Longrightarrow>\n  E \\<inter> reachable \\<times> UNIV =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  back_edges s \\<inter> cross_edges s = {}\n  back_edges s \\<inter> tree_edges s = {}\n  cross_edges s \\<inter> tree_edges s = {}", "have \n      \"E \\<inter> reachable \\<times> UNIV - back_edges s = tree_edges s \\<union> cross_edges s\""], ["proof (prove)\nusing this:\n  \\<not> is_break fas_params s \\<Longrightarrow>\n  E \\<inter> reachable \\<times> UNIV =\n  tree_edges s \\<union> cross_edges s \\<union> back_edges s\n  back_edges s \\<inter> cross_edges s = {}\n  back_edges s \\<inter> tree_edges s = {}\n  cross_edges s \\<inter> tree_edges s = {}\n\ngoal (1 subgoal):\n 1. E \\<inter> reachable \\<times> UNIV - back_edges s =\n    tree_edges s \\<union> cross_edges s", "by auto"], ["proof (state)\nthis:\n  E \\<inter> reachable \\<times> UNIV - back_edges s =\n  tree_edges s \\<union> cross_edges s\n\ngoal (1 subgoal):\n 1. is_fas G (fas_state.fas s)", "with tree_cross_acyclic"], ["proof (chain)\npicking this:\n  acyclic (tree_edges s \\<union> cross_edges s)\n  E \\<inter> reachable \\<times> UNIV - back_edges s =\n  tree_edges s \\<union> cross_edges s", "show \"is_fas G (fas_state.fas s)\""], ["proof (prove)\nusing this:\n  acyclic (tree_edges s \\<union> cross_edges s)\n  E \\<inter> reachable \\<times> UNIV - back_edges s =\n  tree_edges s \\<union> cross_edges s\n\ngoal (1 subgoal):\n 1. is_fas G (fas_state.fas s)", "unfolding is_fas_alt"], ["proof (prove)\nusing this:\n  acyclic (tree_edges s \\<union> cross_edges s)\n  E \\<inter> reachable \\<times> UNIV - back_edges s =\n  tree_edges s \\<union> cross_edges s\n\ngoal (1 subgoal):\n 1. acyclic (E \\<inter> reachable \\<times> UNIV - fas_state.fas s)", "by simp"], ["proof (state)\nthis:\n  is_fas G (fas_state.fas s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma find_fas_correct:\n  assumes \"graph G\"\n  assumes \"finite ((g_E G)\\<^sup>* `` g_V0 G)\"\n  shows \"find_fas G \\<le> SPEC (is_fas G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_fas G \\<le> SPEC (is_fas G)", "unfolding find_fas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (graph G) \\<bind>\n    (\\<lambda>_.\n        ASSERT (finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n        (\\<lambda>_.\n            param_DFS_defs.it_dfsT G fas_params \\<bind>\n            (\\<lambda>s. RETURN (fas_state.fas s))))\n    \\<le> SPEC (is_fas G)", "proof (refine_vcg le_ASSERTI order_trans[OF DFS.it_dfsT_correct], clarsimp_all)"], ["proof (state)\ngoal (4 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> DFS G fas_params\n 4. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "interpret graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph G", "by fact"], ["proof (state)\ngoal (4 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> DFS G fas_params\n 4. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "assume \"finite ((g_E G)\\<^sup>* `` g_V0 G)\""], ["proof (state)\nthis:\n  finite ((g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (4 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> DFS G fas_params\n 4. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "then"], ["proof (chain)\npicking this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G)", "interpret fb_graph G"], ["proof (prove)\nusing this:\n  finite ((g_E G)\\<^sup>* `` g_V0 G)\n\ngoal (1 subgoal):\n 1. fb_graph G", "by (rule fb_graphI_fr)"], ["proof (state)\ngoal (4 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> DFS G fas_params\n 4. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "interpret fas"], ["proof (prove)\ngoal (1 subgoal):\n 1. Feedback_Arcs.fas G", "by unfold_locales fact"], ["proof (state)\ngoal (4 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> DFS G fas_params\n 4. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "show \"DFS G fas_params\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS G fas_params", "by unfold_locales"], ["proof (state)\nthis:\n  DFS G fas_params\n\ngoal (3 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "fix s"], ["proof (state)\ngoal (3 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "assume \"DFS_invar G fas_params s\""], ["proof (state)\nthis:\n  DFS_invar G fas_params s\n\ngoal (3 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "then"], ["proof (chain)\npicking this:\n  DFS_invar G fas_params s", "interpret DFS_invar G fas_params s"], ["proof (prove)\nusing this:\n  DFS_invar G fas_params s\n\ngoal (1 subgoal):\n 1. DFS_invar G fas_params s", "."], ["proof (state)\ngoal (3 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "interpret fas_invar G s"], ["proof (prove)\ngoal (1 subgoal):\n 1. fas_invar G s", "by unfold_locales fact"], ["proof (state)\ngoal (3 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "assume \"\\<not>fas.cond TYPE('b) G s\""], ["proof (state)\nthis:\n  \\<not> param_DFS_defs.cond G fas_params s\n\ngoal (3 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        DFS_invar G fas_params x;\n        \\<not> param_DFS_defs.cond G fas_params x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (fas_state.fas x)", "thus \"is_fas G (fas_state.fas s)\""], ["proof (prove)\nusing this:\n  \\<not> param_DFS_defs.cond G fas_params s\n\ngoal (1 subgoal):\n 1. is_fas G (fas_state.fas s)", "by (rule find_fas_correct_aux)"], ["proof (state)\nthis:\n  is_fas G (fas_state.fas s)\n\ngoal (2 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)", "qed (rule assms)+"], ["", "subsection \\<open>Implementation\\<close>"], ["", "(* Implementation with stack and sso_visited set *)"], ["", "record 'v fas_state_impl = \"'v simple_state\" +\n  fas :: \"('v\\<times>'v) set\""], ["", "(* Definition of refinement relation: The break-flag is refined by identity.*)"], ["", "definition \"fas_erel \\<equiv> { \n  (\\<lparr> fas_state_impl.fas = f \\<rparr>, \\<lparr> fas_state.fas = f\\<rparr>) | f. True }\""], ["", "abbreviation \"fas_rel \\<equiv> \\<langle>fas_erel\\<rangle>simple_state_rel\""], ["", "(* Implementation of the parameters *)"], ["", "definition fas_params_impl \n  :: \"('v,'v fas_state_impl,('v,unit) fas_state_impl_ext) gen_parameterization\"\nwhere \"fas_params_impl \n  \\<equiv> dflt_parametrization simple_state.more (RETURN \\<lparr> fas = {} \\<rparr>) \\<lparr>\n  on_back_edge := \\<lambda>u v s. RETURN \\<lparr> fas = insert (u,v) (fas s) \\<rparr>\\<rparr>\""], ["", "lemmas fas_params_impl_simp[simp,DFS_code_unfold] = \n  gen_parameterization.simps[mk_record_simp, OF fas_params_impl_def[simplified]]"], ["", "lemma fas_impl: \"(si,s)\\<in>fas_rel \n  \\<Longrightarrow> fas_state_impl.fas si = fas_state.fas s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (si, s) \\<in> fas_rel \\<Longrightarrow>\n    fas_state_impl.fas si = fas_state.fas s", "by (cases si, cases s, simp add: simple_state_rel_def fas_erel_def)"], ["", "interpretation fas_impl: simple_impl_defs G fas_params_impl fas_params \n  for G"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(* The above locale creates an iterative and a recursive implementation *)"], ["", "term fas_impl.tailrec_impl"], ["", "term fas_impl.tailrec_implT"], ["", "term fas_impl.rec_impl"], ["", "definition [DFS_code_unfold]: \"find_fas_impl G \\<equiv> do {\n  ASSERT (graph G);\n  ASSERT (finite ((g_E G)\\<^sup>* `` g_V0 G));\n  s \\<leftarrow> fas_impl.tailrec_implT TYPE('a) G;\n  RETURN (fas s)\n}\""], ["", "context fas begin"], ["", "(* Derive the implementation *)"], ["", "sublocale simple_impl G fas_params fas_params_impl fas_erel"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_impl G fas_params fas_params_impl fas_erel", "apply unfold_locales"], ["proof (prove)\ngoal (8 subgoals):\n 1. (simple_state.more_update, state.more_update)\n    \\<in> (fas_erel \\<rightarrow> fas_erel) \\<rightarrow>\n          fas_rel \\<rightarrow> fas_rel\n 2. on_init fas_params_impl \\<le> \\<Down> fas_erel (on_init fas_params)\n 3. (is_break fas_params_impl, is_break fas_params)\n    \\<in> fas_rel \\<rightarrow> bool_rel\n 4. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>gen_dfs.pre_new_root v0 s; (v0i, v0) \\<in> Id;\n        (si, s) \\<in> fas_rel; (si', s') \\<in> fas_rel;\n        nf_inres (gbs_new_root gbs v0 s) s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root fas_params_impl v0i si'\n                         \\<le> \\<Down> fas_erel\n                                (on_new_root fas_params v0 s')\n 5. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_finish v s0 s; (vi, v) \\<in> Id;\n        (si, s) \\<in> fas_rel; (si', s') \\<in> fas_rel;\n        nf_inres (gbs_finish gbs v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_finish fas_params_impl vi si'\n                         \\<le> \\<Down> fas_erel (on_finish fas_params v s')\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_cross_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> fas_rel; (si', s') \\<in> fas_rel;\n        nf_inres (gbs_cross_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge fas_params_impl ui vi si'\n                         \\<le> \\<Down> fas_erel\n                                (on_cross_edge fas_params u v s')\n 7. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_back_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> fas_rel; (si', s') \\<in> fas_rel;\n        nf_inres (gbs_back_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge fas_params_impl ui vi si'\n                         \\<le> \\<Down> fas_erel\n                                (on_back_edge fas_params u v s')\n 8. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_discover u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> fas_rel; (si', s') \\<in> fas_rel;\n        nf_inres (gbs_discover gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_discover fas_params_impl ui vi si'\n                         \\<le> \\<Down> fas_erel\n                                (on_discover fas_params u v s')", "apply (intro fun_relI, clarsimp simp: simple_state_rel_def, parametricity) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. on_init fas_params_impl \\<le> \\<Down> fas_erel (on_init fas_params)\n 2. (is_break fas_params_impl, is_break fas_params)\n    \\<in> fas_rel \\<rightarrow> bool_rel\n 3. \\<And>v0 s v0i si si' s'.\n       \\<lbrakk>gen_dfs.pre_new_root v0 s; (v0i, v0) \\<in> Id;\n        (si, s) \\<in> fas_rel; (si', s') \\<in> fas_rel;\n        nf_inres (gbs_new_root gbs v0 s) s'\\<rbrakk>\n       \\<Longrightarrow> on_new_root fas_params_impl v0i si'\n                         \\<le> \\<Down> fas_erel\n                                (on_new_root fas_params v0 s')\n 4. \\<And>v s0 s vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_finish v s0 s; (vi, v) \\<in> Id;\n        (si, s) \\<in> fas_rel; (si', s') \\<in> fas_rel;\n        nf_inres (gbs_finish gbs v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_finish fas_params_impl vi si'\n                         \\<le> \\<Down> fas_erel (on_finish fas_params v s')\n 5. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_cross_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> fas_rel; (si', s') \\<in> fas_rel;\n        nf_inres (gbs_cross_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_cross_edge fas_params_impl ui vi si'\n                         \\<le> \\<Down> fas_erel\n                                (on_cross_edge fas_params u v s')\n 6. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_back_edge u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> fas_rel; (si', s') \\<in> fas_rel;\n        nf_inres (gbs_back_edge gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_back_edge fas_params_impl ui vi si'\n                         \\<le> \\<Down> fas_erel\n                                (on_back_edge fas_params u v s')\n 7. \\<And>u v s0 s ui vi si si' s'.\n       \\<lbrakk>gen_dfs.pre_discover u v s0 s; (ui, u) \\<in> Id;\n        (vi, v) \\<in> Id; (si, s) \\<in> fas_rel; (si', s') \\<in> fas_rel;\n        nf_inres (gbs_discover gbs u v s) s'\\<rbrakk>\n       \\<Longrightarrow> on_discover fas_params_impl ui vi si'\n                         \\<le> \\<Down> fas_erel\n                                (on_discover fas_params u v s')", "apply (auto simp: fas_erel_def fas_impl simple_state_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas impl_refine = simple_tailrec_refine simple_tailrecT_refine simple_rec_refine"], ["", "thm simple_refine"], ["", "end"], ["", "lemma find_fas_impl_refine: \"find_fas_impl G \\<le> \\<Down>Id (find_fas G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_fas_impl G \\<le> \\<Down> Id (find_fas G)", "unfolding find_fas_impl_def find_fas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (graph G) \\<bind>\n    (\\<lambda>_.\n        ASSERT (finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n        (\\<lambda>_.\n            tailrec_impl_defs.tailrec_implT G\n             (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) fas_params_impl\n               simple_state.more_update) \\<bind>\n            (\\<lambda>s. RETURN (fas_state_impl.fas s))))\n    \\<le> \\<Down> Id\n           (ASSERT (graph G) \\<bind>\n            (\\<lambda>_.\n                ASSERT (finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n                (\\<lambda>_.\n                    param_DFS_defs.it_dfsT G fas_params \\<bind>\n                    (\\<lambda>s. RETURN (fas_state.fas s)))))", "apply (refine_vcg fas.impl_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); graph G;\n     finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> ??.Feedback_Arcs.fas G\n 2. \\<And>s sa.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G); graph G;\n        finite ((g_E G)\\<^sup>* `` g_V0 G); (s, sa) \\<in> fas_rel\\<rbrakk>\n       \\<Longrightarrow> (fas_state_impl.fas s, fas_state.fas sa) \\<in> Id", "apply (simp_all add: fas_impl fasI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Synthesis of Executable Code\\<close>"], ["", "(* Autoref *)"], ["", "record ('si,'nsi,'fsi)fas_state_impl' = \"('si,'nsi)simple_state_impl\" +\n  fas_impl :: 'fsi"], ["", "definition [to_relAPP]: \"fas_state_erel frel erel \\<equiv> {\n  (\\<lparr>fas_impl = fi, \\<dots> =  mi\\<rparr>,\\<lparr>fas = f, \\<dots> = m\\<rparr>) | fi mi f m.\n    (fi,f)\\<in>frel \\<and> (mi,m)\\<in>erel}\""], ["", "consts \n  i_fas_state_ext :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of fas_state_erel i_fas_state_ext]"], ["", "term fas_update"], ["", "term fas_state_impl'.fas_impl_update"], ["", "lemma [autoref_rules]:\n  fixes ns_rel vis_rel frel erel\n  defines \"R \\<equiv> \\<langle>ns_rel,vis_rel,\\<langle>frel,erel\\<rangle>fas_state_erel\\<rangle>ss_impl_rel\"\n  shows \n    \"(fas_state_impl'_ext, fas_state_impl_ext) \\<in> frel \\<rightarrow> erel \\<rightarrow> \\<langle>frel,erel\\<rangle>fas_state_erel\"\n    \"(fas_impl, fas_state_impl.fas) \\<in> R \\<rightarrow> frel\"\n    \"(fas_state_impl'.fas_impl_update, fas_update) \\<in> (frel \\<rightarrow> frel) \\<rightarrow> R \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fas_state_impl'_ext, fas_state_impl_ext)\n    \\<in> frel \\<rightarrow>\n          erel \\<rightarrow> \\<langle>frel, erel\\<rangle>fas_state_erel &&&\n    (fas_impl, fas_state_impl.fas) \\<in> R \\<rightarrow> frel &&&\n    (fas_impl_update, fas_state_impl.fas_update)\n    \\<in> (frel \\<rightarrow> frel) \\<rightarrow> R \\<rightarrow> R", "unfolding fas_state_erel_def ss_impl_rel_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fas_state_impl'_ext, fas_state_impl_ext)\n    \\<in> frel \\<rightarrow>\n          erel \\<rightarrow>\n          {(\\<lparr>fas_impl = fi, \\<dots> = mi\\<rparr>,\n            \\<lparr>fas_state_impl.fas = f, \\<dots> = m\\<rparr>) |\n           fi mi f m. (fi, f) \\<in> frel \\<and> (mi, m) \\<in> erel} &&&\n    (fas_impl, fas_state_impl.fas)\n    \\<in> {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n               ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si osi visi mi s os vis m.\n           (si, s) \\<in> ns_rel \\<and>\n           (osi, os) \\<in> vis_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>fas_impl = fi, \\<dots> = mi\\<rparr>,\n                   \\<lparr>fas_state_impl.fas = f, \\<dots> = m\\<rparr>) |\n                  fi mi f m.\n                  (fi, f) \\<in> frel \\<and>\n                  (mi, m) \\<in> erel}} \\<rightarrow>\n          frel &&&\n    (fas_impl_update, fas_state_impl.fas_update)\n    \\<in> (frel \\<rightarrow> frel) \\<rightarrow>\n          {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n               ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si osi visi mi s os vis m.\n           (si, s) \\<in> ns_rel \\<and>\n           (osi, os) \\<in> vis_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>fas_impl = fi, \\<dots> = mi\\<rparr>,\n                   \\<lparr>fas_state_impl.fas = f, \\<dots> = m\\<rparr>) |\n                  fi mi f m.\n                  (fi, f) \\<in> frel \\<and>\n                  (mi, m) \\<in> erel}} \\<rightarrow>\n          {(\\<lparr>ss_stack_impl = si, ss_on_stack_impl = osi,\n               ss_visited_impl = visi, \\<dots> = mi\\<rparr>,\n            \\<lparr>ss_stack = s, on_stack = os, visited = vis,\n               \\<dots> = m\\<rparr>) |\n           si osi visi mi s os vis m.\n           (si, s) \\<in> ns_rel \\<and>\n           (osi, os) \\<in> vis_rel \\<and>\n           (visi, vis) \\<in> vis_rel \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>fas_impl = fi, \\<dots> = mi\\<rparr>,\n                   \\<lparr>fas_state_impl.fas = f, \\<dots> = m\\<rparr>) |\n                  fi mi f m. (fi, f) \\<in> frel \\<and> (mi, m) \\<in> erel}}", "by (auto, parametricity)"], ["", "schematic_goal find_fas_impl:\n  fixes V :: \"('vi\\<times>'v) set\"\n  assumes [autoref_ga_rules]: \"is_bounded_hashcode V eq bhc\"\n  assumes [autoref_rules]: \"(eq,(=)) \\<in> V \\<rightarrow> V \\<rightarrow> bool_rel\"\n  assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE ('vi) sz\"\n  assumes [autoref_rules]: \n    \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  notes [autoref_tyrel] = \n    TYRELI[where R=\"\\<langle>V\\<rangle>ahs_rel bhc\"]\n    TYRELI[where R=\"\\<langle>V \\<times>\\<^sub>r V\\<rangle>ahs_rel (prod_bhc bhc bhc)\"]\n    TYRELI[where R=\"\\<langle>V \\<times>\\<^sub>r \\<langle>V\\<rangle>list_set_rel\\<rangle>ras_rel\"]\n  shows \"RETURN (?c::?'c) \\<le>\\<Down>?R (find_fas_impl G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> \\<Down> ?R (find_fas_impl G)", "unfolding DFS_code_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (graph G) \\<bind>\n            (\\<lambda>_.\n                ASSERT (finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n                (\\<lambda>_.\n                    RETURN \\<lparr>fas_state_impl.fas = {}\\<rparr> \\<bind>\n                    (\\<lambda>e.\n                        RETURN\n                         \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                            \\<dots> = e\\<rparr>) \\<bind>\n                    FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n        rwof\n         (RETURN \\<lparr>fas_state_impl.fas = {}\\<rparr> \\<bind>\n          (\\<lambda>e.\n              RETURN\n               \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                  \\<dots> = e\\<rparr>))\n         (gen_dfs_defs.gen_cond\n           (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) fas_params_impl\n             simple_state.more_update)\n           (g_V0 G))\n         (gen_dfs_defs.gen_step\n           (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) fas_params_impl\n             simple_state.more_update)\n           (g_V0 G))\n         s \\<and>\n        (\\<not> False \\<longrightarrow> ss_stack s = []) \\<and>\n        g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                     (g_V0 G) (\\<lambda>x. \\<not> False)\n                     (\\<lambda>v0 s.\n                         let s0 = s\n                         in if v0 \\<in> visited s then RETURN s\n                            else ASSERT (v0 \\<notin> visited s) \\<bind>\n                                 (\\<lambda>_.\n                                     let s = s\n     \\<lparr>ss_stack := [(v0, g_E G `` {v0})]\\<rparr>;\n   s = s\\<lparr>on_stack := {v0}\\<rparr>\n                                     in Let\n   (s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                                 (\\<lambda>s.\n                                     RETURN (simple_state.more s) \\<bind>\n                                     (\\<lambda>e.\n   RETURN (s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n                                 WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n                   rwof\n                    (RETURN \\<lparr>fas_state_impl.fas = {}\\<rparr> \\<bind>\n                     (\\<lambda>e.\n                         RETURN\n                          \\<lparr>ss_stack = [], on_stack = {},\n                             visited = {}, \\<dots> = e\\<rparr>))\n                    (gen_dfs_defs.gen_cond\n                      (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                        fas_params_impl simple_state.more_update)\n                      (g_V0 G))\n                    (gen_dfs_defs.gen_step\n                      (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                        fas_params_impl simple_state.more_update)\n                      (g_V0 G))\n                    s \\<and>\n                   insert v0 {v. v \\<in> visited s0}\n                   \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                                  (\\<lambda>s.\n\\<not> False \\<and> ss_stack s \\<noteq> [])\n                                  (\\<lambda>s.\nASSERT (ss_stack s \\<noteq> []) \\<bind>\n(\\<lambda>_.\n    let (u, Vs) = hd (ss_stack s)\n    in if Vs = {} then RETURN (u, None, s)\n       else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n            (\\<lambda>v.\n                let Vs = Vs - {v};\n                    s = s\\<lparr>ss_stack :=\n                                   (u, Vs) # tl (ss_stack s)\\<rparr>\n                in RETURN (u, Some v, s))) \\<bind>\n(\\<lambda>(u, Vs, s).\n    case Vs of\n    None \\<Rightarrow>\n      ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n      (\\<lambda>_.\n          let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n          in Let (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>)\n              RETURN) \\<bind>\n      (\\<lambda>s.\n          RETURN (simple_state.more s) \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n    | Some v \\<Rightarrow>\n        if v \\<in> visited s\n        then if v \\<in> visited s - on_stack s\n             then RETURN s \\<bind>\n                  (\\<lambda>s.\n                      RETURN (simple_state.more s) \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n             else RETURN s \\<bind>\n                  (\\<lambda>s.\n                      RETURN\n                       \\<lparr>fas_state_impl.fas =\n                                 insert (u, v)\n                                  (fas_state_impl.fas s)\\<rparr> \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n        else ASSERT\n              (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n             (\\<lambda>_.\n                 let s = s\\<lparr>ss_stack :=\n                                    (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                     s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n                 in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n                     RETURN) \\<bind>\n             (\\<lambda>s.\n                 RETURN (simple_state.more s) \\<bind>\n                 (\\<lambda>e.\n                     RETURN\n                      (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n                    (\\<lambda>s. RETURN (fas_state_impl.fas s)))))", "using [[autoref_trace_failed_id, goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (graph G) \\<bind>\n            (\\<lambda>_.\n                ASSERT (finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n                (\\<lambda>_.\n                    RETURN \\<lparr>fas_state_impl.fas = {}\\<rparr> \\<bind>\n                    (\\<lambda>e.\n                        RETURN\n                         \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                            \\<dots> = e\\<rparr>) \\<bind>\n                    FOREACH\\<^sub>C\\<^bsup>\\<lambda>it s.\n        rwof\n         (RETURN \\<lparr>fas_state_impl.fas = {}\\<rparr> \\<bind>\n          (\\<lambda>e.\n              RETURN\n               \\<lparr>ss_stack = [], on_stack = {}, visited = {},\n                  \\<dots> = e\\<rparr>))\n         (gen_dfs_defs.gen_cond\n           (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) fas_params_impl\n             simple_state.more_update)\n           (g_V0 G))\n         (gen_dfs_defs.gen_step\n           (gen_param_dfs_defs.gds (pre_simple_impl.gbs G) fas_params_impl\n             simple_state.more_update)\n           (g_V0 G))\n         s \\<and>\n        (\\<not> False \\<longrightarrow> ss_stack s = []) \\<and>\n        g_V0 G - it \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                     (g_V0 G) (\\<lambda>x. \\<not> False)\n                     (\\<lambda>v0 s.\n                         let s0 = s\n                         in if v0 \\<in> visited s then RETURN s\n                            else ASSERT (v0 \\<notin> visited s) \\<bind>\n                                 (\\<lambda>_.\n                                     let s = s\n     \\<lparr>ss_stack := [(v0, g_E G `` {v0})]\\<rparr>;\n   s = s\\<lparr>on_stack := {v0}\\<rparr>\n                                     in Let\n   (s\\<lparr>visited := insert v0 (visited s)\\<rparr>) RETURN) \\<bind>\n                                 (\\<lambda>s.\n                                     RETURN (simple_state.more s) \\<bind>\n                                     (\\<lambda>e.\n   RETURN (s\\<lparr>simple_state.more := e\\<rparr>))) \\<bind>\n                                 WHILE\\<^sub>T\\<^bsup>\\<lambda>s.\n                   rwof\n                    (RETURN \\<lparr>fas_state_impl.fas = {}\\<rparr> \\<bind>\n                     (\\<lambda>e.\n                         RETURN\n                          \\<lparr>ss_stack = [], on_stack = {},\n                             visited = {}, \\<dots> = e\\<rparr>))\n                    (gen_dfs_defs.gen_cond\n                      (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                        fas_params_impl simple_state.more_update)\n                      (g_V0 G))\n                    (gen_dfs_defs.gen_step\n                      (gen_param_dfs_defs.gds (pre_simple_impl.gbs G)\n                        fas_params_impl simple_state.more_update)\n                      (g_V0 G))\n                    s \\<and>\n                   insert v0 {v. v \\<in> visited s0}\n                   \\<subseteq> {v. v \\<in> visited s}\\<^esup>\n                                  (\\<lambda>s.\n\\<not> False \\<and> ss_stack s \\<noteq> [])\n                                  (\\<lambda>s.\nASSERT (ss_stack s \\<noteq> []) \\<bind>\n(\\<lambda>_.\n    let (u, Vs) = hd (ss_stack s)\n    in if Vs = {} then RETURN (u, None, s)\n       else SPEC (\\<lambda>v. v \\<in> Vs) \\<bind>\n            (\\<lambda>v.\n                let Vs = Vs - {v};\n                    s = s\\<lparr>ss_stack :=\n                                   (u, Vs) # tl (ss_stack s)\\<rparr>\n                in RETURN (u, Some v, s))) \\<bind>\n(\\<lambda>(u, Vs, s).\n    case Vs of\n    None \\<Rightarrow>\n      ASSERT (ss_stack s \\<noteq> [] \\<and> u \\<in> on_stack s) \\<bind>\n      (\\<lambda>_.\n          let s = s\\<lparr>ss_stack := tl (ss_stack s)\\<rparr>\n          in Let (s\\<lparr>on_stack := on_stack s - {u}\\<rparr>)\n              RETURN) \\<bind>\n      (\\<lambda>s.\n          RETURN (simple_state.more s) \\<bind>\n          (\\<lambda>e. RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n    | Some v \\<Rightarrow>\n        if v \\<in> visited s\n        then if v \\<in> visited s - on_stack s\n             then RETURN s \\<bind>\n                  (\\<lambda>s.\n                      RETURN (simple_state.more s) \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n             else RETURN s \\<bind>\n                  (\\<lambda>s.\n                      RETURN\n                       \\<lparr>fas_state_impl.fas =\n                                 insert (u, v)\n                                  (fas_state_impl.fas s)\\<rparr> \\<bind>\n                      (\\<lambda>e.\n                          RETURN (s\\<lparr>simple_state.more := e\\<rparr>)))\n        else ASSERT\n              (v \\<notin> on_stack s \\<and> v \\<notin> visited s) \\<bind>\n             (\\<lambda>_.\n                 let s = s\\<lparr>ss_stack :=\n                                    (v, g_E G `` {v}) # ss_stack s\\<rparr>;\n                     s = s\\<lparr>on_stack := insert v (on_stack s)\\<rparr>\n                 in Let (s\\<lparr>visited := insert v (visited s)\\<rparr>)\n                     RETURN) \\<bind>\n             (\\<lambda>s.\n                 RETURN (simple_state.more s) \\<bind>\n                 (\\<lambda>e.\n                     RETURN\n                      (s\\<lparr>simple_state.more := e\\<rparr>)))))) \\<bind>\n                    (\\<lambda>s. RETURN (fas_state_impl.fas s)))))", "apply (autoref_monadic (trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition find_fas_code for eq bhc sz Gi uses find_fas_impl"], ["", "export_code find_fas_code checking SML"], ["", "thm find_fas_code.refine"], ["", "lemma find_fas_code_refine[refine]:\n  fixes V :: \"('vi\\<times>'v) set\"\n  assumes \"is_bounded_hashcode V eq bhc\"\n  assumes \"(eq,(=)) \\<in> V \\<rightarrow> V \\<rightarrow> bool_rel\"\n  assumes \"is_valid_def_hm_size TYPE ('vi) sz\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  shows \"RETURN (find_fas_code eq bhc sz Gi) \\<le> \\<Down>(\\<langle>V\\<times>\\<^sub>rV\\<rangle>ahs_rel (prod_bhc bhc bhc)) (find_fas G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (find_fas_code eq bhc sz Gi)\n    \\<le> \\<Down>\n           (\\<langle>V \\<times>\\<^sub>r\n                     V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n           (find_fas G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. RETURN (find_fas_code eq bhc sz Gi)\n    \\<le> \\<Down>\n           (\\<langle>V \\<times>\\<^sub>r\n                     V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n           (find_fas G)", "note find_fas_code.refine[OF assms]"], ["proof (state)\nthis:\n  RETURN (find_fas_code eq bhc sz Gi)\n  \\<le> \\<Down>\n         (\\<langle>V \\<times>\\<^sub>r V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n         (find_fas_impl G)\n\ngoal (1 subgoal):\n 1. RETURN (find_fas_code eq bhc sz Gi)\n    \\<le> \\<Down>\n           (\\<langle>V \\<times>\\<^sub>r\n                     V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n           (find_fas G)", "also"], ["proof (state)\nthis:\n  RETURN (find_fas_code eq bhc sz Gi)\n  \\<le> \\<Down>\n         (\\<langle>V \\<times>\\<^sub>r V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n         (find_fas_impl G)\n\ngoal (1 subgoal):\n 1. RETURN (find_fas_code eq bhc sz Gi)\n    \\<le> \\<Down>\n           (\\<langle>V \\<times>\\<^sub>r\n                     V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n           (find_fas G)", "note find_fas_impl_refine"], ["proof (state)\nthis:\n  find_fas_impl ?G \\<le> \\<Down> Id (find_fas ?G)\n\ngoal (1 subgoal):\n 1. RETURN (find_fas_code eq bhc sz Gi)\n    \\<le> \\<Down>\n           (\\<langle>V \\<times>\\<^sub>r\n                     V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n           (find_fas G)", "finally"], ["proof (chain)\npicking this:\n  RETURN (find_fas_code eq bhc sz Gi)\n  \\<le> \\<Down>\n         (\\<langle>V \\<times>\\<^sub>r V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n         (find_fas G)", "show ?thesis"], ["proof (prove)\nusing this:\n  RETURN (find_fas_code eq bhc sz Gi)\n  \\<le> \\<Down>\n         (\\<langle>V \\<times>\\<^sub>r V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n         (find_fas G)\n\ngoal (1 subgoal):\n 1. RETURN (find_fas_code eq bhc sz Gi)\n    \\<le> \\<Down>\n           (\\<langle>V \\<times>\\<^sub>r\n                     V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n           (find_fas G)", "."], ["proof (state)\nthis:\n  RETURN (find_fas_code eq bhc sz Gi)\n  \\<le> \\<Down>\n         (\\<langle>V \\<times>\\<^sub>r V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n         (find_fas G)\n\ngoal:\nNo subgoals!", "qed"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>Declare this algorithm to Autoref:\\<close>"], ["", "theorem find_fas_code_autoref[autoref_rules]:\n  fixes V :: \"('vi\\<times>'v) set\" and bhc\n  defines \"RR \\<equiv> \\<langle>\\<langle>V\\<times>\\<^sub>rV\\<rangle>ahs_rel (prod_bhc bhc bhc)\\<rangle>nres_rel\"\n  assumes BHC: \"SIDE_GEN_ALGO (is_bounded_hashcode V eq bhc)\"\n  assumes EQ: \"GEN_OP eq (=) (V \\<rightarrow> V \\<rightarrow> bool_rel)\"\n  assumes VDS: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE ('vi) sz)\"\n  assumes 2: \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n  shows \"(RETURN (find_fas_code eq bhc sz Gi),\n    (OP find_fas \n      ::: \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> RR)$G)\\<in>RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (find_fas_code eq bhc sz Gi),\n     (OP find_fas :::\n      \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> RR) $\n     G)\n    \\<in> RR", "unfolding RR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (find_fas_code eq bhc sz Gi),\n     (OP find_fas :::\n      \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n      \\<langle>\\<langle>V \\<times>\\<^sub>r\n                        V\\<rangle>ahs_rel\n                                   (prod_bhc bhc bhc)\\<rangle>nres_rel) $\n     G)\n    \\<in> \\<langle>\\<langle>V \\<times>\\<^sub>r\n                            V\\<rangle>ahs_rel\n (prod_bhc bhc bhc)\\<rangle>nres_rel", "apply (rule nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (find_fas_code eq bhc sz Gi)\n    \\<le> \\<Down>\n           (\\<langle>V \\<times>\\<^sub>r\n                     V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n           ((OP find_fas :::\n             \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n             \\<langle>\\<langle>V \\<times>\\<^sub>r\n                               V\\<rangle>ahs_rel\n    (prod_bhc bhc bhc)\\<rangle>nres_rel) $\n            G)", "using assms"], ["proof (prove)\nusing this:\n  RR \\<equiv>\n  \\<langle>\\<langle>V \\<times>\\<^sub>r\n                    V\\<rangle>ahs_rel (prod_bhc bhc bhc)\\<rangle>nres_rel\n  SIDE_GEN_ALGO (is_bounded_hashcode V eq bhc)\n  GEN_OP eq (=) (V \\<rightarrow> V \\<rightarrow> bool_rel)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('vi) sz)\n  (Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\n\ngoal (1 subgoal):\n 1. RETURN (find_fas_code eq bhc sz Gi)\n    \\<le> \\<Down>\n           (\\<langle>V \\<times>\\<^sub>r\n                     V\\<rangle>ahs_rel (prod_bhc bhc bhc))\n           ((OP find_fas :::\n             \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n             \\<langle>\\<langle>V \\<times>\\<^sub>r\n                               V\\<rangle>ahs_rel\n    (prod_bhc bhc bhc)\\<rangle>nres_rel) $\n            G)", "by (simp add: find_fas_code_refine)"], ["", "end"], ["", "subsection \\<open>Feedback Arc Set with Initialization\\<close>"], ["", "text \\<open>This algorithm extends a given set to a feedback arc set. It works in two steps:\n  \\<^enum> Determine set of reachable nodes\n  \\<^enum> Construct feedback arc set for graph without initial set\n\\<close>"], ["", "definition find_fas_init where\n  \"find_fas_init G FI \\<equiv> do {\n    ASSERT (graph G);\n    ASSERT (finite ((g_E G)\\<^sup>* `` g_V0 G));\n    let nodes = (g_E G)\\<^sup>* `` g_V0 G;\n    fas \\<leftarrow> find_fas \\<lparr> g_V = g_V G, g_E = g_E G - FI, g_V0 = nodes \\<rparr>;\n    RETURN (FI \\<union> fas)\n  }\""], ["", "text \\<open>The abstract idea:\n  To find a feedback arc set that contains some set F2,\n  we can find a feedback arc set for the graph with F2 removed,\n  and then join with F2.\n\\<close>"], ["", "lemma is_fas_join: \"is_fas G (F1 \\<union> F2) \\<longleftrightarrow>\n  is_fas \\<lparr> g_V = g_V G, g_E = g_E G - F2, g_V0 = (g_E G)\\<^sup>* `` g_V0 G \\<rparr> F1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fas G (F1 \\<union> F2) =\n    is_fas\n     \\<lparr>g_V = g_V G, g_E = g_E G - F2,\n        g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n     F1", "unfolding is_fas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<exists>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n                (u, u) \\<in> (g_E G - (F1 \\<union> F2))\\<^sup>+)) =\n    (\\<not> (\\<exists>u\\<in>(g_E \\<lparr>g_V = g_V G, g_E = g_E G - F2,\n                                    g_V0 =\n(g_E G)\\<^sup>* `` g_V0 G\\<rparr>)\\<^sup>* ``\n                            g_V0\n                             \\<lparr>g_V = g_V G, g_E = g_E G - F2,\n                                g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>.\n                (u, u)\n                \\<in> (g_E \\<lparr>g_V = g_V G, g_E = g_E G - F2,\n                              g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr> -\n                       F1)\\<^sup>+))", "apply (auto simp: set_diff_diff_left Un_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u x xa.\n       \\<lbrakk>\\<forall>u\\<in>(g_E G)\\<^sup>* `` g_V0 G.\n                   (u, u) \\<notin> (g_E G - (F1 \\<union> F2))\\<^sup>+;\n        (x, u) \\<in> (g_E G - F2)\\<^sup>*; (xa, x) \\<in> (g_E G)\\<^sup>*;\n        xa \\<in> g_V0 G;\n        (u, u) \\<in> (g_E G - (F1 \\<union> F2))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis ImageI rtrancl_trans subsetCE rtrancl_mono[of \"g_E G - F2\" \"g_E G\", OF Diff_subset])"], ["", "lemma graphI_init:\n  assumes \"graph G\"\n  shows \"graph \\<lparr> g_V = g_V G, g_E = g_E G - FI, g_V0 = (g_E G)\\<^sup>* `` g_V0 G \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph\n     \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n        g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. graph\n     \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n        g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>", "interpret graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. graph\n     \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n        g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph\n     \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n        g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. g_V0\n     \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n        g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                       g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n 2. g_E \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n           g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                       g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr> \\<times>\n                g_V \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                       g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>", "using reachable_V"], ["proof (prove)\nusing this:\n  (g_E G)\\<^sup>* `` g_V0 G \\<subseteq> g_V G\n\ngoal (2 subgoals):\n 1. g_V0\n     \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n        g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                       g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n 2. g_E \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n           g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                       g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr> \\<times>\n                g_V \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                       g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. g_E \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n           g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                       g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr> \\<times>\n                g_V \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                       g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>", "using E_ss"], ["proof (prove)\nusing this:\n  g_E G \\<subseteq> g_V G \\<times> g_V G\n\ngoal (1 subgoal):\n 1. g_E \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n           g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                       g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr> \\<times>\n                g_V \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                       g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  graph\n   \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n      g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_fas_init_correct:\n  assumes [simp, intro!]: \"graph G\"\n  assumes [simp, intro!]: \"finite ((g_E G)\\<^sup>* `` g_V0 G)\"\n  shows \"find_fas_init G FI \\<le> SPEC (\\<lambda>fas. is_fas G fas \\<and> FI \\<subseteq> fas)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_fas_init G FI\n    \\<le> SPEC (\\<lambda>fas. is_fas G fas \\<and> FI \\<subseteq> fas)", "unfolding find_fas_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (graph G) \\<bind>\n    (\\<lambda>_.\n        ASSERT (finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n        (\\<lambda>_.\n            let nodes = (g_E G)\\<^sup>* `` g_V0 G\n            in find_fas\n                \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                   g_V0 = nodes\\<rparr> \\<bind>\n               (\\<lambda>fas. RETURN (FI \\<union> fas))))\n    \\<le> SPEC (\\<lambda>fas. is_fas G fas \\<and> FI \\<subseteq> fas)", "apply (refine_vcg order_trans[OF find_fas_correct])"], ["proof (prove)\ngoal (6 subgoals):\n 1. graph G\n 2. graph G \\<Longrightarrow> finite ((g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> graph\n                       \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                          g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n 4. \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G)\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((g_E \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                                g_V0 =\n                                  (g_E G)\\<^sup>* ``\n                                  g_V0 G\\<rparr>)\\<^sup>* ``\n                        g_V0\n                         \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                            g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>)\n 5. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        is_fas\n         \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n            g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n         x\\<rbrakk>\n       \\<Longrightarrow> is_fas G (FI \\<union> x)\n 6. \\<And>x.\n       \\<lbrakk>graph G; finite ((g_E G)\\<^sup>* `` g_V0 G);\n        is_fas\n         \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n            g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n         x\\<rbrakk>\n       \\<Longrightarrow> FI \\<subseteq> FI \\<union> x", "apply clarsimp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. graph\n     \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n        g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n 2. finite ((g_E G - FI)\\<^sup>* `` (g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<And>x.\n       is_fas\n        \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n           g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n        x \\<Longrightarrow>\n       is_fas G (FI \\<union> x)", "apply (rule graphI_init)"], ["proof (prove)\ngoal (3 subgoals):\n 1. graph G\n 2. finite ((g_E G - FI)\\<^sup>* `` (g_E G)\\<^sup>* `` g_V0 G)\n 3. \\<And>x.\n       is_fas\n        \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n           g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n        x \\<Longrightarrow>\n       is_fas G (FI \\<union> x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ((g_E G - FI)\\<^sup>* `` (g_E G)\\<^sup>* `` g_V0 G)\n 2. \\<And>x.\n       is_fas\n        \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n           g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n        x \\<Longrightarrow>\n       is_fas G (FI \\<union> x)", "apply (rule finite_subset[rotated], rule assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (g_E G - FI)\\<^sup>* `` (g_E G)\\<^sup>* `` g_V0 G\n    \\<subseteq> (g_E G)\\<^sup>* `` g_V0 G\n 2. \\<And>x.\n       is_fas\n        \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n           g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n        x \\<Longrightarrow>\n       is_fas G (FI \\<union> x)", "apply (metis Diff_subset Image_closed_trancl reachable_mono \n    rtrancl_image_unfold_right rtrancl_reflcl rtrancl_trancl_reflcl \n    trancl_rtrancl_absorb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       is_fas\n        \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n           g_V0 = (g_E G)\\<^sup>* `` g_V0 G\\<rparr>\n        x \\<Longrightarrow>\n       is_fas G (FI \\<union> x)", "apply (simp add: is_fas_join[where ?F2.0=FI] Un_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_cast_set[autoref_rules_raw]:\n  assumes PRIO_TAG_GEN_ALGO\n  assumes INS: \"GEN_OP ins Set.insert (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs2\\<rightarrow>\\<langle>Rk\\<rangle>Rs2)\"\n  assumes EM: \"GEN_OP emp {} (\\<langle>Rk\\<rangle>Rs2)\"\n  assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 tsl)\"\n  shows \"(\\<lambda>s. gen_union (\\<lambda>x. foldli (tsl x)) ins s emp,CAST) \n    \\<in> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. gen_union (\\<lambda>x. foldli (tsl x)) ins s emp, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>s. gen_union (\\<lambda>x. foldli (tsl x)) ins s emp, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2", "note [autoref_rules] = GEN_OP_D[OF INS]"], ["proof (state)\nthis:\n  (ins, insert)\n  \\<in> Rk \\<rightarrow>\n        \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. gen_union (\\<lambda>x. foldli (tsl x)) ins s emp, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2", "note [autoref_rules] = GEN_OP_D[OF EM]"], ["proof (state)\nthis:\n  (emp, {}) \\<in> \\<langle>Rk\\<rangle>Rs2\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. gen_union (\\<lambda>x. foldli (tsl x)) ins s emp, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2", "note [autoref_ga_rules] = SIDE_GEN_ALGO_D[OF IT]"], ["proof (state)\nthis:\n  is_set_to_list Rk Rs1 tsl\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. gen_union (\\<lambda>x. foldli (tsl x)) ins s emp, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2", "have 1: \"CAST = (\\<lambda>s. s \\<union> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CAST = (\\<lambda>s. s \\<union> {})", "by auto"], ["proof (state)\nthis:\n  CAST = (\\<lambda>s. s \\<union> {})\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. gen_union (\\<lambda>x. foldli (tsl x)) ins s emp, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. gen_union (\\<lambda>x. foldli (tsl x)) ins s emp, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. gen_union (\\<lambda>x. foldli (tsl x)) ins s emp,\n     \\<lambda>s. s \\<union> {})\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2", "by autoref"], ["proof (state)\nthis:\n  (\\<lambda>s. gen_union (\\<lambda>x. foldli (tsl x)) ins s emp, CAST)\n  \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gen_cast_fun_set_rel[autoref_rules_raw]:\n  assumes INS: \"GEN_OP mem (\\<in>) (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs\\<rightarrow>bool_rel)\"\n  shows \"(\\<lambda>s x. mem x s,CAST) \\<in> (\\<langle>Rk\\<rangle>Rs) \\<rightarrow> (\\<langle>Rk\\<rangle>fun_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s x. mem x s, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>Rk\\<rangle>fun_set_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>s x. mem x s, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>Rk\\<rangle>fun_set_rel", "have A: \"\\<And>s. (\\<lambda>x. x\\<in>s,CAST s) \\<in> br Collect (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (\\<lambda>x. x \\<in> s, CAST s) \\<in> br Collect (\\<lambda>_. True)", "by (auto simp: br_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. x \\<in> ?s, CAST ?s) \\<in> br Collect (\\<lambda>_. True)\n\ngoal (1 subgoal):\n 1. (\\<lambda>s x. mem x s, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>Rk\\<rangle>fun_set_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s x. mem x s, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>Rk\\<rangle>fun_set_rel", "unfolding fun_set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s x. mem x s, CAST)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          (Rk \\<rightarrow> bool_rel) O br Collect (\\<lambda>_. True)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (\\<lambda>x. mem x a, CAST a')\n       \\<in> (Rk \\<rightarrow> bool_rel) O br Collect (\\<lambda>_. True)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (\\<lambda>x. mem x a, ?b2 a a') \\<in> Rk \\<rightarrow> bool_rel\n 2. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (?b2 a a', CAST a') \\<in> br Collect (\\<lambda>_. True)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (?b2 a a', CAST a') \\<in> br Collect (\\<lambda>_. True)\n 2. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (\\<lambda>x. mem x a, ?b2 a a') \\<in> Rk \\<rightarrow> bool_rel", "apply (rule A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (\\<lambda>x. mem x a, \\<lambda>x. x \\<in> a')\n       \\<in> Rk \\<rightarrow> bool_rel", "using INS[simplified]"], ["proof (prove)\nusing this:\n  (mem, (\\<in>))\n  \\<in> Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (\\<lambda>x. mem x a, \\<lambda>x. x \\<in> a')\n       \\<in> Rk \\<rightarrow> bool_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>s x. mem x s, CAST)\n  \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>fun_set_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_fas_init_impl_aux_unfolds: \n  \"Let (E\\<^sup>*``V0) = Let (CAST (E\\<^sup>*``V0))\" \n  \"(\\<lambda>S. RETURN (FI \\<union> S)) = (\\<lambda>S. RETURN (FI \\<union> CAST S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let (E\\<^sup>* `` V0) = Let (CAST (E\\<^sup>* `` V0)) &&&\n    (\\<lambda>S. RETURN (FI \\<union> S)) =\n    (\\<lambda>S. RETURN (FI \\<union> CAST S))", "by simp_all"], ["", "schematic_goal find_fas_init_impl:\n  fixes V :: \"('vi\\<times>'v) set\" and bhc\n  assumes [autoref_ga_rules]: \"is_bounded_hashcode V eq bhc\"\n  assumes [autoref_rules]: \"(eq,(=)) \\<in> V \\<rightarrow> V \\<rightarrow> bool_rel\"\n  assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE ('vi) sz\"\n  assumes [autoref_rules]: \n    \"(Gi, G) \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext\"\n    \"(FIi,FI)\\<in>\\<langle>V\\<times>\\<^sub>rV\\<rangle>fun_set_rel\"\n  shows \"RETURN (?c::?'c) \\<le>\\<Down>?R (find_fas_init G FI)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> \\<Down> ?R (find_fas_init G FI)", "unfolding find_fas_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (graph G) \\<bind>\n            (\\<lambda>_.\n                ASSERT (finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n                (\\<lambda>_.\n                    let nodes = (g_E G)\\<^sup>* `` g_V0 G\n                    in find_fas\n                        \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                           g_V0 = nodes\\<rparr> \\<bind>\n                       (\\<lambda>fas. RETURN (FI \\<union> fas)))))", "unfolding find_fas_init_impl_aux_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> \\<Down> ?R\n           (ASSERT (graph G) \\<bind>\n            (\\<lambda>_.\n                ASSERT (finite ((g_E G)\\<^sup>* `` g_V0 G)) \\<bind>\n                (\\<lambda>_.\n                    let nodes = CAST ((g_E G)\\<^sup>* `` g_V0 G)\n                    in find_fas\n                        \\<lparr>g_V = g_V G, g_E = g_E G - FI,\n                           g_V0 = nodes\\<rparr> \\<bind>\n                       (\\<lambda>fas. RETURN (FI \\<union> CAST fas)))))", "by (autoref_monadic (plain,trace))"], ["", "concrete_definition find_fas_init_code for eq bhc sz Gi FIi\n  uses find_fas_init_impl"], ["", "export_code find_fas_init_code checking SML"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>The following theorem declares our implementation to Autoref:\\<close>"], ["", "theorem find_fas_init_code_autoref[autoref_rules]:\n  fixes V :: \"('vi\\<times>'v) set\" and bhc\n  defines \"RR \\<equiv> \\<langle>V\\<times>\\<^sub>rV\\<rangle>fun_set_rel\"\n  assumes \"SIDE_GEN_ALGO (is_bounded_hashcode V eq bhc)\"\n  assumes \"GEN_OP eq (=) (V \\<rightarrow> V \\<rightarrow> bool_rel)\"\n  assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE ('vi) sz)\"\n  shows \"(\\<lambda>Gi FIi. RETURN (find_fas_init_code eq bhc sz Gi FIi),find_fas_init) \n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow> RR \\<rightarrow> \\<langle>RR\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>Gi FIi. RETURN (find_fas_init_code eq bhc sz Gi FIi),\n     find_fas_init)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          RR \\<rightarrow> \\<langle>RR\\<rangle>nres_rel", "unfolding RR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>Gi FIi. RETURN (find_fas_init_code eq bhc sz Gi FIi),\n     find_fas_init)\n    \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext \\<rightarrow>\n          \\<langle>V \\<times>\\<^sub>r V\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>\\<langle>V \\<times>\\<^sub>r\n                            V\\<rangle>fun_set_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext;\n        (aa, a'a)\n        \\<in> \\<langle>V \\<times>\\<^sub>r V\\<rangle>fun_set_rel\\<rbrakk>\n       \\<Longrightarrow> RETURN (find_fas_init_code eq bhc sz a aa)\n                         \\<le> \\<Down>\n                                (\\<langle>V \\<times>\\<^sub>r\n    V\\<rangle>fun_set_rel)\n                                (find_fas_init a' a'a)", "using assms"], ["proof (prove)\nusing this:\n  RR \\<equiv> \\<langle>V \\<times>\\<^sub>r V\\<rangle>fun_set_rel\n  SIDE_GEN_ALGO (is_bounded_hashcode V eq bhc)\n  GEN_OP eq (=) (V \\<rightarrow> V \\<rightarrow> bool_rel)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('vi) sz)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rm, V\\<rangle>g_impl_rel_ext;\n        (aa, a'a)\n        \\<in> \\<langle>V \\<times>\\<^sub>r V\\<rangle>fun_set_rel\\<rbrakk>\n       \\<Longrightarrow> RETURN (find_fas_init_code eq bhc sz a aa)\n                         \\<le> \\<Down>\n                                (\\<langle>V \\<times>\\<^sub>r\n    V\\<rangle>fun_set_rel)\n                                (find_fas_init a' a'a)", "by (simp add: find_fas_init_code.refine)"], ["", "end"], ["", "subsection \\<open>Conclusion\\<close>"], ["", "text \\<open>\n  We have defined an algorithm to find a feedback arc set, and one to \n  extend a given set to a feedback arc set. We have registered them to Autoref\n  as implementations for @{const find_fas} and @{const find_fas_init}.\n\n  For preliminary refinement steps, you need the theorems  \n  @{thm [source] find_fas_correct} and @{thm [source] find_fas_init_correct}.\n\\<close>"], ["", "thm find_fas_code_autoref find_fas_init_code_autoref"], ["", "thm find_fas_correct"], ["", "thm find_fas_init_correct"], ["", "end"]]}